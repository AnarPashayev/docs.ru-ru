---
title: Обзор языка F#
description: Изучите некоторые из ключевых особенностей языке этого учебника с образцами кода F#.
ms.date: 11/06/2018
ms.openlocfilehash: 64394342777003b33dd77028739fb7209b9f3c86
ms.sourcegitcommit: 621a5f6df00152006160987395b93b5b55f7ffcd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/29/2019
ms.locfileid: "66301257"
---
# <a name="tour-of-f"></a>Обзор языка F\#

Лучший способ узнать о языке F# — для чтения и записи кода F#. В этой статье будет выступать в качестве обзор некоторых из ключевых функций языка F# и дают некоторые фрагменты кода, которые могут выполняться на компьютере. Дополнительные сведения о настройке среды разработки, [Приступая к работе](tutorials/getting-started/index.md).

Существуют две основные концепции в F#: функции и типы.  Этот обзор будет подчеркнуть возможности языка, которые можно разделить эти две концепции.

## <a name="executing-the-code-online"></a>Выполнение кода в интерактивном режиме

Если у вас нет F# установлен на вашем компьютере, вы можете выполнять все образцы в браузере с [попробуйте F# на WebAssembly](https://tryfsharp.fsbolero.io/). Fable представляет собой диалект F# , выполняемый непосредственно в браузере. Чтобы просмотреть образцы, выполните в REPL, извлечь **примеры > Дополнительные сведения > Обзор F#**  в строке меню слева Fable среду REPL.

## <a name="functions-and-modules"></a>Функций и модулей

Наиболее основных частей любой программы на F# являются ***функции*** упорядочены ***модули***.  [Функции](language-reference/functions/index.md) выполнения на входные данные для создания выходных значений, и они группируются по [модули](language-reference/modules.md), которые являются основным способом сгруппировать объекты в F#.  Они определяются с помощью [ `let` привязки](language-reference/functions/let-bindings.md), который присвойте функции имя и определять ее аргументы.

[!code-fsharp[BasicFunctions](../../samples/snippets/fsharp/tour.fs#L101-L133)]

`let` привязки, также, как привязать значение к имени, аналогичную переменной на других языках.  `let` привязки-это ***неизменяемый*** по умолчанию, что означает, что после привязки значения или функции с именем, его нельзя изменить на месте.  В отличие от переменных в других языках, которые являются ***изменяемый***, то есть их значения можно изменить в любой момент времени.  Если вам требуется изменяемой привязке, можно использовать `let mutable ...` синтаксис.

[!code-fsharp[Immutability](../../samples/snippets/fsharp/tour.fs#L75-L94)]

## <a name="numbers-booleans-and-strings"></a>Числа, логические значения и строки

Как на языке .NET, F# поддерживает тот же базовый [типов-примитивов](language-reference/primitive-types.md) , существующие в .NET.

Вот, как различные числовые типы представлены в F#:

[!code-fsharp[Numbers](../../samples/snippets/fsharp/tour.fs#L49-L68)]

Вот какие логические значения и выполнения основных условной логики выглядит следующим образом:

[!code-fsharp[Bools](../../samples/snippets/fsharp/tour.fs#L142-L152)]

А вот какие basic [строка](language-reference/strings.md) манипуляции выглядит как:

[!code-fsharp[Strings](../../samples/snippets/fsharp/tour.fs#L158-L180)]

## <a name="tuples"></a>Кортежи

[Кортежи](language-reference/tuples.md) являются особенного в F#.  Они являются группирования неименованных, но упорядоченных значений, которые могут рассматриваться как сами значения.  Рассматривайте их как значения, который агрегируется из других значений.  Они имеют множество применений, например удобно возврат из функции несколько значений или значений для удобства некоторые ad-hoc группирования.

[!code-fsharp[Tuples](../../samples/snippets/fsharp/tour.fs#L186-L203)]

По состоянию на F# 4.1, можно также создать `struct` кортежей.  Они также настроить взаимодействие полностью с кортежами C# 7/Visual Basic 15, что также `struct` кортежей:

[!code-fsharp[Tuples](../../samples/snippets/fsharp/tour.fs#L205-L218)]

Важно отметить, что поскольку `struct` кортежи представляют собой типы значений, для ссылки на кортежи, они не может быть неявно преобразован или наоборот.  Необходимо явным образом преобразовать между кортеж ссылок и структуры.

## <a name="pipelines-and-composition"></a>Конвейеры и композиции

Передать операторы, такие как `|>` широко используются при обработке данных в языке F#. Эти операторы являются функциями, которые позволяют установить «конвейеры» функций разными способами. Следующий пример поможет выполнить как можно воспользоваться преимуществами этих операторов для создания простой работы конвейера:

[!code-fsharp[Pipelines](../../samples/snippets/fsharp/tour.fs#L227-L282)]

Приведенный выше образец внесенные использовать многие функции F#, включая список функций по обработке, функций первого класса и [частичное применение](language-reference/functions/index.md#partial-application-of-arguments). Несмотря на то, что глубокого понимания каждого из этих концепций могут стать несколько advanced, должно быть ясно, как легко функции могут использоваться для обработки данных, при создании конвейеров.

## <a name="lists-arrays-and-sequences"></a>Списки, массивы и последовательности

Списки, массивы и последовательности являются три типа основной коллекции из основной библиотеки F#.

[Перечисляет](language-reference/lists.md) — это упорядоченная, неизменная коллекции элементов того же типа.  Они являются однонаправленных списков, что означает, что они предназначены для перечисления, но плохим выбором для произвольного доступа и объединения, если они большие.  Это отличие от списков в других популярных языках, которые обычно не используют однонаправленного связного списка для представления списков.

[!code-fsharp[Lists](../../samples/snippets/fsharp/tour.fs#L309-L359)]

[Массивы](language-reference/arrays.md) являются фиксированного размера, *изменяемый* коллекции элементов того же типа.  Они поддерживают быстрый произвольный доступ элементов и выполняются быстрее, чем F# список, так как они просто смежные блоки памяти.

[!code-fsharp[Arrays](../../samples/snippets/fsharp/tour.fs#L368-L407)]

[Последовательности](language-reference/sequences.md) — это логический ряд элементов одного типа.  Это более общий тип чем списки и массивы, может быть «представления» в любой логический ряд элементов.  Они также используются, так как они могут быть ***отложенной***, что означает, что элементы, можно вычислить только в том случае, когда они нужны.

[!code-fsharp[Sequences](../../samples/snippets/fsharp/tour.fs#L418-L452)]

## <a name="recursive-functions"></a>Рекурсивные функции

Обработка коллекций или последовательности элементов обычно делается с помощью [рекурсии](language-reference/functions/index.md#recursive-functions) в F#.  Несмотря на то, что F# имеет поддержку циклы и императивное программирование, рекурсии является предпочтительным, так как его проще обеспечить правильность.

> [!NOTE]
> Следующий пример использует сопоставление шаблонов с помощью `match` выражение.  Этой фундаментальной конструкцией рассматривается далее в этой статье.

[!code-fsharp[RecursiveFunctions](../../samples/snippets/fsharp/tour.fs#L461-L500)]

F# также обеспечивает полную поддержку оптимизацию вызова с префиксом Tail, это способ оптимизации рекурсивных вызовов, чтобы они были просто так же быстро, как конструкция цикла.

## <a name="record-and-discriminated-union-types"></a>Запись и типы размеченного объединения

Типы объединений и записи являются два основных типа данных используется в коде F# и чаще всего это лучший способ представления данных в программе F#.  Несмотря на то, что это делает их подобные классам в других языках, один из их основных различий является наличие семантикой структурного равенства.  Это означает, что они «изначально» сравнимы и равенства несложно — просто проверить, если он равен другому.

[Записи](language-reference/records.md) являются статистическое вычисление именованных значений, с помощью необязательных элементов (например, методы).  Если вы знакомы с C# или Java, затем они должно казаться похожими POCO или элементов Pojo - только с структурного равенства и менее формального.

[!code-fsharp[Records](../../samples/snippets/fsharp/tour.fs#L507-L559)]

По состоянию на F# 4.1, может также представлять записи в виде `struct`s.  Это делается с помощью `[<Struct>]` атрибут:

[!code-fsharp[Records](../../samples/snippets/fsharp/tour.fs#L561-L568)]

[Размеченные объединения (DUs)](language-reference/discriminated-unions.md) — это значения, которые могут быть ряд именованных форм или случаев.  Данные, хранящиеся в типе может принимать несколько различных значений.

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L575-L631)]

Можно также использовать DUs как *одиночным размеченные объединения*, чтобы помочь с доменом, моделирование по типов-примитивов.  Зачастую, строк и других типов-примитивов, используются для представления и таким образом, предоставить определенного значения.  Тем не менее с помощью простых представлением данных может привести к ошибочно назначение неправильное значение!  Представляет каждый тип данных, как объединение отдельных одиночным можно принудительно задать правильность в этом сценарии.

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L633-L654)]

Как показано в приведенном выше примере, чтобы получить базовое значение в одиночным размеченного объединения, вы должны явно распаковки.

Кроме того DUs также поддерживают рекурсивные определения, что позволяет легко представления дерева и по своей природе рекурсивные данные.  Например, вот как может представлять двоичное дерево поиска с `exists` и `insert` функции.

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L656-L683)]

Поскольку DUs можно представить рекурсивную структуру дерева в тип данных, на этом рекурсивную структуру прост и гарантирует правильность.  Также поддерживается при сопоставлении шаблонов, как показано ниже.

Кроме того, вы можете представить DUs как `struct`s с `[<Struct>]` атрибут:

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L685-L696)]

Тем не менее существует два важных момента при этом следует учитывать:

1. Структура DU не может быть определен рекурсивно.
2. Структура DU должны иметь уникальные имена для каждого из его вариантов.

Несоблюдение выше приведет к ошибке компиляции.

## <a name="pattern-matching"></a>Сопоставление шаблонов

[Шаблон сопоставления](language-reference/pattern-matching.md) -функция F#, которая позволяет правильностью для работающие с типами F#.  В примерах выше вы, наверное, заметили совсем немного `match x with ...` синтаксис.  Эта конструкция позволяет компилятору, который можно определить «форму» типы данных, для принудительного для учетной записи для всех возможных вариантов, при использовании типа данных через то, что известно как полное сопоставление шаблонов.  Это невероятно мощное правильность и искусно позволяют «извлекаете», что обычно является проблемой среды выполнения в во время компиляции.

[!code-fsharp[PatternMatching](../../samples/snippets/fsharp/tour.fs#L705-L742)]

Вы заметите, что-то заключается в использовании `_` шаблон.  Этот процесс называется [Шаблон подстановочного знака](language-reference/pattern-matching.md#wildcard-pattern), который является способом выполнения «Меня не волнует, что что-то такое».  Несмотря на то что удобна, можно случайно обойти полное сопоставление шаблонов и больше не воспользоваться преимуществами принудительные применения во время компиляции, если не соблюдать осторожность при использовании `_`.  Лучше всего использовать, если вас не интересуют некоторые фрагменты разложенные типа при шаблон соответствия или последнего предложения, когда перечислили все значимые варианты в выражении шаблона.

[Активные шаблоны](language-reference/active-patterns.md) являются другой мощные конструкции для использования с сопоставлением шаблонов.  Они позволяют секционировать входные данные в пользовательских форм, их разбивки на сайте вызова соответствия шаблону.  Они могут также быть параметризованы, таким образом для определения секции в качестве функции.  Развертывание в предыдущем примере, для поддержки активные шаблоны выглядит примерно следующим образом:

[!code-fsharp[ActivePatterns](../../samples/snippets/fsharp/tour.fs#L764-L786)]

## <a name="optional-types"></a>Дополнительные типы

Один особый случай размеченного объединения типов — это тип параметра, это так удобно, что он является частью основной библиотеки F#.

[Тип параметра](language-reference/options.md) — это тип, который представляет один из двух случаев: значение, либо значение nothing вообще.  Он используется в любом сценарии, где значение может или не из конкретной операции.  Затем, поэтому приходится учетной записи в обоих случаях станет проблемой во время компиляции, а не значения среды выполнения.  Они часто используются в API-интерфейсах где `null` используется для представления «nothing», вместо этого, тем самым исключая необходимость беспокоиться о `NullReferenceException` во многих случаях.

[!code-fsharp[Options](../../samples/snippets/fsharp/tour.fs#L789-L814)]

## <a name="units-of-measure"></a>Единицы измерения

Одной из уникальных особенностей системы типов F# является возможность предоставления контекста для числовых литералов через единицы измерения.

[Единицы измерения](language-reference/units-of-measure.md) позволяют связывать числового типа к единице измерения, такие как счетчики, и у функции работы с единицы, а не числовые литералы.  Это позволяет компилятору проверять, что типы числовых литералов, передаваемых в смысл при определенном контексте, устраняя ошибки времени выполнения, связанного с такой работы.

[!code-fsharp[UnitsOfMeasure](../../samples/snippets/fsharp/tour.fs#L817-L842)]

Библиотеки ядра F# определяет многие типы единиц SI и преобразования единиц измерения.  Чтобы узнать больше, ознакомьтесь с [Microsoft.FSharp.Data.unitsystems.SI-пространство имен](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d).

## <a name="classes-and-interfaces"></a>Классы и интерфейсы

F# также имеет полную поддержку для классов .NET, [интерфейсы](language-reference/interfaces.md), [абстрактные классы](language-reference/abstract-classes.md), [наследования](language-reference/inheritance.md), и т. д.

[Классы](language-reference/classes.md) представляют объекты .NET, который может иметь свойства, методы и события, что его [члены](language-reference/members/index.md).

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L845-L880)]

Определение универсальных классов также очень проста.

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L883-L908)]

Чтобы реализовать интерфейс, можно использовать либо `interface ... with` синтаксис или [выражение объекта](language-reference/object-expressions.md).

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L911-L934)]

## <a name="which-types-to-use"></a>Типы, которые требуется использовать

Наличие классы, записи, размеченные объединения и кортежи приводит к важный вопрос: что следует использовать?  Как и почти все в жизни ответ зависит от обстоятельств.

Кортежи отлично подходят для возврата нескольких значений из функции и статистическое вычисление ad-hoc значения в качестве значение сам.

Записи являются «шаг вверх» из кортежей, с именем метки и поддержка необязательных элементов.  Они отлично подходят для неофициальное представление данных во время передачи по программе.  Из-за наличия структурного равенства, они легко использовать с сравнения.

Размеченные объединения имеют множество применений, но преимущество core заключается в том, чтобы иметь возможность использовать их вместе с сопоставлением шаблонов, чтобы учесть все возможные «фигуры», которые могут иметь данных.  

Классы отлично подходят для множество причин, например для представления информации и также привязать эту информацию к функциональным возможностям.  Как правило при наличии функциональные возможности, которые концептуально привязывается к некоторым данным с помощью классов и принципы объектно-ориентированное программирование является большим преимуществом.  Классы также представлены предпочтительный тип данных при взаимодействии с C# и Visual Basic, как эти языки используют классы для практически полностью.

## <a name="next-steps"></a>Следующие шаги

Теперь, когда вы увидели некоторые из основных функций языка, можно приступать к записи вашей первой программы на F#!  Ознакомьтесь с [Приступая к работе](tutorials/getting-started/index.md) чтобы узнать, как настроить среду разработки и написать код.

Следующие шаги для получения дополнительных сведений может быть любым, но мы рекомендуем [введение в функциональное программирование в F# ](introduction-to-functional-programming/index.md) успешной работы с основными механизмами функциональное программирование.  Это будут важное значение для построения надежных программ на языке F#.

Кроме того, ознакомьтесь с [Справочник по языку F#](language-reference/index.md) чтобы увидеть полный набор концептуальное содержимое на F#.
