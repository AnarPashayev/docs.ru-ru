---
title: Обзор языка F#
description: Изучите некоторые из ключевых особенностей языке этого учебника с образцами кода F#.
ms.date: 02/09/2020
ms.openlocfilehash: ac2eef40e2dbc494e41a9760f0a70edb0f7ce399
ms.sourcegitcommit: 011314e0c8eb4cf4a11d92078f58176c8c3efd2d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/11/2020
ms.locfileid: "77124576"
---
# <a name="tour-of-f"></a>Обзор F\#

Лучший способ узнать о языке F# — для чтения и записи кода F#. В этой статье будет выступать в качестве обзор некоторых из ключевых функций языка F# и дают некоторые фрагменты кода, которые могут выполняться на компьютере. Чтобы узнать о настройке среды разработки, ознакомьтесь с [Начало работы](get-started/index.md).

Существуют две основные концепции в F#: функции и типы.  В этом обзоре рассматриваются функции языка, которые делятся на эти две концепции.

## <a name="executing-the-code-online"></a>Исполнение кода в сети

Если на компьютере не F# установлен, можно выполнить все примеры в браузере с помощью [ F# Try для сборки](https://tryfsharp.fsbolero.io/). Фабле — это диалект F# , который выполняется непосредственно в браузере. Чтобы просмотреть примеры, приведенные в статье REPL, ознакомьтесь с **примерами, > узнать > F# обзор** в левой строке меню фабле repl.

## <a name="functions-and-modules"></a>Функции и модули

Наиболее фундаментальными частями любой F# программы являются ***функции*** , организованные в ***модули***.  [Функции](./language-reference/functions/index.md) выполняют работу с входными данными для получения выходных данных, и они упорядочены по [модулям](./language-reference/modules.md), которые являются основным способом группирования объектов F#.  Они определяются с помощью [привязки`let`](./language-reference/functions/let-bindings.md), которая придает функции имя и определяет ее аргументы.

[!code-fsharp[BasicFunctions](~/samples/snippets/fsharp/tour.fs#L101-L133)]

привязки `let` также позволяют привязать значение к имени, аналогично переменной на других языках.  `let` привязки являются ***неизменяемыми*** по умолчанию. Это означает, что после привязки значения или функции к имени ее нельзя изменить на месте.  Это отличается от переменных в других языках, которые являются ***изменяемыми***, то есть их значения могут быть изменены в любой момент времени.  Если требуется изменяемая привязка, можно использовать синтаксис `let mutable ...`.

[!code-fsharp[Immutability](~/samples/snippets/fsharp/tour.fs#L75-L94)]

## <a name="numbers-booleans-and-strings"></a>Числа, логические значения и строки

Как язык .NET, F# поддерживает те же базовые [примитивные типы](language-reference/basic-types.md) , которые существуют в .NET.

Вот, как различные числовые типы представлены в F#:

[!code-fsharp[Numbers](~/samples/snippets/fsharp/tour.fs#L49-L68)]

Ниже приведены логические значения и выполнение базовой условной логики.

[!code-fsharp[Bools](~/samples/snippets/fsharp/tour.fs#L142-L152)]

И вот как выглядит базовая обработка [строк](./language-reference/strings.md) :

[!code-fsharp[Strings](~/samples/snippets/fsharp/tour.fs#L158-L180)]

## <a name="tuples"></a>Кортежи

[Кортежи](./language-reference/tuples.md) очень велики F#.  Они представляют собой группирование неименованных, но упорядоченных значений, которые можно рассматривать как сами значения.  Их следует рассматривать как значения, агрегированные из других значений.  Они имеют множество применений, например, удобный возврат нескольких значений из функции или группирование значений для некоторого нерегламентированного удобства.

[!code-fsharp[Tuples](~/samples/snippets/fsharp/tour.fs#L186-L203)]

Можно также создавать `struct` кортежи.  Они также полностью взаимодействуют с кортежами C# 7/Visual Basic 15, которые также `struct` кортежи:

[!code-fsharp[Tuples](~/samples/snippets/fsharp/tour.fs#L205-L218)]

Важно отметить, что поскольку `struct` кортежи являются типами значений, они не могут быть неявно преобразованы в ссылочные кортежи или наоборот.  Необходимо явно выполнить преобразование между ссылкой и кортежем структуры.

## <a name="pipelines-and-composition"></a>Конвейеры и компоновка

Операторы конвейера, такие как `|>`, широко используются при обработке данных F#в. Эти операторы — это функции, позволяющие гибко устанавливать "конвейеры" функций. В следующем примере показано, как можно воспользоваться преимуществами этих операторов для создания простого функционального конвейера:

[!code-fsharp[Pipelines](~/samples/snippets/fsharp/tour.fs#L227-L282)]

В предыдущем примере использовались многие функции F#, включая функции обработки списков, функции первого класса и [частичное применение](./language-reference/functions/index.md#partial-application-of-arguments). Хотя глубокое понимание каждого из этих концепций может стать довольно сложным, должно быть ясно, насколько легко можно использовать функции для обработки данных при создании конвейеров.

## <a name="lists-arrays-and-sequences"></a>Списки, массивы и последовательности

Списки, массивы и последовательности являются три типа основной коллекции из основной библиотеки F#.

[Списки](./language-reference/lists.md) являются упорядоченными, неизменяемыми коллекциями элементов одного типа.  Они представляют собой однонаправленные списки, что означает, что они предназначены для перечисления, но плохо подходит для произвольного доступа и объединения, если они велики.  Это в отличие от списков в других популярных языках, которые обычно не используют однонаправленный список для представления списков.

[!code-fsharp[Lists](~/samples/snippets/fsharp/tour.fs#L309-L359)]

[Массивы](./language-reference/arrays.md) имеют фиксированный размер, *Изменяемые* коллекции элементов одного типа.  Они поддерживают быстрый произвольный доступ элементов и выполняются быстрее, чем F# список, так как они просто смежные блоки памяти.

[!code-fsharp[Arrays](~/samples/snippets/fsharp/tour.fs#L368-L407)]

[Последовательности](./language-reference/sequences.md) являются логическими последовательностями элементов одного типа.  Это более общий тип, чем списки и массивы, способные «просматривать» любые логические последовательности элементов.  Они также выделены, так как могут быть ***отложенными***, то есть элементы могут быть вычислены только при необходимости.

[!code-fsharp[Sequences](~/samples/snippets/fsharp/tour.fs#L418-L452)]

## <a name="recursive-functions"></a>Рекурсивные функции

Обработка коллекций или последовательностей элементов обычно выполняется с помощью [рекурсии](./language-reference/functions/index.md#recursive-functions) в F#.  Несмотря на то, что F# имеет поддержку циклы и императивное программирование, рекурсии является предпочтительным, так как его проще обеспечить правильность.

> [!NOTE]
> В следующем примере используется сопоставление шаблонов с помощью выражения `match`.  Эта фундаментальная конструкция рассматривается далее в этой статье.

[!code-fsharp[RecursiveFunctions](~/samples/snippets/fsharp/tour.fs#L461-L500)]

F# также обеспечивает полную поддержку оптимизацию вызова с префиксом Tail, это способ оптимизации рекурсивных вызовов, чтобы они были просто так же быстро, как конструкция цикла.

## <a name="record-and-discriminated-union-types"></a>Типы записей и размеченных объединений

Типы объединений и записи являются два основных типа данных используется в коде F# и чаще всего это лучший способ представления данных в программе F#.  Хотя это делает их похожими на классы на других языках, одно из их основных отличий состоит в том, что они имеют семантику структурного равенства.  Это означает, что они являются сравнимыми по себе, и равенство достаточно просто проверить, равно ли один другой.

[Записи](./language-reference/records.md) представляют собой совокупность именованных значений с необязательными элементами (например, методами).  Если вы знакомы с C# языком или Java, они должны быть ПОХОЖИ на POCO или POJO-только структурное равенство и менее формальностей.

[!code-fsharp[Records](~/samples/snippets/fsharp/tour.fs#L507-L559)]

Также можно представить записи как структуры. Это делается с помощью атрибута `[<Struct>]`:

[!code-fsharp[Records](~/samples/snippets/fsharp/tour.fs#L561-L568)]

[Размеченные объединения (ветвью)](./language-reference/discriminated-unions.md) — это значения, которые могут быть числом именованных форм или вариантов.  Данные, хранящиеся в типе, могут быть одного из нескольких различных значений.

[!code-fsharp[Unions](~/samples/snippets/fsharp/tour.fs#L575-L631)]

Вы также можете использовать ветвью в качестве *размеченных объединений с одним вариантом*, чтобы упростить моделирование доменов по примитивным типам.  Часто строки и другие примитивные типы используются для представления чего-либо, поэтому они задаются определенным значением.  Однако использование только примитивного представления данных может привести к ошибочному назначению неверного значения!  Представление каждого типа данных в виде отдельного однострочного объединения может обеспечить правильность в этом сценарии.

[!code-fsharp[Unions](~/samples/snippets/fsharp/tour.fs#L633-L654)]

Как показано в приведенном выше примере, чтобы получить базовое значение в размеченного Union с одним вариантом, необходимо явно разворачивать его.

Кроме того, ветвью также поддерживает рекурсивные определения, что позволяет легко представлять деревья и по сути рекурсивные данные.  Например, вот как можно представить двоичное дерево поиска с помощью функций `exists` и `insert`.

[!code-fsharp[Unions](~/samples/snippets/fsharp/tour.fs#L656-L683)]

Поскольку ветвью позволяет представить рекурсивную структуру дерева в типе данных, работа над этой рекурсивной структурой проста и гарантирует правильность.  Он также поддерживается в сопоставлении шаблонов, как показано ниже.

Кроме того, можно представить ветвью как `struct`s с `[<Struct>]`ным атрибутом:

[!code-fsharp[Unions](~/samples/snippets/fsharp/tour.fs#L685-L696)]

Однако при этом следует учитывать два важных момента:

1. Невозможно рекурсивно определить структуру DU.
2. Структура DU должна иметь уникальные имена для каждого из своих вариантов.

Несоблюдение приведенных выше действий приведет к ошибке компиляции.

## <a name="pattern-matching"></a>Сопоставление шаблонов

[Сопоставление шаблонов](./language-reference/pattern-matching.md) — это F# функция языка, которая обеспечивает правильность работы с F# типами.  В приведенных выше примерах вы, вероятно, заметили довольно много `match x with ...` синтаксис.  Эта конструкция позволяет компилятору, который может понять «форму» типов данных, принудительно учитывать все возможные варианты использования типа данных с помощью того, что известно как исчерпывающее сопоставление шаблонов.  Это чрезвычайно мощный вариант для корректности, и его можно использовать для "точности" того, что обычно является проблемой времени выполнения во время компиляции.

[!code-fsharp[PatternMatching](~/samples/snippets/fsharp/tour.fs#L705-L742)]

Что вы могли заметить, это использование шаблона `_`.  Это называется [шаблоном с подстановочными знаками](./language-reference/pattern-matching.md#wildcard-pattern), который позволяет сказать: «я не волнует что-то, что происходит».  Хотя это удобно, вы можете случайно обойти исчерпывающее сопоставление шаблонов и больше не использовать преимущества, если вы не следите за использованием `_`.  Он лучше всего подходит, если вы не следите за определенными фрагментами составного типа при сопоставлении шаблонов или итоговым предложением при перечислении всех осмысленных вариантов в выражении сопоставления шаблонов.

В следующем примере `_` вариант используется при сбое операции анализа.

[!code-fsharp[PatternMatching](~/samples/snippets/fsharp/tour.fs#L744-L762)]

[Активные шаблоны](./language-reference/active-patterns.md) — это еще одна мощная конструкция, используемая с сопоставлением шаблонов.  Они позволяют секционировать входные данные в пользовательские формы, разбивая их на сайте вызова соответствия шаблону.  Они также могут быть параметризованы, тем самым позволяя определять секцию как функцию.  Расширение предыдущего примера для поддержки активных шаблонов выглядит примерно так:

[!code-fsharp[ActivePatterns](~/samples/snippets/fsharp/tour.fs#L764-L786)]

## <a name="optional-types"></a>Необязательные типы

Один особый случай размеченного объединения типов — это тип параметра, это так удобно, что он является частью основной библиотеки F#.

[Тип параметра](./language-reference/options.md) — это тип, представляющий один из двух вариантов: значение или ничего вообще.  Он используется в любом сценарии, где значение может быть или не получено из определенной операции.  Тогда вы назначите вам учитывать оба варианта, сделав его проблемой во время компиляции, а не заботу среды выполнения.  Они часто используются в интерфейсах API, где `null` используется для представления «Nothing», что устраняет необходимость в `NullReferenceException` во многих обстоятельствах.

[!code-fsharp[Options](~/samples/snippets/fsharp/tour.fs#L789-L814)]

## <a name="units-of-measure"></a>Единицы измерения

Одной из уникальных особенностей системы типов F# является возможность предоставления контекста для числовых литералов через единицы измерения.

[Единицы измерения](./language-reference/units-of-measure.md) позволяют связать числовой тип с единицей, например в метрах, а функции выполняют работу с единицами, а не с числовыми литералами.  Это позволяет компилятору проверять, что типы числовых литералов имеют смысл в определенном контексте, тем самым устраняя ошибки времени выполнения, связанные с этим типом работы.

[!code-fsharp[UnitsOfMeasure](~/samples/snippets/fsharp/tour.fs#L817-L842)]

Библиотеки ядра F# определяет многие типы единиц SI и преобразования единиц измерения.  Чтобы узнать больше, ознакомьтесь с [пространством имен Microsoft.FSharp.Data.UnitSystems.Si](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d).

## <a name="classes-and-interfaces"></a>Классы и интерфейсы

F#также обладает полной поддержкой классов .NET, [интерфейсов](./language-reference/interfaces.md), [абстрактных классов](./language-reference/abstract-classes.md), [наследования](./language-reference/inheritance.md)и т. д.

[Классы](./language-reference/classes.md) — это типы, представляющие объекты .NET, которые могут иметь свойства, методы и события в качестве [членов](./language-reference/members/index.md).

[!code-fsharp[Classes](~/samples/snippets/fsharp/tour.fs#L845-L880)]

Определение универсальных классов также очень просто.

[!code-fsharp[Classes](~/samples/snippets/fsharp/tour.fs#L883-L908)]

Для реализации интерфейса можно использовать либо синтаксис `interface ... with`, либо [выражение объекта](./language-reference/object-expressions.md).

[!code-fsharp[Classes](~/samples/snippets/fsharp/tour.fs#L911-L934)]

## <a name="which-types-to-use"></a>Какие типы использовать

Наличие классов, записей, размеченных объединений и кортежей приводит к важному вопросу: что следует использовать?  Как и многие все это в жизни, ответ зависит от обстоятельств.

Кортежи отлично подходят для возвращения нескольких значений из функции и использования специального статистического выражения значений в качестве самого значения.

Записи — это «шаг с заходом» из кортежей, имеющих именованные метки и поддержку необязательных элементов.  Они отлично подходят для формальностей представления данных во время передачи по программе.  Так как они имеют структурное равенство, их легко использовать при сравнении.

Размеченные объединения имеют много использования, но основное преимущество заключается в том, чтобы их можно было использовать в сочетании с сопоставлением шаблонов для учета всех возможных "фигур", которые могут иметь данные.  

Классы отлично подходят для огромного числа причин, например, когда необходимо представить информацию, а также привязать эту информацию к функциональным возможностям.  Как правило, при наличии функциональности, которая концептуально привязана к некоторым данным, использование классов и принципов объектно-ориентированного программирования является большим преимуществом.  Классы также являются предпочтительным типом данных при взаимодействии с C# и Visual Basic, так как эти языки используют классы практически для всех.

## <a name="next-steps"></a>Next Steps

Теперь, когда вы увидели некоторые из основных функций языка, можно приступать к записи вашей первой программы на F#!  Ознакомьтесь [Начало работы](get-started/index.md) , чтобы узнать, как настроить среду разработки и написать код.

Дальнейшие действия для изучения могут быть любыми, но мы рекомендуем ознакомиться с [функциональным программированием в F# ](./introduction-to-functional-programming/index.md) , чтобы приступить к работе с основными понятиями функционального программирования.  Это будут важное значение для построения надежных программ на языке F#.

Кроме того, ознакомьтесь с [ F# справочником по языку](./language-reference/index.md) , чтобы просмотреть исчерпывающую коллекцию F#концептуальных материалов по.
