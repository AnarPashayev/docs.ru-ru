---
title: Обзор языка F#
description: Изучите некоторые из ключевых особенностей языке этого учебника с образцами кода F#.
ms.date: 11/06/2018
ms.openlocfilehash: eba136da3cd829dcb2b0726dd4f1c24434aeba5b
ms.sourcegitcommit: 55f438d4d00a34b9aca9eedaac3f85590bb11565
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/23/2019
ms.locfileid: "71182611"
---
# <a name="tour-of-f"></a>Обзор F\#

Лучший способ узнать о языке F# — для чтения и записи кода F#. В этой статье будет выступать в качестве обзор некоторых из ключевых функций языка F# и дают некоторые фрагменты кода, которые могут выполняться на компьютере. Чтобы узнать о настройке среды разработки, ознакомьтесь с [Начало работы](./tutorials/getting-started/index.md).

Существуют две основные концепции в F#: функции и типы.  В этом обзоре рассматриваются функции языка, которые делятся на эти две концепции.

## <a name="executing-the-code-online"></a>Исполнение кода в сети

Если на компьютере не F# установлен, можно выполнить все примеры в браузере с помощью [ F# Try для сборки](https://tryfsharp.fsbolero.io/). Фабле — это диалект F# , который выполняется непосредственно в браузере. Чтобы просмотреть примеры, приведенные в статье REPL, ознакомьтесь с **примерами, > узнать > F# обзор** в левой строке меню фабле repl.

## <a name="functions-and-modules"></a>Функции и модули

Наиболее основных частей любой программы на F# являются ***функции*** упорядочены ***модули***.  [Функции](./language-reference/functions/index.md) выполнения на входные данные для создания выходных значений, и они группируются по [модули](./language-reference/modules.md), которые являются основным способом сгруппировать объекты в F#.  Они определяются с помощью [ `let` привязки](./language-reference/functions/let-bindings.md), которая придает функции имя и определяет ее аргументы.

[!code-fsharp[BasicFunctions](~/samples/snippets/fsharp/tour.fs#L101-L133)]

`let`привязки также позволяют привязать значение к имени, аналогично переменной на других языках.  `let`привязки являются ***неизменяемыми*** по умолчанию. Это означает, что после привязки значения или функции к имени ее нельзя изменить на месте.  Это отличается от переменных в других языках, которые являются ***изменяемыми***, то есть их значения могут быть изменены в любой момент времени.  Если требуется изменяемая привязка, можно использовать `let mutable ...` синтаксис.

[!code-fsharp[Immutability](~/samples/snippets/fsharp/tour.fs#L75-L94)]

## <a name="numbers-booleans-and-strings"></a>Числа, логические значения и строки

Как на языке .NET, F# поддерживает тот же базовый [типов-примитивов](./language-reference/primitive-types.md) , существующие в .NET.

Вот, как различные числовые типы представлены в F#:

[!code-fsharp[Numbers](~/samples/snippets/fsharp/tour.fs#L49-L68)]

Ниже приведены логические значения и выполнение базовой условной логики.

[!code-fsharp[Bools](~/samples/snippets/fsharp/tour.fs#L142-L152)]

И вот как выглядит базовая обработка [строк](./language-reference/strings.md) :

[!code-fsharp[Strings](~/samples/snippets/fsharp/tour.fs#L158-L180)]

## <a name="tuples"></a>Кортежи

[Кортежи](./language-reference/tuples.md) являются особенного в F#.  Они представляют собой группирование неименованных, но упорядоченных значений, которые можно рассматривать как сами значения.  Их следует рассматривать как значения, агрегированные из других значений.  Они имеют множество применений, например, удобный возврат нескольких значений из функции или группирование значений для некоторого нерегламентированного удобства.

[!code-fsharp[Tuples](~/samples/snippets/fsharp/tour.fs#L186-L203)]

По состоянию на F# 4.1, можно также создать `struct` кортежей.  Они также полностью взаимодействуют с кортежами c# 7/Visual Basic 15, которые также `struct` являются кортежами:

[!code-fsharp[Tuples](~/samples/snippets/fsharp/tour.fs#L205-L218)]

Важно отметить, что, поскольку `struct` кортежи являются типами значений, они не могут быть неявно преобразованы в ссылочные кортежи или наоборот.  Необходимо явно выполнить преобразование между ссылкой и кортежем структуры.

## <a name="pipelines-and-composition"></a>Конвейеры и компоновка

Передать операторы, такие как `|>` широко используются при обработке данных в языке F#. Эти операторы — это функции, позволяющие гибко устанавливать "конвейеры" функций. В следующем примере показано, как можно воспользоваться преимуществами этих операторов для создания простого функционального конвейера:

[!code-fsharp[Pipelines](~/samples/snippets/fsharp/tour.fs#L227-L282)]

Приведенный выше образец внесенные использовать многие функции F#, включая список функций по обработке, функций первого класса и [частичное применение](./language-reference/functions/index.md#partial-application-of-arguments). Хотя глубокое понимание каждого из этих концепций может стать довольно сложным, должно быть ясно, насколько легко можно использовать функции для обработки данных при создании конвейеров.

## <a name="lists-arrays-and-sequences"></a>Списки, массивы и последовательности

Списки, массивы и последовательности являются три типа основной коллекции из основной библиотеки F#.

[Списки](./language-reference/lists.md) являются упорядоченными, неизменяемыми коллекциями элементов одного типа.  Они представляют собой однонаправленные списки, что означает, что они предназначены для перечисления, но плохо подходит для произвольного доступа и объединения, если они велики.  Это в отличие от списков в других популярных языках, которые обычно не используют однонаправленный список для представления списков.

[!code-fsharp[Lists](~/samples/snippets/fsharp/tour.fs#L309-L359)]

[Массивы](./language-reference/arrays.md) имеют фиксированный размер, *Изменяемые* коллекции элементов одного типа.  Они поддерживают быстрый произвольный доступ элементов и выполняются быстрее, чем F# список, так как они просто смежные блоки памяти.

[!code-fsharp[Arrays](~/samples/snippets/fsharp/tour.fs#L368-L407)]

[Последовательности](./language-reference/sequences.md) являются логическими последовательностями элементов одного типа.  Это более общий тип, чем списки и массивы, способные «просматривать» любые логические последовательности элементов.  Они также выделены, так как могут быть ***отложенными***, то есть элементы могут быть вычислены только при необходимости.

[!code-fsharp[Sequences](~/samples/snippets/fsharp/tour.fs#L418-L452)]

## <a name="recursive-functions"></a>Рекурсивные функции

Обработка коллекций или последовательности элементов обычно делается с помощью [рекурсии](./language-reference/functions/index.md#recursive-functions) в F#.  Несмотря на то, что F# имеет поддержку циклы и императивное программирование, рекурсии является предпочтительным, так как его проще обеспечить правильность.

> [!NOTE]
> В следующем примере используется сопоставление шаблонов с помощью `match` выражения.  Эта фундаментальная конструкция рассматривается далее в этой статье.

[!code-fsharp[RecursiveFunctions](~/samples/snippets/fsharp/tour.fs#L461-L500)]

F# также обеспечивает полную поддержку оптимизацию вызова с префиксом Tail, это способ оптимизации рекурсивных вызовов, чтобы они были просто так же быстро, как конструкция цикла.

## <a name="record-and-discriminated-union-types"></a>Типы записей и размеченных объединений

Типы объединений и записи являются два основных типа данных используется в коде F# и чаще всего это лучший способ представления данных в программе F#.  Хотя это делает их похожими на классы на других языках, одно из их основных отличий состоит в том, что они имеют семантику структурного равенства.  Это означает, что они являются сравнимыми по себе, и равенство достаточно просто проверить, равно ли один другой.

[Записи](./language-reference/records.md) представляют собой совокупность именованных значений с необязательными элементами (например, методами).  Если вы знакомы с C# языком или Java, они должны быть ПОХОЖИ на POCO или POJO-только структурное равенство и менее формальностей.

[!code-fsharp[Records](~/samples/snippets/fsharp/tour.fs#L507-L559)]

По состоянию на F# 4.1, может также представлять записи в виде `struct`s.  Это делается с помощью `[<Struct>]` атрибута:

[!code-fsharp[Records](~/samples/snippets/fsharp/tour.fs#L561-L568)]

[Размеченные объединения (ветвью)](./language-reference/discriminated-unions.md) — это значения, которые могут быть числом именованных форм или вариантов.  Данные, хранящиеся в типе, могут быть одного из нескольких различных значений.

[!code-fsharp[Unions](~/samples/snippets/fsharp/tour.fs#L575-L631)]

Вы также можете использовать ветвью в качестве *размеченных объединений с одним вариантом*, чтобы упростить моделирование доменов по примитивным типам.  Часто строки и другие примитивные типы используются для представления чего-либо, поэтому они задаются определенным значением.  Однако использование только примитивного представления данных может привести к ошибочному назначению неверного значения!  Представление каждого типа данных в виде отдельного однострочного объединения может обеспечить правильность в этом сценарии.

[!code-fsharp[Unions](~/samples/snippets/fsharp/tour.fs#L633-L654)]

Как показано в приведенном выше примере, чтобы получить базовое значение в размеченного Union с одним вариантом, необходимо явно разворачивать его.

Кроме того, ветвью также поддерживает рекурсивные определения, что позволяет легко представлять деревья и по сути рекурсивные данные.  Например, вот как можно представить двоичное дерево `exists` поиска функциями и. `insert`

[!code-fsharp[Unions](~/samples/snippets/fsharp/tour.fs#L656-L683)]

Поскольку ветвью позволяет представить рекурсивную структуру дерева в типе данных, работа над этой рекурсивной структурой проста и гарантирует правильность.  Он также поддерживается в сопоставлении шаблонов, как показано ниже.

Кроме того, можно представить ветвью как `struct`s `[<Struct>]` с атрибутом:

[!code-fsharp[Unions](~/samples/snippets/fsharp/tour.fs#L685-L696)]

Однако при этом следует учитывать два важных момента:

1. Невозможно рекурсивно определить структуру DU.
2. Структура DU должна иметь уникальные имена для каждого из своих вариантов.

Несоблюдение приведенных выше действий приведет к ошибке компиляции.

## <a name="pattern-matching"></a>Сопоставление шаблонов

[Шаблон сопоставления](./language-reference/pattern-matching.md) -функция F#, которая позволяет правильностью для работающие с типами F#.  В приведенных выше примерах вы, вероятно, заметили довольно `match x with ...` много синтаксиса.  Эта конструкция позволяет компилятору, который может понять «форму» типов данных, принудительно учитывать все возможные варианты использования типа данных с помощью того, что известно как исчерпывающее сопоставление шаблонов.  Это чрезвычайно мощный вариант для корректности, и его можно использовать для "точности" того, что обычно является проблемой времени выполнения во время компиляции.

[!code-fsharp[PatternMatching](~/samples/snippets/fsharp/tour.fs#L705-L742)]

Что вы, возможно, заметили, это использование `_` шаблона.  Это называется [шаблоном с подстановочными знаками](./language-reference/pattern-matching.md#wildcard-pattern), который позволяет сказать: «я не волнует что-то, что происходит».  Хотя это удобно, вы можете случайно обойти полную проверку соответствия шаблонов и больше не использовать преимущества, если не соблюдать осторожность при использовании `_`.  Он лучше всего подходит, если вы не следите за определенными фрагментами составного типа при сопоставлении шаблонов или итоговым предложением при перечислении всех осмысленных вариантов в выражении сопоставления шаблонов.

[Активные шаблоны](./language-reference/active-patterns.md) — это еще одна мощная конструкция, используемая с сопоставлением шаблонов.  Они позволяют секционировать входные данные в пользовательские формы, разбивая их на сайте вызова соответствия шаблону.  Они также могут быть параметризованы, тем самым позволяя определять секцию как функцию.  Расширение предыдущего примера для поддержки активных шаблонов выглядит примерно так:

[!code-fsharp[ActivePatterns](~/samples/snippets/fsharp/tour.fs#L764-L786)]

## <a name="optional-types"></a>Необязательные типы

Один особый случай размеченного объединения типов — это тип параметра, это так удобно, что он является частью основной библиотеки F#.

[Тип параметра](./language-reference/options.md) — это тип, представляющий один из двух вариантов: значение или ничего вообще.  Он используется в любом сценарии, где значение может быть или не получено из определенной операции.  Тогда вы назначите вам учитывать оба варианта, сделав его проблемой во время компиляции, а не заботу среды выполнения.  Они часто используются в интерфейсах API `null` , где используется для представления «Nothing», что устраняет необходимость `NullReferenceException` во многих обстоятельствах.

[!code-fsharp[Options](~/samples/snippets/fsharp/tour.fs#L789-L814)]

## <a name="units-of-measure"></a>Единицы измерения

Одной из уникальных особенностей системы типов F# является возможность предоставления контекста для числовых литералов через единицы измерения.

[Единицы измерения](./language-reference/units-of-measure.md) позволяют связать числовой тип с единицей, например в метрах, а функции выполняют работу с единицами, а не с числовыми литералами.  Это позволяет компилятору проверять, что типы числовых литералов имеют смысл в определенном контексте, тем самым устраняя ошибки времени выполнения, связанные с этим типом работы.

[!code-fsharp[UnitsOfMeasure](~/samples/snippets/fsharp/tour.fs#L817-L842)]

Библиотеки ядра F# определяет многие типы единиц SI и преобразования единиц измерения.  Чтобы узнать больше, ознакомьтесь с [пространством имен Microsoft.FSharp.Data.UnitSystems.Si](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d).

## <a name="classes-and-interfaces"></a>Классы и интерфейсы

F# также имеет полную поддержку для классов .NET, [интерфейсы](./language-reference/interfaces.md), [абстрактные классы](./language-reference/abstract-classes.md), [наследования](./language-reference/inheritance.md), и т. д.

[Классы](./language-reference/classes.md) — это типы, представляющие объекты .NET, которые могут иметь свойства, методы и события в качестве [членов](./language-reference/members/index.md).

[!code-fsharp[Classes](~/samples/snippets/fsharp/tour.fs#L845-L880)]

Определение универсальных классов также очень просто.

[!code-fsharp[Classes](~/samples/snippets/fsharp/tour.fs#L883-L908)]

Для реализации интерфейса можно использовать либо `interface ... with` синтаксис, либо [выражение объекта](./language-reference/object-expressions.md).

[!code-fsharp[Classes](~/samples/snippets/fsharp/tour.fs#L911-L934)]

## <a name="which-types-to-use"></a>Какие типы использовать

Наличие классов, записей, размеченных объединений и кортежей приводит к важному вопросу: что следует использовать?  Как и многие все это в жизни, ответ зависит от обстоятельств.

Кортежи отлично подходят для возвращения нескольких значений из функции и использования специального статистического выражения значений в качестве самого значения.

Записи — это «шаг с заходом» из кортежей, имеющих именованные метки и поддержку необязательных элементов.  Они отлично подходят для формальностей представления данных во время передачи по программе.  Так как они имеют структурное равенство, их легко использовать при сравнении.

Размеченные объединения имеют много использования, но основное преимущество заключается в том, чтобы их можно было использовать в сочетании с сопоставлением шаблонов для учета всех возможных "фигур", которые могут иметь данные.  

Классы отлично подходят для огромного числа причин, например, когда необходимо представить информацию, а также привязать эту информацию к функциональным возможностям.  Как правило, при наличии функциональности, которая концептуально привязана к некоторым данным, использование классов и принципов объектно-ориентированного программирования является большим преимуществом.  Классы также являются предпочтительным типом данных при взаимодействии с C# и Visual Basic, так как эти языки используют классы практически для всех.

## <a name="next-steps"></a>Следующие шаги

Теперь, когда вы увидели некоторые из основных функций языка, можно приступать к записи вашей первой программы на F#!  Ознакомьтесь [Начало работы](./tutorials/getting-started/index.md) , чтобы узнать, как настроить среду разработки и написать код.

Дальнейшие действия для изучения могут быть любыми, но мы рекомендуем ознакомиться с [функциональным программированием в F# ](./introduction-to-functional-programming/index.md) , чтобы приступить к работе с основными понятиями функционального программирования.  Это будут важное значение для построения надежных программ на языке F#.

Кроме того, ознакомьтесь с [Справочник по языку F#](./language-reference/index.md) чтобы увидеть полный набор концептуальное содержимое на F#.
