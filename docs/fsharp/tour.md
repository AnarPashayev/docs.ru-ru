---
title: Обзор языка F#
description: Изучите некоторые из ключевых особенностей языке этого учебника с образцами кода F#.
ms.date: 11/06/2018
ms.openlocfilehash: 4b3ec7fd2c42712440ea7d7045c560ab20390b45
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61901735"
---
# <a name="tour-of-f"></a><span data-ttu-id="3f224-103">Обзор языка F\#</span><span class="sxs-lookup"><span data-stu-id="3f224-103">Tour of F\#</span></span>

<span data-ttu-id="3f224-104">Лучший способ узнать о языке F# — для чтения и записи кода F#.</span><span class="sxs-lookup"><span data-stu-id="3f224-104">The best way to learn about F# is to read and write F# code.</span></span> <span data-ttu-id="3f224-105">В этой статье будет выступать в качестве обзор некоторых из ключевых функций языка F# и дают некоторые фрагменты кода, которые могут выполняться на компьютере.</span><span class="sxs-lookup"><span data-stu-id="3f224-105">This article will act as a tour through some of the key features of the F# language and give you some code snippets that you can execute on your machine.</span></span> <span data-ttu-id="3f224-106">Дополнительные сведения о настройке среды разработки, [Приступая к работе](tutorials/getting-started/index.md).</span><span class="sxs-lookup"><span data-stu-id="3f224-106">To learn about setting up a development environment, check out [Getting Started](tutorials/getting-started/index.md).</span></span>

<span data-ttu-id="3f224-107">Существуют две основные концепции в F#: функции и типы.</span><span class="sxs-lookup"><span data-stu-id="3f224-107">There are two primary concepts in F#: functions and types.</span></span>  <span data-ttu-id="3f224-108">Этот обзор будет подчеркнуть возможности языка, которые можно разделить эти две концепции.</span><span class="sxs-lookup"><span data-stu-id="3f224-108">This tour will emphasize features of the language which fall into these two concepts.</span></span>

## <a name="executing-the-code-online"></a><span data-ttu-id="3f224-109">Выполнение кода в интерактивном режиме</span><span class="sxs-lookup"><span data-stu-id="3f224-109">Executing the code online</span></span>

<span data-ttu-id="3f224-110">Если у вас нет F# установлен на компьютере, можно выполнить все примеров в Интернете с помощью [Fable REPL](https://fable.io/repl/).</span><span class="sxs-lookup"><span data-stu-id="3f224-110">If you don't have F# installed on your machine, you can execute all of the samples online with the [Fable REPL](https://fable.io/repl/).</span></span> <span data-ttu-id="3f224-111">Fable представляет собой диалект F# , выполняемый непосредственно в браузере.</span><span class="sxs-lookup"><span data-stu-id="3f224-111">Fable is a dialect of F# that executes directly in your browser.</span></span> <span data-ttu-id="3f224-112">Чтобы просмотреть образцы, выполните в REPL, извлечь **примеры > Дополнительные сведения > Обзор F#**  в строке меню слева Fable среду REPL.</span><span class="sxs-lookup"><span data-stu-id="3f224-112">To view the samples that follow in the REPL, check out **Samples > Learn > Tour of F#** in the left-hand menu bar of the Fable REPL.</span></span>

## <a name="functions-and-modules"></a><span data-ttu-id="3f224-113">Функций и модулей</span><span class="sxs-lookup"><span data-stu-id="3f224-113">Functions and Modules</span></span>

<span data-ttu-id="3f224-114">Наиболее основных частей любой программы на F# являются ***функции*** упорядочены ***модули***.</span><span class="sxs-lookup"><span data-stu-id="3f224-114">The most fundamental pieces of any F# program are ***functions*** organized into ***modules***.</span></span>  <span data-ttu-id="3f224-115">[Функции](language-reference/functions/index.md) выполнения на входные данные для создания выходных значений, и они группируются по [модули](language-reference/modules.md), которые являются основным способом сгруппировать объекты в F#.</span><span class="sxs-lookup"><span data-stu-id="3f224-115">[Functions](language-reference/functions/index.md) perform work on inputs to produce outputs, and they are organized under [Modules](language-reference/modules.md), which are the primary way you group things in F#.</span></span>  <span data-ttu-id="3f224-116">Они определяются с помощью [ `let` привязки](language-reference/functions/let-bindings.md), который присвойте функции имя и определять ее аргументы.</span><span class="sxs-lookup"><span data-stu-id="3f224-116">They are defined using the [`let` binding](language-reference/functions/let-bindings.md), which give the function a name and define its arguments.</span></span>

[!code-fsharp[BasicFunctions](../../samples/snippets/fsharp/tour.fs#L101-L133)]

<span data-ttu-id="3f224-117">`let` привязки, также, как привязать значение к имени, аналогичную переменной на других языках.</span><span class="sxs-lookup"><span data-stu-id="3f224-117">`let` bindings are also how you bind a value to a name, similar to a variable in other languages.</span></span>  <span data-ttu-id="3f224-118">`let` привязки-это ***неизменяемый*** по умолчанию, что означает, что после привязки значения или функции с именем, его нельзя изменить на месте.</span><span class="sxs-lookup"><span data-stu-id="3f224-118">`let` bindings are ***immutable*** by default, which means that once a value or function is bound to a name, it cannot be changed in-place.</span></span>  <span data-ttu-id="3f224-119">В отличие от переменных в других языках, которые являются ***изменяемый***, то есть их значения можно изменить в любой момент времени.</span><span class="sxs-lookup"><span data-stu-id="3f224-119">This is in contrast to variables in other languages, which are ***mutable***, meaning their values can be changed at any point in time.</span></span>  <span data-ttu-id="3f224-120">Если вам требуется изменяемой привязке, можно использовать `let mutable ...` синтаксис.</span><span class="sxs-lookup"><span data-stu-id="3f224-120">If you require a mutable binding, you can use `let mutable ...` syntax.</span></span>

[!code-fsharp[Immutability](../../samples/snippets/fsharp/tour.fs#L75-L94)]

## <a name="numbers-booleans-and-strings"></a><span data-ttu-id="3f224-121">Числа, логические значения и строки</span><span class="sxs-lookup"><span data-stu-id="3f224-121">Numbers, Booleans, and Strings</span></span>

<span data-ttu-id="3f224-122">Как на языке .NET, F# поддерживает тот же базовый [типов-примитивов](language-reference/primitive-types.md) , существующие в .NET.</span><span class="sxs-lookup"><span data-stu-id="3f224-122">As a .NET language, F# supports the same underlying [primitive types](language-reference/primitive-types.md) that exist in .NET.</span></span>

<span data-ttu-id="3f224-123">Вот, как различные числовые типы представлены в F#:</span><span class="sxs-lookup"><span data-stu-id="3f224-123">Here is how various numeric types are represented in F#:</span></span>

[!code-fsharp[Numbers](../../samples/snippets/fsharp/tour.fs#L49-L68)]

<span data-ttu-id="3f224-124">Вот какие логические значения и выполнения основных условной логики выглядит следующим образом:</span><span class="sxs-lookup"><span data-stu-id="3f224-124">Here's what Boolean values and performing basic conditional logic looks like:</span></span>

[!code-fsharp[Bools](../../samples/snippets/fsharp/tour.fs#L142-L152)]

<span data-ttu-id="3f224-125">А вот какие basic [строка](language-reference/strings.md) манипуляции выглядит как:</span><span class="sxs-lookup"><span data-stu-id="3f224-125">And here's what basic [string](language-reference/strings.md) manipulation looks like:</span></span>

[!code-fsharp[Strings](../../samples/snippets/fsharp/tour.fs#L158-L180)]

## <a name="tuples"></a><span data-ttu-id="3f224-126">Кортежи</span><span class="sxs-lookup"><span data-stu-id="3f224-126">Tuples</span></span>

<span data-ttu-id="3f224-127">[Кортежи](language-reference/tuples.md) являются особенного в F#.</span><span class="sxs-lookup"><span data-stu-id="3f224-127">[Tuples](language-reference/tuples.md) are a big deal in F#.</span></span>  <span data-ttu-id="3f224-128">Они являются группирования неименованных, но упорядоченных значений, которые могут рассматриваться как сами значения.</span><span class="sxs-lookup"><span data-stu-id="3f224-128">They are a grouping of unnamed, but ordered values, that can be treated as values themselves.</span></span>  <span data-ttu-id="3f224-129">Рассматривайте их как значения, который агрегируется из других значений.</span><span class="sxs-lookup"><span data-stu-id="3f224-129">Think of them as values which are aggregated from other values.</span></span>  <span data-ttu-id="3f224-130">Они имеют множество применений, например удобно возврат из функции несколько значений или значений для удобства некоторые ad-hoc группирования.</span><span class="sxs-lookup"><span data-stu-id="3f224-130">They have many uses, such as conveniently returning multiple values from a function, or grouping values for some ad-hoc convenience.</span></span>

[!code-fsharp[Tuples](../../samples/snippets/fsharp/tour.fs#L186-L203)]

<span data-ttu-id="3f224-131">По состоянию на F# 4.1, можно также создать `struct` кортежей.</span><span class="sxs-lookup"><span data-stu-id="3f224-131">As of F# 4.1, you can also create `struct` tuples.</span></span>  <span data-ttu-id="3f224-132">Они также настроить взаимодействие полностью с кортежами C# 7/Visual Basic 15, что также `struct` кортежей:</span><span class="sxs-lookup"><span data-stu-id="3f224-132">These also interoperate fully with C#7/Visual Basic 15 tuples, which are also `struct` tuples:</span></span>

[!code-fsharp[Tuples](../../samples/snippets/fsharp/tour.fs#L205-L218)]

<span data-ttu-id="3f224-133">Важно отметить, что поскольку `struct` кортежи представляют собой типы значений, для ссылки на кортежи, они не может быть неявно преобразован или наоборот.</span><span class="sxs-lookup"><span data-stu-id="3f224-133">It's important to note that because `struct` tuples are value types, they cannot be implicitly converted to reference tuples, or vice versa.</span></span>  <span data-ttu-id="3f224-134">Необходимо явным образом преобразовать между кортеж ссылок и структуры.</span><span class="sxs-lookup"><span data-stu-id="3f224-134">You must explicitly convert between a reference and struct tuple.</span></span>

## <a name="pipelines-and-composition"></a><span data-ttu-id="3f224-135">Конвейеры и композиции</span><span class="sxs-lookup"><span data-stu-id="3f224-135">Pipelines and Composition</span></span>

<span data-ttu-id="3f224-136">Передать операторы, такие как `|>` широко используются при обработке данных в языке F#.</span><span class="sxs-lookup"><span data-stu-id="3f224-136">Pipe operators such as `|>` are used extensively when processing data in F#.</span></span> <span data-ttu-id="3f224-137">Эти операторы являются функциями, которые позволяют установить «конвейеры» функций разными способами.</span><span class="sxs-lookup"><span data-stu-id="3f224-137">These operators are functions that allow you to establish "pipelines" of functions in a flexible manner.</span></span> <span data-ttu-id="3f224-138">Следующий пример поможет выполнить как можно воспользоваться преимуществами этих операторов для создания простой работы конвейера:</span><span class="sxs-lookup"><span data-stu-id="3f224-138">The following example walks through how you can take advantage of these operators to build a simple functional pipeline:</span></span>

[!code-fsharp[Pipelines](../../samples/snippets/fsharp/tour.fs#L227-L282)]

<span data-ttu-id="3f224-139">Приведенный выше образец внесенные использовать многие функции F#, включая список функций по обработке, функций первого класса и [частичное применение](language-reference/functions/index.md#partial-application-of-arguments).</span><span class="sxs-lookup"><span data-stu-id="3f224-139">The previous sample made use of many features of F#, including list processing functions, first-class functions, and [partial application](language-reference/functions/index.md#partial-application-of-arguments).</span></span> <span data-ttu-id="3f224-140">Несмотря на то, что глубокого понимания каждого из этих концепций могут стать несколько advanced, должно быть ясно, как легко функции могут использоваться для обработки данных, при создании конвейеров.</span><span class="sxs-lookup"><span data-stu-id="3f224-140">Although a deep understanding of each of those concepts can become somewhat advanced, it should be clear how easily functions can be used to process data when building pipelines.</span></span>

## <a name="lists-arrays-and-sequences"></a><span data-ttu-id="3f224-141">Списки, массивы и последовательности</span><span class="sxs-lookup"><span data-stu-id="3f224-141">Lists, Arrays, and Sequences</span></span>

<span data-ttu-id="3f224-142">Списки, массивы и последовательности являются три типа основной коллекции из основной библиотеки F#.</span><span class="sxs-lookup"><span data-stu-id="3f224-142">Lists, Arrays, and Sequences are three primary collection types in the F# core library.</span></span>

<span data-ttu-id="3f224-143">[Перечисляет](language-reference/lists.md) — это упорядоченная, неизменная коллекции элементов того же типа.</span><span class="sxs-lookup"><span data-stu-id="3f224-143">[Lists](language-reference/lists.md) are ordered, immutable collections of elements of the same type.</span></span>  <span data-ttu-id="3f224-144">Они являются однонаправленных списков, что означает, что они предназначены для перечисления, но плохим выбором для произвольного доступа и объединения, если они большие.</span><span class="sxs-lookup"><span data-stu-id="3f224-144">They are singly-linked lists, which means they are meant for enumeration, but a poor choice for random access and concatenation if they're large.</span></span>  <span data-ttu-id="3f224-145">Это отличие от списков в других популярных языках, которые обычно не используют однонаправленного связного списка для представления списков.</span><span class="sxs-lookup"><span data-stu-id="3f224-145">This in contrast to Lists in other popular languages, which typically do not use a singly-linked list to represent Lists.</span></span>

[!code-fsharp[Lists](../../samples/snippets/fsharp/tour.fs#L309-L359)]

<span data-ttu-id="3f224-146">[Массивы](language-reference/arrays.md) являются фиксированного размера, *изменяемый* коллекции элементов того же типа.</span><span class="sxs-lookup"><span data-stu-id="3f224-146">[Arrays](language-reference/arrays.md) are fixed-size, *mutable* collections of elements of the same type.</span></span>  <span data-ttu-id="3f224-147">Они поддерживают быстрый произвольный доступ элементов и выполняются быстрее, чем F# список, так как они просто смежные блоки памяти.</span><span class="sxs-lookup"><span data-stu-id="3f224-147">They support fast random access of elements, and are faster than F# lists because they are just contiguous blocks of memory.</span></span>

[!code-fsharp[Arrays](../../samples/snippets/fsharp/tour.fs#L368-L407)]

<span data-ttu-id="3f224-148">[Последовательности](language-reference/sequences.md) — это логический ряд элементов одного типа.</span><span class="sxs-lookup"><span data-stu-id="3f224-148">[Sequences](language-reference/sequences.md) are a logical series of elements, all of the same type.</span></span>  <span data-ttu-id="3f224-149">Это более общий тип чем списки и массивы, может быть «представления» в любой логический ряд элементов.</span><span class="sxs-lookup"><span data-stu-id="3f224-149">These are a more general type than Lists and Arrays, capable of being your "view" into any logical series of elements.</span></span>  <span data-ttu-id="3f224-150">Они также используются, так как они могут быть ***отложенной***, что означает, что элементы, можно вычислить только в том случае, когда они нужны.</span><span class="sxs-lookup"><span data-stu-id="3f224-150">They also stand out because they can be ***lazy***, which means that elements can be computed only when they are needed.</span></span>

[!code-fsharp[Sequences](../../samples/snippets/fsharp/tour.fs#L418-L452)]

## <a name="recursive-functions"></a><span data-ttu-id="3f224-151">Рекурсивные функции</span><span class="sxs-lookup"><span data-stu-id="3f224-151">Recursive Functions</span></span>

<span data-ttu-id="3f224-152">Обработка коллекций или последовательности элементов обычно делается с помощью [рекурсии](language-reference/functions/index.md#recursive-functions) в F#.</span><span class="sxs-lookup"><span data-stu-id="3f224-152">Processing collections or sequences of elements is typically done with [recursion](language-reference/functions/index.md#recursive-functions) in F#.</span></span>  <span data-ttu-id="3f224-153">Несмотря на то, что F# имеет поддержку циклы и императивное программирование, рекурсии является предпочтительным, так как его проще обеспечить правильность.</span><span class="sxs-lookup"><span data-stu-id="3f224-153">Although F# has support for loops and imperative programming, recursion is preferred because it is easier to guarantee correctness.</span></span>

> [!NOTE]
> <span data-ttu-id="3f224-154">Следующий пример использует сопоставление шаблонов с помощью `match` выражение.</span><span class="sxs-lookup"><span data-stu-id="3f224-154">The following example makes use of the pattern matching via the `match` expression.</span></span>  <span data-ttu-id="3f224-155">Этой фундаментальной конструкцией рассматривается далее в этой статье.</span><span class="sxs-lookup"><span data-stu-id="3f224-155">This fundamental construct is covered later in this article.</span></span>

[!code-fsharp[RecursiveFunctions](../../samples/snippets/fsharp/tour.fs#L461-L500)]

<span data-ttu-id="3f224-156">F# также обеспечивает полную поддержку оптимизацию вызова с префиксом Tail, это способ оптимизации рекурсивных вызовов, чтобы они были просто так же быстро, как конструкция цикла.</span><span class="sxs-lookup"><span data-stu-id="3f224-156">F# also has full support for Tail Call Optimization, which is a way to optimize recursive calls so that they are just as fast as a loop construct.</span></span>

## <a name="record-and-discriminated-union-types"></a><span data-ttu-id="3f224-157">Запись и типы размеченного объединения</span><span class="sxs-lookup"><span data-stu-id="3f224-157">Record and Discriminated Union Types</span></span>

<span data-ttu-id="3f224-158">Типы объединений и записи являются два основных типа данных используется в коде F# и чаще всего это лучший способ представления данных в программе F#.</span><span class="sxs-lookup"><span data-stu-id="3f224-158">Record and Union types are two fundamental data types used in F# code, and are generally the best way to represent data in an F# program.</span></span>  <span data-ttu-id="3f224-159">Несмотря на то, что это делает их подобные классам в других языках, один из их основных различий является наличие семантикой структурного равенства.</span><span class="sxs-lookup"><span data-stu-id="3f224-159">Although this makes them similar to classes in other languages, one of their primary differences is that they have structural equality semantics.</span></span>  <span data-ttu-id="3f224-160">Это означает, что они «изначально» сравнимы и равенства несложно — просто проверить, если он равен другому.</span><span class="sxs-lookup"><span data-stu-id="3f224-160">This means that they are "natively" comparable and equality is straightforward - just check if one is equal to the other.</span></span>

<span data-ttu-id="3f224-161">[Записи](language-reference/records.md) являются статистическое вычисление именованных значений, с помощью необязательных элементов (например, методы).</span><span class="sxs-lookup"><span data-stu-id="3f224-161">[Records](language-reference/records.md) are an aggregate of named values, with optional members (such as methods).</span></span>  <span data-ttu-id="3f224-162">Если вы знакомы с C# или Java, затем они должно казаться похожими POCO или элементов Pojo - только с структурного равенства и менее формального.</span><span class="sxs-lookup"><span data-stu-id="3f224-162">If you're familiar with C# or Java, then these should feel similar to POCOs or POJOs - just with structural equality and less ceremony.</span></span>

[!code-fsharp[Records](../../samples/snippets/fsharp/tour.fs#L507-L559)]

<span data-ttu-id="3f224-163">По состоянию на F# 4.1, может также представлять записи в виде `struct`s.</span><span class="sxs-lookup"><span data-stu-id="3f224-163">As of F# 4.1, you can also represent Records as `struct`s.</span></span>  <span data-ttu-id="3f224-164">Это делается с помощью `[<Struct>]` атрибут:</span><span class="sxs-lookup"><span data-stu-id="3f224-164">This is done with the `[<Struct>]` attribute:</span></span>

[!code-fsharp[Records](../../samples/snippets/fsharp/tour.fs#L561-L568)]

<span data-ttu-id="3f224-165">[Размеченные объединения (DUs)](language-reference/discriminated-unions.md) — это значения, которые могут быть ряд именованных форм или случаев.</span><span class="sxs-lookup"><span data-stu-id="3f224-165">[Discriminated Unions (DUs)](language-reference/discriminated-unions.md) are values which could be a number of named forms or cases.</span></span>  <span data-ttu-id="3f224-166">Данные, хранящиеся в типе может принимать несколько различных значений.</span><span class="sxs-lookup"><span data-stu-id="3f224-166">Data stored in the type can be one of several distinct values.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L575-L631)]

<span data-ttu-id="3f224-167">Можно также использовать DUs как *одиночным размеченные объединения*, чтобы помочь с доменом, моделирование по типов-примитивов.</span><span class="sxs-lookup"><span data-stu-id="3f224-167">You can also use DUs as *Single-Case Discriminated Unions*, to help with domain modeling over primitive types.</span></span>  <span data-ttu-id="3f224-168">Зачастую, строк и других типов-примитивов, используются для представления и таким образом, предоставить определенного значения.</span><span class="sxs-lookup"><span data-stu-id="3f224-168">Often times, strings and other primitive types are used to represent something, and are thus given a particular meaning.</span></span>  <span data-ttu-id="3f224-169">Тем не менее с помощью простых представлением данных может привести к ошибочно назначение неправильное значение!</span><span class="sxs-lookup"><span data-stu-id="3f224-169">However, using only the primitive representation of the data can result in mistakenly assigning an incorrect value!</span></span>  <span data-ttu-id="3f224-170">Представляет каждый тип данных, как объединение отдельных одиночным можно принудительно задать правильность в этом сценарии.</span><span class="sxs-lookup"><span data-stu-id="3f224-170">Representing each type of information as a distinct single-case union can enforce correctness in this scenario.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L633-L654)]

<span data-ttu-id="3f224-171">Как показано в приведенном выше примере, чтобы получить базовое значение в одиночным размеченного объединения, вы должны явно распаковки.</span><span class="sxs-lookup"><span data-stu-id="3f224-171">As the above sample demonstrates, to get the underlying value in a single-case Discriminated Union, you must explicitly unwrap it.</span></span>

<span data-ttu-id="3f224-172">Кроме того DUs также поддерживают рекурсивные определения, что позволяет легко представления дерева и по своей природе рекурсивные данные.</span><span class="sxs-lookup"><span data-stu-id="3f224-172">Additionally, DUs also support recursive definitions, allowing you to easily represent trees and inherently recursive data.</span></span>  <span data-ttu-id="3f224-173">Например, вот как может представлять двоичное дерево поиска с `exists` и `insert` функции.</span><span class="sxs-lookup"><span data-stu-id="3f224-173">For example, here's how you can represent a Binary Search Tree with `exists` and `insert` functions.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L656-L683)]

<span data-ttu-id="3f224-174">Поскольку DUs можно представить рекурсивную структуру дерева в тип данных, на этом рекурсивную структуру прост и гарантирует правильность.</span><span class="sxs-lookup"><span data-stu-id="3f224-174">Because DUs allow you to represent the recursive structure of the tree in the data type, operating on this recursive structure is straightforward and guarantees correctness.</span></span>  <span data-ttu-id="3f224-175">Также поддерживается при сопоставлении шаблонов, как показано ниже.</span><span class="sxs-lookup"><span data-stu-id="3f224-175">It is also supported in pattern matching, as shown below.</span></span>

<span data-ttu-id="3f224-176">Кроме того, вы можете представить DUs как `struct`s с `[<Struct>]` атрибут:</span><span class="sxs-lookup"><span data-stu-id="3f224-176">Additionally, you can represent DUs as `struct`s with the `[<Struct>]` attribute:</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L685-L696)]

<span data-ttu-id="3f224-177">Тем не менее существует два важных момента при этом следует учитывать:</span><span class="sxs-lookup"><span data-stu-id="3f224-177">However, there are two key things to keep in mind when doing so:</span></span>

1. <span data-ttu-id="3f224-178">Структура DU не может быть определен рекурсивно.</span><span class="sxs-lookup"><span data-stu-id="3f224-178">A struct DU cannot be recursively-defined.</span></span>
2. <span data-ttu-id="3f224-179">Структура DU должны иметь уникальные имена для каждого из его вариантов.</span><span class="sxs-lookup"><span data-stu-id="3f224-179">A struct DU must have unique names for each of its cases.</span></span>

<span data-ttu-id="3f224-180">Несоблюдение выше приведет к ошибке компиляции.</span><span class="sxs-lookup"><span data-stu-id="3f224-180">Failure to follow the above will result in a compilation error.</span></span>

## <a name="pattern-matching"></a><span data-ttu-id="3f224-181">Сопоставление шаблонов</span><span class="sxs-lookup"><span data-stu-id="3f224-181">Pattern Matching</span></span>

<span data-ttu-id="3f224-182">[Шаблон сопоставления](language-reference/pattern-matching.md) -функция F#, которая позволяет правильностью для работающие с типами F#.</span><span class="sxs-lookup"><span data-stu-id="3f224-182">[Pattern Matching](language-reference/pattern-matching.md) is the F# language feature which enables correctness for operating on F# types.</span></span>  <span data-ttu-id="3f224-183">В примерах выше вы, наверное, заметили совсем немного `match x with ...` синтаксис.</span><span class="sxs-lookup"><span data-stu-id="3f224-183">In the above samples, you probably noticed quite a bit of `match x with ...` syntax.</span></span>  <span data-ttu-id="3f224-184">Эта конструкция позволяет компилятору, который можно определить «форму» типы данных, для принудительного для учетной записи для всех возможных вариантов, при использовании типа данных через то, что известно как полное сопоставление шаблонов.</span><span class="sxs-lookup"><span data-stu-id="3f224-184">This construct allows the compiler, which can understand the "shape" of data types, to force you to account for all possible cases when using a data type through what is known as Exhaustive Pattern Matching.</span></span>  <span data-ttu-id="3f224-185">Это невероятно мощное правильность и искусно позволяют «извлекаете», что обычно является проблемой среды выполнения в во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="3f224-185">This is incredibly powerful for correctness, and can be cleverly used to "lift" what would normally be a runtime concern into compile-time.</span></span>

[!code-fsharp[PatternMatching](../../samples/snippets/fsharp/tour.fs#L705-L742)]

<span data-ttu-id="3f224-186">Вы заметите, что-то заключается в использовании `_` шаблон.</span><span class="sxs-lookup"><span data-stu-id="3f224-186">Something you may have noticed is the use of the `_` pattern.</span></span>  <span data-ttu-id="3f224-187">Этот процесс называется [Шаблон подстановочного знака](language-reference/pattern-matching.md#wildcard-pattern), который является способом выполнения «Меня не волнует, что что-то такое».</span><span class="sxs-lookup"><span data-stu-id="3f224-187">This is known as the [Wildcard Pattern](language-reference/pattern-matching.md#wildcard-pattern), which is a way of saying "I don't care what something is".</span></span>  <span data-ttu-id="3f224-188">Несмотря на то что удобна, можно случайно обойти полное сопоставление шаблонов и больше не воспользоваться преимуществами принудительные применения во время компиляции, если не соблюдать осторожность при использовании `_`.</span><span class="sxs-lookup"><span data-stu-id="3f224-188">Although convenient, you can accidentally bypass Exhaustive Pattern Matching and no longer benefit from compile-time enforcements if you aren't careful in using `_`.</span></span>  <span data-ttu-id="3f224-189">Лучше всего использовать, если вас не интересуют некоторые фрагменты разложенные типа при шаблон соответствия или последнего предложения, когда перечислили все значимые варианты в выражении шаблона.</span><span class="sxs-lookup"><span data-stu-id="3f224-189">It is best used when you don't care about certain pieces of a decomposed type when pattern matching, or the final clause when you have enumerated all meaningful cases in a pattern matching expression.</span></span>

<span data-ttu-id="3f224-190">[Активные шаблоны](language-reference/active-patterns.md) являются другой мощные конструкции для использования с сопоставлением шаблонов.</span><span class="sxs-lookup"><span data-stu-id="3f224-190">[Active Patterns](language-reference/active-patterns.md) are another powerful construct to use with pattern matching.</span></span>  <span data-ttu-id="3f224-191">Они позволяют секционировать входные данные в пользовательских форм, их разбивки на сайте вызова соответствия шаблону.</span><span class="sxs-lookup"><span data-stu-id="3f224-191">They allow you to partition input data into custom forms, decomposing them at the pattern match call site.</span></span>  <span data-ttu-id="3f224-192">Они могут также быть параметризованы, таким образом для определения секции в качестве функции.</span><span class="sxs-lookup"><span data-stu-id="3f224-192">They can also be parameterized, thus allowing to define the partition as a function.</span></span>  <span data-ttu-id="3f224-193">Развертывание в предыдущем примере, для поддержки активные шаблоны выглядит примерно следующим образом:</span><span class="sxs-lookup"><span data-stu-id="3f224-193">Expanding the previous example to support Active Patterns looks something like this:</span></span>

[!code-fsharp[ActivePatterns](../../samples/snippets/fsharp/tour.fs#L764-L786)]

## <a name="optional-types"></a><span data-ttu-id="3f224-194">Дополнительные типы</span><span class="sxs-lookup"><span data-stu-id="3f224-194">Optional Types</span></span>

<span data-ttu-id="3f224-195">Один особый случай размеченного объединения типов — это тип параметра, это так удобно, что он является частью основной библиотеки F#.</span><span class="sxs-lookup"><span data-stu-id="3f224-195">One special case of Discriminated Union types is the Option Type, which is so useful that it's a part of the F# core library.</span></span>

<span data-ttu-id="3f224-196">[Тип параметра](language-reference/options.md) — это тип, который представляет один из двух случаев: значение, либо значение nothing вообще.</span><span class="sxs-lookup"><span data-stu-id="3f224-196">[The Option Type](language-reference/options.md) is a type which represents one of two cases: a value, or nothing at all.</span></span>  <span data-ttu-id="3f224-197">Он используется в любом сценарии, где значение может или не из конкретной операции.</span><span class="sxs-lookup"><span data-stu-id="3f224-197">It is used in any scenario where a value may or may not result from a particular operation.</span></span>  <span data-ttu-id="3f224-198">Затем, поэтому приходится учетной записи в обоих случаях станет проблемой во время компиляции, а не значения среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="3f224-198">This then forces you to account for both cases, making it a compile-time concern rather than a runtime concern.</span></span>  <span data-ttu-id="3f224-199">Они часто используются в API-интерфейсах где `null` используется для представления «nothing», вместо этого, тем самым исключая необходимость беспокоиться о `NullReferenceException` во многих случаях.</span><span class="sxs-lookup"><span data-stu-id="3f224-199">These are often used in APIs where `null` is used to represent "nothing" instead, thus eliminating the need to worry about `NullReferenceException` in many circumstances.</span></span>

[!code-fsharp[Options](../../samples/snippets/fsharp/tour.fs#L789-L814)]

## <a name="units-of-measure"></a><span data-ttu-id="3f224-200">Единицы измерения</span><span class="sxs-lookup"><span data-stu-id="3f224-200">Units of Measure</span></span>

<span data-ttu-id="3f224-201">Одной из уникальных особенностей системы типов F# является возможность предоставления контекста для числовых литералов через единицы измерения.</span><span class="sxs-lookup"><span data-stu-id="3f224-201">One unique feature of F#'s type system is the ability to provide context for numeric literals through Units of Measure.</span></span>

<span data-ttu-id="3f224-202">[Единицы измерения](language-reference/units-of-measure.md) позволяют связывать числового типа к единице измерения, такие как счетчики, и у функции работы с единицы, а не числовые литералы.</span><span class="sxs-lookup"><span data-stu-id="3f224-202">[Units of Measure](language-reference/units-of-measure.md) allow you to associate a numeric type to a unit, such as Meters, and have functions perform work on units rather than numeric literals.</span></span>  <span data-ttu-id="3f224-203">Это позволяет компилятору проверять, что типы числовых литералов, передаваемых в смысл при определенном контексте, устраняя ошибки времени выполнения, связанного с такой работы.</span><span class="sxs-lookup"><span data-stu-id="3f224-203">This enables the compiler to verify that the types of numeric literals passed in make sense under a certain context, thus eliminating runtime errors associated with that kind of work.</span></span>

[!code-fsharp[UnitsOfMeasure](../../samples/snippets/fsharp/tour.fs#L817-L842)]

<span data-ttu-id="3f224-204">Библиотеки ядра F# определяет многие типы единиц SI и преобразования единиц измерения.</span><span class="sxs-lookup"><span data-stu-id="3f224-204">The F# Core library defines many SI unit types and unit conversions.</span></span>  <span data-ttu-id="3f224-205">Чтобы узнать больше, ознакомьтесь с [Microsoft.FSharp.Data.unitsystems.SI-пространство имен](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d).</span><span class="sxs-lookup"><span data-stu-id="3f224-205">To learn more, check out the [Microsoft.FSharp.Data.UnitSystems.SI Namespace](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d).</span></span>

## <a name="classes-and-interfaces"></a><span data-ttu-id="3f224-206">Классы и интерфейсы</span><span class="sxs-lookup"><span data-stu-id="3f224-206">Classes and Interfaces</span></span>

<span data-ttu-id="3f224-207">F# также имеет полную поддержку для классов .NET, [интерфейсы](language-reference/interfaces.md), [абстрактные классы](language-reference/abstract-classes.md), [наследования](language-reference/inheritance.md), и т. д.</span><span class="sxs-lookup"><span data-stu-id="3f224-207">F# also has full support for .NET classes, [Interfaces](language-reference/interfaces.md), [Abstract Classes](language-reference/abstract-classes.md), [Inheritance](language-reference/inheritance.md), and so on.</span></span>

<span data-ttu-id="3f224-208">[Классы](language-reference/classes.md) представляют объекты .NET, который может иметь свойства, методы и события, что его [члены](language-reference/members/index.md).</span><span class="sxs-lookup"><span data-stu-id="3f224-208">[Classes](language-reference/classes.md) are types that represent .NET objects, which can have properties, methods, and events as its [Members](language-reference/members/index.md).</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L845-L880)]

<span data-ttu-id="3f224-209">Определение универсальных классов также очень проста.</span><span class="sxs-lookup"><span data-stu-id="3f224-209">Defining generic classes is also very straightforward.</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L883-L908)]

<span data-ttu-id="3f224-210">Чтобы реализовать интерфейс, можно использовать либо `interface ... with` синтаксис или [выражение объекта](language-reference/object-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="3f224-210">To implement an Interface, you can use either `interface ... with` syntax or an [Object Expression](language-reference/object-expressions.md).</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L911-L934)]

## <a name="which-types-to-use"></a><span data-ttu-id="3f224-211">Типы, которые требуется использовать</span><span class="sxs-lookup"><span data-stu-id="3f224-211">Which Types to Use</span></span>

<span data-ttu-id="3f224-212">Наличие классы, записи, размеченные объединения и кортежи приводит к важный вопрос: что следует использовать?</span><span class="sxs-lookup"><span data-stu-id="3f224-212">The presence of Classes, Records, Discriminated Unions, and Tuples leads to an important question: which should you use?</span></span>  <span data-ttu-id="3f224-213">Как и почти все в жизни ответ зависит от обстоятельств.</span><span class="sxs-lookup"><span data-stu-id="3f224-213">Like most everything in life, the answer depends on your circumstances.</span></span>

<span data-ttu-id="3f224-214">Кортежи отлично подходят для возврата нескольких значений из функции и статистическое вычисление ad-hoc значения в качестве значение сам.</span><span class="sxs-lookup"><span data-stu-id="3f224-214">Tuples are great for returning multiple values from a function, and using an ad-hoc aggregate of values as a value itself.</span></span>

<span data-ttu-id="3f224-215">Записи являются «шаг вверх» из кортежей, с именем метки и поддержка необязательных элементов.</span><span class="sxs-lookup"><span data-stu-id="3f224-215">Records are a "step up" from Tuples, having named labels and support for optional members.</span></span>  <span data-ttu-id="3f224-216">Они отлично подходят для неофициальное представление данных во время передачи по программе.</span><span class="sxs-lookup"><span data-stu-id="3f224-216">They are great for a low-ceremony representation of data in-transit through your program.</span></span>  <span data-ttu-id="3f224-217">Из-за наличия структурного равенства, они легко использовать с сравнения.</span><span class="sxs-lookup"><span data-stu-id="3f224-217">Because they have structural equality, they are easy to use with comparison.</span></span>

<span data-ttu-id="3f224-218">Размеченные объединения имеют множество применений, но преимущество core заключается в том, чтобы иметь возможность использовать их вместе с сопоставлением шаблонов, чтобы учесть все возможные «фигуры», которые могут иметь данных.</span><span class="sxs-lookup"><span data-stu-id="3f224-218">Discriminated Unions have many uses, but the core benefit is to be able to utilize them in conjunction with Pattern Matching to account for all possible "shapes" that a data can have.</span></span>  

<span data-ttu-id="3f224-219">Классы отлично подходят для множество причин, например для представления информации и также привязать эту информацию к функциональным возможностям.</span><span class="sxs-lookup"><span data-stu-id="3f224-219">Classes are great for a huge number of reasons, such as when you need to represent information and also tie that information to functionality.</span></span>  <span data-ttu-id="3f224-220">Как правило при наличии функциональные возможности, которые концептуально привязывается к некоторым данным с помощью классов и принципы объектно-ориентированное программирование является большим преимуществом.</span><span class="sxs-lookup"><span data-stu-id="3f224-220">As a rule of thumb, when you have functionality which is conceptually tied to some data, using Classes and the principles of Object-Oriented Programming is a big benefit.</span></span>  <span data-ttu-id="3f224-221">Классы также представлены предпочтительный тип данных при взаимодействии с C# и Visual Basic, как эти языки используют классы для практически полностью.</span><span class="sxs-lookup"><span data-stu-id="3f224-221">Classes are also the preferred data type when interoperating with C# and Visual Basic, as these languages use classes for nearly everything.</span></span>

## <a name="next-steps"></a><span data-ttu-id="3f224-222">Следующие шаги</span><span class="sxs-lookup"><span data-stu-id="3f224-222">Next Steps</span></span>

<span data-ttu-id="3f224-223">Теперь, когда вы увидели некоторые из основных функций языка, можно приступать к записи вашей первой программы на F#!</span><span class="sxs-lookup"><span data-stu-id="3f224-223">Now that you've seen some of the primary features of the language, you should be ready to write your first F# programs!</span></span>  <span data-ttu-id="3f224-224">Ознакомьтесь с [Приступая к работе](tutorials/getting-started/index.md) чтобы узнать, как настроить среду разработки и написать код.</span><span class="sxs-lookup"><span data-stu-id="3f224-224">Check out [Getting Started](tutorials/getting-started/index.md) to learn how to set up your development environment and write some code.</span></span>

<span data-ttu-id="3f224-225">Следующие шаги для получения дополнительных сведений может быть любым, но мы рекомендуем [введение в функциональное программирование в F# ](introduction-to-functional-programming/index.md) успешной работы с основными механизмами функциональное программирование.</span><span class="sxs-lookup"><span data-stu-id="3f224-225">The next steps for learning more can be whatever you like, but we recommend [Introduction to Functional Programming in F#](introduction-to-functional-programming/index.md) to get comfortable with core Functional Programming concepts.</span></span>  <span data-ttu-id="3f224-226">Это будут важное значение для построения надежных программ на языке F#.</span><span class="sxs-lookup"><span data-stu-id="3f224-226">These will be essential in building robust programs in F#.</span></span>

<span data-ttu-id="3f224-227">Кроме того, ознакомьтесь с [Справочник по языку F#](language-reference/index.md) чтобы увидеть полный набор концептуальное содержимое на F#.</span><span class="sxs-lookup"><span data-stu-id="3f224-227">Also, check out the [F# Language Reference](language-reference/index.md) to see a comprehensive collection of conceptual content on F#.</span></span>
