---
title: Обзор языка F#
description: 'Изучите некоторые основные возможности языка программирования F # в этом обзоре с примерами кода.'
ms.date: 08/14/2020
ms.openlocfilehash: b115317e1f47ef7e18333cae4145b99e11645579
ms.sourcegitcommit: 8bfeb5930ca48b2ee6053f16082dcaf24d46d221
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/18/2020
ms.locfileid: "88558599"
---
# <a name="tour-of-f"></a>Обзор F\#

Лучший способ узнать о F # — читать и писать код на F #. В этой статье рассматриваются некоторые ключевые возможности языка F # и приводятся некоторые фрагменты кода, которые можно выполнять на компьютере. Чтобы узнать о настройке среды разработки, ознакомьтесь с [Начало работы](get-started/index.md).

В F # есть два основных понятия: функции и типы.  В этом обзоре рассматриваются функции языка, которые делятся на эти две концепции.

## <a name="executing-the-code-online"></a>Исполнение кода в сети

Если на компьютере не установлен F #, вы можете выполнить все примеры в браузере с помощью инструкции [try F # для](https://tryfsharp.fsbolero.io/)веб – сборки. Фабле — это диалект F #, который выполняется непосредственно в браузере. Чтобы просмотреть примеры, приведенные в статье REPL, ознакомьтесь с **примерами, > узнать > обзор F #** в левой строке меню фабле repl.

## <a name="functions-and-modules"></a>Функции и модули

Наиболее фундаментальными частями любой программы F # являются ***функции*** , организованные в ***модули***.  [Функции](./language-reference/functions/index.md) выполняют работу с входными данными для получения выходных данных, и они упорядочены по [модулям](./language-reference/modules.md), которые являются основным способом группирования в F #.  Они определяются с помощью [ `let` привязки](./language-reference/functions/let-bindings.md), которая придает функции имя и определяет ее аргументы.

[!code-fsharp[BasicFunctions](~/samples/snippets/fsharp/tour.fs#L101-L133)]

`let` привязки также позволяют привязать значение к имени, аналогично переменной на других языках.  `let` привязки являются ***неизменяемыми*** по умолчанию. Это означает, что после привязки значения или функции к имени ее нельзя изменить на месте.  Это отличается от переменных в других языках, которые являются ***изменяемыми***, то есть их значения могут быть изменены в любой момент времени.  Если требуется изменяемая привязка, можно использовать `let mutable ...` синтаксис.

[!code-fsharp[Immutability](~/samples/snippets/fsharp/tour.fs#L75-L94)]

## <a name="numbers-booleans-and-strings"></a>Числа, логические значения и строки

Как язык .NET, F # поддерживает те же базовые [примитивные типы](language-reference/basic-types.md) , которые существуют в .NET.

Ниже показано, как различные числовые типы представлены в F #:

[!code-fsharp[Numbers](~/samples/snippets/fsharp/tour.fs#L49-L68)]

Ниже приведены логические значения и выполнение базовой условной логики.

[!code-fsharp[Bools](~/samples/snippets/fsharp/tour.fs#L142-L152)]

И вот как выглядит базовая обработка [строк](./language-reference/strings.md) :

[!code-fsharp[Strings](~/samples/snippets/fsharp/tour.fs#L158-L180)]

## <a name="tuples"></a>Кортежи

[Кортежи](./language-reference/tuples.md) — это большая сделка в F #.  Они представляют собой группирование неименованных, но упорядоченных значений, которые можно рассматривать как сами значения.  Их следует рассматривать как значения, агрегированные из других значений.  Они имеют множество применений, например, удобный возврат нескольких значений из функции или группирование значений для некоторого нерегламентированного удобства.

[!code-fsharp[Tuples](~/samples/snippets/fsharp/tour.fs#L186-L203)]

Можно также создавать `struct` кортежи.  Они также полностью взаимодействуют с кортежами C# 7/Visual Basic 15, которые также являются `struct` кортежами:

[!code-fsharp[Tuples](~/samples/snippets/fsharp/tour.fs#L205-L218)]

Важно отметить, что, поскольку `struct` кортежи являются типами значений, они не могут быть неявно преобразованы в ссылочные кортежи или наоборот.  Необходимо явно выполнить преобразование между ссылкой и кортежем структуры.

## <a name="pipelines-and-composition"></a>Конвейеры и компоновка

Операторы конвейера, такие как `|>` , широко используются при обработке данных в F #. Эти операторы — это функции, позволяющие гибко устанавливать "конвейеры" функций. В следующем примере показано, как можно воспользоваться преимуществами этих операторов для создания простого функционального конвейера:

[!code-fsharp[Pipelines](~/samples/snippets/fsharp/tour.fs#L227-L282)]

В предыдущем примере использовались многие функции F #, включая функции обработки списков, функции первого класса и [частичное приложение](./language-reference/functions/index.md#partial-application-of-arguments). Хотя глубокое понимание каждого из этих концепций может стать довольно сложным, должно быть ясно, насколько легко можно использовать функции для обработки данных при создании конвейеров.

## <a name="lists-arrays-and-sequences"></a>Списки, массивы и последовательности

Списки, массивы и последовательности — это три основных типа коллекций в основной библиотеке F #.

[Списки](./language-reference/lists.md) являются упорядоченными, неизменяемыми коллекциями элементов одного типа.  Они представляют собой однонаправленные списки, что означает, что они предназначены для перечисления, но плохо подходит для произвольного доступа и объединения, если они велики.  Это в отличие от списков в других популярных языках, которые обычно не используют однонаправленный список для представления списков.

[!code-fsharp[Lists](~/samples/snippets/fsharp/tour.fs#L309-L359)]

[Массивы](./language-reference/arrays.md) имеют фиксированный размер, *Изменяемые* коллекции элементов одного типа.  Они поддерживают быстрый произвольный доступ к элементам и работают быстрее, чем списки F #, так как они являются только непрерывными блоками памяти.

[!code-fsharp[Arrays](~/samples/snippets/fsharp/tour.fs#L368-L407)]

[Последовательности](./language-reference/sequences.md) являются логическими последовательностями элементов одного типа.  Это более общий тип, чем списки и массивы, способные «просматривать» любые логические последовательности элементов.  Они также выделены, так как могут быть ***отложенными***, то есть элементы могут быть вычислены только при необходимости.

[!code-fsharp[Sequences](~/samples/snippets/fsharp/tour.fs#L418-L452)]

## <a name="recursive-functions"></a>Рекурсивные функции

Обработка коллекций или последовательностей элементов обычно выполняется с помощью [рекурсии](./language-reference/functions/index.md#recursive-functions) в F #.  Хотя F # поддерживает циклы и императивное программирование, рекурсия предпочтительнее, так как проще гарантировать правильность.

> [!NOTE]
> В следующем примере используется сопоставление шаблонов с помощью `match` выражения.  Эта фундаментальная конструкция рассматривается далее в этой статье.

[!code-fsharp[RecursiveFunctions](~/samples/snippets/fsharp/tour.fs#L461-L500)]

F # также обеспечивает полную поддержку оптимизации вызовов с префиксом tail, что позволяет оптимизировать рекурсивные вызовы, чтобы они были настолько же быстрыми, что и Циклическая конструкция.

## <a name="record-and-discriminated-union-types"></a>Типы записей и размеченных объединений

Типы записей и объединений — это два основных типа данных, которые используются в коде F #, и обычно являются лучшим способом представления данных в программе F #.  Хотя это делает их похожими на классы на других языках, одно из их основных отличий состоит в том, что они имеют семантику структурного равенства.  Это означает, что они являются сравнимыми по себе, и равенство достаточно просто проверить, равно ли один другой.

[Записи](./language-reference/records.md) представляют собой совокупность именованных значений с необязательными элементами (например, методами).  Если вы знакомы с C# или Java, то они должны быть похожи на POCO или POJO-только структурное равенство и менее формальностей.

[!code-fsharp[Records](~/samples/snippets/fsharp/tour.fs#L507-L559)]

Также можно представить записи как структуры. Это делается с помощью `[<Struct>]` атрибута:

[!code-fsharp[Records](~/samples/snippets/fsharp/tour.fs#L561-L568)]

[Размеченные объединения (ветвью)](./language-reference/discriminated-unions.md) — это значения, которые могут быть числом именованных форм или вариантов.  Данные, хранящиеся в типе, могут быть одного из нескольких различных значений.

[!code-fsharp[Unions](~/samples/snippets/fsharp/tour.fs#L575-L631)]

Вы также можете использовать ветвью в качестве *размеченных объединений с одним вариантом*, чтобы упростить моделирование доменов по примитивным типам.  Часто строки и другие примитивные типы используются для представления чего-либо, поэтому они задаются определенным значением.  Однако использование только примитивного представления данных может привести к ошибочному назначению неверного значения!  Представление каждого типа данных в виде отдельного однострочного объединения может обеспечить правильность в этом сценарии.

[!code-fsharp[Unions](~/samples/snippets/fsharp/tour.fs#L633-L654)]

Как показано в приведенном выше примере, чтобы получить базовое значение в размеченного Union с одним вариантом, необходимо явно разворачивать его.

Кроме того, ветвью также поддерживает рекурсивные определения, что позволяет легко представлять деревья и по сути рекурсивные данные.  Например, вот как можно представить двоичное дерево поиска `exists` `insert` функциями и.

[!code-fsharp[Unions](~/samples/snippets/fsharp/tour.fs#L656-L683)]

Поскольку ветвью позволяет представить рекурсивную структуру дерева в типе данных, работа над этой рекурсивной структурой проста и гарантирует правильность.  Он также поддерживается в сопоставлении шаблонов, как показано ниже.

Кроме того, можно представить ветвью как `struct` s с `[<Struct>]` атрибутом:

[!code-fsharp[Unions](~/samples/snippets/fsharp/tour.fs#L685-L696)]

Однако при этом следует учитывать два важных момента:

1. Невозможно рекурсивно определить структуру DU.
2. Структура DU должна иметь уникальные имена для каждого из своих вариантов.

Несоблюдение приведенных выше действий приведет к ошибке компиляции.

## <a name="pattern-matching"></a>Сопоставление шаблонов

[Сопоставление шаблонов](./language-reference/pattern-matching.md) — это функция языка f #, которая обеспечивает правильность работы с типами F #.  В приведенных выше примерах вы, вероятно, заметили довольно много `match x with ...` синтаксиса.  Эта конструкция позволяет компилятору, который может понять «форму» типов данных, принудительно учитывать все возможные варианты использования типа данных с помощью того, что известно как исчерпывающее сопоставление шаблонов.  Это чрезвычайно мощный вариант для корректности, и его можно использовать для "точности" того, что обычно является проблемой времени выполнения во время компиляции.

[!code-fsharp[PatternMatching](~/samples/snippets/fsharp/tour.fs#L705-L742)]

Что вы, возможно, заметили, это использование `_` шаблона.  Это называется [шаблоном с подстановочными знаками](./language-reference/pattern-matching.md#wildcard-pattern), который позволяет сказать: «я не волнует что-то, что происходит».  Хотя это удобно, вы можете случайно обойти полную проверку соответствия шаблонов и больше не использовать преимущества, если не соблюдать осторожность при использовании `_` .  Он лучше всего подходит, если вы не следите за определенными фрагментами составного типа при сопоставлении шаблонов или итоговым предложением при перечислении всех осмысленных вариантов в выражении сопоставления шаблонов.

В следующем примере `_` используется вариант при сбое операции синтаксического анализа.

[!code-fsharp[PatternMatching](~/samples/snippets/fsharp/tour.fs#L744-L762)]

[Активные шаблоны](./language-reference/active-patterns.md) — это еще одна мощная конструкция, используемая с сопоставлением шаблонов.  Они позволяют секционировать входные данные в пользовательские формы, разбивая их на сайте вызова соответствия шаблону.  Они также могут быть параметризованы, тем самым позволяя определять секцию как функцию.  Расширение предыдущего примера для поддержки активных шаблонов выглядит примерно так:

[!code-fsharp[ActivePatterns](~/samples/snippets/fsharp/tour.fs#L764-L786)]

## <a name="optional-types"></a>Необязательные типы

Одним из особых случаев для размеченных типов объединений является тип Option, который полезен, так как он является частью основной библиотеки F #.

[Тип параметра](./language-reference/options.md) — это тип, представляющий один из двух вариантов: значение или ничего вообще.  Он используется в любом сценарии, где значение может быть или не получено из определенной операции.  Тогда вы назначите вам учитывать оба варианта, сделав его проблемой во время компиляции, а не заботу среды выполнения.  Они часто используются в интерфейсах API `null` , где используется для представления «Nothing», что устраняет необходимость `NullReferenceException` во многих обстоятельствах.

[!code-fsharp[Options](~/samples/snippets/fsharp/tour.fs#L789-L814)]

## <a name="units-of-measure"></a>Единицы измерения

Одной из уникальных функций системы типов F # является возможность предоставления контекста для числовых литералов через единицы измерения.

[Единицы измерения](./language-reference/units-of-measure.md) позволяют связать числовой тип с единицей, например в метрах, а функции выполняют работу с единицами, а не с числовыми литералами.  Это позволяет компилятору проверять, что типы числовых литералов имеют смысл в определенном контексте, тем самым устраняя ошибки времени выполнения, связанные с этим типом работы.

[!code-fsharp[UnitsOfMeasure](~/samples/snippets/fsharp/tour.fs#L817-L842)]

Основная библиотека F # определяет множество типов единиц СИ и преобразования единиц.  Чтобы узнать больше, ознакомьтесь с [пространством имен FSharp. Data. унитсистемс. si. унитсимболс](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-data-unitsystems-si-unitsymbols.html).

## <a name="classes-and-interfaces"></a>Классы и интерфейсы

В F # также включена полная поддержка классов .NET, [интерфейсов](./language-reference/interfaces.md), [абстрактных классов](./language-reference/abstract-classes.md), [наследования](./language-reference/inheritance.md)и т. д.

[Классы](./language-reference/classes.md) — это типы, представляющие объекты .NET, которые могут иметь свойства, методы и события в качестве [членов](./language-reference/members/index.md).

[!code-fsharp[Classes](~/samples/snippets/fsharp/tour.fs#L845-L880)]

Определение универсальных классов также очень просто.

[!code-fsharp[Classes](~/samples/snippets/fsharp/tour.fs#L883-L908)]

Для реализации интерфейса можно использовать либо `interface ... with` синтаксис, либо [выражение объекта](./language-reference/object-expressions.md).

[!code-fsharp[Classes](~/samples/snippets/fsharp/tour.fs#L911-L934)]

## <a name="which-types-to-use"></a>Какие типы использовать

Наличие классов, записей, размеченных объединений и кортежей приводит к важному вопросу: что следует использовать?  Как и многие все это в жизни, ответ зависит от обстоятельств.

Кортежи отлично подходят для возвращения нескольких значений из функции и использования специального статистического выражения значений в качестве самого значения.

Записи — это «шаг с заходом» из кортежей, имеющих именованные метки и поддержку необязательных элементов.  Они отлично подходят для формальностей представления данных во время передачи по программе.  Так как они имеют структурное равенство, их легко использовать при сравнении.

Размеченные объединения имеют много использования, но основное преимущество заключается в том, чтобы их можно было использовать в сочетании с сопоставлением шаблонов для учета всех возможных "фигур", которые могут иметь данные.  

Классы отлично подходят для огромного числа причин, например, когда необходимо представить информацию, а также привязать эту информацию к функциональным возможностям.  Как правило, при наличии функциональности, которая концептуально привязана к некоторым данным, использование классов и принципов объектно-ориентированного программирования является большим преимуществом.  Классы также являются предпочтительным типом данных при взаимодействии с C# и Visual Basic, так как эти языки используют классы практически для всех.

## <a name="next-steps"></a>Next Steps

Теперь, когда вы видели некоторые основные возможности языка, вы должны быть готовы к написанию первых программ на F #!  Ознакомьтесь [Начало работы](get-started/index.md) , чтобы узнать, как настроить среду разработки и написать код.

Дальнейшие действия для изучения могут быть любыми, но мы рекомендуем ознакомиться с [функциональным программированием в F #](./introduction-to-functional-programming/index.md) , чтобы приступить к работе с основными понятиями функционального программирования.  Они необходимы для создания надежных программ в F #.

Кроме того, ознакомьтесь со [справочником по языку f #](./language-reference/index.md) , чтобы просмотреть исчерпывающую коллекцию концептуального содержимого на F #.
