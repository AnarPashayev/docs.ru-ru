---
title: 'Начало работы с F # в Visual Studio для Mac'
description: 'Узнайте, как использовать F # с Visual Studio для Mac.'
ms.date: 07/03/2018
ms.openlocfilehash: d2ad24ad18bb31419b39508f2cf555c82fbe2e0b
ms.sourcegitcommit: 721c3e4bdbb1ea0bb420818ec944c538fe5c513a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/01/2020
ms.locfileid: "96437993"
---
# <a name="get-started-with-f-in-visual-studio-for-mac"></a>Начало работы с F # в Visual Studio для Mac

В интегрированной среде разработки Visual Studio для Mac поддерживаются F # и средства Visual F#. Убедитесь, что [установлен Visual Studio для Mac](install-fsharp.md#install-f-with-visual-studio-for-mac).

## <a name="creating-a-console-application"></a>Создание консольного приложения

Одним из самых основных проектов в Visual Studio для Mac является консольное приложение.  Вот как это сделать.  После открытия Visual Studio для Mac:

1. В меню **файл** укажите пункт **создать решение**.

2. В диалоговом окне Новый проект есть два разных шаблона для консольного приложения.  В другом > .NET, предназначенный для .NET Framework.  Другой шаблон находится в приложении .NET Core — >, предназначенном для .NET Core.  В этой статье должен работать один из шаблонов.

3. В разделе консольное приложение при необходимости измените C# на F #.  Нажмите кнопку **Далее** , чтобы перейти вперед.  

4. Присвойте проекту имя и выберите нужные параметры для приложения.  Обратите внимание, что панель предварительного просмотра находится сбоку экрана, где отображается структура каталогов, которая будет создана на основе выбранных параметров.  

5. Нажмите кнопку **Создать**.  Теперь в обозреватель решений должен отобразиться проект F #.

## <a name="writing-your-code"></a>Написание кода

Приступим к работе, сначала напишем некоторый код.  Убедитесь, что `Program.fs` файл открыт, и замените его содержимое следующим:

[!code-fsharp[HelloSquare](~/samples/snippets/fsharp/getting-started/hello-square.fs)]

В предыдущем примере кода определена функция, `square` которая принимает входные данные с именем `x` и умножает ее на саму себя.  Поскольку F # использует [вывод типа](../language-reference/type-inference.md), тип `x` не требуется указывать.  Компилятор F # понимает типы, в которых умножение является допустимым, и присвоит тип в `x` зависимости от того, как `square` вызывается.  Если навести указатель мыши на `square` , вы увидите следующее:

```console
val square: x:int -> int
```

Это называется сигнатурой типа функции.  Его можно прочитать следующим образом: "Square — это функция, которая принимает целое число с именем" x "и создает целое число".  Обратите внимание, что компилятор выдавал `square` `int` тип для Now, так как умножение не является универсальным для *всех* типов, а является универсальным по отношению к закрытому набору типов.  На этом этапе мы выбрали компилятор F #, но настроите `int` сигнатуру типа, если вызов осуществляется `square` с использованием другого типа входных данных, например `float` .

Определена другая функция, `main` , которая снабжена `EntryPoint` атрибутом, чтобы сообщить компилятору F # о том, что должно начаться выполнение программы.  Он соответствует тому же соглашению, что и другие [языки программирования в стиле C](https://en.wikipedia.org/wiki/Entry_point#C_and_C.2B.2B), где аргументы командной строки могут передаваться в эту функцию, и возвращается целочисленный код (обычно `0` ).

В этой функции мы вызываем `square` функцию с аргументом `12` .  Затем компилятор F # присваивает типу значение `square` `int -> int` (то есть функция, которая принимает `int` и создает объект `int` ).  Вызов `printfn` — это форматированная функция печати, которая использует строку форматирования, аналогичную языку программирования в стиле C, параметры, соответствующие указанным в строке формата, а затем выводят результат и новую строку.

## <a name="running-your-code"></a>Выполнение кода

Можно запустить код и просмотреть результаты, щелкнув **запустить** в меню верхнего уровня, а затем **запустить без отладки**.  Это приведет к запуску программы без отладки и позволяет просмотреть результаты.

Теперь в окне консоли, которое Visual Studio для Mac выводится на экран, должны отобразиться следующие сведения:

```console
12 squared is 144!
```

Поздравляем!  Вы создали первый проект F # в Visual Studio для Mac, написали функцию F #, выпечатал результаты вызова этой функции, и запустите проект, чтобы увидеть некоторые результаты.

## <a name="using-f-interactive"></a>Использование F# Interactive

Одной из лучших функций Visual F# инструментов в Visual Studio для Mac является окно F# Interactive.  Он позволяет отправить код в процесс, в котором можно вызвать этот код и просмотреть результат в интерактивном режиме.

Чтобы приступить к работе, выделите `square` функцию, определенную в коде.  Затем в меню верхнего уровня щелкните **Edit (изменить** ).  Затем выберите **Отправить выделенный фрагмент в F# Interactive**.  Это приведет к выполнению кода в окне F# Interactive.  Кроме того, можно щелкнуть выделенный фрагмент правой кнопкой мыши и выбрать пункт **Отправить выделенный фрагмент в F# Interactive**.  В нем должно отобразиться окно F# Interactive.

```console
>

val square : x:int -> int

>
```

Здесь показана та же сигнатура функции для `square` функции, которую вы видели ранее при наведении указателя мыши на функцию.  Так как `square` теперь определен в F# Interactive процессе, его можно вызвать с различными значениями:

```console
> square 12;;
val it : int = 144
>square 13;;
val it : int = 169
```

Эта функция выполняет функцию, привязывает результат к новому имени `it` и отображает тип и значение `it` .  Обратите внимание, что каждая строка должна заканчиваться на `;;` .  Это то, как F# Interactive знает о завершении вызова функции.  В F# Interactive можно также определить новые функции:

```console
> let isOdd x = x % 2 <> 0;;

val isOdd : x:int -> bool

> isOdd 12;;
val it : bool = false
```

Приведенный выше объект определяет новую функцию, `isOdd` которая принимает `int` и проверяет, нечетна ли она!  Эту функцию можно вызвать, чтобы увидеть, что она возвращает с различными входными данными.  Функции можно вызывать внутри вызовов функций:

```console
> isOdd (square 15);;
val it : bool = true
```

Можно также использовать [оператор переадресации канала](../language-reference/symbol-and-operator-reference/index.md) для передачи значения в две функции:

```console
> 15 |> square |> isOdd;;
val it : bool = true
```

Оператор переадресации канала и многое другое рассматривается в последующих руководствах.

Это лишь краткий обзор того, что можно сделать с помощью F# Interactive.  Дополнительные сведения см. в [интерактивном программировании с помощью F #](../tools/fsharp-interactive/index.md).

## <a name="next-steps"></a>Дальнейшие действия

Если вы еще этого не сделали, ознакомьтесь с [обзором f #](../tour.md), в котором рассматриваются некоторые основные функции языка f #.  Вы получите обзор некоторых возможностей F # и предоставьте достаточное количество примеров кода, которые можно скопировать в Visual Studio для Mac и выполнить.  Кроме того, существуют некоторые отличные внешние ресурсы, которые можно использовать с помощью [инструкции по F #](../index.yml).

## <a name="see-also"></a>См. также раздел

- [Руководство по языку F#](../index.yml)
- [Обзор языка F#](../tour.md)
- [Справочник по языку F#](../language-reference/index.md)
- [Определение типа](../language-reference/type-inference.md)
- [Справочник по символам и операторам](../language-reference/symbol-and-operator-reference/index.md)
