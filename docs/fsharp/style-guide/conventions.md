---
title: Соглашения о написании кода на F#
description: Дополнительные общие рекомендации и способы, при написании F# кода.
ms.date: 05/14/2018
ms.openlocfilehash: c8df654cbb94fff1ef7ffb909655439398f30bf5
ms.sourcegitcommit: bab17fd81bab7886449217356084bf4881d6e7c8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/26/2019
ms.locfileid: "67402368"
---
# <a name="f-coding-conventions"></a>Соглашения о написании кода на F#

Из опыта работы с большими формулируются следующим соглашениям F# базы кода. [Хорошее пять принципов F# кода](index.md#five-principles-of-good-f-code) являются основой каждой рекомендации. Они связаны с [ F# рекомендации по проектированию компонентов](component-design-guidelines.md), но подходят для любого F# кода, не только компонентов, таких как библиотеки.

## <a name="organizing-code"></a>Упорядочение кода

F#два основных способа, чтобы упорядочить код функции: модулей и пространств имен. Они похожи, но имеют следующие отличия:

* Пространства имен компилируются как пространства имен .NET. Модули обычно компилируются как статических классов.
* Пространства имен всегда являются верхнего уровня. Модули могут быть верхнего уровня и вложенные в другие модули.
* Пространства имен могут охватывать несколько файлов. Модули не могут.
* Модули можно снабдить `[<RequireQualifiedAccess>]` и `[<AutoOpen>]`.

Следующие рекомендации поможет вам использовать их для организации кода.

### <a name="prefer-namespaces-at-the-top-level"></a>Предпочитать пространства имен верхнего уровня

Для любой доступной для использования кода пространства имен, предпочтительную модули на верхнем уровне. Так как они компилируются как пространства имен .NET, они готовых к использованию с помощью C# с помощью проблем.

```fsharp
// Good!
namespace MyCode

type MyClass() =
    ...
```

С помощью модуля верхнего уровня может не отличаться при вызове только из F#, но для C# потребителей, вызывающие объекты могут удивить необходимости квалификации `MyClass` с `MyCode` модуля.

```fsharp
// Bad!
module MyCode

type MyClass() =
    ...
```

### <a name="carefully-apply-autoopen"></a>Тщательно применить `[<AutoOpen>]`

`[<AutoOpen>]` Конструкции можно повредить области доступных вызывающим объектам, и ответ на что-то образуется «magic». Обычно это не хорошо. Исключением из этого правила является F# основной библиотеки сам (хотя этот факт является также немного противоречивым).

Тем не менее это удобный способ, при наличии вспомогательную функциональность для открытый API, который вы хотите организовать отдельно от общедоступного интерфейса API.

```fsharp
module MyAPI =
    [<AutoOpen>]
    module private Helpers =
        let helper1 x y z =
            ...

    let myFunction1 x =
        let y = ...
        let z = ...

        helper1 x y z
```

Это позволяет четко отдельные реализации сведения из открытого API-интерфейса функции без необходимости каждый раз, когда она вызывается полного определения вспомогательного метода.

Кроме того, предоставление методов расширения и построители выражений на уровне пространства имен может быть аккуратно выражен `[<AutoOpen>]`.

### <a name="use-requirequalifiedaccess-whenever-names-could-conflict-or-you-feel-it-helps-with-readability"></a>Используйте `[<RequireQualifiedAccess>]` каждый раз, когда может вызвать конфликт имен, или вы считаете, что организации могут работать с удобства чтения

Добавление `[<RequireQualifiedAccess>]` атрибут к модулю указывает, что модуль не может быть открыт, и необходимость явной ссылки на элементы модуля полного доступа. Например `Microsoft.FSharp.Collections.List` модуля с этим атрибутом.

Это полезно в том случае, если функции и значения в модуле имеют имена, которые могут конфликтовать с именами в других модулях. Требуется метод доступа может значительно увеличивать долгосрочной поддержки и развиваемости библиотеки.

```fsharp
[<RequireQualifiedAccess>]
module StringTokenization =
    let parse s = ...

...

let s = getAString()
let parsed = StringTokenization.parse s // Must qualify to use 'parse'
```

### <a name="sort-open-statements-topologically"></a>Сортировка `open` инструкций топологически

В F#, порядок имеет значение объявления, в том числе с `open` инструкций. В отличие от C#, где эффект `using` и `using static` не зависит от порядка этих инструкций в файле.

В F#, открывается в область элементов можно скрывать другие уже присутствует. Это означает, что изменение порядка `open` операторы могут привести к изменению значения кодов. В результате любой произвольный сортировки всех `open` инструкций (например, буквенно-цифровом порядке) обычно не рекомендуется, иначе создать другое поведение, можно ожидать.

Вместо этого рекомендуется отсортировать их [топологически](https://en.wikipedia.org/wiki/Topological_sorting); то есть заказать вашей `open` операторов в порядке, в котором _слои_ определенные системы. Это буквенно-цифровых, сортировки в различных уровней топологическом мощностями.

Например, вот топологическую сортировку для F# файл открытого API компилятора службы:

```fsharp
namespace Microsoft.FSharp.Compiler.SourceCodeServices

open System
open System.Collections.Generic
open System.Collections.Concurrent
open System.Diagnostics
open System.IO
open System.Reflection
open System.Text

open Microsoft.FSharp.Compiler
open Microsoft.FSharp.Compiler.AbstractIL
open Microsoft.FSharp.Compiler.AbstractIL.Diagnostics
open Microsoft.FSharp.Compiler.AbstractIL.IL
open Microsoft.FSharp.Compiler.AbstractIL.ILBinaryReader
open Microsoft.FSharp.Compiler.AbstractIL.Internal
open Microsoft.FSharp.Compiler.AbstractIL.Internal.Library

open Microsoft.FSharp.Compiler.AccessibilityLogic
open Microsoft.FSharp.Compiler.Ast
open Microsoft.FSharp.Compiler.CompileOps
open Microsoft.FSharp.Compiler.CompileOptions
open Microsoft.FSharp.Compiler.Driver
open Microsoft.FSharp.Compiler.ErrorLogger
open Microsoft.FSharp.Compiler.Infos
open Microsoft.FSharp.Compiler.InfoReader
open Microsoft.FSharp.Compiler.Lexhelp
open Microsoft.FSharp.Compiler.Layout
open Microsoft.FSharp.Compiler.Lib
open Microsoft.FSharp.Compiler.NameResolution
open Microsoft.FSharp.Compiler.PrettyNaming
open Microsoft.FSharp.Compiler.Parser
open Microsoft.FSharp.Compiler.Range
open Microsoft.FSharp.Compiler.Tast
open Microsoft.FSharp.Compiler.Tastops
open Microsoft.FSharp.Compiler.TcGlobals
open Microsoft.FSharp.Compiler.TypeChecker
open Microsoft.FSharp.Compiler.SourceCodeServices.SymbolHelpers

open Internal.Utilities
open Internal.Utilities.Collections
```

Обратите внимание на то, что разрыв строки отделяет топологическом слои с каждым слоем сортируемых буквенно-цифровом порядке позже. Это четко организует кода без случайного затенение значения.

## <a name="use-classes-to-contain-values-that-have-side-effects"></a>Используйте классы для хранения значения, которые имеют побочные эффекты

Существует много случаев, когда инициализация значение может иметь побочные эффекты, такие как создание экземпляра контекста базы данных или других удаленных ресурсов. Соблазнительно для инициализации таких объектов, в модуль и использовать его в последующих функций:

```fsharp
// This is bad!
module MyApi =
    let dep1 = File.ReadAllText "/Users/{your name}/connectionstring.txt"
    let dep2 = Environment.GetEnvironmentVariable "DEP_2"

    let private r = Random()
    let dep3() = r.Next() // Problematic if multiple threads use this

    let function1 arg = doStuffWith dep1 dep2 dep3 arg
    let function2 arg = doSutffWith dep1 dep2 dep3 arg
```

Это часто рекомендуется по нескольким причинам:

Во-первых, Конфигурация приложения помещается в базе кода с `dep1` и `dep2`. Этого сложно поддерживать в больших базах кода.

Во-вторых, статически инициализируемыми данные не должны включать значения, которые не являются потокобезопасными, если компонент будет сам будет использовать несколько потоков. Очевидно, что нарушено `dep3`.

Наконец инициализации модуля компилирует в статический конструктор для всего блока компиляции. Если возникают ошибки при инициализации значения привязки let в этом модуле, он объявляется в качестве `TypeInitializationException` , сохраняется в кэше в течение всего времени существования приложения. Это может быть трудно диагностировать. Обычно имеется внутреннее исключение, можно попытаться строить заключения, но если не существует, то есть не о том, что основной причиной.

Вместо этого используйте просто простой класс для хранения зависимости:

```fsharp
type MyParametricApi(dep1, dep2, dep3) =
    member __.Function1 arg1 = doStuffWith dep1 dep2 dep3 arg1
    member __.Function2 arg2 = doStuffWith dep1 dep2 dep3 arg2
```

Это позволяет следующее:

1. Помещает все зависимые состояния за пределами самого API.
2. Конфигурации теперь может выполняться за пределами API.
3. Ошибки при инициализации для зависимых значений не являются скорее всего, как `TypeInitializationException`.
4. API удобен для тестирования.

## <a name="error-management"></a>Управление обработкой ошибок

Управление обработкой ошибок в больших системах является сложной и огромным задачей, и нет не silver маркеры в обеспечении систем устойчивы к сбоям и вести себя хорошо. Следующие рекомендации следует приводятся рекомендации по это сложно пространство.

### <a name="represent-error-cases-and-illegal-state-in-types-intrinsic-to-your-domain"></a>Представляют сценарии ошибок и состояния в типах, характерными для вашего домена

С помощью [размеченные объединения](../language-reference/discriminated-unions.md), F# дает возможность представлять состояние неисправных программы в вашей системе типов. Пример:

```fsharp
type MoneyWithdrawalResult =
    | Success of amount:decimal
    | InsufficientFunds of balance:decimal
    | CardExpired of DateTime
    | UndisclosedFailure
```

В этом случае тремя способами известных, списывая деньги с банковского счета может завершиться ошибкой. Каждый вариант ошибка представить в типе и можно таким образом обработаны безопасно в программе.

```fsharp
let handleWithdrawal amount =
    let w = withdrawMoney amount
    match w with
    | Success am -> printfn "Successfully withdrew %f" am
    | InsufficientFunds balance -> printfn "Failed: balance is %f" balance
    | CardExpired expiredDate -> printfn "Failed: card expired on %O" expiredDate
    | UndisclosedFailure -> printfn "Failed: unknown"
```

Как правило, если можно моделировать различные способы что-то может **ошибкой** в вашем домене, то код обработки ошибок больше не рассматривается как что-то приходится работать с помимо потока программы. Он является просто частью нормального выполнения программы и не считается **исключительных**. Существует два основных преимущества этого:

1. Это упрощает поддержку вашего домена по мере изменения.
2. Сценарии ошибок легче модульного теста.

### <a name="use-exceptions-when-errors-cannot-be-represented-with-types"></a>Используйте исключения, если ошибки не могут быть представлены с типами

Не все ошибки могут быть представлены в домене проблему. Эти виды ошибок *исключительных* по своей природе, поэтому возможность вызывать и перехватывать исключения в F#.

Во-первых, рекомендуется ознакомиться с [правила разработки исключений](../../standard/design-guidelines/exceptions.md). Это также применимо к F#.

Создает в главном F# для целей возникновения исключений следует учитывать в следующем порядке предпочтения:

| Функция | Синтаксис | Цель |
|----------|--------|---------|
| `nullArg` | `nullArg "argumentName"` | Вызывает `System.ArgumentNullException` с заданным именем аргумента. |
| `invalidArg` | `invalidArg "argumentName" "message"` | Вызывает `System.ArgumentException` с заданным именем аргумента и сообщением. |
| `invalidOp` | `invalidOp "message"` | Вызывает `System.InvalidOperationException` с заданным сообщением. |
|`raise`| `raise (ExceptionType("message"))` | Универсальный механизм для создания исключений. |
| `failwith` | `failwith "message"` | Вызывает `System.Exception` с заданным сообщением. |
| `failwithf` | `failwithf "format string" argForFormatString` | Вызывает `System.Exception` с сообщением, определить с помощью строки формата и ее входными данными. |

Используйте `nullArg`, `invalidArg` и `invalidOp` в качестве механизма throw `ArgumentNullException`, `ArgumentException` и `InvalidOperationException` при необходимости.

`failwith` И `failwithf` функции обычно следует избегать, так как они вызывают базовый `Exception` тип, не определенное исключение. Согласно [правила разработки исключений](../../standard/design-guidelines/exceptions.md), требуется повысить более конкретные исключения, когда это возможно.

### <a name="using-exception-handling-syntax"></a>Используя синтаксис обработки исключений

F#поддерживает шаблоны исключение через `try...with` синтаксис:

```fsharp
try
    tryGetFileContents()
with
| :? System.IO.FileNotFoundException as e -> // Do something with it here
| :? System.Security.SecurityException as e -> // Do something with it here
```

Согласование функциональные возможности для выполнения при возникновении исключения с сопоставлением шаблонов может быть немного сложнее, если вы хотите максимально оптимизировать код. Один из таких способов для обработки этого является использование [активные шаблоны](../language-reference/active-patterns.md) позволяет функции группами, окружающие как случай ошибки с исключением сам. Например может использовать API, который, когда он создает исключение, заключает ценную информацию в метаданные исключения. Распаковывание полезное значение в теле записанного исключения внутри активный шаблон и возврат, что значение может быть полезным в некоторых ситуациях.

### <a name="do-not-use-monadic-error-handling-to-replace-exceptions"></a>Не используйте результата вычисления обработку ошибок, чтобы заменить исключения

Исключения представляются отчасти запретным в функциональном программировании. Действительно исключения нарушать чистоты, поэтому можно безопасно рассматривать их работы не совсем. Тем не менее это не учитывает реальность, где должен быть запущен код и среды выполнения, могут возникать ошибки. В общем случае следует писать код на предположении, что большинство параметров являются чисто ни общий, чтобы свести к минимуму неприятных сюрпризов.

Очень важно учесть следующие основные преимущества/аспекты исключений по отношению к их релевантность и адекватность в среду выполнения .NET и версий на разных языках экосистемы в целом:

1. Они содержат подробные диагностические сведения, которые очень полезно при отладке проблемы.
2. Они вполне понятной средой выполнения и других языках .NET.
3. Они могут уменьшить количество значительные стандартного по сравнению с кодом, который выходит за пределы пути *избежать* исключения путем реализации некоторого подмножества их семантику на основе ad-hoc.

Это третья точка важно. Для нетривиальных сложные операции не сможет использовать исключения может привести к работе со структурами, следующим образом:

```fsharp
Result<Result<MyType, string>, string list>
```

Может легко привести к уязвимости кода сопоставления шаблонов в «stringly типизированные» ошибки:

```fsharp
let result = doStuff()
match result with
| Ok r -> ...
| Error e ->
    if e.Contains "Error string 1" then ...
    elif e.Contains "Error string 2" then ...
    else ... // Who knows?
```

Кроме того он может показаться проглотить любое исключение в требуемом для функции «простой», возвращающий тип «лучше»:

```fsharp
// This is bad!
let tryReadAllText (path : string) =
    try System.IO.File.ReadAllText path |> Some
    with _ -> None
```

К сожалению `tryReadAllText` может создавать многочисленные исключения, зависимости бесчисленного множества вещей, которые могут возникать в файловой системе, и этот код немедленно отменяет любые сведения о что могло фактически пойти в вашей среде. Если необходимо заменить этот код с типом результатов, затем вы возвращаетесь назад «stringly типизированные» ошибки синтаксического анализа сообщений:

```fsharp
// This is bad!
let tryReadAllText (path : string) =
    try System.IO.File.ReadAllText path |> Ok
    with e -> Error e.Message

let r = tryReadAllText "path-to-file"
match r with
| Ok text -> ...
| Error e ->
    if e.Contains "uh oh, here we go again..." then ...
    else ...
```

А сам объект исключения в `Error` конструктор просто заставляет должным образом работать с типом исключения во время вызова, а не в функции. Это фактически создает проверяемые исключения, которые являются заведомо unfun дело как вызывающего объекта API.

Является хорошей альтернативой приведенных выше примерах для перехвата *конкретных* исключений и возврат осмысленное значение в контексте этого исключения. При изменении `tryReadAllText` функцию следующим образом, `None` имеет большее значение:

```fsharp
let tryReadAllTextIfPresent (path : string) =
    try System.IO.File.ReadAllText path |> Some
    with :? FileNotFoundException -> None
```

Вместо того, как catch-all, эта функция будет теперь правильно обрабатывать случаи, когда файл не найден и назначить значение, возвращаемое значение. Это возвращаемое значение можно сопоставить в этом случае ошибка во время не отменяя все контекстные сведения или принудительное вызывающие объекты для обработки случая, которая может не относиться в этот момент в коде.

Типы, такие как `Result<'Success, 'Error>` наиболее подходящие для основных операций, где они не являются вложенными, и F# дополнительные типы идеальны для представляющий когда что-то удалось возвращения *что-то* или *ничего не*. Они не являются заменой для исключений, хотя и не должны использоваться с целью для замены исключения. Вместо этого они должны применяться осмотрительно адреса определенных аспектов исключения и ошибки политики управления целевых способами.

## <a name="partial-application-and-point-free-programming"></a>Частичное применение и программирование без использования точки

F#поддерживает частичное применение и, следовательно, различные способы программы в стиле без использования точки. Это может быть использовано для повторного использования кода в модуль или что-то реализации, но обычно это не что-то для предоставления публично. Как правило программирование без использования точки не тем, само по себе и можно добавить cognitive образуют серьезный барьер для тех, кто не занимается стиль.

### <a name="do-not-use-partial-application-and-currying-in-public-apis"></a>Не используйте частичное применение и каррирование общедоступных интерфейсов API

За исключением мало использование частичное применение общедоступных интерфейсов API может запутать пользователей. Как правило `let`-привязанного значения в F# код **значения**, а не **значений функций**. Смешивание друг с другом, значений и значений функций может привести к сохранение небольшое количество строк кода за счет совсем немного тратить время и силы, особенно в том случае, если совместно с операторами, такие как `>>` для создания функции.

### <a name="consider-the-tooling-implications-for-point-free-programming"></a>Следует учитывать влияние средств для программирования без использования точки

Каррированные функции метки не для их аргументов. Это имеет последствия для средств. Рассмотрим следующие две функции:

```fsharp
let func name age =
    printfn "My name is %s and I am %d years old!" name age

let funcWithApplication =
    printfn "My name is %s and I am %d years old!"
```

Оба являются допустимым функции, но `funcWithApplication` Каррированная функция. При наведении указателя мыши над их типы, в редакторе, вы видите это:

```fsharp
val func : name:string -> age:int -> unit

val funcWithApplication : (string -> int -> unit)
```

Во время вызова, всплывающие подсказки в средствах, таких как Visual Studio не даст значимую информацию о том, что `string` и `int` фактически описывают типы входных данных.

При возникновении кода, без точки, такие как `funcWithApplication` , доступной для использования, рекомендуется выполнить полный η-расширения, чтобы средства можно обратить ваше внимание на значимые имена для аргументов.

Кроме того отладка кода без точки может оказаться сложной задачей, если не невозможной. Средства отладки зависит от значений, связанных с именами (например, `let` привязки) таким образом, вы можете проверить промежуточные значения во время выполнения. Если код содержит значения, не проверять, нет ничего для отладки. В будущем, средства отладки, могут видоизменяться синтезировать эти значения, на основании путей к предыдущим, но это не рекомендуется hedge ваша ставка на *потенциальных* функции отладки.

### <a name="consider-partial-application-as-a-technique-to-reduce-internal-boilerplate"></a>Рассмотрим частичное применение как методика, чтобы уменьшить количество внутренних стандартного

В отличие от предыдущей точки частичное применение – это замечательное средство для сокращения стандартный внутри приложения или более внутренних API. Может быть полезным для модульного тестирования реализации более сложных интерфейсов API, в которых шаблона является неудобной, поскольку для работы с. Например, в следующем коде показано, как это можно сделать какие наиболее макетирования платформы позволяют без перевода внешнюю зависимость такую платформу и необходимости изучать, связанный с ним заказному API.

Например рассмотрим следующие топографии решения:

```
MySolution.sln
|_/ImplementationLogic.fsproj
|_/ImplementationLogic.Tests.fsproj
|_/API.fsproj
```

`ImplementationLogic.fsproj` Например, может предоставлять код:

```fsharp
module Transactions =
    let doTransaction txnContext txnType balance =
        ...

type Transactor(ctx, currentBalance) =
    member __.ExecuteTransaction(txnType) =
        Transactions.doTransaction ctx txtType currentBalance
        ...
```

Модульное тестирование `Transactions.doTransaction` в `ImplementationLogic.Tests.fsproj` прост:

```fsharp
namespace TransactionsTestingUtil

open Transactions

module TransactionsTestable =
    let getTestableTransactionRoutine mockContext = Transactions.doTransaction mockContext
```

Частично применение `doTransaction` благодаря макетирования контекста объекта можно вызвать функцию во всех модульных тестов без необходимости создавать макеты контекста каждый раз:

```fsharp
namespace TransactionTests

open Xunit
open TransactionTypes
open TransactionsTestingUtil
open TransactionsTestingUtil.TransactionsTestable

let testableContext =
    { new ITransactionContext with
        member __.TheFirstMember() = ...
        member __.TheSecondMember() = ... }

let transactionRoutine = getTestableTransactionRoutine testableContext

[<Fact>]
let ``Test withdrawal transaction with 0.0 for balance``() =
    let expected = ...
    let actual = transactionRoutine TransactionType.Withdraw 0.0
    Assert.Equal(expected, actual)
```

Этот способ не следует применять универсально для всей базы кода, но это хороший способ уменьшить количество стандартного для сложных внутренние компоненты и модульного тестирования эти внутренние компоненты.

## <a name="access-control"></a>Управление доступом

F#есть несколько вариантов для [управление доступом](../language-reference/access-control.md), унаследованное от того, что доступно в среде выполнения .NET. Это не просто можно использовать для типов — их можно использовать для функций, слишком.

* Предпочитать отличных`public` типов и членов, пока она не понадобится, чтобы быть доступной для использования. Это также минимизирует какие несколько потребителей для.
* Старайтесь, чтобы все вспомогательные функции `private`.
* Рассмотрите возможность использования `[<AutoOpen>]` на частный модуль вспомогательные функции, если они становятся многочисленные.

## <a name="type-inference-and-generics"></a>Распознавание типов и обобщения

Вывод типа, которые можно сохранить массу стандартного ввода. И Автоматическое обобщение в F# компилятор может помочь написать более общий код с почти никаких дополнительных действий со стороны пользователя. Тем не менее эти функции не глобально.

* Рассмотрите возможность добавления меток имена аргументов с помощью явных типов общедоступных интерфейсов API и не следует полагаться на определение типа для этого.

    Причина в том, что **вы** должны находиться в элемент управления фигуры API, не компилятор. Несмотря на то, что компилятор может сделать нормально задания на вывод типов для вас, это может быть форма изменения API, если внутренние компоненты, которые она зависит от были изменены типы. Это может быть то, что нужно, но это почти наверняка приведет к критически важное изменение API, подчиненные потребители придется иметь дело с. Вместо этого Если вы явным образом управления формой создаваемого общедоступного API, можно управлять эти критические изменения. В терминах DDD это может рассматриваться как уровень защиты от повреждения.

* Рекомендуется дать понятное имя для универсальных аргументов.

    Если вы создаете по-настоящему универсальный код, который не относится к определенному домену, понятное имя может помочь другим программистам, основные сведения о домене, с которыми они работают в. Например, параметр типа с именем `'Document` в контексте взаимодействия с документом базы данных дает яснее понять, что типы универсального документа может быть принят функцией или член, вы работаете.

* Следует назвать параметров универсального типа с PascalCase.

    Это общий способ для выполнения задач в .NET, в том случае, поэтому рекомендуется использовать PascalCase, а не snake_case или camelCase.

Наконец, Автоматическое обобщение не всегда отдушина для тех, кто еще не работали с F# или большой базы кода. Есть время и силы в использовании компонентов, которые являются обобщенными. Кроме того Если автоматически универсальной функции не используются с различными типами входных (только в том случае, если они предназначены для использования таким образом не говоря), то не имеет смысла реальных им быть универсальным в определенный момент времени. Всегда учитывайте, если код, который вы пишете будет фактически преимущества, связанные с универсальным.

## <a name="performance"></a>Производительность

F#значения являются неизменяемыми по умолчанию, что позволяет избежать определенные классы ошибок (особенно этих включающие параллельная обработка и параллелизм). Однако в некоторых случаях для достижения оптимальной (или даже разумного) эффективность времени выполнения или выделения памяти, диапазон рабочих может лучше всего реализовать с помощью встроенного мутаций состояния. Это можно сделать в выраженного ими согласия с F# с `mutable` ключевое слово.

Однако использование `mutable` в F# может показаться соответствует функциональной чистоты. Это нормально, если установить значение ожидания со чистоты для [ссылочной прозрачности](https://en.wikipedia.org/wiki/Referential_transparency). Ссылочной прозрачности - не чистоты — это конечная цель при написании F# функции. Это позволяет писать функциональной интерфейс через реализацию на основе изменений для критического кода на производительности.

### <a name="wrap-mutable-code-in-immutable-interfaces"></a>Поместите код с изменяемым в неизменяемом интерфейсы

С помощью ссылочной прозрачности как целевой показатель на крайне важно написать код, который не содержит изменяемую underbelly критически важным для производительности функций. Например, в следующем коде реализуется `Array.contains` работать в F# основной библиотеки:

```fsharp
[<CompiledName("Contains")>]
let inline contains value (array:'T[]) =
    checkNonNull "array" array
    let mutable state = false
    let mutable i = 0
    while not state && i < array.Length do
        state <- value = array.[i]
        i <- i + 1
    state
```

Вызов этой функции несколько раз не приводит к изменению базового массива, и ему не требуется возможность поддерживать любое изменяемое состояние, в использовании ее. Он прозрачен со ссылочным, несмотря на то, что почти все строки кода в нем используется изменений.

### <a name="consider-encapsulating-mutable-data-in-classes"></a>Рассмотрите возможность инкапсуляции изменяемые данные в классах

В предыдущем примере использовался одной функции для инкапсуляции операций с использованием изменяемые данные. Это не всегда достаточно для более сложных наборов данных. Рассмотрим следующий набор функций:

```fsharp
open System.Collections.Generic

let addToClosureTable (key, value) (t: Dictionary<_,_>) =
    if not (t.ContainsKey(key)) then
        t.Add(key, value)
    else
        t.[key] <- value

let closureTableCount (t: Dictionary<_,_>) = t.Count

let closureTableContains (key, value) (t: Dictionary<_, HashSet<_>>) =
    match t.TryGetValue(key) with
    | (true, v) -> v.Equals(value)
    | (false, _) -> false
```

Этот код обеспечивает высокую производительность, но предоставляет структуру данных на основе изменений, что вызывающие объекты отвечают за обеспечение. Это может быть заключен в теле класса без базовых членов, которые можно изменить:

```fsharp
open System.Collections.Generic

/// The results of computing the LALR(1) closure of an LR(0) kernel
type Closure1Table() =
    let t = Dictionary<Item0, HashSet<TerminalIndex>>()

    member __.Add(key, value) =
        if not (t.ContainsKey(key)) then
            t.Add(key, value)
        else
            t.[key] <- value

    member __.Count = t.Count

    member __.Contains(key, value) =
        match t.TryGetValue(key) with
        | (true, v) -> v.Equals(value)
        | (false, _) -> false
```

`Closure1Table` Инкапсулирует базовой структуры данных на основе изменений, тем самым не выполняется принудительно вызывающих объектов для поддержания базовой структуры данных. Классы являются мощным средством для инкапсуляции данных и подпрограммы, которые создаются на основе изменений без предоставления сведений для вызывающих объектов.

### <a name="prefer-let-mutable-to-reference-cells"></a>Предпочитать `let mutable` для ссылочные ячейки

Ссылочные ячейки — это способ ссылкой на значение, а не само значение. Несмотря на то, что они могут использоваться для кода, важных для производительности, они обычно не рекомендуются. Рассмотрим следующий пример.

```fsharp
let kernels =
    let acc = ref Set.empty

    processWorkList startKernels (fun kernel ->
        if not ((!acc).Contains(kernel)) then
            acc := (!acc).Add(kernel)
        ...)

    !acc |> Seq.toList
```

Использовать ссылочную ячейку теперь «засоряет» все последующие кода по разыменовываем и повторно ссылаются на базовые данные. Вместо этого рассмотрите возможность `let mutable`:

```fsharp
let kernels =
    let mutable acc = Set.empty

    processWorkList startKernels (fun kernel ->
        if not (acc.Contains(kernel)) then
            acc <- acc.Add(kernel)
        ...)

    acc |> Seq.toList
```

Помимо единой точки изменений середине лямбда-выражения, все остальные кода, касается `acc` можно сделать таким образом, ничем не отличается для использования обычной `let`-привязан постоянное значение. Это облегчит могут изменяться со временем.

## <a name="object-programming"></a>Программирование на основе объекта

F#имеет полную поддержку для объектов и объектно ориентированные концепции (ОО). Несмотря на то, что многие концепции объектно-Ориентированный являются мощным и полезным, не все из них идеально подходят для использования. Перечисленные ниже приводятся рекомендации по категории: функции объектно-Ориентированный на высоком уровне.

**Рассмотрите возможность использования этих функций во многих ситуациях:**

* Нотация с точками (`x.Length`)
* Члены экземпляров
* Неявные конструкторы
* Статические члены
* Обозначения индексатора (`arr.[x]`)
* Именованные и необязательные аргументы
* Интерфейсы и реализации интерфейса

**Не достигают для этих функций сначала, но применить их их осмотрительно, когда они удобны для решения проблемы:**

* Перегрузка методов
* Инкапсулированный изменяемые данные
* Операторы типов
* Автосвойства
* Реализация `IDisposable` и `IEnumerable`
* Расширения типов
* События
* Структуры
* Делегаты
* перечислениям;

**Если не требуется использовать их как правило, избегайте этих функций:**

* Иерархии типов на основе наследования и реализации наследования
* Значения NULL и `Unchecked.defaultof<_>`

### <a name="prefer-composition-over-inheritance"></a>Предпочтение компоновки наследованию

[Композиции через наследование](https://en.wikipedia.org/wiki/Composition_over_inheritance) так просто издавна идиом F# можно придерживаться кода. Фундаментальный принцип — следует предоставить базовый класс и не принудительно наследовать от этого базового класса, чтобы получить функции вызывающим объектам.

### <a name="use-object-expressions-to-implement-interfaces-if-you-dont-need-a-class"></a>Выражения объекта используются для реализации интерфейсов в том случае, если класс не требуется

[Выражения объектов](../language-reference/object-expressions.md) позволяют реализовывать интерфейсы на ходу, привязывая реализованный интерфейс к значению без необходимости сделать это внутри класса. Это удобно, особенно в том случае, если вы _только_ необходимо реализовать интерфейс и не требуются для полного класса.

Например, ниже приведен код, выполняемый на [Ionide](http://ionide.io/) для предоставления действие исправления кода, если вы добавили символ, у вас нет `open` инструкции для:

```fsharp
    let private createProvider () =
        { new CodeActionProvider with
            member this.provideCodeActions(doc, range, context, ct) =
                let diagnostics = context.diagnostics
                let diagnostic = diagnostics |> Seq.tryFind (fun d -> d.message.Contains "Unused open statement")
                let res =
                    match diagnostic with
                    | None -> [||]
                    | Some d ->
                        let line = doc.lineAt d.range.start.line
                        let cmd = createEmpty<Command>
                        cmd.title <- "Remove unused open"
                        cmd.command <- "fsharp.unusedOpenFix"
                        cmd.arguments <- Some ([| doc |> unbox; line.range |> unbox; |] |> ResizeArray)
                        [|cmd |]
                res
                |> ResizeArray
                |> U2.Case1
        }
```

Так как нет необходимости для класса при взаимодействии с API кода Visual Studio, выражения объекта — идеальное средство для этого. Их также можно использовать для модульного тестирования для заглушки для интерфейса с помощью процедуры тестирования ad hoc образом.

## <a name="type-abbreviations"></a>Сокращенные обозначения типов

[Аббревиатуры типов](../language-reference/type-abbreviations.md) являются удобным способом для назначения метки для другого типа, например сигнатуру функции или более сложного типа. Например, следующий псевдоним присваивает метки что необходимо для определения вычислений с [CNTK](https://docs.microsoft.com/cognitive-toolkit/), глубокого обучения библиотеки:

```fsharp
open CNTK

// DeviceDescriptor, Variable, and Function all come from CNTK
type Computation = DeviceDescriptor -> Variable -> Function
```

`Computation` Имя является удобным способом для обозначения того, любая функция, которая совпадает с сигнатурой, он является присвоение псевдонимов. С помощью сокращенные формы типов, как это удобно и позволяет более лаконичный код.

### <a name="avoid-using-type-abbreviations-to-represent-your-domain"></a>Старайтесь не использовать сокращенные формы типов для представления вашего домена

Несмотря на то, что сокращенные формы типов удобны для присвоения имени сигнатуры функций, они могут быть путаницу при сокращение параметра других типов. Рассмотрим это сокращение.

```fsharp
// Does not actually abstract integers.
type BufferSize = int
```

Это может вызывать трудности несколькими способами:

* `BufferSize` не представляет собой абстракцию; Это просто еще одно имя для целого числа.
* Если `BufferSize` предоставляется в открытый API, его можно легко быть неправильно интерпретированы означает больше, чем просто `int`. Как правило, типы домена имеют несколько атрибутов, чтобы их и не являются типами-примитивами, например `int`. Это сокращение нарушает этого предположения.
* Регистр `BufferSize` (PascalCase) означает, что этот тип содержит дополнительные данные.
* Этот псевдоним не обеспечивает повышенный уровень четкости, по сравнению с обеспечением именованный аргумент в функцию.
* Сокращение не выразится в скомпилированного промежуточного языка; Это просто целое число, и этот псевдоним — это конструкция, во время компиляции.

```fsharp
module Networking =
    ...
    let send data (bufferSize: int) =
        ...
```

Таким образом, ловушек с сокращенные формы типов является то, что они **не** абстракции по типам, они сокращение параметра. В предыдущем примере `BufferSize` просто `int` на самом деле с нет дополнительных данных, а также все преимущества из системы типов помимо что `int` уже есть.
