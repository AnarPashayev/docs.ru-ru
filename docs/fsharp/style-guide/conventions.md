---
title: Соглашения о написании кода на F#
description: Изучите общие руководящие принципы и идиомы при написании кода F.
ms.date: 01/15/2020
ms.openlocfilehash: 7266211e501bdb52564220781e2347d1aceaf296
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401151"
---
# <a name="f-coding-conventions"></a>Соглашения о написании кода на F#

Следующие конвенции сформулированы на основе опыта работы с большими базами кодов F. [Пять принципов хорошего кода ФЗ](index.md#five-principles-of-good-f-code) являются основой каждой рекомендации. Они связаны с [руководящими принципами проектирования компонентов F,,](component-design-guidelines.md)но применимы для любого кода F, а не только компонентов, таких как библиотеки.

## <a name="organizing-code"></a>Организационный код

Фз имеет два основных способа организации кода: модули и пространства имен. Они похожи, но имеют следующие различия:

* Пространства имен компилируются как пространства имен .NET. Модули компилируются как статические классы.
* Именные пространства всегда находятся на высшем уровне. Модули могут быть на высшем уровне и вложены в другие модули.
* Пространства имен могут охватывать несколько файлов. Модули не могут.
* Модули могут `[<RequireQualifiedAccess>]` быть `[<AutoOpen>]`украшены и .

Следующие рекомендации помогут вам использовать их для организации кода.

### <a name="prefer-namespaces-at-the-top-level"></a>Предпочитаюте пространства имен на верхнем уровне

Для любого публично расходного кода пространства имен являются предпочтительными для модулей на верхнем уровне. Поскольку они компилируются как области имен .NET, они расходуются из C-класса без проблем.

```fsharp
// Good!
namespace MyCode

type MyClass() =
    ...
```

Использование модуля верхнего уровня может отличаться от вызова только от F, но для потребителей C, абоненты могут быть удивлены, имея право на доступ `MyClass` к `MyCode` модулю.

```fsharp
// Bad!
module MyCode

type MyClass() =
    ...
```

### <a name="carefully-apply-autoopen"></a>Тщательно нанесите`[<AutoOpen>]`

Конструкция `[<AutoOpen>]` может загрязнять область того, что доступно для абонентов, и ответ на то, где что-то происходит от является "волшебство". Это не очень хорошо. Исключением из этого правила является сама базовая библиотека F » (хотя этот факт также немного противоречив).

Тем не менее, это удобство, если у вас есть функция помощника для общедоступного API, который вы хотите организовать отдельно от этого общедоступного API.

```fsharp
module MyAPI =
    [<AutoOpen>]
    module private Helpers =
        let helper1 x y z =
            ...

    let myFunction1 x =
        let y = ...
        let z = ...

        helper1 x y z
```

Это позволяет чисто отделить детали реализации от общедоступного API функции без необходимости полностью квалифицировать помощника каждый раз, когда вы называете его.

Кроме того, разоблачение методов расширения и раздатчиков выражения `[<AutoOpen>]`на уровне пространства имен может быть аккуратно выражено с .

### <a name="use-requirequalifiedaccess-whenever-names-could-conflict-or-you-feel-it-helps-with-readability"></a>Используйте `[<RequireQualifiedAccess>]` всякий раз, когда имена могут конфликтовать или вы чувствуете, что это помогает с читаемостью

Добавление `[<RequireQualifiedAccess>]` атрибута к модулю указывает на то, что модуль не может быть открыт и что ссылки на элементы модуля требуют явного квалифицированного доступа. Например, `Microsoft.FSharp.Collections.List` модуль имеет этот атрибут.

Это полезно, когда функции и значения в модуле имеют имена, которые могут впротиворечить именам в других модулях. Требование квалифицированного доступа может значительно повысить долгосрочную удобство обслуживания и эволюционность библиотеки.

```fsharp
[<RequireQualifiedAccess>]
module StringTokenization =
    let parse s = ...

...

let s = getAString()
let parsed = StringTokenization.parse s // Must qualify to use 'parse'
```

### <a name="sort-open-statements-topologically"></a>Сортировка `open` заявлений топологически

В ФЗ важен порядок деклараций, `open` в том числе с заявлениями. Это не похоже на c', где эффект `using` и `using static` не зависит от заказа этих инструкций в файле.

В F- элементы, открытые в область, могут затмевать других уже присутствующих. Это означает, что `open` переупорядочение инструкций может изменить значение кода. В результате не рекомендуется проводить `open` произвольные сортировки всех инструкций (например, альфанумерически), чтобы не создавать другое поведение, которое можно было бы ожидать.

Вместо этого, мы рекомендуем вам сортировать их [топологически](https://en.wikipedia.org/wiki/Topological_sorting); то есть, `open` заказать ваши заявления в порядке, в котором _слои_ вашей системы определены. Также может быть рассмотренвопрос о проведении алфавитной сортировки в различных топологических слоях.

В качестве примера можно сделать топологический сортировку для общедоступного файла API-сервиса компиляционов F's:

```fsharp
namespace Microsoft.FSharp.Compiler.SourceCodeServices

open System
open System.Collections.Generic
open System.Collections.Concurrent
open System.Diagnostics
open System.IO
open System.Reflection
open System.Text

open Microsoft.FSharp.Compiler
open Microsoft.FSharp.Compiler.AbstractIL
open Microsoft.FSharp.Compiler.AbstractIL.Diagnostics
open Microsoft.FSharp.Compiler.AbstractIL.IL
open Microsoft.FSharp.Compiler.AbstractIL.ILBinaryReader
open Microsoft.FSharp.Compiler.AbstractIL.Internal
open Microsoft.FSharp.Compiler.AbstractIL.Internal.Library

open Microsoft.FSharp.Compiler.AccessibilityLogic
open Microsoft.FSharp.Compiler.Ast
open Microsoft.FSharp.Compiler.CompileOps
open Microsoft.FSharp.Compiler.CompileOptions
open Microsoft.FSharp.Compiler.Driver
open Microsoft.FSharp.Compiler.ErrorLogger
open Microsoft.FSharp.Compiler.Infos
open Microsoft.FSharp.Compiler.InfoReader
open Microsoft.FSharp.Compiler.Lexhelp
open Microsoft.FSharp.Compiler.Layout
open Microsoft.FSharp.Compiler.Lib
open Microsoft.FSharp.Compiler.NameResolution
open Microsoft.FSharp.Compiler.PrettyNaming
open Microsoft.FSharp.Compiler.Parser
open Microsoft.FSharp.Compiler.Range
open Microsoft.FSharp.Compiler.Tast
open Microsoft.FSharp.Compiler.Tastops
open Microsoft.FSharp.Compiler.TcGlobals
open Microsoft.FSharp.Compiler.TypeChecker
open Microsoft.FSharp.Compiler.SourceCodeServices.SymbolHelpers

open Internal.Utilities
open Internal.Utilities.Collections
```

Обратите внимание, что разрыв линии разделяет топологические слои, при этом каждый слой затем сортируется альфанумерически. Это чисто организует код без случайного затенения значений.

## <a name="use-classes-to-contain-values-that-have-side-effects"></a>Используйте классы для содержания значений, которые имеют побочные эффекты

Есть много случаев, когда инициализация значения может иметь побочные эффекты, такие как мгновенное воспроизведение контекста в базу данных или другой удаленный ресурс. Заманчиво инициализировать такие вещи в модуле и использовать его в последующих функциях:

```fsharp
// This is bad!
module MyApi =
    let dep1 = File.ReadAllText "/Users/{your name}/connectionstring.txt"
    let dep2 = Environment.GetEnvironmentVariable "DEP_2"

    let private r = Random()
    let dep3() = r.Next() // Problematic if multiple threads use this

    let function1 arg = doStuffWith dep1 dep2 dep3 arg
    let function2 arg = doSutffWith dep1 dep2 dep3 arg
```

Это часто плохая идея по нескольким причинам:

Во-первых, конфигурация приложения заталкивается в кодовую базу с `dep1` и `dep2`. Это трудно поддерживать в больших баз кода.

Во-вторых, статические инициализированные данные не должны включать значения, которые не являются безопасными для потока, если компонент сам будет использовать несколько потоков. Это явно нарушается `dep3`.

Наконец, инициализация модуля компилируется в статический конструктор для всего блока компиляции. Если какая-либо ошибка возникает в инициализации значения, связанного с пуском в этом модуле, она проявляется как `TypeInitializationException` ошибка, которая затем кэшируется на протяжении всего срока службы приложения. Это может быть трудно диагностировать. Существует, как правило, внутреннее исключение, что вы можете попытаться рассуждать о, но если нет, то никто не знает, что первопричина.

Вместо этого просто используйте простой класс для хранения зависимостей:

```fsharp
type MyParametricApi(dep1, dep2, dep3) =
    member _.Function1 arg1 = doStuffWith dep1 dep2 dep3 arg1
    member _.Function2 arg2 = doStuffWith dep1 dep2 dep3 arg2
```

Это позволяет следующим образом:

1. Нажатие любого зависимого состояния за пределы самого API.
2. Конфигурация теперь может быть выполнена за пределами API.
3. Ошибки в инициализации для зависимых значений вряд ли проявляются как `TypeInitializationException`.
4. Теперь API легче тестировать.

## <a name="error-management"></a>Управление ошибками

Управление ошибками в больших системах является сложной и тонкой работы, и Есть нет серебряных пуль в обеспечении ваших систем являются отказоустойчивыми и ведут себя хорошо. Следующие руководящие принципы должны дать рекомендации в области навигации по этому сложному пространству.

### <a name="represent-error-cases-and-illegal-state-in-types-intrinsic-to-your-domain"></a>Представлять случаи ошибок и незаконное состояние в типах, присущих вашему домену

С [дискриминируемыми союзами,](../language-reference/discriminated-unions.md)ФЗ дает вам возможность представлять неисправное состояние программы в вашей системе типа. Пример:

```fsharp
type MoneyWithdrawalResult =
    | Success of amount:decimal
    | InsufficientFunds of balance:decimal
    | CardExpired of DateTime
    | UndisclosedFailure
```

В этом случае существует три известных способа, что снятие денег с банковского счета может потерпеть неудачу. Каждый случай ошибки представлен в типе, и таким образом может быть рассмотрен безопасно на протяжении всей программы.

```fsharp
let handleWithdrawal amount =
    let w = withdrawMoney amount
    match w with
    | Success am -> printfn "Successfully withdrew %f" am
    | InsufficientFunds balance -> printfn "Failed: balance is %f" balance
    | CardExpired expiredDate -> printfn "Failed: card expired on %O" expiredDate
    | UndisclosedFailure -> printfn "Failed: unknown"
```

В общем случае, если вы можете моделировать различные способы, что что-то может **потерпеть неудачу** в вашем домене, то код обработки ошибок больше не рассматривается как то, что вы должны иметь дело с в дополнение к регулярному потоку программы. Это просто часть нормального потока программы, и не считается **исключительным**. Есть два основных преимущества этого:

1. Это проще поддерживать, как ваш домен меняется с течением времени.
2. Случаи ошибок проще удельного тестирования.

### <a name="use-exceptions-when-errors-cannot-be-represented-with-types"></a>Используйте исключения, если ошибки не могут быть представлены с типами

Не все ошибки могут быть представлены в проблемной области. Эти виды неисправностей являются *исключительными* по своему характеру, следовательно, способность поднимать и ловить исключения в F.

Во-первых, рекомендуется прочитать [Руководящие принципы проектирования исключений.](../../standard/design-guidelines/exceptions.md) Они также применимы к ФЗ.

Основные конструкции, доступные в ФЗ для целей повышения исключений, должны рассматриваться в следующем порядке предпочтений:

| Компонент | Синтаксис | Назначение |
|----------|--------|---------|
| `nullArg` | `nullArg "argumentName"` | Поднимает `System.ArgumentNullException` с указанным названием аргумента. |
| `invalidArg` | `invalidArg "argumentName" "message"` | Поднимает `System.ArgumentException` с указанным названием аргумента и сообщением. |
| `invalidOp` | `invalidOp "message"` | Поднимает `System.InvalidOperationException` с указанным сообщением. |
|`raise`| `raise (ExceptionType("message"))` | Механизм общего назначения для метания исключений. |
| `failwith` | `failwith "message"` | Поднимает `System.Exception` с указанным сообщением. |
| `failwithf` | `failwithf "format string" argForFormatString` | Поднимает `System.Exception` сообщение, определяемые строкой формата и ее входными данными. |

`nullArg`Используйте, `invalidOp` `invalidArg` и в качестве `ArgumentException` `InvalidOperationException` механизма бросать, `ArgumentNullException`и когда это уместно.

`failwith` Функции `failwithf` и функции, как правило, следует избегать, поскольку они повышают базовый `Exception` тип, а не конкретное исключение. В рамках [Руководящих принципов проектирования исключений](../../standard/design-guidelines/exceptions.md)необходимо, когда это возможно, вы можете создать более конкретные исключения.

### <a name="using-exception-handling-syntax"></a>Использование синтаксиса обработки исключений

Шаблоны исключений с `try...with` помощью синтаксиса:

```fsharp
try
    tryGetFileContents()
with
| :? System.IO.FileNotFoundException as e -> // Do something with it here
| :? System.Security.SecurityException as e -> // Do something with it here
```

Согласование функциональности для выполнения перед лицом исключения с сопоставлением шаблонов может быть немного сложнее, если вы хотите сохранить код в чистоте. Одним из таких способов обработки этого является использование [активных шаблонов](../language-reference/active-patterns.md) в качестве средства для группирования функциональности, окружающей случай ошибки, за исключением самого. Например, вы можете употреблять API, который, когда он бросает исключение, привязав ценную информацию в метаданные исключения. Разворачивание полезного значения в теле захваченного исключения внутри Active Pattern и возвращение этого значения может быть полезно в некоторых ситуациях.

### <a name="do-not-use-monadic-error-handling-to-replace-exceptions"></a>Не используйте обработку монадических ошибок для замены исключений

Исключения рассматриваются как несколько табу в функциональном программировании. Действительно, исключения нарушают чистоту, поэтому смело считать их не совсем функциональными. Однако при этом игнорируется реальность того, где должен работать код, и могут возникать ошибки в времени выполнения. В общем, напишите код на предположении, что большинство вещей не являются ни чистыми, ни полными, чтобы свести к минимуму неприятные сюрпризы.

Важно учитывать следующие основные сильные стороны/аспекты исключений в отношении их актуальности и целесообразности в режиме выполнения .NET и кросс-языковой экосистеме в целом:

1. Они содержат подробную диагностическую информацию, что очень полезно при отладке проблемы.
2. Они хорошо понимаются временем выполнения и другими языками .NET.
3. Они могут уменьшить значительный шаблон по сравнению с кодом, который выходит из его пути, чтобы *избежать* исключений, реализуя некоторые подмножество их семантики на специальной основе.

Этот третий пункт имеет решающее значение. Для нетривиальных сложных операций отказ от использования исключений может привести к работе со структурами, подобными этим:

```fsharp
Result<Result<MyType, string>, string list>
```

Что может легко привести к хрупкому коду, как шаблон, соответствующий на "строка-набранных" ошибок:

```fsharp
let result = doStuff()
match result with
| Ok r -> ...
| Error e ->
    if e.Contains "Error string 1" then ...
    elif e.Contains "Error string 2" then ...
    else ... // Who knows?
```

Кроме того, может быть заманчиво проглотить любое исключение в желании "простой" функции, которая возвращает "хороший" тип:

```fsharp
// This is bad!
let tryReadAllText (path : string) =
    try System.IO.File.ReadAllText path |> Some
    with _ -> None
```

К `tryReadAllText` сожалению, может бросать многочисленные исключения, основанные на множеству вещей, которые могут произойти в файловой системе, и этот код отбрасывает любую информацию о том, что может на самом деле происходит не так в вашей среде. Если вы замените этот код типом результата, вы вернетесь к разбору сообщений об ошибке с строкой:

```fsharp
// This is bad!
let tryReadAllText (path : string) =
    try System.IO.File.ReadAllText path |> Ok
    with e -> Error e.Message

let r = tryReadAllText "path-to-file"
match r with
| Ok text -> ...
| Error e ->
    if e.Contains "uh oh, here we go again..." then ...
    else ...
```

А размещение самого объекта `Error` исключения в конструкторе просто заставляет вас правильно иметь дело с типом исключения на сайте вызова, а не в функции. Это эффективно создает проверенные исключения, с которыми, как известно, неинтересно иметь дело в качестве вызываемого API.

Хорошей альтернативой приведенным выше примерам является уловие *конкретных* исключений и возвращение значимого значения в контексте этого исключения. Если вы `tryReadAllText` измените функцию следующим образом, `None` имеет больше смысла:

```fsharp
let tryReadAllTextIfPresent (path : string) =
    try System.IO.File.ReadAllText path |> Some
    with :? FileNotFoundException -> None
```

Вместо того, чтобы функционировать как универсальный, эта функция теперь будет правильно обрабатывать случай, когда файл не был найден и назначить, что смысл возвращения. Это значение возврата может отобразить этот случай ошибки, не отбрасывая при этом какую-либо контекстную информацию или заставляя абонентов иметь дело с случаем, который может не иметь значения на данном этапе кода.

Такие типы, как, `Result<'Success, 'Error>` подходят для основных операций, где они не вложены, и f'дополнительные типы идеально подходят для представления, когда что-то может либо вернуть *что-то* или *ничего*. Однако они не являются заменой исключений и не должны использоваться в попытке заменить исключения. Скорее, они должны применяться разумно для рассмотрения конкретных аспектов политики исключения и управления ошибками целевыми способами.

## <a name="partial-application-and-point-free-programming"></a>Частичное применение и программирование без точек

ФЗ поддерживает частичное применение, и, таким образом, различные способы программирования в стиле, свободном от точек. Это может быть полезно для повторного использования кода в модуле или реализации чего-либо, но это не то, чтобы разоблачить публично. В общем, точечное программирование само по себе не является добродетелью и может добавить значительный когнитивный барьер для людей, которые не погружены в стиль.

### <a name="do-not-use-partial-application-and-currying-in-public-apis"></a>Не используйте частичное применение и карри в публичных AIS

За небольшим исключением, использование частичного применения в публичных AA может ввести в заблуждение потребителей. Как `let`правило, значения, связанные с F-кодом, являются **значениями,** а не **значениями функций.** Смешивание значений и значений функций может привести к сохранению небольшого количества строк кода в обмен на `>>` довольно много когнитивных накладных расходов, особенно в сочетании с операторами, такими как для составления функций.

### <a name="consider-the-tooling-implications-for-point-free-programming"></a>Рассмотрим инструментарий последствия для программирования без точек

Карри функции не обозначать свои аргументы. Это имеет инструментальный последствия. Рассмотрим следующие две функции:

```fsharp
let func name age =
    printfn "My name is %s and I am %d years old!" name age

let funcWithApplication =
    printfn "My name is %s and I am %d years old!"
```

Оба являются действительными `funcWithApplication` функциями, но является функцией карри. Когда вы нависнете над их типами в редакторе, вы видите это:

```fsharp
val func : name:string -> age:int -> unit

val funcWithApplication : (string -> int -> unit)
```

На сайте вызова, инструменты в инструментарии, такие как Visual Studio `string` `int` не даст вам значимую информацию о том, что и типы ввода на самом деле представляют.

Если вы сталкиваетесь `funcWithApplication` с кодом, свободным от точек, как это публично расходуется, рекомендуется сделать полное расширение, так что инструментальный инструмент может подобрать на значимые имена для аргументов.

Кроме того, отладка кода без точек может быть сложной задачей, если не невозможной. Инструменты отладки полагаются на значения, `let` связанные с именами (например, привязки), чтобы можно было проверить промежуточные значения в середине выполнения. Если код не имеет значений для проверки, отладить нечего. В будущем инструменты отладки могут эволюционировать для синтеза этих значений на основе ранее выполненных путей, но не стоит хеджировать свои ставки на *потенциальную* функциональность отладки.

### <a name="consider-partial-application-as-a-technique-to-reduce-internal-boilerplate"></a>Рассматривайте частичное применение как метод для уменьшения внутреннего шаблона

В отличие от предыдущей точки, частичное применение является прекрасным инструментом для уменьшения шаблона внутри приложения или более глубоких внутренностений API. Это может быть полезно для модульного тестирования реализации более сложных AIS, где шаблон часто боль иметь дело. Например, следующий код показывает, как можно выполнить то, что дает большинство насмешливых инфраструктур, не принимая внешнюю зависимость от такой платформы и не изучая связанный на заказ API.

Например, рассмотрим следующую топографию решений:

```
MySolution.sln
|_/ImplementationLogic.fsproj
|_/ImplementationLogic.Tests.fsproj
|_/API.fsproj
```

`ImplementationLogic.fsproj`может подвергать код, такой как:

```fsharp
module Transactions =
    let doTransaction txnContext txnType balance =
        ...

type Transactor(ctx, currentBalance) =
    member _.ExecuteTransaction(txnType) =
        Transactions.doTransaction ctx txtType currentBalance
        ...
```

Модульное тестирование `Transactions.doTransaction` в `ImplementationLogic.Tests.fsproj` несложно:

```fsharp
namespace TransactionsTestingUtil

open Transactions

module TransactionsTestable =
    let getTestableTransactionRoutine mockContext = Transactions.doTransaction mockContext
```

Частичное `doTransaction` применение с насмешливым контекстным объектом позволяет вызывать функцию во всех модульных тестах без необходимости каждый раз создавать насмешливый контекст:

```fsharp
namespace TransactionTests

open Xunit
open TransactionTypes
open TransactionsTestingUtil
open TransactionsTestingUtil.TransactionsTestable

let testableContext =
    { new ITransactionContext with
        member _.TheFirstMember() = ...
        member _.TheSecondMember() = ... }

let transactionRoutine = getTestableTransactionRoutine testableContext

[<Fact>]
let ``Test withdrawal transaction with 0.0 for balance``() =
    let expected = ...
    let actual = transactionRoutine TransactionType.Withdraw 0.0
    Assert.Equal(expected, actual)
```

Этот метод не должен повсеместно применяться ко всей кодовой базе, но это хороший способ уменьшить шаблон для сложных внутренноств и модульного тестирования этих внутренностей.

## <a name="access-control"></a>Управление доступом

ФЗ имеет несколько вариантов [управления доступом,](../language-reference/access-control.md)унаследованных от того, что доступно в времени выполнения .NET. Они не только использовать для типов - вы можете использовать их для функций, тоже.

* Предпочитаюненее нетипов`public` и членов, пока вам не нужно, чтобы они были публично расходуемыми. Это также сводит к минимуму то, что потребители пара.
* Старайтесь сохранить всю `private`функциональность помощника.
* Рассмотрим использование `[<AutoOpen>]` на частный модуль функций помощника, если они становятся многочисленными.

## <a name="type-inference-and-generics"></a>Выводы типов и дженерики

Вывод типа может спасти вас от ввода большого количества шаблонов. Автоматическое обобщение в компиляторе F-й может помочь вам написать более общий код, практически без дополнительных усилий с вашей стороны. Тем не менее, эти функции не являются универсально хорошими.

* Рассмотрите маркировку имен аргументов с явными типами в публичных AIS и не опирайтесь на вывод типа для этого.

    Причина этого заключается в том, что **вы** должны контролировать форму вашего API, а не компилятор. Хотя компилятор может выполнять прекрасную работу при выводе типов для вас, можно иметь форму изменения API, если внутренние детали, на которые он опирается, изменились. Это может быть то, что вы хотите, но это почти наверняка приведет к нарушению Изменения API, что вниз по течению потребители будут иметь дело с. Вместо этого, если вы явно контролируете форму вашего общедоступного API, то вы можете контролировать эти изменения. С точки зрения DDD, это можно рассматривать как антикоррупционный слой.

* Рассмотрите возможность предоставления значимого названия общим аргументам.

    Если вы не пишете действительно общий код, который не специфичен для конкретного домена, значимое имя может помочь другим программистам понять домен, в который они работают. Например, параметр `'Document` типа, названный в контексте взаимодействия с базой данных документов, позволяет понять, что общие типы документов могут быть приняты функцией или членом, с которым вы работаете.

* Рассмотрите вопрос о наименовании общих параметров типа с помощью PascalCase.

    Это общий способ сделать что-то в .NET, поэтому рекомендуется использовать PascalCase, а не snake_case или верблюда.

Наконец, автоматическое обобщение не всегда является благом для людей, которые являются новыми для F- или большой кодовой базы. Существует когнитивных накладных расходов в использовании компонентов, которые являются общими. Кроме того, если автоматически обобщенные функции не используются с различными типами ввода (не говоря уже о том, что они предназначены для использования в качестве таковых), то нет никакой реальной пользы для них быть общими в данный момент времени. Всегда учитывайте, действительно ли код, который вы пишете, выиграет от общего.

## <a name="performance"></a>Производительность

### <a name="prefer-structs-for-small-data-types"></a>Предпочитают структуры для небольших типов данных

Использование структур (также называемых типами значений) часто может привести к повышению производительности для некоторых кодов, поскольку обычно он избегает выделения объектов. Тем не менее, структуры не всегда являются кнопкой "идти быстрее": если размер данных в структуре превышает 16 байт, копирование данных часто может привести к большему времени процессора тратить, чем с помощью эталонного типа.

Чтобы определить, следует ли использовать структуру, рассмотрим следующие условия:

- Если размер ваших данных составляет 16 байтов или меньше.
- Если в запущенной программе в памяти может быть много таких типов данных.

Если применяется первое условие, обычно следует использовать структуру. Если оба применяются, вы должны почти всегда использовать структуру. Там могут быть некоторые случаи, когда предыдущие условия применяются, но с помощью структуры не лучше или хуже, чем с помощью эталонного типа, но они могут быть редкими. Важно всегда измерять при внесении изменений, как это, хотя, а не работать на предположение или интуицию.

#### <a name="prefer-struct-tuples-when-grouping-small-value-types"></a>Предпочитают структурировать tuples при группировке малых типов значений

Рассмотрим следующие две функции:

```fsharp
let rec runWithTuple t offset times =
    let offsetValues x y z offset =
        (x + offset, y + offset, z + offset)

    if times <= 0 then
        t
    else
        let (x, y, z) = t
        let r = offsetValues x y z offset
        runWithTuple r offset (times - 1)

let rec runWithStructTuple t offset times =
    let offsetValues x y z offset =
        struct(x + offset, y + offset, z + offset)

    if times <= 0 then
        t
    else
        let struct(x, y, z) = t
        let r = offsetValues x y z offset
        runWithStructTuple r offset (times - 1)
```

При бенчмарке эти функции со статистическим инструментом бенчмаркинга, как [BenchmarkDotNet](https://benchmarkdotnet.org/), вы обнаружите, что `runWithStructTuple` функция, которая использует структурировать tuples работает на 40% быстрее и не выделяет памяти.

Однако эти результаты не всегда будут иметь место в вашем собственном коде. Если вы пометите функцию как, `inline`код, который использует ссылки tuples может получить некоторые дополнительные оптимизации, или код, который бы выделить может быть просто оптимизирован. Вы всегда должны измерять результаты, когда речь идет, и никогда не работать на основе предположения или интуиции.

#### <a name="prefer-struct-records-when-the-data-type-is-small"></a>Предпочитают записи структурирования, когда тип данных небольшой

Правило большого пальца, описанное ранее, также имеет место для [типов записей F'.](../language-reference/records.md) Рассмотрим следующие типы данных и функции, которые их обрабатывают:

```fsharp
type Point = { X: float; Y: float; Z: float }

[<Struct>]
type SPoint = { X: float; Y: float; Z: float }

let rec processPoint (p: Point) offset times =
    let inline offsetValues (p: Point) offset =
        { p with X = p.X + offset; Y = p.Y + offset; Z = p.Z + offset }

    if times <= 0 then
        p
    else
        let r = offsetValues p offset
        processPoint r offset (times - 1)

let rec processStructPoint (p: SPoint) offset times =
    let inline offsetValues (p: SPoint) offset =
        { p with X = p.X + offset; Y = p.Y + offset; Z = p.Z + offset }

    if times <= 0 then
        p
    else
        let r = offsetValues p offset
        processStructPoint r offset (times - 1)
```

Это похоже на предыдущий код tuple, но на этот раз пример использует записи и подстроенную внутреннюю функцию.

При бенчмарке эти функции со статистическим инструментом бенчмаркинга, как [BenchmarkDotNet](https://benchmarkdotnet.org/), вы обнаружите, что `processStructPoint` работает почти на 60% быстрее и ничего не выделяет на управляемой куче.

#### <a name="prefer-struct-discriminated-unions-when-the-data-type-is-small"></a>Предпочитаю тростковые дискриминируемые союзы, когда тип данных мал

Предыдущие наблюдения о производительности с структурами tuples и записи также имеет место для [F' Дискриминационные союзы](../language-reference/discriminated-unions.md). Рассмотрим следующий код.

```fsharp
    type Name = Name of string

    [<Struct>]
    type SName = SName of string

    let reverseName (Name s) =
        s.ToCharArray()
        |> Array.rev
        |> string
        |> Name

    let structReverseName (SName s) =
        s.ToCharArray()
        |> Array.rev
        |> string
        |> SName
```

Обычно для моделирования доменов обычно определяются однократные дискриминирующие союзы. При бенчмарке эти функции со статистическим инструментом бенчмаркинга, как `reverseName` [BenchmarkDotNet](https://benchmarkdotnet.org/), вы обнаружите, что `structReverseName` работает примерно на 25% быстрее, чем для небольших строк. Для больших строк оба выполняют примерно одно и то же. Так что, в этом случае, это всегда предпочтительнее использовать структуру. Как упоминалось ранее, всегда измерять и не оперировать на предположениях или интуиции.

Хотя предыдущий пример показал, что структурируемый дискриминируемый союз показал более высокую производительность, при моделировании домена часто бывает больше дискриминированных союзов. Более крупные типы данных, подобные этому, могут также выполняться, если они структурируются в зависимости от операций на них, так как может быть задействовано большекопирование.

### <a name="functional-programming-and-mutation"></a>Функциональное программирование и мутация

Значения F-класса неизменяемы по умолчанию, что позволяет избежать определенных классов ошибок (особенно тех, которые связаны с параллелизмом и параллелизмом). Однако в некоторых случаях для достижения оптимальной (или даже разумной) эффективности времени выполнения или распределения памяти, промежуток работы может быть лучше всего реализован с помощью мутации состояния на месте. Это возможно в основе выбора с F `mutable` с ключевым словом.

Использование `mutable` в F-фз может противоречить функциональной чистоте. Это понятно, но функциональная чистота везде может противоречить целям производительности. Компромисс заключается в том, чтобы инкапсулировать мутации таким образом, что абоненты не должны заботиться о том, что происходит, когда они называют функцию. Это позволяет написать функциональный интерфейс над реализацией на основе мутаций для критически важного кода.

#### <a name="wrap-mutable-code-in-immutable-interfaces"></a>Оберните изменяемый код в неизменяемые интерфейсы

При основе референтной прозрачности в качестве цели крайне важно писать код, который не разоблачает изменяемые подбрюшье критически важных функций. Например, следующий код `Array.contains` реализует функцию в основной библиотеке F-кода:

```fsharp
[<CompiledName("Contains")>]
let inline contains value (array:'T[]) =
    checkNonNull "array" array
    let mutable state = false
    let mutable i = 0
    while not state && i < array.Length do
        state <- value = array.[i]
        i <- i + 1
    state
```

Вызов этой функции несколько раз не изменяет базовый массив, и не требует, чтобы вы поддерживали любое изменяемое состояние в его потреблении. Он является референциально прозрачным, хотя почти каждая строка кода в нем использует мутацию.

#### <a name="consider-encapsulating-mutable-data-in-classes"></a>Рассмотрим инкапсуляцию изменяемых данных в классах

В предыдущем примере использовалась одна функция для инкапсулировать операции с использованием изменяемых данных. Этого не всегда достаточно для более сложных наборов данных. Рассмотрим следующие наборы функций:

```fsharp
open System.Collections.Generic

let addToClosureTable (key, value) (t: Dictionary<_,_>) =
    if not (t.ContainsKey(key)) then
        t.Add(key, value)
    else
        t.[key] <- value

let closureTableCount (t: Dictionary<_,_>) = t.Count

let closureTableContains (key, value) (t: Dictionary<_, HashSet<_>>) =
    match t.TryGetValue(key) with
    | (true, v) -> v.Equals(value)
    | (false, _) -> false
```

Этот код выполняется, но он предоставляет структуру данных, основанную на мутации, которую абоненты несут ответственность за поддержание. Это может быть обернуто внутри класса без каких-либо основных членов, которые могут измениться:

```fsharp
open System.Collections.Generic

/// The results of computing the LALR(1) closure of an LR(0) kernel
type Closure1Table() =
    let t = Dictionary<Item0, HashSet<TerminalIndex>>()

    member _.Add(key, value) =
        if not (t.ContainsKey(key)) then
            t.Add(key, value)
        else
            t.[key] <- value

    member _.Count = t.Count

    member _.Contains(key, value) =
        match t.TryGetValue(key) with
        | (true, v) -> v.Equals(value)
        | (false, _) -> false
```

`Closure1Table`инкапсулирует базовую структуру данных на основе мутаций, тем самым не заставляя абонентов поддерживать базовую структуру данных. Классы — это мощный способ инкапсулировать данные и процедуры, основанные на мутациях, не подвергая детали абонентам.

#### <a name="prefer-let-mutable-to-reference-cells"></a>Предпочитаю `let mutable` эталонные ячейки

Справочные ячейки являются способом представления ссылки на значение, а не само значение. Хотя они могут быть использованы для критически важного кода, они не рекомендуются. Рассмотрим следующий пример:

```fsharp
let kernels =
    let acc = ref Set.empty

    processWorkList startKernels (fun kernel ->
        if not ((!acc).Contains(kernel)) then
            acc := (!acc).Add(kernel)
        ...)

    !acc |> Seq.toList
```

Использование справочной ячейки теперь "загрязняет" весь последующий код, имея необходимость dereference и перессылки базовых данных. Вместо этого, рассмотрим: `let mutable`

```fsharp
let kernels =
    let mutable acc = Set.empty

    processWorkList startKernels (fun kernel ->
        if not (acc.Contains(kernel)) then
            acc <- acc.Add(kernel)
        ...)

    acc |> Seq.toList
```

Помимо одной точки мутации в середине выражения лямбда, `acc` все другие коды, которые касаются может `let`сделать это таким образом, что ничем не отличается от использования нормального связанного неизменного значения. Это упростит изменение с течением времени.

## <a name="object-programming"></a>Программирование объектов

ФЗ имеет полную поддержку объектов и объектно-ориентированных (OO) концепций. Хотя многие концепции OO являются мощными и полезными, не все из них идеально подходят для использования. Следующие списки содержат рекомендации по категориям функций OO на высоком уровне.

**Рассмотрите возможность использования этих функций во многих ситуациях:**

* Точка нотации (`x.Length`)
* Члены инстанции
* Неявные конструкторы
* Статические члены
* Показательное обозначение (`arr.[x]`)
* Именованные и факультативные аргументы
* Интерфейсы и реализации интерфейсов

**Не достигайте этих функций во-первых, но разумно применять их, когда они удобны для решения проблемы:**

* Перегрузка методов
* Инкапсулированные изменяемые данные
* Операторы по типам
* Автосвойства
* Реализация `IDisposable` и`IEnumerable`
* Расширение типа
* События
* Структуры
* Делегаты
* Перечисления

**Как правило, избегайте этих функций, если вы не должны использовать их:**

* Иерархии типов наследования и наследования наследования
* Нутс и`Unchecked.defaultof<_>`

### <a name="prefer-composition-over-inheritance"></a>Предпочитаю состав над наследством

[Композиция над наследством](https://en.wikipedia.org/wiki/Composition_over_inheritance) – это давняя идиома, к которым может придерживаться хороший код F'. Фундаментальный принцип заключается в том, что вы не должны подвергать базовый класс и заставить абонентов наследовать из этого базового класса, чтобы получить функциональность.

### <a name="use-object-expressions-to-implement-interfaces-if-you-dont-need-a-class"></a>Используйте выражения объектов для реализации интерфейсов, если вам не нужен класс

[Выражения объектов](../language-reference/object-expressions.md) позволяют реализовывать интерфейсы на лету, связывая реализованный интерфейс с значением без необходимости делать это внутри класса. Это удобно, особенно если вам _нужно только_ реализовать интерфейс и не нужно для полного класса.

Например, вот код, который работает в [Ionide,](http://ionide.io/) чтобы обеспечить действие исправления кода, `open` если вы добавили символ, для которого у вас нет оператора:

```fsharp
    let private createProvider () =
        { new CodeActionProvider with
            member this.provideCodeActions(doc, range, context, ct) =
                let diagnostics = context.diagnostics
                let diagnostic = diagnostics |> Seq.tryFind (fun d -> d.message.Contains "Unused open statement")
                let res =
                    match diagnostic with
                    | None -> [||]
                    | Some d ->
                        let line = doc.lineAt d.range.start.line
                        let cmd = createEmpty<Command>
                        cmd.title <- "Remove unused open"
                        cmd.command <- "fsharp.unusedOpenFix"
                        cmd.arguments <- Some ([| doc |> unbox; line.range |> unbox; |] |> ResizeArray)
                        [|cmd |]
                res
                |> ResizeArray
                |> U2.Case1
        }
```

Поскольку при взаимодействии с API Visual Studio не требуется, выражения объектов являются идеальным инструментом для этого. Они также ценны для модульного тестирования, когда вы хотите заглушить интерфейс с тестовыми процедурами в специальной манере.

## <a name="consider-type-abbreviations-to-shorten-signatures"></a>Рассмотрим аббревиатуры типа для сокращения подписей

[Аббревиативы типа](../language-reference/type-abbreviations.md) — это удобный способ присвоить метку другому типу, например подпись функции или более сложный тип. Например, следующий псевдоним присваивает метку тому, что необходимо для определения вычислений с [помощью CNTK,](https://docs.microsoft.com/cognitive-toolkit/)библиотеки глубокого обучения:

```fsharp
open CNTK

// DeviceDescriptor, Variable, and Function all come from CNTK
type Computation = DeviceDescriptor -> Variable -> Function
```

Имя `Computation` является удобным способом обозначить любую функцию, которая соответствует подписи, которую он псевдоним. Использование таких аббревиатив типа удобно и позволяет использовать более краткий код.

### <a name="avoid-using-type-abbreviations-to-represent-your-domain"></a>Избегайте использования аббревиаций типа для представления вашего домена

Хотя аббревиатуры типа удобны для придания имени для функциональных подписей, они могут ввести в заблуждение при сокращении других типов. Рассмотрим эту аббревиаюрацию:

```fsharp
// Does not actually abstract integers.
type BufferSize = int
```

Это может ввести в заблуждение несколькими способами:

* `BufferSize`это не абстракция; это просто другое название для рядов.
* Если `BufferSize` он разоблачается в общедоступном API, его `int`можно легко неправильно истолковать как нечто большее, чем просто. Как правило, типы доменов имеют несколько `int`атрибутов к ним и не являются примитивными типами, как. Эта аббревиатива нарушает это предположение.
* Корпус `BufferSize` (PascalCase) подразумевает, что этот тип содержит больше данных.
* Этот псевдоним не предлагает повышенной ясности по сравнению с предоставлением названного аргумента к функции.
* Аббревиатива не проявляется в скомпилированном IL; это всего лишь целый ряд, и этот псевдоним представляет собой построение компиляции времени.

```fsharp
module Networking =
    ...
    let send data (bufferSize: int) = ...
```

Таким образом, ловушка с типом Abbreviations является то, что они **не** являются абстракциями по сравнению с типами, которые они аббревиании. В предыдущем примере, `BufferSize` `int` это просто под крышкой, без каких-либо дополнительных данных, ни каких-либо преимуществ от системы типа, кроме того, что `int` уже есть.

Альтернативный подход к использованию аббревиатий типов для представления домена заключается в использовании единичных дискриминируемых союзов. Предыдущий образец можно смоделировать следующим образом:

```fsharp
type BufferSize = BufferSize of int
```

Если вы пишете код, `BufferSize` который работает с точки зрения и его основное значение, вам нужно построить один, а не пройти в любой произвольной ряд:

```fsharp
module Networking =
    ...
    let send data (BufferSize size) =
    ...
```

Это снижает вероятность ошибочного прохождения произвольного `send` стеге в функцию, поскольку абонент должен построить `BufferSize` тип, чтобы обернуть значение перед вызовом функции.
