---
title: Соглашения о написании кода на F#
description: Ознакомьтесь с общими правилами и идиомами при F# написании кода.
ms.date: 11/04/2019
ms.openlocfilehash: 60eff6392d71caa54eeb438f2f6ba9db910f1bc1
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/12/2019
ms.locfileid: "73978230"
---
# <a name="f-coding-conventions"></a>Соглашения о написании кода на F#

Следующие соглашения формируются из опыта работы с большими F# кодовыми средами. [Пять принципов работы с хорошим F# кодом](index.md#five-principles-of-good-f-code) являются основой каждой рекомендации. Они связаны с [ F# рекомендациями по проектированию компонентов](component-design-guidelines.md), но применимы для F# любого кода, а не только для таких компонентов, как библиотеки.

## <a name="organizing-code"></a>Организация кода

F#два основных способа организации кода: модули и пространства имен. Они похожи, но имеют следующие отличия.

* Пространства имен компилируются как пространства имен .NET. Модули компилируются как статические классы.
* Пространства имен всегда имеют верхний уровень. Модули могут быть верхнего уровня и вложены в другие модули.
* Пространства имен могут охватывать несколько файлов. Модули не могут.
* Модули можно снабдить `[<RequireQualifiedAccess>]` и `[<AutoOpen>]`.

Следующие рекомендации помогут вам использовать их для организации кода.

### <a name="prefer-namespaces-at-the-top-level"></a>Предпочитать пространства имен на верхнем уровне

Для любого общедоступного кода пространства имен являются предпочтительными для модулей на верхнем уровне. Поскольку они компилируются как пространства имен .NET, они могут быть потреблены от C# без каких-либо проблем.

```fsharp
// Good!
namespace MyCode

type MyClass() =
    ...
```

Использование модуля верхнего уровня может не отличаться при вызове только из F#, но для C# потребителей вызывающие объекты могут быть удивлены тем, что необходимо уточнить`MyClass`с помощью модуля`MyCode`.

```fsharp
// Bad!
module MyCode

type MyClass() =
    ...
```

### <a name="carefully-apply-autoopen"></a>Тщательное применение `[<AutoOpen>]`

Конструкция `[<AutoOpen>]` может засоряла область действия, которая доступна для вызывающих объектов, и ответ на то, что поступает от "волшебного". Как правило, это не хорошая вещь. Исключением из F# этого правила является сама основная библиотека (хотя этот факт также является битом спорной).

Однако это удобство, если у вас есть вспомогательная функциональность для общедоступного API, который вы хотите упорядочить отдельно от этого общедоступного API.

```fsharp
module MyAPI =
    [<AutoOpen>]
    module private Helpers =
        let helper1 x y z =
            ...

    let myFunction1 x =
        let y = ...
        let z = ...

        helper1 x y z
```

Это позволяет четко отделить сведения о реализации от открытого API функции, не требуя полного определения вспомогательного метода при каждом его вызове.

Кроме того, предоставление методов расширения и построителей выражений на уровне пространства имен можно аккуратно выразить с помощью `[<AutoOpen>]`.

### <a name="use-requirequalifiedaccess-whenever-names-could-conflict-or-you-feel-it-helps-with-readability"></a>Используйте `[<RequireQualifiedAccess>]` всякий раз, когда имена могут конфликтовать, или вы считаете, что они помогают удобочитаемости

Добавление атрибута `[<RequireQualifiedAccess>]` к модулю означает, что модуль не может быть открыт и что ссылки на элементы модуля должны явно иметь полный доступ. Например, модуль `Microsoft.FSharp.Collections.List` имеет этот атрибут.

Это полезно, когда функции и значения в модуле имеют имена, которые, скорее всего, конфликтуют с именами в других модулях. Обязательное получение полного доступа может значительно увеличить долгосрочное обслуживание и развитию библиотеки.

```fsharp
[<RequireQualifiedAccess>]
module StringTokenization =
    let parse s = ...

...

let s = getAString()
let parsed = StringTokenization.parse s // Must qualify to use 'parse'
```

### <a name="sort-open-statements-topologically"></a>Инструкции сортировки `open` топологически

В F#порядок объявлений имеет значение, включая инструкции `open`. Это не похоже C#на то, где воздействие`using`и`using static`не зависит от порядка этих инструкций в файле.

В F#элементы, открытые в области, могут уже быть скрыты другими. Это означает, что Переупорядочение инструкций `open` может изменить значение кода. В результате некоторая Любая произвольная сортировка всех инструкций `open` (например, буквенно-цифровых) обычно не рекомендуется, допустим вы создаете другое поведение, которое вы можете ожидать.

Вместо этого рекомендуется отсортировать их [топологически](https://en.wikipedia.org/wiki/Topological_sorting); то есть закажите операторы `open` в том порядке, в котором определены _уровни_ системы. Также можно учитывать алфавитно-цифровые сортировки в разных слоях топологическом.

Ниже приведен пример сортировки топологическом для файла общедоступного API F# -интерфейса службы компилятора:

```fsharp
namespace Microsoft.FSharp.Compiler.SourceCodeServices

open System
open System.Collections.Generic
open System.Collections.Concurrent
open System.Diagnostics
open System.IO
open System.Reflection
open System.Text

open Microsoft.FSharp.Compiler
open Microsoft.FSharp.Compiler.AbstractIL
open Microsoft.FSharp.Compiler.AbstractIL.Diagnostics
open Microsoft.FSharp.Compiler.AbstractIL.IL
open Microsoft.FSharp.Compiler.AbstractIL.ILBinaryReader
open Microsoft.FSharp.Compiler.AbstractIL.Internal
open Microsoft.FSharp.Compiler.AbstractIL.Internal.Library

open Microsoft.FSharp.Compiler.AccessibilityLogic
open Microsoft.FSharp.Compiler.Ast
open Microsoft.FSharp.Compiler.CompileOps
open Microsoft.FSharp.Compiler.CompileOptions
open Microsoft.FSharp.Compiler.Driver
open Microsoft.FSharp.Compiler.ErrorLogger
open Microsoft.FSharp.Compiler.Infos
open Microsoft.FSharp.Compiler.InfoReader
open Microsoft.FSharp.Compiler.Lexhelp
open Microsoft.FSharp.Compiler.Layout
open Microsoft.FSharp.Compiler.Lib
open Microsoft.FSharp.Compiler.NameResolution
open Microsoft.FSharp.Compiler.PrettyNaming
open Microsoft.FSharp.Compiler.Parser
open Microsoft.FSharp.Compiler.Range
open Microsoft.FSharp.Compiler.Tast
open Microsoft.FSharp.Compiler.Tastops
open Microsoft.FSharp.Compiler.TcGlobals
open Microsoft.FSharp.Compiler.TypeChecker
open Microsoft.FSharp.Compiler.SourceCodeServices.SymbolHelpers

open Internal.Utilities
open Internal.Utilities.Collections
```

Обратите внимание, что разрыв строки разделяет слои топологическом, при этом каждый слой сортируется в алфавитном порядке. Это четко организует код без случайного затенения значений.

## <a name="use-classes-to-contain-values-that-have-side-effects"></a>Использование классов для хранения значений, имеющих побочные эффекты

Существует много случаев, когда инициализация значения может иметь побочные эффекты, такие как создание экземпляра контекста для базы данных или другого удаленного ресурса. Он позволяет инициализировать такие вещи в модуле и использовать его в последующих функциях:

```fsharp
// This is bad!
module MyApi =
    let dep1 = File.ReadAllText "/Users/{your name}/connectionstring.txt"
    let dep2 = Environment.GetEnvironmentVariable "DEP_2"

    let private r = Random()
    let dep3() = r.Next() // Problematic if multiple threads use this

    let function1 arg = doStuffWith dep1 dep2 dep3 arg
    let function2 arg = doSutffWith dep1 dep2 dep3 arg
```

Это неплохое идея по нескольким причинам:

Во-первых, Конфигурация приложения помещается в базу кода с помощью `dep1` и `dep2`. Это сложно поддерживать в больших базах кода.

Во вторых, статически инициализированные данные не должны содержать значения, которые не являются потокобезопасными, если компонент будет использовать несколько потоков. Это явно нарушается `dep3`.

Наконец, инициализация модуля компилируется в статический конструктор для всей единицы компиляции. Если какая-либо ошибка возникает при инициализации значения с привязкой let в этом модуле, она переносится в качестве `TypeInitializationException`, которая кэшируется в течение всего времени существования приложения. Это может быть трудно диагностировать. Обычно существует внутреннее исключение, которое можно попытаться определить, но в противном случае нет сведений о причине возникновения основной причины.

Вместо этого просто используйте простой класс для хранения зависимостей:

```fsharp
type MyParametricApi(dep1, dep2, dep3) =
    member _.Function1 arg1 = doStuffWith dep1 dep2 dep3 arg1
    member _.Function2 arg2 = doStuffWith dep1 dep2 dep3 arg2
```

Это позволяет выполнять следующие действия:

1. Отправка любого зависимого состояния вне самого API.
2. Теперь конфигурацию можно выполнять за пределами API.
3. Ошибки инициализации зависимых значений, скорее всего, не будут пере`TypeInitializationException`ся в манифест.
4. Теперь API проще тестировать.

## <a name="error-management"></a>Управление ошибками

Управление ошибками в больших системах является сложной и устойчивой задачей, и нет ни одного серебристого маркера, обеспечивающего отказоустойчивость и поведение систем. Приведенные ниже рекомендации должны содержать рекомендации по переходу на эту трудную область.

### <a name="represent-error-cases-and-illegal-state-in-types-intrinsic-to-your-domain"></a>Представляет случаи ошибок и недопустимое состояние в типах, встроенных в ваш домен

С помощью [размеченных объединений](../language-reference/discriminated-unions.md) F# дает возможность представить состояние неисправной программы в системе типов. Пример:

```fsharp
type MoneyWithdrawalResult =
    | Success of amount:decimal
    | InsufficientFunds of balance:decimal
    | CardExpired of DateTime
    | UndisclosedFailure
```

В этом случае может произойти сбой из-за трех известных способов снятия денег с банковского счета. Каждый вариант ошибки представлен в типе и, таким образом, может быть достаточно безопасен во всей программе.

```fsharp
let handleWithdrawal amount =
    let w = withdrawMoney amount
    match w with
    | Success am -> printfn "Successfully withdrew %f" am
    | InsufficientFunds balance -> printfn "Failed: balance is %f" balance
    | CardExpired expiredDate -> printfn "Failed: card expired on %O" expiredDate
    | UndisclosedFailure -> printfn "Failed: unknown"
```

В общем случае, если вы можете моделировать различные способы **сбоя** в вашем домене, код обработки ошибок больше не обрабатывается в дополнение к обычной последовательности программ. Это просто часть обычного потока программы, не признанная **исключительной**. Существует два основных преимущества:

1. С течением времени мы проще поддерживать изменения в домене.
2. Случаи ошибок проще в модульном тесте.

### <a name="use-exceptions-when-errors-cannot-be-represented-with-types"></a>Использовать исключения, если ошибки не могут быть представлены с помощью типов

Не все ошибки могут быть представлены в домене проблемы. Эти типы ошибок являются *исключительными* по своей природе, поэтому возможность вызывать и перехватывать исключения в F#.

Во-первых, рекомендуется ознакомиться с [рекомендациями по проектированию исключений](../../standard/design-guidelines/exceptions.md). Они также применимы к F#.

Основные конструкции, доступные в, F# в целях создания исключений следует учитывать в следующем порядке предпочтения:

| Функция | Синтаксис | Цель |
|----------|--------|---------|
| `nullArg` | `nullArg "argumentName"` | Вызывает `System.ArgumentNullException` с указанным именем аргумента. |
| `invalidArg` | `invalidArg "argumentName" "message"` | Вызывает `System.ArgumentException` с указанным именем аргумента и сообщением. |
| `invalidOp` | `invalidOp "message"` | Вызывает `System.InvalidOperationException` с указанным сообщением. |
|`raise`| `raise (ExceptionType("message"))` | Универсальный механизм для генерации исключений. |
| `failwith` | `failwith "message"` | Вызывает `System.Exception` с указанным сообщением. |
| `failwithf` | `failwithf "format string" argForFormatString` | Вызывает `System.Exception` с сообщением, определяемым строкой формата и его входными данными. |

Используйте `nullArg`, `invalidArg` и `invalidOp` в качестве механизма вызова `ArgumentNullException`, `ArgumentException` и `InvalidOperationException`, если это уместно.

Обычно следует избегать функций `failwith` и `failwithf`, поскольку они создают базовый тип `Exception`, а не определенное исключение. В соответствии с [рекомендациями по проектированию исключений](../../standard/design-guidelines/exceptions.md), когда это возможно, необходимо вызвать более конкретные исключения.

### <a name="using-exception-handling-syntax"></a>Использование синтаксиса обработки исключений

F#поддерживает шаблоны исключений с помощью синтаксиса`try...with`:

```fsharp
try
    tryGetFileContents()
with
| :? System.IO.FileNotFoundException as e -> // Do something with it here
| :? System.Security.SecurityException as e -> // Do something with it here
```

Согласование функций, выполняемых в случае исключения с сопоставлением шаблонов, может быть немного сложным, если вы хотите оставить код нечетким. Одним из способов обработки этого является использование [активных шаблонов](../language-reference/active-patterns.md) в качестве средства для группирования функциональности, окружающей ошибку, с самим исключением. Например, вы можете использовать API, который, когда он создает исключение, заключает в метаданные исключения ценную информацию. Распаковка полезного значения в тексте перехваченного исключения в активном шаблоне и возвращение этого значения может оказаться полезной в некоторых ситуациях.

### <a name="do-not-use-monadic-error-handling-to-replace-exceptions"></a>Не используйте собственную обработку ошибок для замены исключений

Исключения рассматриваются как несколько табу в функциональном программировании. Действительно, исключения нарушают чистоту, поэтому их можно спокойно считать недостаточной функциональностью. Однако это пропускает реальность, где должен выполняться код, и могут возникнуть ошибки времени выполнения. Как правило, написание кода предполагает, что большинство вещей не являются ни чистым, ни итоговым, чтобы максимально упростить неприятные сюрпризы.

Важно учитывать следующие основные сильные стороны и аспекты исключений в отношении их релевантности и адекватности в среде выполнения .NET и многоязыковой экосистемы в целом:

1. Они содержат подробные диагностические сведения, которые очень полезны при отладке проблемы.
2. Они хорошо понятны среде выполнения и другим языкам .NET.
3. Они могут уменьшить значительный шаблон при сравнении с кодом, который *не позволяет избежать* исключений, путем реализации некоторого подмножества их семантики на произвольной основе.

Этот третий момент является критически важным. Для нетривиальных сложных операций невозможность использования исключений может привести к работе с такими структурами:

```fsharp
Result<Result<MyType, string>, string list>
```

Что может легко привести к ненадежному коду, такому как сопоставление шаблонов при ошибках со строковыми типами:

```fsharp
let result = doStuff()
match result with
| Ok r -> ...
| Error e ->
    if e.Contains "Error string 1" then ...
    elif e.Contains "Error string 2" then ...
    else ... // Who knows?
```

Кроме того, может возникнуть желание проглотить любое исключение в случае, если для "простой" функции возвращается тип "лучше":

```fsharp
// This is bad!
let tryReadAllText (path : string) =
    try System.IO.File.ReadAllText path |> Some
    with _ -> None
```

К сожалению, `tryReadAllText` может вызывать многочисленные исключения в зависимости от множества вещей, которые могут произойти в файловой системе, и этот код отклоняет любые сведения о том, что в вашей среде может быть неверно. Если заменить этот код типом результата, то будет выполнен синтаксический анализ сообщения об ошибке с вводом строкового типа:

```fsharp
// This is bad!
let tryReadAllText (path : string) =
    try System.IO.File.ReadAllText path |> Ok
    with e -> Error e.Message

let r = tryReadAllText "path-to-file"
match r with
| Ok text -> ...
| Error e ->
    if e.Contains "uh oh, here we go again..." then ...
    else ...
```

И размещение объекта исключения в конструкторе `Error` просто заставляет вас правильно работать с типом исключения в месте вызова, а не в функции. Это позволяет эффективно создавать проверенные исключения, которые, в свою унфун, могут работать как вызывающий объект API.

Хорошим альтернативой приведенным выше примерам является перехват *конкретных* исключений и возврат осмысленного значения в контексте этого исключения. Если изменить функцию `tryReadAllText` следующим образом, `None` имеет большее значение:

```fsharp
let tryReadAllTextIfPresent (path : string) =
    try System.IO.File.ReadAllText path |> Some
    with :? FileNotFoundException -> None
```

Вместо того, чтобы работать в качестве блока catch-all, эта функция теперь будет правильно обработана, если файл не найден и присвоить это значение возвращаемому значению. Это возвращаемое значение может сопоставляться с этим случаем ошибки, не удаляя никаких контекстных сведений и не требуя от вызывающих объектов обращения к ситуации, которая может не быть актуальной в этой точке кода.

Типы, такие как `Result<'Success, 'Error>`, подходят для основных операций, в которых они не F# являются вложенными, а необязательные типы идеально подходят для представления, когда что-либо может вернуть *что* -либо или *ничего*. Однако они не являются заменой для исключений и не должны использоваться при попытке заменить исключения. Вместо этого их следует применять внимательно, чтобы решить определенные аспекты политики исключений и управления ошибками.

## <a name="partial-application-and-point-free-programming"></a>Частичное программирование приложений и без точек

F#поддерживает частичное применение приложений и, таким образом, различные способы программирования в стиле "без точки". Это может быть полезно для повторного использования кода в модуле или реализации чего-либо, но обычно не является каким-либо общедоступным. Как правило, программирование без точки зрения не является приростом самого себя и может добавить значительный захватывающий барьер для людей, не вошедших в стиль.

### <a name="do-not-use-partial-application-and-currying-in-public-apis"></a>Не используйте частичные приложения и карринг в общедоступных API

При небольшом исключении использование частичного приложения в общедоступных API может вызвать путаницу для потребителей. Обычно значения, привязанные к `let`F# в коде, являются **значениями**, а не **значениями функций**. Сочетание значений и значений функций может привести к сохранению небольшого числа строк кода в Exchange для довольно большого количества системных издержек, особенно в сочетании с операторами, такими как `>>` для создания функций.

### <a name="consider-the-tooling-implications-for-point-free-programming"></a>Примите во внимание особенности разработки средств для программирования без точки зрения

Каррированных функции не помечают свои аргументы. Это влияет на средства. Рассмотрим следующие две функции:

```fsharp
let func name age =
    printfn "My name is %s and I am %d years old!" name age

let funcWithApplication =
    printfn "My name is %s and I am %d years old!"
```

Оба являются допустимыми функциями, но `funcWithApplication` является каррированных функцией. При наведении указателя мыши на типы в редакторе вы увидите следующее:

```fsharp
val func : name:string -> age:int -> unit

val funcWithApplication : (string -> int -> unit)
```

В месте вызова всплывающие подсказки в инструментарии, такие как Visual Studio, не предоставляют осмысленной информации о том, как фактически представляются типы входных данных `string` и `int`.

Если вы столкнулись с кодом без точки, например `funcWithApplication`, который является общедоступным, рекомендуется выполнить полное расширение η, чтобы средства могли получать осмысленные имена для аргументов.

Кроме того, код без поддержки точек отладки может быть непростым, если это невозможно. Средства отладки зависят от значений, привязанных к именам (например, `let` привязок), чтобы можно было проверять промежуточные значения в середине по исполнению. Если код не имеет значений для проверки, отладка не требуется. В будущем средства отладки могут развиваться для синтезирования этих значений с учетом ранее выполненных путей, но не рекомендуется хеджирование свои элементы на *потенциальные* функции отладки.

### <a name="consider-partial-application-as-a-technique-to-reduce-internal-boilerplate"></a>Рассмотрите частичные приложения как методику сокращения внутреннего стандартного

В отличие от предыдущей точки, частичное применение — это замечательное средство для сокращения стандартного в приложении или более глубоких внутренних компонентов API. Он может быть полезен для модульного тестирования реализации более сложных интерфейсов API, где часто возникает проблема с шаблоном. Например, в следующем коде показано, как можно добиться того, что большинство инфраструктурных макетов позволит вам не брать внешнюю зависимость от такой платформы, а также изучать связанный API-интерфейс.

Например, рассмотрим следующее решение топографии:

```
MySolution.sln
|_/ImplementationLogic.fsproj
|_/ImplementationLogic.Tests.fsproj
|_/API.fsproj
```

`ImplementationLogic.fsproj` может представлять код, например:

```fsharp
module Transactions =
    let doTransaction txnContext txnType balance =
        ...

type Transactor(ctx, currentBalance) =
    member _.ExecuteTransaction(txnType) =
        Transactions.doTransaction ctx txtType currentBalance
        ...
```

Модульное тестирование `Transactions.doTransaction` в `ImplementationLogic.Tests.fsproj` — это просто:

```fsharp
namespace TransactionsTestingUtil

open Transactions

module TransactionsTestable =
    let getTestableTransactionRoutine mockContext = Transactions.doTransaction mockContext
```

Частичное применение `doTransaction` с объектом контекста макетирования позволяет вызывать функцию во всех модульных тестах, не требуя каждый раз создавать макет макета.

```fsharp
namespace TransactionTests

open Xunit
open TransactionTypes
open TransactionsTestingUtil
open TransactionsTestingUtil.TransactionsTestable

let testableContext =
    { new ITransactionContext with
        member _.TheFirstMember() = ...
        member _.TheSecondMember() = ... }

let transactionRoutine = getTestableTransactionRoutine testableContext

[<Fact>]
let ``Test withdrawal transaction with 0.0 for balance``() =
    let expected = ...
    let actual = transactionRoutine TransactionType.Withdraw 0.0
    Assert.Equal(expected, actual)
```

Этот метод не должен применяться к всей базе кода в универсальном коде, но это хороший способ сокращения стандартного для сложных внутренних компонентов и модульного тестирования этих внутренних компонентов.

## <a name="access-control"></a>Управление доступом

F#имеет несколько параметров для [управления доступом](../language-reference/access-control.md), наследуемых от доступных в среде выполнения .NET. Они не просто могут использоваться для типов. их также можно использовать для функций.

* Предпочитать типы и члены, не относящиеся к`public`, до тех пор, пока они не понадобятся для общего использования. Это также сводится к уменьшению числа потребителей, с которыми связана пара.
* Оставайтесь в курсе всех вспомогательных функций `private`.
* Рекомендуется использовать `[<AutoOpen>]` в частном модуле вспомогательных функций, если они становятся многочисленными.

## <a name="type-inference-and-generics"></a>Определение типа и универсальные шаблоны

Определение типа может помочь вам в вводе большого числа шаблонов. И автоматическое обобщение в F# компиляторе может помочь в написании более универсального кода с практически без дополнительных усилий. Однако эти функции не являются универсальными.

* Рекомендуется помечать имена аргументов явными типами в общедоступных API и не полагаться на вывод типа для этого.

    Причина в том, что **вы** должны контролировать форму API, а не компилятор. Несмотря на то, что компилятор может выполнять хорошее задание в выведение типов, можно изменить форму API, если внутренние компоненты, от которых он зависит, изменили типы. Это может быть то, что вам нужно, но это почти наверняка приведет к прерыванию изменения API, с которым потом нижестоящим потребителям придется справиться. Вместо этого, если вы явно управляете формой открытого API, вы можете управлять этими критическими изменениями. В терминах DDD это можно рассматривать как уровень защиты от повреждений.

* Рекомендуется дать универсальным аргументам понятное имя.

    Если вы не пишете действительно универсальный код, который не относится к конкретному домену, понятное имя может помочь другим программистам понять, в каком домене они работают. Например, параметр типа с именем `'Document` в контексте взаимодействия с базой данных документов делает более ясно, что универсальные типы документов могут быть приняты функцией или членом, с которым вы работаете.

* Рассмотрите возможность именования параметров универсального типа с помощью PascalCase.

    Это общий способ выполнить действия в .NET, поэтому рекомендуется использовать PascalCase, а не snake_case или camelCase.

Наконец, автоматическое обобщение не всегда является boonом для тех, кто не является F# новым в или большой базе кода. При использовании универсальных компонентов существуют накладные расходы на переприятие. Более того, если автоматически обобщенные функции не используются с различными типами входных данных (то есть если они предназначены для использования), то в этот момент времени не существует реальных преимуществ. Всегда учитывайте, что код, который вы пишете, будет действительно выгодным.

## <a name="performance"></a>Производительность

F#значения по умолчанию являются неизменяемыми, что позволяет избежать определенных классов ошибок (особенно связанных с параллелизмом и параллелизмом). Однако в некоторых случаях, чтобы достичь оптимальной (или даже разумной) эффективности времени выполнения или выделения памяти, объем работы можно реализовать с помощью изменения состояния на месте. Это можно сделать F# с помощью ключевого слова`mutable`.

Однако использование `mutable` в F# может быть, скорее всего, с функциональной чистотой. Это нормально, если вы настраиваете ожидания от чистоты до [ссылочной прозрачности](https://en.wikipedia.org/wiki/Referential_transparency). Ссылочная прозрачность — не чистота — конечная цель при F# написании функций. Это позволяет написать функциональный интерфейс с реализацией на основе изменений для критичного в производительности кода.

### <a name="wrap-mutable-code-in-immutable-interfaces"></a>Перенос изменяемого кода в неизменяемые интерфейсы

При использовании ссылочной прозрачности в качестве цели очень важно написать код, который не предоставляет изменяемую ненужные функции, критические для производительности. Например, следующий код реализует функцию `Array.contains` в F# основной библиотеке:

```fsharp
[<CompiledName("Contains")>]
let inline contains value (array:'T[]) =
    checkNonNull "array" array
    let mutable state = false
    let mutable i = 0
    while not state && i < array.Length do
        state <- value = array.[i]
        i <- i + 1
    state
```

Многократное обращение к этой функции не приводит к изменению базового массива, а также не требует поддержки какого либо изменяющегося состояния при его использовании. Эта функция прозрачна, даже если в ней почти каждая строка кода использует изменения.

### <a name="consider-encapsulating-mutable-data-in-classes"></a>Рассмотрите возможность инкапсуляции изменяемых данных в классы

В предыдущем примере использовалась одна функция для инкапсуляции операций с использованием изменяемых данных. Это не всегда достаточно для более сложных наборов данных. Рассмотрим следующие наборы функций:

```fsharp
open System.Collections.Generic

let addToClosureTable (key, value) (t: Dictionary<_,_>) =
    if not (t.ContainsKey(key)) then
        t.Add(key, value)
    else
        t.[key] <- value

let closureTableCount (t: Dictionary<_,_>) = t.Count

let closureTableContains (key, value) (t: Dictionary<_, HashSet<_>>) =
    match t.TryGetValue(key) with
    | (true, v) -> v.Equals(value)
    | (false, _) -> false
```

Этот код является выполняемым, но он предоставляет структуру данных на основе изменений, которые вызывающие объекты отвечают за обслуживание. Это можно обернуть внутри класса без базовых членов, которые могут измениться:

```fsharp
open System.Collections.Generic

/// The results of computing the LALR(1) closure of an LR(0) kernel
type Closure1Table() =
    let t = Dictionary<Item0, HashSet<TerminalIndex>>()

    member _.Add(key, value) =
        if not (t.ContainsKey(key)) then
            t.Add(key, value)
        else
            t.[key] <- value

    member _.Count = t.Count

    member _.Contains(key, value) =
        match t.TryGetValue(key) with
        | (true, v) -> v.Equals(value)
        | (false, _) -> false
```

`Closure1Table` инкапсулирует базовую структуру данных на основе изменений, тем самым не представляя вызывающие объекты поддерживать базовую структуру данных. Классы — это мощный способ инкапсуляции данных и подпрограмм, основанных на возможностях, без предоставления сведений вызывающим объектам.

### <a name="prefer-let-mutable-to-reference-cells"></a>Предпочитать `let mutable` для ссылок на ячейки

Ссылочные ячейки — это способ представления ссылки на значение, а не само значение. Хотя они могут использоваться для критичного в производительности кода, они обычно не рекомендуются. Рассмотрим следующий пример.

```fsharp
let kernels =
    let acc = ref Set.empty

    processWorkList startKernels (fun kernel ->
        if not ((!acc).Contains(kernel)) then
            acc := (!acc).Add(kernel)
        ...)

    !acc |> Seq.toList
```

Использование ссылочной ячейки теперь «засоряет» все последующие коды с целью разыменования и повторной ссылки на базовые данные. Вместо этого рассмотрите `let mutable`:

```fsharp
let kernels =
    let mutable acc = Set.empty

    processWorkList startKernels (fun kernel ->
        if not (acc.Contains(kernel)) then
            acc <- acc.Add(kernel)
        ...)

    acc |> Seq.toList
```

Помимо единственной точки изменения в середине лямбда-выражения, весь остальной код, который касается `acc`, может сделать это так, что не отличается от использования обычного неизменяемого значения, привязанного к `let`. Это упростит изменение со временем.

## <a name="object-programming"></a>Программирование объектов

F#обеспечивает полную поддержку объектов и объектно-ориентированных концепций (ОО). Хотя многие основные понятия ОО являются мощными и полезными, не все из них идеально подходят для использования. В следующих списках приведены рекомендации по категориям функций ОО на высоком уровне.

**Рассмотрите возможность использования этих функций во многих ситуациях.**

* Точечная нотация (`x.Length`)
* Члены экземпляра
* Неявные конструкторы
* Статические члены
* Нотация индексатора (`arr.[x]`)
* Именованные и необязательные аргументы
* Реализации интерфейсов и интерфейсов

**Не обращайтесь к этим функциям первыми, но применяйте их разумным образом, когда они удобны для решения проблемы:**

* Перегрузка методов
* Инкапсулированные изменяемые данные
* Операторы в типах
* Автоматические свойства
* Реализация `IDisposable` и `IEnumerable`
* Расширения типов
* события
* структурам;
* Делегаты
* перечислениям;

**Как правило, Избегайте этих функций, если их не нужно использовать:**

* Иерархии типов на основе наследования и наследование реализации
* Значения NULL и `Unchecked.defaultof<_>`

### <a name="prefer-composition-over-inheritance"></a>Предпочитать композицию наследования

[Композиция с наследованием](https://en.wikipedia.org/wiki/Composition_over_inheritance) — это долгий идиом, который F# может придерживаться хорошего кода. Основной принцип заключается в том, что не следует предоставлять базовый класс и заставить вызывающие объекты наследовать от этого базового класса для получения функциональности.

### <a name="use-object-expressions-to-implement-interfaces-if-you-dont-need-a-class"></a>Использование выражений объектов для реализации интерфейсов, если не требуется класс

[Выражения объектов](../language-reference/object-expressions.md) позволяют реализовать интерфейсы на лету, привязывая реализованный интерфейс к значению без необходимости делать это внутри класса. Это удобно, особенно если требуется _только_ реализовать интерфейс и не требуется полный класс.

Например, ниже приведен код, который выполняется в [Ionide](http://ionide.io/) для предоставления действия по исправлению кода, если вы добавили символ, для которого у вас нет оператора `open`:

```fsharp
    let private createProvider () =
        { new CodeActionProvider with
            member this.provideCodeActions(doc, range, context, ct) =
                let diagnostics = context.diagnostics
                let diagnostic = diagnostics |> Seq.tryFind (fun d -> d.message.Contains "Unused open statement")
                let res =
                    match diagnostic with
                    | None -> [||]
                    | Some d ->
                        let line = doc.lineAt d.range.start.line
                        let cmd = createEmpty<Command>
                        cmd.title <- "Remove unused open"
                        cmd.command <- "fsharp.unusedOpenFix"
                        cmd.arguments <- Some ([| doc |> unbox; line.range |> unbox; |] |> ResizeArray)
                        [|cmd |]
                res
                |> ResizeArray
                |> U2.Case1
        }
```

Поскольку при взаимодействии с Visual Studio Code API не требуется класс, выражения объектов являются идеальным средством для этого. Они также полезны при модульном тестировании, когда необходимо создать заглушку интерфейса с помощью подпрограмм тестирования нерегламентированным способом.

## <a name="consider-type-abbreviations-to-shorten-signatures"></a>Рекомендуется использовать сокращения типов для сокращения сигнатур

[Аббревиатуры типов](../language-reference/type-abbreviations.md) — это удобный способ назначения метки другому типу, например сигнатуре функции или более сложному типу. Например, следующий псевдоним назначает метку, необходимую для определения вычислений с помощью [CNTK](https://docs.microsoft.com/cognitive-toolkit/), библиотеки глубокого обучения:

```fsharp
open CNTK

// DeviceDescriptor, Variable, and Function all come from CNTK
type Computation = DeviceDescriptor -> Variable -> Function
```

Имя `Computation` — это удобный способ обозначить любую функцию, совпадающую с сигнатурой, которая является псевдонимом. Использование сокращенных обоподобие типов удобно и позволяет использовать более сжатый код.

### <a name="avoid-using-type-abbreviations-to-represent-your-domain"></a>Избегайте использования сокращений типов для представления домена

Хотя аббревиатуры типов удобно использовать для присвоения имени сигнатурам функций, они могут вызывать путаницу, если аббревиатинг другие типы. Рассмотрим следующее сокращение:

```fsharp
// Does not actually abstract integers.
type BufferSize = int
```

Это может быть затруднено несколькими способами:

* `BufferSize` не является абстракцией; Это просто другое имя для целого числа.
* Если `BufferSize` предоставляется в общедоступном API, он легко интерпретируется как неправильное, что означает не только `int`. Как правило, типы домена имеют несколько атрибутов и не являются примитивными типами, такими как `int`. Это сокращение нарушает это допущение.
* Регистр `BufferSize` (PascalCase) подразумевает, что этот тип содержит больше данных.
* Этот псевдоним не обеспечивает повышенную четкость по сравнению с предоставлением именованного аргумента функции.
* Аббревиатура не будет сокомпилироваться в скомпилированном IL; Это всего лишь целое число, а этот псевдоним является конструкцией времени компиляции.

```fsharp
module Networking =
    ...
    let send data (bufferSize: int) = ...
```

В целом, ловушки с сокращениями типов заключаются в том, что они **не** являются абстракциями для типов, которые они аббревиатинг. В предыдущем примере `BufferSize` — это просто `int`, который не содержит дополнительных данных, а также любые преимущества системы типов, Кроме того, что `int` уже есть.

Альтернативный подход к использованию сокращений типов для представления домена — Использование размеченных объединений с одним вариантом. Предыдущий пример можно смоделировать следующим образом:

```fsharp
type BufferSize = BufferSize of int
```

При написании кода, который работает в терминах `BufferSize` и его базовом значении, необходимо создать один из них вместо передачи любого произвольного целого числа:

```fsharp
module Networking =
    ...
    let send data (BufferSize size) =
    ...
```

Это уменьшает вероятность ошибочного перепередачи произвольного целого числа в функцию `send`, так как вызывающий объект должен создать `BufferSize` тип для заключения значения перед вызовом функции.
