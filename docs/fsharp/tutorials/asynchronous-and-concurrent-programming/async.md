---
title: Асинхронное программирование
description: Узнайте, как F# асинхронного программирования можно выполнить посредством модель языка программирования, простой в использовании и естественный язык.
ms.date: 06/20/2016
ms.openlocfilehash: 8cd7d7bcecabe8ea2c33a4787fe9ebbadd67fe67
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2019
ms.locfileid: "64753592"
---
# <a name="async-programming-in-f"></a>Асинхронное программирование на языке f #\#

> [!NOTE]
> В этой статье были обнаружены некоторые неточности.  Она переписывается.  См. в разделе [проблема № 666](https://github.com/dotnet/docs/issues/666) Дополнительные сведения об изменениях.

Асинхронное программирование в F# решается с помощью модели программирования уровня языка должна быть простой в использовании и естественный язык.

Основой асинхронного программирования в F# — `Async<'T>`, представление работы, который можно активировать для выполнения в фоновом режиме, где `'T` — либо тип, возвращаемый через специальную `return` ключевое слово или `unit` если асинхронный рабочий процесс не имеет результатов для возврата.

Ключевым принципом, чтобы понять, является тип выражение async `Async<'T>`, который является просто _спецификации_ выполняться в контексте асинхронной работы. Он не будет работать, пока не запустить ее явно с помощью одного из начала функции (такие как `Async.RunSynchronously`). Несмотря на то, что это другой способ думать о работу, в конечном итоге довольно проста, на практике.

Например предположим, что вы хотите скачать код HTML из dotnetfoundation.org без блокирования основного потока. Его можно сделать следующим образом:

```fsharp
open System
open System.Net

let fetchHtmlAsync url =
    async {
        let uri = Uri(url)
        use webClient = new WebClient()

        // Execution of fetchHtmlAsync won't continue until the result
        // of AsyncDownloadString is bound.
        let! html = webClient.AsyncDownloadString(uri)
        return html
    }

let html = "https://dotnetfoundation.org" |> fetchHtmlAsync |> Async.RunSynchronously
printfn "%s" html
```

Вот и все! Несмотря на использование `async`, `let!`, и `return`, это просто нормально F# кода.

Существует несколько синтаксических конструкций, которые стоит обратить внимание:

* `let!` Привязывает результат выражения async (выполняющегося в другом контексте).
* `use!` работает аналогично `let!`, но удаляет ее связанных ресурсов в том случае, когда оно выходит за пределы области.
* `do!` будет ожидать асинхронный рабочий процесс, который не возвращает ничего.
* `return` просто возвращает результат из асинхронного выражения.
* `return!` выполняет другой асинхронный рабочий процесс и возвращает его возвращаемое значение в результате.

Кроме того обычные `let`, `use`, и `do` ключевые слова могут использоваться вместе со асинхронные версии, так же, как это было бы в обычной функции.

## <a name="how-to-start-async-code-in-f"></a>Запуск асинхронного кода на языке f #\#

Как уже упоминалось, асинхронный код представляет собой спецификацию должны быть выполнены в другом контексте, который должен быть явным образом запущено. Ниже приведены два основных способа выполнения этой задачи:

1. `Async.RunSynchronously` запускается поток async в другом потоке и ожидает его результат.

    ```fsharp
    open System
    open System.Net

    let fetchHtmlAsync url =
        async {
            let uri = Uri(url)
            use webClient = new WebClient()
            let! html = webClient.AsyncDownloadString(uri)
            return html
        }

    // Execution will pause until fetchHtmlAsync finishes
    let html = "https://dotnetfoundation.org" |> fetchHtmlAsync |> Async.RunSynchronously

    // you actually have the result from fetchHtmlAsync now!
    printfn "%s" html
    ```

2. `Async.Start` Запуск рабочего процесса async в другом потоке и будет **не** ожидает его результат.

    ```fsharp
    open System
    open System.Net

    let uploadDataAsync url data =
        async {
            let uri = Uri(url)
            use webClient = new WebClient()
            webClient.UploadStringAsync(uri, data)
        }

    let workflow = uploadDataAsync "https://url-to-upload-to.com" "hello, world!"

    // Execution will continue after calling this!
    Async.Start(workflow)

    printfn "%s" "uploadDataAsync is running in the background..."
    ```

Существуют другие способы запуска асинхронного рабочего процесса, доступного для конкретных сценариев. Они подробно описаны [справочника по Async](https://msdn.microsoft.com/library/ee370232.aspx).

### <a name="a-note-on-threads"></a>Примечание о потоках

Фраза «в другом потоке» упомянутой выше, но очень важно знать, что **это не означает, что асинхронных рабочих потоков являются фасадом для многопоточности**. Рабочий процесс фактически «переходит» между потоками, заимствуя их для небольшой объем выполнять полезную работу. Когда поток async эффективно «ожидает» (например, ожидания сетевого вызова, чтобы он возвращал нечто), любой поток, который он займов во время освобождается до перейдите выполнять полезную работу на что-то еще. Это позволяет асинхронных рабочих потоков для использования системы, в которой они выполняются так же эффективно и делает их особенно высоки сценариях с большим количеством операций ввода-вывода.

## <a name="how-to-add-parallelism-to-async-code"></a>Добавление параллелизма в асинхронный код

Иногда можно требуется для выполнения нескольких асинхронных заданий в параллельном режиме, собирать их результаты и интерпретировать их каким-либо образом. `Async.Parallel` позволяет это сделать без необходимости использования библиотеки параллельных задач, на которой будет включать в себя необходимости приводимое `Task<'T>` и `Async<'T>` типов.

Следующий пример будет использоваться `Async.Parallel` Чтобы загрузить HTML-код из четырех популярных сайтов в параллельном режиме, дождитесь завершения выполнения этих задач и затем напечатайте HTML, который был загружен.

```fsharp
open System
open System.Net

let urlList =
    [ "https://www.microsoft.com"
      "https://www.google.com"
      "https://www.amazon.com"
      "https://www.facebook.com" ]

let fetchHtmlAsync url =
    async {
        let uri = Uri(url)
        use webClient = new WebClient()
        let! html = webClient.AsyncDownloadString(uri)
        return html
    }

let getHtmlList urls =
    urls
    |> Seq.map fetchHtmlAsync   // Build an Async<'T> for each site
    |> Async.Parallel           // Returns an Async<'T []>
    |> Async.RunSynchronously   // Wait for the result of the parallel work

let htmlList = getHtmlList urlList

// We now have the downloaded HTML for each site!
for html in htmlList do
    printfn "%s" html
```

## <a name="important-info-and-advice"></a>Важные сведения и советы

* Добавьте «Async» в конец любой функции, которые вы будете использовать

 Несмотря на то, что это просто соглашения об именовании, он облегчить как возможность обнаружения API. Особенно в том случае, если существуют синхронные и асинхронные версии той же подпрограммы, рекомендуется явно указать, который выполняется асинхронно с помощью имени.

* Прослушайте компилятор!

F#в компилятор очень строгие, делая практически невозможно сделать что-то беспокоят как синхронное выполнение кода «async». Если вам встретится предупреждение, это знак, что код не будет выполняться, как вы считаете, что будет происходить. Если компилятор может сделать удачного, код скорее всего будет выполнен должным образом.

## <a name="for-the-cvb-programmer-looking-into-f"></a>Для C#и Visual Basic программист, рассматривая F\#

В этом разделе предполагается, что вы знакомы с моделью async в C#/VB. Если вы не, [асинхронного программирования в C# ](../../../csharp/async.md) является отправной точкой.

Есть фундаментальные различия между C#модели асинхронного и Visual Basic и F# асинхронной модели.

При вызове функции, которая возвращает `Task` или `Task<'T>`, это задание уже началось выполнение. Дескриптор, возвращенный представляет задание уже выполняющейся асинхронной. Напротив, при вызове асинхронной функции F#, `Async<'a>` возвращается представляет задание, которое будет иметь **создан** в определенный момент. Основные сведения об этой модели обладает широкими возможностями, так как он позволяет асинхронных заданий в F# объединять в цепочку, выполняется по условию и запускаться с большей степенью детализации в элемент управления.

Существует несколько других сходства и различия, следует отметить.

### <a name="similarities"></a>Сходства

* `let!`, `use!`, и `do!` аналогичны `await` при вызове задание async изнутри `async{ }` блока.

  Три ключевых слова можно использовать только в пределах `async { }` блока, подобно тому, как `await` может быть вызван только внутри `async` метод. Короче говоря `let!` применяется для записи и использовании результате `use!` является прежним, но для чего-нибудь, ресурсы которых следует удаляются после его использования, и `do!` применяется для ожидания для асинхронных рабочего процесса без возвращаемого значения, чтобы завершить Прежде чем продолжить.

* F#поддерживает параллелизм данных аналогичным образом.

  Несмотря на то, что она работает очень по-разному, `Async.Parallel` соответствует `Task.WhenAll` для сценария реагируя результаты набор заданий async после их полного завершения.

### <a name="differences"></a>Различия

* Вложенные `let!` не разрешено, в отличие от вложенных `await`

  В отличие от `await`, которой могут быть вложенными неопределенно долгое время, `let!` не может и должен иметь результат привязан перед его использованием внутрь другой `let!`, `do!`, или `use!`.

* Поддержка отмены проще в F# чем в C#/VB.

  Поддержка отмены задачи во время его выполнения C#и Visual Basic требуется выполнить проверку `IsCancellationRequested` свойства или вызов `ThrowIfCancellationRequested()` на `CancellationToken` объект, который передается в асинхронный метод.

Напротив F# более естественным образом будет поддерживать отмену асинхронных рабочих потоков. Отмена является простой трехшаговый процесс.

1. Создайте объект `CancellationTokenSource`.
2. Передайте его в функция запуска.
3. Вызовите `Cancel` в маркере.

Пример

```fsharp
open System.Threading

// Create a workflow which will loop forever.
let workflow =
    async {
        while true do
            printfn "Working..."
            do! Async.Sleep 1000
    }

let tokenSource = new CancellationTokenSource()

// Start the workflow in the background
Async.Start (workflow, tokenSource.Token)

// Executing the next line will stop the workflow
tokenSource.Cancel()
```

Вот и все!

## <a name="further-resources"></a>Дополнительные ресурсы:

* [Асинхронных рабочих потоков на сайте MSDN](https://msdn.microsoft.com/library/dd233250.aspx)
* [Асинхронные последовательностей дляF#](https://fsprojects.github.io/FSharp.Control.AsyncSeq/library/AsyncSeq.html)
* [F#Служебные программы данных HTTP](https://fsharp.github.io/FSharp.Data/library/Http.html)
