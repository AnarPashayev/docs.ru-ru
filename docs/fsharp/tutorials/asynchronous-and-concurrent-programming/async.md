---
title: Программирование Async
description: Узнайте, как Фз обеспечивает чистую поддержку асинхронности на основе модели программирования на языковом уровне, основанной на основных функциональных концепциях программирования.
ms.date: 12/17/2018
ms.openlocfilehash: 9b2e3057c126d84474c21fde653da5bbee32938a
ms.sourcegitcommit: d9470d8b2278b33108332c05224d86049cb9484b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2020
ms.locfileid: "81608040"
---
# <a name="async-programming-in-f"></a>Программирование Async в F\#

Асинхронное программирование является механизмом, который имеет важное значение для современных приложений по разным причинам. Существует два основных случая использования, с которыми столкнутся большинство разработчиков:

- Представление серверного процесса, который может обслуживать значительное количество одновременных входящих запросов, при минимизации ресурсов системы, занятых при обработке запросов, ждет входных данных от систем или служб, внешних для этого процесса
- Поддержание адаптивного uI или основного потока при одновременном прогрессе фоновой работы

Хотя фоновая работа часто включает в себя использование нескольких потоков, важно рассматривать понятия асинхронности и многопоточности отдельно. На самом деле, они являются отдельными проблемами, и одно не подразумевает другое. Ниже приводится в этой статье описываетэто это более подробно.

## <a name="asynchrony-defined"></a>Асинхрония определена

Предыдущий пункт - что асинхронность не зависит от использования нескольких потоков - стоит объяснить немного дальше. Есть три понятия, которые иногда связаны, но строго независимо друг от друга:

- Параллель; при выполнении нескольких вычислений в перекрывающихся периодах времени.
- Параллелизм; когда несколько вычислений или несколько частей одной вычислений работают в одно и то же время.
- Асинхронность; когда один или несколько вычислений могут выполняться отдельно от основного потока программы.

Все три ортогональных концепций, но могут быть легко conflated, особенно когда они используются вместе. Например, может потребоваться параллельно еранды несколько асинхронных вычислений. Это не означает, что параллелизм или асинхронность подразумевают друг друга.

Если вы считаете, этимология слова "асинхронный", Есть две части участие:

- "а", что означает "не".
- "синхронный", что означает "в то же время".

Когда вы поставите эти два термина вместе, вы увидите, что "асинхронный" означает "не в то же время". Вот и все! В этом определении нет никаких последствий параллелизма или параллелизма. Это также верно на практике.

В практическом плане асинхронные вычисления в ФЗ планируется выполнять независимо от основного потока программы. Это не означает параллелизм или параллелизм, а также не означает, что вычисление всегда происходит в фоновом режиме. На самом деле, асинхронные вычисления могут даже выполняться синхронно, в зависимости от характера вычислений и среды, в которой выполняется вычисление.

Основной вынос вы должны иметь в том, что асинхронные вычисления не зависят от основного потока программы. Хотя есть несколько гарантий о том, когда и как выполняется асинхронная вычисления, существуют некоторые подходы к их организации и планированию. В остальной части этой статьи рассматриваются основные концепции для асинхронности F и как использовать типы, функции и выражения, встроенные в F.

## <a name="core-concepts"></a>Ключевые понятия

В F, асинхронное программирование сосредоточено вокруг трех основных концепций:

- Тип, `Async<'T>` представляющий собой композитные асинхронные вычисления.
- Функции `Async` модуля, позволяющие планировать асинхронную работу, составляют асинхронные вычисления и преобразуют асинхронные результаты.
- Вычислительное `async { }` [выражение,](../../language-reference/computation-expressions.md)которое обеспечивает удобный синтаксис для создания и управления асинхронными вычислениями.

Вы можете увидеть эти три понятия в следующем примере:

```fsharp
open System
open System.IO

let printTotalFileBytes path =
    async {
        let! bytes = File.ReadAllBytesAsync(path) |> Async.AwaitTask
        let fileName = Path.GetFileName(path)
        printfn "File %s has %d bytes" fileName bytes.Length
    }

[<EntryPoint>]
let main argv =
    printTotalFileBytes "path-to-file.txt"
    |> Async.RunSynchronously

    Console.Read() |> ignore
    0
```

В примере `printTotalFileBytes` функция типа `string -> Async<unit>`. Вызов функции на самом деле не выполняет асинхронные вычисления. Вместо этого, `Async<unit>` он возвращает, что выступает в качестве *спецификации* работы, которая должна выполнять сяврону. Оно `Async.AwaitTask` вызывает в своем теле, которое преобразовывает результат <xref:System.IO.File.ReadAllBytesAsync%2A> к соотвествуя типу.

Другой важной линией `Async.RunSynchronously`является призыв к . Это одна из стартовых функций модуля Async, которую необходимо вызвать, если вы хотите выполнить асинхронные вычисления.

Это принципиальное отличие от базового стиля `async` программирования с C'/Visual. В F-, асинхронные вычисления можно рассматривать как **холодные задачи**. Они должны быть явно начали на самом деле выполнять. Это имеет некоторые преимущества, так как позволяет комбинировать и последовательности асинхронных работ гораздо легче, чем в C- или Visual Basic.

## <a name="combine-asynchronous-computations"></a>Объедините асинхронные вычисления

Вот пример, который опирается на предыдущий, комбинируя вычисления:

```fsharp
open System
open System.IO

let printTotalFileBytes path =
    async {
        let! bytes = File.ReadAllBytesAsync(path) |> Async.AwaitTask
        let fileName = Path.GetFileName(path)
        printfn "File %s has %d bytes" fileName bytes.Length
    }

[<EntryPoint>]
let main argv =
    argv
    |> Array.map printTotalFileBytes
    |> Async.Parallel
    |> Async.Ignore
    |> Async.RunSynchronously

    0
```

Как вы можете `main` видеть, функция имеет довольно много больше звонков. Концептуально он делает следующее:

1. Преобразование аргументов командной строки в `Async<unit>` вычисления с помощью `Array.map`.
2. Создайте `Async<'T[]>` расписание и `printTotalFileBytes` запуск вычислений параллельно при запуске.
3. `Async<unit>` Создайте, который будет запускать параллельные вычисления и игнорировать его результат.
4. Явно запускать последние `Async.RunSynchronously` вычисления с и блокировать, пока он не будет завершен.

Когда эта программа `printTotalFileBytes` выполняется, выполняется параллельно для каждого аргумента командной строки. Поскольку асинхронные вычисления выполняются независимо от потока программы, нет порядка, в котором они печатают свою информацию и заканчивают выполнение. Вычисления будут запланированы параллельно, но их порядок выполнения не гарантируется.

## <a name="sequence-asynchronous-computations"></a>Последовательность асинхронных вычислений

Поскольку `Async<'T>` спецификация работы, а не уже запущенная задача, вы можете легко выполнять более сложные преобразования. Вот пример, который последовательности набор вычислений Async, чтобы они выполняют один за другим.

```fsharp
let printTotalFileBytes path =
    async {
        let! bytes = File.ReadAllBytesAsync(path) |> Async.AwaitTask
        let fileName = Path.GetFileName(path)
        printfn "File %s has %d bytes" fileName bytes.Length
    }

[<EntryPoint>]
let main argv =
    argv
    |> Array.map printTotalFileBytes
    |> Async.Sequential
    |> Async.Ignore
    |> Async.RunSynchronously
    |> ignore
```

Это будет `printTotalFileBytes` график для выполнения в `argv` порядке элементов, а не планирование их параллельно. Поскольку следующий элемент не будет запланирован до завершения выполнения последнего вычисления, вычисления секвенируются таким образом, что в их выполнении нет перекрытия.

## <a name="important-async-module-functions"></a>Важные функции модуля Async

Когда вы пишете код async в F,, вы обычно взаимодействуете с инфраструктурой, которая обрабатывает планирование вычислений для вас. Однако, это не всегда так, так что это хорошо, чтобы узнать различные стартовые функции, чтобы запланировать асинхронную работу.

Поскольку асинхронные вычисления являются _спецификацией_ работы, а не представлением уже выполнения работы, они должны быть явно запущены с исходной функции. Есть много [стартовых функций Async,](https://msdn.microsoft.com/library/ee370232.aspx) которые полезны в различных контекстах. В следующем разделе описаны некоторые из наиболее распространенных стартовых функций.

### <a name="asyncstartchild"></a>Async.StartChild

Запускает вычисление ребенка в рамках асинхронных вычислений. Это позволяет выполнять одновременно несколько асинхронных вычислений. Вычисление ребенка разделяет токен отмены с родительскими вычислениями. Если родительские вычисления отменены, вычисления ребенка также отменяются.

Сигнатура:

```fsharp
computation: Async<'T> * timeout: ?int -> Async<Async<'T>>
```

Когда следует использовать:

- Если вы хотите выполнить несколько асинхронных вычислений одновременно, а не по одному за раз, но не планируется их параллельно.
- Если вы хотите связать срок службы детского вычисления с родительскими вычислениями.

На что обратить сяочку:

- Запуск нескольких вычислений `Async.StartChild` с не то же самое, что планировать их параллельно. Если вы хотите планировать вычисления параллельно, используйте `Async.Parallel`.
- Отмена родительских вычислений вызовет отмену всех начатых ими детских вычислений.

### <a name="asyncstartimmediate"></a>Async.StartImmediate

Запускает асинхронные вычисления, начиная сразу с текущего потока операционной системы. Это полезно, если вам нужно обновить что-то на потоке вызова во время вычислений. Например, если асинхронные вычисления должны обновлять ui (например, обновление панели прогресса), следует `Async.StartImmediate` использовать его.

Сигнатура:

```fsharp
computation: Async<unit> - cancellationToken: ?CancellationToken -> unit
```

Когда следует использовать:

- Когда вам нужно обновить что-то на потоке вызова в середине асинхронных вычислений.

На что обратить сяочку:

- Код в асинхронных вычислениях будет работать на любом потоке, на который, случается, запланировано. Это может быть проблематично, если этот поток каким-то образом чувствителен, например поток uI. В таких `Async.StartImmediate` случаях, скорее всего, нецелесообразно использовать.

### <a name="asyncstartastask"></a>Async.StartasTask

Выполняет вычисление в пуле потоков. <xref:System.Threading.Tasks.Task%601> Возвращает, которая будет завершена в соответствующем состоянии после завершения вычислений (производит результат, выбрасывает исключение или отменяется). Если токен отмены не предусмотрен, используется токен отмены по умолчанию.

Сигнатура:

```fsharp
computation: Async<'T> - taskCreationOptions: ?TaskCreationOptions - cancellationToken: ?CancellationToken -> Task<'T>
```

Когда следует использовать:

- При необходимости вызова API .NET, <xref:System.Threading.Tasks.Task%601> который ожидает, что будет представлен результат асинхронных вычислений.

На что обратить сяочку:

- Этот вызов будет `Task` выделять дополнительный объект, который может увеличить накладные расходы, если он используется часто.

### <a name="asyncparallel"></a>Async.Parallel

Расписание последовательности асинхронных вычислений, которые должны выполняться параллельно. Степень параллелизма может быть дополнительно настроена/задушена `maxDegreesOfParallelism` путем указания параметра.

Сигнатура:

```fsharp
computations: seq<Async<'T>> - ?maxDegreesOfParallelism: int -> Async<'T[]>
```

Когда следует использовать:

- Если вам нужно запустить набор вычислений в то же время и не полагаться на их порядок выполнения.
- Если вам не требуются результаты вычислений, запланированные параллельно, пока они не будут завершены.

На что обратить сяочку:

- Вы можете получить доступ к полученному массиву значений только после завершения всех вычислений.
- Вычисления будут запущены, однако они в конечном итоге получить запланировано. Это означает, что вы не можете полагаться на их порядок их исполнения.

### <a name="asyncsequential"></a>Async.Последовательный

Расписание последовательности асинхронных вычислений, которые должны быть выполнены в порядке, который они передаются. Первые вычисления будут выполнены, затем следующий, и так далее. Вычисления не выполняются параллельно.

Сигнатура:

```fsharp
computations: seq<Async<'T>> -> Async<'T[]>
```

Когда следует использовать:

- Если вам нужно выполнить несколько вычислений в порядке.

На что обратить сяочку:

- Вы можете получить доступ к полученному массиву значений только после завершения всех вычислений.
- Вычисления будут выполняться в порядке, в котором они будут переданы этой функции, что может означать, что пройдет больше времени, прежде чем результаты будут возвращены.

### <a name="asyncawaittask"></a>Async.AwaitTask

Возвращает асинхронные вычисления, которые <xref:System.Threading.Tasks.Task%601> ждут данного для завершения и возвращает свой результат в виде`Async<'T>`

Сигнатура:

```fsharp
task: Task<'T>  -> Async<'T>
```

Когда следует использовать:

- При потреблении API .NET, <xref:System.Threading.Tasks.Task%601> который возвращает asynchronous вычисления F's.

На что обратить сяочку:

- Исключения заворачиваются <xref:System.AggregateException> в соответствии с конвенцией Параллельной библиотеки задач, и это отличается от того, как F'async обычно всплывает на поверхность исключений.

### <a name="asynccatch"></a>Async.Catch

Создает асинхронные вычисления, которые `Async<'T>`выполняет `Async<Choice<'T, exn>>`данный, возвращая . Если данное `Async<'T>` завершается успешно, `Choice1Of2` то a возвращается с резучным значением. Если исключение выбрасывается до его завершения, то возврат исключиться `Choice2of2` с поднятым исключением. Если он используется на асинхронных вычислениях, которые сами по себе состоят из многих вычислений, и один из этих вычислений бросает исключение, охватывающие вычисления будут полностью остановлены.

Сигнатура:

```fsharp
computation: Async<'T> -> Async<Choice<'T, exn>>
```

Когда следует использовать:

- При выполнении асинхронной работы, которая может выйти из строя за исключением, и вы хотите обрабатывать это исключение в вызываемом абоненте.

На что обратить сяочку:

- При использовании комбинированных или секвенированных асинхронных вычислений охватывающая вычисления полностью остановится, если один из его «внутренних» вычислений выбросит исключение.

### <a name="asyncignore"></a>Async.Ignore

Создает асинхронные вычисления, которые выражает данный расчет и игнорируют его результат.

Сигнатура:

```fsharp
computation: Async<'T> -> Async<unit>
```

Когда следует использовать:

- Если у вас есть асинхронные вычисления, результат которых не нужен. Это аналогично коду `ignore` неасинхронного кода.

На что обратить сяочку:

- Если вы должны использовать это, `Async.Start` потому что `Async<unit>`вы хотите использовать или другую функцию, которая требует, рассмотреть, если отбрасывание результат хорошо делать. Отбрасывание результатов только для того, чтобы соответствовать подписи типа, как правило, не должно быть сделано.

### <a name="asyncrunsynchronously"></a>Async.RunСинхронно

Запускает асинхронные вычисления и ждет его результата на потоке вызова. Этот вызов блокируется.

Сигнатура:

```fsharp
computation: Async<'T> - timeout: ?int - cancellationToken: ?CancellationToken -> 'T
```

Когда следует использовать:

- Если вам это нужно, используйте его только один раз в приложении - в точке входа для исполняемой.
- Если вы не заботитесь о производительности и хотите выполнить набор других асинхронных операций сразу.

На что обратить сяочку:

- Вызов `Async.RunSynchronously` блокирует поток вызова до завершения выполнения.

### <a name="asyncstart"></a>Async.Start

Запускает асинхронные вычисления в пуле потоков, который возвращается. `unit` Не ждет его результата. Вложенные вычисления, `Async.Start` начатые с запуска, запускаются полностью независимо от родительских вычислений, которые их называли. Их продолжительность жизни не привязана ни к какому родительскому вычислению. Если родительские вычисления отменены, не отменяются детские вычисления.

Сигнатура:

```fsharp
computation: Async<unit> - cancellationToken: ?CancellationToken -> unit
```

Используйте только тогда, когда:

- У вас есть асинхронные вычисления, которые не дают результата и/или требуют его обработки.
- Вам не нужно знать, когда асинхронные вычисления завершены.
- Вам все равно, на какой поток работает асинхронная вычисления.
- У вас нет необходимости быть в курсе или сообщать об исключениях, вытекающих из задачи.

На что обратить сяочку:

- Исключения, поднятые вычислениями, `Async.Start` начатыми с, не распространяются на вызыватель. Стек вызова будет полностью развёрнут.
- Любая эффективная работа `printfn`(например, вызов), начатая с `Async.Start` не приведет к тому, что эффект может произойти на основной поток выполнения программы.

## <a name="interoperate-with-net"></a>Взаимодействие с .NET

Возможно, вы работаете с библиотекой .NET или базой кода с c'net, которая использует асинхронное программирование в стиле [async/await.](../../../standard/async.md) Поскольку в качестве основных абстракций и <xref:System.Threading.Tasks.Task%601> <xref:System.Threading.Tasks.Task> типов используется `Async<'T>`c-образная система, а не , необходимо пересечь границу между этими двумя подходами к асинхронности.

### <a name="how-to-work-with-net-async-and-taskt"></a>Как работать с .NET async и`Task<T>`

Работа с библиотеками async .NET <xref:System.Threading.Tasks.Task%601> и базами кода, которые используют (т.е. вычислениями async, которые имеют значения возврата), является простой и имеет встроенную поддержку с F..

Функция может `Async.AwaitTask` использоваться для ожидания асинхронных вычислений .NET:

```fsharp
let getValueFromLibrary param =
    async {
        let! value = DotNetLibrary.GetValueAsync param |> Async.AwaitTask
        return value
    }
```

Функцию `Async.StartAsTask` можно использовать для передачи асинхронных вычислений вызывающему абоненту .NET:

```fsharp
let computationForCaller param =
    async {
        let! result = getAsyncResult param
        return result
    } |> Async.StartAsTask
```

### <a name="how-to-work-with-net-async-and-task"></a>Как работать с .NET async и`Task`

Для работы с <xref:System.Threading.Tasks.Task> AI, которые используют (т.е. вычисления .NET async, которые не возвращают `Async<'T>` значение), <xref:System.Threading.Tasks.Task>может потребоваться добавить дополнительную функцию, которая преобразует ся:

```fsharp
module Async =
    // Async<unit> -> Task
    let startTaskFromAsyncUnit (comp: Async<unit>) =
        Async.StartAsTask comp :> Task
```

Существует уже, `Async.AwaitTask` что принимает <xref:System.Threading.Tasks.Task> в качестве ввода. С помощью этой `startTaskFromAsyncUnit` и ранее определенной <xref:System.Threading.Tasks.Task> функции можно начать и ждать типы из вычислений F'async.

## <a name="relationship-to-multi-threading"></a>Отношение к многопоточному

Хотя потоки упоминается в этой статье, Есть две важные вещи, чтобы помнить:

1. Нет никакого сродства между асинхронным вычислением и потоком, если только явно не запущенный на текущем потоке.
1. Асинхронное программирование в F- не является абстракцией для многопоточности.

Например, вычисление может фактически работать на потоке вызывающего абонента, в зависимости от характера работы. Вычисление может также "прыгать" между потоками, заимствуя их на небольшое количество времени, чтобы сделать полезную работу между периодами "ожидания" (например, когда сетевой вызов находится в пути).

Хотя F-образное взаимодействие дает некоторые возможности для запуска асинхронных вычислений на текущем потоке (или явно не в текущем потоке), асинхронность обычно не связана с конкретной стратегией потоков.

## <a name="see-also"></a>См. также

- [Модель асинхронного программирования](https://www.microsoft.com/research/publication/the-f-asynchronous-programming-model)
- [Jet.com в F е Async Руководство](https://medium.com/jettech/f-async-guide-eb3c8a2d180a)
- [F для удовольствия и прибыли асинхронного программирования руководство](https://fsharpforfunandprofit.com/posts/concurrency-async-and-parallel/)
- [Асинхрон в C и F: Асинхронные gotchas в C #](http://tomasp.net/blog/csharp-async-gotchas.aspx/)
