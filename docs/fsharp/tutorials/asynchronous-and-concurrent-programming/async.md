---
title: Асинхронное программирование
description: 'Узнайте, как F # обеспечивает чистую поддержку асинхронность на основе модели программирования на уровне языка, полученной из основных концепций функционального программирования.'
ms.date: 08/15/2020
ms.openlocfilehash: 2e5d4fb744b4443eb9caf90cc1bf01473b809127
ms.sourcegitcommit: 9c45035b781caebc63ec8ecf912dc83fb6723b1f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/25/2020
ms.locfileid: "88811773"
---
# <a name="async-programming-in-f"></a>Асинхронное программирование в F\#

Асинхронное программирование — это механизм, который необходим для современных приложений по различным причинам. Большинство разработчиков могут столкнуться с двумя основными вариантами использования:

- Представление серверного процесса, который может обслуживать значительное количество одновременных входящих запросов, одновременно сокращая объем системных ресурсов, занятых во время обработки запроса, ожидающих входные данные из систем или служб извне этого процесса.
- Поддержание реагирующего пользовательского интерфейса или основного потока при одновременном выполнении фоновой работы

Хотя фоновая работа часто занимается использованием нескольких потоков, важно учитывать концепцию Асинхронность и многопоточности отдельно. На самом деле, это отдельные проблемы, и одна из них не подразумевает другую. В этой статье подробно описаны отдельные концепции.

## <a name="asynchrony-defined"></a>Определено асинхронность

Предыдущая точка — то, что асинхронность не зависит от использования нескольких потоков, стоит немного подробнее объяснить. Существуют три концепции, которые иногда связаны, но строго независимы друг от друга:

- Параллелизма когда несколько вычислений выполняются в перекрывающиеся периоды времени.
- Параллелизма Если несколько вычислений или несколько частей одного вычисления выполняются в точно одно и то же время.
- Асинхронность Если одно или несколько вычислений могут выполняться отдельно от основного потока программы.

Все три являются ортогональными концепциями, но их можно легко увеличить, особенно если они используются совместно. Например, может потребоваться параллельное выполнение нескольких асинхронных вычислений. Это отношение не означает, что параллелизм или асинхронность предполагают одно другое.

Если вы считаете, что етимологи слово «асинхронный», участвуют две части:

- "a", что означает "not".
- "Синхронное", означающее "в то же время".

При совместном помещении этих двух терминов вы увидите, что "асинхронное" означает "не одновременно". Вот и все! В этом определении не происходит неарифметического параллелизма или параллелизма. Это также справедливо и на практике.

На практике асинхронные вычисления в F # планируются для выполнения независимо от основной последовательности программы. Это независимое выполнение не подразумевает параллелизм или параллелизм, а также не подразумевает, что вычисления всегда выполняются в фоновом режиме. Фактически асинхронные вычисления могут даже выполняться синхронно, в зависимости от природы вычислений и среды, в которой выполняется вычисление.

Основная мысльа заключается в том, что асинхронные вычисления не зависят от основного потока программы. Хотя существует несколько гарантий относительно того, когда и как выполняется асинхронное вычисление, существует ряд подходов к координации и планированию. Оставшаяся часть этой статьи посвящена основным понятиям F # Асинхронность и использованию типов, функций и выражений, встроенных в F #.

## <a name="core-concepts"></a>Основные понятия

В F # асинхронное программирование основано на трех основных понятиях:

- `Async<'T>`Тип, представляющий Составное асинхронное вычисление.
- `Async`Функции модуля, которые позволяют планировать асинхронную работу, создавать асинхронные вычисления и преобразовывать асинхронные результаты.
- `async { }` [Вычислительное выражение](../../language-reference/computation-expressions.md), которое предоставляет удобный синтаксис для создания и управления асинхронными вычислениями.

Эти три концепции можно увидеть в следующем примере:

```fsharp
open System
open System.IO

let printTotalFileBytes path =
    async {
        let! bytes = File.ReadAllBytesAsync(path) |> Async.AwaitTask
        let fileName = Path.GetFileName(path)
        printfn "File %s has %d bytes" fileName bytes.Length
    }

[<EntryPoint>]
let main argv =
    printTotalFileBytes "path-to-file.txt"
    |> Async.RunSynchronously

    Console.Read() |> ignore
    0
```

В примере `printTotalFileBytes` функция имеет тип `string -> Async<unit>` . Вызов функции фактически не выполняет асинхронное вычисление. Вместо этого он возвращает объект `Async<unit>` , который выступает в качестве *спецификации* работы, выполняемой асинхронно. Он вызывает `Async.AwaitTask` в своем тексте, который преобразует результат <xref:System.IO.File.ReadAllBytesAsync%2A> в соответствующий тип.

Еще одна важная строка — вызов `Async.RunSynchronously` . Это одна из функций запуска асинхронного модуля, которую необходимо вызвать, если необходимо выполнить асинхронное вычисление F #.

Это фундаментальное различие в стиле программирования C#/Visual Basic `async` . В F # асинхронные вычисления можно рассматривать как **холодные задачи**. Они должны быть явным образом запущены для фактического выполнения. Это имеет некоторые преимущества, так как позволяет объединять и последовательно выполнять асинхронную работу гораздо проще, чем в C# или Visual Basic.

## <a name="combine-asynchronous-computations"></a>Объединение асинхронных вычислений

Ниже приведен пример, который строится на основе предыдущего путем объединения вычислений:

```fsharp
open System
open System.IO

let printTotalFileBytes path =
    async {
        let! bytes = File.ReadAllBytesAsync(path) |> Async.AwaitTask
        let fileName = Path.GetFileName(path)
        printfn "File %s has %d bytes" fileName bytes.Length
    }

[<EntryPoint>]
let main argv =
    argv
    |> Array.map printTotalFileBytes
    |> Async.Parallel
    |> Async.Ignore
    |> Async.RunSynchronously

    0
```

Как видите, `main` функция имеет довольно много обращений. По сути, он выполняет следующие действия:

1. Преобразуйте аргументы командной строки в `Async<unit>` вычисления с помощью `Array.map` .
2. Создайте `Async<'T[]>` , который планирует и выполняет `printTotalFileBytes` вычисления параллельно при запуске.
3. Создайте объект `Async<unit>` , который будет выполнять параллельное вычисление и игнорировать его результат.
4. Явно запускать Последнее вычисление с помощью `Async.RunSynchronously` и блокировать до завершения.

При запуске эта программа `printTotalFileBytes` выполняется параллельно для каждого аргумента командной строки. Поскольку асинхронные вычисления выполняются независимо от последовательности программ, порядок, в котором они печатаются, не задаются и завершается. Вычисления будут планироваться параллельно, но их порядок выполнения не гарантируется.

## <a name="sequence-asynchronous-computations"></a>Асинхронные вычисления последовательности

Поскольку `Async<'T>` — это спецификация работы, а не уже выполняющаяся задача, можно легко выполнять более сложные преобразования. Ниже приведен пример, покоторому набор асинхронных вычислений помещается в последовательность, чтобы они выполнялись один за другим.

```fsharp
let printTotalFileBytes path =
    async {
        let! bytes = File.ReadAllBytesAsync(path) |> Async.AwaitTask
        let fileName = Path.GetFileName(path)
        printfn "File %s has %d bytes" fileName bytes.Length
    }

[<EntryPoint>]
let main argv =
    argv
    |> Array.map printTotalFileBytes
    |> Async.Sequential
    |> Async.Ignore
    |> Async.RunSynchronously
    |> ignore
```

Это будет запланировать `printTotalFileBytes` выполнение в порядке элементов, `argv` а не планировать их параллельно. Поскольку следующий элемент не будет планироваться до тех пор, пока не завершится выполнение последнего вычисления, вычисления будут упорядочены таким, что в их выполнении не будет перекрываться.

## <a name="important-async-module-functions"></a>Важные функции асинхронного модуля

При написании асинхронного кода в F # вы обычно взаимодействуете с платформой, которая обрабатывает планирование вычислений. Однако это не всегда так, поэтому рекомендуется изучить различные начальные функции для планирования асинхронной работы.

Поскольку асинхронные вычисления F # являются _спецификацией_ работы, а не представлением уже выполненной работы, они должны быть явно запущены с помощью начальной функции. Существует множество [асинхронных методов запуска](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-fsharpasync.html#section0) , которые полезны в разных контекстах. В следующем разделе описаны некоторые из наиболее распространенных начальных функций.

### <a name="asyncstartchild"></a>Async. Стартчилд

Запускает дочерние вычисления в асинхронном вычислении. Это позволяет параллельно выполнять несколько асинхронных вычислений. Дочерние вычисления совместно используют токен отмены с родительскими вычислениями. Если родительские вычисления отменены, дочерние вычисления также отменяются.

Сигнатура:

```fsharp
computation: Async<'T> * timeout: ?int -> Async<Async<'T>>
```

Когда следует использовать:

- Если требуется одновременное выполнение нескольких асинхронных вычислений, а не по одному, но не запланированных параллельно.
- Если вы хотите привязать время существования дочернего вычисления к отношению к родительскому вычислению.

Что следует отслеживать:

- Запуск нескольких вычислений с помощью `Async.StartChild` отличается от планирования параллельно. Если вы хотите запланировать вычисления параллельно, используйте `Async.Parallel` .
- Отмена родительских вычислений приведет к срабатыванию отмены всех запущенных дочерних вычислений.

### <a name="asyncstartimmediate"></a>Async. Стартиммедиате

Выполняет асинхронное вычисление, немедленно запуская в текущем потоке операционной системы. Это полезно, если необходимо обновить что-либо в вызывающем потоке во время вычисления. Например, если асинхронное вычисление должно обновить пользовательский интерфейс (например, обновление индикатора выполнения), то `Async.StartImmediate` следует использовать.

Сигнатура:

```fsharp
computation: Async<unit> * cancellationToken: ?CancellationToken -> unit
```

Когда следует использовать:

- Когда необходимо обновить что-либо в вызывающем потоке в середине асинхронного вычисления.

Что следует отслеживать:

- Код асинхронного вычисления будет выполняться в любом потоке, для которого выполняется планирование. Это может быть проблематичным, если поток имеет какой-то секрет, например поток пользовательского интерфейса. В таких случаях, `Async.StartImmediate` скорее всего, будет неприемлемо для использования.

### <a name="asyncstartastask"></a>Async. Стартастаск

Выполняет вычисление в пуле потоков. Возвращает объект <xref:System.Threading.Tasks.Task%601> , который будет завершен в соответствующем состоянии после завершения вычисления (создает результат, вызывает исключение или возвращает значение Cancel). Если токен отмены не указан, используется токен отмены по умолчанию.

Сигнатура:

```fsharp
computation: Async<'T> * taskCreationOptions: ?TaskCreationOptions * cancellationToken: ?CancellationToken -> Task<'T>
```

Когда следует использовать:

- Если необходимо вызвать API .NET, который предполагает, что будет <xref:System.Threading.Tasks.Task%601> представлять результат асинхронного вычисления.

Что следует отслеживать:

- Этот вызов выделит дополнительный `Task` объект, который может увеличить издержки, если он часто используется.

### <a name="asyncparallel"></a>Async. Parallel

Планирует параллельное выполнение последовательности асинхронных вычислений. Степень параллелизма может при необходимости настраиваться и регулироваться путем указания `maxDegreesOfParallelism` параметра.

Сигнатура:

```fsharp
computations: seq<Async<'T>> * ?maxDegreesOfParallelism: int -> Async<'T[]>
```

Когда следует использовать:

- Значение, если необходимо одновременно запустить набор вычислений и не иметь никакой зависимости от их порядка выполнения.
- Значение, если не требуется использовать результаты вычислений, запланированных параллельно, пока все они не будут завершены.

Что следует отслеживать:

- Доступ к результирующему массиву значений можно получить только после завершения всех вычислений.
- Вычисления будут выполняться каждый раз, когда они завершаются по расписанию. Такое поведение означает, что нельзя полагаться на порядок их выполнения.

### <a name="asyncsequential"></a>Асинхронный. последовательный

Планирует выполнение последовательности асинхронных вычислений в том порядке, в котором они передаются. Будут выполнены первые вычисления, далее и т. д. Вычисления не будут выполняться параллельно.

Сигнатура:

```fsharp
computations: seq<Async<'T>> -> Async<'T[]>
```

Когда следует использовать:

- Значение, если необходимо выполнить несколько вычислений по порядку.

Что следует отслеживать:

- Доступ к результирующему массиву значений можно получить только после завершения всех вычислений.
- Вычисления будут выполняться в том порядке, в котором они передаются в эту функцию, что может означать, что больше времени должно пройти до возврата результатов.

### <a name="asyncawaittask"></a>Async. Аваиттаск

Возвращает асинхронное вычисление, которое ожидает завершения заданного объекта <xref:System.Threading.Tasks.Task%601> и возвращает результат в виде `Async<'T>`

Сигнатура:

```fsharp
task: Task<'T> -> Async<'T>
```

Когда следует использовать:

- При использовании API .NET, который возвращает в <xref:System.Threading.Tasks.Task%601> асинхронное вычисление F #.

Что следует отслеживать:

- Исключения упаковываются в соответствии с <xref:System.AggregateException> соглашением о библиотеке параллельных задач, и это поведение отличается от того, как в F # Async обычно отображаются исключения.

### <a name="asynccatch"></a>Async. catch

Создает асинхронное вычисление, которое выполняет заданную инструкцию `Async<'T>` , возвращая `Async<Choice<'T, exn>>` . Если заданное `Async<'T>` Завершение завершается успешно, `Choice1Of2` возвращается результирующее значение. Если перед завершением создается исключение, `Choice2of2` возвращается исключение с вызванным. Если он используется в асинхронном вычислении, который состоит из многих вычислений, и одно из этих вычислений создает исключение, охватывающие вычисления будут полностью остановлены.

Сигнатура:

```fsharp
computation: Async<'T> -> Async<Choice<'T, exn>>
```

Когда следует использовать:

- При выполнении асинхронной работы, которая может завершиться с исключением, и необходимо обойти это исключение в вызывающем объекте.

Что следует отслеживать:

- При использовании Объединенных или последовательных асинхронных вычислений охватывающие вычисления будут полностью прекращаться, если одно из внутренних вычислений выдаст исключение.

### <a name="asyncignore"></a>Async. Ignore

Создает асинхронное вычисление, которое выполняет заданное вычисление и игнорирует его результат.

Сигнатура:

```fsharp
computation: Async<'T> -> Async<unit>
```

Когда следует использовать:

- При наличии асинхронного вычисления, результат которого не требуется. Это аналогично `ignore` коду для неасинхронного кода.

Что следует отслеживать:

- Если необходимо использовать `Async.Ignore` , так как вы хотите использовать `Async.Start` или другую функцию, которая требует `Async<unit>` , рассмотрите возможность отмены результата. Старайтесь не отменять результаты в соответствии с сигнатурой типа.

### <a name="asyncrunsynchronously"></a>Async. RunSynchronously нельзя вызывать

Выполняет асинхронное вычисление и ожидает его результат в вызывающем потоке. Этот вызов блокируется.

Сигнатура:

```fsharp
computation: Async<'T> * timeout: ?int * cancellationToken: ?CancellationToken -> 'T
```

Когда следует использовать:

- Если это необходимо, используйте его только один раз в приложении — в точке входа исполняемого файла.
- Если вы не следите за производительностью и хотите выполнить набор других асинхронных операций одновременно.

Что следует отслеживать:

- Вызов `Async.RunSynchronously` блокирует вызывающий поток до завершения выполнения.

### <a name="asyncstart"></a>Async. Start

Запускает асинхронное вычисление в пуле потоков, который возвращает `unit` . Не ждет своего результата. Вложенные вычисления, запущенные с `Async.Start` , запускаются независимо от родительских вычислений, которые вызвали их. Их время существования не привязано к какому-либо родительскому вычислению. Если родительские вычисления отменены, дочерние вычисления не отменяются.

Сигнатура:

```fsharp
computation: Async<unit> * cancellationToken: ?CancellationToken -> unit
```

Используйте только в следующих случаях:

- Имеется асинхронное вычисление, которое не дает результата и/или требует обработки одного из них.
- Вам не нужно знать, когда завершается асинхронное вычисление.
- Вы не волнует, на каком потоке выполняется асинхронное вычисление.
- У вас нет необходимости учитывать исключения, возникшие в результате выполнения задачи, и сообщать о них.

Что следует отслеживать:

- Исключения, вызванные вычислениями, запущенными, `Async.Start` не распространяются на вызывающий объект. Стек вызовов будет полностью развернут.
- Любая работа (например, вызов `printfn` ), запущенная с помощью, `Async.Start` не будет приводить к выполнению этого действия в основном потоке выполнения программы.

## <a name="interoperate-with-net"></a>Взаимодействие с .NET

Возможно, вы работаете с библиотекой .NET или с базой кода C#, которая использует асинхронное программирование в стиле [async/await](../../../standard/async.md). Так как C# и большинство библиотек .NET используют <xref:System.Threading.Tasks.Task%601> типы и в <xref:System.Threading.Tasks.Task> качестве основных абстракций, а не `Async<'T>` , необходимо пересекать границы между этими двумя подходами и асинхронность.

### <a name="how-to-work-with-net-async-and-taskt"></a>Как работать с .NET Async и `Task<T>`

Работа с библиотеками .NET Async и базой кода, использующей <xref:System.Threading.Tasks.Task%601> (то есть асинхронные вычисления, которые имеют возвращаемые значения), проста и имеет встроенную поддержку F #.

Функцию можно использовать `Async.AwaitTask` для ожидания асинхронного вычисления .NET:

```fsharp
let getValueFromLibrary param =
    async {
        let! value = DotNetLibrary.GetValueAsync param |> Async.AwaitTask
        return value
    }
```

Функцию можно использовать `Async.StartAsTask` для передачи асинхронных вычислений вызывающему объекту .NET:

```fsharp
let computationForCaller param =
    async {
        let! result = getAsyncResult param
        return result
    } |> Async.StartAsTask
```

### <a name="how-to-work-with-net-async-and-task"></a>Как работать с .NET Async и `Task`

Для работы с API-интерфейсами, использующими <xref:System.Threading.Tasks.Task> (то есть асинхронные вычисления .NET, которые не возвращают значение), может потребоваться добавить дополнительную функцию, которая будет преобразовывать `Async<'T>` в <xref:System.Threading.Tasks.Task> :

```fsharp
module Async =
    // Async<unit> -> Task
    let startTaskFromAsyncUnit (comp: Async<unit>) =
        Async.StartAsTask comp :> Task
```

Уже существует объект `Async.AwaitTask` , принимающий <xref:System.Threading.Tasks.Task> входные данные. С помощью этой и ранее определенной `startTaskFromAsyncUnit` функции можно начинать и ожидать <xref:System.Threading.Tasks.Task> типы из асинхронного вычисления F #.

## <a name="relationship-to-multi-threading"></a>Связь с многопоточностью

Несмотря на то, что в этой статье упоминается потоковая ситуация, необходимо помнить о двух важных вещах.

1. Нет сходства между асинхронным вычислением и потоком, если только явно не запущен в текущем потоке.
1. Асинхронное программирование в F # не является абстракцией для многопоточности.

Например, вычисление может фактически выполняться в потоке вызывающего объекта в зависимости от природы работы. Вычисления могут также "переходить" между потоками, позаимствование их в течение небольшого количества времени для выполнения полезной работы в период ожидания (например, при передаче сетевого вызова).

Хотя F # предоставляет некоторые возможности для запуска асинхронного вычисления в текущем потоке (или явно не в текущем потоке), асинхронность обычно не связан с конкретной стратегией потоков.

## <a name="see-also"></a>См. также

- [Модель асинхронного программирования F #](https://www.microsoft.com/research/publication/the-f-asynchronous-programming-model)
- [Асинхронное руководством по F # для Jet. com](https://medium.com/jettech/f-async-guide-eb3c8a2d180a)
- [F # для получения привлекательных и асинхронных руководств по программированию](https://fsharpforfunandprofit.com/posts/concurrency-async-and-parallel/)
- [Async в C# и F #: асинхронные проблемы в C #](http://tomasp.net/blog/csharp-async-gotchas.aspx/)
