---
title: Асинхронное программирование
description: Узнайте, F# как обеспечивается чистая Поддержка асинхронность на основе модели программирования на уровне языка, полученной из основных концепций функционального программирования.
ms.date: 12/17/2018
ms.openlocfilehash: 471566befd69f330fb9254dbd57b19569d9f9ad3
ms.sourcegitcommit: 30a558d23e3ac5a52071121a52c305c85fe15726
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/25/2019
ms.locfileid: "75344661"
---
# <a name="async-programming-in-f"></a>Асинхронное программирование в F\#

Асинхронное программирование — это механизм, который необходим для современных приложений по различным причинам. Большинство разработчиков могут столкнуться с двумя основными вариантами использования:

- Представление серверного процесса, который может обслуживать значительное количество одновременных входящих запросов, одновременно сокращая объем системных ресурсов, занятых во время обработки запроса, ожидающих входные данные из систем или служб извне этого процесса.
- Поддержание реагирующего пользовательского интерфейса или основного потока при одновременном выполнении фоновой работы

Хотя фоновая работа часто занимается использованием нескольких потоков, важно учитывать концепцию Асинхронность и многопоточности отдельно. На самом деле, это отдельные проблемы, и одна из них не подразумевает другую. Далее в этой статье подробно описывается это.

## <a name="asynchrony-defined"></a>Определено асинхронность

Предыдущая точка — то, что асинхронность не зависит от использования нескольких потоков, стоит немного подробнее объяснить. Существуют три концепции, которые иногда связаны, но строго независимы друг от друга:

- Параллелизма когда несколько вычислений выполняются в перекрывающиеся периоды времени.
- Параллелизма Если несколько вычислений или несколько частей одного вычисления выполняются в точно одно и то же время.
- Асинхронность Если одно или несколько вычислений могут выполняться отдельно от основного потока программы.

Все три являются ортогональными концепциями, но их можно легко увеличить, особенно если они используются совместно. Например, может потребоваться параллельное выполнение нескольких асинхронных вычислений. Это не означает, что параллелизм или асинхронность предполагают друг друга.

Если вы считаете, что етимологи слово «асинхронный», участвуют две части:

- "a", что означает "not".
- "Синхронное", означающее "в то же время".

При совместном помещении этих двух терминов вы увидите, что "асинхронное" означает "не одновременно". Вот и все! В этом определении не происходит неарифметического параллелизма или параллелизма. Это также справедливо и на практике.

На практике асинхронные вычисления в F# запланированы на выполнение независимо от основной последовательности программы. Это не подразумевает параллелизм или параллелизм, а также не подразумевает, что вычисления всегда выполняются в фоновом режиме. Фактически асинхронные вычисления могут даже выполняться синхронно, в зависимости от природы вычислений и среды, в которой выполняется вычисление.

Основная мысльа заключается в том, что асинхронные вычисления не зависят от основного потока программы. Хотя существует несколько гарантий относительно того, когда и как выполняется асинхронное вычисление, существует ряд подходов к координации и планированию. Оставшаяся часть этой статьи посвящена основным понятиям F# Асинхронность и использованию типов, функций и выражений, встроенных в. F#

## <a name="core-concepts"></a>Основные понятия

В F#асинхронное программирование основано на трех основных понятиях:

- Тип `Async<'T>`, представляющий Составное асинхронное вычисление.
- Функции модуля `Async`, которые позволяют планировать асинхронную работу, создавать асинхронные вычисления и преобразовывать асинхронные результаты.
- `async { }` [вычислительное выражение](../../language-reference/computation-expressions.md), предоставляющее удобный синтаксис для создания асинхронных вычислений и управления ими.

Эти три концепции можно увидеть в следующем примере:

```fsharp
open System
open System.IO

let printTotalFileBytes path =
    async {
        let! bytes = File.ReadAllBytesAsync(path) |> Async.AwaitTask
        let fileName = Path.GetFileName(path)
        printfn "File %s has %d bytes" fileName bytes.Length
    }

[<EntryPoint>]
let main argv =
    printTotalFileBytes "path-to-file.txt"
    |> Async.RunSynchronously

    Console.Read() |> ignore
    0
```

В примере функция `printTotalFileBytes` имеет тип `string -> Async<unit>`. Вызов функции фактически не выполняет асинхронное вычисление. Вместо этого он возвращает `Async<unit>`, который выступает в качестве *спецификации* работы, выполняемой асинхронно. Он вызывает `Async.AwaitTask` в своем тексте, который преобразует результат <xref:System.IO.File.WriteAllBytesAsync%2A> в соответствующий тип.

Еще одна важная строка — вызов `Async.RunSynchronously`. Это одна из функций запуска асинхронного модуля, которые необходимо вызвать, если необходимо выполнить F# асинхронное вычисление.

Это фундаментальное различие в стиле C#/Visual Basic `async` программировании. В F#асинхронные вычисления можно рассматривать как **холодные задачи**. Они должны быть явным образом запущены для фактического выполнения. Это имеет некоторые преимущества, так как позволяет объединять и последовательно выполнять асинхронную работу гораздо проще, C# чем в или Visual Basic.

## <a name="combine-asynchronous-computations"></a>Объединение асинхронных вычислений

Ниже приведен пример, который строится на основе предыдущего путем объединения вычислений:

```fsharp
open System
open System.IO

let printTotalFileBytes path =
    async {
        let! bytes = File.ReadAllBytesAsync(path) |> Async.AwaitTask
        let fileName = Path.GetFileName(path)
        printfn "File %s has %d bytes" fileName bytes.Length
    }

[<EntryPoint>]
let main argv =
    argv
    |> Array.map printTotalFileBytes
    |> Async.Parallel
    |> Async.Ignore
    |> Async.RunSynchronously

    0
```

Как видите, функция `main` имеет довольно много вызовов. По сути, он выполняет следующие действия:

1. Преобразуйте аргументы командной строки в `Async<unit>` вычисления с `Array.map`.
2. Создайте `Async<'T[]>`, который планирует и запускает `printTotalFileBytes` вычисления параллельно при запуске.
3. Создайте `Async<unit>`, который будет выполнять параллельное вычисление и игнорировать его результат.
4. Явным образом запустите Последнее вычисление с `Async.RunSynchronously` и заблокируйте его до завершения.

При запуске этой программы `printTotalFileBytes` выполняется параллельно для каждого аргумента командной строки. Поскольку асинхронные вычисления выполняются независимо от последовательности программ, порядок, в котором они печатаются, не задаются и завершается. Вычисления будут планироваться параллельно, но их порядок выполнения не гарантируется.

## <a name="sequence-asynchronous-computations"></a>Асинхронные вычисления последовательности

Поскольку `Async<'T>` является спецификацией работы, а не выполняемой ранее задачей, можно легко выполнять более сложные преобразования. Ниже приведен пример, покоторому набор асинхронных вычислений помещается в последовательность, чтобы они выполнялись один за другим.

```fsharp
let printTotalFileBytes path =
    async {
        let! bytes = File.ReadAllBytesAsync(path) |> Async.AwaitTask
        let fileName = Path.GetFileName(path)
        printfn "File %s has %d bytes" fileName bytes.Length
    }

[<EntryPoint>]
let main argv =
    argv
    |> Array.map printTotalFileBytes
    |> Async.Sequential
    |> Async.Ignore
    |> Async.RunSynchronously
    |> ignore
```

Это запланирует `printTotalFileBytes` выполняться в порядке элементов `argv` вместо того, чтобы планировать их параллельно. Поскольку следующий элемент не будет планироваться до тех пор, пока не завершится выполнение последнего вычисления, вычисления будут упорядочены таким, что в их выполнении не будет перекрываться.

## <a name="important-async-module-functions"></a>Важные функции асинхронного модуля

При написании асинхронного кода F# в обычно взаимодействует с платформой, которая обрабатывает планирование вычислений. Однако это не всегда так, поэтому рекомендуется изучить различные начальные функции для планирования асинхронной работы.

Поскольку F# асинхронные вычисления являются _спецификацией_ работы, а не представлением уже выполненной работы, они должны быть явно запущены с помощью начальной функции. Существует множество [функций асинхронного запуска](https://msdn.microsoft.com/library/ee370232.aspx) , которые полезны в разных контекстах. В следующем разделе описаны некоторые из наиболее распространенных начальных функций.

### <a name="asyncstartchild"></a>Async. Стартчилд

Запускает дочерние вычисления в асинхронном вычислении. Это позволяет параллельно выполнять несколько асинхронных вычислений. Дочерние вычисления совместно используют токен отмены с родительскими вычислениями. Если родительские вычисления отменены, дочерние вычисления также отменяются.

Сигнатура:

```fsharp
computation: Async<'T> - timeout: ?int -> Async<Async<'T>>
```

Когда следует использовать:

- Если требуется одновременное выполнение нескольких асинхронных вычислений, а не по одному, но не запланированных параллельно.
- Если вы хотите привязать время существования дочернего вычисления к отношению к родительскому вычислению.

Что следует отслеживать:

- Запуск нескольких вычислений с `Async.StartChild` не так же, как параллельное планирование. Если вы хотите запланировать вычисления параллельно, используйте `Async.Parallel`.
- Отмена родительских вычислений приведет к срабатыванию отмены всех запущенных дочерних вычислений.

### <a name="asyncstartimmediate"></a>Async. Стартиммедиате

Выполняет асинхронное вычисление, немедленно запуская в текущем потоке операционной системы. Это полезно, если необходимо обновить что-либо в вызывающем потоке во время вычисления. Например, если асинхронное вычисление должно обновить пользовательский интерфейс (например, обновление индикатора выполнения), то `Async.StartImmediate` следует использовать.

Сигнатура:

```fsharp
computation: Async<unit> - cancellationToken: ?CancellationToken -> unit
```

Когда следует использовать:

- Когда необходимо обновить что-либо в вызывающем потоке в середине асинхронного вычисления.

Что следует отслеживать:

- Код асинхронного вычисления будет выполняться в любом потоке, для которого выполняется планирование. Это может быть проблематичным, если поток имеет какой-то секрет, например поток пользовательского интерфейса. В таких случаях `Async.StartImmediate`, скорее всего, будет неприемлемым для использования.

### <a name="asyncstartastask"></a>Async. Стартастаск

Выполняет вычисление в пуле потоков. Возвращает <xref:System.Threading.Tasks.Task%601>, который будет выполнен в соответствующем состоянии после завершения вычисления (создает результат, вызывает исключение или возвращает значение Cancel). Если токен отмены не указан, используется токен отмены по умолчанию.

Сигнатура:

```fsharp
computation: Async<'T> - taskCreationOptions: ?TaskCreationOptions - cancellationToken: ?CancellationToken -> Task<'T>
```

Когда следует использовать:

- Когда необходимо вызвать API .NET, который требует <xref:System.Threading.Tasks.Task%601> для представления результата асинхронного вычисления.

Что следует отслеживать:

- Этот вызов выделит дополнительный объект `Task`, который может увеличить издержки, если он часто используется.

### <a name="asyncparallel"></a>Async. Parallel

Планирует параллельное выполнение последовательности асинхронных вычислений. Степень параллелизма может при необходимости настраиваться и регулироваться путем указания параметра `maxDegreesOfParallelism`.

Сигнатура:

```fsharp
computations: seq<Async<'T>> - ?maxDegreesOfParallelism: int -> Async<'T[]>
```

Когда следует использовать:

- Значение, если необходимо одновременно запустить набор вычислений и не иметь никакой зависимости от их порядка выполнения.
- Значение, если не требуется использовать результаты вычислений, запланированных параллельно, пока все они не будут завершены.

Что следует отслеживать:

- Доступ к результирующему массиву значений можно получить только после завершения всех вычислений.
- Вычисления будут выполняться, но они получат расписание. Это означает, что нельзя полагаться на порядок их выполнения.

### <a name="asyncsequential"></a>Асинхронный. последовательный

Планирует выполнение последовательности асинхронных вычислений в том порядке, в котором они передаются. Будут выполнены первые вычисления, далее и т. д. Вычисления не будут выполняться параллельно.

Сигнатура:

```fsharp
computations: seq<Async<'T>> -> Async<'T[]>
```

Когда следует использовать:

- Значение, если необходимо выполнить несколько вычислений по порядку.

Что следует отслеживать:

- Доступ к результирующему массиву значений можно получить только после завершения всех вычислений.
- Вычисления будут выполняться в том порядке, в котором они передаются в эту функцию, что может означать, что больше времени должно пройти до возврата результатов.

### <a name="asyncawaittask"></a>Async. Аваиттаск

Возвращает асинхронное вычисление, которое ожидает завершения заданного <xref:System.Threading.Tasks.Task%601> и возвращает его результат в виде `Async<'T>`

Сигнатура:

```fsharp
task: Task<'T>  -> Async<'T>
```

Когда следует использовать:

- При использовании API-интерфейса .NET, возвращающего <xref:System.Threading.Tasks.Task%601> в F# асинхронном вычислении.

Что следует отслеживать:

- Исключения упаковываются в <xref:System.AggregateException> соответствии с соглашением о библиотеке параллельных задач, и это отличается от асинхронного отображения F# исключений.

### <a name="asynccatch"></a>Async. catch

Создает асинхронное вычисление, которое выполняет заданный `Async<'T>`, возвращая `Async<Choice<'T, exn>>`. Если заданная `Async<'T>` успешно завершается, возвращается `Choice1Of2` с результирующим значением. Если перед завершением создается исключение, возвращается `Choice2of2` с вызванным исключением. Если он используется в асинхронном вычислении, который состоит из многих вычислений, и одно из этих вычислений создает исключение, охватывающие вычисления будут полностью остановлены.

Сигнатура:

```fsharp
computation: Async<'T> -> Async<Choice<'T, exn>>
```

Когда следует использовать:

- При выполнении асинхронной работы, которая может завершиться с исключением, и необходимо обойти это исключение в вызывающем объекте.

Что следует отслеживать:

- При использовании Объединенных или последовательных асинхронных вычислений охватывающие вычисления будут полностью прекращаться, если одно из внутренних вычислений выдаст исключение.

### <a name="asyncignore"></a>Async. Ignore

Создает асинхронное вычисление, которое выполняет заданное вычисление и игнорирует его результат.

Сигнатура:

```fsharp
computation: Async<'T> -> Async<unit>
```

Когда следует использовать:

- При наличии асинхронного вычисления, результат которого не требуется. Это аналогично коду `ignore` для неасинхронного кода.

Что следует отслеживать:

- Если необходимо использовать `Async.Start` или другую функцию, для которой требуется `Async<unit>`, рассмотрите возможность отмены результата. Отмена результатов в соответствии с сигнатурой типа не должна выполняться обычно.

### <a name="asyncrunsynchronously"></a>Async. RunSynchronously нельзя вызывать

Выполняет асинхронное вычисление и ожидает его результат в вызывающем потоке. Этот вызов блокируется.

Сигнатура:

```fsharp
computation: Async<'T> - timeout: ?int - cancellationToken: ?CancellationToken -> 'T
```

Когда следует использовать:

- Если это необходимо, используйте его только один раз в приложении — в точке входа исполняемого файла.
- Если вы не следите за производительностью и хотите выполнить набор других асинхронных операций одновременно.

Что следует отслеживать:

- Вызов `Async.RunSynchronously` блокирует вызывающий поток до завершения выполнения.

### <a name="asyncstart"></a>Async. Start

Запускает асинхронное вычисление в пуле потоков, которое возвращает `unit`. Не ждет своего результата. Вложенные вычисления, запущенные с `Async.Start`, запускаются полностью независимо от родительских вычислений, которые вызвали их. Их время существования не привязано к какому-либо родительскому вычислению. Если родительские вычисления отменены, дочерние вычисления не отменяются.

Сигнатура:

```fsharp
computation: Async<unit> - cancellationToken: ?CancellationToken -> unit
```

Используйте только в следующих случаях:

- Имеется асинхронное вычисление, которое не дает результата и/или требует обработки одного из них.
- Вам не нужно знать, когда завершается асинхронное вычисление.
- Вы не волнует, на каком потоке выполняется асинхронное вычисление.
- У вас нет необходимости учитывать исключения, возникшие в результате выполнения задачи, и сообщать о них.

Что следует отслеживать:

- Исключения, вызванные вычислениями, запущенными с `Async.Start`, не распространяются на вызывающий объект. Стек вызовов будет полностью развернут.
- Любая работа (например, вызов `printfn`), запущенная с `Async.Start`, не приведет к выполнению этого действия в основном потоке выполнения программы.

## <a name="interoperate-with-net"></a>Взаимодействие с .NET

Возможно, вы работаете с библиотекой или C# базой кода .NET, которая использует асинхронное программирование в стиле [async/await](../../../standard/async.md). Поскольку C# и большинство библиотек .NET используют типы <xref:System.Threading.Tasks.Task%601> и <xref:System.Threading.Tasks.Task> в качестве основных абстракций, а не `Async<'T>`, необходимо пересекать границы между этими двумя подходами и асинхронность.

### <a name="how-to-work-with-net-async-and-taskt"></a>Как работать с .NET Async и `Task<T>`

Работа с библиотеками асинхронных вычислений .NET и баз кода, использующих <xref:System.Threading.Tasks.Task%601> (то есть асинхронные вычисления, которые имеют возвращаемые значения), проста F#и имеет встроенную поддержку.

Для ожидания асинхронного вычисления .NET можно использовать функцию `Async.AwaitTask`:

```fsharp
let getValueFromLibrary param =
    async {
        let! value = DotNetLibrary.GetValueAsync param |> Async.AwaitTask
        return value
    }
```

Функцию `Async.StartAsTask` можно использовать для передачи асинхронных вычислений вызывающему объекту .NET:

```fsharp
let computationForCaller param =
    async {
        let! result = getAsyncResult param
        return result
    } |> Async.StartAsTask
```

### <a name="how-to-work-with-net-async-and-task"></a>Как работать с .NET Async и `Task`

Для работы с API, которые используют <xref:System.Threading.Tasks.Task> (то есть асинхронные вычисления .NET, которые не возвращают значение), может потребоваться добавить дополнительную функцию, которая преобразует `Async<'T>` в <xref:System.Threading.Tasks.Task>:

```fsharp
module Async =
    // Async<unit> -> Task
    let startTaskFromAsyncUnit (comp: Async<unit>) =
        Async.StartAsTask comp :> Task
```

Уже существует `Async.AwaitTask`, принимающая <xref:System.Threading.Tasks.Task> в качестве входных данных. С помощью этой и ранее определенной функции `startTaskFromAsyncUnit` можно запускать и ожидать <xref:System.Threading.Tasks.Task> типов из F# асинхронных вычислений.

## <a name="relationship-to-multi-threading"></a>Связь с многопоточностью

Несмотря на то, что в этой статье упоминается потоковая ситуация, необходимо помнить о двух важных вещах.

1. Нет сходства между асинхронным вычислением и потоком, если только явно не запущен в текущем потоке.
1. Асинхронное программирование F# в не является абстракцией для многопоточности.

Например, вычисление может фактически выполняться в потоке вызывающего объекта в зависимости от природы работы. Вычисления могут также "переходить" между потоками, позаимствование их в течение небольшого количества времени для выполнения полезной работы в период ожидания (например, при передаче сетевого вызова).

Хотя F# предоставляет некоторые возможности для запуска асинхронного вычисления в текущем потоке (или явно не в текущем потоке), асинхронность обычно не связан с конкретной стратегией потоков.

## <a name="see-also"></a>См. также:

- [F# Асинхронная модель программирования](https://www.microsoft.com/research/publication/the-f-asynchronous-programming-model)
- [F# Асинхронное руководством по Jet. com](https://medium.com/jettech/f-async-guide-eb3c8a2d180a)
- [F#для получения удовольствия и асинхронного программного программирования прибыли](https://fsharpforfunandprofit.com/posts/concurrency-async-and-parallel/)
- [Асинхронные C# в F#и: асинхронные проблемы вC#](http://tomasp.net/blog/csharp-async-gotchas.aspx/)
