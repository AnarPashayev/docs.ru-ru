---
title: Привязки let
description: 'Узнайте, как использовать привязку F # let, которая связывает идентификатор со значением или функцией.'
ms.date: 05/16/2016
ms.openlocfilehash: 6f2396f480c5e6c631d0022f4732419ee5b07db6
ms.sourcegitcommit: 9c45035b781caebc63ec8ecf912dc83fb6723b1f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/25/2020
ms.locfileid: "88812228"
---
# <a name="let-bindings"></a>Привязки let

*Привязка* связывает идентификатор со значением или функцией. Используйте `let` ключевое слово для привязки имени к значению или функции.

## <a name="syntax"></a>Синтаксис

```fsharp
// Binding a value:
let identifier-or-pattern [: type] =expressionbody-expression
// Binding a function value:
let identifier parameter-list [: return-type ] =expressionbody-expression
```

## <a name="remarks"></a>Remarks

`let`Ключевое слово используется в выражениях привязки для определения значений или значений функций для одного или нескольких имен. Простейшая форма `let` выражения привязывает имя к простому значению, как показано ниже.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1101.fs)]

Если выражение отделяется от идентификатора с помощью новой строки, необходимо задать отступ для каждой строки выражения, как показано в следующем коде.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1102.fs)]

Вместо просто имени можно указать шаблон, содержащий имена, например кортеж, как показано в следующем коде.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1103.fs)]

*Выражение body* — это выражение, в котором используются имена. Выражение тела отображается в отдельной строке с отступом до первого символа в `let` ключевом слове:

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1104.fs)]

`let`Привязка может отображаться на уровне модуля, в определении типа класса или в локальных областях, например в определении функции. `let`Для привязки на верхнем уровне модуля или в типе класса не требуется выражение тела, но на других уровнях области требуется выражение тела. Привязанные имена можно использовать после точки определения, но не в любой точке перед `let` отображением привязки, как показано в следующем коде.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1105.fs)]

## <a name="function-bindings"></a>Привязки функций

Привязки функций следуют правилам для привязок значений, за исключением того, что привязки функций включают имя функции и параметры, как показано в следующем коде.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1106.fs)]

Как правило, параметры — это шаблоны, такие как шаблон кортежа:

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1107.fs)]

`let`Выражение привязки принимает значение последнего выражения. Таким образом, в следующем примере кода значение `result` вычисляется из `100 * function3 (1, 2)` , результатом вычисления которого является `300` .

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1109.fs)]

См. дополнительные сведения о [функциях](index.md).

## <a name="type-annotations"></a>Аннотации типов

Можно указать типы для параметров, добавив двоеточие (:) , за которым следует имя типа, заключенное в круглые скобки. Можно также указать тип возвращаемого значения, добавив двоеточие и тип после последнего параметра. Полные аннотации типа для `function1` , в качестве типов параметров которых есть целые числа, будут выглядеть следующим образом.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1108.fs)]

Если нет явных параметров типа, для определения типов параметров функций используется определение типа. Это может включать автоматическое обобщение типа параметра как универсального.

Дополнительные сведения см. в разделе [Автоматическое обобщение](../generics/automatic-generalization.md) и [Вывод типов](../type-inference.md).

## <a name="let-bindings-in-classes"></a>Привязки let в классах

`let`Привязка может присутствовать в типе класса, но не в типе структуры или записи. Чтобы использовать привязку let в типе класса, класс должен иметь первичный конструктор. Параметры конструктора должны находиться после имени типа в определении класса. `let`Привязка в типе класса определяет закрытые поля и члены для этого типа класса, а вместе с `do` привязками в типе формирует код для первичного конструктора для типа. В следующих примерах кода показан класс `MyClass` с закрытыми полями `field1` и `field2` .

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1110.fs)]

Области `field1` и `field2` ограничены типом, в котором они объявляются. Дополнительные сведения см. [ `let` в разделе привязки в классах](../members/let-bindings-in-classes.md) и [классах](../classes.md).

## <a name="type-parameters-in-let-bindings"></a>Параметры типа в привязках let

`let`Привязка на уровне модуля, в типе или в вычислительном выражении может иметь явные параметры типа. Привязка let в выражении, например в определении функции, не может иметь параметры типа. Дополнительные сведения см. в статье [Универсальные шаблоны](../generics/index.md).

## <a name="attributes-on-let-bindings"></a>Атрибуты в привязках let

Атрибуты могут применяться к привязкам верхнего уровня `let` в модуле, как показано в следующем коде.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1111.fs)]

## <a name="scope-and-accessibility-of-let-bindings"></a>Область и доступность привязок let

Область сущности, объявленной с привязкой let, ограничена частью содержащей его области (например, функции, модуля, файла или класса) после отображения привязки. Таким образом, можно сказать, что привязка let вводит имя в область. В модуле значение, привязанное к let, может быть доступно клиентам модуля, если модуль доступен, так как привязки let в модуле компилируются в открытые функции модуля. В отличие от этого, привязки let в классе являются частными для класса.

Обычно функции в модулях должны уточняться именем модуля при использовании клиентского кода. Например, если модуль `Module1` содержит функцию `function1` , пользователи будут `Module1.function1` ссылаться на функцию.

Пользователи модуля могут использовать объявление импорта, чтобы сделать функции в этом модуле доступными для использования без уточнения по имени модуля. В этом примере пользователи модуля могут открыть модуль с помощью открытого объявления импорта `Module1` , а затем напрямую обратиться к нему `function1` .

```fsharp
module Module1 =
    let function1 x = x + 1.0

module Module2 =
    let function2 x =
        Module1.function1 x

open Module1

let function3 x =
    function1 x
```

Некоторые модули имеют атрибут [рекуирекуалифиедакцесс](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-core-requirequalifiedaccessattribute.html), что означает, что предоставляемые им функции должны уточняться именем модуля. Например, у модуля списка F # есть этот атрибут.

Дополнительные сведения о модулях и контроле доступа см. в разделе [модули](../modules.md) и [Управление доступом](../access-control.md).

## <a name="see-also"></a>См. также

- [Функции](index.md)
- [`let` Привязки в классах](../members/let-bindings-in-classes.md)
