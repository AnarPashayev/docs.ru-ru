---
title: Рекурсивные функции. Ключевое слово rec
description: 'Узнайте, как ключевое слово F # REC используется с ключевым словом let для определения рекурсивной функции.'
ms.date: 05/16/2016
ms.openlocfilehash: c2374f90b4585327c6f5208a3d6bca75a23d0cbb
ms.sourcegitcommit: 7499bdb428d63ed0e19e97f54d3d576c41598659
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/31/2020
ms.locfileid: "87455652"
---
# <a name="recursive-functions-the-rec-keyword"></a>Рекурсивные функции. Ключевое слово rec

`rec`Ключевое слово используется вместе с `let` ключевым словом для определения рекурсивной функции.

## <a name="syntax"></a>Синтаксис

```fsharp
// Recursive function:
let rec function-nameparameter-list =
function-body

// Mutually recursive functions:
let rec function1-nameparameter-list =
function1-body
and function2-nameparameter-list =
function2-body
...
```

## <a name="remarks"></a>Примечания

Рекурсивные функции — функции, которые вызывают сами себя, определяются явно на языке F #. Это делает определяемый идентификатор доступным в области действия функции.

В следующем примере кода показана рекурсивная функция, которая выполняет вычисление *n*-<sup>го</sup> числа Фибоначчи с помощью математического определения.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet4001.fs)]

> [!NOTE]
> На практике код, подобный предыдущему примеру, не является идеальным, поскольку он унецессарили повторно выполняет вычисление значений, которые уже были вычислены. Это обусловлено тем, что не является рекурсивным, что объясняется далее в этой статье.

Методы неявно являются рекурсивными в пределах типа; нет необходимости добавлять `rec` ключевое слово. Привязки let в классах не являются неявно рекурсивными.

## <a name="tail-recursion"></a>Заключительная рекурсия

Для некоторых рекурсивных функций необходимо выполнить рефакторинг более "чистого" определения до первого [рекурсивного](https://cs.stackexchange.com/questions/6230/what-is-tail-recursion). Это предотвращает ненужные вычисления. Например, предыдущий генератор чисел Фибоначчи можно перезаписывать следующим образом:

```fsharp
let fib n =
    let rec loop acc1 acc2 n =
        match n with
        | 0 -> acc1
        | 1 -> acc2
        | _ ->
            loop acc2 (acc1 + acc2) (n - 1)
    loop 0 1 n
```

Это более сложная реализация. Создание числа Фибоначчи — отличный пример алгоритма "упрощенного", который математически является чистым, но неэффективным на практике. Некоторые аспекты делают его эффективным в F #, хотя и по-прежнему рекурсивно определяются:

* Рекурсивная внутренняя функция с именем `loop` , которая является шаблоном идиоматическим F #.
* Два агрегатных параметра, которые передают значения накопления рекурсивным вызовам.
* Проверка значения, `n` возвращающего определенную совокупность.

Если этот пример был написан итеративно с помощью цикла, код будет выглядеть аналогично двум различным значениям, которые суммируют числа до тех пор, пока не будет выполнено определенное условие.

Причина этого состоит в том, что рекурсивный вызов не требует сохранения каких-либо значений в стеке вызовов. Все вычисляемые промежуточные значения накапливаются с помощью входных данных внутренней функции. Это также позволяет компилятору F # оптимизировать код так же быстро, как если бы вы написали нечто вроде `while` цикла.

Часто написание кода на F # позволяет рекурсивно обрабатывать что-то с внутренней и внешней функцией, как показано в предыдущем примере. Внутренняя функция использует хвостовую рекурсию, а внешняя функция — лучший интерфейс для вызывающих объектов.

## <a name="mutually-recursive-functions"></a>Взаимные рекурсивные функции

Иногда функции являются *взаимно рекурсивными*, то есть вызывают форму круга, где одна функция вызывает другую, которая, в свою очередь, вызывает первую, с любым числом вызовов между. Необходимо определить такие функции вместе в одной `let` привязке, используя `and` ключевое слово, чтобы связать их вместе.

В следующем примере показаны две взаимно рекурсивные функции.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet4002.fs)]

## <a name="see-also"></a>См. также

- [Функции](index.md)
