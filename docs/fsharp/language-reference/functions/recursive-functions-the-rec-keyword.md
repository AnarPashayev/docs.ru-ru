---
title: Рекурсивные функции. Ключевое слово rec
description: 'Узнайте, как ключевое слово F # REC используется с ключевым словом let для определения рекурсивной функции.'
ms.date: 08/12/2020
ms.openlocfilehash: 1ab00ff9400129e531fd7320861b3d9625cad08c
ms.sourcegitcommit: b4a46f6d7ebf44c0035627d00924164bcae2db30
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/29/2020
ms.locfileid: "91438077"
---
# <a name="recursive-functions-the-rec-keyword"></a>Рекурсивные функции. Ключевое слово rec

`rec`Ключевое слово используется вместе с `let` ключевым словом для определения рекурсивной функции.

## <a name="syntax"></a>Синтаксис

```fsharp
// Recursive function:
let rec function-nameparameter-list =
    function-body

// Mutually recursive functions:
let rec function1-nameparameter-list =
    function1-body

and function2-nameparameter-list =
    function2-body
...
```

## <a name="remarks"></a>Remarks

Рекурсивные функции — функции, которые вызывают сами себя, явным образом определяются на языке F # с помощью `rec` ключевого слова. `rec`Ключевое слово делает имя `let` привязки доступным в ее тексте.

В следующем примере показана рекурсивная функция, которая выполняет вычисление *n*-<sup>го</sup> числа Фибоначчи с помощью математического определения.

```fsharp
let rec fib n =
    match n with
    | 0 | 1 -> 1
    | n -> fib (n-1) + fib (n-2)
```

> [!NOTE]
> На практике код, подобный предыдущему примеру, не является идеальным, поскольку он унецессарили повторно выполняет вычисление значений, которые уже были вычислены. Это обусловлено тем, что не является рекурсивным, что объясняется далее в этой статье.

Методы неявно являются рекурсивными в пределах типа, в котором они определены, то есть нет необходимости добавлять `rec` ключевое слово. Пример:

```fsharp
type MyClass() =
    member this.Fib(n) =
        match n with
        | 0 | 1 -> 1
        | n -> this.Fib(n-1) + this.Fib(n-2)
```

Однако привязки let в классах не являются неявно рекурсивными. `let`Для функций с привязкой требуется `rec` ключевое слово.

## <a name="tail-recursion"></a>Заключительная рекурсия

Для некоторых рекурсивных функций необходимо выполнить рефакторинг более "чистого" определения до первого [рекурсивного](https://cs.stackexchange.com/questions/6230/what-is-tail-recursion). Это предотвращает ненужные вычисления. Например, предыдущий генератор чисел Фибоначчи можно перезаписывать следующим образом:

```fsharp
let fib n =
    let rec loop acc1 acc2 n =
        match n with
        | 0 -> acc1
        | 1 -> acc2
        | _ ->
            loop acc2 (acc1 + acc2) (n - 1)
    loop 0 1 n
```

Это более сложная реализация. Создание числа Фибоначчи — отличный пример алгоритма "упрощенного", который математически является чистым, но неэффективным на практике. Некоторые аспекты делают его эффективным в F #, хотя и по-прежнему рекурсивно определяются:

* Рекурсивная внутренняя функция с именем `loop` , которая является шаблоном идиоматическим F #.
* Два агрегатных параметра, которые передают значения накопления рекурсивным вызовам.
* Проверка значения, `n` возвращающего определенную совокупность.

Если этот пример был написан итеративно с помощью цикла, код будет выглядеть аналогично двум различным значениям, которые суммируют числа до тех пор, пока не будет выполнено определенное условие.

Причина этого состоит в том, что рекурсивный вызов не требует сохранения каких-либо значений в стеке вызовов. Все вычисляемые промежуточные значения накапливаются с помощью входных данных внутренней функции. Это также позволяет компилятору F # оптимизировать код так же быстро, как если бы вы написали нечто вроде `while` цикла.

Часто написание кода на F # позволяет рекурсивно обрабатывать что-то с внутренней и внешней функцией, как показано в предыдущем примере. Внутренняя функция использует хвостовую рекурсию, а внешняя функция — лучший интерфейс для вызывающих объектов.

## <a name="mutually-recursive-functions"></a>Взаимные рекурсивные функции

Иногда функции являются *взаимно рекурсивными*, то есть вызывают форму круга, где одна функция вызывает другую, которая, в свою очередь, вызывает первую, с любым числом вызовов между. Необходимо определить такие функции вместе в одной `let` привязке, используя `and` ключевое слово, чтобы связать их вместе.

В следующем примере показаны две взаимно рекурсивные функции.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet4002.fs)]

## <a name="recursive-values"></a>Рекурсивные значения

Можно также определить значение с `let` привязкой, которое будет рекурсивно. Это иногда делается для ведения журнала. С помощью F # 5 и `nameof` функции можно сделать следующее:

```fsharp
let rec nameDoubles = nameof nameDoubles + nameof nameDoubles
```

## <a name="see-also"></a>См. также

- [Функции](index.md)
