---
title: Встраиваемые функции
description: Сведения об использовании F# встроенные функции, интегрированные непосредственно в вызывающем коде.
ms.date: 05/16/2016
ms.openlocfilehash: 12c175e3e46e12d978fe02d3e1fe83142e71a25d
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61966599"
---
# <a name="inline-functions"></a>Встраиваемые функции

*Встроенные функции* — это функции, интегрированные непосредственно в вызывающем коде.

## <a name="using-inline-functions"></a>С помощью встроенных функций

При использовании статических типов параметров, любые функции, которые параметризуются языком параметров типа должны быть встроенными. Это гарантирует, что компилятор может разрешить эти параметры типа. При использовании обычных параметров универсального типа, не существует такого ограничения.

Кроме применение ограничений членов, встроенные функции могут быть полезны при оптимизации кода. Тем не менее избыточное использование встроенных функций может привести к ваш код будет менее устойчивы к изменениям в оптимизации компилятора и реализации функций библиотек. По этой причине следует избегать использования встроенных функций для оптимизации, если вы попытались использовать другие методы оптимизации. Создание встроенной функции или метода может иногда повысить производительность, но это не всегда так. Таким образом чтобы убедиться, что сделать все встроенные заданная функция на самом деле оказывает положительное влияние также следует использовать измерения производительности.

`inline` Модификатор может применяться к функциям на верхнем уровне, на уровне модуля или на уровне метода в классе.

В следующем примере кода показана встроенная функция на верхнем уровне, встроенный метод экземпляра и встроенный статический метод.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-3/snippet201.fs)]

## <a name="inline-functions-and-type-inference"></a>Встроенные функции и вывод типов

Наличие `inline` влияет на определение типа. Это так, как встроенные функции могут иметь статически разрешаемые параметры типа, а не встроенные функции нельзя. В следующем примере кода показан случай где `inline` полезно потому, что при использовании функции, которая имеет статически разрешаемым параметром типа, `float` оператор преобразования.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-3/snippet202.fs)]

Без `inline` модификатор, вывод типа заставляет функции определенного типа, в данном случае `int`. Но с `inline` модификатор, функция также логически распознается статически разрешаемым параметром типа. С помощью `inline` модификатор, тип определяется следующим:

```fsharp
^a -> unit when ^a : (static member op_Explicit : ^a -> float)
```

Это означает, что функция принимает любой тип, поддерживающий преобразование в **float**.

## <a name="see-also"></a>См. также

- [Функции](index.md)
- [Ограничения](../generics/constraints.md)
- [Статически разрешаемые параметры типов](../generics/statically-resolved-type-parameters.md)