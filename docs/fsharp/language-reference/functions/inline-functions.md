---
title: Встраиваемые функции
description: Сведения об использовании F# встроенные функции, интегрированные непосредственно в вызывающем коде.
ms.date: 05/16/2016
ms.openlocfilehash: d1c3fb3d2721024febc95b3c5e01e06cd547f81e
ms.sourcegitcommit: 8699383914c24a0df033393f55db3369db728a7b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/15/2019
ms.locfileid: "65642068"
---
# <a name="inline-functions"></a>Встраиваемые функции

*Встроенные функции* — это функции, интегрированные непосредственно в вызывающем коде.

## <a name="using-inline-functions"></a>С помощью встроенных функций

При использовании статических типов параметров, любые функции, которые параметризуются языком параметров типа должны быть встроенными. Это гарантирует, что компилятор может разрешить эти параметры типа. При использовании обычных параметров универсального типа, не существует такого ограничения.

Кроме применение ограничений членов, встроенные функции могут быть полезны при оптимизации кода. Тем не менее избыточное использование встроенных функций может привести к ваш код будет менее устойчивы к изменениям в оптимизации компилятора и реализации функций библиотек. По этой причине следует избегать использования встроенных функций для оптимизации, если вы попытались использовать другие методы оптимизации. Создание встроенной функции или метода может иногда повысить производительность, но это не всегда так. Таким образом чтобы убедиться, что сделать все встроенные заданная функция на самом деле оказывает положительное влияние также следует использовать измерения производительности.

`inline` Модификатор может применяться к функциям на верхнем уровне, на уровне модуля или на уровне метода в классе.

В следующем примере кода показана встроенная функция на верхнем уровне, встроенный метод экземпляра и встроенный статический метод.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-3/snippet201.fs)]

## <a name="inline-functions-and-type-inference"></a>Встроенные функции и вывод типов

Наличие `inline` влияет на определение типа. Это так, как встроенные функции могут иметь статически разрешаемые параметры типа, а не встроенные функции нельзя. В следующем примере кода показан случай где `inline` полезно потому, что при использовании функции, которая имеет статически разрешаемым параметром типа, `float` оператор преобразования.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-3/snippet202.fs)]

Без `inline` модификатор, вывод типа заставляет функции определенного типа, в данном случае `int`. Но с `inline` модификатор, функция также логически распознается статически разрешаемым параметром типа. С помощью `inline` модификатор, тип определяется следующим:

```fsharp
^a -> unit when ^a : (static member op_Explicit : ^a -> float)
```

Это означает, что функция принимает любой тип, поддерживающий преобразование в **float**.

## <a name="see-also"></a>См. также

- [Функции](index.md)
- [Ограничения](../generics/constraints.md)
- [Статически разрешаемые параметры типов](../generics/statically-resolved-type-parameters.md)
