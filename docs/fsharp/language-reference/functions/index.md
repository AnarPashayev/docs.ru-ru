---
title: Функции
description: Сведения о функциях F# в и F# о том, как поддерживает стандартные конструкции функционального программирования.
ms.date: 05/16/2016
ms.openlocfilehash: 6f65ce692169b71abe8d2eff7ef07b66975d478b
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/30/2019
ms.locfileid: "68630700"
---
# <a name="functions"></a>Функции

Функции являются основным элементом выполнения программы на любом языке программирования. Как и в других языках, функция F# имеет имя, может иметь параметры и принимать аргументы, а также имеет тело. F# также поддерживает конструкции функционального программирования, например, обработку функций как значений, использование неименованных функций в выражениях, объединение функций для образования новых функций, каррированные функции и неявное определение функций посредством частичного применения аргументов функции.

Функции определяются с помощью ключевого слова `let`, или, если функция является рекурсивной, сочетания ключевых слов `let rec`.

## <a name="syntax"></a>Синтаксис

```fsharp
// Non-recursive function definition.
let [inline] function-name parameter-list [ : return-type ] = function-body
// Recursive function definition.
let rec function-name parameter-list = recursive-function-body
```

## <a name="remarks"></a>Примечания

Элемент *function-name* — это идентификатор, который представляет функцию. Элемент *parameter-list* состоит из последовательных параметров, разделенных пробелами. Вы можете указать явный тип для каждого параметра, как описано в разделе "Параметры". Если не указать конкретный тип аргумента, компилятор пытается определить тип из тела функции. Элемент *function-body* состоит из выражения. Выражение, представляющее тело функции, обычно является составным. Оно состоит из нескольких выражений, которые в результате дают итоговое выражение, являющееся возвращаемым значением. Элемент *return-type* представляет собой двоеточие, за которым следует тип, и является необязательным. Если вы явно не указываете тип возвращаемого значения, компилятор определяет тип возвращаемого значения из итогового выражения.

Простое определение функции выглядит следующим образом:

```fsharp
let f x = x + 1
```

В предыдущем примере `f` является именем функции, `x` — аргументом, имеющим тип `int`, `x + 1` является телом функции, а возвращаемое значение имеет тип `int`.

Функции могут быть помечены как `inline`. Сведения о `inline` см. в статье [Встраиваемые функции](../functions/inline-functions.md).

## <a name="scope"></a>Область

На любом уровне области, отличной от области модуля, не будет ошибкой повторно использовать значение или имя функции. При повторном использовании имя, объявленное позже, затемняет имя, объявленное раньше. Но в области верхнего уровня в модуле имена должны быть уникальными. Например, следующий код вызывает ошибку, когда отображается в области модуля, и не вызывает ее при отображении внутри функции:

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet101.fs)]

Но следующий код допустим на любом уровне области:

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet102.fs)]

### <a name="parameters"></a>Параметры

Имена параметров указываются после имени функции. Можно указать тип для параметра, как показано в следующем примере:

```fsharp
let f (x : int) = x + 1
```

Если тип указан, он стоит после имени параметра и отделяется от него двоеточием. Если тип параметра не указан, он определяется компилятором. Например, в следующем определении функции аргумент `x` определяется, как относящийся к типу `int`, так как 1 имеет тип `int`.

```fsharp
let f x = x + 1
```

Но компилятор попытается сделать функцию как можно более универсальной. Например, изучите следующий код:

```fsharp
let f x = (x, x)
```

Функция создает кортеж из одного аргумента любого типа. Так как тип не задан, функция может использоваться с любым типом аргумента. Дополнительные сведения см. в статье [Автоматическое обобщение](../generics/automatic-generalization.md).

## <a name="function-bodies"></a>Тела функций

Тело функции может содержать определения локальных переменных и функций. Такие переменные и функции находятся в области действия внутри тела текущей функции, но не за его пределами. Если включен упрощенный синтаксис, нужно использовать отступ, чтобы указать, что определение находится внутри тела функции, как показано в следующем примере:

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet103.fs)]

Дополнительные сведения см. в статьях [Рекомендации по форматированию кода](../code-formatting-guidelines.md) и [Подробный синтаксис](../verbose-syntax.md).

## <a name="return-values"></a>Возвращаемые значения

Компилятор использует итоговое выражение в теле функции, чтобы определить возвращаемое значение и его тип. Компилятор может вывести тип итогового выражения из предыдущих выражений. В функции `cylinderVolume`, показанной в предыдущем разделе, тип `pi` определяется по типу литерала `3.14159` как `float`. Компилятор использует тип `pi`, чтобы определить тип выражения `h * pi * r * r` как `float`. Таким образом, общим типом возвращаемого значения функции является `float`.

Чтобы явно задать возвращаемое значение, составьте код следующим образом:

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet105.fs)]

В приведенном выше коде компилятор применяет **float** ко всей функции. Если требуется применить его и к типам параметров, используйте следующий код:

```fsharp
let cylinderVolume (radius : float) (length : float) : float
```

## <a name="calling-a-function"></a>Вызов функции

Вы можете вызывать функции, указав имя функции, за которыми следует пробел, а затем аргументы, разделенные пробелами. Например, чтобы вызвать функцию **cylinderVolume** и назначить результат значению **vol**, составьте следующий код:

```fsharp
let vol = cylinderVolume 2.0 3.0
```

## <a name="partial-application-of-arguments"></a>Частичное применение аргументов

Если число предоставленных аргументов меньше заданного их количества, создается новая функция, ожидающая оставшиеся аргументы. Такой метод работы с аргументами называется *каррингом* и характерен для языков функционального программирования, таких как F#. Предположим, вы работаете с двумя размерами труб: одна имеет радиус **2,0**, а другая — радиус **3,0**. Можно создать функции, определяющие объем трубы следующим образом:

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet106.fs)]

Затем можно предоставить дополнительный аргумент для различных длин трубы двух разных размеров:

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet107.fs)]

## <a name="recursive-functions"></a>Рекурсивные функции

*Рекурсивными* называются функциями, которые вызывают сами себя. Для них нужно указать ключевое слово **rec**, следующее за ключевым словом **let**. Вызов рекурсивной функции в теле функции выполняется так же, как и для любой другой функции. Следующая рекурсивная функция выполняет вычисление n-<sup>го</sup> числа Фибоначчи. Последовательность чисел Фибоначчи известна с античных времен. В ней каждый последующий элемент равен сумме двух предыдущих чисел.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet108.fs)]

Некоторые рекурсивные функции могут переполнить стек программы или работать неэффективно, если при их написании не принимать меры предосторожности и не использовать специальные методики, такие как накапливаемые значения и продолжения.

## <a name="function-values"></a>Значения функции

В языке F# все функции считаются значениями. На самом деле они называются *значениями функции*. Так как функции являются значениями, они могут использоваться в качестве аргументов для других функций или в других контекстах, где применяются значения. Ниже приведен пример функции, которая принимает значение функции в качестве аргумента:

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet109.fs)]

Укажите тип значения функции с помощью токена `->`. В левой части токена находится тип аргумента, а в правой части — возвращаемое значение. В предыдущем примере `apply1` является функцией, которая принимает функцию `transform` как аргумент, где `transform` — это функция, которая принимает целое число и возвращает другое целое число. В следующем коде показано использование `apply1`:

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet110.fs)]

После выполнения предыдущего кода `result` будет иметь значение 101.

Несколько аргументов разделяются токенами `->`, как показано в следующем примере:

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet111.fs)]

Результат равен 200.

## <a name="lambda-expressions"></a>Лямбда-выражения

*Лямбда-выражение* — это неименованная функция. В предыдущих примерах вместо определения именованных функций **increment** и **mul** можно было воспользоваться лямбда-выражением:

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet112.fs)]

Лямбда-выражения определяются с помощью ключевого слова `fun`. Лямбда-выражение напоминает определение функции, за исключением того, что вместо токена `=` для отделения списка аргументов от тела функции используется токен `->`. Как и в обычном определении функции, типы аргументов могут выводиться или указываться явно, а тип возвращаемого значения лямбда-выражения выводится из типа последнего выражения в теле. Дополнительные сведения см. в [разделе Лямбда-выражения: Ключевое](../functions/lambda-expressions-the-fun-keyword.md)слово. `fun`

## <a name="function-composition-and-pipelining"></a>Композиция и конвейеризация функций

В F# функции могут состоять из других функций. Композицией двух функций **function1** и **function2** является другая функция, которая представляет применение функции **function1** с последующим применением функции **function2**:

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet113.fs)]

Результат равен 202.

Конвейеризация позволяет объединять вызовы функций в виде последовательных операций. Конвейеризация работает следующим образом:

```fsharp
let result = 100 |> function1 |> function2
```

Результат снова равен 202.

Операторы композиции принимают две функции и возвращают функцию. Операторы конвейера принимают функцию и аргумент и возвращают значение. В следующем примере кода показано различие между операторами конвейера и композиции. Там продемонстрировано отличие в сигнатурах и использовании функций.

```fsharp
// Function composition and pipeline operators compared.

let addOne x = x + 1
let timesTwo x = 2 * x

// Composition operator
// ( >> ) : ('T1 -> 'T2) -> ('T2 -> 'T3) -> 'T1 -> 'T3
let Compose2 = addOne >> timesTwo

// Backward composition operator
// ( << ) : ('T2 -> 'T3) -> ('T1 -> 'T2) -> 'T1 -> 'T3
let Compose1 = addOne << timesTwo

// Result is 5
let result1 = Compose1 2

// Result is 6
let result2 = Compose2 2

// Pipelining
// Pipeline operator
// ( |> ) : 'T1 -> ('T1 -> 'U) -> 'U
let Pipeline2 x = addOne x |> timesTwo

// Backward pipeline operator
// ( <| ) : ('T -> 'U) -> 'T -> 'U
let Pipeline1 x = addOne <| timesTwo x

// Result is 5
let result3 = Pipeline1 2

// Result is 6
let result4 = Pipeline2 2
```

## <a name="overloading-functions"></a>Перегрузка функций

Можно перегружать методы типа, но не функции. Дополнительные сведения см. в статье [Методы](../members/methods.md).

## <a name="see-also"></a>См. также

- [Значения](../values/index.md)
- [Справочник по языку F#](../index.md)
