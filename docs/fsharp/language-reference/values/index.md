---
title: Значения
description: Узнайте, как значения в F# являются величинами, имеющими конкретный тип.
ms.date: 05/16/2016
ms.openlocfilehash: 5c1d4f1e59cbf092911d99a725654042bf3383b1
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61902191"
---
# <a name="values"></a><span data-ttu-id="3264d-103">Значения</span><span class="sxs-lookup"><span data-stu-id="3264d-103">Values</span></span>

<span data-ttu-id="3264d-104">Значения в F# являются величинами, имеющими конкретный тип. Значения могут быть целыми числами или числами с плавающей запятой, символами или текстом, списками, последовательностями, массивами, кортежами, размеченными объединениями, записями, типами классов или значениями функции.</span><span class="sxs-lookup"><span data-stu-id="3264d-104">Values in F# are quantities that have a specific type; values can be integral or floating point numbers, characters or text, lists, sequences, arrays, tuples, discriminated unions, records, class types, or function values.</span></span>

## <a name="binding-a-value"></a><span data-ttu-id="3264d-105">Привязка значения</span><span class="sxs-lookup"><span data-stu-id="3264d-105">Binding a Value</span></span>

<span data-ttu-id="3264d-106">Термин *привязка* означает сопоставление имени с определением.</span><span class="sxs-lookup"><span data-stu-id="3264d-106">The term *binding* means associating a name with a definition.</span></span> <span data-ttu-id="3264d-107">Ключевое слово `let` привязывает значение, как показано в следующих примерах:</span><span class="sxs-lookup"><span data-stu-id="3264d-107">The `let` keyword binds a value, as in the following examples:</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet601.fs)]

<span data-ttu-id="3264d-108">Тип значения выводится из определения.</span><span class="sxs-lookup"><span data-stu-id="3264d-108">The type of a value is inferred from the definition.</span></span> <span data-ttu-id="3264d-109">Для типа-примитива, такого как целое число или число с плавающей запятой, тип определяется типом литерала.</span><span class="sxs-lookup"><span data-stu-id="3264d-109">For a primitive type, such as an integral or floating point number, the type is determined from the type of the literal.</span></span> <span data-ttu-id="3264d-110">Таким образом, в предыдущем примере компилятор определяет тип `b` как `unsigned int`, а тип `a` — как `int`.</span><span class="sxs-lookup"><span data-stu-id="3264d-110">Therefore, in the previous example, the compiler infers the type of `b` to be `unsigned int`, whereas the compiler infers the type of `a` to be `int`.</span></span> <span data-ttu-id="3264d-111">Тип значения функции определяется по возвращаемому значению в теле функции.</span><span class="sxs-lookup"><span data-stu-id="3264d-111">The type of a function value is determined from the return value in the function body.</span></span> <span data-ttu-id="3264d-112">Дополнительные сведения о типах значений функций см. в статье [Функции](../functions/index.md).</span><span class="sxs-lookup"><span data-stu-id="3264d-112">For more information about function value types, see [Functions](../functions/index.md).</span></span> <span data-ttu-id="3264d-113">Дополнительные сведения о типах литералов см. в статье [Литералы](../literals.md).</span><span class="sxs-lookup"><span data-stu-id="3264d-113">For more information about literal types, see [Literals](../literals.md).</span></span>

<span data-ttu-id="3264d-114">Компилятор не выдает диагностики о неиспользуемых привязки по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="3264d-114">The compiler does not issue diagnostics about unused bindings by default.</span></span> <span data-ttu-id="3264d-115">Чтобы получать эти сообщения, включить предупреждение 1182 в файле проекта или при вызове компилятора (см. в разделе `--warnon` под [параметры компилятора](../compiler-options.md)).</span><span class="sxs-lookup"><span data-stu-id="3264d-115">To receive these messages, enable warning 1182 in your project file or when invoking the compiler (see `--warnon` under [Compiler Options](../compiler-options.md)).</span></span>

## <a name="why-immutable"></a><span data-ttu-id="3264d-116">Для чего нужны неизменяемые значения?</span><span class="sxs-lookup"><span data-stu-id="3264d-116">Why Immutable?</span></span>

<span data-ttu-id="3264d-117">Неизменяемые значения — это значения, которые не могут изменяться в течение всего выполнения программы.</span><span class="sxs-lookup"><span data-stu-id="3264d-117">Immutable values are values that cannot be changed throughout the course of a program's execution.</span></span> <span data-ttu-id="3264d-118">Если вы привыкли к таким языкам, как C++, Visual Basic или C#, вас может удивить, что в F# предпочтение отдается неизменяемым значениям, а не переменным, которым можно назначать новые значения во время выполнения программы.</span><span class="sxs-lookup"><span data-stu-id="3264d-118">If you are used to languages such as C++, Visual Basic, or C#, you might find it surprising that F# puts primacy over immutable values rather than variables that can be assigned new values during the execution of a program.</span></span> <span data-ttu-id="3264d-119">Неизменяемые данные являются важным элементом функционального программирования.</span><span class="sxs-lookup"><span data-stu-id="3264d-119">Immutable data is an important element of functional programming.</span></span> <span data-ttu-id="3264d-120">В многопоточной среде управлять общими изменяемыми переменными, которые могут изменяться множеством разных потоков, довольно сложно.</span><span class="sxs-lookup"><span data-stu-id="3264d-120">In a multithreaded environment, shared mutable variables that can be changed by many different threads are difficult to manage.</span></span> <span data-ttu-id="3264d-121">Кроме того, при работе с изменяемыми переменными иногда бывает трудно определить, может ли переменная изменяться при передаче в другую функцию.</span><span class="sxs-lookup"><span data-stu-id="3264d-121">Also, with mutable variables, it can sometimes be hard to tell if a variable might be changed when it is passed to another function.</span></span>

<span data-ttu-id="3264d-122">В чисто функциональных языках переменные отсутствуют, а функции ведут себя строго как математические функции.</span><span class="sxs-lookup"><span data-stu-id="3264d-122">In pure functional languages, there are no variables, and functions behave strictly as mathematical functions.</span></span> <span data-ttu-id="3264d-123">Там, где код на процедурном языке присваивает переменную для изменения значения, эквивалентный код на функциональном языке использует неизменяемое значение, относящееся к входным данным, неизменяемую функцию и разные неизменяемые значения в качестве выходных данных.</span><span class="sxs-lookup"><span data-stu-id="3264d-123">Where code in a procedural language uses a variable assignment to alter a value, the equivalent code in a functional language has an immutable value that is the input, an immutable function, and different immutable values as the output.</span></span> <span data-ttu-id="3264d-124">Такая математическая строгость позволяет точнее организовать работу программы.</span><span class="sxs-lookup"><span data-stu-id="3264d-124">This mathematical strictness allows for tighter reasoning about the behavior of the program.</span></span> <span data-ttu-id="3264d-125">Это позволяет компиляторам строже проверять код и эффективнее оптимизировать его, а также помогает разработчикам читать и составлять код правильно.</span><span class="sxs-lookup"><span data-stu-id="3264d-125">This tighter reasoning is what enables compilers to check code more stringently and to optimize more effectively, and helps make it easier for developers to understand and write correct code.</span></span> <span data-ttu-id="3264d-126">Таким образом, по сравнению с обычным процедурным кодом отладка функционального кода, скорее всего, будет выполнять проще.</span><span class="sxs-lookup"><span data-stu-id="3264d-126">Functional code is therefore likely to be easier to debug than ordinary procedural code.</span></span>

<span data-ttu-id="3264d-127">Хотя F# и не является чисто функциональным языком, он полностью поддерживает возможности функционального программирования.</span><span class="sxs-lookup"><span data-stu-id="3264d-127">F# is not a pure functional language, yet it fully supports functional programming.</span></span> <span data-ttu-id="3264d-128">Применять неизменяемые значения крайне полезно, так как это позволяет коду использовать важные преимущества функционального программирования.</span><span class="sxs-lookup"><span data-stu-id="3264d-128">Using immutable values is a good practice because doing this allows your code to benefit from an important aspect of functional programming.</span></span>

## <a name="mutable-variables"></a><span data-ttu-id="3264d-129">Изменяемые переменные</span><span class="sxs-lookup"><span data-stu-id="3264d-129">Mutable Variables</span></span>

<span data-ttu-id="3264d-130">Вы можете использовать ключевое слово `mutable` для задания переменной, которую можно изменить.</span><span class="sxs-lookup"><span data-stu-id="3264d-130">You can use the keyword `mutable` to specify a variable that can be changed.</span></span> <span data-ttu-id="3264d-131">В общем случае изменяемые переменные в F# должны иметь ограниченную область действия, например в виде поля типа или локального значения.</span><span class="sxs-lookup"><span data-stu-id="3264d-131">Mutable variables in F# should generally have a limited scope, either as a field of a type or as a local value.</span></span> <span data-ttu-id="3264d-132">Изменяемыми переменными с ограниченной областью легче управлять, кроме того, для них ниже вероятность ошибочного изменения.</span><span class="sxs-lookup"><span data-stu-id="3264d-132">Mutable variables with a limited scope are easier to control and are less likely to be modified in incorrect ways.</span></span>

<span data-ttu-id="3264d-133">Вы можете присвоить изменяемой переменной начальное значение с помощью ключевого слова `let` точно так же, как и при определении значения.</span><span class="sxs-lookup"><span data-stu-id="3264d-133">You can assign an initial value to a mutable variable by using the `let` keyword in the same way as you would define a value.</span></span> <span data-ttu-id="3264d-134">Отличие заключается в том, что позднее изменяемым переменным можно присваивать новые значения с помощью оператора `<-`, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="3264d-134">However, the difference is that you can subsequently assign new values to mutable variables by using the `<-` operator, as in the following example.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet602.fs)]

<span data-ttu-id="3264d-135">Значения, помеченные `mutable` может быть автоматически повышена до `'a ref` Если отслеживается замыкание, включая формы, которые создают замыкания, такие как `seq` построители.</span><span class="sxs-lookup"><span data-stu-id="3264d-135">Values marked `mutable` may be automatically promoted to `'a ref` if captured by a closure, including forms that create closures, such as `seq` builders.</span></span> <span data-ttu-id="3264d-136">Если вы хотите получать уведомления, когда это происходит, включите предупреждение 3180 в файле проекта или при вызове компилятора.</span><span class="sxs-lookup"><span data-stu-id="3264d-136">If you wish to be notified when this occurs, enable warning 3180 in your project file or when invoking the compiler.</span></span>

## <a name="related-topics"></a><span data-ttu-id="3264d-137">См. также</span><span class="sxs-lookup"><span data-stu-id="3264d-137">Related Topics</span></span>

|<span data-ttu-id="3264d-138">Заголовок</span><span class="sxs-lookup"><span data-stu-id="3264d-138">Title</span></span>|<span data-ttu-id="3264d-139">Описание</span><span class="sxs-lookup"><span data-stu-id="3264d-139">Description</span></span>|
|-----|-----------|
|[<span data-ttu-id="3264d-140">Привязки let</span><span class="sxs-lookup"><span data-stu-id="3264d-140">let Bindings</span></span>](../functions/let-bindings.md)|<span data-ttu-id="3264d-141">Содержит сведения об использовании `let` ключевое слово для привязки имен к значениям и функциям.</span><span class="sxs-lookup"><span data-stu-id="3264d-141">Provides information about using the `let` keyword to bind names to values and functions.</span></span>|
|[<span data-ttu-id="3264d-142">Функции</span><span class="sxs-lookup"><span data-stu-id="3264d-142">Functions</span></span>](../functions/index.md)|<span data-ttu-id="3264d-143">Содержит общие сведения о функциях в F#.</span><span class="sxs-lookup"><span data-stu-id="3264d-143">Provides an overview of functions in F#.</span></span>|

## <a name="see-also"></a><span data-ttu-id="3264d-144">См. также</span><span class="sxs-lookup"><span data-stu-id="3264d-144">See also</span></span>

- [<span data-ttu-id="3264d-145">Значения NULL</span><span class="sxs-lookup"><span data-stu-id="3264d-145">Null Values</span></span>](null-Values.md)
- [<span data-ttu-id="3264d-146">Справочник по языку F#</span><span class="sxs-lookup"><span data-stu-id="3264d-146">F# Language Reference</span></span>](../index.md)