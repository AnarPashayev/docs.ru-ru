---
title: Параметры и аргументы
description: Дополнительные сведения о F# поддержка языков для определения параметров и передачи аргументов в функции, методы и свойства.
ms.date: 05/16/2016
ms.openlocfilehash: b68b3fdd14a66a7312efa5adb709adaeceaae282
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61666265"
---
# <a name="parameters-and-arguments"></a>Параметры и аргументы

В этом разделе описывается поддержка языка определения параметров и передачи аргументов в функции, методы и свойства. Он содержит сведения о передаче по ссылке и как определить и использовать методы, которые могут принимать переменное число аргументов.

## <a name="parameters-and-arguments"></a>Параметры и аргументы

Термин *параметр* используется для описания имена для значений, которые требуется предоставить. Термин *аргумент* используется для значения, предоставляемые для каждого параметра.

Параметры можно указать в кортеж или каррированные или в сочетание двух. Можно передать аргументы с помощью явно указанного имени параметра. Параметры методов можно указан как необязательный и задано значение по умолчанию.

## <a name="parameter-patterns"></a>Шаблоны параметров

Параметры, передаваемые функции и методы, как правило, шаблоны, разделяя их пробелами. Это означает, что, в принципе, один из шаблонов, описанных в [выражения сопоставления](match-expressions.md) может использоваться в списке параметров для функции или члена.

Методы обычно используют форме кортежа передача аргументов. Это обеспечивает более четкие результаты с точки зрения других языков .NET, так как в кортеже способ аргументы передаются в методы .NET.

Каррированные чаще всего используется с функциями, созданными с помощью `let` привязки.

Следующий псевдокод отображает примеры кортежа и каррированными аргументами.

```fsharp
// Tuple form.
member this.SomeMethod(param1, param2) = ...
// Curried form.
let function1 param1 param2 = ...
```

Комбинированные формы возможны, когда некоторые аргументы имеют кортежей, а некоторые — нет.

```fsharp
let function2 param1 (param2a, param2b) param3 = ...
```

Другие шаблоны могут также использоваться в списках параметров, но если параметр шаблона не соответствует всех возможных входных значений, может существовать неполное соответствие во время выполнения. Исключение `MatchFailureException` создается, когда значение аргумента не соответствует шаблону, указанному в списке параметров. Компилятор выдает предупреждение в случае, если шаблон параметров неполные совпадений. Хотя бы один шаблон часто имеет смысл использовать списки параметров, и Шаблон подстановочного знака. Вы можете использовать этот шаблон в списке параметров, если нужно просто игнорировать любые аргументы, передаваемые. Следующий код иллюстрирует использование Шаблон подстановочного знака в списке аргументов.

[!code-fsharp[Main](../../../samples/snippets/fsharp/parameters-and-arguments-1/snippet3801.fs)]

Шаблон подстановочного знака может быть полезен всякий раз, когда нет необходимости аргументы, передаваемые в, например главную точку входа в программу, если вы не заинтересованы в аргументы командной строки, которые обычно передаются как массив строк, как показано в следующем коде.

[!code-fsharp[Main](../../../samples/snippets/fsharp/parameters-and-arguments-1/snippet3802.fs)]

Другие шаблоны, которые иногда используются в аргументы являются `as` шаблон и идентификатор шаблоны, связанные с размеченные объединения и активные шаблоны. Шаблон размеченного объединения одиночным можно использовать следующим образом.

[!code-fsharp[Main](../../../samples/snippets/fsharp/parameters-and-arguments-1/snippet3803.fs)]

Выходные данные выглядят следующим образом.

```
Data begins at 0 and ends at 4 in string Et tu, Brute?
Et tu
```

Активные шаблоны можно использовать как параметры, например, при преобразовании аргумента в нужный формат, как показано в следующем примере:

```fsharp
type Point = { x : float; y : float }

let (| Polar |) { x = x; y = y} =
    ( sqrt (x*x + y*y), System.Math.Atan (y/ x) )

let radius (Polar(r, _)) = r
let angle (Polar(_, theta)) = theta
```

Можно использовать `as` шаблон для хранения совпадающее значение как локальное значение, как показано в следующей строке кода.

[!code-fsharp[Main](../../../samples/snippets/fsharp/parameters-and-arguments-1/snippet3805.fs)]

Другой шаблон, который иногда используется — функция, которая остается последний аргумент без имени, предоставляя в теле функции, лямбда-выражения и немедленно выполняет сопоставление шаблона неявный аргумент. Примером этого является следующий код.

[!code-fsharp[Main](../../../samples/snippets/fsharp/parameters-and-arguments-1/snippet3804.fs)]

Этот код определяет функцию, которая принимает список и возвращает `true` Если список пуст, и `false` в противном случае. Использование таких приемов может сделать код более трудным для чтения.

В некоторых случаях шаблоны, включающие неполные совпадения полезны, например, если вы знаете, что списки в программе имеют только три элемента, можно использовать шаблон, как показано ниже в списке параметров.

[!code-fsharp[Main](../../../samples/snippets/fsharp/parameters-and-arguments-1/snippet3806.fs)]

Использование шаблонов с неполным совпадением вариант лучше всего подходит для быстрого создания прототипов и других временных задач. Компилятор выдаст предупреждение для такой код. Такие шаблоны не может охватывать из всех возможных входных значений и следовательно, не подходят для компонента API-интерфейсы.

## <a name="named-arguments"></a>Именованные аргументы

Аргументы методов могут указываться по позиции в список аргументов с разделителями запятыми, или они могут передаваться в метод явно указав имя, за которым следует знак равенства и значение должны быть переданы в. Если указано, указав имя, они могут отображаться в порядке, отличном от используемого в объявлении.

Именованные аргументы может сделать код более читаемым и более адаптируемым к определенным типам изменений в API, такие как изменение порядка параметров метода.

Именованные аргументы можно использовать только для методов, не для `let`-связанные функции, значения функции или лямбда-выражения.

В следующем примере кода показано использование именованных аргументов.

[!code-fsharp[Main](../../../samples/snippets/fsharp/parameters-and-arguments-1/snippet3807.fs)]

В вызове конструктора класса можно задать значения свойств класса с помощью синтаксиса, аналогичного синтаксису именованных аргументов. В следующем примере этот синтаксис.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet3506.fs)]

Дополнительные сведения см. в разделе [конструкторы (F#)](https://msdn.microsoft.com/library/2cd0ed07-d214-4125-8317-4f288af99f05).

## <a name="optional-parameters"></a>Необязательные параметры

Можно указать необязательный параметр для метода, используя знак вопроса перед именем параметра. Необязательные параметры, интерпретируются как F# параметр типа, поэтому их можно запросить его обычным образом, что запрашиваются типы параметров, с помощью `match` выражение с `Some` и `None`. Необязательные параметры можно использовать только для членов, не для функций, созданных с помощью `let` привязки.

Можно передать существующий необязательных значений метода по имени параметра, такие как `?arg=None` или `?arg=Some(3)` или `?arg=arg`. Это может быть полезно, когда построение метод, который передает необязательные аргументы другому методу.

Можно также использовать функцию `defaultArg`, который устанавливает значение по умолчанию для необязательного аргумента. `defaultArg` Функция принимает необязательный параметр в качестве первого аргумента и значение по умолчанию в качестве второго.

Следующий пример иллюстрирует использование необязательных параметров.

[!code-fsharp[Main](../../../samples/snippets/fsharp/parameters-and-arguments-1/snippet3808.fs)]

Выходные данные выглядят следующим образом.

```
Baud Rate: 9600 Duplex: Full Parity: false
Baud Rate: 4800 Duplex: Half Parity: false
Baud Rate: 300 Duplex: Half Parity: true
Baud Rate: 9600 Duplex: Full Parity: false
Baud Rate: 9600 Duplex: Full Parity: false
Baud Rate: 4800 Duplex: Half Parity: false
```

В рамках C# и взаимодействие Visual Basic, можно использовать атрибуты `[<Optional; DefaultParameterValue<(...)>]` в F#, таким образом, чтобы вызывающие объекты будут видеть аргумента как необязательные. Это эквивалентно определения аргумента как необязательные в C# как в `MyMethod(int i = 3)`.

```fsharp
open System
open System.Runtime.InteropServices
type C =
    static member Foo([<Optional; DefaultParameterValue("Hello world")>] message) =
        printfn "%s" message
```

Можно также указать новый объект как значение параметра по умолчанию. Например `Foo` член может иметь необязательный `CancellationToken` как входной вместо:

```fsharp
open System.Threading
open System.Runtime.InteropServices
type C =
    static member Foo([<Optional; DefaultParameterValue(CancellationToken())>] ct: CancellationToken) =
        printfn "%A" ct
```

Значение, заданное в качестве аргумента `DefaultParameterValue` должен соответствовать типу параметра. Например ниже не допускается:

```fsharp
type C =
    static member Wrong([<Optional; DefaultParameterValue("string")>] i:int) = ()
```

В этом случае компилятор создает предупреждение и будет полностью игнорировать оба атрибута. Обратите внимание, что значение по умолчанию `null` должен быть аннотацией типа, как в противном случае компилятор выводит неверный тип, т. е. `[<Optional; DefaultParameterValue(null:obj)>] o:obj`.

## <a name="passing-by-reference"></a>Передача по ссылке

Передачи F# значению по ссылке включает в себя [byrefs](byrefs.md), которые являются типами управляемый указатель. Рекомендации для используемого типа выглядит следующим образом:

* Используйте `inref<'T>` Если вам нужно только считывать указатель.
* Используйте `outref<'T>` Если требуется только для записи указателя.
* Используйте `byref<'T>` Если вам нужно как для чтения, так и для записи к указателю.

```fsharp
let example1 (x: inref<int>) = printfn "It's %d" x

let example2 (x: outref<int>) = x <- x + 1

let example3 (x: byref<int>) =
    printfn "It'd %d" x
    x <- x + 1

// No need to make it mutable, since it's read-only
let x = 1
example1 &x

// Needs to be mutable, since we write to it
let mutable y = 2
example2 &y
example3 &y // Now 'y' is 3
```

Поскольку параметр является указателем, а значение является изменяемым, любые изменения значения сохраняются после выполнения функции.

Кортеж можно использовать как возвращаемое значение для хранения `out` параметров в методы библиотеки .NET. Кроме того, вы можете рассматривать `out` параметра в виде `byref` параметра. В следующем примере кода показаны оба способа.

[!code-fsharp[Main](../../../samples/snippets/fsharp/parameters-and-arguments-1/snippet3810.fs)]

## <a name="parameter-arrays"></a>Массивы параметров

Иногда бывает необходимо определить функцию, которая принимает произвольное число параметров различных типов. Не было бы смысл создать все возможные перегруженные методы для учетной записи для всех типов, которые могут использоваться. Реализации .NET обеспечивают поддержку таких методов за счет функции массивов параметров. Метод, который принимает массив параметров сигнатура можно предоставить произвольное число параметров. Параметры помещаются в массив. Тип элементов массива определяет типы параметров, которые могут быть переданы в функцию. Если определить массив параметров с `System.Object` как тип элемента, клиентский код может передавать значения любого типа.

В F#, массивы параметров можно задавать только в методах. Они не может использоваться в отдельные функции или функции, определенные в модулях.

Массив параметров определяется с помощью `ParamArray` атрибута. `ParamArray` Атрибут может применяться только к последнему параметру.

В следующем коде показан вызов метода .NET, который принимает массив параметров и определение типа в F# , имеющий метод, принимающий массив параметров.

[!code-fsharp[Main](../../../samples/snippets/fsharp/parameters-and-arguments-2/snippet3811.fs)]

При запуске проекта, выходные данные приведенного выше кода выглядит следующим образом:

```console
a 1 10 Hello world 1 True
"a"
1
10.0
"Hello world"
1u
true
```

## <a name="see-also"></a>См. также

- [Члены](members/index.md)
