---
title: Параметры и аргументы
description: Узнайте о поддержке языка F-языка для определения параметров и передачи аргументов функциям, методам и свойствам.
ms.date: 12/04/2019
ms.openlocfilehash: b234ef939128e7cf09d35f9580d4d5010d7dc639
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401055"
---
# <a name="parameters-and-arguments"></a>Параметры и аргументы

Эта тема описывает языковую поддержку для определения параметров и передачи аргументов функциям, методам и свойствам. Она включает в себя информацию о том, как пройти по ссылке, и как определить и использовать методы, которые могут принимать переменное количество аргументов.

## <a name="parameters-and-arguments"></a>Параметры и аргументы

*Параметр* термина используется для описания имен значений, которые должны быть предоставлены. Термин *аргумент* используется для значений, предусмотренных для каждого параметра.

Параметры могут быть указаны в tuple или карри форме, или в некоторой комбинации из двух. Вы можете передавать аргументы, используя явное имя параметра. Параметры методов могут быть определены как факультативные и учитываются значение по умолчанию.

## <a name="parameter-patterns"></a>Шаблоны параметров

Параметры, поставляемые в функции и методы, в целом представляют узоры, разделенные пробелами. Это означает, что в принципе любой из шаблонов, описанных в [выражениях соответствия,](match-expressions.md) может быть использован в списке параметров для функции или члена.

Методы обычно используют форму tuple проходя аргументы. Это обеспечивает более четкий результат с точки зрения других языков .NET, поскольку форма tuple соответствует способу передаваемых аргументов в методах .NET.

Форма карри чаще всего используется с функциями, созданными с помощью `let` переплетов.

Следующие псевдокод показывает примеры tuple и карри аргументы.

```fsharp
// Tuple form.
member this.SomeMethod(param1, param2) = ...
// Curried form.
let function1 param1 param2 = ...
```

Комбинированные формы возможны, когда некоторые аргументы находятся в tuples, а некоторые нет.

```fsharp
let function2 param1 (param2a, param2b) param3 = ...
```

Другие шаблоны также могут быть использованы в списках параметров, но если шаблон параметра не соответствует всем возможным входным моментам, может быть неполное совпадение во время выполнения. Исключение `MatchFailureException` создается, когда значение аргумента не соответствует шаблонам, указанным в списке параметров. Компилятор выдает предупреждение, когда шаблон параметра позволяет неполные совпадения. По крайней мере, один другой шаблон обычно полезен для списков параметров, и это шаблон подстановочных знаков. Шаблон подстановочных знаков используется в списке параметров, когда вы просто хотите игнорировать любые аргументы, которые поставляются. Следующий код иллюстрирует использование шаблона подстановочных знаков в списке аргументов.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3801.fs)]

Шаблон подстановочного знака может быть полезен всякий раз, когда вам не нужны аргументы, передаваемые, например, в основной точке входа в программу, когда вас не интересуют аргументы командной строки, которые обычно поставляются в виде массива строки, как в следующем коде.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3802.fs)]

Другими шаблонами, которые иногда используются в аргументах, являются `as` шаблон и идентификаторы, связанные с дискриминируемыми союзами и активными шаблонами. Вы можете использовать шаблон единого дискриминируемого союза следующим образом.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3803.fs)]

Выходные данные выглядят следующим образом.

```console
Data begins at 0 and ends at 4 in string Et tu, Brute?
Et tu
```

Активные шаблоны могут быть полезны в качестве параметров, например, при преобразовании аргумента в желаемый формат, как в следующем примере:

```fsharp
type Point = { x : float; y : float }

let (| Polar |) { x = x; y = y} =
    ( sqrt (x*x + y*y), System.Math.Atan (y/ x) )

let radius (Polar(r, _)) = r
let angle (Polar(_, theta)) = theta
```

Шаблон можно `as` использовать для хранения совмещенных значений в качестве локального значения, как показано в следующей строке кода.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3805.fs)]

Другой шаблон, который используется время от времени является функция, которая оставляет последний аргумент безымянным, предоставляя, как тело функции, выражение lambda, который сразу же выполняет шаблон совпадают на неявном аргументе. Примером этого является следующая строка кода.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3804.fs)]

Этот код определяет функцию, которая принимает `true` общий список `false` и возвращается, если список пуст, и в противном случае. Использование таких методов может сделать код более трудным для чтения.

Иногда шаблоны, связанные с неполными совпадениями, полезны, например, если вы знаете, что в списках программы есть только три элемента, можно использовать шаблон, подобный следующему в списке параметров.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3806.fs)]

Использование шаблонов, которые имеют неполные совпадения лучше всего зарезервированы для быстрого прототипирования и других временных применений. Компилятор выдаст предупреждение для такого кода. Такие закономерности не могут охватывать общий случай всех возможных входных данных и поэтому не подходят для компонентных AIS.

## <a name="named-arguments"></a>Именованные аргументы

Аргументы для методов могут быть указаны по позиции в списке аргументов, разделенных запятой, или они могут быть переданы методу явно, предоставив имя, за которым следует равный знак и значение, которое должно быть передано. Если указано, указывая имя, они могут отображаться в другом порядке, чем в декларации.

Названные аргументы могут сделать код более читаемым и более адаптируемым к определенным типам изменений в API, таким как переупорядочение параметров метода.

Именованные аргументы допускаются `let`только для методов, а не для связанных функций, значений функций или выражений лямбды.

Следующий пример кода демонстрирует использование названных аргументов.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3807.fs)]

При вызове к конструктору класса можно установить значения свойств класса, используя синтаксис, аналогичный тому, который используется из названных аргументов. Следующий пример показывает этот синтаксис.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet3506.fs)]

Для получения дополнительной [информации, см.](https://msdn.microsoft.com/library/2cd0ed07-d214-4125-8317-4f288af99f05)

## <a name="optional-parameters"></a>Необязательные параметры

Можно указать дополнительный параметр для метода, используя вопросительный знак перед именем параметра. Дополнительные параметры интерпретируются как тип опции F, так что вы можете запрашивать их `match` в `Some` `None`обычном порядке, что типы опций запрашиваются, с помощью выражения с и . Дополнительные параметры допускаются только на членах, `let` а не на функциях, созданных с помощью привязок.

Вы можете передать существующие дополнительные значения методу `?arg=Some(3)` `?arg=arg`по имени параметра, например `?arg=None` или . Это может быть полезно при создании метода, который передает дополнительные аргументы другому методу.

Вы также можете `defaultArg`использовать функцию, которая устанавливает значение по умолчанию факультативного аргумента. Функция `defaultArg` принимает дополнительный параметр в качестве первого аргумента, а значение по умолчанию — второй.

Следующий пример иллюстрирует использование факультативных параметров.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3808.fs)]

Выходные данные выглядят следующим образом.

```console
Baud Rate: 9600 Duplex: Full Parity: false
Baud Rate: 4800 Duplex: Half Parity: false
Baud Rate: 300 Duplex: Half Parity: true
Baud Rate: 9600 Duplex: Full Parity: false
Baud Rate: 9600 Duplex: Full Parity: false
Baud Rate: 4800 Duplex: Half Parity: false
```

Для целей C и Visual Basic interop вы `[<Optional; DefaultParameterValue<(...)>]` можете использовать атрибуты в F, так что абоненты будут рассматривать аргумент как необязательный. Это эквивалентно определению аргумента как факультативного в C, как и в `MyMethod(int i = 3)`.

```fsharp
open System
open System.Runtime.InteropServices
type C =
    static member Foo([<Optional; DefaultParameterValue("Hello world")>] message) =
        printfn "%s" message
```

Можно также указать новый объект в качестве значения параметра по умолчанию. Например, `Foo` вместо этого у `CancellationToken` участника может быть дополнительный в качестве ввода:

```fsharp
open System.Threading
open System.Runtime.InteropServices
type C =
    static member Foo([<Optional; DefaultParameterValue(CancellationToken())>] ct: CancellationToken) =
        printfn "%A" ct
```

Значение, приведенное `DefaultParameterValue` в качестве аргумента, должно соответствовать типу параметра. Например, не допускается следующее:

```fsharp
type C =
    static member Wrong([<Optional; DefaultParameterValue("string")>] i:int) = ()
```

В этом случае компилятор генерирует предупреждение и полностью проигнорирует оба атрибута. Обратите внимание, `null` что значение по умолчанию должно быть аннотировано к типу, так `[<Optional; DefaultParameterValue(null:obj)>] o:obj`как в противном случае компилятор вычеркивает неправильный тип, т.е.

## <a name="passing-by-reference"></a>Проходя мимо Справки

Прохождение значения F-значения по ссылке включает в себя [byrefs](byrefs.md), которые управляются типами указателей. Руководство по типу для использования заключается в следующем:

- Используйте, `inref<'T>` если вам нужно только прочитать указатель.
- Используйте, `outref<'T>` если вам нужно только написать в указатель.
- Используйте, `byref<'T>` если вам нужно как читать, так и писать в указатель.

```fsharp
let example1 (x: inref<int>) = printfn "It's %d" x

let example2 (x: outref<int>) = x <- x + 1

let example3 (x: byref<int>) =
    printfn "It'd %d" x
    x <- x + 1

let test () =
    // No need to make it mutable, since it's read-only
    let x = 1
    example1 &x

    // Needs to be mutable, since we write to it
    let mutable y = 2
    example2 &y
    example3 &y // Now 'y' is 3
```

Поскольку параметр является указателем и значение изменяется, любые изменения значения сохраняются после выполнения функции.

Для хранения любых `out` параметров в методах библиотеки .NET можно использовать tuple в качестве значения возврата. Кроме того, можно `out` рассматривать параметр как `byref` параметр. Следующий пример кода иллюстрирует оба способа.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3810.fs)]

## <a name="parameter-arrays"></a>Массивы параметров

Иногда необходимо определить функцию, которая принимает произвольное количество параметров неоднородного типа. Было бы нецелесообразно создавать все возможные перегруженные методы для учета всех типов, которые могут быть использованы. Реализации .NET обеспечивают поддержку таких методов через функцию параметра. Метод, который принимает массив параметров в своей подписи, может быть предоставлен с произвольным числом параметров. Параметры помещаются в массив. Тип элементов массива определяет типы параметров, которые могут быть переданы функции. Если вы определяете `System.Object` массив параметров с типом элемента, то клиентский код может передавать значения любого типа.

В F-области параметры могут быть определены только в методах. Они не могут быть использованы в автономных функциях или функциях, которые определяются в модулях.

Вы определяете массив параметров с помощью атрибута. `ParamArray` Атрибут `ParamArray` может быть применен только к последнему параметру.

Следующий код иллюстрирует как вызов метода .NET, который принимает массив параметров, так и определение типа в F-, который имеет метод, который принимает массив параметров.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-2/snippet3811.fs)]

При запуске в проекте вывод предыдущего кода:

```console
a 1 10 Hello world 1 True
"a"
1
10.0
"Hello world"
1u
true
```

## <a name="see-also"></a>См. также раздел

- [Членов](./members/index.md)
