---
title: Параметры и аргументы
description: Сведения о F# языковой поддержке для определения параметров и передачи аргументов в функции, методы и свойства.
ms.date: 05/16/2016
ms.openlocfilehash: 561cefb1d437b2f38f6ee4ca37cd955235ca06fa
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/30/2019
ms.locfileid: "68627315"
---
# <a name="parameters-and-arguments"></a>Параметры и аргументы

В этом разделе описывается языковая поддержка для определения параметров и передачи аргументов в функции, методы и свойства. Он содержит сведения о том, как передавать данные по ссылке, а также определять и использовать методы, которые могут принимать переменное число аргументов.

## <a name="parameters-and-arguments"></a>Параметры и аргументы

*Параметр* term используется для описания имен для значений, которые должны быть указаны. *Аргумент* term используется для значений, предоставленных для каждого параметра.

Параметры могут быть указаны в кортеже или в каррированных форме или в некоторой комбинации этих двух значений. Аргументы можно передать с помощью явного имени параметра. Параметры методов можно указать как необязательные и задавая значение по умолчанию.

## <a name="parameter-patterns"></a>Шаблоны параметров

Параметры, предоставляемые функциям и методам, обычно являются шаблонами, разделенными пробелами. Это означает, что в принципе любой из шаблонов, описанных в [выражениях Match](match-expressions.md) , можно использовать в списке параметров для функции или элемента.

Обычно методы используют форму кортежа передаваемых аргументов. Это дает более четкий результат с точки зрения других языков .NET, поскольку форма кортежа соответствует способу передачи аргументов в методах .NET.

Каррированных формы чаще всего используются с функциями, созданными с помощью `let` привязок.

В следующем псевдокоде показаны примеры кортежа и каррированных аргумента.

```fsharp
// Tuple form.
member this.SomeMethod(param1, param2) = ...
// Curried form.
let function1 param1 param2 = ...
```

Объединенные формы возможны, когда некоторые аргументы находятся в кортежах, а некоторые — нет.

```fsharp
let function2 param1 (param2a, param2b) param3 = ...
```

Другие шаблоны также можно использовать в списках параметров, но если шаблон параметра не соответствует всем возможным входным данным, то во время выполнения может быть неполным совпадением. Исключение `MatchFailureException` создается, когда значение аргумента не совпадает с шаблонами, указанными в списке параметров. Компилятор выдает предупреждение, если шаблон параметра допускает неполные соответствия. По крайней мере один другой шаблон обычно полезен для списков параметров, и это шаблон с подстановочными знаками. Шаблон подстановочного знака используется в списке параметров, если нужно просто игнорировать любые аргументы. Следующий код иллюстрирует использование шаблона с подстановочными знаками в списке аргументов.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3801.fs)]

Шаблон подстановочного знака может быть полезен, если не нужны передаваемые аргументы, например, в главной точке входа в программу, если вы не заинтересованы в аргументах командной строки, которые обычно предоставляются в виде массива строк, как показано в следующем коде.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3802.fs)]

Другие шаблоны, которые иногда используются в аргументах, `as` являются шаблоном и шаблонами идентификаторов, связанными с размеченные объединениями и активными шаблонами. Шаблон размеченного объединения с одним вариантом можно использовать следующим образом.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3803.fs)]

Выходные данные выглядят следующим образом.

```
Data begins at 0 and ends at 4 in string Et tu, Brute?
Et tu
```

Активные шаблоны могут быть полезны в качестве параметров, например при преобразовании аргумента в нужный формат, как показано в следующем примере:

```fsharp
type Point = { x : float; y : float }

let (| Polar |) { x = x; y = y} =
    ( sqrt (x*x + y*y), System.Math.Atan (y/ x) )

let radius (Polar(r, _)) = r
let angle (Polar(_, theta)) = theta
```

`as` Шаблон можно использовать для сохранения совпадающего значения в качестве локального значения, как показано в следующей строке кода.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3805.fs)]

Другой шаблон, который используется иногда, — это функция, которая оставляет последний аргумент без имени, предоставляя в качестве тела функции лямбда-выражение, которое сразу же выполняет сопоставление шаблона с неявным аргументом. Ниже приведен пример кода.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3804.fs)]

Этот код определяет функцию, которая принимает универсальный список и возвращает `true` значение, если список пуст, и `false` в противном случае. Использование таких методов может сделать код более трудным для чтения.

Иногда шаблоны, использующие Неполные совпадения, полезны, например, если известно, что списки в программе содержат только три элемента, в списке параметров можно использовать такой шаблон, как показано ниже.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3806.fs)]

Использование шаблонов с неполными соответствиями лучше всего зарезервировано для быстрого создания прототипов и других временных применений. Компилятор выдаст предупреждение для такого кода. Такие шаблоны не могут охватывать все возможные входные данные и поэтому не подходят для API-интерфейсов компонентов.

## <a name="named-arguments"></a>Именованные аргументы

Аргументы для методов могут быть заданы по положению в списке аргументов с разделителями-запятыми или могут быть переданы в метод явным образом путем указания имени, за которым следует знак равенства и значение, которое необходимо передать. Если указано имя, оно может находиться в другом порядке, отличном от того, который используется в объявлении.

Именованные аргументы могут сделать код более удобочитаемым и более адаптируемым к определенным типам изменений в API, например изменить порядок параметров метода.

Именованные аргументы допускаются только для методов, а `let`не для функций, значений функций или лямбда-выражений.

В следующем примере кода показано использование именованных аргументов.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3807.fs)]

При вызове конструктора класса можно задать значения свойств класса, используя синтаксис, аналогичный именованным аргументам. Этот синтаксис показан в следующем примере.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet3506.fs)]

Дополнительные сведения см. в разделе [конструкторыF#()](https://msdn.microsoft.com/library/2cd0ed07-d214-4125-8317-4f288af99f05).

## <a name="optional-parameters"></a>Необязательные параметры

Для метода можно указать необязательный параметр, используя вопросительный знак перед именем параметра. Необязательные параметры интерпретируется как F# тип параметра, поэтому их можно запросить обычным способом запроса типов параметров с помощью `match` выражения с `Some` и `None`. Необязательные параметры разрешены только для членов, но не для функций `let` , созданных с помощью привязок.

Можно передать существующие необязательные значения методу по имени параметра, например `?arg=None` `?arg=arg`или `?arg=Some(3)` . Это может быть полезно при создании метода, который передает необязательные аргументы другому методу.

Можно также использовать функцию `defaultArg`, которая задает значение по умолчанию для необязательного аргумента. `defaultArg` Функция принимает необязательный параметр в качестве первого аргумента и значение по умолчанию в качестве второго.

В следующем примере показано использование необязательных параметров.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3808.fs)]

Выходные данные выглядят следующим образом.

```
Baud Rate: 9600 Duplex: Full Parity: false
Baud Rate: 4800 Duplex: Half Parity: false
Baud Rate: 300 Duplex: Half Parity: true
Baud Rate: 9600 Duplex: Full Parity: false
Baud Rate: 9600 Duplex: Full Parity: false
Baud Rate: 4800 Duplex: Half Parity: false
```

В целях C# и Visual Basic Interop можно использовать атрибуты `[<Optional; DefaultParameterValue<(...)>]` в F#, чтобы вызывающие объекты увидят аргумент как необязательный. Это эквивалентно определению аргумента в качестве C# необязательного `MyMethod(int i = 3)`в, как в.

```fsharp
open System
open System.Runtime.InteropServices
type C =
    static member Foo([<Optional; DefaultParameterValue("Hello world")>] message) =
        printfn "%s" message
```

Можно также указать новый объект в качестве значения параметра по умолчанию. Например, `Foo` элемент может иметь необязательный `CancellationToken` вход в качестве входа:

```fsharp
open System.Threading
open System.Runtime.InteropServices
type C =
    static member Foo([<Optional; DefaultParameterValue(CancellationToken())>] ct: CancellationToken) =
        printfn "%A" ct
```

Значение, заданное в качестве `DefaultParameterValue` аргумента, должно соответствовать типу параметра. Например, следующее не разрешено:

```fsharp
type C =
    static member Wrong([<Optional; DefaultParameterValue("string")>] i:int) = ()
```

В этом случае компилятор выдает предупреждение и будет полностью игнорировать оба атрибута. Обратите внимание, что `null` значение по умолчанию должно быть снабжено заметками типа, так как в противном случае компилятор `[<Optional; DefaultParameterValue(null:obj)>] o:obj`выводит неверный тип, т. е.

## <a name="passing-by-reference"></a>Передача по ссылке

Передача F# значения по ссылке включает в себя [ByRef](byrefs.md), которые являются типами управляемых указателей. Ниже приведены рекомендации по использованию типа.

* Используйте `inref<'T>` , если требуется только чтение указателя.
* Используйте `outref<'T>` , если требуется только запись в указатель.
* Используйте `byref<'T>` , если требуется как чтение, так и запись в указатель.

```fsharp
let example1 (x: inref<int>) = printfn "It's %d" x

let example2 (x: outref<int>) = x <- x + 1

let example3 (x: byref<int>) =
    printfn "It'd %d" x
    x <- x + 1

// No need to make it mutable, since it's read-only
let x = 1
example1 &x

// Needs to be mutable, since we write to it
let mutable y = 2
example2 &y
example3 &y // Now 'y' is 3
```

Поскольку параметр является указателем и значение является изменяемым, любые изменения значения сохраняются после выполнения функции.

Можно использовать кортеж в качестве возвращаемого значения для хранения любых `out` параметров в методах библиотеки .NET. Кроме того, `out` параметр можно рассматривать `byref` как параметр. В следующем примере кода показаны оба способа.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3810.fs)]

## <a name="parameter-arrays"></a>Массивы параметров

Иногда необходимо определить функцию, которая принимает произвольное число параметров разнородного типа. Было бы нецелесообразным создавать все возможные перегруженные методы для учета всех типов, которые можно использовать. Реализации .NET обеспечивают поддержку таких методов с помощью функции массива параметров. Метод, принимающий в сигнатуру массив параметров, может предоставляться с произвольным числом параметров. Параметры помещаются в массив. Тип элементов массива определяет типы параметров, которые могут быть переданы в функцию. Если определить массив параметров с `System.Object` типом элемента, клиентский код может передавать значения любого типа.

В F#массивы параметров можно определять только в методах. Их нельзя использовать в отдельных функциях или функциях, определенных в модулях.

Массив параметров определяется с помощью `ParamArray` атрибута. `ParamArray` Атрибут может применяться только к последнему параметру.

В следующем коде показано, как вызвать метод .NET, который принимает массив параметров, и определение типа в F# , имеющее метод, принимающий массив параметров.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-2/snippet3811.fs)]

При запуске в проекте выходные данные предыдущего кода выглядят следующим образом:

```console
a 1 10 Hello world 1 True
"a"
1
10.0
"Hello world"
1u
true
```

## <a name="see-also"></a>См. также

- [Члены](./members/index.md)
