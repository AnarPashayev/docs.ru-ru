---
title: Записи
description: Узнайте, как F# записи представляют собой простые агрегаты именованных значений, при необходимости с участниками.
ms.date: 05/16/2016
ms.openlocfilehash: a499755383654ddaf76af12776ee93f27834b7b0
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61795425"
---
# <a name="records"></a>Записи

Записи представляют собой простые агрегаты именованных значений, которые могут иметь элементы.  Начиная с F# 4.1, они могут входить структуры или ссылочный тип.  Они являются ссылочными типами, по умолчанию.

## <a name="syntax"></a>Синтаксис

```fsharp
[ attributes ]
type [accessibility-modifier] typename =
    { [ mutable ] label1 : type1;
      [ mutable ] label2 : type2;
      ... }
    [ member-list ]
```

## <a name="remarks"></a>Примечания

В приведенном выше синтаксисе *typename* имя типа записи, *label1* и *label2* — это имена значений, называется *метки*, и *тип1* и *тип2* типы из следующих значений. *Список членов* — необязательный список элементов для типа.  Можно использовать `[<Struct>]` атрибут для создания записи структуры, а не записи, которая является ссылочным типом.

Ниже приведены некоторые примеры.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1901.fs)]

При каждой метки находится на отдельной строке, точка с запятой является необязательным.

Можно задать значения в выражениях, известный как *записи выражения*. Компилятор выводит тип на основе подписи (если метки в достаточной степени отличаются от других типов записей). Фигурные скобки ({}) заключите выражение записи. В следующем коде показано выражение записи, инициализирующее запись с тремя элементами число с плавающей запятой с метками `x`, `y` и `z`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1907.fs)]

Не используйте сокращенную форму, если может быть другой тип, который также имеет одинаковые заголовки.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1903.fs)]

Метки последнего объявленного типа имеют приоритет над метками ранее объявленного типа, поэтому в приведенном выше примере `mypoint3D` выводится как `Point3D`. Можно явно указать тип записи, как показано в следующем коде.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1908.fs)]

Методы могут определяться для типов записей, так же как и типы классов.

## <a name="creating-records-by-using-record-expressions"></a>Создание записей с помощью выражений записей

Записи можно инициализировать с помощью метки, которые определены в записи. Выражение, которое делает это называется *записать выражение*. Используйте фигурные скобки для заключите выражение записи и используют в качестве разделителя точку с запятой.

В следующем примере показано, как создать запись.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1904.fs)]

Точка с запятой после последнего поля в выражении записи и в определении типа являются необязательными, независимо от того, являются ли поля все в одну строку.

При создании записи необходимо указать значения для каждого поля. Нельзя ссылаться на значения других полей в выражении инициализации для любого поля.

В следующем коде, тип `myRecord2` выводится из имена полей. При необходимости можно явно указать имя типа.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1905.fs)]

Можно использовать другую форму конструкции записи, при необходимо будет скопировать существующую запись, возможно, изменить некоторые значения полей. Это показано в следующей строке кода.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1906.fs)]

Эта форма выражения записи называется *копирование и обновление выражений записей*.

Записи являются неизменяемыми по умолчанию; Тем не менее можно легко создать измененные записи с помощью копирования и обновить выражение. Можно также явно указать изменяемого поля.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1909.fs)]

Не используйте атрибут DefaultValue с полями записей. Лучшим подходом является определение экземпляров по умолчанию записей с полями, которые были инициализированы значениями по умолчанию, а затем использовать копию и обновить записи выражение, чтобы задать все поля, которые отличаются от значений по умолчанию.

```fsharp
// Rather than use [<DefaultValue>], define a default record.
type MyRecord =
    { Field1 : int
      Field2 : int }

let defaultRecord1 = { Field1 = 0; Field2 = 0 }
let defaultRecord2 = { Field1 = 1; Field2 = 25 }

// Use the with keyword to populate only a few chosen fields
// and leave the rest with default values.
let rr3 = { defaultRecord1 with Field2 = 42 }
```

## <a name="creating-mutually-recursive-records"></a>Создание взаимно рекурсивные записей

Некоторое время в том случае, когда создается запись, может потребоваться его зависят от другого типа, который вы хотите определить позже. Это ошибка компиляции, если не определить типы записей, которые взаимно быть рекурсивными.

Определение взаимно рекурсивные записей выполняется с помощью `and` ключевое слово. Это позволяет привязать 2 или более записей типы друг с другом.

Например, следующий код определяет `Person` и `Address` тип как взаимно рекурсивные:

```fsharp
// Create a Person type and use the Address type that is not defined
type Person =
  { Name: string
    Age: int
    Address: Address }
// Define the Address type which is used in the Person record
and Address =
  { Line1: string
    Line2: string
    PostCode: string }
```

Если определить в предыдущем примере без `and` ключевое слово, то оно не будет компилироваться. `and` Ключевое слово является обязательным для взаимно рекурсивные определения.

## <a name="pattern-matching-with-records"></a>Сопоставление шаблонов с записями

Записи могут использоваться с сопоставлением шаблонов. Можно явным образом задать некоторые поля и указать переменные для других полей, которые будут назначаться при совпадении. Это показано в следующем примере кода.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1910.fs)]

Результат выполнения этого кода выглядит следующим образом.

```
Point is at the origin.
Point is on the x-axis. Value is 100.000000.
Point is at (10.000000, 0.000000, -1.000000).
```

## <a name="differences-between-records-and-classes"></a>Различия между записями и классы

Поля записей отличаются от классов, в том, что они автоматически представляются как свойства, и они используются при создании и копировании записей. Построение записей также отличается от построения класса. В типе записи не может определить конструктор. Вместо этого применяется синтаксис конструкции, описанный в этом разделе. Классы не имеют прямых связей между параметров конструктора, поля и свойства.

Как и типы объединения и структуру записи имеют семантику структурного равенства. Классы имеют ссылки семантику равенства. Это действие представлено в следующем примере кода:

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1911.fs)]

Результат выполнения этого кода выглядит следующим образом:

```
The records are equal.
```

При написании один и тот же код с классами, два объекта класса будут неравными, так как эти два значения будут представлять два объекта в куче и будут сравниваться только адреса (если тип класса не переопределяет `System.Object.Equals` метод).

Если требуется ссылка на равенство для записей, добавьте атрибут `[<ReferenceEquality>]` выше запись.

## <a name="see-also"></a>См. также

- [Типы языка F#](fsharp-types.md)
- [Классы](classes.md)
- [Справочник по языку F#](index.md)
- [Равенство ссылок](https://msdn.microsoft.com/visualfsharpdocs/conceptual/core.referenceequalityattribute-class-%5bfsharp%5d)
- [Соответствие шаблону](pattern-matching.md)
