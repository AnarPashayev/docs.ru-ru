---
title: Записи
description: 'Узнайте, как записи F # представляют простые статистические выражения именованных значений, при необходимости с элементами.'
ms.date: 08/15/2020
ms.openlocfilehash: 182b2e83c3940c866197052af102787a96e49c54
ms.sourcegitcommit: 8bfeb5930ca48b2ee6053f16082dcaf24d46d221
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/18/2020
ms.locfileid: "88559054"
---
# <a name="records"></a>Записи

Записи представляют собой простые агрегаты именованных значений, которые могут иметь элементы. Они могут быть либо структурами, либо ссылочными типами.  По умолчанию они являются ссылочными типами.

## <a name="syntax"></a>Синтаксис

```fsharp
[ attributes ]
type [accessibility-modifier] typename =
    { [ mutable ] label1 : type1;
      [ mutable ] label2 : type2;
      ... }
    [ member-list ]
```

## <a name="remarks"></a>Remarks

В предыдущем синтаксисе *TypeName* — это имя типа записи, *Label1* и *ярлык2* — имена значений, называемые *метками*, а *Type1* и *тип2* — типы этих значений. *member-list* — это необязательный список элементов для типа.  Атрибут можно использовать `[<Struct>]` для создания записи структуры, а не для записи, которая является ссылочным типом.

Ниже приводятся некоторые примеры.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1901.fs)]

Если каждая метка находится в отдельной строке, точка с запятой является необязательной.

Значения можно задавать в выражениях, называемых *выражениями записи*. Компилятор выводит тип из используемых меток (если метки достаточно отличаются от других типов записей). Фигурные скобки ({}) заключают выражение записи. В следующем коде показано выражение записи, которое инициализирует запись с тремя элементами с плавающей запятой с метками `x` `y` и `z` .

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1907.fs)]

Не используйте сокращенную форму, если возможно наличие другого типа, который также имеет одинаковые метки.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1903.fs)]

Метки последнего объявленного типа имеют приоритет над элементами ранее объявленного типа, поэтому в предыдущем примере `mypoint3D` выводится как `Point3D` . Можно явно указать тип записи, как показано в следующем коде.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1908.fs)]

Методы могут быть определены для типов записей так же, как для типов классов.

## <a name="creating-records-by-using-record-expressions"></a>Создание записей с помощью выражений записи

Можно инициализировать записи с помощью меток, определенных в записи. Выражение, которое делает это, называется *выражением записи*. Используйте фигурные скобки, чтобы заключить выражение записи и использовать точку с запятой в качестве разделителя.

В следующем примере показано, как создать запись.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1904.fs)]

Точки с запятой после последнего поля в выражении записи и в определении типа являются необязательными независимо от того, все ли поля находятся в одной строке.

При создании записи необходимо указать значения для каждого поля. Нельзя ссылаться на значения других полей в выражении инициализации для любого поля.

В следующем коде тип `myRecord2` выводится из имен полей. При необходимости можно явно указать имя типа.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1905.fs)]

Другая форма создания записи может быть полезной, если необходимо скопировать существующую запись и, возможно, изменить некоторые значения полей. Это показано в следующей строке кода.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1906.fs)]

Эта форма выражения записи называется *выражением копирования и обновления записи*.

По умолчанию записи являются неизменяемыми; Однако вы можете легко создавать измененные записи с помощью выражения копирования и обновления. Можно также явно указать изменяемое поле.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1909.fs)]

Не используйте атрибут DefaultValue с полями записей. Лучшим подходом является определение экземпляров по умолчанию для записей с полями, которые инициализируются значениями по умолчанию, а затем использование выражения копирования и обновления записей для установки любых полей, которые отличаются от значений по умолчанию.

```fsharp
// Rather than use [<DefaultValue>], define a default record.
type MyRecord =
    { Field1 : int
      Field2 : int }

let defaultRecord1 = { Field1 = 0; Field2 = 0 }
let defaultRecord2 = { Field1 = 1; Field2 = 25 }

// Use the with keyword to populate only a few chosen fields
// and leave the rest with default values.
let rr3 = { defaultRecord1 with Field2 = 42 }
```

## <a name="creating-mutually-recursive-records"></a>Создание взаимно рекурсивных записей

Иногда при создании записи может потребоваться, чтобы она зависела от другого типа, который вы хотите определить позже. Это ошибка компиляции, если не определить типы записей для взаимной рекурсивной рекурсии.

Определение взаимно рекурсивных записей выполняется с помощью `and` ключевого слова. Это позволяет связать 2 или более типов записей вместе.

Например, следующий код определяет `Person` `Address` тип и как взаимно рекурсивный:

```fsharp
// Create a Person type and use the Address type that is not defined
type Person =
  { Name: string
    Age: int
    Address: Address }
// Define the Address type which is used in the Person record
and Address =
  { Line1: string
    Line2: string
    PostCode: string
    Occupant: Person }
```

Если бы вы определили предыдущий пример без `and` ключевого слова, он не будет компилироваться. `and`Для взаимно рекурсивных определений требуется ключевое слово.

## <a name="pattern-matching-with-records"></a>Сопоставление шаблонов с записями

Записи можно использовать с сопоставлением шаблонов. Можно явно указать некоторые поля и предоставить переменные для других полей, которые будут назначаться при совпадении. Это показано в следующем примере кода.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1910.fs)]

Выходные данные этого кода выглядят следующим образом.

```console
Point is at the origin.
Point is on the x-axis. Value is 100.000000.
Point is at (10.000000, 0.000000, -1.000000).
```

## <a name="records-and-members"></a>Записи и члены

Вы можете указать элементы в записях так же, как и с классами. Поля не поддерживаются. Распространенный подход заключается в определении `Default` статического члена для простоты создания записей:

```fsharp
type Person =
  { Name: string
    Age: int
    Address: string }

    static member Default =
        { Name = "Phillip"
          Age = 12
          Address = "123 happy fun street" }

let defaultPerson = Person.Default
```

При использовании собственного идентификатора этот идентификатор ссылается на экземпляр записи, членом которой является:

```fsharp
type Person =
  { Name: string
    Age: int
    Address: string }

    member this.WeirdToString() =
        this.Name + this.Address + string this.Age

let p = { Name = "a"; Age = 12; Address = "abc123 }
let weirdString = p.WeirdToString()
```

## <a name="differences-between-records-and-classes"></a>Различия между записями и классами

Поля записей отличаются от классов тем, что они автоматически предоставляются как свойства и используются при создании и копировании записей. Построение записей также отличается от создания класса. В типе записи нельзя определить конструктор. Вместо этого применяется синтаксис создания, описанный в этом разделе. Классы не имеют прямой связи между параметрами конструктора, полями и свойствами.

Как и типы Union и Structure, записи имеют семантику структурного равенства. Классы имеют семантику равенства ссылок. Это действие представлено в следующем примере кода:

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1911.fs)]

Результат выполнения этого кода выглядит следующим образом:

```console
The records are equal.
```

Если написать тот же код с классами, то два объекта класса будут неравными, так как два значения будут представлять два объекта в куче и будут сравниваться только адреса (если только тип класса не переопределит `System.Object.Equals` метод).

Если для записей требуется равенство ссылок, добавьте атрибут `[<ReferenceEquality>]` над записью.

## <a name="see-also"></a>См. также раздел

- [Типы языка F#](fsharp-types.md)
- [Классы](classes.md)
- [Справочник по языку F#](index.md)
- [Равенство ссылок](https://msdn.microsoft.com/visualfsharpdocs/conceptual/core.referenceequalityattribute-class-%5bfsharp%5d)
- [Соответствие шаблону](pattern-matching.md)
