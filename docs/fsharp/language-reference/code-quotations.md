---
title: Цитирование кода
description: Сведения о F# цитатах кода, языковой функции, позволяющей программно создавать выражения кода F# и работать с ними.
ms.date: 05/16/2016
ms.openlocfilehash: c6ec0078c685a6452f49edd289b01491dd62e3db
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/30/2019
ms.locfileid: "68630416"
---
# <a name="code-quotations"></a>Цитирование кода

> [!NOTE]
> Ссылка на справочник по API ведет на сайт MSDN.  Работа над справочником по API docs.microsoft.com не завершена.

В этом разделе описываются *цитаты кода*, функции языка, позволяющие программно создавать выражения кода F# и работать с ними. Эта функция позволяет создать абстрактное дерево синтаксиса, представляющее F# код. Затем дерево абстрактного синтаксиса можно просмотреть и обработать в соответствии с потребностями приложения. Например, дерево можно использовать для создания F# кода или создания кода на другом языке.

## <a name="quoted-expressions"></a>Выражения в кавычках

*Выражение* в кавычках — это F# выражение в коде, которое отделяется таким образом, что оно не компилируется как часть программы, а компилируется в объект, представляющий F# выражение. Можно пометить выражение в кавычках одним из двух способов: с информацией о типе или без сведений о типе. Если вы хотите включить сведения о типах, используйте символы `<@` и `@>` для разделения выражения в кавычках. Если сведения о типах не требуются, используются символы `<@@` и. `@@>` В следующем коде показаны типизированные и нетипизированные предложения.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-3/snippet501.fs)]

Обход большого дерева выражения выполняется быстрее, если не включать сведения о типе. Результирующий тип выражения, заключенного в кавычки с типизированными `Expr<'T>`символами, — это, где параметр типа имеет тип выражения, определяемый F# алгоритмом определения типа компилятора. При использовании цитат кода без сведений о типе тип выражения, заключенного в кавычки, является выражением типа, не являющимся универсальным типом [expr](https://msdn.microsoft.com/library/ed6a2caf-69d4-45c2-ab97-e9b3be9bce65). Для получения нетипизированного `Expr` объекта можно вызвать свойство `Expr` [RAW](https://msdn.microsoft.com/library/47fb94f1-e77f-4c68-aabc-2b0ba40d59c2) для типизированного класса.

Существуют разнообразные статические методы, позволяющие программно создавать F# объекты выражений в `Expr` классе без использования заключенных в кавычки выражений.

Обратите внимание, что цитата кода должна включать выражение Complete. Например, для привязки требуется как определение связанного имени, так и дополнительное выражение, использующее привязку. `let` В подробном синтаксисе это выражение, следующее за `in` ключевым словом. На верхнем уровне в модуле это просто следующее выражение в модуле, но в кавычках оно требуется явным образом.

Поэтому следующее выражение является недопустимым.

```fsharp
// Not valid:
// <@ let f x = x + 1 @>
```

Однако следующие выражения являются допустимыми.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-3/snippet502.fs)]

Для вычисления F# предложений необходимо использовать [ F# средство оценки предложений](https://github.com/fsprojects/FSharp.Quotations.Evaluator). Он обеспечивает поддержку оценки и исполнения F# объектов выражений.

## <a name="expr-type"></a>Тип выражения

Экземпляр `Expr` типа представляет F# выражение. Универсальные и неуниверсальные `Expr` типы описаны в документации по F# библиотеке. Дополнительные сведения см. в [статье о пространстве имен Microsoft. FSharp. цитирований](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.quotations-namespace-%5bfsharp%5d) и [предложениях. expr](https://msdn.microsoft.com/visualfsharpdocs/conceptual/quotations.expr-class-%5bfsharp%5d).

## <a name="splicing-operators"></a>Операторы объединения

Объединение позволяет комбинировать цитаты с литеральным кодом с выражениями, созданными программно или из другой цитаты в виде кода. Операторы `%` и `%%` позволяют добавлять объект F# выражения в цитату кода. `%` Оператор используется для вставки объекта типизированного выражения в типизированную кавычку; `%%` оператор используется для вставки нетипизированного объекта выражения в нетипизированное предложение. Оба оператора являются унарными префиксными операторами. Таким образом `expr` , если является нетипизированным выражением `Expr`типа, следующий код является допустимым.

```fsharp
<@@ 1 + %%expr @@>
```

И если `expr` является типизированной кавычкой типа `Expr<int>`, следующий код является допустимым.

```fsharp
<@ 1 + %expr @>
```

## <a name="example"></a>Пример

### <a name="description"></a>Описание

В следующем примере показано использование цитат кода для помещения F# кода в объект выражения, а затем печать F# кода, представляющего выражение. Определена `println` функция, которая содержит рекурсивную `print` функцию, которая отображает объект F# выражения (типа `Expr`) в удобном формате. Существует несколько активных шаблонов в модулях [Microsoft. FSharp. цитирований. Patterns](https://msdn.microsoft.com/library/093944a9-c752-403a-8983-5fcd5dbf92a4) и [Microsoft. FSharp. цитирований. активный шаблон derivedpatterns](https://msdn.microsoft.com/library/d2434a6e-ae7b-4f3d-b567-c162938bc9cd) , которые можно использовать для анализа объектов выражений. Этот пример не включает в себя все возможные закономерности, которые могут отображаться F# в выражении. Любой нераспознанный шаблон активирует совпадение с шаблоном шаблона (`_`) и подготавливается к просмотру `ToString` с помощью метода `Expr` , который в типе позволяет знать активный шаблон для добавления в выражение соответствия.

### <a name="code"></a>Код

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-3/snippet601.fs)]

### <a name="output"></a>Вывод

```fsharp
fun (x:System.Int32) -> x + 1
a + 1
let f = fun (x:System.Int32) -> x + 10 in f 10
```

## <a name="example"></a>Пример

### <a name="description"></a>Описание

Вы также можете использовать три активных шаблона в [модуле експршапе](https://msdn.microsoft.com/library/7685150e-2432-4d39-9338-57292eff18de) для прохода по деревьям выражений с меньшим количеством активных шаблонов. Эти активные шаблоны могут оказаться полезными, если требуется пройти по дереву, но не требуется вся информация в большинстве узлов. При использовании F# этих шаблонов любое выражение соответствует одному из следующих трех шаблонов: `ShapeVar` если выражение является переменной, `ShapeLambda` если выражение является лямбда-выражением, или `ShapeCombination` если выражение является любым другим. Если вы просматриваете дерево выражения с помощью активных шаблонов, как в предыдущем примере кода, необходимо использовать гораздо больше шаблонов для управления всеми возможными F# типами выражений, и код будет более сложен. Дополнительные сведения см. в разделе [експршапе.&#124;Шапевар&#124;шапеламбда шапекомбинатион Active Pattern](https://msdn.microsoft.com/visualfsharpdocs/conceptual/exprshape.shapevarhshapelambdahshapecombination-active-pattern-%5bfsharp%5d).

Следующий пример кода можно использовать в качестве основания для более сложных обходов. В этом коде дерево выражения создается для выражения, включающего вызов функции, `add`. Активный шаблон [спеЦификкалл](https://msdn.microsoft.com/library/05a77b21-20fe-4b9a-8e07-aa999538198d) используется для обнаружения любого вызова `add` в дереве выражения. Этот активный шаблон назначает аргументы вызова `exprList` значения. В этом случае существует только два, поэтому они извлекаются, и функция вызывается рекурсивно для аргументов. Результаты вставляются в цитату кода, которая представляет вызов `mul` с помощью оператора splice (`%%`). `println` Функция из предыдущего примера используется для вывода результатов.

Код в других активных ветвях шаблонов просто повторно создает одно и то же дерево выражения, поэтому единственное изменение в результирующем выражении — это изменение `add` с на. `mul`

### <a name="code"></a>Код

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-3/snippet701.fs)]

### <a name="output"></a>Вывод

```fsharp
1 + Module1.add(2,Module1.add(3,4))
1 + Module1.mul(2,Module1.mul(3,4))
```

## <a name="see-also"></a>См. также

- [Справочник по языку F#](index.md)
