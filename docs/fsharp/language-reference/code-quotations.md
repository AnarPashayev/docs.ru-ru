---
title: Цитирование кода
description: Дополнительные сведения о F# Цитирование кода, — функцию языка, позволяет создавать и работать с F# программного кода выражения.
ms.date: 05/16/2016
ms.openlocfilehash: 464df5e3fafa683c93fd5fb6e94d24c229903491
ms.sourcegitcommit: 8699383914c24a0df033393f55db3369db728a7b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/15/2019
ms.locfileid: "65642002"
---
# <a name="code-quotations"></a>Цитирование кода

> [!NOTE]
> Ссылка на справочник по API ведет на сайт MSDN.  Работа над справочником по API docs.microsoft.com не завершена.

В этом разделе описывается *кавычки кода*, — функцию языка, позволяет создавать и работать с F# программного кода выражения. Эта функция позволяет создавать дерево абстрактного синтаксиса, которое представляет F# кода. Дерево абстрактного синтаксиса можно просматривать и обрабатываются в соответствии с требованиями приложения. Например, можно использовать для создания дерева F# кода или кода на другом языке.

## <a name="quoted-expressions"></a>Цитируемые выражения

Объект *заключено в кавычки выражение* — F# выражение в коде, в качестве разделителя используется таким образом, что оно не компилируется как часть программы, а компилируется в объект, представляющий F# выражение. Вы можете пометить заключенные в кавычки выражения в одном из двух способов: с помощью сведений о типе или без сведений о типе. Если вы хотите включить сведения о типе, можно использовать символы `<@` и `@>` для разделения заключенные в кавычки выражения. Если сведения о типе не требуется, можно использовать символы `<@@` и `@@>`. В следующем коде показано типизированные и нетипизированные цитаты.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet501.fs)]

Обход большого дерева выражения выполняется быстрее, если не включать сведения о типе. Результирующий тип выражения в кавычках символами является `Expr<'T>`, где параметр типа имеет тип выражения определяется F# алгоритма вывода компилятора. При использовании Цитирование кода без сведений о типе, тип указанного выражения — неуниверсального типа [Expr](https://msdn.microsoft.com/library/ed6a2caf-69d4-45c2-ab97-e9b3be9bce65). Можно вызвать [Raw](https://msdn.microsoft.com/library/47fb94f1-e77f-4c68-aabc-2b0ba40d59c2) свойство типизированного `Expr` для получения нетипизированное `Expr` объекта.

Существуют разнообразные статические методы, которые позволяют создавать F# выражения объектов в обработчике `Expr` выражения, содержащие класс без использования.

Обратите внимание на то, что цитату кода должен включать полное выражение. Для `let` привязки, например, требуется как определение имени привязки и дополнительное выражение, которое использует эту привязку. В подробном синтаксисе это выражение, следующее за `in` ключевое слово. На верхнем уровне в модуле это просто следующее выражение в модуле, но в предложение, это явно не требуется.

Таким образом следующее выражение не является допустимым.

```fsharp
// Not valid:
// <@ let f x = x + 1 @>
```

Но следующие выражения являются допустимыми.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet502.fs)]

Чтобы использовать Цитирование кода, необходимо добавить объявление импорта (с помощью `open` ключевое слово), открывает [Microsoft.FSharp.Quotations](https://msdn.microsoft.com/library/e9ce8a3a-e00c-4190-bad5-cce52ee089b2) пространства имен.

F# PowerPack обеспечивает поддержку для вычисления и выполнения F# объекты выражений.

## <a name="expr-type"></a>Тип expr

Экземпляр `Expr` тип представленного F# выражение. Универсальные и неуниверсальные `Expr` типы описаны в F# библиотеки документов. Дополнительные сведения см. в разделе [имен Microsoft.FSharp.Quotations](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.quotations-namespace-%5bfsharp%5d) и [класс Quotations.Expr](https://msdn.microsoft.com/visualfsharpdocs/conceptual/quotations.expr-class-%5bfsharp%5d).

## <a name="splicing-operators"></a>Операторы объединения

Объединение позволяет объединять литеральные цитаты кода с выражениями, которые вы создали программным способом или из другого цитату кода. `%` И `%%` операторы позволяют добавлять F# объект выражения в цитату кода. Использовании `%` оператор для вставки объекта типизированного выражения в типизированную цитату; вам использовать `%%` оператор для вставки объекта нетипизированного выражения в нетипизированную цитату. Оба оператора, префикс унарные операторы. Поэтому если `expr` является нетипизированным выражением типа `Expr`, следующий код является допустимым.

```fsharp
<@@ 1 + %%expr @@>
```

И если `expr` является типизированным предложения типа `Expr<int>`, следующий код является допустимым.

```fsharp
<@ 1 + %expr @>
```

## <a name="example"></a>Пример

### <a name="description"></a>Описание

Следующий пример иллюстрирует использование Цитирование кода для помещения F# код в объект выражения, а затем распечатать F# кода, который представляет выражение. Функция `println` определяется, содержащий рекурсивной функции `print` , отображающий F# объект выражения (типа `Expr`) в удобном формате. Существует несколько активных шаблонов в [Microsoft.FSharp.Quotations.Patterns](https://msdn.microsoft.com/library/093944a9-c752-403a-8983-5fcd5dbf92a4) и [Microsoft.FSharp.Quotations.DerivedPatterns](https://msdn.microsoft.com/library/d2434a6e-ae7b-4f3d-b567-c162938bc9cd) модули, которые могут быть использованы для анализа объектов выражений. В этом примере не включает все возможные шаблоны, которые могут отображаться в F# выражение. Любой нераспознанный шаблон вызывает сопоставления Шаблон подстановочного знака (`_`) и обрабатывается с помощью `ToString` метод, который, в `Expr` введите позволяет узнать активный шаблон для добавления в выражение match.

### <a name="code"></a>Код

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet601.fs)]

### <a name="output"></a>Вывод

```fsharp
fun (x:System.Int32) -> x + 1
a + 1
let f = fun (x:System.Int32) -> x + 10 in f 10
```

## <a name="example"></a>Пример

### <a name="description"></a>Описание

Также можно использовать три активные шаблоны в [ExprShape-модуль](https://msdn.microsoft.com/library/7685150e-2432-4d39-9338-57292eff18de) для обхода деревьев выражений с меньшим количеством активных шаблонов. Эти активные шаблоны можно использовать, когда требуется переход по дереву, но не обязательно вся информация содержится в большинство узлов. При использовании этих шаблонов, любое F# выражения совпадает с одним из следующих трех шаблонов: `ShapeVar` Если выражение является переменной, `ShapeLambda` Если выражение является лямбда-выражения, или `ShapeCombination` Если выражение является что-нибудь еще. Если обход дерева выражения с помощью активные шаблоны как в предыдущем примере кода, необходимо использовать многие другие шаблоны все возможные F# типов выражений и ваш код будет более сложной. Дополнительные сведения см. в разделе [ExprShape.ShapeVar&#124;ShapeLambda&#124;ShapeCombination-активный шаблон](https://msdn.microsoft.com/visualfsharpdocs/conceptual/exprshape.shapevarhshapelambdahshapecombination-active-pattern-%5bfsharp%5d).

В следующем примере кода можно использовать в качестве основы для более сложных обходов. В этом коде создается дерево выражений для выражения, содержащего вызов функции `add`. [SpecificCall](https://msdn.microsoft.com/library/05a77b21-20fe-4b9a-8e07-aa999538198d) активный шаблон используется для обнаружения всех вызовов функции `add` в дереве выражения. Это активный шаблон присваивает аргументы вызова `exprList` значение. В этом случае существует только два, поэтому они извлекаются и функция вызывается рекурсивно на аргументы. Результаты вставляются в цитату кода, который представляет вызов `mul` с помощью оператора объединения (`%%`). `println` Функция из предыдущего примера используется для отображения результатов.

Код в других ветвях активный шаблон просто заново создает это же дерево выражения, поэтому единственное изменение в результирующем выражении является замена `add` для `mul`.

### <a name="code"></a>Код

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet701.fs)]

### <a name="output"></a>Вывод

```fsharp
1 + Module1.add(2,Module1.add(3,4))
1 + Module1.mul(2,Module1.mul(3,4))
```

## <a name="see-also"></a>См. также

- [Справочник по языку F#](index.md)
