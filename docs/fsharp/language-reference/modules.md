---
title: Модули
description: 'Сведения о том, как модуль F # представляет собой Группирование кода F #, такого как значения, типы и значения функций, в программе F #.'
ms.date: 04/24/2017
ms.openlocfilehash: 5f99bbd8069478bf0c7db2800ae545f31926728a
ms.sourcegitcommit: de7f589de07a9979b6ac28f54c3e534a617d9425
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/05/2020
ms.locfileid: "82794368"
---
# <a name="modules"></a>Модули

В контексте языка F # *модуль* представляет собой Группирование кода f #, такого как значения, типы и значения функций, в программе F #. Код группирования в модулях объединяет связанный код и помогает избежать конфликтов имен в программе.

## <a name="syntax"></a>Синтаксис

```fsharp
// Top-level module declaration.
module [accessibility-modifier] [qualified-namespace.]module-name
declarations
// Local module declaration.
module [accessibility-modifier] module-name =
    declarations
```

## <a name="remarks"></a>Remarks

Модуль F # представляет собой группирование конструкций кода F #, таких как типы, значения, значения функций и код в `do` привязках. Он реализуется как класс среды CLR, имеющий только статические члены. Существует два типа объявлений модулей в зависимости от того, включен ли в модуль весь файл: объявление модуля верхнего уровня и объявление локального модуля. Объявление модуля верхнего уровня включает в себя весь файл в модуле. Объявление модуля верхнего уровня может использоваться только в качестве первого объявления в файле.

В синтаксисе объявления модуля верхнего уровня необязательное *полное-пространство имен* — это последовательность вложенных имен пространств имен, содержащих модуль. Полное имя пространства имен не обязательно должно быть объявлено ранее.

Добавлять отступы в модуль верхнего уровня не требуется. Необходимо задать отступ для всех объявлений в локальных модулях. В объявлении локального модуля только объявления, имеющие отступ под этим объявлением модуля, являются частью модуля.

Если файл кода не начинается с объявления модуля верхнего уровня или объявления пространства имен, все содержимое файла, включая все локальные модули, станет частью неявно созданного модуля верхнего уровня, который имеет то же имя, что и файл, без расширения с первой буквой, преобразованной в верхний регистр. Например, рассмотрим следующий файл.

[!code-fsharp[Main](~/samples/snippets/fsharp/modules/snippet6601.fs)]

Этот файл будет скомпилирован так, как если бы он был написан таким образом:

[!code-fsharp[Main](~/samples/snippets/fsharp/modules/snippet6602.fs)]

Если в файле имеется несколько модулей, необходимо использовать локальное объявление модуля для каждого модуля. Если объявлено включающее пространство имен, эти модули являются частью включающего пространства имен. Если включающее пространство имен не объявлено, модули становятся частью неявно созданного модуля верхнего уровня. В следующем примере кода показан файл кода, содержащий несколько модулей. Компилятор неявно создает модуль верхнего уровня с именем `Multiplemodules`, и `MyModule1` и `MyModule2` вложены в этот модуль верхнего уровня.

[!code-fsharp[Main](~/samples/snippets/fsharp/modules/snippet6603.fs)]

При наличии нескольких файлов в проекте или в одной компиляции или при построении библиотеки необходимо включить объявление пространства имен или объявление модуля в начало файла. Компилятор F # определяет имя модуля неявным образом, если в проекте или в командной строке компиляции имеется только один файл, и создается приложение.

*Модификатором Accessibility* может быть один из следующих: `public`, `private`,. `internal` Дополнительные сведения см. в статье [Управление доступом](access-control.md). Значение по умолчанию: public.

## <a name="referencing-code-in-modules"></a>Ссылка на код в модулях

При ссылке на функции, типы и значения из другого модуля необходимо либо использовать полное имя, либо открыть модуль. При использовании полного имени необходимо указать пространства имен, модуль и идентификатор нужного элемента программы. Каждая часть полного пути разделяются точкой (.), как показано ниже.

`Namespace1.Namespace2.ModuleName.Identifier`

Чтобы упростить код, можно открыть модуль или одно или несколько пространств имен. Дополнительные сведения об открытии пространств имен и модулей см. [в `open` разделе Импорт объявлений: ключевое слово](import-declarations-the-open-keyword.md).

В следующем примере кода показан модуль верхнего уровня, содержащий весь код до конца файла.

[!code-fsharp[Main](~/samples/snippets/fsharp/modules/snippet6604.fs)]

Чтобы использовать этот код из другого файла в том же проекте, необходимо либо использовать полные имена, либо открыть модуль перед использованием функций, как показано в следующих примерах.

[!code-fsharp[Main](~/samples/snippets/fsharp/modules/snippet6605.fs)]

## <a name="nested-modules"></a>Вложенные модули

Модули могут быть вложенными. Внутренние модули должны быть с отступом до объявлений внешних модулей, чтобы указать, что они являются внутренними модулями, а не новыми модулями. Например, Сравните следующие два примера. Модуль `Z` является внутренним модулем в следующем коде.

[!code-fsharp[Main](~/samples/snippets/fsharp/modules/snippet6607.fs)]

Но модуль `Z` является родственным для модуля `Y` в следующем коде.

[!code-fsharp[Main](~/samples/snippets/fsharp/modules/snippet6608.fs)]
Модуль `Z` также является родственным модулем в следующем коде, так как он не имеет отступов, чем другие объявления в модуле `Y`.

[!code-fsharp[Main](~/samples/snippets/fsharp/modules/snippet6609.fs)]
Наконец, если внешний модуль не имеет объявлений и за ним сразу же поступает объявление другого модуля, то новое объявление модуля считается внутренним модулем, но компилятор выдаст предупреждение, если второе определение модуля не имеет отступа дальше, чем первый.

[!code-fsharp[Main](~/samples/snippets/fsharp/modules/snippet6610.fs)]
Чтобы устранить это предупреждение, помещает внутренний модуль в отступ.

[!code-fsharp[Main](~/samples/snippets/fsharp/modules/snippet6611.fs)]
Если требуется, чтобы весь код в файле настроился в одном внешнем модуле и вы хотели использовать внутренние модули, внешний модуль не требует знака равенства, а объявления, включая любые внутренние объявления модулей, которые будут находиться во внешнем модуле, не должны иметь отступов. Объявления внутри внутренних объявлений модуля должны иметь отступы. Этот случай показан в следующем коде.

[!code-fsharp[Main](~/samples/snippets/fsharp/modules/snippet6612.fs)]

## <a name="recursive-modules"></a>Рекурсивные модули

В F # 4,1 введено понятие модулей, которые позволяют взаимно рекурсивно выполнять весь автономный код.  Это делается с помощью `module rec`.  Использование служб `module rec` может сократить некоторые трудности, не позволяя писать взаимно ссылочный код между типами и модулями.  Ниже приведен пример.

```fsharp
module rec RecursiveModule =
    type Orientation = Up | Down
    type PeelState = Peeled | Unpeeled

    // This exception depends on the type below.
    exception DontSqueezeTheBananaException of Banana

    type Banana(orientation : Orientation) =
        member val IsPeeled = false with get, set
        member val Orientation = orientation with get, set
        member val Sides: PeelState list = [ Unpeeled; Unpeeled; Unpeeled; Unpeeled] with get, set

        member self.Peel() = BananaHelpers.peel self // Note the dependency on the BananaHelpers module.
        member self.SqueezeJuiceOut() = raise (DontSqueezeTheBananaException self) // This member depends on the exception above.

    module BananaHelpers =
        let peel (b: Banana) =
            let flip (banana: Banana) =
                match banana.Orientation with
                | Up ->
                    banana.Orientation <- Down
                    banana
                | Down -> banana

            let peelSides (banana: Banana) =
                banana.Sides
                |> List.map (function
                             | Unpeeled -> Peeled
                             | Peeled -> Peeled)

            match b.Orientation with
            | Up ->   b |> flip |> peelSides
            | Down -> b |> peelSides
```

Обратите внимание, `DontSqueezeTheBananaException` что исключение и `Banana` класс ссылаются друг на друга.  Кроме того, модуль `BananaHelpers` и класс `Banana` также ссылаются друг на друга.  Если вы удалили `rec` ключевое слово из модуля, `RecursiveModule` это невозможно будет сделать в F #.

Эта возможность также возможна в [пространствах имен](namespaces.md) с F # 4,1.

## <a name="see-also"></a>См. также раздел

- [Справочник по языку F #](index.md)
- [Пространства имен](namespaces.md)
- [F # RFC FS-1009-разрешить взаимно ссылочные типы и модули в более крупных областях внутри файлов](https://github.com/fsharp/fslang-design/blob/master/FSharp-4.1/FS-1009-mutually-referential-types-and-modules-single-scope.md)
