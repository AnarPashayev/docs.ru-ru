---
title: Автоматическое обобщение
description: Узнайте, как F# автоматически обобщаются аргументы и типы функций, чтобы они работали с несколькими типами, когда это возможно.
ms.date: 05/16/2016
ms.openlocfilehash: 15ecf8e6f07da19bb015fd028a7465ba8b837190
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61937544"
---
# <a name="automatic-generalization"></a>Автоматическое обобщение

F#Определение, оценка типов функций и выражений типа использует. Здесь описывается, как F# автоматически обобщаются аргументы и типы функций, чтобы они работают с несколькими типами, если это возможно.

## <a name="automatic-generalization"></a>Автоматическое обобщение

F# Компилятора, когда он выполняет вывод типа для функции, определяет ли данного параметра могут быть универсальными. Компилятор проверяет каждый параметр и определяет, имеет ли функция зависимость от конкретного типа этого параметра. Если этого не произошло, тип выводится как универсальный.

В следующем примере кода показана функция, компилятор выводит быть универсальными.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-3/snippet101.fs)]

Тип определяется как `'a -> 'a -> 'a`.

Тип указывает, что это функция, которая принимает два аргумента же неизвестного типа и возвращает значение того же типа. Одной из причин, которые могут быть предыдущую функцию универсального —, больше-оператор «больше» (`>`) сам является универсальным. Больше-оператор имеет сигнатуру, чем `'a -> 'a -> bool`. Не все операторы являются универсальными, и если код в функции использует тип параметра вместе с неуниверсальных функций или оператор, такой тип параметра не удается подготовить к использованию.

Так как `max` является универсальным, он может использоваться с типами например `int`, `float`, и так далее, как показано в следующих примерах.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-3/snippet102.fs)]

Тем не менее двух аргументов должен быть того же типа. Подпись является `'a -> 'a -> 'a`, а не `'a -> 'b -> 'a`. Таким образом для следующего кода создается ошибка, так как типы не совпадают.

```fsharp
// Error: type mismatch.
let biggestIntFloat = max 2.0 3
```

`max` Функция также работает с любым типом, который поддерживает больше-оператор «больше». Таким образом можно также использовать его в строке, как показано в следующем коде.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-3/snippet104.fs)]

## <a name="value-restriction"></a>Ограничение значения

Компилятор выполняет Автоматическое обобщение только для полных определений функций, которые имеют явные аргументы и для простых постоянных значений.

Это означает, что компилятор выдает ошибку при попытке скомпилировать код, достаточно не обязательно должен быть определенного типа, но не также обобщению. Сообщение об ошибке для этой проблемы ссылается на это ограничение на Автоматическое обобщение для значения, что *ограничение значения*.

Как правило ошибки ограничения значений происходит, если требуется, чтобы конструкцию как универсальный, но компилятор не получает достаточно информации, чтобы обобщить его или при достаточной информации о типе в неуниверсальной конструкции непреднамеренно опускаются. Решения для ошибки ограничения значений — для предоставления более явную информацию для более полного устранения проблемы вывода типа, в одном из следующих способов:

- Сделайте тип неуниверсальным, добавив заметку явный тип значения или параметра.

- Если проблемы с помощью конструкции необобщаемой для определения универсальной функции, такие как объединения функций или неполностью примененных каррированных аргументов, попробуйте переписать эту функцию определение обычной функции.

- Если проблема заключается выражение, которое слишком сложен, чтобы подготовить к использованию, когда-нибудь функцию, добавив дополнительный неиспользуемый параметр.

- Добавьте параметры явной универсального типа. Этот параметр используется редко.

- В следующих примерах кода демонстрируется каждый из этих сценариев.

Вариант 1. Слишком сложное выражение. В этом примере список `counter` должен быть `int option ref`, но он не определен как простое постоянное значение.

```fsharp
let counter = ref None
// Adding a type annotation fixes the problem:
let counter : int option ref = ref None
```

Вариант 2. Использование необобщаемой конструкции для задания универсальной функции. В этом примере конструкция является необобщаемой, так как он содержит частичного применения аргументов функции.

```fsharp
let maxhash = max << hash
// The following is acceptable because the argument for maxhash is explicit:
let maxhash obj = (max << hash) obj
```

Вариант 3. Добавление дополнительного неиспользуемого параметра. Поскольку это выражение не является достаточно простым для обобщения, компилятор выдает ошибку ограничения значения.

```fsharp
let emptyList10 = Array.create 10 []
// Adding an extra (unused) parameter makes it a function, which is generalizable.
let emptyList10 () = Array.create 10 []
```

Вариант 4. Добавление параметров типа.

```fsharp
let arrayOf10Lists = Array.create 10 []
// Adding a type parameter and type annotation lets you write a generic value.
let arrayOf10Lists<'T> = Array.create 10 ([]:'T list)
```

В последнем случае значение становится тип функции, который может использоваться для создания значения разных типов, например следующим образом:

```fsharp
let intLists = arrayOf10Lists<int>
let floatLists = arrayOf10Lists<float>
```

## <a name="see-also"></a>См. также

- [Вывод типа](../type-inference.md)
- [Универсальные шаблоны](index.md)
- [Статически разрешаемые параметры типов](statically-resolved-type-parameters.md)
- [Ограничения](constraints.md)