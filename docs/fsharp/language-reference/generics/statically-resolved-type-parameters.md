---
title: Статически разрешаемые параметры типов
description: Узнайте, как использовать F# статически разрешаемый параметр типа, который заменяется фактическим типом во время компиляции, а не во время выполнения.
ms.date: 05/16/2016
ms.openlocfilehash: 017c18dd3caaa484ddc653557573f548e3224ca0
ms.sourcegitcommit: 14ad34f7c4564ee0f009acb8bfc0ea7af3bc9541
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/01/2019
ms.locfileid: "73425001"
---
# <a name="statically-resolved-type-parameters"></a>Статически разрешаемые параметры типов

*Статически разрешаемый параметр типа* — это параметр типа, который заменяется фактическим типом во время компиляции, а не во время выполнения. Им предшествует символ каретки (^).

## <a name="syntax"></a>Синтаксис

```fsharp
ˆtype-parameter
```

## <a name="remarks"></a>Заметки

На F# языке существует два различных вида параметров типа. Первый тип является стандартным параметром универсального типа. Они обозначены апострофом ('), как в `'T` и `'U`. Они эквивалентны параметрам универсального типа в других .NET Framework языках. Другой тип является статически разрешаемым и обозначается символом курсора, как в `^T` и `^U`.

Статически разрешаемые параметры типа в первую очередь полезны в сочетании с ограничениями элементов, которые являются ограничениями, позволяющими указать, что аргумент типа должен иметь определенный элемент или элементы для использования. Невозможно создать этот тип ограничения с помощью обычного параметра универсального типа.

В следующей таблице перечислены сходства и различия между двумя типами параметров типа.

|Возможность|Универсальный|Статическое разрешение|
|-------|-------|-------------------|
|Синтаксис|`'T`, `'U`|`^T`, `^U`|
|Время разрешения|Выполнение|Время компиляции|
|Ограничения элементов|Не может использоваться с ограничениями элементов.|Может использоваться с ограничениями элементов.|
|Создание кода|Тип (или метод) со стандартными параметрами универсального типа приводит к созданию одного универсального типа или метода.|Создается несколько экземпляров типов и методов, по одному для каждого требуемого типа.|
|Использование с типами|Может использоваться для типов.|Не может использоваться для типов.|
|Использование со встроенными функциями|Номер Встроенная функция не может быть параметризована со стандартным параметром универсального типа.|Да. Статически разрешаемые параметры типа нельзя использовать в функциях и методах, которые не являются встроенными.|

Многие F# функции основной библиотеки, в частности, операторы, имеют статически разрешаемые параметры типа. Эти функции и операторы являются встроенными и приводят к эффективному созданию кода для числовых вычислений.

Встроенные методы и функции, использующие операторы, или другие функции, которые имеют статически разрешаемые параметры типа, также могут использовать статически разрешаемые параметры типа. Как правило, вывод типа выводит такие встроенные функции в статически разрешаемые параметры типа. В следующем примере показано определение оператора, для которого определен статически разрешаемый параметр типа.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-3/snippet401.fs)]

Разрешенный тип `(+@)` основан на использовании как `(+)`, так и `(*)`, оба из которых вызывают определение типа для определения ограничений членов в статически разрешаемых параметрах типа. Разрешенный тип, как показано в F# интерпретаторе, выглядит следующим образом.

```fsharp
^a -> ^c -> ^d
when (^a or ^b) : (static member ( + ) : ^a * ^b -> ^d) and
(^a or ^c) : (static member ( * ) : ^a * ^c -> ^b)
```

Выходные данные выглядят следующим образом.

```console
2
1.500000
```

Начиная с F# 4,1, можно также указать конкретные имена типов в статически разрешаемых сигнатурах параметров типа.  В предыдущих версиях языка имя типа может быть выделено компилятором, но фактически не может быть указано в сигнатуре.  Начиная с F# 4,1 можно также указать конкретные имена типов в статически разрешаемых сигнатурах параметров типа. Ниже приведен пример:

```fsharp
let inline konst x _ = x

type CFunctor() =
    static member inline fmap (f: ^a -> ^b, a: ^a list) = List.map f a
    static member inline fmap (f: ^a -> ^b, a: ^a option) =
        match a with
        | None -> None
        | Some x -> Some (f x)

    // default implementation of replace
    static member inline replace< ^a, ^b, ^c, ^d, ^e when ^a :> CFunctor and (^a or ^d): (static member fmap: (^b -> ^c) * ^d -> ^e) > (a, f) =
        ((^a or ^d) : (static member fmap : (^b -> ^c) * ^d -> ^e) (konst a, f))

    // call overridden replace if present
    static member inline replace< ^a, ^b, ^c when ^b: (static member replace: ^a * ^b -> ^c)>(a: ^a, f: ^b) =
        (^b : (static member replace: ^a * ^b -> ^c) (a, f))

let inline replace_instance< ^a, ^b, ^c, ^d when (^a or ^c): (static member replace: ^b * ^c -> ^d)> (a: ^b, f: ^c) =
        ((^a or ^c): (static member replace: ^b * ^c -> ^d) (a, f))

// Note the concrete type 'CFunctor' specified in the signature
let inline replace (a: ^a) (f: ^b): ^a0 when (CFunctor or  ^b): (static member replace: ^a *  ^b ->  ^a0) =
    replace_instance<CFunctor, _, _, _> (a, f)
```

## <a name="see-also"></a>См. также

- [Универсальные шаблоны](index.md)
- [Вывод типа](../type-inference.md)
- [Автоматическое обобщение](automatic-generalization.md)
- [Ограничения](constraints.md)
- [Встраиваемые функции](../functions/inline-functions.md)
