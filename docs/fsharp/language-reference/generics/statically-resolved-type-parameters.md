---
title: Статически разрешаемые параметры типов
description: Сведения об использовании F# статически разрешаемым параметром типа, который заменяется фактическим типом во время компиляции, а не во время выполнения.
ms.date: 05/16/2016
ms.openlocfilehash: 9ad23a881e644dfe2bccd56fa04d3c219b51cf7d
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61937492"
---
# <a name="statically-resolved-type-parameters"></a>Статически разрешаемые параметры типов

Объект *статически разрешаемым параметром типа* является параметром типа, который заменяется фактическим типом во время компиляции, а не во время выполнения. Перед ними присутствует символ крышки (^).

## <a name="syntax"></a>Синтаксис

```
ˆtype-parameter
```

## <a name="remarks"></a>Примечания

В F# языка, существует два вида параметров типа. Первый тип — стандартным параметром универсального типа. Они обозначаются с помощью апострофа ('), как показано на `'T` и `'U`. Они эквивалентны параметров универсального типа в других языках .NET Framework. Другой вид является статически разрешаемым и обозначается символом крышки, как показано на `^T` и `^U`.

Статически разрешаемые параметры типа, в основном используются в связи с ограничениями членов, которые являются ограничения, которые позволяют пользователю указать, что аргумент типа должен иметь определенный элемент или элементы для использования. Нет способа для создания такого рода ограничение с помощью параметра регулярных универсального типа.

В следующей таблице перечислены сходства и различия между двумя типами параметров типа.

|Функция|Универсальный|Статически разрешаемые|
|-------|-------|-------------------|
|Синтаксис|`'T`, `'U`|`^T`, `^U`|
|Время разрешения|Выполнение|Время компиляции|
|Ограничения члена|Не может использоваться с ограничениями членов.|Может использоваться с ограничениями членов.|
|Создание кода|Тип (или метод) со стандартными параметрами универсального типа приводит к формированию, одного универсального типа или метода.|Создаются несколько экземпляров типов и методов, он будет необходим для каждого типа.|
|Использовать с типами|Можно применять к типам.|Нельзя применять к типам.|
|Использование со встроенными функциями|Нет. Встроенная функция не могут быть параметризованы с параметром standard универсального типа.|Да. Статически разрешаемые параметры типа нельзя применять к функции или методы, не являющиеся встроенными.|

Многие F# основных функций библиотеки, особенно операторы, статически разрешаемые параметры типов. Эти функции и операторы в строке и привести к созданию эффективного кода для численных вычислений.

Встроенные методы и функции, которые используют операторы или использовать другие функции, которые статически разрешаемые параметры типов, также могут использовать статически разрешаемые параметры типа самостоятельно. Часто такие встроенные функции, имеющие статически разрешаемые параметры типа определяются вывод типа. В следующем примере показано определение оператора, логически распознается статически разрешаемым параметром типа.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-3/snippet401.fs)]

Разрешенный тип `(+@)` основан на использование обоих `(+)` и `(*)`, обе из чему вывод типа ограничениям членов на статически разрешаемые параметры типа. Разрешенный тип, как показано в F# интерпретатор, выглядит следующим образом.

```fsharp
^a -> ^c -> ^d
when (^a or ^b) : (static member ( + ) : ^a * ^b -> ^d) and
(^a or ^c) : (static member ( * ) : ^a * ^c -> ^b)
```

Выходные данные выглядят следующим образом.

```
2
1.500000
```

Начиная с F# 4.1, можно также указать имена конкретный тип в статически разрешенный тип параметра сигнатуры.  В предыдущих версиях языка имя типа могут быть выведены фактически компилятором, но фактически не удается задать в сигнатуре.  Начиная с версии F# 4.1, можно также указать имена конкретный тип в статически разрешенный тип параметра сигнатуры. Ниже приведен пример:

```fsharp
let inline konst x _ = x

type CFunctor() = 
    static member inline fmap (f: ^a -> ^b, a: ^a list) = List.map f a
    static member inline fmap (f: ^a -> ^b, a: ^a option) =
        match a with
        | None -> None
        | Some x -> Some (f x)

    // default implementation of replace
    static member inline replace< ^a, ^b, ^c, ^d, ^e when ^a :> CFunctor and (^a or ^d): (static member fmap: (^b -> ^c) * ^d -> ^e) > (a, f) =
        ((^a or ^d) : (static member fmap : (^b -> ^c) * ^d -> ^e) (konst a, f))

    // call overridden replace if present
    static member inline replace< ^a, ^b, ^c when ^b: (static member replace: ^a * ^b -> ^c)>(a: ^a, f: ^b) =
        (^b : (static member replace: ^a * ^b -> ^c) (a, f))

let inline replace_instance< ^a, ^b, ^c, ^d when (^a or ^c): (static member replace: ^b * ^c -> ^d)> (a: ^b, f: ^c) =
        ((^a or ^c): (static member replace: ^b * ^c -> ^d) (a, f))

// Note the concrete type 'CFunctor' specified in the signature
let inline replace (a: ^a) (f: ^b): ^a0 when (CFunctor or  ^b): (static member replace: ^a *  ^b ->  ^a0) =
    replace_instance<CFunctor, _, _, _> (a, f)
```

## <a name="see-also"></a>См. также

- [Универсальные шаблоны](index.md)
- [Вывод типа](../type-inference.md)
- [Автоматическое обобщение](automatic-generalization.md)
- [Ограничения](constraints.md)
- [Встраиваемые функции](../functions/inline-functions.md)