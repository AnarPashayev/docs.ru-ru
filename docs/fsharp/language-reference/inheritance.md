---
title: Наследование
description: Узнайте, как указать отношения наследования F,s, используя ключевое слово «наследовать».
ms.date: 05/16/2016
ms.openlocfilehash: 5ab891a93528427a66e4eb8f7bfeccbf6e4d2c7e
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401133"
---
# <a name="inheritance"></a>Наследование

Наследование используется для моделирования отношений «is-a» или субтипирования в объектно-ориентированном программировании.

## <a name="specifying-inheritance-relationships"></a>Определение отношений к наследству

Вы указываете отношения `inherit` наследования, используя ключевое слово в декларации класса. Основная синтаксическая форма показана в следующем примере.

```fsharp
type MyDerived(...) =
    inherit MyBase(...)
```

Класс может иметь не более одного прямого базового класса. Если вы не указали базовый `inherit` класс с помощью ключевого `System.Object`слова, класс косвенно наследует от .

## <a name="inherited-members"></a>Унаследованные элементы

Если класс наследует от другого класса, методы и члены базового класса доступны пользователям производных классов, как если бы они были прямыми членами производного класса.

Любые привязки и параметры конструктора являются частными для класса и, следовательно, не могут быть доступны из производных классов.

Ключевое `base` слово доступно в производных классах и относится к экземпляру базового класса. Он используется как самоижденитель.

## <a name="virtual-methods-and-overrides"></a>Виртуальные методы и переопределения

Виртуальные методы (и свойства) работают несколько иначе в F-по сравнению с другими языками .NET. Чтобы объявить нового виртуального `abstract` участника, вы используете ключевое слово. Вы делаете это независимо от того, предоставляете ли вы реализацию по умолчанию для этого метода. Таким образом, полное определение виртуального метода в базовом классе следует этому шаблону:

```fsharp
abstract member [method-name] : [type]

default [self-identifier].[method-name] [argument-list] = [method-body]
```

И в производном классе переопределение этого виртуального метода следует этому шаблону:

```fsharp
override [self-identifier].[method-name] [argument-list] = [method-body]
```

Если вы не сможете пропустить реализацию по умолчанию в базовом классе, базовый класс становится абстрактным классом.

Следующий пример кода иллюстрирует объявление нового `function1` виртуального метода в базовом классе и способпереть переопределить его в производном классе.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2601.fs)]

## <a name="constructors-and-inheritance"></a>Конструкторы и наследование

Конструктор для базового класса должен быть вызван в производный класс. Аргументы для конструктора базового класса отображаются в списке аргументов в предложении. `inherit` Используемые значения должны определяться на основе аргументов, поставляемых на выводимый класс.

Следующий код показывает базовый класс и производный класс, где полученный класс называет конструктора базового класса в пункте наследования:

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2602.fs)]

В случае нескольких конструкторов можно использовать следующий код. Первая строка выводимых конструкторов `inherit` класса — это положение, а поля `val` отображаются как явные поля, объявленные ключевым словом. Для получения дополнительной информации [см. `val` ](./members/explicit-fields-the-val-keyword.md)

```fsharp
type BaseClass =
    val string1 : string
    new (str) = { string1 = str }
    new () = { string1 = "" }

type DerivedClass =
    inherit BaseClass

    val string2 : string
    new (str1, str2) = { inherit BaseClass(str1); string2 = str2 }
    new (str2) = { inherit BaseClass(); string2 = str2 }

let obj1 = DerivedClass("A", "B")
let obj2 = DerivedClass("A")
```

## <a name="alternatives-to-inheritance"></a>Альтернативы наследованию

В тех случаях, когда требуется незначительное изменение типа, рассмотрите возможность использования выражения объекта в качестве альтернативы наследству. Следующий пример иллюстрирует использование выражения объекта в качестве альтернативы созданию нового производного типа:

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2603.fs)]

Для получения дополнительной информации [Object Expressions](object-expressions.md)о выражениях объектов см.

При создании иерархии объектов рассмотрите возможность использования дискриминируемого соединения вместо наследования. Дискриминированные союзы могут также моделировать разнообразное поведение различных объектов, которые имеют общий общий тип. Один дискриминируемый союз часто может устранить необходимость в ряде производных классов, которые являются незначительными вариациями друг друга. Для получения информации о дискриминируемых профсоюзах [см.](discriminated-unions.md)

## <a name="see-also"></a>См. также раздел

- [Выражения объекта](object-expressions.md)
- [Ссылка на язык F](index.md)
