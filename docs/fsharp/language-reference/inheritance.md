---
title: Наследование
description: Сведения об указании F# связи наследования с помощью ключевого слова «наследовать».
ms.date: 05/16/2016
ms.openlocfilehash: 775ee52039caf4c4ab65f82fa21d4e536135a12a
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61937466"
---
# <a name="inheritance"></a>Наследование

Наследование используется для моделирования отношения «is-a», или подтипов в объектно ориентированного программирования.

## <a name="specifying-inheritance-relationships"></a>Определение отношений наследования

Определить отношения наследования с помощью `inherit` ключевое слово в объявлении класса. В следующем примере показан базовый синтаксическая форма.

```fsharp
type MyDerived(...) =
    inherit MyBase(...)
```

Класс может иметь не более одного прямого базового класса. Если вы не укажете базового класса с помощью `inherit` ключевое слово, неявно наследуется от `System.Object`.

## <a name="inherited-members"></a>Унаследованные члены

Если класс наследует от другого класса, методы и члены базового класса доступны пользователям производного класса как будто они являются непосредственными членами производного класса.

Все привязки let и параметры конструктора являются закрытыми для класса и, таким образом, нельзя обращаться из производных классов.

Ключевое слово `base` доступно в производных классах и относится к экземпляру базового класса. Он используется как идентификатор самого себя.

## <a name="virtual-methods-and-overrides"></a>Виртуальные методы и переопределений

Виртуальные методы (и свойства) работают немного по-разному в F# по сравнению с другими языками .NET. Чтобы объявить новый виртуальный член, следует использовать `abstract` ключевое слово. Это можно сделать независимо от того, может ли предоставлять реализацию по умолчанию для этого метода. Таким образом, полное определение виртуального метода в базовом классе соответствует следующему шаблону:

```fsharp
abstract member [method-name] : [type]

default [self-identifier].[method-name] [argument-list] = [method-body]
```

И в производном классе, переопределение данного виртуального метода соответствует следующему шаблону:

```fsharp
override [self-identifier].[method-name] [argument-list] = [method-body]
```

Если опустить реализация по умолчанию в базовом классе, базовый класс становится абстрактным классом.

В следующем примере кода показано объявление нового виртуального метода `function1` в базовый класс и его переопределении в производном классе.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2601.fs)]

## <a name="constructors-and-inheritance"></a>Конструкторы и наследование

Необходимо вызвать конструктор базового класса в производном классе. Аргументы для конструктора базового класса, отображаются в списке аргументов в `inherit` предложение. Значения, которые используются должны определяться из аргументов, предоставляемых конструктором производного класса.

В следующем коде показано базовый класс и производный класс, где производном классе вызывает конструктор базового класса в выражении inherit:

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2602.fs)]

В случае несколько конструкторов можно использовать следующий код. В первой строке конструкторов производных классов `inherit` предложение, а также поля отображаются как явные поля, объявленные с `val` ключевое слово. Дополнительные сведения см. в разделе [явные поля: `val` Ключевое слово](members/explicit-fields-the-val-keyword.md).

```fsharp
type BaseClass =
    val string1 : string
    new (str) = { string1 = str }
    new () = { string1 = "" }

type DerivedClass =
    inherit BaseClass

    val string2 : string
    new (str1, str2) = { inherit BaseClass(str1); string2 = str2 }
    new (str2) = { inherit BaseClass(); string2 = str2 }

let obj1 = DerivedClass("A", "B")
let obj2 = DerivedClass("A")
```

## <a name="alternatives-to-inheritance"></a>Альтернативы наследованию

В случаях, где требуется незначительное изменение типа следует использовать выражение объекта вместо наследования. Следующий пример иллюстрирует использование выражения объекта в качестве альтернативы созданию нового производного типа:

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2603.fs)]

Дополнительные сведения о выражениях объектов, см. в разделе [выражения объекта](object-expressions.md).

При создании иерархии объектов, рассмотрите возможность использования размеченное объединение вместо наследования. Размеченные объединения также могут моделировать изменение поведения различных объектов, которые совместно используют общий тип. Использование одного размеченного объединения также порой устраняет потребность в несколько производных классов, которые незначительно отличаются друг от друга. Сведения о размеченные объединения, см. в разделе [размеченные объединения](discriminated-unions.md).

## <a name="see-also"></a>См. также

- [Выражения объекта](object-expressions.md)
- [Справочник по языку F#](index.md)