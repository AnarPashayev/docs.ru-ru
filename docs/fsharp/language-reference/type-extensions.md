---
title: Расширения типов
description: Узнайте, как F# расширения типов позволяют добавлять новые члены в ранее определенный тип объекта.
ms.date: 02/08/2019
ms.openlocfilehash: 69fb3b771b5334c5771f2ac75341b38c1dad5b90
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61982609"
---
# <a name="type-extensions"></a>Расширения типов

Расширения типа (также называется _дополнения_) — это семейство функций, которые позволяют добавлять новые члены в ранее определенный тип объекта. Ниже перечислены три возможности.

* Встроенных расширений типа
* В дополнительных расширениях
* Методы расширения

Каждый может использоваться в различных сценариях и имеет различные компромиссы.

## <a name="syntax"></a>Синтаксис

```fsharp
// Intrinsic and optional extensions
type typename with
    member self-identifier.member-name =
        body
    ...

// Extension methods
open System.Runtime.CompilerServices

[<Extension>]
type Extensions() =
    [static] member self-identifier.extension-name (ty: typename, [args]) =
        body
    ...
```

## <a name="intrinsic-type-extensions"></a>Встроенных расширений типа

Встроенное расширение типа является расширением типа, который расширяет определяемого пользователем типа.

Встроенных расширений типа должен быть определен в том же файле **и** в том же пространстве имен или модуль в качестве типа, они расширяемых. Все другие определения приведет к их, [дополнительных расширениях](type-extensions.md#optional-type-extensions).

Встроенных расширений типа иногда являются более точный способ отделяют функции из объявления типа. В следующем примере показано, как определить встроенное расширение типа:

```fsharp
namespace Example

type Variant =
    | Num of int
    | Str of string
  
module Variant =
    let print v =
        match v with
        | Num n -> printf "Num %d" n
        | Str s -> printf "Str %s" s

// Add a member to Variant as an extension
type Variant with
    member x.Print() = Variant.print x
```

С помощью расширения типа позволяет отделить каждое из перечисленных ниже:

* Объявление `Variant` типа
* Функциональные возможности для печати `Variant` класс в зависимости от его «фигуры»
* Способ доступа к функциональность печати с помощью стиля объекта `.`-нотация

Это является альтернативой для определения всех объектов, как член на `Variant`. Несмотря на то, что он не является по своей сути эффективнее, он может быть очистки представлением функциональные возможности, в некоторых ситуациях.

Встроенных расширений типа компилируются как члены типа, они дополнения и типа отображаются при проверке этого типа с путем отражения.

## <a name="optional-type-extensions"></a>В дополнительных расширениях

Необязательный тип расширения — это расширение, которое находится за пределами исходного модуля, пространства имен или сборке расширяемого типа.

В дополнительных расширениях полезны для расширения типа, который вы не определили самостоятельно. Пример:

```fsharp
module Extensions

open System.Collections.Generic

type IEnumerable<'T> with
    /// Repeat each element of the sequence n times
    member xs.RepeatElements(n: int) =
        seq {
            for x in xs do
                for i in 1 .. n do
                    yield x
        }
```

Теперь вы можете открывать `RepeatElements` как, если он является членом <xref:System.Collections.Generic.IEnumerable%601> , пока `Extensions` модуль открыт в области, в которой вы работаете.

Дополнительные расширения не отображаются в расширенном типе при проверке с помощью отражения. Дополнительное расширение должно содержаться в модулях, и они только в области, когда модуль, содержащий его модуль открыт или область — в противном случае.

Члены дополнительных расширений компилируются в статические члены, для которых экземпляр объекта неявно передается как первый параметр. Тем не менее они действуют как будто они являются членами экземпляра или статические члены в соответствии с, как они определены.

Члены дополнительных расширений также не видны для C# или VB потребителей. Может быть использован только в других F# кода.

## <a name="generic-limitation-of-intrinsic-and-optional-type-extensions"></a>Ограничение универсального типа встроенных и необязательных расширений

Можно объявить в расширение типа для универсального типа, где переменной типа ограничен. Требование относится, что ограничение объявления расширение соответствует ограничению объявленного типа.

Тем не менее даже в том случае, если ограничения сопоставляются между объявленным типом и расширение типа, это возможно для ограничения могут выводиться в теле расширенный элемент, который накладывает различные требование параметра типа, чем объявленного типа. Пример:

```fsharp
open System.Collections.Generic

// NOT POSSIBLE AND FAILS TO COMPILE!
//
// The member 'Sum' has a different requirement on 'T than the type IEnumerable<'T>
type IEnumerable<'T> with
    member this.Sum() = Seq.sum this
```

Не существует способа получить этот код для работы с расширением необязательный тип:

* Как, `Sum` член имеет различные ограничения `'T` (`static member get_Zero` и `static member (+)`), чем то, что определяет расширение типа.
* Изменение расширения типа иметь такое же ограничение как `Sum` больше не будут соответствовать определенные ограничения на `IEnumerable<'T>`.
* Изменение `member this.Sum` для `member inline this.Sum` вызывает эту ошибку, что ограничения типов совпадают.

Что требуется являются статических методов, которые могут быть представлены так, как если бы они расширение типа «float в пространстве». Это, где методы расширения возникает необходимость.

## <a name="extension-methods"></a>Методы расширения

Наконец, методы расширения (иногда называется "C# члены расширений в стиле») могут быть объявлены в F# как метод статический член класса.

Методы расширения полезны для когда нужно определять расширения на универсальный тип, который будет ограничивать тип переменной. Пример:

```fsharp
namespace Extensions

open System.Runtime.CompilerServices

[<Extension>]
type IEnumerableExtensions() =
    [<Extension>]
    static member inline Sum(xs: IEnumerable<'T>) = Seq.sum xs
```

При использовании этого кода поможет вам отображаются так, как если `Sum` определен на <xref:System.Collections.Generic.IEnumerable%601>, при условии что `Extensions` был открыт или находится в области.

## <a name="other-remarks"></a>Другие примечания

Расширения типов также иметь следующие атрибуты:

* Любой тип, который может осуществляться можно расширить.
* Можно определить внутренние и необязательный тип расширения _любой_ тип члена, не только методы. Поэтому свойства расширения возможны также, например.
* `self-identifier` Маркера в [синтаксис](type-extensions.md#syntax) представляет экземпляр типа, вызываемого так же, как обычные элементы.
* Расширенные элементы могут быть статическими или члены экземпляров.
* Переменные типа в расширении типа должны соответствовать ограничениям объявленного типа.

Для расширения типов также имеются следующие ограничения:

* Тип расширения не поддерживают виртуальные и абстрактные методы.
* Тип расширения не поддерживают методы переопределения в качестве дополнения.
* Тип расширения не поддерживают [статически разрешаемые параметры типов](generics/statically-resolved-type-parameters.md).
* Необязательный тип расширения не поддерживают конструкторы в качестве дополнения.
* Расширения типов нельзя определить для [аббревиатуры типов](type-abbreviations.md).
* Тип расширения не являются допустимыми для `byref<'T>` (хотя они могут быть объявлены).
* Расширения типов не допускаются для атрибутов (хотя они могут быть объявлены).
* Можно определять расширения, которые перегружают другие методы с тем же именем, но F# компилятор отдает предпочтение методам методы без расширения, в случае неоднозначного вызова.

Наконец Если для одного типа имеется несколько встроенных расширений типа, все члены должно быть уникальным. Для дополнительных расширениях члены различных расширений типов в тот же тип может иметь одинаковые имена. Ошибок неоднозначности возникают, только в том случае, если код клиента открывает две различные области, определяющие одинаковые имена членов.

## <a name="see-also"></a>См. также

- [Справочник по языку F#](index.md)
- [Члены](members/index.md)
