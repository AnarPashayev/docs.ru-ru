---
title: Расширения типов
description: Узнайте, F# как расширения типов позволяют добавлять новые элементы к ранее определенным типам объектов.
ms.date: 02/05/2020
ms.openlocfilehash: 9ab3a007783f67fd8d80cff840ac3085fdcd60f7
ms.sourcegitcommit: 011314e0c8eb4cf4a11d92078f58176c8c3efd2d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/09/2020
ms.locfileid: "77092685"
---
# <a name="type-extensions"></a>Расширения типов

Расширения типов (также называемые _приращениями_) — это семейство функций, которые позволяют добавлять новые члены к ранее определенным типам объектов. Доступны следующие три функции.

- Встроенные расширения типов
- Необязательные расширения типов
- Методы расширения

Каждый из них можно использовать в различных сценариях и имеет различные компромиссы.

## <a name="syntax"></a>Синтаксис

```fsharp
// Intrinsic and optional extensions
type typename with
    member self-identifier.member-name =
        body
    ...

// Extension methods
open System.Runtime.CompilerServices

[<Extension>]
type Extensions() =
    [<Extension>]
    static member self-identifier.extension-name (ty: typename, [args]) =
        body
    ...
```

## <a name="intrinsic-type-extensions"></a>Встроенные расширения типов

Внутреннее расширение типа — это расширение типа, расширяющее определяемый пользователем тип.

Встроенные расширения типов должны быть определены в том же файле **и** в том же пространстве имен или модуле, что и расширяемый тип. Любое другое определение приведет к тому, что они станут [дополнительными расширениями типа](type-extensions.md#optional-type-extensions).

Встроенные расширения типов иногда являются четким способом разделения функциональных возможностей из объявления типа. В следующем примере показано, как определить внутреннее расширение типа:

```fsharp
namespace Example

type Variant =
    | Num of int
    | Str of string
  
module Variant =
    let print v =
        match v with
        | Num n -> printf "Num %d" n
        | Str s -> printf "Str %s" s

// Add a member to Variant as an extension
type Variant with
    member x.Print() = Variant.print x
```

Использование расширения типа позволяет разделить каждый из следующих элементов:

- Объявление типа `Variant`
- Функции печати `Variant` класса в зависимости от его "формы"
- Способ доступа к функции печати с помощью `.`-нотации в стиле объекта

Это альтернатива определению всех элементов в `Variant`. Хотя это и не является оптимальным подходом, в некоторых ситуациях это может быть понятным представлением функциональных возможностей.

Встроенные расширения типов компилируются как члены типа, которые они расширяют, и отображаются в типе при проверке типа с помощью отражения.

## <a name="optional-type-extensions"></a>Необязательные расширения типов

Необязательное расширение типа — это расширение, которое отображается вне исходного модуля, пространства имен или сборки расширяемого типа.

Необязательные расширения типов полезны для расширения типа, который вы не определили самостоятельно. Пример:

```fsharp
module Extensions

type IEnumerable<'T> with
    /// Repeat each element of the sequence n times
    member xs.RepeatElements(n: int) =
        seq {
            for x in xs do
                for _ in 1 .. n -> x
        }
```

Теперь можно получить доступ к `RepeatElements`, как если бы он был членом <xref:System.Collections.Generic.IEnumerable%601>, если модуль `Extensions` открыт в области, в которой вы работаете.

Дополнительные расширения не отображаются в расширенном типе при проверке с помощью отражения. Необязательные расширения должны находиться в модулях, и они находятся только в области, если модуль, содержащий расширение, открыт или в другой области.

Необязательные элементы расширения компилируются в статические члены, для которых экземпляр объекта передается неявно в качестве первого параметра. Однако они действуют так, как если бы они были членами экземпляров или статическими членами в соответствии с их объявлением.

Необязательные члены расширения также не видны C# или Visual Basic потребителям. Их можно использовать только в другом F# коде.

## <a name="generic-limitation-of-intrinsic-and-optional-type-extensions"></a>Универсальное ограничение встроенных и необязательных расширений типов

Можно объявить расширение типа для универсального типа, в котором переменная типа ограничена. Требование заключается в том, что ограничение объявления расширения соответствует ограничению объявленного типа.

Однако даже при совпадении ограничений между объявленным типом и расширением типа можно вывести ограничение в тексте расширенного члена, который накладывает иное требование для параметра типа, чем объявленный тип. Пример:

```fsharp
open System.Collections.Generic

// NOT POSSIBLE AND FAILS TO COMPILE!
//
// The member 'Sum' has a different requirement on 'T than the type IEnumerable<'T>
type IEnumerable<'T> with
    member this.Sum() = Seq.sum this
```

Невозможно получить этот код для работы с дополнительным расширением типа:

- Как есть, элемент `Sum` имеет другое ограничение для `'T` (`static member get_Zero` и `static member (+)`), чем определено расширением типа.
- Изменение расширения типа с тем же ограничением, что и `Sum` больше не будет соответствовать определенному ограничению в `IEnumerable<'T>`.
- Изменение `member this.Sum` на `member inline this.Sum` приведет к ошибке, в которой ограничения типа не совпадают.

Нужны такие статические методы, как "плавающее место", и их можно представить так, как если бы они расширялись типом. Именно здесь методы расширения становятся необходимыми.

## <a name="extension-methods"></a>Методы расширения

Наконец, методы расширения (иногда называемыеC# "членами расширения стиля") можно объявить F# в виде статического метода-члена для класса.

Методы расширения полезны при определении расширений для универсального типа, которые ограничивают бы переменную типа. Пример:

```fsharp
namespace Extensions

open System.Runtime.CompilerServices

[<Extension>]
type IEnumerableExtensions =
    [<Extension>]
    static member inline Sum(xs: IEnumerable<'T>) = Seq.sum xs
```

При использовании этого кода он будет выглядеть так, как если бы `Sum` был определен в <xref:System.Collections.Generic.IEnumerable%601>, пока `Extensions` открыт или находится в области.

Чтобы расширение было доступно для кода VB.NET, на уровне сборки требуется дополнительный `ExtensionAttribute`:

```fsharp
module AssemblyInfo
open System.Runtime.CompilerServices
[<assembly:Extension>]
do ()
```

## <a name="other-remarks"></a>Другие замечания

Расширения типов также имеют следующие атрибуты:

- Любой тип, к которому можно получить доступ, можно расширить.
- Встроенные и необязательные расширения типов могут определять _любые_ типы членов, а не только методы. Итак, свойства расширения также возможны, например.
- Маркер `self-identifier` в [синтаксисе](type-extensions.md#syntax) представляет экземпляр вызываемого типа, как и обычные члены.
- Расширенные элементы могут быть статическими или членами экземпляра.
- Переменные типа в расширении типа должны соответствовать ограничениям объявленного типа.

Для расширений типов также существуют следующие ограничения.

- Расширения типов не поддерживают виртуальные или абстрактные методы.
- Расширения типов не поддерживают методы переопределения в качестве дополнений.
- Расширения типов не поддерживают [статически разрешаемые параметры типа](./generics/statically-resolved-type-parameters.md).
- Необязательные расширения типов не поддерживают конструкторы как дополнения.
- Расширения типов не могут быть определены для [сокращений типов](type-abbreviations.md).
- Расширения типов недопустимы для `byref<'T>` (хотя они могут быть объявлены).
- Расширения типов недопустимы для атрибутов (хотя они могут быть объявлены).
- Можно определить расширения, которые перегружают другие методы с тем же именем, но F# компилятор дает предпочтение методам, не являющимся расширениями, если имеется неоднозначный вызов.

Наконец, если существует несколько встроенных расширений типов для одного типа, все элементы должны быть уникальными. Для необязательных расширений типов члены в разных расширениях типов могут иметь одинаковые имена. Ошибки неоднозначности возникают, только если клиентский код открывает две различные области, определяющие одинаковые имена членов.

## <a name="see-also"></a>См. также раздел

- [Справочник по языку F#](index.md)
- [Участники](./members/index.md)
