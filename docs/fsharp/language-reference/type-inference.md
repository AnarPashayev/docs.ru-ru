---
title: Вывод типа
description: Узнайте, как F# компилятор определяет типы значений, переменных, параметров и возвращаемых значений.
ms.date: 05/16/2016
ms.openlocfilehash: 4b18c1a67a8b7ddadb4fb334ea4736e9fd29feb0
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/30/2019
ms.locfileid: "68630182"
---
# <a name="type-inference"></a>Вывод типа

В F# этом разделе описывается, как компилятор определяет типы значений, переменных, параметров и возвращаемых значений.

## <a name="type-inference-in-general"></a>Определение типа в целом

Идея определения типа заключается в том, что нет необходимости указывать типы F# конструкций, за исключением случаев, когда компилятор не может вывести тип. Пропуск сведений о явном типе не означает, F# что является динамически типизированным языком или что значения F# в слабо типизированы. F#— Это язык со статической типизацией, который означает, что компилятор выводит точный тип для каждой конструкции во время компиляции. Если у компилятора недостаточно сведений для вывода типов каждой конструкции, необходимо предоставить дополнительные сведения о типе, как правило, путем добавления явных заметок типа в любое место кода.

## <a name="inference-of-parameter-and-return-types"></a>Вывод типов параметров и возвращаемых данных

В списке параметров не нужно указывать тип каждого параметра. И, тем F# не менее, является языком со статической типизацией, поэтому во время компиляции каждое значение и выражение имеют определенный тип. Для тех типов, которые не указываются явным образом, компилятор выводит тип на основе контекста. Если тип не указан иным образом, он выводится как универсальный. Если код использует несогласованное значение, таким образом, что не существует единственного выводимого типа, удовлетворяющего всем условиям использования значения, компилятор сообщает об ошибке.

Тип возвращаемого значения функции определяется типом последнего выражения в функции.

Например, `a` в следующем коде типы параметров и `b` и возвращаемый тип выводятся `int` так, что литерал `100` имеет тип `int`.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-3/snippet301.fs)]

Можно повлиять на вывод типа, изменив литералы. Если сделать `100` a `u` `b` ,добавив`a`суффикс, типы`uint32`, и возвращаемое значение будут выведены как. `uint32`

Также можно повлиять на вывод типа с помощью других конструкций, которые подразумевают ограничения на тип, например функции и методы, работающие только с определенным типом.

Кроме того, можно применить явные аннотации типа к параметрам функции или метода или переменным в выражениях, как показано в следующих примерах. Ошибки возникают при возникновении конфликтов между разными ограничениями.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-3/snippet302.fs)]

Можно также явно указать возвращаемое значение функции, указав аннотацию типа после всех параметров.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-3/snippet303.fs)]

Типичный случай, когда аннотация типа полезен для параметра, — это то, что параметр является типом объекта и требуется использовать член.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-3/snippet304.fs)]

## <a name="automatic-generalization"></a>Автоматическое обобщение

Если код функции не зависит от типа параметра, компилятор считает, что параметр является универсальным. Это называется *автоматической*обобщением и может быть мощным средством для написания универсального кода без повышения сложности.

Например, следующая функция объединяет два параметра любого типа в кортеж.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-3/snippet305.fs)]

Тип выводится как

```fsharp
'a -> 'b -> 'a * 'b
```

## <a name="additional-information"></a>Дополнительные сведения

Определение типа описывается более подробно в спецификации F# языка.

## <a name="see-also"></a>См. также

- [Автоматическое обобщение](./generics/automatic-generalization.md)
