---
title: Объявления импорта. Ключевое слово open
description: Узнайте о декларациях импорта f и о том, как они указывают модуль или пространство имен, на элементы которых можно ссылаться без использования полностью квалифицированного имени.
ms.date: 04/04/2019
ms.openlocfilehash: 0baef27c7dc3181b9da0defb1c793fec04269c09
ms.sourcegitcommit: 348bb052d5cef109a61a3d5253faa5d7167d55ac
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/22/2020
ms.locfileid: "82021529"
---
# <a name="import-declarations-the-open-keyword"></a>Объявления импорта: ключевое слово `open`

> [!NOTE]
> Ссылки на справочник по API в этой статье ведут на сайт MSDN.  Работа над справочником по API docs.microsoft.com не завершена.

*В декларации импорта* указывается модуль или пространство имен, на элементы которого можно ссылаться без использования полностью квалифицированного имени.

## <a name="syntax"></a>Синтаксис

```fsharp
open module-or-namespace-name
```

## <a name="remarks"></a>Remarks

Ссылки на код с помощью полностью квалифицированного пространства имен или модульного пути каждый раз могут создавать код, который трудно писать, читать и поддерживать. Вместо этого можно `open` использовать ключевое слово для часто используемых модулей и именных пространств, чтобы при упоминании члена этого модуля или пространства имен можно было использовать короткую форму имени вместо полностью квалифицированного имени. Это ключевое слово `using` похоже на ключевое `using namespace` слово в C, `Imports` в Visual C и в Visual Basic.

Модуль или при условии, что пространство имен должно быть в том же проекте или в справочном проекте или сборке. Если это не так, вы можете добавить ссылку на проект или использовать `-reference` опцию `-r`командной строки (или ее аббревиативу). Дополнительные сведения см. в разделе [Параметры компилятора](compiler-options.md).

В декларации об импорте имена доступны в коде, который следует за декларацией, вплоть до конца оговоренного пространства имен, модуля или файла.

При использовании нескольких импортных деклараций они должны отображаться на отдельных строках.

Следующий код показывает использование `open` ключевого слова для упрощения кода.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet6801.fs)]

Компилятор F's не испускает ошибку или предупреждение, когда возникают двусмысленности, когда одно и то же имя происходит в более чем одном открытом модуле или пространстве имен. При возникновении двусмысленности, F-удается отдавать предпочтение недавно открытому модулю или пространству имен. Например, в следующем `empty` коде, `Seq.empty` `empty` означает, даже `List` если `Seq` находится в обоих и модулей.

```fsharp
open List
open Seq
printfn "%A" empty
```

Поэтому будьте осторожны при открытии модулей или именных пространств, таких как `List` или `Seq` содержащих членов с одинаковыми именами; вместо этого рассмотрите возможность использования квалифицированных имен. Следует избегать любой ситуации, в которой код зависит от порядка импортных деклараций.

## <a name="namespaces-that-are-open-by-default"></a>Области имен, открытые по умолчанию

Некоторые области имен настолько часто используются в коде F,s, что они открываются неявно без явной декларации импорта. В следующей таблице показаны пространства имен, открытые по умолчанию.

|Пространство имен|Описание|
|---------|-----------|
|`Microsoft.FSharp.Core`|Содержит базовые определения типа F-типа для `int` `float`встроенных типов, таких как и .|
|`Microsoft.FSharp.Core.Operators`|Содержит основные арифметические `+` `*`операции, такие как и .|
|`Microsoft.FSharp.Collections`|Содержит неизменяемые `List` `Array`классы коллекции, такие как и .|
|`Microsoft.FSharp.Control`|Содержит типы для контрольных конструкций, такие как ленивая оценка и асинхронные рабочие процессы.|
|`Microsoft.FSharp.Text`|Содержит функции для отформатированных io-х, таких как `printf` функция.|

## <a name="autoopen-attribute"></a>AutoOpen Атрибут

При этом `AutoOpen` атрибут можно применить к сборке, если вы хотите автоматически открыть пространство имен или модуль при упоминании сборки. Вы также можете `AutoOpen` применить атрибут к модулю, чтобы автоматически открыть этот модуль при открытии родительского модуля или пространства имен. Для получения дополнительной информации [см.](https://msdn.microsoft.com/visualfsharpdocs/conceptual/core.autoopenattribute-class-%5bfsharp%5d)

## <a name="requirequalifiedaccess-attribute"></a>Атрибут requireQualifiedAccess

Некоторые модули, записи или `RequireQualifiedAccess` типы соединения могут указывать атрибут. При упоминании элементов этих модулей, записей или союзов необходимо использовать квалифицированное имя независимо от того, включаете ли вы объявление об импорте. При стратегическом использовании этого атрибута в типах, определяющих часто используемые имена, можно избежать коллизий имен и тем самым сделать код более устойчивым к изменениям в библиотеках. Для получения дополнительной [Core.RequireQualifiedAccessAttribute Class](https://msdn.microsoft.com/visualfsharpdocs/conceptual/core.requirequalifiedaccessattribute-class-%5Bfsharp%5D)информации см.

## <a name="see-also"></a>См. также раздел

- [Ссылка на язык F](index.md)
- [Пространства имен](namespaces.md)
- [Модули](modules.md)
