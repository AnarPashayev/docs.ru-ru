---
title: Объявления импорта. Ключевое слово open
description: 'Сведения об объявлениях импорта F # и о том, как они указывают модуль или пространство имен, на элементы которых можно ссылаться без использования полного имени.'
ms.date: 04/04/2019
ms.openlocfilehash: 2b88427ca92212fb4a7598447dd1a5e12061093a
ms.sourcegitcommit: c37e8d4642fef647ebab0e1c618ecc29ddfe2a0f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/06/2020
ms.locfileid: "87855092"
---
# <a name="import-declarations-the-open-keyword"></a>Объявления импорта: `open` ключевое слово

В *объявлении импорта* указан модуль или пространство имен, элементы которого можно ссылаться без использования полного имени.

## <a name="syntax"></a>Синтаксис

```fsharp
open module-or-namespace-name
```

## <a name="remarks"></a>Remarks

> [!NOTE]
> Справочник по API docs.microsoft.com для F # не завершен. Если вы столкнулись с неработающими ссылками, используйте [документацию по основной библиотеке F #](https://fsharp.github.io/fsharp-core-docs/) .

Создание ссылки на код с помощью полного пространства имен или пути к модулю каждый раз может создать код, который трудно писать, читать и обслуживать. Вместо этого можно использовать `open` ключевое слово для часто используемых модулей и пространств имен, чтобы при ссылке на член этого модуля или пространства имен можно было использовать краткую форму имени вместо полного имени. Это ключевое слово похоже на `using` ключевое слово в C#, `using namespace` в Visual C++ и `Imports` в Visual Basic.

Предоставленный модуль или пространство имен должен находиться в том же проекте или в проекте или сборке, на которую имеется ссылка. Если это не так, можно добавить ссылку на проект или использовать `-reference` параметр командной строки (или его сокращение `-r` ). Дополнительные сведения см. в разделе [Параметры компилятора](compiler-options.md).

Объявление импорта делает имена доступными в коде, который следует за объявлением, вплоть до конца включающего пространства имен, модуля или файла.

При использовании нескольких объявлений импорта они должны отображаться в разных строках.

В следующем коде показано использование `open` ключевого слова для упрощения кода.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet6801.fs)]

Компилятор F # не выдает ошибку или предупреждение, если неоднозначность возникает, когда одно и то же имя встречается в нескольких открытых модулях или пространствах имен. При возникновении неоднозначности F # дает предпочтение более последнему открытому модулю или пространству имен. Например, в следующем коде `empty` это означает, что, несмотря на то, что находится `Seq.empty` `empty` в `List` обоих `Seq` модулях и.

```fsharp
open List
open Seq
printfn "%A" empty
```

Поэтому будьте внимательны при открытии модулей или пространств имен, таких как `List` или `Seq` , которые содержат элементы с одинаковыми именами. вместо этого рекомендуется использовать полные имена. Следует избегать ситуаций, в которых код зависит от порядка объявлений импорта.

## <a name="namespaces-that-are-open-by-default"></a>Пространства имен, открытые по умолчанию

Некоторые пространства имен часто используются в коде F #, поэтому они открыты неявно без необходимости явного объявления импорта. В следующей таблице показаны пространства имен, открытые по умолчанию.

|Пространство имен|Описание|
|---------|-----------|
|`Microsoft.FSharp.Core`|Содержит основные определения типов F # для встроенных типов, таких как `int` и `float` .|
|`Microsoft.FSharp.Core.Operators`|Содержит базовые арифметические операции, такие как `+` и `*` .|
|`Microsoft.FSharp.Collections`|Содержит неизменяемые классы коллекций, такие как `List` и `Array` .|
|`Microsoft.FSharp.Control`|Содержит типы для конструкций элементов управления, таких как отложенная оценка и асинхронные рабочие процессы.|
|`Microsoft.FSharp.Text`|Содержит функции для форматированного ввода-вывода, например `printf` функции.|

## <a name="autoopen-attribute"></a>Атрибут Автооткрытия

Атрибут можно применить `AutoOpen` к сборке, если необходимо автоматически открывать пространство имен или модуль при ссылке на сборку. Можно также применить `AutoOpen` атрибут к модулю для автоматического открытия этого модуля при открытии родительского модуля или пространства имен. Дополнительные сведения см. в разделе [класс Core. AutoOpenAttribute](https://msdn.microsoft.com/visualfsharpdocs/conceptual/core.autoopenattribute-class-%5bfsharp%5d).

## <a name="requirequalifiedaccess-attribute"></a>Атрибут Рекуирекуалифиедакцесс

Некоторые модули, записи или типы объединений могут задавать `RequireQualifiedAccess` атрибут. При ссылке на элементы этих модулей, записей или объединений необходимо использовать полное имя независимо от того, включено ли объявление импорта. Если этот атрибут используется стратегически для типов, определяющих часто используемые имена, можно избежать конфликтов имен и, таким образом, сделать код более устойчивым к изменениям в библиотеках. Дополнительные сведения см. в разделе [класс Core. рекуирекуалифиедакцессаттрибуте](https://msdn.microsoft.com/visualfsharpdocs/conceptual/core.requirequalifiedaccessattribute-class-%5Bfsharp%5D).

## <a name="see-also"></a>См. также

- [Справочник по языку F#](index.md)
- [Пространства имен](namespaces.md)
- [Модули](modules.md)
