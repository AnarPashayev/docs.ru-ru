---
title: Объявления импорта. Ключевое слово open
description: 'Сведения об объявлениях импорта F # и о том, как они указывают модуль или пространство имен, на элементы которых можно ссылаться без использования полного имени.'
ms.date: 08/15/2020
ms.openlocfilehash: ab208c53809e120bc216c8f8b4d04a322d67cf2f
ms.sourcegitcommit: f99115e12a5eb75638abe45072e023a3ce3351ac
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/12/2020
ms.locfileid: "94557185"
---
# <a name="import-declarations-the-open-keyword"></a>Объявления импорта: `open` ключевое слово

В *объявлении импорта* указан модуль или пространство имен, элементы которого можно ссылаться без использования полного имени.

## <a name="syntax"></a>Синтаксис

```fsharp
open module-or-namespace-name
open type type-name
```

## <a name="remarks"></a>Примечания

Создание ссылки на код с помощью полного пространства имен или пути к модулю каждый раз может создать код, который трудно писать, читать и обслуживать. Вместо этого можно использовать `open` ключевое слово для часто используемых модулей и пространств имен, чтобы при ссылке на член этого модуля или пространства имен можно было использовать краткую форму имени вместо полного имени. Это ключевое слово похоже на `using` ключевое слово в C#, `using namespace` в Visual C++ и `Imports` в Visual Basic.

Предоставленный модуль или пространство имен должен находиться в том же проекте или в проекте или сборке, на которую имеется ссылка. Если это не так, можно добавить ссылку на проект или использовать `-reference` параметр командной строки (или его сокращение `-r` ). Дополнительные сведения см. в разделе [параметры компилятора](compiler-options.md).

Объявление импорта делает имена доступными в коде, который следует за объявлением, вплоть до конца включающего пространства имен, модуля или файла.

При использовании нескольких объявлений импорта они должны отображаться в разных строках.

В следующем коде показано использование `open` ключевого слова для упрощения кода.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet6801.fs)]

Компилятор F # не выдает ошибку или предупреждение, если неоднозначность возникает, когда одно и то же имя встречается в нескольких открытых модулях или пространствах имен. При возникновении неоднозначности F # дает предпочтение более последнему открытому модулю или пространству имен. Например, в следующем коде `empty` это означает, что, несмотря на то, что находится `Seq.empty` `empty` в `List` обоих `Seq` модулях и.

```fsharp
open List
open Seq
printfn "%A" empty
```

Поэтому будьте внимательны при открытии модулей или пространств имен, таких как `List` или `Seq` , которые содержат элементы с одинаковыми именами. вместо этого рекомендуется использовать полные имена. Следует избегать ситуаций, в которых код зависит от порядка объявлений импорта.

## <a name="open-type-declarations"></a>Открытые объявления типов

F # поддерживает `open` для типа следующим образом:

```fsharp
open type System.Math
PI
```

Это обеспечит доступ ко всем доступным статическим полям и элементам типа.

`open`Для предоставления статических членов можно также использовать F # с определенными типами [записей](records.md) и [размеченных объединений](discriminated-unions.md) . В случае размеченных объединений можно также предоставить варианты объединения. Это может быть полезно для доступа к вариантам объединения в типе, объявленном внутри модуля, который вы не хотите открывать, например так:

```fsharp
module M =
    type DU = A | B | C

    let someOtherFunction x = x + 1

// Open only the type inside the module
open type M.DU

printfn "%A" A
```

## <a name="namespaces-that-are-open-by-default"></a>Пространства имен, открытые по умолчанию

Некоторые пространства имен часто используются в коде F #, поэтому они открыты неявно без необходимости явного объявления импорта. В следующей таблице показаны пространства имен, открытые по умолчанию.

|Пространство имен|Описание|
|---------|-----------|
|`FSharp.Core`|Содержит основные определения типов F # для встроенных типов, таких как `int` и `float` .|
|`FSharp.Core.Operators`|Содержит базовые арифметические операции, такие как `+` и `*` .|
|`FSharp.Collections`|Содержит неизменяемые классы коллекций, такие как `List` и `Array` .|
|`FSharp.Control`|Содержит типы для конструкций элементов управления, таких как отложенная оценка и асинхронные рабочие процессы.|
|`FSharp.Text`|Содержит функции для форматированного ввода-вывода, например `printf` функции.|

## <a name="autoopen-attribute"></a>Атрибут Автооткрытия

Атрибут можно применить `AutoOpen` к сборке, если необходимо автоматически открывать пространство имен или модуль при ссылке на сборку. Можно также применить `AutoOpen` атрибут к модулю для автоматического открытия этого модуля при открытии родительского модуля или пространства имен. Дополнительные сведения см. в разделе [AutoOpenAttribute](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-core-autoopenattribute.html).

## <a name="requirequalifiedaccess-attribute"></a>Атрибут Рекуирекуалифиедакцесс

Некоторые модули, записи или типы объединений могут задавать `RequireQualifiedAccess` атрибут. При ссылке на элементы этих модулей, записей или объединений необходимо использовать полное имя независимо от того, включено ли объявление импорта. Если этот атрибут используется стратегически для типов, определяющих часто используемые имена, можно избежать конфликтов имен и, таким образом, сделать код более устойчивым к изменениям в библиотеках. Дополнительные сведения см. в разделе [рекуирекуалифиедакцессаттрибуте](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-core-requirequalifiedaccessattribute.html).

## <a name="see-also"></a>См. также

- [Справочник по языку F#](index.md)
- [Пространства имен](namespaces.md)
- [Модули](modules.md)
