---
title: Перегрузка операторов
description: Узнайте, как перегрузка арифметических операторов в классе или типе записи, а также на глобальном уровне в F#.
ms.date: 05/16/2016
ms.openlocfilehash: f4b63818cbdc44d214dca6446162ec9a8922f601
ms.sourcegitcommit: 8699383914c24a0df033393f55db3369db728a7b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/15/2019
ms.locfileid: "65645365"
---
# <a name="operator-overloading"></a>Перегрузка операторов

В этом разделе описывает перегрузку арифметических операторов в классе или типе записи, а также на глобальном уровне.

## <a name="syntax"></a>Синтаксис

```fsharp
// Overloading an operator as a class or record member.
static member (operator-symbols) (parameter-list) =
    method-body
// Overloading an operator at the global level
let [inline] (operator-symbols) parameter-list = function-body
```

## <a name="remarks"></a>Примечания

В приведенном выше синтаксисе *символ оператора* является одним из `+`, `-`, `*`, `/`, `=`, и т. д. *Список параметров* задает операнды в порядке, они отображаются в обычном синтаксисе данного оператора. *Тело метода* создает результирующее значение.

Перегрузки операторов для операторов должны быть статическими. Оператор перегрузок для унарных операторов, таких как `+` и `-`, необходимо использовать тильду (`~`) в *символ оператора* прошел оператора унарного оператора и бинарного оператора, как показано на следующее объявление.

```fsharp
static member (~-) (v : Vector)
```

Следующий код иллюстрирует класс vector, имеет только два оператора: один для "унарный минус", а другой для умножения на скаляр. В примере две перегрузки для скалярного умножения необходимы, так как оператор должен работать независимо от порядка, в котором отображаются вектора и скалярные.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4001.fs)]

## <a name="creating-new-operators"></a>Создание новых операторов

Все стандартные операторы можно перегружать, но вы также можете создать новые операторы из последовательностей определенных символов. Допустимые знаки операторов `!`, `%`, `&`, `*`, `+`, `-`, `.`, `/`, `<`, `=`, `>`, `?`, `@`, `^`, `|`, и `~`. `~` Символ имеет особое значение делает оператор унарным и не является частью последовательности символов оператора. Не все операторы могут выполняться унарный.

В зависимости от символьной последовательности, используемого ваш оператор будет иметь приоритет и ассоциативность операторов. Ассоциативность операторов могут быть либо слева направо или справа налево и используется каждый раз, когда операторы тот же уровень приоритета, отображаются в последовательности без скобок.

Символ оператора `.` не влияет на более высокий приоритет, поэтому, например, если вы хотите определить собственную версию умножения, имеющий тот же приоритет и ассоциативность операторов, что и обычное умножение, можно создать операторов, таких как `.*`.

Только операторы `?` и `?<-` может начинаться с `?`.

Таблица, показывающая всех операторов в F# можно найти в [Справочник символов и операторов](symbol-and-operator-reference/index.md).

## <a name="overloaded-operator-names"></a>Имена перегруженных операторов

Когда F# компилятор компилирует выражения оператора, он создает метод с именем, созданный компилятором, для этого оператора. Это имя, отображаемое в промежуточный язык Майкрософт (MSIL) для метода, а также в отражении и IntelliSense. Вы не обязательно обычно должны использовать эти имена в F# кода.

В следующей таблице показаны стандартные операторы и соответствующие им создаются имена.

|Оператор|Созданное имя|
|--------|--------------|
|`[]`|`op_Nil`|
|`::`|`op_Cons`|
|`+`|`op_Addition`|
|`-`|`op_Subtraction`|
|`*`|`op_Multiply`|
|`/`|`op_Division`|
|`@`|`op_Append`|
|`^`|`op_Concatenate`|
|`%`|`op_Modulus`|
|`&&&`|`op_BitwiseAnd`|
|<code>&#124;&#124;&#124;</code>|`op_BitwiseOr`|
|`^^^`|`op_ExclusiveOr`|
|`<<<`|`op_LeftShift`|
|`~~~`|`op_LogicalNot`|
|`>>>`|`op_RightShift`|
|`~+`|`op_UnaryPlus`|
|`~-`|`op_UnaryNegation`|
|`=`|`op_Equality`|
|`<=`|`op_LessThanOrEqual`|
|`>=`|`op_GreaterThanOrEqual`|
|`<`|`op_LessThan`|
|`>`|`op_GreaterThan`|
|`?`|`op_Dynamic`|
|`?<-`|`op_DynamicAssignment`|
|<code>&#124;></code>|`op_PipeRight`|
|<code><&#124;</code>|`op_PipeLeft`|
|`!`|`op_Dereference`|
|`>>`|`op_ComposeRight`|
|`<<`|`op_ComposeLeft`|
|`<@ @>`|`op_Quotation`|
|`<@@ @@>`|`op_QuotationUntyped`|
|`+=`|`op_AdditionAssignment`|
|`-=`|`op_SubtractionAssignment`|
|`*=`|`op_MultiplyAssignment`|
|`/=`|`op_DivisionAssignment`|
|`..`|`op_Range`|
|`.. ..`|`op_RangeStep`|

Другие сочетания символов операторов, не перечисленные здесь можно использовать в качестве операторов и имеют имена, сформированные путем объединения имена отдельных символов из следующей таблицы. Например +! становится `op_PlusBang`.

|Символ оператора|name|
|------------------|----|
|`>`|`Greater`|
|`<`|`Less`|
|`+`|`Plus`|
|`-`|`Minus`|
|`*`|`Multiply`|
|`/`|`Divide`|
|`=`|`Equals`|
|`~`|`Twiddle`|
|`%`|`Percent`|
|`.`|`Dot`|
|`&`|`Amp`|
|<code>&#124;</code>|`Bar`|
|`@`|`At`|
|`^`|`Hat`|
|`!`|`Bang`|
|`?`|`Qmark`|
|`(`|`LParen`|
|`,`|`Comma`|
|`)`|`RParen`|
|`[`|`LBrack`|
|`]`|`RBrack`|

## <a name="prefix-and-infix-operators"></a>Префикс и инфиксные операторы

*Префикс* операторы должны размещаться перед операнда или операндов, подобно функции. *Инфиксные* операторы должны располагаться между двумя операндами.

Только определенные операторы можно использовать в качестве префикса операторов. Некоторые операторы всегда являются префиксные операторы, другие могут быть инфиксные или префикс и остальные всегда являются инфиксные операторы. Операторы, которые начинаются с `!`, за исключением `!=`и оператор `~`, и не будут повторяться последовательности`~`, всегда являются операторами префикс. Операторы `+`, `-`, `+.`, `-.`, `&`, `&&`, `%`, и `%%` может быть префиксные операторы или инфиксные операторы. Префиксная версия этих операторов было отличить от версии инфиксные путем добавления `~` в начале префиксный оператор, если она определена. `~` Не используется при использовании оператора, только в том случае, если она определена.

## <a name="example"></a>Пример

Следующий код иллюстрирует использование перегрузки операторов для реализации дробного типа. Небольшую представляется числителя и знаменателя. Функция `hcf` используется для определения наибольшего общего делителя, который используется для сокращения дробей.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4002.fs)]

**Выходные данные:**

```
3/4 + 1/2 = 5/4
3/4 - 1/2 = 1/4
3/4 * 1/2 = 3/8
3/4 / 1/2 = 3/2
3/4 + 1 = 7/4
```

## <a name="operators-at-the-global-level"></a>Операторы на глобальном уровне

Можно также определить операторы на глобальном уровне. В следующем коде определяется оператор `+?`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4003.fs)]

Приведенный выше код является `12`.

Так как определение областей правила для обычных арифметических операторов таким образом можно переопределить F# диктовать, что новые определенные операторы имеют приоритет над встроенными операторами.

Ключевое слово `inline` часто используется с глобальных операторов, которые часто бывают небольших функций, которые лучше всего интегрируются в вызывающий код. Встроенные функции оператор решений также позволяет пользователям работать с статически разрешаемые параметры типа для получения статически разрешаемым универсального кода. Дополнительные сведения см. в разделе [встраиваемые функции](functions/inline-functions.md) и [статически разрешаемые параметры типов](generics/statically-resolved-type-parameters.md).

## <a name="see-also"></a>См. также

- [Члены](members/index.md)
