---
title: Гибкие типы
description: Узнайте, как использовать F# гибкую аннотацию типа, которая указывает, что параметр, переменная или значение имеют тип, совместимый с указанным типом.
ms.date: 05/16/2016
ms.openlocfilehash: bf05f78f163d1f9c73c667df60925b66a5315627
ms.sourcegitcommit: a2d0e1f66367367065bc8dc0dde488ab536da73f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/18/2019
ms.locfileid: "71083066"
---
# <a name="flexible-types"></a>Гибкие типы

*Заметка гибкого типа* указывает, что параметр, переменная или значение имеют тип, совместимый с указанным типом, где совместимость определяется положением в объектно-ориентированной иерархии классов или интерфейсов. Гибкие типы полезны в частности, если автоматическое преобразование в типы выше в иерархии типов не выполняется, но все равно требуется обеспечить работу функций с любым типом в иерархии или любым типом, реализующим интерфейс.

## <a name="syntax"></a>Синтаксис

```fsharp
#type
```

## <a name="remarks"></a>Примечания

В предыдущем синтаксисе *тип* представляет базовый тип или интерфейс.

Гибкий тип эквивалентен универсальному типу, имеющему ограничение, которое ограничивает допустимые типы типами, совместимыми с базовым или интерфейсным типом. То есть следующие две строки кода эквивалентны.

```fsharp
#SomeType

'T when 'T :> SomeType
```

Гибкие типы полезны в ситуациях нескольких типов. Например, если имеется функция более высокого порядка (функция, которая принимает функцию в качестве аргумента), часто бывает полезно, чтобы функция возвращала гибкий тип. В следующем примере использование гибкого типа с аргументом последовательности в `iterate2` позволяет функции более высокого порядка работать с функциями, создающими последовательности, массивы, списки и любые другие перечислимые типы.

Рассмотрим следующие две функции, одна из которых возвращает последовательность, а другая — гибкий тип.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4101.fs)]

В качестве другого примера рассмотрим функцию [Seq. Concat](https://msdn.microsoft.com/library/2eeb69a9-fc2f-4b7d-8dee-101fa2b00712) Library:

```fsharp
val concat: sequences:seq<#seq<'T>> -> seq<'T>
```

В эту функцию можно передать любую из следующих перечислимых последовательностей:

- Список списков
- Список массивов
- Массив списков
- Массив последовательностей
- Любое другое сочетание перечислимых последовательностей

В следующем коде используется `Seq.concat` для демонстрации сценариев, которые можно поддерживать с помощью гибких типов.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4102.fs)]

Выходные данные выглядят следующим образом.

```console
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
```

В F#, как и в других объектно-ориентированных языках, существуют контексты, в которых производные типы или типы, реализующие интерфейсы, автоматически преобразуются в базовый тип или тип интерфейса. Эти автоматические преобразования происходят в прямых аргументах, но не в том случае, если тип находится в подчиненной положении, как часть более сложного типа, например тип возвращаемого значения типа функции, или как аргумент типа. Таким образом, нотация гибкого типа особенно полезна, когда тип, к которому он применяется, является частью более сложного типа.

## <a name="see-also"></a>См. также

- [Справочник по языку F#](index.md)
- [Универсальные шаблоны](./generics/index.md)
