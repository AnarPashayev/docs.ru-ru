---
title: Гибкие типы
description: Сведения об использовании F# заметка с гибким типом, который указывает, что параметр, переменная или значение имеет тип, совместимый с указанным типом.
ms.date: 05/16/2016
ms.openlocfilehash: e8edae671c54971862a35f03da8663c8567e2261
ms.sourcegitcommit: 8699383914c24a0df033393f55db3369db728a7b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/15/2019
ms.locfileid: "65641906"
---
# <a name="flexible-types"></a>Гибкие типы

Объект *заметка с гибким типом* указывает, что параметр, переменная или значение имеет тип, который совместим с указанным типом, где совместимость определяется положением в объектно ориентированного иерархии классов или интерфейсов. Гибкие типы полезны в тех случаях, в частности в том случае, когда не происходит автоматического преобразования в типы, расположенные выше в иерархии типов, но вы по-прежнему хотите включить функциональные возможности по работе для работы с любым типом в иерархии или любой тип, реализующий интерфейс.

## <a name="syntax"></a>Синтаксис

```fsharp
#type
```

## <a name="remarks"></a>Примечания

В приведенном выше синтаксисе *тип* представляет базовый тип или интерфейс.

Гибкий тип соответствует универсальный тип, который имеет ограничение, которое ограничивает допустимых типов для типов, которые совместимы с типом базового типа или интерфейса. То есть следующие две строки кода эквивалентны.

```fsharp
#SomeType

'T when 'T :> SomeType
```

Гибкие типы можно использовать в нескольких случаях. Например если у вас есть функция высшего порядка (функции, которая принимает в качестве аргумента), часто бывает удобно иметь гибкий тип возвращаемого значения функции. В следующем примере, использование гибкий тип с аргументом последовательности в `iterate2` позволяет функции высшего порядка для работы с функциями, которые создают последовательности, массивы, списки и любой другой перечисляемый тип.

Рассмотрим следующие две функции, один из которых возвращает последовательность, а вторая возвращает гибкий тип.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4101.fs)]

В качестве другого примера рассмотрим [Seq.concat](https://msdn.microsoft.com/library/2eeb69a9-fc2f-4b7d-8dee-101fa2b00712) функция библиотеки:

```fsharp
val concat: sequences:seq<#seq<'T>> -> seq<'T>
```

Для этой функции можно передать любой из следующих последовательностей enumerable:

- Список списков
- Список массивов
- Массив списков
- Массив из последовательности
- Любые комбинации перечисляемые последовательности

В следующем коде используется `Seq.concat` для демонстрации сценариев, которые может поддерживать, используя гибкие типы.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4102.fs)]

Выходные данные выглядят следующим образом.

```
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
```

В F#, как и в других объектно ориентированных языках есть в контекстах, в котором производные типы или типы, реализующие интерфейсы автоматически преобразуются в базовый тип или тип интерфейса. Эти автоматические преобразования происходят в прямой аргументов, но не в том случае, если тип находится в подчиненном положении, как часть более сложного типа, такие как тип возвращаемого значения тип функции или как аргумент типа. Таким образом нотация гибкий тип является особенно удобно использовать, когда типа, которое вы хотите применить его к является частью более сложного типа.

## <a name="see-also"></a>См. также

- [Справочник по языку F#](index.md)
- [Универсальные шаблоны](generics/index.md)
