---
title: Гибкие типы
description: 'Узнайте, как использовать аннотацию гибкого типа F #, которая указывает, что параметр, переменная или значение имеют тип, совместимый с указанным типом.'
ms.date: 08/15/2020
ms.openlocfilehash: 44241ad082cd7f3de9e0cc6a48b8a8946e7b33d3
ms.sourcegitcommit: 8bfeb5930ca48b2ee6053f16082dcaf24d46d221
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/18/2020
ms.locfileid: "88557754"
---
# <a name="flexible-types"></a>Гибкие типы

*Заметка гибкого типа* указывает, что параметр, переменная или значение имеют тип, совместимый с указанным типом, где совместимость определяется положением в объектно-ориентированной иерархии классов или интерфейсов. Гибкие типы полезны в частности, если автоматическое преобразование в типы выше в иерархии типов не выполняется, но все равно требуется обеспечить работу функций с любым типом в иерархии или любым типом, реализующим интерфейс.

## <a name="syntax"></a>Синтаксис

```fsharp
#type
```

## <a name="remarks"></a>Remarks

В предыдущем синтаксисе *тип* представляет базовый тип или интерфейс.

Гибкий тип эквивалентен универсальному типу, имеющему ограничение, которое ограничивает допустимые типы типами, совместимыми с базовым или интерфейсным типом. То есть следующие две строки кода эквивалентны.

```fsharp
#SomeType

'T when 'T :> SomeType
```

Гибкие типы полезны в ситуациях нескольких типов. Например, если имеется функция более высокого порядка (функция, которая принимает функцию в качестве аргумента), часто бывает полезно, чтобы функция возвращала гибкий тип. В следующем примере использование гибкого типа с аргументом последовательности в `iterate2` позволяет функции более высокого порядка работать с функциями, создающими последовательности, массивы, списки и любые другие перечислимые типы.

Рассмотрим следующие две функции, одна из которых возвращает последовательность, а другая — гибкий тип.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4101.fs)]

В качестве другого примера рассмотрим функцию [Seq. Concat](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#concat) Library:

```fsharp
val concat: sequences:seq<#seq<'T>> -> seq<'T>
```

В эту функцию можно передать любую из следующих перечислимых последовательностей:

- Список списков
- Список массивов
- Массив списков
- Массив последовательностей
- Любое другое сочетание перечислимых последовательностей

В следующем коде используется `Seq.concat` для демонстрации сценариев, которые можно поддерживать с помощью гибких типов.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4102.fs)]

Выходные данные выглядят следующим образом.

```console
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
```

В F #, как и в других объектно-ориентированных языках, существуют контексты, в которых производные типы или типы, реализующие интерфейсы, автоматически преобразуются в базовый тип или тип интерфейса. Эти автоматические преобразования происходят в прямых аргументах, но не в том случае, если тип находится в подчиненной положении, как часть более сложного типа, например тип возвращаемого значения типа функции, или как аргумент типа. Таким образом, нотация гибкого типа особенно полезна, когда тип, к которому он применяется, является частью более сложного типа.

## <a name="see-also"></a>См. также

- [Справочник по языку F#](index.md)
- [Универсальные шаблоны](./generics/index.md)
