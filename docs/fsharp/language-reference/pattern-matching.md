---
title: Сопоставление шаблонов
description: Узнайте, как использовать шаблоны в F# для сравнения данных с логическими структурами, разложения данных на составные части или извлечения информации из данных.
ms.date: 05/16/2016
ms.openlocfilehash: f76a5fb675f83df87dd896f471a3552495f39e7e
ms.sourcegitcommit: 8699383914c24a0df033393f55db3369db728a7b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/15/2019
ms.locfileid: "65641772"
---
# <a name="pattern-matching"></a>Сопоставление шаблонов

Шаблоны — это правила для преобразования входных данных. Они используются во всем F# языка для сравнения данных с логической структурой или структурами, разложения данных на составные части или извлечения информации из данных различными способами.

## <a name="remarks"></a>Примечания

Шаблоны используются во многих конструкциях языка, таких как `match` выражение. Они используются при обработке аргументов для функций в `let` привязки, лямбда-выражения и в обработчиках исключений, связанных с `try...with` выражение. Дополнительные сведения см. в разделе [выражения сопоставления](match-expressions.md), [привязки let](functions/let-bindings.md), [лямбда-выражения: `fun` Ключевое слово](functions/lambda-expressions-the-fun-keyword.md), и [исключения: `try...with` Выражение](exception-handling/the-try-with-expression.md).

Например, в `match` выражения, *шаблон* является то, что следует за символом вертикальной черты.

```fsharp
match expression with
| pattern [ when condition ] -> result-expression
...
```

Каждый шаблон выступает в качестве правила для преобразования входных данных каким-либо образом. В `match` выражения, каждый шаблон поочередно анализируется ли входные данные совместим с шаблоном. Если соответствие найдено, выполняется результирующего выражения. Если совпадение не найден, проверяется следующее правило-шаблон. Обязательно при *условие* часть описан в [выражения сопоставления](match-expressions.md).

Поддерживаемые шаблоны приведены в следующей таблице. Во время выполнения входные данные сравниваются с каждым из следующих шаблонов в порядке, указанном в таблице, и шаблонов применяются рекурсивно из сначала к последнему, как они указаны в коде и слева направо для шаблонов в каждой строке.

|name|Описание|Пример|
|----|-----------|-------|
|Шаблон константы|Любой числовой, символ, или строковый литерал, константа перечисления или определенный литеральный идентификатор|`1.0`, `"test"`, `30`, `Color.Red`|
|Шаблон идентификатора|Значение варианта размеченного объединения, метка исключения или ветвь активного шаблона|`Some(x)`<br /><br />`Failure(msg)`|
|Шаблон переменной|*identifier*|`a`|
|`as` Шаблон|*шаблон* как *идентификатор*|`(a, b) as tuple1`|
|ИЛИ шаблон|*pattern1* &#124; *pattern2*|<code>([h] &#124; [h; _])</code>|
|И шаблон|*pattern1* &amp; *pattern2*|`(a, b) & (_, "test")`|
|Шаблон cons-списка|*identifier* :: *list-identifier*|`h :: t`|
|Шаблон списка|[ *pattern_1*; ... ; *pattern_n* ]|`[ a; b; c ]`|
|Шаблон массива|[&#124; *pattern_1*; ..; *pattern_n* &#124;]|<code>[&#124; a; b; c &#124;]</code>|
|Шаблон в круглых скобках|( *шаблон* )|`( a )`|
|Шаблон кортежа|( *шаблон_1*,..., *pattern_n* )|`( a, b )`|
|Шаблон записи|{ *identifier1* = *pattern_1*; ... ; *identifier_n* = *pattern_n* }|`{ Name = name; }`|
|Шаблон подстановочного знака|_|`_`|
|Шаблон вместе с аннотацией типа|*шаблон* : *типа*|`a : int`|
|Шаблон проверки типа|:? *Тип* [как *идентификатор* ]|`:? System.DateTime as dt`|
|Шаблон NULL|null|`null`|

## <a name="constant-patterns"></a>Шаблоны констант

Шаблоны констант — это числовые, символов и строковые литералы, константы перечисления (включая имя типа перечисления). Объект `match` выражение, содержащее только шаблоны констант может сравниваться с оператором case в других языках. Входные данные сравниваются с литеральным значением и шаблон считается соответствующим, если значения равны. Тип литерала должен быть совместим с типом входных данных.

В следующем примере демонстрируется использование литеральных шаблонов и также использует шаблон переменной и шаблон OR.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4801.fs)]

Другой пример литерального шаблона — шаблон, основанный на константах перечисления. При использовании констант перечисления необходимо указать имя типа перечисления.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4802.fs)]

## <a name="identifier-patterns"></a>Шаблоны идентификаторов

Если шаблон является строкой символов, представляющей допустимый идентификатор, форма идентификатора определяет, как соответствие будет обнаружено. Если идентификатор длиннее одного символа и начинается с символа верхнего регистра, компилятор пытается найти соответствие шаблону идентификатора. Идентификатором для этого шаблона может быть значение, отмеченное литерального атрибута, размеченного объединения, идентификатор исключения или ветвь активного шаблона. Если не совпадающий идентификатор не найден, подбор завершается неудачей и входными данными сравнивается следующее правило-шаблон, шаблон переменной.

Шаблоны размеченных объединений могут представлять собой простые именованные или они могут иметь значение или кортеж, содержащий несколько значений. Если значение, необходимо указать идентификатор для значения. В случае кортежа необходимо предоставить шаблон кортежа с идентификатором для каждого элемента кортежа или идентификатор с именем поля для одного или нескольких именованных полей объединения. См. в примерах кода в этом разделе вы найдете примеры.

`option` Тип — это размеченное объединение, имеющее два варианта `Some` и `None`. Один случай (`Some`) имеет значение, а вторая (`None`) представляет собой просто именованную ветвь. Таким образом `Some` должен иметь переменную для значения, связанного с `Some` , однако `None` должен записываться отдельно. В следующем коде, переменная `var1` присваивается значение, полученное путем сравнения с `Some` случая.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4803.fs)]

В следующем примере `PersonName` размеченное объединение содержит смесь строк и символов, представляющих возможные формы имен. Регистр размеченное объединение `FirstOnly`, `LastOnly`, и `FirstLast`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4804.fs)]

Для размеченных объединений, имеющих именованные поля используйте знак равенства (=) для извлечения значения именованного поля. Например рассмотрим размеченное объединение с объявлением следующим образом.

```fsharp
type Shape =
    | Rectangle of height : float * width : float
    | Circle of radius : float
```

Именованные поля в выражении можно использовать следующим образом.

```fsharp
let matchShape shape =
    match shape with
    | Rectangle(height = h) -> printfn "Rectangle with length %f" h
    | Circle(r) -> printfn "Circle with radius %f" r
```

Использование именованного поля необязательно, поэтому в предыдущем примере, оба `Circle(r)` и `Circle(radius = r)` дают одинаковый результат.

При указании нескольких полей используйте точку с запятой (;) в качестве разделителя.

```
match shape with
| Rectangle(height = h; width = w) -> printfn "Rectangle with height %f and width %f" h w
| _ -> ()
```

Активные шаблоны позволяют определять более сложный настраиваемый подбор шаблона. Дополнительные сведения об активных шаблонах см. в разделе [активные шаблоны](active-patterns.md).

При подборе шаблона в контексте обработчиков исключений используется вариант, в котором идентификатор является исключением. Сведения о подборе шаблона при обработке исключений см. в разделе [исключения: `try...with` Выражение](exception-handling/the-try-with-expression.md).

## <a name="variable-patterns"></a>Шаблоны переменных

Шаблон переменной присваивает сравниваемое значение имени переменной, которое становится доступным для использования в выполняемом выражении справа от `->` символов. Отдельно, шаблон переменной соответствует любым входным данным, но шаблоны переменных часто используются внутри других шаблонов, что позволяет более сложные структуры, такие как кортежи и массивы позволяет разлагать на переменные.

В следующем примере шаблон переменной внутри шаблона кортежа.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4805.fs)]

## <a name="as-pattern"></a>как шаблон

`as` Шаблон — это шаблон, который имеет `as` предложение, добавленным к нему. `as` Предложение привязывает подобранное значение к имени, который может использоваться в выполняемом выражении `match` выражения, или, в случае, когда этот шаблон используется в `let` привязки, имя добавляется в качестве привязки в локальную область видимости.

В следующем примере используется `as` шаблон.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4806.fs)]

## <a name="or-pattern"></a>ИЛИ шаблон

Шаблон OR используется в том случае, когда входные данные могут соответствовать нескольким шаблонам и требуется выполнить тот же код, в результате. Типы обеих сторон шаблона OR должны быть совместимы.

Ниже приведен пример шаблона OR.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4807.fs)]

## <a name="and-pattern"></a>И шаблон

Шаблон AND требует, что входные данные соответствовали двум шаблонам. Типы обеих сторон шаблона AND должны быть совместимы.

Следующий пример аналогичен `detectZeroTuple` показано [шаблон кортежа](https://msdn.microsoft.com/library/#tuple) далее в этой статье, но здесь оба `var1` и `var2` получаются как значения с помощью шаблона.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4808.fs)]

## <a name="cons-pattern"></a>Шаблон cons-списка

Шаблон cons-списка используется для разложения списка на первый элемент, *head*и список, содержащий остальные элементы, *заключительного*.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4809.fs)]

## <a name="list-pattern"></a>Шаблон списка

Шаблон списка позволяет списков позволяет разлагать на ряд элементов. Сам по себе шаблон списка может соответствовать только спискам определенным количеством элементов.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4810.fs)]

## <a name="array-pattern"></a>Шаблон массива

Шаблон массива сходен с шаблоном списка и может использоваться для разложения массивов определенной длины.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4811.fs)]

## <a name="parenthesized-pattern"></a>Шаблон в круглых скобках

Можно группировать круглые скобки вокруг шаблонов для достижения требуемой ассоциативности. В следующем примере круглые скобки используются для управления ассоциативностью между шаблоном AND и шаблоном cons-списка.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4812.fs)]

## <a name="tuple-pattern"></a>Шаблон кортежа

Шаблон кортежа соответствует входным данным в форме кортежа и позволяет кортежа позволяет разлагать на составляющие его элементы с помощью переменных подбора шаблона для каждой позиции в кортеже.

В следующем примере демонстрируется шаблон кортежа и также используются литеральные шаблоны, шаблоны переменных и Шаблон подстановочного знака.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4813.fs)]

## <a name="record-pattern"></a>Шаблон записи

Шаблон записи используется для разложения записей с целью извлечения значений полей. Шаблон не обязательно должен ссылаться на все поля в записи; пропущенные поля просто не участвуют в сравнении и не извлекаются.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4814.fs)]

## <a name="wildcard-pattern"></a>Шаблон подстановочного знака

Шаблон подстановочного знака представляется подчеркиванием (`_`) знака и соответствует любым входным данным, так же, как и шаблон переменной, за исключением того, что входные данные удаляются, а не присваивается переменной. Шаблон подстановочного знака части используется внутри других шаблонов как заполнитель для значений, которые не требуются в выражении справа от `->` символов. Шаблон подстановочного знака также часто используется в конце списка шаблонов в соответствии с любой несопоставленных входных данных. Шаблон подстановочного знака демонстрируется во многих примерах кода в этом разделе. См. предыдущий код для примера.

## <a name="patterns-that-have-type-annotations"></a>Шаблоны, имеющие аннотации типов

Шаблоны могут иметь аннотации типов. Они ведут себя как другие аннотации типов и способствуют в определении типа. Круглые скобки необходимы для аннотации типов в шаблонах. В следующем коде показано шаблон, имеющий аннотацию типа.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4815.fs)]

## <a name="type-test-pattern"></a>Шаблон проверки типа

Шаблон проверки типа используется для сопоставления входных данных с типом. Если входным типом является сопоставления (или производный тип) типа, указанного в шаблоне, сопоставление выполняется успешно.

В следующем примере шаблон проверки типа.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4816.fs)]

## <a name="null-pattern"></a>Шаблон NULL

Шаблон null соответствует значению null, которое может появиться при работе с типами, допускающими значение null. Шаблоны NULL часто используются при взаимодействии с кодом .NET Framework. Например, значение, возвращаемое .NET API может быть входными данными для `match` выражение. Вы можете управлять выполнением программы на основе ли возвращаемое значение равно null, а также на основе других характеристик возвращенного значения. Шаблон null можно использовать для предотвращения значения null в остальные программы составляющие.

В следующем примере используется шаблон null и шаблон переменной.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4817.fs)]

## <a name="see-also"></a>См. также

- [Выражения match](match-expressions.md)
- [Активные шаблоны](active-patterns.md)
- [Справочник по языку F#](index.md)
