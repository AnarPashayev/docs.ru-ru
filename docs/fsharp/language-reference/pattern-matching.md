---
title: Сопоставление шаблонов
description: Сведения о том, как шаблоны F# используются для сравнения данных с логическими структурами, разложения данных на составляющие части или извлечения информации из данных.
ms.date: 10/27/2019
ms.openlocfilehash: 1acb795cbe5581898ae5e1439098f906a8a16b93
ms.sourcegitcommit: ad800f019ac976cb669e635fb0ea49db740e6890
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2019
ms.locfileid: "73041012"
---
# <a name="pattern-matching"></a>Сопоставление шаблонов

Шаблоны — это правила для преобразования входных данных. Они используются на всех F# языках для сравнения данных с логической структурой или структурами, разложения данных в составные части или извлечения информации из данных различными способами.

## <a name="remarks"></a>Заметки

Шаблоны используются во многих языковых конструкциях, например в `match` выражении. Они используются при обработке аргументов для функций в `let` привязках, лямбда-выражениях и в обработчиках исключений, связанных с выражением `try...with`. Дополнительные сведения см. в разделе [выражения Match](match-expressions.md), [Привязка let](./functions/let-bindings.md), [лямбда-выражения: ключевое слово `fun`](./functions/lambda-expressions-the-fun-keyword.md)и [исключения: выражение `try...with`](./exception-handling/the-try-with-expression.md).

Например, в выражении `match` *шаблон* соответствует символу вертикальной черты.

```fsharp
match expression with
| pattern [ when condition ] -> result-expression
...
```

Каждый шаблон выступает в качестве правила для преобразования входных данных каким-либо образом. В `match` выражении каждый шаблон просматривается, в свою очередь, чтобы проверить, совместимы ли входные данные с шаблоном. При обнаружении совпадения выполняется результирующее выражение. Если совпадение не найдено, проверяется следующее правило шаблона. Необязательная часть *условия* when объясняется в [выражениях Match](match-expressions.md).

Поддерживаемые шаблоны показаны в следующей таблице. Во время выполнения входные данные тестируются по каждому из следующих шаблонов в порядке, указанном в таблице, а шаблоны применяются рекурсивно, от первого до последнего, как они отображаются в коде, и слева направо для шаблонов в каждой строке.

|Название|Описание|Пример|
|----|-----------|-------|
|Шаблон константы|Любой числовой, символьный или строковый литерал, константа перечисления или определенный литеральный идентификатор|`1.0`, `"test"`, `30`, `Color.Red`|
|Шаблон идентификатора|Значение варианта для размеченного объединения, метки исключения или активного варианта шаблона|`Some(x)`<br /><br />`Failure(msg)`|
|Шаблон переменной|*identifier*|`a`|
|шаблон `as`|*шаблон* в качестве *идентификатора*|`(a, b) as tuple1`|
|ИЛИ шаблон|*pattern1* &#124; *pattern2*|<code>([h] &#124; [h; _])</code>|
|И шаблон|*pattern1* &amp; *pattern2*|`(a, b) & (_, "test")`|
|Шаблон «против»|*идентификатор* :: *List-identifier*|`h :: t`|
|Шаблон списка|[ *pattern_1*;...; *pattern_n* ]|`[ a; b; c ]`|
|Шаблон массива|[&#124; *pattern_1*;..; *pattern_n* &#124;]|<code>[&#124; a; b; c &#124;]</code>|
|Шаблон в круглых скобках|( *шаблон* )|`( a )`|
|Шаблон кортежа|( *pattern_1*,..., *pattern_n* )|`( a, b )`|
|Шаблон записи|{ *идентификатор1* = *pattern_1*;...; *identifier_n* = *pattern_n* }|`{ Name = name; }`|
|Шаблон подстановочного знака|_|`_`|
|Шаблон вместе с аннотацией типа|*шаблон* : *тип*|`a : int`|
|Шаблон проверки типа|:? *введите* [как *идентификатор* ]|`:? System.DateTime as dt`|
|Шаблон NULL|null|`null`|

## <a name="constant-patterns"></a>Шаблоны констант

Шаблоны констант — это числовые, символьные и строковые литералы, константы перечисления (с включаемым именем типа перечисления). Выражение `match`, имеющее только постоянные шаблоны, можно сравнивать с оператором case на других языках. Входные данные сравниваются с литеральным значением, а шаблон соответствует, если значения равны. Тип литерала должен быть совместим с типом входных данных.

В следующем примере демонстрируется использование литеральных шаблонов, а также используется шаблон переменной и шаблон или.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4801.fs)]

Еще один пример литерального шаблона — это шаблон, основанный на константах перечисления. При использовании констант перечисления необходимо указать имя типа перечисления.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4802.fs)]

## <a name="identifier-patterns"></a>Шаблоны идентификаторов

Если шаблон представляет собой строку символов, образующих допустимый идентификатор, форма идентификатора определяет способ сопоставления шаблона. Если идентификатор длиннее одного символа и начинается с символа верхнего регистра, компилятор пытается выполнить сопоставление с шаблоном идентификатора. Идентификатором для этого шаблона может быть значение, помеченное атрибутом Literal, вариантом размеченного объединения, идентификатором исключения или активным шаблоном. Если соответствующий идентификатор не найден, сопоставление завершается ошибкой, а следующее правило шаблона, шаблон переменной, сравнивается с входными данными.

Шаблоны размеченного объединения могут быть простыми именованными вариантами или иметь значение или кортеж, содержащий несколько значений. Если имеется значение, необходимо указать идентификатор для этого значения. В случае кортежа необходимо предоставить шаблон кортежа с идентификатором для каждого элемента кортежа или идентификатором с именем поля для одного или нескольких именованных полей объединения. Примеры см. в примерах кода в этом разделе.

Тип `option` — это размеченное объединение, которое имеет два варианта: `Some` и `None`. Один вариант (`Some`) имеет значение, а другое (`None`) — только именованный вариант. Таким образом, `Some` должен иметь переменную для значения, связанного с `Some`ным вариантом, но `None` должен быть сам по себе. В следующем коде переменной `var1` присваивается значение, полученное путем сопоставления с `Some`ным вариантом.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4803.fs)]

В следующем примере `PersonName` размеченное объединение содержит сочетание строк и символов, представляющих возможные формы имен. Варианты размеченного объединения: `FirstOnly`, `LastOnly`и `FirstLast`.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4804.fs)]

Для размеченных объединений с именованными полями используется знак равенства (=) для извлечения значения именованного поля. Например, рассмотрим размеченное объединение с объявлением, как показано ниже.

```fsharp
type Shape =
    | Rectangle of height : float * width : float
    | Circle of radius : float
```

Именованные поля можно использовать в выражении сопоставления шаблонов следующим образом.

```fsharp
let matchShape shape =
    match shape with
    | Rectangle(height = h) -> printfn "Rectangle with length %f" h
    | Circle(r) -> printfn "Circle with radius %f" r
```

Использование именованного поля является необязательным, поэтому в предыдущем примере оба `Circle(r)` и `Circle(radius = r)` имеют одинаковый результат.

При указании нескольких полей используйте точку с запятой (;) в качестве разделителя.

```fsharp
match shape with
| Rectangle(height = h; width = w) -> printfn "Rectangle with height %f and width %f" h w
| _ -> ()
```

Активные шаблоны позволяют определить более сложное сопоставление пользовательских шаблонов. Дополнительные сведения об активных шаблонах см. в разделе [Активные закономерности](active-patterns.md).

Случай, когда идентификатор является исключением, используется в сопоставлении шаблонов в контексте обработчиков исключений. Сведения о сопоставлении шаблонов в обработке исключений см. [в разделе Exceptions: the `try...with` выражение](./exception-handling/the-try-with-expression.md).

## <a name="variable-patterns"></a>Шаблоны переменных

Шаблон переменной присваивает значение, совпадающее с именем переменной, которое затем можно использовать в выражении выполнения справа от символа `->`. Только шаблон переменной соответствует любым входным данным, но шаблоны переменных часто появляются в других шаблонах, поэтому для реализации более сложных структур, таких как кортежи и массивы, следует разложить их на переменные.

В следующем примере демонстрируется шаблон переменной в шаблоне кортежа.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4805.fs)]

## <a name="as-pattern"></a>Шаблон as

Шаблон `as` — это шаблон, к которому добавляется предложение `as`. Предложение `as` привязывает сопоставленное значение к имени, которое может использоваться в выражении выполнения выражения `match`, или, если этот шаблон используется в привязке `let`, имя добавляется в качестве привязки в локальную область.

В следующем примере используется шаблон `as`.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4806.fs)]

## <a name="or-pattern"></a>ИЛИ шаблон

Шаблон или используется, если входные данные могут соответствовать нескольким шаблонам и вы хотите выполнить тот же код в результате. Типы обеих сторон шаблона или должны быть совместимы.

В следующем примере демонстрируется шаблон или.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4807.fs)]

## <a name="and-pattern"></a>И шаблон

Шаблон и требует, чтобы входные данные соответствовали двум шаблонам. Типы обеих сторон шаблона и должны быть совместимы.

Следующий пример похож на `detectZeroTuple`, показанный в разделе [шаблон кортежа](https://msdn.microsoft.com/library/#tuple) далее в этом разделе, но в данном случае `var1` и `var2` получаются в виде значений с помощью шаблона и.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4808.fs)]

## <a name="cons-pattern"></a>Шаблон «против»

Шаблон недостатков используется для разбиения списка на первый элемент, *заголовок*и список, содержащий остальные элементы, *хвост*.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4809.fs)]

## <a name="list-pattern"></a>Шаблон списка

Шаблон списка позволяет разложить списки на несколько элементов. Сам шаблон списка может сопоставлять только списки определенного числа элементов.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4810.fs)]

## <a name="array-pattern"></a>Шаблон массива

Шаблон массива напоминает шаблон списка и может использоваться для разложения массивов определенной длины.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4811.fs)]

## <a name="parenthesized-pattern"></a>Шаблон в круглых скобках

Круглые скобки могут быть сгруппированы вокруг шаблонов для достижения требуемой ассоциативности. В следующем примере круглые скобки используются для управления ассоциативностью между шаблоном и и шаблоном недостатка.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4812.fs)]

## <a name="tuple-pattern"></a>Шаблон кортежа

Шаблон кортежа соответствует входным данным в форме кортежа и позволяет разложить кортеж в составные элементы с помощью переменных сопоставления шаблонов для каждой из позиций в кортеже.

В следующем примере демонстрируется шаблон кортежа, а также используются литеральные шаблоны, шаблоны переменных и шаблон с подстановочными знаками.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4813.fs)]

## <a name="record-pattern"></a>Шаблон записи

Шаблон записи используется для разложения записей, чтобы извлечь значения полей. Шаблон не должен ссылаться на все поля записи; все пропущенные поля просто не участвуют в сопоставлении и не извлекаются.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4814.fs)]

## <a name="wildcard-pattern"></a>Шаблон подстановочного знака

Шаблон подстановочного знака представлен символом подчеркивания (`_`) и соответствует любым входным данным, как и шаблону переменной, за исключением того, что входные данные удаляются, а не присваиваются переменной. Шаблон шаблона часто используется в других шаблонах в качестве заполнителя для значений, которые не требуются в выражении справа от символа `->`. Шаблон с подстановочным знаком также часто используется в конце списка шаблонов для сопоставления с любыми несоответствующими входными данными. Шаблон с подстановочными знаками демонстрируется во многих примерах кода в этом разделе. См. Приведенный выше код для одного примера.

## <a name="patterns-that-have-type-annotations"></a>Шаблоны с аннотациями типов

Шаблоны могут иметь аннотации типов. Они ведут себя так же, как и другие аннотации типа и пошаговое определение, как и другие заметки типа. Для заметок типа в шаблонах требуются круглые скобки. В следующем коде показан шаблон с аннотацией типа.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4815.fs)]

## <a name="type-test-pattern"></a>Шаблон проверки типа

Шаблон проверки типа используется для сопоставления входных данных с типом. Если тип входных данных соответствует типу (или производному типу) типа, указанного в шаблоне, сопоставление выполняется с ошибкой.

В следующем примере показан шаблон проверки типа.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4816.fs)]

Если проверяется только идентификатор определенного производного типа, `as identifier` часть шаблона не требуется, как показано в следующем примере:

```fsharp
type A() = class end
type B() = inherit A()
type C() = inherit A()

let m (a: A) =
    match a with
    | :? B -> printfn "It's a B"
    | :? C -> printfn "It's a C"
    | _ -> ()
```

## <a name="null-pattern"></a>Шаблон NULL

Шаблон NULL соответствует значению NULL, которое может появиться при работе с типами, допускающими значение null. Шаблоны NULL часто используются при взаимодействии с .NET Frameworkным кодом. Например, возвращаемое значение API .NET может быть входными данными для `match` выражения. Можно управлять выполнением программы в зависимости от того, имеет ли возвращаемое значение значение null, а также другие характеристики возвращаемого значения. Можно использовать шаблон NULL, чтобы предотвратить распространение значений NULL на остальную часть программы.

В следующем примере используется шаблон NULL и шаблон переменной.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4817.fs)]

## <a name="see-also"></a>См. также

- [Выражения match](match-expressions.md)
- [Активные шаблоны](active-patterns.md)
- [Справочник по языку F#](index.md)
