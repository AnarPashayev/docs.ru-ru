---
title: Классы
description: Сведения о F# том, как классы являются типами, представляющими объекты, которые могут иметь свойства, методы и события.
ms.date: 05/16/2016
ms.openlocfilehash: 5c012d028bc1f89e3e9f5969b3461faab9aad3a0
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/30/2019
ms.locfileid: "68630441"
---
# <a name="classes"></a><span data-ttu-id="726cc-103">Классы</span><span class="sxs-lookup"><span data-stu-id="726cc-103">Classes</span></span>

<span data-ttu-id="726cc-104">*Классы* — это типы, представляющие объекты, которые могут иметь свойства, методы и события.</span><span class="sxs-lookup"><span data-stu-id="726cc-104">*Classes* are types that represent objects that can have properties, methods, and events.</span></span>

## <a name="syntax"></a><span data-ttu-id="726cc-105">Синтаксис</span><span class="sxs-lookup"><span data-stu-id="726cc-105">Syntax</span></span>

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a><span data-ttu-id="726cc-106">Примечания</span><span class="sxs-lookup"><span data-stu-id="726cc-106">Remarks</span></span>

<span data-ttu-id="726cc-107">Классы представляют фундаментальное описание типов объектов .NET. класс является концепцией основного типа, поддерживающей объектно-ориентированное F#программирование в.</span><span class="sxs-lookup"><span data-stu-id="726cc-107">Classes represent the fundamental description of .NET object types; the class is the primary type concept that supports object-oriented programming in F#.</span></span>

<span data-ttu-id="726cc-108">В приведенном выше синтаксисе `type-name` — любой допустимый идентификатор.</span><span class="sxs-lookup"><span data-stu-id="726cc-108">In the preceding syntax, the `type-name` is any valid identifier.</span></span> <span data-ttu-id="726cc-109">`type-params` Описывает необязательные параметры универсального типа.</span><span class="sxs-lookup"><span data-stu-id="726cc-109">The `type-params` describes optional generic type parameters.</span></span> <span data-ttu-id="726cc-110">Он состоит из имен параметров типа и ограничений, заключенных в угловые `>`скобки (`<` и).</span><span class="sxs-lookup"><span data-stu-id="726cc-110">It consists of type parameter names and constraints enclosed in angle brackets (`<` and `>`).</span></span> <span data-ttu-id="726cc-111">Дополнительные сведения см. в разделе [универсальные шаблоны](./generics/index.md) и [ограничения](./generics/constraints.md).</span><span class="sxs-lookup"><span data-stu-id="726cc-111">For more information, see [Generics](./generics/index.md) and [Constraints](./generics/constraints.md).</span></span> <span data-ttu-id="726cc-112">`parameter-list` Описывает параметры конструктора.</span><span class="sxs-lookup"><span data-stu-id="726cc-112">The `parameter-list` describes constructor parameters.</span></span> <span data-ttu-id="726cc-113">Первый модификатор доступа относится к типу; второй объект относится к основному конструктору.</span><span class="sxs-lookup"><span data-stu-id="726cc-113">The first access modifier pertains to the type; the second pertains to the primary constructor.</span></span> <span data-ttu-id="726cc-114">В обоих случаях значение по умолчанию `public`—.</span><span class="sxs-lookup"><span data-stu-id="726cc-114">In both cases, the default is `public`.</span></span>

<span data-ttu-id="726cc-115">Базовый класс для класса указывается с помощью `inherit` ключевого слова.</span><span class="sxs-lookup"><span data-stu-id="726cc-115">You specify the base class for a class by using the `inherit` keyword.</span></span> <span data-ttu-id="726cc-116">Для конструктора базового класса необходимо указать аргументы в скобках.</span><span class="sxs-lookup"><span data-stu-id="726cc-116">You must supply arguments, in parentheses, for the base class constructor.</span></span>

<span data-ttu-id="726cc-117">Поля или значения функций, локальные для класса, объявляются с помощью `let` привязок, поэтому необходимо следовать общим правилам для `let` привязок.</span><span class="sxs-lookup"><span data-stu-id="726cc-117">You declare fields or function values that are local to the class by using `let` bindings, and you must follow the general rules for `let` bindings.</span></span> <span data-ttu-id="726cc-118">`do-bindings` Раздел содержит код, выполняемый при создании объекта.</span><span class="sxs-lookup"><span data-stu-id="726cc-118">The `do-bindings` section includes code to be executed upon object construction.</span></span>

<span data-ttu-id="726cc-119">`member-list` Содержит дополнительные конструкторы, объявления экземпляров и статических методов, объявления интерфейсов, абстрактные привязки и объявления свойств и событий.</span><span class="sxs-lookup"><span data-stu-id="726cc-119">The `member-list` consists of additional constructors, instance and static method declarations, interface declarations, abstract bindings, and property and event declarations.</span></span> <span data-ttu-id="726cc-120">Они описаны в разделе [элементы](./members/index.md).</span><span class="sxs-lookup"><span data-stu-id="726cc-120">These are described in [Members](./members/index.md).</span></span>

<span data-ttu-id="726cc-121">Объект `identifier` , используемый с ключевым словом Optional `as` , задает имя переменной экземпляра или собственный идентификатор, который можно использовать в определении типа для ссылки на экземпляр типа.</span><span class="sxs-lookup"><span data-stu-id="726cc-121">The `identifier` that is used with the optional `as` keyword gives a name to the instance variable, or self identifier, which can be used in the type definition to refer to the instance of the type.</span></span> <span data-ttu-id="726cc-122">Дополнительные сведения см. в подразделе «собственные идентификаторы» далее в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="726cc-122">For more information, see the section Self Identifiers later in this topic.</span></span>

<span data-ttu-id="726cc-123">Ключевые слова `class` и `end` , которые отмечают начало и конец определения, являются необязательными.</span><span class="sxs-lookup"><span data-stu-id="726cc-123">The keywords `class` and `end` that mark the start and end of the definition are optional.</span></span>

<span data-ttu-id="726cc-124">Взаимно рекурсивные типы, которые являются типами, ссылающимися друг на друга, объединяются вместе с ключевым `and` словом так же, как и взаимно рекурсивные функции.</span><span class="sxs-lookup"><span data-stu-id="726cc-124">Mutually recursive types, which are types that reference each other, are joined together with the `and` keyword just as mutually recursive functions are.</span></span> <span data-ttu-id="726cc-125">Пример см. в разделе взаимно рекурсивные типы.</span><span class="sxs-lookup"><span data-stu-id="726cc-125">For an example, see the section Mutually Recursive Types.</span></span>

## <a name="constructors"></a><span data-ttu-id="726cc-126">Конструкторы</span><span class="sxs-lookup"><span data-stu-id="726cc-126">Constructors</span></span>

<span data-ttu-id="726cc-127">Конструктор — это код, создающий экземпляр типа класса.</span><span class="sxs-lookup"><span data-stu-id="726cc-127">The constructor is code that creates an instance of the class type.</span></span> <span data-ttu-id="726cc-128">Конструкторы для классов работают несколько иначе, F# чем в других языках .NET.</span><span class="sxs-lookup"><span data-stu-id="726cc-128">Constructors for classes work somewhat differently in F# than they do in other .NET languages.</span></span> <span data-ttu-id="726cc-129">В F# классе всегда существует первичный конструктор, аргументы которого описаны в `parameter-list` разделе, который следует за именем типа, а `let` тело состоит из привязок (и `let rec`) в начале объявления класса и `do` следующие привязки.</span><span class="sxs-lookup"><span data-stu-id="726cc-129">In an F# class, there is always a primary constructor whose arguments are described in the `parameter-list` that follows the type name, and whose body consists of the `let` (and `let rec`) bindings at the start of the class declaration and the `do` bindings that follow.</span></span> <span data-ttu-id="726cc-130">Аргументы первичного конструктора находятся в области действия во всем объявлении класса.</span><span class="sxs-lookup"><span data-stu-id="726cc-130">The arguments of the primary constructor are in scope throughout the class declaration.</span></span>

<span data-ttu-id="726cc-131">Можно добавить дополнительные конструкторы, используя `new` ключевое слово для добавления члена следующим образом:</span><span class="sxs-lookup"><span data-stu-id="726cc-131">You can add additional constructors by using the `new` keyword to add a member, as follows:</span></span>

<span data-ttu-id="726cc-132">`new`(`argument-list`) = `constructor-body`</span><span class="sxs-lookup"><span data-stu-id="726cc-132">`new`(`argument-list`) = `constructor-body`</span></span>

<span data-ttu-id="726cc-133">Тело нового конструктора должно вызывать первичный конструктор, который указан в верхней части объявления класса.</span><span class="sxs-lookup"><span data-stu-id="726cc-133">The body of the new constructor must invoke the primary constructor that is specified at the top of the class declaration.</span></span>

<span data-ttu-id="726cc-134">В следующем примере показана эта концепция.</span><span class="sxs-lookup"><span data-stu-id="726cc-134">The following example illustrates this concept.</span></span> <span data-ttu-id="726cc-135">В следующем коде `MyClass` имеет два конструктора — первичный конструктор, который принимает два аргумента и еще один конструктор, не принимающий аргументов.</span><span class="sxs-lookup"><span data-stu-id="726cc-135">In the following code, `MyClass` has two constructors, a primary constructor that takes two arguments and another constructor that takes no arguments.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]

## <a name="let-and-do-bindings"></a><span data-ttu-id="726cc-136">Привязка let и do</span><span class="sxs-lookup"><span data-stu-id="726cc-136">let and do Bindings</span></span>

<span data-ttu-id="726cc-137">Привязки `let` и`do` в определении класса формируют тело конструктора первичного класса и поэтому выполняются при каждом создании экземпляра класса.</span><span class="sxs-lookup"><span data-stu-id="726cc-137">The `let` and `do` bindings in a class definition form the body of the primary class constructor, and therefore they run whenever a class instance is created.</span></span> <span data-ttu-id="726cc-138">`let` Если привязка является функцией, то она компилируется в элемент.</span><span class="sxs-lookup"><span data-stu-id="726cc-138">If a `let` binding is a function, then it is compiled into a member.</span></span> <span data-ttu-id="726cc-139">`let` Если привязка является значением, которое не используется ни в одной функции или члене, то оно компилируется в переменную, которая является локальной для конструктора.</span><span class="sxs-lookup"><span data-stu-id="726cc-139">If the `let` binding is a value that is not used in any function or member, then it is compiled into a variable that is local to the constructor.</span></span> <span data-ttu-id="726cc-140">В противном случае он компилируется в поле класса.</span><span class="sxs-lookup"><span data-stu-id="726cc-140">Otherwise, it is compiled into a field of the class.</span></span> <span data-ttu-id="726cc-141">Приведенные ниже `do` выражения компилируются в основной конструктор и выполняют код инициализации для каждого экземпляра.</span><span class="sxs-lookup"><span data-stu-id="726cc-141">The `do` expressions that follow are compiled into the primary constructor and execute initialization code for every instance.</span></span> <span data-ttu-id="726cc-142">Поскольку любые дополнительные конструкторы всегда вызывают первичный конструктор, `let` привязки и `do` привязки всегда выполняются независимо от того, какой конструктор вызывается.</span><span class="sxs-lookup"><span data-stu-id="726cc-142">Because any additional constructors always call the primary constructor, the `let` bindings and `do` bindings always execute regardless of which constructor is called.</span></span>

<span data-ttu-id="726cc-143">К полям, созданным `let` с помощью привязок, можно обращаться через методы и свойства класса, однако к ним нельзя получить доступ из статических методов, даже если статические методы принимают переменную экземпляра в качестве параметра.</span><span class="sxs-lookup"><span data-stu-id="726cc-143">Fields that are created by `let` bindings can be accessed throughout the methods and properties of the class; however, they cannot be accessed from static methods, even if the static methods take an instance variable as a parameter.</span></span> <span data-ttu-id="726cc-144">К ним нельзя получить доступ с помощью собственного идентификатора, если он существует.</span><span class="sxs-lookup"><span data-stu-id="726cc-144">They cannot be accessed by using the self identifier, if one exists.</span></span>

## <a name="self-identifiers"></a><span data-ttu-id="726cc-145">Собственные идентификаторы</span><span class="sxs-lookup"><span data-stu-id="726cc-145">Self Identifiers</span></span>

<span data-ttu-id="726cc-146">*Собственный идентификатор* — это имя, представляющее текущий экземпляр.</span><span class="sxs-lookup"><span data-stu-id="726cc-146">A *self identifier* is a name that represents the current instance.</span></span> <span data-ttu-id="726cc-147">Собственные идентификаторы `this` похожи на ключевое слово в C++ `Me` C# или в Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="726cc-147">Self identifiers resemble the `this` keyword in C# or C++ or `Me` in Visual Basic.</span></span> <span data-ttu-id="726cc-148">Собственный идентификатор можно определить двумя разными способами в зависимости от того, должен ли сам идентификатор находиться в области видимости для определения всего класса или только для отдельного метода.</span><span class="sxs-lookup"><span data-stu-id="726cc-148">You can define a self identifier in two different ways, depending on whether you want the self identifier to be in scope for the whole class definition or just for an individual method.</span></span>

<span data-ttu-id="726cc-149">Чтобы определить собственный идентификатор для всего класса, используйте `as` ключевое слово после закрывающих круглых скобок списка параметров конструктора и укажите имя идентификатора.</span><span class="sxs-lookup"><span data-stu-id="726cc-149">To define a self identifier for the whole class, use the `as` keyword after the closing parentheses of the constructor parameter list, and specify the identifier name.</span></span>

<span data-ttu-id="726cc-150">Чтобы определить собственный идентификатор только для одного метода, укажите собственный идентификатор в объявлении члена непосредственно перед именем метода и точкой (.) в качестве разделителя.</span><span class="sxs-lookup"><span data-stu-id="726cc-150">To define a self identifier for just one method, provide the self identifier in the member declaration, just before the method name and a period (.) as a separator.</span></span>

<span data-ttu-id="726cc-151">В следующем примере кода показаны два способа создания собственного идентификатора.</span><span class="sxs-lookup"><span data-stu-id="726cc-151">The following code example illustrates the two ways to create a self identifier.</span></span> <span data-ttu-id="726cc-152">В первой строке `as` ключевое слово используется для определения собственного идентификатора.</span><span class="sxs-lookup"><span data-stu-id="726cc-152">In the first line, the `as` keyword is used to define the self identifier.</span></span> <span data-ttu-id="726cc-153">В пятой строке идентификатор `this` используется для определения собственного идентификатора, область действия которого ограничена методом. `PrintMessage`</span><span class="sxs-lookup"><span data-stu-id="726cc-153">In the fifth line, the identifier `this` is used to define a self identifier whose scope is restricted to the method `PrintMessage`.</span></span>

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

<span data-ttu-id="726cc-154">В отличие от других языков .NET, можно присвоить себе собственный идентификатор. Вы не ограничены такими именами, как `self`, `Me`или `this`.</span><span class="sxs-lookup"><span data-stu-id="726cc-154">Unlike in other .NET languages, you can name the self identifier however you want; you are not restricted to names such as `self`, `Me`, or `this`.</span></span>

<span data-ttu-id="726cc-155">Собственный идентификатор, объявленный с `as` ключевым словом, не инициализируется до тех пор, `let` пока не будут выполнены привязки.</span><span class="sxs-lookup"><span data-stu-id="726cc-155">The self identifier that is declared with the `as` keyword is not initialized until after the `let` bindings are executed.</span></span> <span data-ttu-id="726cc-156">Поэтому его нельзя использовать в `let` привязках.</span><span class="sxs-lookup"><span data-stu-id="726cc-156">Therefore, it cannot be used in the `let` bindings.</span></span> <span data-ttu-id="726cc-157">Можно использовать собственный идентификатор в `do` разделе привязок.</span><span class="sxs-lookup"><span data-stu-id="726cc-157">You can use the self identifier in the `do` bindings section.</span></span>

## <a name="generic-type-parameters"></a><span data-ttu-id="726cc-158">Параметры универсального типа</span><span class="sxs-lookup"><span data-stu-id="726cc-158">Generic Type Parameters</span></span>

<span data-ttu-id="726cc-159">Параметры универсального типа задаются в угловых `>`скобках (`<` и) в виде одиночной кавычки, за которой следует идентификатор.</span><span class="sxs-lookup"><span data-stu-id="726cc-159">Generic type parameters are specified in angle brackets (`<` and `>`), in the form of a single quotation mark followed by an identifier.</span></span> <span data-ttu-id="726cc-160">Несколько параметров универсального типа разделяются запятыми.</span><span class="sxs-lookup"><span data-stu-id="726cc-160">Multiple generic type parameters are separated by commas.</span></span> <span data-ttu-id="726cc-161">Параметр универсального типа находится в области видимости во всем объявлении.</span><span class="sxs-lookup"><span data-stu-id="726cc-161">The generic type parameter is in scope throughout the declaration.</span></span> <span data-ttu-id="726cc-162">В следующем примере кода показано, как задать параметры универсального типа.</span><span class="sxs-lookup"><span data-stu-id="726cc-162">The following code example shows how to specify generic type parameters.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

<span data-ttu-id="726cc-163">Аргументы типа выводятся при использовании типа.</span><span class="sxs-lookup"><span data-stu-id="726cc-163">Type arguments are inferred when the type is used.</span></span> <span data-ttu-id="726cc-164">В следующем коде выводимый тип является последовательностью кортежей.</span><span class="sxs-lookup"><span data-stu-id="726cc-164">In the following code, the inferred type is a sequence of tuples.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]

## <a name="specifying-inheritance"></a><span data-ttu-id="726cc-165">Указание наследования</span><span class="sxs-lookup"><span data-stu-id="726cc-165">Specifying Inheritance</span></span>

<span data-ttu-id="726cc-166">`inherit` Предложение определяет прямой базовый класс, если таковой имеется.</span><span class="sxs-lookup"><span data-stu-id="726cc-166">The `inherit` clause identifies the direct base class, if there is one.</span></span> <span data-ttu-id="726cc-167">В F#поддерживается только один прямой базовый класс.</span><span class="sxs-lookup"><span data-stu-id="726cc-167">In F#, only one direct base class is allowed.</span></span> <span data-ttu-id="726cc-168">Интерфейсы, реализуемые классом, не считаются базовыми классами.</span><span class="sxs-lookup"><span data-stu-id="726cc-168">Interfaces that a class implements are not considered base classes.</span></span> <span data-ttu-id="726cc-169">Интерфейсы обсуждаются в разделе [интерфейсы](Interfaces.md) .</span><span class="sxs-lookup"><span data-stu-id="726cc-169">Interfaces are discussed in the [Interfaces](Interfaces.md) topic.</span></span>

<span data-ttu-id="726cc-170">Доступ к методам и свойствам базового класса из производного класса можно получить с помощью ключевого слова `base` Language в качестве идентификатора, за которым следует точка (.) и имя члена.</span><span class="sxs-lookup"><span data-stu-id="726cc-170">You can access the methods and properties of the base class from the derived class by using the language keyword `base` as an identifier, followed by a period (.) and the name of the member.</span></span>

<span data-ttu-id="726cc-171">Дополнительные сведения см. в разделе [Наследование](inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="726cc-171">For more information, see [Inheritance](inheritance.md).</span></span>

## <a name="members-section"></a><span data-ttu-id="726cc-172">Раздел членов</span><span class="sxs-lookup"><span data-stu-id="726cc-172">Members Section</span></span>

<span data-ttu-id="726cc-173">В этом разделе можно определить статические методы или экземпляры методов, свойства, реализации интерфейса, абстрактные элементы, объявления событий и дополнительные конструкторы.</span><span class="sxs-lookup"><span data-stu-id="726cc-173">You can define static or instance methods, properties, interface implementations, abstract members, event declarations, and additional constructors in this section.</span></span> <span data-ttu-id="726cc-174">Привязки let и Do не могут присутствовать в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="726cc-174">Let and do bindings cannot appear in this section.</span></span> <span data-ttu-id="726cc-175">Поскольку члены могут добавляться в различные F# типы в дополнение к классам, они обсуждаются в отдельной теме, [членах](./members/index.md).</span><span class="sxs-lookup"><span data-stu-id="726cc-175">Because members can be added to a variety of F# types in addition to classes, they are discussed in a separate topic, [Members](./members/index.md).</span></span>

## <a name="mutually-recursive-types"></a><span data-ttu-id="726cc-176">Взаимно рекурсивные типы</span><span class="sxs-lookup"><span data-stu-id="726cc-176">Mutually Recursive Types</span></span>

<span data-ttu-id="726cc-177">При определении типов, ссылающихся друг на друга циклически, вы объединяете определения типов с помощью `and` ключевого слова.</span><span class="sxs-lookup"><span data-stu-id="726cc-177">When you define types that reference each other in a circular way, you string together the type definitions by using the `and` keyword.</span></span> <span data-ttu-id="726cc-178">Ключевое слово `type` заменяет ключевое слово на все, кроме первого определения, следующим образом. `and`</span><span class="sxs-lookup"><span data-stu-id="726cc-178">The `and` keyword replaces the `type` keyword on all except the first definition, as follows.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

<span data-ttu-id="726cc-179">Выходные данные представляют собой список всех файлов в текущем каталоге.</span><span class="sxs-lookup"><span data-stu-id="726cc-179">The output is a list of all the files in the current directory.</span></span>

## <a name="when-to-use-classes-unions-records-and-structures"></a><span data-ttu-id="726cc-180">Когда следует использовать классы, объединения, записи и структуры</span><span class="sxs-lookup"><span data-stu-id="726cc-180">When to Use Classes, Unions, Records, and Structures</span></span>

<span data-ttu-id="726cc-181">Учитывая различные типы выборки, необходимо хорошо понимать, что каждый тип предназначен для выбора подходящего типа для конкретной ситуации.</span><span class="sxs-lookup"><span data-stu-id="726cc-181">Given the variety of types to choose from, you need to have a good understanding of what each type is designed for to select the appropriate type for a particular situation.</span></span> <span data-ttu-id="726cc-182">Классы предназначены для использования в контекстах объектно-ориентированного программирования.</span><span class="sxs-lookup"><span data-stu-id="726cc-182">Classes are designed for use in object-oriented programming contexts.</span></span> <span data-ttu-id="726cc-183">Объектно-ориентированное программирование является главным парадигмой, используемой в приложениях, написанных для .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="726cc-183">Object-oriented programming is the dominant paradigm used in applications that are written for the .NET Framework.</span></span> <span data-ttu-id="726cc-184">Если F# код должен тесно работать с .NET Framework или другой объектно-ориентированной библиотекой, и особенно в том случае, если необходимо расширить объектно-ориентированную систему типов, например библиотеку пользовательского интерфейса, то классы, вероятно, подходят.</span><span class="sxs-lookup"><span data-stu-id="726cc-184">If your F# code has to work closely with the .NET Framework or another object-oriented library, and especially if you have to extend from an object-oriented type system such as a UI library, classes are probably appropriate.</span></span>

<span data-ttu-id="726cc-185">Если вы не тесно взаимодействуете с объектно-ориентированным кодом или пишете код, который является автономным и, следовательно, защищен от частого взаимодействия с объектно-ориентированным кодом, следует рассмотреть возможность использования записей и размеченных объединений.</span><span class="sxs-lookup"><span data-stu-id="726cc-185">If you are not interoperating closely with object-oriented code, or if you are writing code that is self-contained and therefore protected from frequent interaction with object-oriented code, you should consider using records and discriminated unions.</span></span> <span data-ttu-id="726cc-186">В качестве более простой альтернативы иерархии объектов часто можно использовать одно, хорошо продуманное размеченное объединение, а также соответствующий код сопоставления шаблонов.</span><span class="sxs-lookup"><span data-stu-id="726cc-186">A single, well thought–out discriminated union, together with appropriate pattern matching code, can often be used as a simpler alternative to an object hierarchy.</span></span> <span data-ttu-id="726cc-187">Дополнительные сведения о размеченных объединениях см. в разделе [Размеченные объединения](discriminated-unions.md).</span><span class="sxs-lookup"><span data-stu-id="726cc-187">For more information about discriminated unions, see [Discriminated Unions](discriminated-unions.md).</span></span>

<span data-ttu-id="726cc-188">Записи имеют преимущество, чем классы, но записи не подходят, если требования типа превышают возможности, которые могут быть выполнены с простотой.</span><span class="sxs-lookup"><span data-stu-id="726cc-188">Records have the advantage of being simpler than classes, but records are not appropriate when the demands of a type exceed what can be accomplished with their simplicity.</span></span> <span data-ttu-id="726cc-189">Записи по сути являются простыми статистическими значениями, без отдельных конструкторов, которые могут выполнять пользовательские действия без скрытых полей и без реализации наследования и интерфейса.</span><span class="sxs-lookup"><span data-stu-id="726cc-189">Records are basically simple aggregates of values, without separate constructors that can perform custom actions, without hidden fields, and without inheritance or interface implementations.</span></span> <span data-ttu-id="726cc-190">Хотя элементы, такие как свойства и методы, можно добавлять к записям, чтобы сделать их поведение более сложным, поля, хранящиеся в записи, по-прежнему представляют собой простую статистическую функцию значений.</span><span class="sxs-lookup"><span data-stu-id="726cc-190">Although members such as properties and methods can be added to records to make their behavior more complex, the fields stored in a record are still a simple aggregate of values.</span></span> <span data-ttu-id="726cc-191">Дополнительные сведения о записях см. в разделе [записи](records.md).</span><span class="sxs-lookup"><span data-stu-id="726cc-191">For more information about records, see [Records](records.md).</span></span>

<span data-ttu-id="726cc-192">Структуры также полезны для небольших статистических данных, но они отличаются от классов и записей тем, что они являются типами значений .NET.</span><span class="sxs-lookup"><span data-stu-id="726cc-192">Structures are also useful for small aggregates of data, but they differ from classes and records in that they are .NET value types.</span></span> <span data-ttu-id="726cc-193">Классы и записи являются ссылочными типами .NET.</span><span class="sxs-lookup"><span data-stu-id="726cc-193">Classes and records are .NET reference types.</span></span> <span data-ttu-id="726cc-194">Семантика типов значений и ссылочных типов различается в том, что типы значений передаются по значению.</span><span class="sxs-lookup"><span data-stu-id="726cc-194">The semantics of value types and reference types are different in that value types are passed by value.</span></span> <span data-ttu-id="726cc-195">Это означает, что они копируются бит для бита, когда они передаются в качестве параметра или возвращаются из функции.</span><span class="sxs-lookup"><span data-stu-id="726cc-195">This means that they are copied bit for bit when they are passed as a parameter or returned from a function.</span></span> <span data-ttu-id="726cc-196">Они также хранятся в стеке или, если они используются в качестве поля, внедрены в родительский объект, а не хранятся в отдельном месте в куче.</span><span class="sxs-lookup"><span data-stu-id="726cc-196">They are also stored on the stack or, if they are used as a field, embedded inside the parent object instead of stored in their own separate location on the heap.</span></span> <span data-ttu-id="726cc-197">Таким образом, структуры подходят для часто используемых данных, когда издержки доступа к куче являются проблемой.</span><span class="sxs-lookup"><span data-stu-id="726cc-197">Therefore, structures are appropriate for frequently accessed data when the overhead of accessing the heap is a problem.</span></span> <span data-ttu-id="726cc-198">Дополнительные сведения о структурах см. в разделе [структуры](structures.md).</span><span class="sxs-lookup"><span data-stu-id="726cc-198">For more information about structures, see [Structures](structures.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="726cc-199">См. также</span><span class="sxs-lookup"><span data-stu-id="726cc-199">See also</span></span>

- [<span data-ttu-id="726cc-200">Справочник по языку F#</span><span class="sxs-lookup"><span data-stu-id="726cc-200">F# Language Reference</span></span>](index.md)
- [<span data-ttu-id="726cc-201">Члены</span><span class="sxs-lookup"><span data-stu-id="726cc-201">Members</span></span>](./members/index.md)
- [<span data-ttu-id="726cc-202">Наследование</span><span class="sxs-lookup"><span data-stu-id="726cc-202">Inheritance</span></span>](inheritance.md)
- [<span data-ttu-id="726cc-203">Интерфейсы</span><span class="sxs-lookup"><span data-stu-id="726cc-203">Interfaces</span></span>](interfaces.md)
