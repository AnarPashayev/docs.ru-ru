---
title: Классы
description: Сведения о F# том, как классы являются типами, представляющими объекты, которые могут иметь свойства, методы и события.
ms.date: 05/16/2016
ms.openlocfilehash: 5c012d028bc1f89e3e9f5969b3461faab9aad3a0
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/30/2019
ms.locfileid: "68630441"
---
# <a name="classes"></a>Классы

*Классы* — это типы, представляющие объекты, которые могут иметь свойства, методы и события.

## <a name="syntax"></a>Синтаксис

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a>Примечания

Классы представляют фундаментальное описание типов объектов .NET. класс является концепцией основного типа, поддерживающей объектно-ориентированное F#программирование в.

В приведенном выше синтаксисе `type-name` — любой допустимый идентификатор. `type-params` Описывает необязательные параметры универсального типа. Он состоит из имен параметров типа и ограничений, заключенных в угловые `>`скобки (`<` и). Дополнительные сведения см. в разделе [универсальные шаблоны](./generics/index.md) и [ограничения](./generics/constraints.md). `parameter-list` Описывает параметры конструктора. Первый модификатор доступа относится к типу; второй объект относится к основному конструктору. В обоих случаях значение по умолчанию `public`—.

Базовый класс для класса указывается с помощью `inherit` ключевого слова. Для конструктора базового класса необходимо указать аргументы в скобках.

Поля или значения функций, локальные для класса, объявляются с помощью `let` привязок, поэтому необходимо следовать общим правилам для `let` привязок. `do-bindings` Раздел содержит код, выполняемый при создании объекта.

`member-list` Содержит дополнительные конструкторы, объявления экземпляров и статических методов, объявления интерфейсов, абстрактные привязки и объявления свойств и событий. Они описаны в разделе [элементы](./members/index.md).

Объект `identifier` , используемый с ключевым словом Optional `as` , задает имя переменной экземпляра или собственный идентификатор, который можно использовать в определении типа для ссылки на экземпляр типа. Дополнительные сведения см. в подразделе «собственные идентификаторы» далее в этом разделе.

Ключевые слова `class` и `end` , которые отмечают начало и конец определения, являются необязательными.

Взаимно рекурсивные типы, которые являются типами, ссылающимися друг на друга, объединяются вместе с ключевым `and` словом так же, как и взаимно рекурсивные функции. Пример см. в разделе взаимно рекурсивные типы.

## <a name="constructors"></a>Конструкторы

Конструктор — это код, создающий экземпляр типа класса. Конструкторы для классов работают несколько иначе, F# чем в других языках .NET. В F# классе всегда существует первичный конструктор, аргументы которого описаны в `parameter-list` разделе, который следует за именем типа, а `let` тело состоит из привязок (и `let rec`) в начале объявления класса и `do` следующие привязки. Аргументы первичного конструктора находятся в области действия во всем объявлении класса.

Можно добавить дополнительные конструкторы, используя `new` ключевое слово для добавления члена следующим образом:

`new`(`argument-list`) = `constructor-body`

Тело нового конструктора должно вызывать первичный конструктор, который указан в верхней части объявления класса.

В следующем примере показана эта концепция. В следующем коде `MyClass` имеет два конструктора — первичный конструктор, который принимает два аргумента и еще один конструктор, не принимающий аргументов.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]

## <a name="let-and-do-bindings"></a>Привязка let и do

Привязки `let` и`do` в определении класса формируют тело конструктора первичного класса и поэтому выполняются при каждом создании экземпляра класса. `let` Если привязка является функцией, то она компилируется в элемент. `let` Если привязка является значением, которое не используется ни в одной функции или члене, то оно компилируется в переменную, которая является локальной для конструктора. В противном случае он компилируется в поле класса. Приведенные ниже `do` выражения компилируются в основной конструктор и выполняют код инициализации для каждого экземпляра. Поскольку любые дополнительные конструкторы всегда вызывают первичный конструктор, `let` привязки и `do` привязки всегда выполняются независимо от того, какой конструктор вызывается.

К полям, созданным `let` с помощью привязок, можно обращаться через методы и свойства класса, однако к ним нельзя получить доступ из статических методов, даже если статические методы принимают переменную экземпляра в качестве параметра. К ним нельзя получить доступ с помощью собственного идентификатора, если он существует.

## <a name="self-identifiers"></a>Собственные идентификаторы

*Собственный идентификатор* — это имя, представляющее текущий экземпляр. Собственные идентификаторы `this` похожи на ключевое слово в C++ `Me` C# или в Visual Basic. Собственный идентификатор можно определить двумя разными способами в зависимости от того, должен ли сам идентификатор находиться в области видимости для определения всего класса или только для отдельного метода.

Чтобы определить собственный идентификатор для всего класса, используйте `as` ключевое слово после закрывающих круглых скобок списка параметров конструктора и укажите имя идентификатора.

Чтобы определить собственный идентификатор только для одного метода, укажите собственный идентификатор в объявлении члена непосредственно перед именем метода и точкой (.) в качестве разделителя.

В следующем примере кода показаны два способа создания собственного идентификатора. В первой строке `as` ключевое слово используется для определения собственного идентификатора. В пятой строке идентификатор `this` используется для определения собственного идентификатора, область действия которого ограничена методом. `PrintMessage`

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

В отличие от других языков .NET, можно присвоить себе собственный идентификатор. Вы не ограничены такими именами, как `self`, `Me`или `this`.

Собственный идентификатор, объявленный с `as` ключевым словом, не инициализируется до тех пор, `let` пока не будут выполнены привязки. Поэтому его нельзя использовать в `let` привязках. Можно использовать собственный идентификатор в `do` разделе привязок.

## <a name="generic-type-parameters"></a>Параметры универсального типа

Параметры универсального типа задаются в угловых `>`скобках (`<` и) в виде одиночной кавычки, за которой следует идентификатор. Несколько параметров универсального типа разделяются запятыми. Параметр универсального типа находится в области видимости во всем объявлении. В следующем примере кода показано, как задать параметры универсального типа.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

Аргументы типа выводятся при использовании типа. В следующем коде выводимый тип является последовательностью кортежей.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]

## <a name="specifying-inheritance"></a>Указание наследования

`inherit` Предложение определяет прямой базовый класс, если таковой имеется. В F#поддерживается только один прямой базовый класс. Интерфейсы, реализуемые классом, не считаются базовыми классами. Интерфейсы обсуждаются в разделе [интерфейсы](Interfaces.md) .

Доступ к методам и свойствам базового класса из производного класса можно получить с помощью ключевого слова `base` Language в качестве идентификатора, за которым следует точка (.) и имя члена.

Дополнительные сведения см. в разделе [Наследование](inheritance.md).

## <a name="members-section"></a>Раздел членов

В этом разделе можно определить статические методы или экземпляры методов, свойства, реализации интерфейса, абстрактные элементы, объявления событий и дополнительные конструкторы. Привязки let и Do не могут присутствовать в этом разделе. Поскольку члены могут добавляться в различные F# типы в дополнение к классам, они обсуждаются в отдельной теме, [членах](./members/index.md).

## <a name="mutually-recursive-types"></a>Взаимно рекурсивные типы

При определении типов, ссылающихся друг на друга циклически, вы объединяете определения типов с помощью `and` ключевого слова. Ключевое слово `type` заменяет ключевое слово на все, кроме первого определения, следующим образом. `and`

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

Выходные данные представляют собой список всех файлов в текущем каталоге.

## <a name="when-to-use-classes-unions-records-and-structures"></a>Когда следует использовать классы, объединения, записи и структуры

Учитывая различные типы выборки, необходимо хорошо понимать, что каждый тип предназначен для выбора подходящего типа для конкретной ситуации. Классы предназначены для использования в контекстах объектно-ориентированного программирования. Объектно-ориентированное программирование является главным парадигмой, используемой в приложениях, написанных для .NET Framework. Если F# код должен тесно работать с .NET Framework или другой объектно-ориентированной библиотекой, и особенно в том случае, если необходимо расширить объектно-ориентированную систему типов, например библиотеку пользовательского интерфейса, то классы, вероятно, подходят.

Если вы не тесно взаимодействуете с объектно-ориентированным кодом или пишете код, который является автономным и, следовательно, защищен от частого взаимодействия с объектно-ориентированным кодом, следует рассмотреть возможность использования записей и размеченных объединений. В качестве более простой альтернативы иерархии объектов часто можно использовать одно, хорошо продуманное размеченное объединение, а также соответствующий код сопоставления шаблонов. Дополнительные сведения о размеченных объединениях см. в разделе [Размеченные объединения](discriminated-unions.md).

Записи имеют преимущество, чем классы, но записи не подходят, если требования типа превышают возможности, которые могут быть выполнены с простотой. Записи по сути являются простыми статистическими значениями, без отдельных конструкторов, которые могут выполнять пользовательские действия без скрытых полей и без реализации наследования и интерфейса. Хотя элементы, такие как свойства и методы, можно добавлять к записям, чтобы сделать их поведение более сложным, поля, хранящиеся в записи, по-прежнему представляют собой простую статистическую функцию значений. Дополнительные сведения о записях см. в разделе [записи](records.md).

Структуры также полезны для небольших статистических данных, но они отличаются от классов и записей тем, что они являются типами значений .NET. Классы и записи являются ссылочными типами .NET. Семантика типов значений и ссылочных типов различается в том, что типы значений передаются по значению. Это означает, что они копируются бит для бита, когда они передаются в качестве параметра или возвращаются из функции. Они также хранятся в стеке или, если они используются в качестве поля, внедрены в родительский объект, а не хранятся в отдельном месте в куче. Таким образом, структуры подходят для часто используемых данных, когда издержки доступа к куче являются проблемой. Дополнительные сведения о структурах см. в разделе [структуры](structures.md).

## <a name="see-also"></a>См. также

- [Справочник по языку F#](index.md)
- [Члены](./members/index.md)
- [Наследование](inheritance.md)
- [Интерфейсы](interfaces.md)
