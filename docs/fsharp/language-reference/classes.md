---
title: Классы
description: 'Узнайте, как классы F # представляют собой типы, представляющие объекты, которые могут иметь свойства, методы и события.'
ms.date: 05/16/2016
ms.openlocfilehash: fd6638e0f1c08cf667a73582e19b2bb5bba46e20
ms.sourcegitcommit: 7ef96827b161ef3fcde75f79d839885632e26ef1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "97970171"
---
# <a name="classes"></a>Классы

*Классы* — это типы, представляющие объекты, которые могут иметь свойства, методы и события.

## <a name="syntax"></a>Синтаксис

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a>Remarks

Классы представляют фундаментальное описание типов объектов .NET. класс является концепцией основного типа, поддерживающей объектно-ориентированное программирование в F #.

В приведенном выше синтаксисе `type-name` — любой допустимый идентификатор. `type-params`Описывает необязательные параметры универсального типа. Он состоит из имен параметров типа и ограничений, заключенных в угловые скобки ( `<` и `>` ). Дополнительные сведения см. в разделе [универсальные шаблоны](./generics/index.md) и [ограничения](./generics/constraints.md). `parameter-list`Описывает параметры конструктора. Первый модификатор доступа относится к типу; второй объект относится к основному конструктору. В обоих случаях значение по умолчанию — `public` .

Базовый класс для класса указывается с помощью `inherit` ключевого слова. Для конструктора базового класса необходимо указать аргументы в скобках.

Поля или значения функций, локальные для класса, объявляются с помощью `let` привязок, поэтому необходимо следовать общим правилам для `let` привязок. `do-bindings`Раздел содержит код, выполняемый при создании объекта.

`member-list`Содержит дополнительные конструкторы, объявления экземпляров и статических методов, объявления интерфейсов, абстрактные привязки и объявления свойств и событий. Они описаны в разделе [элементы](./members/index.md).

Объект `identifier` , используемый с `as` ключевым словом Optional, задает имя переменной экземпляра или собственный идентификатор, который можно использовать в определении типа для ссылки на экземпляр типа. Дополнительные сведения см. в подразделе «собственные идентификаторы» далее в этом разделе.

Ключевые слова `class` и `end` , которые отмечают начало и конец определения, являются необязательными.

Взаимно рекурсивные типы, которые являются типами, ссылающимися друг на друга, объединяются вместе с `and` ключевым словом так же, как и взаимно рекурсивные функции. Пример см. в разделе взаимно рекурсивные типы.

## <a name="constructors"></a>Конструкторы

Конструктор — это код, создающий экземпляр типа класса. Конструкторы для классов работают несколько иначе в F #, чем в других языках .NET. В классе F # всегда существует первичный конструктор, аргументы которого описаны в разделе `parameter-list` , который следует за именем типа, а текст состоит из `let` `let rec` привязок (и) в начале объявления класса и `do` привязок, которые следуют за ними. Аргументы первичного конструктора находятся в области действия во всем объявлении класса.

Можно добавить дополнительные конструкторы, используя `new` ключевое слово для добавления члена следующим образом:

`new`(`argument-list`) = `constructor-body`

Тело нового конструктора должно вызывать первичный конструктор, который указан в верхней части объявления класса.

В следующем примере показана эта концепция. В следующем коде `MyClass` имеет два конструктора — первичный конструктор, который принимает два аргумента и еще один конструктор, не принимающий аргументов.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]

## <a name="let-and-do-bindings"></a>Привязка let и do

`let`Привязки и `do` в определении класса формируют тело конструктора первичного класса и поэтому выполняются при каждом создании экземпляра класса. Если `let` Привязка является функцией, то она компилируется в элемент. Если `let` Привязка является значением, которое не используется ни в одной функции или члене, то оно компилируется в переменную, которая является локальной для конструктора. В противном случае он компилируется в поле класса. Приведенные `do` ниже выражения компилируются в основной конструктор и выполняют код инициализации для каждого экземпляра. Поскольку любые дополнительные конструкторы всегда вызывают первичный конструктор, `let` привязки и `do` привязки всегда выполняются независимо от того, какой конструктор вызывается.

К полям, созданным с помощью `let` привязок, можно обращаться через методы и свойства класса, однако к ним нельзя получить доступ из статических методов, даже если статические методы принимают переменную экземпляра в качестве параметра. К ним нельзя получить доступ с помощью собственного идентификатора, если он существует.

## <a name="self-identifiers"></a>Собственные идентификаторы

*Собственный идентификатор* — это имя, представляющее текущий экземпляр. Собственные идентификаторы похожи на `this` ключевое слово в C# или C++ или `Me` в Visual Basic. Собственный идентификатор можно определить двумя разными способами в зависимости от того, должен ли сам идентификатор находиться в области видимости для определения всего класса или только для отдельного метода.

Чтобы определить собственный идентификатор для всего класса, используйте `as` ключевое слово после закрывающих круглых скобок списка параметров конструктора и укажите имя идентификатора.

Чтобы определить собственный идентификатор только для одного метода, укажите собственный идентификатор в объявлении члена непосредственно перед именем метода и точкой (.) в качестве разделителя.

В следующем примере кода показаны два способа создания собственного идентификатора. В первой строке `as` ключевое слово используется для определения собственного идентификатора. В пятой строке идентификатор `this` используется для определения собственного идентификатора, область действия которого ограничена методом `PrintMessage` .

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

В отличие от других языков .NET, можно присвоить себе собственный идентификатор. Вы не ограничены такими именами, как `self` , `Me` или `this` .

Собственный идентификатор, объявленный с `as` ключевым словом, не инициализируется до тех пор, пока не будет создан базовый конструктор. Поэтому при использовании до или в базовом конструкторе `System.InvalidOperationException: The initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.` оно будет создано во время выполнения. Собственный идентификатор можно использовать свободно после базового конструктора, например в `let` привязках или `do` привязках.

## <a name="generic-type-parameters"></a>Параметры универсального типа

Параметры универсального типа задаются в угловых скобках ( `<` и `>` ) в виде одиночной кавычки, за которой следует идентификатор. Несколько параметров универсального типа разделяются запятыми. Параметр универсального типа находится в области видимости во всем объявлении. В следующем примере кода показано, как задать параметры универсального типа.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

Аргументы типа выводятся при использовании типа. В следующем коде выводимый тип является последовательностью кортежей.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]

## <a name="specifying-inheritance"></a>Указание наследования

`inherit`Предложение определяет прямой базовый класс, если таковой имеется. В F # допускается только один прямой базовый класс. Интерфейсы, реализуемые классом, не считаются базовыми классами. Интерфейсы обсуждаются в разделе [интерфейсы](Interfaces.md) .

Доступ к методам и свойствам базового класса из производного класса можно получить с помощью ключевого слова Language в `base` качестве идентификатора, за которым следует точка (.) и имя члена.

Дополнительные сведения см. в разделе [Наследование](inheritance.md).

## <a name="members-section"></a>Раздел членов

В этом разделе можно определить статические методы или экземпляры методов, свойства, реализации интерфейса, абстрактные элементы, объявления событий и дополнительные конструкторы. Привязки let и Do не могут присутствовать в этом разделе. Поскольку члены могут добавляться в различные типы F # в дополнение к классам, они обсуждаются в отдельной теме, [членах](./members/index.md).

## <a name="mutually-recursive-types"></a>Взаимно рекурсивные типы

При определении типов, ссылающихся друг на друга циклически, вы объединяете определения типов с помощью `and` ключевого слова. `and`Ключевое слово заменяет `type` ключевое слово на все, кроме первого определения, следующим образом.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

Выходные данные представляют собой список всех файлов в текущем каталоге.

## <a name="when-to-use-classes-unions-records-and-structures"></a>Когда следует использовать классы, объединения, записи и структуры

Учитывая различные типы выборки, необходимо хорошо понимать, что каждый тип предназначен для выбора подходящего типа для конкретной ситуации. Классы предназначены для использования в контекстах объектно-ориентированного программирования. Объектно-ориентированное программирование является главным парадигмой, используемой в приложениях, написанных для .NET Framework. Если код F # должен тесно работать с .NET Framework или другой объектно-ориентированной библиотекой, и особенно в том случае, если необходимо расширить объектно-ориентированную систему типов, такую как библиотека пользовательского интерфейса, то классы, вероятно, подходят.

Если вы не тесно взаимодействуете с объектно-ориентированным кодом или пишете код, который является автономным и, следовательно, защищен от частого взаимодействия с объектно-ориентированным кодом, следует рассмотреть возможность использования записей и размеченных объединений. В качестве более простой альтернативы иерархии объектов часто можно использовать одно, хорошо продуманное размеченное объединение, а также соответствующий код сопоставления шаблонов. Дополнительные сведения о размеченных объединениях см. в разделе [Размеченные объединения](discriminated-unions.md).

Записи имеют преимущество, чем классы, но записи не подходят, если требования типа превышают возможности, которые могут быть выполнены с простотой. Записи по сути являются простыми статистическими значениями, без отдельных конструкторов, которые могут выполнять пользовательские действия без скрытых полей и без реализации наследования и интерфейса. Хотя элементы, такие как свойства и методы, можно добавлять к записям, чтобы сделать их поведение более сложным, поля, хранящиеся в записи, по-прежнему представляют собой простую статистическую функцию значений. Дополнительные сведения о записях см. в разделе [записи](records.md).

Структуры также полезны для небольших статистических данных, но они отличаются от классов и записей тем, что они являются типами значений .NET. Классы и записи являются ссылочными типами .NET. Семантика типов значений и ссылочных типов различается в том, что типы значений передаются по значению. Это означает, что они копируются бит для бита, когда они передаются в качестве параметра или возвращаются из функции. Они также хранятся в стеке или, если они используются в качестве поля, внедрены в родительский объект, а не хранятся в отдельном месте в куче. Таким образом, структуры подходят для часто используемых данных, когда издержки доступа к куче являются проблемой. Дополнительные сведения о структурах см. в разделе [структуры](structures.md).

## <a name="see-also"></a>См. также

- [Справочник по языку F#](index.md)
- [Члены](./members/index.md)
- [Наследование](inheritance.md)
- [Интерфейсы](interfaces.md)
