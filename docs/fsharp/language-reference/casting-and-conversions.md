---
title: Приведение и преобразование
description: Узнайте, F# как язык программирования предоставляет операторы преобразования для арифметических преобразований между различными типами-примитивами.
ms.date: 02/20/2020
ms.openlocfilehash: 5f9727d14a7ae070e0f0f71fa0a0abe04f662071
ms.sourcegitcommit: 771c554c84ba38cbd4ac0578324ec4cfc979cf2e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/21/2020
ms.locfileid: "77543590"
---
# <a name="casting-and-conversions-f"></a>Приведение и преобразование (F#)

В этом разделе описывается поддержка преобразований типов F#в.

## <a name="arithmetic-types"></a>Арифметические типы

F#предоставляет операторы преобразования для арифметических преобразований между различными типами-примитивами, такими как целочисленные и плавающие точки. Операторы целочисленного и символьного преобразования имеют проверенные и непроверенные формы; Операторы с плавающей запятой и оператором преобразования `enum` не являются. Непроверенные формы определяются в `Microsoft.FSharp.Core.Operators`, а проверенные формы определяются в `Microsoft.FSharp.Core.Operators.Checked`. Проверенная форма проверяет наличие переполнения и создает исключение во время выполнения, если полученное значение превышает ограничения целевого типа.

Имя каждого из этих операторов совпадает с именем целевого типа. Например, в следующем коде, в котором типы имеют явно заметку, `byte` отображается с двумя разными значениями. Первое вхождение — это тип, а второй — оператор преобразования.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4401.fs)]

В следующей таблице показаны операторы преобразования, определенные F#в.

|Оператор|Description|
|--------|-----------|
|`byte`|Преобразование в Byte, 8-разрядный тип без знака.|
|`sbyte`|Преобразовать в байт со знаком.|
|`int16`|Преобразует в 16-разрядное целое число со знаком.|
|`uint16`|Преобразование в 16-битовое целое число без знака.|
|`int32, int`|Преобразование в 32-разрядное целое число со знаком.|
|`uint32`|Преобразование в 32-битовое целое число без знака.|
|`int64`|Преобразование в 64-разрядное целое число со знаком.|
|`uint64`|Преобразование в 64-битовое целое число без знака.|
|`nativeint`|Преобразовать в собственное целое число.|
|`unativeint`|Преобразование в собственное целое число без знака.|
|`float, double`|Преобразование в 64-разрядное число с плавающей запятой двойной точности (Double).|
|`float32, single`|Преобразование в 32-разрядное число с плавающей запятой одиночной точности (однозначная).|
|`decimal`|Преобразовать в `System.Decimal`.|
|`char`|Преобразование в `System.Char`, символ Юникода.|
|`enum`|Преобразование в перечисляемый тип.|

Помимо встроенных типов-примитивов, эти операторы можно использовать с типами, реализующими `op_Explicit` или `op_Implicit` методы с соответствующими сигнатурами. Например, оператор преобразования `int` работает с любым типом, предоставляющим статический метод `op_Explicit`, который принимает тип в качестве параметра и возвращает `int`. В качестве специального исключения для общего правила, которое методы не могут перегружаться типом возвращаемого значения, это можно сделать для `op_Explicit` и `op_Implicit`.

## <a name="enumerated-types"></a>Перечислимые типы

`enum` оператор является универсальным оператором, который принимает один параметр типа, представляющий тип `enum`, в который необходимо выполнить преобразование. При преобразовании в перечислимый тип определение типа пытается определить тип `enum`, в который необходимо выполнить преобразование. В следующем примере переменная `col1` не объявляется явно, но ее тип выводится из более поздней проверки на равенство. Таким образом, компилятор может вывести, что вы преобразуете в перечисление `Color`. Кроме того, можно указать аннотацию типа, как в случае с `col2` в следующем примере.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4402.fs)]

Можно также явно указать целевой тип перечисления в качестве параметра типа, как показано в следующем коде:

```fsharp
let col3 = enum<Color> 3
```

Обратите внимание, что приведенные перечисления работают только в том случае, если базовый тип перечисления совместим с преобразуемым типом. В следующем коде не удается скомпилировать преобразование из-за несоответствия между `int32` и `uint32`.

```fsharp
// Error: types are incompatible
let col4 : Color = enum 2u
```

Дополнительные сведения см. в разделе [перечисления](enumerations.md).

## <a name="casting-object-types"></a>Приведение типов объектов

Преобразование между типами в иерархии объектов является фундаментальным для объектно-ориентированного программирования. Существует два базовых типа преобразований: приведение к исполнению (исходящее) и приведение вниз (образование производных). Приведение вверх по иерархии означает приведение производного объекта к ссылке на базовый объект. Такое приведение гарантированно будет работать, если базовый класс находится в иерархии наследования производного класса. Приведение вниз к иерархии из базового объекта в ссылку на производный объект завершается, только если объект фактически является экземпляром правильного (производного) типа или типа, производного от целевого типа.

F#предоставляет операторы для таких типов преобразований. Оператор `:>` приводит иерархию, а оператор `:?>` приводит вниз к иерархии.

### <a name="upcasting"></a>Treat

Во многих объектно-ориентированных языках приведение является неявным; в F#правила отличаются друг от друга. При передаче аргументов в методы в типе объекта применяется автоматическое приведение. Однако для функций, связанных с let, в модуле не выполняется автоматическое приведение, если тип параметра не объявлен как гибкий тип. Дополнительные сведения см. в разделе [гибкие типы](flexible-Types.md).

Оператор `:>` выполняет статическое приведение, которое означает, что успешность приведения определяется во время компиляции. Если приведение, использующее `:>`, успешно компилируется, это допустимое приведение и не может привести к сбою во время выполнения.

Можно также использовать оператор `upcast` для выполнения такого преобразования. Следующее выражение задает преобразование в иерархию:

```fsharp
upcast expression
```

При использовании оператора CAST компилятор пытается определить тип, к которому выполняется преобразование, из контекста. Если компилятору не удается определить тип целевого объекта, компилятор сообщает об ошибке. Может потребоваться аннотация типа.

### <a name="downcasting"></a>Опуститься

Оператор `:?>` выполняет динамическое приведение, то есть успешность приведения определяется во время выполнения. Приведение, в котором используется оператор `:?>`, не проверяется во время компиляции. но во время выполнения предпринимается попытка приведения к указанному типу. Если объект совместим с целевым типом, приведение будет выполняться с ошибкой. Если объект несовместим с целевым типом, среда выполнения создает `InvalidCastException`.

Можно также использовать оператор `downcast` для выполнения динамического преобразования типов. Следующее выражение задает преобразование иерархии в тип, выводимый из контекста программы:

```fsharp
downcast expression
```

Как и для оператора `upcast`, если компилятор не может вывести конкретный целевой тип из контекста, он сообщает об ошибке. Может потребоваться аннотация типа.

В следующем коде показано использование операторов `:>` и `:?>`. В коде показано, что оператор `:?>` лучше использовать, если известно, что преобразование будет успешным, так как оно вызывает `InvalidCastException` в случае сбоя преобразования. Если неизвестно, что преобразование будет выполнено, то проверка типа, использующая `match` выражение, лучше, поскольку это позволяет избежать издержек, вызванных созданием исключения.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4403.fs)]

Поскольку универсальные операторы `downcast` и `upcast` полагаются на определение типа для определения аргумента и типа возвращаемого значения, в приведенном выше коде можно заменить

```fsharp
let base1 = d1 :> Base1
```

на

```fsharp
let base1: Base1 = upcast d1
```

Обратите внимание, что аннотация типа является обязательной, так как сама по себе `upcast` не может определить базовый класс.

## <a name="see-also"></a>См. также раздел

- [Справочник по языку F#](index.md)
