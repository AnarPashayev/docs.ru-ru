---
title: Последовательности
description: 'Узнайте, как использовать последовательности F # при наличии большой упорядоченной коллекции данных, но не обязательно должны использовать все элементы.'
ms.date: 11/04/2019
ms.openlocfilehash: fa5073f33b9dae52371c249bfb257a2446b4d26a
ms.sourcegitcommit: c37e8d4642fef647ebab0e1c618ecc29ddfe2a0f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/06/2020
ms.locfileid: "87855326"
---
# <a name="sequences"></a>Последовательности

*Последовательность* — это логический ряд элементов одного типа. Последовательности особенно полезны при наличии большой упорядоченной коллекции данных, но не обязательно должны использовать все элементы. Отдельные элементы последовательности вычисляются только по мере необходимости, поэтому последовательность может обеспечить лучшую производительность, чем список в ситуациях, когда не все элементы используются. Последовательности представлены `seq<'T>` типом, который является псевдонимом для <xref:System.Collections.Generic.IEnumerable%601> . Поэтому в качестве последовательности можно использовать любой тип .NET, реализующий <xref:System.Collections.Generic.IEnumerable%601> интерфейс. [Модуль Seq](https://msdn.microsoft.com/library/54e8f059-ca52-4632-9ae9-49685ee9b684) обеспечивает поддержку манипуляций с последовательностями.

> [!NOTE]
> Справочник по API docs.microsoft.com для F # не завершен. Если вы столкнулись с неработающими ссылками, используйте [документацию по основной библиотеке F #](https://fsharp.github.io/fsharp-core-docs/) .

## <a name="sequence-expressions"></a>Выражения последовательности

*Выражение последовательности* — это выражение, результатом которого является последовательность. Выражения последовательности могут принимать несколько форм. В самой простой форме указывается диапазон. Например, `seq { 1 .. 5 }` создает последовательность, содержащую пять элементов, включая конечные точки 1 и 5. Можно также указать шаг приращения (или уменьшение) между двумя двойными точками. Например, следующий код создает последовательность кратных 10.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1502.fs)]

Выражения последовательности состоят из выражений F #, создающих значения последовательности. Значения также можно формировать программно:

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1503.fs)]

В предыдущем примере используется `->` оператор, который позволяет указать выражение, значение которого станет частью последовательности. Можно использовать, только `->` если каждая часть кода, следующая за ней, возвращает значение.

Кроме того, можно указать `do` ключевое слово с необязательным `yield` следующим образом:

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1504.fs)]

Следующий код создает список пар координат и индексов в массиве, представляющем сетку. Обратите внимание, что `for` для первого выражения требуется `do` указать.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1505.fs)]

`if`Выражение, используемое в последовательности, является фильтром. Например, чтобы создать последовательность только простых чисел, при условии, что имеется функция `isprime` типа `int -> bool` , создайте последовательность следующим образом.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1506.fs)]

Как упоминалось ранее, `do` требуется здесь, так как нет `else` ветви, которая перемещается с `if` . Если вы попытаетесь использовать `->` , вы получите сообщение об ошибке, сообщающее, что не все ветви возвращают значение.

## <a name="the-yield-keyword"></a>Ключевое слово `yield!`.

Иногда может потребоваться включить последовательность элементов в другую последовательность. Чтобы включить последовательность в другую последовательность, необходимо использовать `yield!` ключевое слово:

```fsharp
// Repeats '1 2 3 4 5' ten times
seq {
    for _ in 1..10 do
        yield! seq { 1; 2; 3; 4; 5}
}
```

Другой способ подумать `yield!` заключается в том, что он выполняет сведение внутренней последовательности, а затем включает его в содержащую последовательность.

При `yield!` использовании в выражении все остальные одиночные значения должны использовать `yield` ключевое слово:

```fsharp
// Combine repeated values with their values
seq {
    for x in 1..10 do
        yield x
        yield! seq { for i in 1..x -> i}
}
```

Указание только `x` в предыдущем примере приведет к тому, что последовательность не будет формировать значения.

## <a name="examples"></a>Примеры

В первом примере используется выражение последовательности, содержащее итерацию, фильтр и оператор yield для создания массива. Этот код выводит на консоль последовательность простых чисел от 1 до 100.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1507.fs)]

В следующем примере создается таблица умножения, состоящая из кортежей из трех элементов, каждый из которых состоит из двух факторов и продукта:

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1508.fs)]

В следующем примере показано использование `yield!` для объединения отдельных последовательностей в одну последнюю последовательность. В этом случае последовательности для каждого поддерева в двоичном дереве объединяются в рекурсивную функцию для создания конечной последовательности.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1509.fs)]

## <a name="using-sequences"></a>Использование последовательностей

Последовательности поддерживают многие из тех же функций, что и [списки](lists.md). Последовательности также поддерживают операции, такие как группирование и подсчет, с помощью функций создания ключа. Последовательности также поддерживают более разнообразные функции для извлечения подпоследовательностей.

Многие типы данных, такие как списки, массивы, наборы и карты, являются неявными последовательностями, так как они являются перечислимыми коллекциями. Функция, которая принимает последовательность в качестве аргумента, работает с любыми распространенными типами данных F # в дополнение к любому типу данных .NET, реализующему `System.Collections.Generic.IEnumerable<'T>` . Сравните это с функцией, которая принимает список в качестве аргумента, который может принимать только списки. Тип `seq<'T>` является аббревиатурой типа для `IEnumerable<'T>` . Это означает, что любой тип, реализующий универсальный объект `System.Collections.Generic.IEnumerable<'T>` , включающий массивы, списки, наборы и карты в F #, а также большинство типов коллекций .NET, совместим с `seq` типом и может использоваться везде, где ожидается последовательность.

## <a name="module-functions"></a>Функции модуля

[Модуль Seq](https://msdn.microsoft.com/library/54e8f059-ca52-4632-9ae9-49685ee9b684) в [пространстве имен Microsoft. FSharp. Collections](https://msdn.microsoft.com/library/24f64e5f-5030-47d0-9759-8d3e398ed13f) содержит функции для работы с последовательностями. Эти функции также работают с списками, массивами, картами и наборами, так как все эти типы являются перечислимыми и поэтому могут рассматриваться как последовательности.

## <a name="creating-sequences"></a>Создание последовательностей

Последовательности можно создавать с помощью выражений последовательности, как описано выше, или с помощью определенных функций.

Можно создать пустую последовательность с помощью [Seq. Empty](https://msdn.microsoft.com/library/3c7f1c69-6117-4782-b2da-0e04d6854f59)или создать последовательность только одного указанного элемента с помощью [Seq. Singleton](https://msdn.microsoft.com/library/9b8cc460-a282-4ec5-b29a-630ab17e9de7).

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet9.fs)]

Для создания последовательности, для которой создаются элементы с помощью предоставляемой функции, можно использовать [Seq.init](https://msdn.microsoft.com/library/059de69d-812c-4f8e-be86-88aa72101576) . Вы также предоставляете размер последовательности. Эта функция аналогична [List.init](https://msdn.microsoft.com/library/dd38c096-0ea8-4858-be6b-794b90418b83), за исключением того, что элементы не создаются до выполнения итерации по последовательности. В следующем коде показано использование `Seq.init` .

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet10.fs)]

Выходные данные:

```console
0 10 20 30 40
```

С помощью функции [Seq. офаррай](https://msdn.microsoft.com/library/299cd4d9-be72-4511-aac8-089e1ddaac99) и [seq. офлист&#60;&#62;](https://msdn.microsoft.com/visualfsharpdocs/conceptual/seq.oflist%5b%27t%5d-function-%5bfsharp%5d)можно создавать последовательности из массивов и списков. Однако массивы и списки можно также преобразовать в последовательности с помощью оператора приведения. В следующем коде показаны оба метода.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet11.fs)]

С помощью [Seq. Cast](https://msdn.microsoft.com/library/1d087db3-a8b2-41dd-8ddc-227544529334)можно создать последовательность из слабо типизированной коллекции, например, определенных в `System.Collections` . Такие слабо типизированные коллекции имеют тип элемента `System.Object` и перечисляются с помощью неуниверсального `System.Collections.Generic.IEnumerable&#96;1` типа. Следующий код иллюстрирует использование `Seq.cast` для преобразования `System.Collections.ArrayList` в последовательность.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet12.fs)]

Можно определить бесконечные последовательности с помощью функции [Seq.iniтинфините](https://msdn.microsoft.com/library/d1804e53-da92-48ec-8d6e-57eaf4c62bef) . Для такой последовательности необходимо предоставить функцию, которая создает каждый элемент из индекса элемента. Бесконечные последовательности возможны из-за отложенного вычисления. элементы создаются по мере необходимости путем вызова указанной функции. В следующем примере кода создается неограниченная последовательность чисел с плавающей запятой, в данном случае чередующийся ряд квадратов последовательных целых чисел.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet13.fs)]

[Seq. unfold](https://msdn.microsoft.com/library/7d9232fc-742e-42bc-bdf7-6f130f0eff21) создает последовательность из вычислительной функции, которая принимает состояние и преобразует его для создания каждого последующего элемента последовательности. Состояние — это просто значение, используемое для расчета каждого элемента, и может изменяться при вычислении каждого элемента. Вторым аргументом для `Seq.unfold` является начальное значение, используемое для запуска последовательности. `Seq.unfold`использует тип параметра для состояния, что позволяет завершить последовательность, возвращая `None` значение. В следующем коде показаны два примера последовательностей: `seq1` и `fib` , которые создаются `unfold` операцией. Первая — `seq1` это просто последовательность с числами до 20. Второе, `fib` ,, использует `unfold` для расчета последовательности Фибоначчи. Поскольку каждый элемент последовательности Фибоначчи является суммой двух предыдущих чисел Фибоначчи, значение состояния является кортежем, состоящим из двух предыдущих чисел в последовательности. Начальное значение — это `(1,1)` первые два числа в последовательности.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet14.fs)]

Вывод выглядит следующим образом.

```console
The sequence seq1 contains numbers from 0 to 20.

0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

The sequence fib contains Fibonacci numbers.

2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
```

Ниже приведен пример кода, в котором используются многие из описанных здесь функций модуля последовательности для создания и расчета значений бесконечных последовательностей. Выполнение кода может занять несколько минут.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet15.fs)]

## <a name="searching-and-finding-elements"></a>Поиск и поиск элементов

Функции поддержки последовательностей доступны в списках: [Seq. Exists](https://msdn.microsoft.com/library/428c97bf-599d-4c39-a5b9-f8717c198ad1), [Seq. exists2-](https://msdn.microsoft.com/library/efdf14a4-27f7-4dc1-9281-52639e66d565), [Seq. Find](https://msdn.microsoft.com/library/02c21ecd-97e5-4e99-a4c1-b4d0b730b7d8), [Seq. findIndex](https://msdn.microsoft.com/library/96dfe86b-df15-4d92-8316-7cd6055e09f3), [Seq. Pick](https://msdn.microsoft.com/library/a87bc771-55f7-43f9-94f9-33d8f9bf325d), [Seq. tryFind](https://msdn.microsoft.com/library/ac43c6f5-4dc7-4e9a-a222-00b5736aee47)и [Seq. tryFindIndex](https://msdn.microsoft.com/library/c357b221-edf6-4f68-bf40-82a3156d945a). Версии этих функций, доступные для последовательностей, оценивают последовательность только до элемента, для которого выполняется поиск. Примеры см. в разделе [списки](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d).

## <a name="obtaining-subsequences"></a>Получение подпоследовательностей

[Seq. Filter](https://msdn.microsoft.com/library/7f2e9850-a660-460c-9831-3bbff5613770) и [Seq. Choose](https://msdn.microsoft.com/library/63b83b06-4b24-4239-bf69-a2c12d891395) подобны соответствующим функциям, доступным для списков, за исключением того, что фильтрация и выбор не выполняются до оценки элементов последовательности.

[Seq. truncate](https://msdn.microsoft.com/library/1892dfeb-308e-45e2-857a-3c3405d02244) создает последовательность из другой последовательности, но ограничивает ее заданным числом элементов. [Seq. take](https://msdn.microsoft.com/library/6e75f701-640b-4c4a-9d63-4313fc090596) создает новую последовательность, содержащую только заданное число элементов из начала последовательности. Если в последовательности меньше элементов, чем указано для выполнения, `Seq.take` создает исключение `System.InvalidOperationException` . Разница между `Seq.take` и `Seq.truncate` заключается в том, что не `Seq.truncate` создает ошибку, если число элементов меньше указанного числа.

В следующем коде показано поведение и различия между `Seq.truncate` и `Seq.take` .

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet16.fs)]

Выходные данные до возникновения ошибки выглядят следующим образом.

```console
1 4 9 16 25
1 4 9 16 25 36 49 64 81 100
1 4 9 16 25
1 4 9 16 25 36 49 64 81 100
```

С помощью [Seq. TakeWhile](https://msdn.microsoft.com/library/19eea4ce-66e0-4353-b015-72eb03421d92)можно указать функцию предиката (логическую функцию) и создать последовательность из другой последовательности, состоящие из элементов исходной последовательности, для которых предикат имеет значение `true` , но останавливаться перед первым элементом, для которого предикат возвращает `false` . [Seq. Skip](https://msdn.microsoft.com/library/b4eb3f08-8594-4d17-8180-852c6c688bf1) возвращает последовательность, которая пропускает заданное число первых элементов другой последовательности и возвращает остальные элементы. [Seq. SkipWhile](https://msdn.microsoft.com/library/fb729021-2a3c-430f-83c3-0b37526f1a16) возвращает последовательность, которая пропускает первые элементы другой последовательности, если предикат возвращает `true` , а затем возвращает оставшиеся элементы, начиная с первого элемента, для которого предикат возвращает `false` .

В следующем примере кода показано поведение и различия между, и `Seq.takeWhile` `Seq.skip` `Seq.skipWhile` .

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet17.fs)]

Выходные данные выглядят следующим образом.

```console
1 4 9
36 49 64 81 100
16 25 36 49 64 81 100
```

## <a name="transforming-sequences"></a>Преобразование последовательностей

Функция [Seq. парная](https://msdn.microsoft.com/library/210dcf26-4e24-4d83-af6d-a8288b2ae4b1) создает новую последовательность, в которой последовательные элементы входной последовательности группируются по кортежам.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet18.fs)]

[Seq. windowd](https://msdn.microsoft.com/library/8b565b8f-d645-4dba-be22-099075fe4744) имеет следующий `Seq.pairwise` смысл, за исключением того, что вместо создания последовательности кортежей создается последовательность массивов, которая содержит копии смежных элементов ( *окна*) из последовательности. Вы указываете число соседних элементов в каждом массиве.

В следующем коде показано использование функции `Seq.windowed`. В этом случае число элементов в окне равно 3. В примере используется `printSeq` , который определен в предыдущем примере кода.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet180.fs)]

Выходные данные выглядят следующим образом.

Начальная последовательность:

```console
1.0 1.5 2.0 1.5 1.0 1.5

Windows of length 3:
[|1.0; 1.5; 2.0|] [|1.5; 2.0; 1.5|] [|2.0; 1.5; 1.0|] [|1.5; 1.0; 1.5|]

Moving average:
1.5 1.666666667 1.5 1.333333333
```

## <a name="operations-with-multiple-sequences"></a>Операции с несколькими последовательностями

[Seq.zip](https://msdn.microsoft.com/library/0a5df8bf-0d48-44ce-bff4-e8ef1df5bca4) и [Seq.zip3](https://msdn.microsoft.com/library/ef13bebb-22ae-4eb9-873b-87dd29154d16) принимают две или три последовательности и создают последовательность кортежей. Эти функции подобны соответствующим функциям, доступным для [списков](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d). Нет соответствующей функциональности для разделения одной последовательности на две или более последовательностей. Если эта функция необходима для последовательности, преобразуйте последовательность в список и используйте [List. unzip](https://msdn.microsoft.com/library/639db80c-41b5-45bb-a6b4-1eaa04d61d21).

## <a name="sorting-comparing-and-grouping"></a>Сортировка, сравнение и группирование

Функции сортировки, поддерживаемые для списков, также работают с последовательностями. Сюда входят [Seq. Sort](https://msdn.microsoft.com/library/327ea595-e77c-4529-b61e-8c6cbf5ec92e) и [Seq. sortBy](https://msdn.microsoft.com/library/4f8b4fb9-bf20-49d9-b4ee-dcc906c8208f). Эти функции выполняют итерацию всей последовательности.

Для сравнения двух последовательностей используется функция [Seq. компаревис](https://msdn.microsoft.com/library/5a740135-0b3a-4545-816f-8f91cc31290f) . Функция сравнивает последовательные элементы в свою очередь и останавливается при обнаружении первой неравной пары. Все дополнительные элементы не участвуют в сравнении.

В следующем коде показано использование `Seq.compareWith`.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet19.fs)]

В предыдущем коде вычисляются и анализируются только первый элемент, а результат равен-1.

[Seq. каунтби](https://msdn.microsoft.com/library/721702a5-150e-4fe8-81cd-ffbf8476cc1f) принимает функцию, которая создает значение, именуемое *ключом* для каждого элемента. Ключ создается для каждого элемента путем вызова этой функции для каждого элемента. `Seq.countBy`затем возвращает последовательность, содержащую значения ключа, и количество элементов, которые создали каждое значение ключа.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet201.fs)]

Выходные данные выглядят следующим образом.

```console
(1, 34) (2, 33) (0, 33)
```

В предыдущих выходных данных показано, что имелось 34 элементов исходной последовательности, которые производили значение ключа 1, 33, которое вызвало ключ 2, и значение 33, полученное с помощью ключа 0.

Элементы последовательности можно сгруппировать, вызвав [Seq. GroupBy](https://msdn.microsoft.com/library/d46a04df-1a42-40cc-a368-058c9c5806fd). `Seq.groupBy`принимает последовательность и функцию, которая создает ключ из элемента. Функция выполняется для каждого элемента последовательности. `Seq.groupBy`Возвращает последовательность кортежей, где первый элемент каждого кортежа является ключом, а второй — последовательность элементов, которые создают этот ключ.

В следующем примере кода показано использование `Seq.groupBy` для секционирования последовательности чисел от 1 до 100 в три группы, имеющие уникальные значения ключа 0, 1 и 2.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet202.fs)]

Выходные данные выглядят следующим образом.

```console
(1, seq [1; 4; 7; 10; ...]) (2, seq [2; 5; 8; 11; ...]) (0, seq [3; 6; 9; 12; ...])
```

Можно создать последовательность, которая устраняет повторяющиеся элементы, вызывая [Seq. DISTINCT](https://msdn.microsoft.com/library/99d01014-7e0e-4e7b-9d0a-41a61d93f401). Или можно использовать [Seq. дистинктби](https://msdn.microsoft.com/library/9293293b-9420-49c8-848f-401a9cd49b75), который принимает функцию создания ключа для каждого элемента. Результирующая последовательность содержит элементы исходной последовательности, имеющие уникальные ключи. последующие элементы, которые создают дубликат ключа для более раннего элемента, отбрасываются.

В следующем примере кода показано использование `Seq.distinct` . `Seq.distinct`демонстрируется путем создания последовательностей, представляющих двоичные числа, а затем показывается, что единственными отдельными элементами являются 0 и 1.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet22.fs)]

Следующий код демонстрирует, `Seq.distinctBy` начиная с последовательности, содержащей отрицательные и положительные числа, и используя функцию абсолютного значения в качестве функции создания ключа. В результирующей последовательности отсутствуют все положительные числа, соответствующие отрицательным числам в последовательности, так как отрицательные числа отображаются ранее в последовательности и, следовательно, выбираются вместо положительных чисел, имеющих одинаковое абсолютное значение или ключ.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet23.fs)]

## <a name="readonly-and-cached-sequences"></a>Последовательностей только для чтения и кэширование

[Seq. ReadOnly](https://msdn.microsoft.com/library/88059cb4-3bb0-4126-9448-fbcd48fe13a7) создает копию последовательности, доступную только для чтения. `Seq.readonly`может использоваться, если имеется коллекция для чтения и записи, например массив, и вы не хотите изменять исходную коллекцию. Эта функция может использоваться для сохранения инкапсуляции данных. В следующем примере кода создается тип, содержащий массив. Свойство предоставляет массив, но вместо возвращения массива он возвращает последовательность, созданную из массива с помощью `Seq.readonly` .

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet24.fs)]

[Seq. Cache](https://msdn.microsoft.com/library/d197f9cc-08bf-4986-9869-246e72ca73f0) создает сохраненную версию последовательности. Используйте, `Seq.cache` чтобы избежать повторного вычисления последовательности или при наличии нескольких потоков, использующих последовательность, но необходимо убедиться, что каждый элемент действует только один раз. При наличии последовательности, используемой несколькими потоками, у вас может быть один поток, который перечисляет и выполняет вычисление значений для исходной последовательности, а оставшиеся потоки могут использовать кэшированную последовательность.

## <a name="performing-computations-on-sequences"></a>Выполнение вычислений в последовательностях

Простые арифметические операции аналогичны спискам, например [Seq. Average](https://msdn.microsoft.com/library/609d793b-c70f-4e36-9ab4-d928056d65b8), [Seq. Sum](https://msdn.microsoft.com/library/01208515-4880-4358-91f5-af34f66dc77a), [Seq. averageBy](https://msdn.microsoft.com/library/47c855c1-2dbd-415a-885e-b909d9d3e4f8), [Seq. sumBy](https://msdn.microsoft.com/library/68cca78c-94ed-4a45-9b8d-34d2c5f2b1b1)и т. д.

Функции [Seq. fold](https://msdn.microsoft.com/library/30c4c95a-9563-4c96-bbe1-f7aacfd026e3), [Seq. reduce](https://msdn.microsoft.com/library/a2ad4f64-ac69-47d2-92f0-7173d9dfeae9)и [Seq. Scan](https://msdn.microsoft.com/library/7e2d23e9-f153-4411-a884-b6d415ff627e) подобны соответствующим функциям, доступным для списков. Последовательности поддерживают подмножество всех вариантов этих функций, которые поддерживаются в списках. Дополнительные сведения и примеры см. в разделе [списки](lists.md).

## <a name="see-also"></a>См. также

- [Справочник по языку F#](index.md)
- [Типы языка F#](fsharp-types.md)
