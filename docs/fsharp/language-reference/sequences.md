---
title: Последовательности
description: Сведения об использовании F# последовательности, при наличии большой упорядоченной коллекции данных, но вряд ли будет обязательно использовать все элементы.
ms.date: 02/19/2019
ms.openlocfilehash: a7791be5e8bd07d81fe9e890fc5896b181f0cb39
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61770478"
---
# <a name="sequences"></a>Последовательности

> [!NOTE]
> Ссылки на справочник по API в этой статье ведут на сайт MSDN.  Работа над справочником по API docs.microsoft.com не завершена.

Объект *последовательности* — это логический ряд элементов одного типа. Последовательностей особенно полезны при наличии большой упорядоченной коллекции данных, но не планируете обязательно использовать все элементы. Отдельные последовательность, в которой элементы вычисляются только при необходимости последовательности могут обеспечить лучшую производительность, чем в ситуациях, в которых не используются все элементы списка. Последовательности представляются `seq<'T>` тип, который является псевдонимом для `System.Collections.Generic.IEnumerable`. Таким образом, любой тип .NET Framework, который реализует `System.IEnumerable` может использоваться как последовательность. [Seq-модуль](https://msdn.microsoft.com/library/54e8f059-ca52-4632-9ae9-49685ee9b684) обеспечивает поддержку операций с последовательностями.

## <a name="sequence-expressions"></a>Выражения последовательности

Объект *последовательности выражений* представляет собой выражение, результатом которого является последовательность. Выражения последовательности могут принимать несколько форм. Самая простая форма указывает диапазон. Например `seq { 1 .. 5 }` создает последовательность, которая содержит пять элементов, включая конечные точки, от 1 до 5. Можно также указать шаг (или уменьшения) между двумя двойными точками. Например следующий код создает последовательность, кратных 10.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1502.fs)]

Выражения последовательности состоят из F# выражения, возвращающие значения последовательности. Они могут использовать `yield` ключевое слово для получения значений, которые становятся частью последовательности.

Ниже приведен пример.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1503.fs)]

Можно использовать `->` оператор вместо `yield`, в этом случае можно опустить `do` ключевое слово, как показано в следующем примере.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1504.fs)]

Следующий код создает список пар координат и индекса в массив, который представляет сетку.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1505.fs)]

`if` Выражение, используемое в последовательности является фильтром. Например, чтобы создать последовательность простых чисел, при условии, что у вас есть функция `isprime` типа `int -> bool`, построить последовательность следующим образом.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1506.fs)]

При использовании `yield` или `->` во время итерации каждой итерации должен создать единственный элемент последовательности. Если в каждой итерации создается последовательность элементов, используйте `yield!`. В этом случае чтобы результирующая последовательность сцепляются элементов, созданных в каждой итерации.

Вы можете объединить несколько выражений друг с другом в выражении последовательности. Элементы, созданные каждого выражения объединяются вместе. Например см. в разделе «Примеры» этого раздела.

## <a name="examples"></a>Примеры

В первом примере используется выражение последовательности, содержащий итерации, фильтр и оператор yield для создания массива. Этот код выводит последовательность простых чисел от 1 до 100 в консоль.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1507.fs)]

В следующем коде используется `yield` для создания таблицы умножения, состоящий из кортежей из трех элементов, каждый элемент состоит из двух факторов и продукта.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1508.fs)]

В следующем примере показано использование `yield!` для объединения нескольких отдельных последовательностей в единую результирующую последовательность. В этом случае последовательностей для каждого поддерева в двоичном дереве объединяются в рекурсивной функции, чтобы результирующая последовательность.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1509.fs)]

## <a name="using-sequences"></a>Использование последовательностей

Последовательности поддерживают многие функции, как [перечислены](lists.md). Последовательности также поддерживают операции, такие как Группировка и подсчет с помощью функции создания ключей. Последовательности также поддерживают более сложные функции для извлечения подпоследовательностей.

Множество типов данных, таких как списки, массивы, наборы и карты являются неявно последовательностей, поскольку они являются перечислимые коллекции. Функция, которая принимает последовательность как аргумент подходит для любых общих F# типы данных, а также любой тип данных .NET Framework, реализующий `System.Collections.Generic.IEnumerable<'T>`. Сравните это с функцию, которая принимает список в качестве аргумента, который может принимать только списки. Тип `seq<'T>` представляет собой сокращенную для `IEnumerable<'T>`. Это означает, что любой тип, реализующий универсальный `System.Collections.Generic.IEnumerable<'T>`, включая массивы, списки, устанавливает и карты в F#, а также к большинство типов коллекций .NET Framework, совместимый с `seq` типа и может использоваться везде, где ожидается последовательности .

## <a name="module-functions"></a>Функции модуля

[Seq-модуль](https://msdn.microsoft.com/library/54e8f059-ca52-4632-9ae9-49685ee9b684) в [пространство имен Microsoft.FSharp.Collections](https://msdn.microsoft.com/library/24f64e5f-5030-47d0-9759-8d3e398ed13f) содержит функции для работы с последовательностями. Эти функции работают с списки, массивы, карт и наборов, так как эти типы являются enumerable и таким образом можно рассматривать как последовательности.

## <a name="creating-sequences"></a>Создание последовательностей

Можно создавать последовательности с помощью выражения последовательности, как описано выше, или с помощью некоторых функций.

Можно создать пустую последовательность, используя [Seq.empty](https://msdn.microsoft.com/library/3c7f1c69-6117-4782-b2da-0e04d6854f59), или можно создать последовательность всего из одного указанного элемента с помощью [Seq.singleton](https://msdn.microsoft.com/library/9b8cc460-a282-4ec5-b29a-630ab17e9de7).

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet9.fs)]

Можно использовать [Seq.init](https://msdn.microsoft.com/library/059de69d-812c-4f8e-be86-88aa72101576) создать последовательность, для которого элементы создаются с помощью функции вами. Также можно указать размер для последовательности. Эта функция представляет так же, как [List.init](https://msdn.microsoft.com/library/dd38c096-0ea8-4858-be6b-794b90418b83), за исключением того, что элементы не создаются до выполнения последовательности. Следующий код иллюстрирует использование `Seq.init`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet10.fs)]

Выходные данные:

```
0 10 20 30 40
```

С помощью [Seq.ofArray](https://msdn.microsoft.com/library/299cd4d9-be72-4511-aac8-089e1ddaac99) и [Seq.ofList&#60;'T&#62; функция](https://msdn.microsoft.com/visualfsharpdocs/conceptual/seq.oflist%5b%27t%5d-function-%5bfsharp%5d), можно создавать последовательности из массивов и списков. Тем не менее можно также преобразовать массивами и списками в последовательности с помощью оператора приведения. В следующем коде показаны обе методики.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet11.fs)]

С помощью [Seq.cast](https://msdn.microsoft.com/library/1d087db3-a8b2-41dd-8ddc-227544529334), можно создать последовательность из слабо типизированных коллекций, определенных в `System.Collections`. Такие слабо типизированные коллекции имеют тип элемента `System.Object` и перечисляются с помощью неуниверсального `System.Collections.Generic.IEnumerable&#96;1` типа. Следующий код иллюстрирует использование `Seq.cast` для преобразования `System.Collections.ArrayList` в последовательность.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet12.fs)]

Бесконечные последовательности можно определить с помощью [Seq.initInfinite](https://msdn.microsoft.com/library/d1804e53-da92-48ec-8d6e-57eaf4c62bef) функции. Для такой последовательности предоставляют функции, создающей каждого элемента из индекса элемента. Бесконечные последовательности возможны из-за отложенного вычисления; элементы создаются в том случае, при необходимости путем вызова функции. В следующем примере кода создается бесконечная последовательность чисел с плавающей запятой, в данном случае чередующихся последовательность обратных величин квадратов последовательных целых чисел.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet13.fs)]

[Функция Seq.unfold](https://msdn.microsoft.com/library/7d9232fc-742e-42bc-bdf7-6f130f0eff21) создает последовательность из вычислительной функции, которая принимает состояние и преобразует его для создания каждого последующего элемента в последовательности. Состояние — просто значение, которое используется для вычисления каждого элемента и можно изменить, как каждый элемент является вычисляемым. Второй аргумент `Seq.unfold` — начальное значение, которое используется для запуска последовательности. `Seq.unfold` использует тип параметра для состояния, что дает возможность завершить последовательность, возвращая `None` значение. В следующем коде показано два примера последовательностей, `seq1` и `fib`, создаваемые `unfold` операции. Во-первых, `seq1`, представляет собой простой последовательность чисел до 20. Второй, `fib`, использует `unfold` для вычисления последовательности Фибоначчи. Так как каждый элемент в последовательности Фибоначчи складывается из двух предыдущих чисел Фибоначчи, значение состояния — кортеж, состоящий из двух предыдущих чисел в последовательности. Начальное значение — `(1,1)`, первые два числа в последовательности.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet14.fs)]

Выходные данные выглядят следующим образом:

```
The sequence seq1 contains numbers from 0 to 20.

0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

The sequence fib contains Fibonacci numbers.

2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
```

Ниже приведен пример, использующее многие из функций модуля последовательностей, описанные здесь, для создания и вычисления значений бесконечных последовательностей. Код может занять несколько минут.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet15.fs)]

## <a name="searching-and-finding-elements"></a>Поиск и поиск элементов

Последовательности поддерживают функциональные возможности, доступные со списками: [SEQ.Exists](https://msdn.microsoft.com/library/428c97bf-599d-4c39-a5b9-f8717c198ad1), [Seq.exists2](https://msdn.microsoft.com/library/efdf14a4-27f7-4dc1-9281-52639e66d565), [Seq.find](https://msdn.microsoft.com/library/02c21ecd-97e5-4e99-a4c1-b4d0b730b7d8), [Seq.findIndex](https://msdn.microsoft.com/library/96dfe86b-df15-4d92-8316-7cd6055e09f3), [Seq.pick](https://msdn.microsoft.com/library/a87bc771-55f7-43f9-94f9-33d8f9bf325d), [Seq.tryFind ](https://msdn.microsoft.com/library/ac43c6f5-4dc7-4e9a-a222-00b5736aee47), и [Seq.tryFindIndex](https://msdn.microsoft.com/library/c357b221-edf6-4f68-bf40-82a3156d945a). Версии этих функций, доступных для последовательностей оценить только до элемента, поиск которого выполняется для последовательности. Примеры, см. в разделе [перечислены](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d).

## <a name="obtaining-subsequences"></a>Получение подпоследовательностей

[SEQ.Filter](https://msdn.microsoft.com/library/7f2e9850-a660-460c-9831-3bbff5613770) и [Seq.choose](https://msdn.microsoft.com/library/63b83b06-4b24-4239-bf69-a2c12d891395) имеют как соответствующие функции, доступные для списков, за исключением того, что фильтрация и выбор вычисления элементов последовательности.

[SEQ.truncate](https://msdn.microsoft.com/library/1892dfeb-308e-45e2-857a-3c3405d02244) создает последовательность из другой последовательности, но ограничивает указанное число элементов. [Функция Seq.Take](https://msdn.microsoft.com/library/6e75f701-640b-4c4a-9d63-4313fc090596) создает новую последовательность, содержащую только заданное число элементов с начала последовательности. Если в последовательности меньше элементов, чем задано для получения, `Seq.take` вызывает `System.InvalidOperationException`. Разница между `Seq.take` и `Seq.truncate` является то, что `Seq.truncate` не сообщает об ошибке, если количество элементов меньше вами.

Следующий код показывает поведение, а также отличия между `Seq.truncate` и `Seq.take`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet16.fs)]

Выходные данные, прежде чем произойдет ошибка, выглядит следующим образом.

```
1 4 9 16 25 
1 4 9 16 25 36 49 64 81 100 
1 4 9 16 25 
1 4 9 16 25 36 49 64 81 100
```

С помощью [Seq.takeWhile](https://msdn.microsoft.com/library/19eea4ce-66e0-4353-b015-72eb03421d92), можно указать функции предиката (логическую функцию) и создайте последовательность из другую последовательность, состоящую из тех элементов исходной последовательности, для которого предикат имеет `true`, остановится, Перед первым элементом, для которого предикат возвращает `false`. [Функция Seq.Skip](https://msdn.microsoft.com/library/b4eb3f08-8594-4d17-8180-852c6c688bf1) возвращает последовательность, которая пропускает указанное число начальных элементов другой последовательности и возвращает остальные элементы. [Seq.skipWhile](https://msdn.microsoft.com/library/fb729021-2a3c-430f-83c3-0b37526f1a16) возвращает последовательность, первые элементы другой последовательности до тех пор, пока предикат возвращает `true`, а затем возвращает оставшиеся элементы, начиная с первого элемента, для которого предикат возвращает `false`.

В следующем примере кода показано поведение, а также отличия между `Seq.takeWhile`, `Seq.skip`, и `Seq.skipWhile`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet17.fs)]

Выходные данные выглядят следующим образом.

```
1 4 9 
36 49 64 81 100 
16 25 36 49 64 81 100
```

## <a name="transforming-sequences"></a>Преобразование последовательностей

[Функция Seq.pairwise](https://msdn.microsoft.com/library/210dcf26-4e24-4d83-af6d-a8288b2ae4b1) создает новую последовательность, в котором идущие подряд элементы входной последовательности группируются в кортежи.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet18.fs)]

[SEQ.windowed](https://msdn.microsoft.com/library/8b565b8f-d645-4dba-be22-099075fe4744) аналогичен `Seq.pairwise`, за исключением того, что вместо создания последовательность кортежей, она создает последовательность массивов, которые содержат копии соседних элементов ( *окно*) из последовательности. Укажите число соседних элементов, которые требуется в каждом массиве.

В следующем коде показано использование функции `Seq.windowed`. В этом случае количество элементов в окне равно 3. В примере используется `printSeq`, определенный в предыдущем примере кода.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet180.fs)]

Выходные данные выглядят следующим образом.

Начальная последовательность:

```
1.0 1.5 2.0 1.5 1.0 1.5 

Windows of length 3: 
[|1.0; 1.5; 2.0|] [|1.5; 2.0; 1.5|] [|2.0; 1.5; 1.0|] [|1.5; 1.0; 1.5|] 

Moving average: 
1.5 1.666666667 1.5 1.333333333
```

## <a name="operations-with-multiple-sequences"></a>Операции с несколькими последовательностями

[SEQ.ZIP](https://msdn.microsoft.com/library/0a5df8bf-0d48-44ce-bff4-e8ef1df5bca4) и [Seq.zip3](https://msdn.microsoft.com/library/ef13bebb-22ae-4eb9-873b-87dd29154d16) принимают два или три последовательности и создают последовательность кортежей. Эти функции аналогичны соответствующим функциям для [перечислены](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d). Нет никаких соответствующих функций для разделения одной последовательности на два или более последовательностей. Если данная функция необходима для последовательности, преобразуйте ее в список и использовать [List.unzip](https://msdn.microsoft.com/library/639db80c-41b5-45bb-a6b4-1eaa04d61d21).

## <a name="sorting-comparing-and-grouping"></a>Сортировка, сравнение и группирование

Функции сортировки, поддерживаемые для списков также работы с последовательностями. Сюда входят [Seq.sort](https://msdn.microsoft.com/library/327ea595-e77c-4529-b61e-8c6cbf5ec92e) и [Seq.sortBy](https://msdn.microsoft.com/library/4f8b4fb9-bf20-49d9-b4ee-dcc906c8208f). Эти функции выполняют перебор всей последовательности.

Для сравнения двух последовательностей с помощью [Seq.compareWith](https://msdn.microsoft.com/library/5a740135-0b3a-4545-816f-8f91cc31290f) функции. Функция сравнивает идущие подряд элементы в свою очередь и останавливается при обнаружении первой неравной паре значений. Дополнительные элементы не влияют на сравнение.

В следующем коде показано использование `Seq.compareWith`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet19.fs)]

В предыдущем коде вычисляется и проверяется только первый элемент, и результатом является -1.

[Seq.countBy](https://msdn.microsoft.com/library/721702a5-150e-4fe8-81cd-ffbf8476cc1f) принимает функцию, которая создает значение с именем *ключ* для каждого элемента. Ключ создается для каждого элемента путем вызова этой функции для каждого элемента. `Seq.countBy` Возвращает последовательность, которая содержит значения ключей и количество элементов, которые созданы каждого значения ключа.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet201.fs)]

Выходные данные выглядят следующим образом.

```
(1, 34) (2, 33) (0, 33)
```

Предыдущие выходные данные показывают, что 34 элемента исходной последовательности дают значение ключа 1, 33 значения, которые дают значение ключа 2 и 33 дают значение ключа 0.

Можно сгруппировать элементы последовательности, вызвав [Seq.groupBy](https://msdn.microsoft.com/library/d46a04df-1a42-40cc-a368-058c9c5806fd). `Seq.groupBy` принимает последовательность и функцию, которая создает ключ для элемента. Функция выполняется для каждого элемента последовательности. `Seq.groupBy` Возвращает последовательность кортежей, где первый элемент каждого кортежа является ключом, а второй — это последовательность элементов, дающих этим ключом.

В следующем примере кода показано использование `Seq.groupBy` для разбиения последовательности чисел от 1 до 100 на три группы, которые имеют уникальных значений ключей 0, 1 и 2.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet202.fs)]

Выходные данные выглядят следующим образом.

```
(1, seq [1; 4; 7; 10; ...]) (2, seq [2; 5; 8; 11; ...]) (0, seq [3; 6; 9; 12; ...])
```

Можно создать последовательность, повторяющиеся элементы путем вызова [Seq.distinct](https://msdn.microsoft.com/library/99d01014-7e0e-4e7b-9d0a-41a61d93f401). Или можно использовать [Seq.distinctBy](https://msdn.microsoft.com/library/9293293b-9420-49c8-848f-401a9cd49b75), который использует функцию создания ключей для вызова для каждого элемента. Результирующая последовательность содержит элементы исходной последовательности, которые имеют уникальные ключи; более поздние версии элементов, дающих повторяющийся ключ, относящийся к элементу более ранних, отбрасываются.

В следующем примере кода показано использование `Seq.distinct`. `Seq.distinct` демонстрируется создание последовательностей, представляющих двоичные числа, а затем демонстрируется, что только уникальные элементы, 0 и 1.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet22.fs)]

В следующем коде показано `Seq.distinctBy` , начиная с последовательность, которая содержит отрицательных и положительных чисел и используя функцию абсолютного значения функцию создания ключей. Результирующая последовательность отсутствует положительных чисел, которые соответствуют отрицательных чисел в последовательности, так как отрицательные числа отображаются по порядку и таким образом выбраны вместо положительных чисел, с тем же абсолютное значение, или ключ.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet23.fs)]

## <a name="readonly-and-cached-sequences"></a>Только для чтения и кэшированные последовательности

[SEQ.ReadOnly](https://msdn.microsoft.com/library/88059cb4-3bb0-4126-9448-fbcd48fe13a7) создает копию последовательности, только для чтения. `Seq.readonly` Когда у вас есть коллекция чтения и записи, такого как массив, и вы не хотите изменять исходную коллекцию. Эта функция может использоваться для сохранения инкапсуляции данных. В следующем примере кода создается тип, содержащий массив. Свойство предоставляет массив, но вместо возвращения массива, оно возвращает последовательность, которая создается из массива с помощью `Seq.readonly`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet24.fs)]

[Функция Seq.Cache](https://msdn.microsoft.com/library/d197f9cc-08bf-4986-9869-246e72ca73f0) создает сохраненную версию последовательности. Использовать `Seq.cache` Чтобы избежать повторного вычисления, последовательности или при наличии нескольких потоков, последовательность, но необходимо убедиться в том, что каждый элемент это действие производится только один раз. При наличии последовательности, который используется несколькими потоками, у вас есть один поток, который выполняет перечисление и вычисление значений исходной последовательности, а остальные потоки могут использовать кэшированную последовательность.

## <a name="performing-computations-on-sequences"></a>Вычисления с последовательностями

Простые арифметические операции, таких как списки, такие как [Seq.average](https://msdn.microsoft.com/library/609d793b-c70f-4e36-9ab4-d928056d65b8), [Seq.sum](https://msdn.microsoft.com/library/01208515-4880-4358-91f5-af34f66dc77a), [Seq.averageBy](https://msdn.microsoft.com/library/47c855c1-2dbd-415a-885e-b909d9d3e4f8), [Seq.sumBy](https://msdn.microsoft.com/library/68cca78c-94ed-4a45-9b8d-34d2c5f2b1b1), и т. д.

[SEQ.fold](https://msdn.microsoft.com/library/30c4c95a-9563-4c96-bbe1-f7aacfd026e3), [Seq.reduce](https://msdn.microsoft.com/library/a2ad4f64-ac69-47d2-92f0-7173d9dfeae9), и [Seq.scan](https://msdn.microsoft.com/library/7e2d23e9-f153-4411-a884-b6d415ff627e) имеют как соответствующие функции, доступные для списков. Последовательности поддерживают подмножество полной варианты этих функций, поддерживаемых списками. Дополнительные сведения и примеры см. в разделе [перечислены](lists.md).

## <a name="see-also"></a>См. также

- [Справочник по языку F#](index.md)
- [Типы языка F#](fsharp-types.md)
