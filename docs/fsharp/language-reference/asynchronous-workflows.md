---
title: Асинхронные рабочие потоки
description: Сведения о поддержке в языке F# программирования для асинхронного выполнения вычислений, которые выполняются без блокировки выполнения другой работы.
ms.date: 05/16/2016
ms.openlocfilehash: 2d967f6bfe46b4f3916648b3063210d1ba1c210f
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/30/2019
ms.locfileid: "68629999"
---
# <a name="asynchronous-workflows"></a>Асинхронные рабочие потоки

> [!NOTE]
> Ссылка на справочник по API ведет на сайт MSDN.  Работа над справочником по API docs.microsoft.com не завершена.

В этом разделе описывается поддержка F# в для асинхронного выполнения вычислений, т. е. без блокировки выполнения другой работы. Например, асинхронные вычисления можно использовать для написания приложений, которые имеют пользовательские интерфейсы, которые продолжают реагировать на запросы пользователей, так как приложение выполняет другую работу.

## <a name="syntax"></a>Синтаксис

```fsharp
async { expression }
```

## <a name="remarks"></a>Примечания

В предыдущем синтаксисе вычисление, представленное `expression` , настроено для асинхронного выполнения, то есть без блокировки текущего вычислительного потока при выполнении асинхронных операций сна, ввода-вывода и других асинхронных операций. Асинхронные вычисления часто запускаются в фоновом потоке, а выполнение продолжаются в текущем потоке. Выражение имеет `Async<'T>`тип, где `'T` — тип, возвращаемый выражением при `return` использовании ключевого слова. Код в таком выражении называется асинхронным блоком илиасинхронным блоком.

Существует множество способов программирования в асинхронном режиме, а [`Async`](https://msdn.microsoft.com/library/03eb4d12-a01a-4565-a077-5e83f17cf6f7) класс предоставляет методы, поддерживающие несколько сценариев. Общий подход заключается в создании `Async` объектов, представляющих вычисления или вычисления, которые необходимо выполнять асинхронно, а затем запускайте эти вычисления с помощью одной из функций запуска. Различные функции, вызывающие срабатывание, предоставляют различные способы выполнения асинхронных вычислений, и какое из них зависит от того, хотите ли вы использовать текущий поток, фоновый поток или объект задачи .NET Framework, а также наличие продолжения. функции, которые должны выполняться после завершения вычисления. Например, чтобы запустить асинхронное вычисление в текущем потоке, можно использовать [`Async.StartImmediate`](https://msdn.microsoft.com/library/2f71d1cc-187f-48cf-ac66-e7fda41c46e3). Когда вы запускаете асинхронное вычисление из потока пользовательского интерфейса, вы не блокируете главный цикл событий, который обрабатывает действия пользователя, такие как нажатия клавиш и действия мыши, чтобы приложение оставалось реагировать на запросы.

## <a name="asynchronous-binding-by-using-let"></a>Асинхронная привязка с помощью let!

В асинхронном рабочем процессе некоторые выражения и операции являются синхронными, а некоторые — более длинными вычислениями, которые предназначены для асинхронного возврата результатов. При асинхронном вызове метода вместо обычной `let` привязки используется. `let!` Результат `let!` заключается в том, чтобы обеспечить продолжение выполнения в других вычислениях или потоках при выполнении вычислений. После того как правая часть `let!` привязки возвращаются, остальная часть асинхронного рабочего процесса возобновляет выполнение.

В следующем коде показано различие между `let` и. `let!` Строка кода, в которой используется `let` , просто создает асинхронное вычисление как объект, который можно запустить позднее с помощью, `Async.StartImmediate` например или [`Async.RunSynchronously`](https://msdn.microsoft.com/library/0a6663a9-50f2-4d38-8bf3-cefd1a51fd6b). Строка кода, в которой используется `let!` , начинает вычисление, а затем поток приостанавливается до тех пор, пока результат не станет доступным, после чего выполнение продолжится.

```fsharp
// let just stores the result as an asynchronous operation.
let (result1 : Async<byte[]>) = stream.AsyncRead(bufferSize)
// let! completes the asynchronous operation and returns the data.
let! (result2 : byte[])  = stream.AsyncRead(bufferSize)
```

Кроме `let!`того, можно использовать `use!` для выполнения асинхронных привязок. Разница между `let!` и `use!` совпадает с разностью между `let` и `use`. Для `use!`объект удаляется при закрытии текущей области. Обратите внимание, что в текущем F# выпуске `use!` языка не позволяет инициализировать значение со значением `use` null, несмотря на это.

## <a name="asynchronous-primitives"></a>Асинхронные примитивы

Метод, выполняющий одну асинхронную задачу и возвращающий результат, называется *асинхронным примитивом*, и они предназначены специально для использования `let!`с. В F# основной библиотеке определены несколько асинхронных примитивов. Два таких метода для веб-приложений определяются в модуле [`Microsoft.FSharp.Control.WebExtensions`](https://msdn.microsoft.com/library/95ef17bc-ee3f-44ba-8a11-c90fcf4cf003): [`WebRequest.AsyncGetResponse`](https://msdn.microsoft.com/library/09a60c31-e6e2-4b5c-ad23-92a86e50060c) и [`WebClient.AsyncDownloadString`](https://msdn.microsoft.com/library/8a85a9b7-f712-4cac-a0ce-0a797f8ea32a). Оба примитива загружают данные с веб-страницы по указанному URL-адресу. `AsyncGetResponse`Создает объект и `AsyncDownloadString` создает строку, представляющую код HTML для веб-страницы. `System.Net.WebResponse`

В [`Microsoft.FSharp.Control.CommonExtensions`](https://msdn.microsoft.com/library/2edb67cb-6814-4a30-849f-b6dbdd042396) модуль включаются несколько примитивов для асинхронных операций ввода-вывода. Эти методы `System.IO.Stream` расширения класса являются [`Stream.AsyncRead`](https://msdn.microsoft.com/library/85698aaa-bdda-47e6-abed-3730f59fda5e) и [`Stream.AsyncWrite`](https://msdn.microsoft.com/library/1b0a2751-e42a-47e1-bd27-020224adc618).

Можно также написать собственные асинхронные примитивы, определив функцию, полный текст которой заключен в блок async.

Для использования асинхронных методов в .NET Framework, предназначенных для других асинхронных моделей с F# асинхронной моделью программирования, создается функция, возвращающая F# `Async` объект. F# Библиотека содержит функции, упрощающие это.

Сюда входит один пример использования асинхронных рабочих процессов; в документации есть множество других методов [класса Async](https://msdn.microsoft.com/library/03eb4d12-a01a-4565-a077-5e83f17cf6f7).

В этом примере показано, как использовать асинхронные рабочие процессы для параллельного выполнения вычислений.

В следующем примере кода функция `fetchAsync` получает текст HTML, возвращаемый веб-запросом. `fetchAsync` Функция содержит асинхронный блок кода. Если привязка выполняется к результату асинхронного примитива, в данном случае [`AsyncDownloadString`](https://msdn.microsoft.com/library/8a85a9b7-f712-4cac-a0ce-0a797f8ea32a)— Let! используется вместо let.

Функция [`Async.RunSynchronously`](https://msdn.microsoft.com/library/0a6663a9-50f2-4d38-8bf3-cefd1a51fd6b) используется для выполнения асинхронной операции и ожидания ее результата. Например, можно выполнить несколько асинхронных операций параллельно, используя [`Async.Parallel`](https://msdn.microsoft.com/library/aa9b0355-2d55-4858-b943-cbe428de9dc4) функцию вместе `Async.RunSynchronously` с функцией. Функция принимает список `Async` объектов, настраивает код для каждого `Async` объекта задачи `Async` для параллельного выполнения и возвращает объект, представляющий параллельное вычисление. `Async.Parallel` Точно так же, как и для одной операции `Async.RunSynchronously` , вы вызываете, чтобы начать выполнение.

`runAll` Функция запускает три асинхронных рабочих процесса в параллельном режиме и ожидает до завершения всех.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet8003.fs)]

## <a name="see-also"></a>См. также

- [Справочник по языку F#](index.md)
- [Выражения вычисления](computation-expressions.md)
- [Класс Control. Async](https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.async-class-%5bfsharp%5d)
