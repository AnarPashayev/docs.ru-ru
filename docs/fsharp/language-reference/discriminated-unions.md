---
title: Размеченные объединения
description: Сведения об использовании F# размеченные объединения.
ms.date: 05/16/2016
ms.openlocfilehash: 27fb9205f3f216adc435483fd1dcc839a6e13e03
ms.sourcegitcommit: 682c64df0322c7bda016f8bfea8954e9b31f1990
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/13/2019
ms.locfileid: "65557960"
---
# <a name="discriminated-unions"></a>Размеченные объединения

Размеченные объединения обеспечивают поддержку значений, которые может принимать одно из множества именованных вариантов, возможно, с разными значениями и типами. Размеченные объединения удобны для разнородных данных; данные, которые могут иметь особые случаи, включая допустимые и ошибочные; данные, зависит от одного экземпляра типа в другой. и в качестве альтернативы иерархии небольших объектов. Кроме того, рекурсивные размеченные объединения используются для представления древовидных структур данных.

## <a name="syntax"></a>Синтаксис

```fsharp
[ attributes ]
type [accessibility-modifier] type-name =
    | case-identifier1 [of [ fieldname1 : ] type1 [ * [ fieldname2 : ] type2 ...]
    | case-identifier2 [of [fieldname3 : ]type3 [ * [ fieldname4 : ]type4 ...]

    [ member-list ]
```

## <a name="remarks"></a>Примечания

Размеченные объединения аналогичны типам объединений в других языках, но существуют различия. Как с типом объединения в C++ или типа variant в Visual Basic, данные, хранящиеся в значении не фиксирована; он может принимать одно из нескольких отдельных вариантов. В отличие от объединений в этих других языках, однако каждому из таких возможных вариантов присваивается *идентификатор варианта*. Идентификаторы варианта представляют собой имена для различных типов возможных значений, которые могут быть объекты этого типа; значения являются необязательными. Если значения отсутствуют, вариант эквивалентен варианту перечисления. Если значения присутствуют, каждое значение может быть одно значение заданного типа или кортежем, объединяющим несколько полей из одной или разных типов. Можно присвоить имя, определенное поле, но имя является необязательным, даже если другие поля в том же регистре имеют имена.

По умолчанию специальные возможности для размеченных объединений `public`.

Например рассмотрим следующее объявление типа Shape.

```fsharp
type Shape =
    | Rectangle of width : float * length : float
    | Circle of radius : float
    | Prism of width : float * float * height : float
```

Предыдущий код объявляет фигуры размеченного объединения, которая может иметь значения любого из трех случаях: Прямоугольник, круг и Prism. Каждый случай имеет другой набор полей. Случае прямоугольника имеет два именованных поля, оба типа `float`, которые имеют длину и ширину. В случае с кругом имеется только одно именованное поле radius. В случае призмы поля содержит 3, два из которых (ширина и высота) с именем поля. Неименованные поля называются анонимные поля.

Объекты создаются путем задания значений для именованных и анонимных полей согласно следующим примерам.

```fsharp
let rect = Rectangle(length = 1.3, width = 10.0)
let circ = Circle (1.0)
let prism = Prism(5., 2.0, height = 3.0)
```

Этот код показывает, что вы можете использовать именованные поля в инициализации или можно полагаться на упорядочивание полей в объявлении и просто предоставить значения для каждого поля, в свою очередь. Вызов конструктора для `rect` в предыдущем коде использует именованные поля, но вызов конструктора для `circ` использует порядок. Вы можете совместно использовать упорядоченные и именованные поля, как конструирование `prism`.

`option` Тип — это простое размеченное объединение в F# основной библиотеки. `option` Тип объявляется следующим образом.

```fsharp
// The option type is a discriminated union.
type Option<'a> =
    | Some of 'a
    | None
```

Предыдущий код указывает, что тип `Option` — это размеченное объединение, имеющее два варианта `Some` и `None`. `Some` Case имеет связанное значение, которое состоит из одного анонимные поля, тип которого представлен параметром типа `'a`. `None` Случай не имеет связанного значения. Таким образом `option` тип указывает универсальный тип, который либо имеет значение некоторого типа, либо не имеет значения. Тип `Option` также имеет псевдоним в нижнем регистре, `option`, то есть сведения, которые обычно используются.

Идентификаторы варианта может использоваться в качестве конструкторов типа размеченного объединения. Например, следующий код используется для создания значений `option` типа.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2001.fs)]

Идентификаторы варианта также используются в выражениях сопоставления шаблонов. В выражении сопоставления с шаблонами идентификаторы предоставляются для значений, связанных с отдельными вариантами. Например, в следующем коде `x` идентификатор, которому присваивается значение, с которым связан `Some` вариант `option` типа.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2002.fs)]

В выражениях сопоставления шаблонов можно использовать именованные поля для задания соответствия размеченным объединениям. Для типа фигуры, который был объявлен ранее можно использовать именованные поля, как показывает следующий код для извлечения значений полей.

```fsharp
let getShapeHeight shape =
    match shape with
    | Rectangle(height = h) -> h
    | Circle(radius = r) -> 2. * r
    | Prism(height = h) -> h
```

Обычно идентификаторы варианта могут использоваться без указания имени объединения. Если вы хотите использовать имя, чтобы всегда уточняться именем объединения, можно применить [RequireQualifiedAccess](https://msdn.microsoft.com/visualfsharpdocs/conceptual/core.requirequalifiedaccessattribute-class-[fsharp]) к определению типа объединения атрибут.

### <a name="unwrapping-discriminated-unions"></a>Распаковки размеченные объединения

В F# размеченные объединения часто используются в модели предметной области для упаковки одного типа. Это можно легко извлечь базового значения с помощью сопоставления шаблонов, а также. Не нужно использовать выражение match для одного объекта:

```fsharp
let ([UnionCaseName] [values]) = [UnionValue]
```

Следующий пример демонстрирует это:

```fsharp
type ShaderProgram = | ShaderProgram of id:int

let someFunctionUsingShaderProgram shaderProgram =
    let (ShaderProgram id) = shaderProgram
    // Use the unwrapped value
    ...
```

Сопоставление шаблонов также допускается непосредственно в виде параметров, поэтому можно снять оболочку с одного варианта:

```fsharp
let someFunctionUsingShaderProgram (ShaderProgram id) =
    // Use the unwrapped value
    ...
```

## <a name="struct-discriminated-unions"></a>Размеченные объединения

Начиная с F# 4.1, может также представлять размеченные объединения, как структуры.  Это делается с помощью `[<Struct>]` атрибута.

```fsharp
[<Struct>]
type SingleCase = Case of string

[<Struct>]
type Multicase =
    | Case1 of Case1 : string
    | Case2 of Case2 : int
    | Case3 of Case3 : double
```

Так как они являются типами значений и не ссылаться на типы, существуют дополнительные рекомендации по сравнению со ссылкой на размеченные объединения:

1. Они будут скопированы в качестве типов значений и имеют семантика типа значения.
2. Рекурсивное определение типа нельзя использовать со структурой multicase размеченные объединения.
3. Необходимо указать уникальные имена вариантов для структуры multicase размеченные объединения.

## <a name="using-discriminated-unions-instead-of-object-hierarchies"></a>Использование размеченных объединений вместо иерархий объектов

Часто размеченное объединение можно использовать в качестве более простой альтернативы небольшой иерархии объектов. Например, следующее размеченное объединение может использоваться вместо `Shape` базового класса, имеющего производные классы для окружности, квадрата и т. д.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2003.fs)]

Вместо виртуального метода для вычисления площади или периметра, который бы использовался в объектно ориентированной реализации, можно использовать сопоставление шаблонов для выбора соответствующих формул расчета этих величин. В следующем примере различные формулы используются для вычисления площади, зависит от формы.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2004.fs)]

Выходные данные выглядят следующим образом:

```
Area of circle that has radius 15.000000: 706.858347
Area of square that has side 10.000000: 100.000000
Area of rectangle that has height 5.000000 and width 10.000000 is 50.000000
```

## <a name="using-discriminated-unions-for-tree-data-structures"></a>Использование размеченных объединений для древовидных структур данных

Размеченные объединения могут быть рекурсивными, это означает, что само объединение может быть включено в тип одного или нескольких случаях. Рекурсивные размеченные объединения могут использоваться для создания древовидных структур, которые используются для моделирования выражений в языках программирования. В следующем коде рекурсивное размеченное объединение используется для создания древовидной структуры двоичных данных. Объединение состоит из двух вариантов `Node`, который является узел с целым значением, а также левую и правую ветви, и `Tip`, завершающий дерево.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2005.fs)]

В приведенном выше коде `resultSumTree` имеет значение 10. Ниже показана структура дерева для `myTree`.

![Схема, показывающая структура дерева myTree.](../media/discriminated-unions/tree-structure-mytree.png)

Размеченные объединения хорошо работают, если узлы дерева являются разнородными. В следующем коде, тип `Expression` представляет дерево абстрактного синтаксиса выражения в простом языке программирования, поддерживающем сложение и умножение чисел и переменных. Некоторые из вариантов объединения не являются рекурсивными и представляют либо числа (`Number`) или переменные (`Variable`). Другие варианты являются рекурсивными и представляют операции (`Add` и `Multiply`), в которых операнды также являются выражениями. `Evaluate` Функции используется выражение match для рекурсивной обработки дерева синтаксиса.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2006.fs)]

При выполнении этого кода, значение `result` равно 5.

## <a name="common-attributes"></a>Общие атрибуты

Следующие атрибуты часто встречающихся в размеченные объединения:

* `[RequireQualifiedAccess]`
* `[NoEquality]`
* `[NoComparison]`
* `[Struct]`

## <a name="see-also"></a>См. также

- [Справочник по языку F#](index.md)
