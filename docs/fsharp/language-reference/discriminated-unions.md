---
title: Размеченные объединения
description: Узнайте, как использовать F# размеченные объединения.
ms.date: 05/16/2016
ms.openlocfilehash: 539e2843c0bbc8c5ac9c0597ffc5443f8cd127f8
ms.sourcegitcommit: 700ea803fb06c5ce98de017c7f76463ba33ff4a9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/19/2020
ms.locfileid: "77452647"
---
# <a name="discriminated-unions"></a>Размеченные объединения

Размеченные объединения обеспечивают поддержку значений, которые могут быть одного из нескольких именованных вариантов, возможно, с разными значениями и типами. Размеченные объединения полезны для разнородных данных. данные, которые могут иметь особые случаи, включая допустимые и ошибочные варианты; данные, которые могут различаться в типе от одного экземпляра к другому; а также в качестве альтернативы для небольших иерархий объектов. Кроме того, рекурсивные размеченные объединения используются для представления древовидных структур данных.

## <a name="syntax"></a>Синтаксис

```fsharp
[ attributes ]
type [accessibility-modifier] type-name =
    | case-identifier1 [of [ fieldname1 : ] type1 [ * [ fieldname2 : ] type2 ...]
    | case-identifier2 [of [fieldname3 : ]type3 [ * [ fieldname4 : ]type4 ...]

    [ member-list ]
```

## <a name="remarks"></a>Remarks

Размеченные объединения похожи на типы объединения на других языках, но существуют различия. Как и в случае с типом C++ объединения в или типа variant в Visual Basic, данные, хранящиеся в значении, не являются фиксированными; Это может быть один из нескольких различных параметров. Однако в отличие от объединений в этих других языках, каждому из возможных параметров присваивается *идентификатор варианта*. Идентификаторы вариантов — это имена различных возможных типов значений, которые могут быть объектами этого типа. значения являются необязательными. Если значения не указаны, регистр эквивалентен регистру перечисления. При наличии значений каждое значение может быть одним значением указанного типа или кортежем, который объединяет несколько полей одного или разных типов. Можно присвоить имя отдельному полю, но имя является необязательным, даже если другие поля в том же регистре называются.

По умолчанию специальные возможности для размеченных объединений имеют значение `public`.

Например, рассмотрим следующее объявление типа фигуры.

```fsharp
type Shape =
    | Rectangle of width : float * length : float
    | Circle of radius : float
    | Prism of width : float * float * height : float
```

Приведенный выше код объявляет фигуру размеченного объединения, которая может иметь значения любого из трех вариантов: прямоугольника, круга и Prism. Каждый вариант имеет другой набор полей. В прямоугольнике есть два именованных поля типа `float`, которые имеют имена Width и length. В круглом варианте есть только одно именованное поле, RADIUS. В Prism Case есть три поля, два из которых (ширина и высота) называются полями. Безымянные поля называются анонимными полями.

Объекты создаются путем предоставления значений для именованных и анонимных полей в соответствии со следующими примерами.

```fsharp
let rect = Rectangle(length = 1.3, width = 10.0)
let circ = Circle (1.0)
let prism = Prism(5., 2.0, height = 3.0)
```

Этот код показывает, что можно либо использовать именованные поля в инициализации, либо полагаться на порядок полей в объявлении и просто предоставить значения для каждого поля в свою очередь. В вызове конструктора для `rect` в предыдущем коде используются именованные поля, но при вызове конструктора для `circ` используется упорядочение. Можно смешивать упорядоченные поля и именованные поля, как в построении `prism`.

Тип `option` — это простое размеченное объединение в F# основной библиотеке. Тип `option` объявляется следующим образом.

```fsharp
// The option type is a discriminated union.
type Option<'a> =
    | Some of 'a
    | None
```

Предыдущий код указывает, что тип `Option` является размеченного Union с двумя случаями: `Some` и `None`. `Some` вариант имеет связанное значение, состоящее из одного анонимного поля, тип которого представлен параметром типа `'a`. `None` регистр не имеет связанного значения. Таким же типом `option` указывает универсальный тип, который либо имеет значение некоторого типа, либо не имеет значения. Тип `Option` также имеет псевдоним типа "нижний регистр", `option`, который чаще всего используется.

Идентификаторы вариантов можно использовать в качестве конструкторов для типа размеченного объединения. Например, следующий код используется для создания значений типа `option`.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2001.fs)]

Идентификаторы вариантов также используются в выражениях сопоставления шаблонов. В выражении сопоставления шаблонов идентификаторы предоставляются для значений, связанных с отдельными вариантами. Например, в следующем коде `x` является идентификатором, которому присваивается значение, связанное с `Some`ным вариантом типа `option`.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2002.fs)]

В выражениях сопоставления шаблонов можно использовать именованные поля для указания совпадений размеченного объединения. Для типа фигуры, объявленного ранее, можно использовать именованные поля, как показано в следующем коде, чтобы извлечь значения полей.

```fsharp
let getShapeWidth shape =
    match shape with
    | Rectangle(width = w) -> w
    | Circle(radius = r) -> 2. * r
    | Prism(width = w) -> w
```

Как правило, идентификаторы вариантов можно использовать без уточнения их именем объединения. Если необходимо, чтобы имя всегда было дополнено именем объединения, можно применить атрибут [рекуирекуалифиедакцесс](https://msdn.microsoft.com/visualfsharpdocs/conceptual/core.requirequalifiedaccessattribute-class-[fsharp]) к определению типа объединения.

### <a name="unwrapping-discriminated-unions"></a>Разтекание размеченных объединений

В F# размеченных объединениях часто используются в моделировании доменов для упаковки одного типа. Также можно легко извлечь базовое значение с помощью сопоставления шаблонов. Не нужно использовать выражение соответствия для одного варианта:

```fsharp
let ([UnionCaseIdentifier] [values]) = [UnionValue]
```

Следующий пример демонстрирует это:

```fsharp
type ShaderProgram = | ShaderProgram of id:int

let someFunctionUsingShaderProgram shaderProgram =
    let (ShaderProgram id) = shaderProgram
    // Use the unwrapped value
    ...
```

Сопоставление шаблонов также разрешено непосредственно в параметрах функции, поэтому можно разворачивать один случай:

```fsharp
let someFunctionUsingShaderProgram (ShaderProgram id) =
    // Use the unwrapped value
    ...
```

## <a name="struct-discriminated-unions"></a>Размеченные объединения структуры

Можно также представить размеченные объединения как структуры.  Это делается с помощью атрибута `[<Struct>]`.

```fsharp
[<Struct>]
type SingleCase = Case of string

[<Struct>]
type Multicase =
    | Case1 of Case1 : string
    | Case2 of Case2 : int
    | Case3 of Case3 : double
```

Так как это типы значений, а не ссылочные типы, существуют дополнительные рекомендации по сравнению со ссылочными объединениями.

1. Они копируются как типы значений и имеют семантику типов значений.
2. Нельзя использовать определение рекурсивного типа с многовариантным размеченное объединением.
3. Необходимо указать уникальные имена вариантов для размеченного объединения с многовариантными структурами.

## <a name="using-discriminated-unions-instead-of-object-hierarchies"></a>Использование размеченных объединений вместо иерархий объектов

Вы часто можете использовать размеченное объединение в качестве более простой альтернативы небольшой иерархии объектов. Например, следующее размеченное объединение можно использовать вместо базового класса `Shape`, который имеет производные типы для окружности, квадрата и т. д.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2003.fs)]

Вместо виртуального метода для вычисления области или периметра, как при использовании в объектно-ориентированной реализации, можно использовать сопоставление шаблонов для ветвления в соответствующих формулах для вычисления этих количеств. В следующем примере для вычисления области используются различные формулы, в зависимости от фигуры.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2004.fs)]

Вывод выглядит следующим образом.

```console
Area of circle that has radius 15.000000: 706.858347
Area of square that has side 10.000000: 100.000000
Area of rectangle that has height 5.000000 and width 10.000000 is 50.000000
```

## <a name="using-discriminated-unions-for-tree-data-structures"></a>Использование размеченных объединений для структур данных дерева

Размеченные объединения могут быть рекурсивными, что означает, что объединение может включаться в тип одного или нескольких вариантов. Рекурсивные размеченные объединения можно использовать для создания древовидных структур, которые используются для моделирования выражений в языках программирования. В следующем коде рекурсивное размеченное объединение используется для создания структуры данных в двоичном дереве. Объединение состоит из двух вариантов: `Node`, который является узлом с целочисленным значением и левым и правым поддеревьями, и `Tip`, который завершает дерево.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2005.fs)]

В приведенном выше коде `resultSumTree` имеет значение 10. На следующем рисунке показана древовидная структура для `myTree`.

![Схема, показывающая древовидную структуру для Митри.](../media/discriminated-unions/tree-structure-mytree.png)

Размеченные объединения хорошо работают, если узлы в дереве являются разнородными. В следующем коде тип `Expression` представляет абстрактное дерево синтаксиса выражения в простом языке программирования, который поддерживает сложение и умножение чисел и переменных. Некоторые варианты объединения не являются рекурсивными и представляют либо числа (`Number`), либо переменные (`Variable`). Другие варианты являются рекурсивными и представляют операции (`Add` и `Multiply`), где операнды также являются выражениями. Функция `Evaluate` использует выражение match для рекурсивной обработки дерева синтаксиса.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2006.fs)]

При выполнении этого кода значение `result` равно 5.

## <a name="members"></a>Члены

Можно определить элементы в размеченных объединениях. В следующем примере показано, как определить свойство и реализовать интерфейс:

```fsharp
open System

type IPrintable =
    abstract Print: unit -> unit

type Shape =
    | Circle of float
    | EquilateralTriangle of float
    | Square of float
    | Rectangle of float * float

    member this.Area =
        match this with
        | Circle r -> 2.0 * Math.PI * r
        | EquilateralTriangle s -> s * s * sqrt 3.0 / 4.0
        | Square s -> s * s
        | Rectangle(l, w) -> l * w

    interface IPrintable with
        member this.Print () =
            match this with
            | Circle r -> printfn "Circle with radius %f" r
            | EquilateralTriangle s -> printfn "Equilateral Triangle of side %f" s
            | Square s -> printfn "Square with side %f" s
            | Rectangle(l, w) -> printfn "Rectangle with length %f and width %f" l w
```

## <a name="common-attributes"></a>Общие атрибуты

В размеченных объединениях обычно встречаются следующие атрибуты:

- `[<RequireQualifiedAccess>]`
- `[<NoEquality>]`
- `[<NoComparison>]`
- `[<Struct>]`

## <a name="see-also"></a>См. также раздел

- [Справочник по языку F#](index.md)
