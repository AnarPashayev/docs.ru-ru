---
title: Размеченные объединения
description: Узнайте, как использовать дискриминируемые союзы.
ms.date: 05/16/2016
ms.openlocfilehash: 539e2843c0bbc8c5ac9c0597ffc5443f8cd127f8
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401073"
---
# <a name="discriminated-unions"></a>Размеченные объединения

Дискриминируемые союзы обеспечивают поддержку ценностей, которые могут быть одним из нескольких названных случаев, возможно, каждый с различными значениями и типами. Дискриминируемые союзы полезны для получения неоднородных данных; данные, которые могут иметь особые случаи, включая действительные и случаи ошибки; данные, которые различаются по типу в зависимости от другого; и в качестве альтернативы для малых объектов иерархии. Кроме того, для представления структур данных о деревьях используются рекурсивные дискриминирующие союзы.

## <a name="syntax"></a>Синтаксис

```fsharp
[ attributes ]
type [accessibility-modifier] type-name =
    | case-identifier1 [of [ fieldname1 : ] type1 [ * [ fieldname2 : ] type2 ...]
    | case-identifier2 [of [fieldname3 : ]type3 [ * [ fieldname4 : ]type4 ...]

    [ member-list ]
```

## <a name="remarks"></a>Remarks

Дискриминируемые союзы аналогичны типам профсоюзов на других языках, но существуют различия. Как и в отношении типа соединения в C- или типа варианта в Visual Basic, данные, хранящиеся в значении, не фиксируются; это может быть один из нескольких различных вариантов. В отличие от союзов на этих других языках, однако, каждый из возможных вариантов дается *идентификатор случая*. Идентификаторы случаев представляют имена для различных возможных типов значений, которыми могут быть объекты этого типа; значения не являются обязательными. Если значения отсутствуют, случай эквивалентен делу о перечислении. При наличии значений каждое значение может быть либо одним значением определенного типа, либо тулутом, который агрегирует несколько полей одного или одного типа. Вы можете дать отдельному полю имя, но имя необязательно, даже если названы другие поля в том же случае.

Доступность для дискриминируемых `public`профсоюзов по умолчанию .

Например, рассмотрим следующую декларацию типа формы.

```fsharp
type Shape =
    | Rectangle of width : float * length : float
    | Circle of radius : float
    | Prism of width : float * float * height : float
```

Предыдущий код объявляет дискриминационную форму союза, которая может иметь значения любого из трех случаев: Rectangle, Circle и Prism. Каждый случай имеет свой набор полей. Корпус Rectangle имеет два названных `float`поля, оба типа, которые имеют ширину и длину названий. В корпусе Круга есть только одно названное поле радиус. Случай Prism имеет три поля, два из которых (ширина и высота) названы полями. Неназванные поля называются анонимными полями.

Объекты строятся, предоставляя значения для названных и анонимных полей в соответствии со следующими примерами.

```fsharp
let rect = Rectangle(length = 1.3, width = 10.0)
let circ = Circle (1.0)
let prism = Prism(5., 2.0, height = 3.0)
```

Этот код показывает, что вы можете использовать названные поля в инициализации, либо можно положиться на упорядочение полей в декларации и просто предоставить значения для каждого поля в свою очередь. Конструктор вызова `rect` в предыдущем коде использует названные поля, но `circ` конструктор вызова для использования заказа. Можно смешивать заказанные поля и названные `prism`поля, как при строительстве.

Тип `option` представляет собой простой дискриминируемый союз в основной библиотеке F. Тип `option` объявляется следующим образом.

```fsharp
// The option type is a discriminated union.
type Option<'a> =
    | Some of 'a
    | None
```

Предыдущий код указывает, что `Option` тип является дискриминируемым `Some` союзом, который имеет два случая, и `None`. Случай `Some` имеет связанное значение, которое состоит из одного анонимного `'a`поля, тип которого представлен параметром типа. Случай `None` не имеет связанного значения. Таким `option` образом, тип определяет общий тип, который либо имеет значение определенного типа, либо не имеет значения. Тип `Option` также имеет псевдоним нижнего типа, `option`который чаще используется.

Идентификаторы случаев могут использоваться в качестве конструкторов для дискриминируемого типа профсоюза. Например, для создания значений `option` типа используется следующий код.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2001.fs)]

Идентификаторы случая также используются в выражениях, соответствующих шаблонам. В выражении, соответствуя шаблону, идентификаторы предоставляются значения, связанные с отдельными случаями. Например, в следующем `x` коде является идентификатор, `Some` учитывая `option` значение, связанное с случаем типа.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2002.fs)]

При сопоставлении шаблонов можно использовать именные поля для указания дискриминированных совпадений соединения. Для типа формы, который был объявлен ранее, можно использовать названные поля в качестве следующего кода для извлечения значений полей.

```fsharp
let getShapeWidth shape =
    match shape with
    | Rectangle(width = w) -> w
    | Circle(radius = r) -> 2. * r
    | Prism(width = w) -> w
```

Как правило, идентификаторы случаев могут быть использованы без квалификации их с именем союза. Если вы хотите, чтобы имя всегда квалифицировалось с названием союза, вы можете применить атрибут [RequireQualifiedAccess](https://msdn.microsoft.com/visualfsharpdocs/conceptual/core.requirequalifiedaccessattribute-class-[fsharp]) к определению типа соединения.

### <a name="unwrapping-discriminated-unions"></a>Разворачивание дискриминированных союзов

В F-дискриированных союзах часто используются в моделировании доменов для упаковки одного типа. Легко извлечь основное значение с помощью шаблона соответствия, а также. Вам не нужно использовать выражение соответствия для одного случая:

```fsharp
let ([UnionCaseIdentifier] [values]) = [UnionValue]
```

Следующий пример демонстрирует это:

```fsharp
type ShaderProgram = | ShaderProgram of id:int

let someFunctionUsingShaderProgram shaderProgram =
    let (ShaderProgram id) = shaderProgram
    // Use the unwrapped value
    ...
```

Соответствие шаблона также допускается непосредственно в параметрах функции, так что вы можете развернуть один случай там:

```fsharp
let someFunctionUsingShaderProgram (ShaderProgram id) =
    // Use the unwrapped value
    ...
```

## <a name="struct-discriminated-unions"></a>Struct дискриминируемые союзы

Вы также можете представлять дискриминируемые союзы как структуры.  Это делается `[<Struct>]` с атрибутом.

```fsharp
[<Struct>]
type SingleCase = Case of string

[<Struct>]
type Multicase =
    | Case1 of Case1 : string
    | Case2 of Case2 : int
    | Case3 of Case3 : double
```

Поскольку это типы значений, а не типы ссылок, существуют дополнительные соображения по сравнению со ссылками дискриминируемых союзов:

1. Они копируются как типы значений и имеют семантику типа значений.
2. Вы не можете использовать рекурсивное определение типа с многокомпонентным структурированным дискриминированным союзом.
3. Вы должны предоставить уникальные имена дел для многокомпонентного структурного дискриминируемого союза.

## <a name="using-discriminated-unions-instead-of-object-hierarchies"></a>Использование дискриминируемых союзов вместо иерархии объектов

Часто можно использовать дискриминируемый союз как более простую альтернативу иерархии малых объектов. Например, вместо `Shape` базового класса, который вывел типы для круга, квадрата и так далее, можно использовать следующий дискриминируемый союз.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2003.fs)]

Вместо виртуального метода вычисления области или периметра, как это можно использовать в объектно-ориентированной реализации, можно использовать шаблон, соответствующий ветвке, соответствующим формулам для вычисления этих количеств. В следующем примере для вычисления области используются различные формулы в зависимости от формы.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2004.fs)]

Вывод выглядит следующим образом.

```console
Area of circle that has radius 15.000000: 706.858347
Area of square that has side 10.000000: 100.000000
Area of rectangle that has height 5.000000 and width 10.000000 is 50.000000
```

## <a name="using-discriminated-unions-for-tree-data-structures"></a>Использование дискриминируемых союзов для структур данных деревьев

Дискриминируемые союзы могут быть рекурсивными, а это означает, что сам союз может быть включен в тип одного или нескольких случаев. Рекурсивные дискриминируемые союзы могут использоваться для создания структур деревьев, которые используются для моделирования выражений в языках программирования. В следующем коде для создания бинарной структуры данных дерева используется рекурсивный дискриминируемый союз. Союз состоит из двух `Node`случаев, которые представляет собой узла с цельным значением и левые и правые поддеревья, и `Tip`, который завершает дерево.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2005.fs)]

В предыдущем коде значение `resultSumTree` 10. Следующая иллюстрация показывает `myTree`структуру дерева для .

![Диаграмма, которая показывает структуру дерева для myTree.](../media/discriminated-unions/tree-structure-mytree.png)

Дискриминированные союзы хорошо работают, если узлы в дереве неоднородны. В следующем коде `Expression` тип представляет абстрактное древо синтаксиса выражения на простом языке программирования, которое поддерживает добавление и умножение чисел и переменных. Некоторые из случаев соединения не являются рекурсивными и представляют собой либо цифры ()`Number`или переменные ().`Variable` Другие случаи являются рекурсивными, и представляют операции (и`Add` `Multiply`), где операции также выражения. Функция `Evaluate` использует выражение соответствия для рекурсивной обработки дерева синтаксиса.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2006.fs)]

Когда этот код выполняется, `result` значение 5.

## <a name="members"></a>Члены

Можно определить членов по дискриминируемым профсоюзам. В следующем примере показано, как определить свойство и реализовать интерфейс:

```fsharp
open System

type IPrintable =
    abstract Print: unit -> unit

type Shape =
    | Circle of float
    | EquilateralTriangle of float
    | Square of float
    | Rectangle of float * float

    member this.Area =
        match this with
        | Circle r -> 2.0 * Math.PI * r
        | EquilateralTriangle s -> s * s * sqrt 3.0 / 4.0
        | Square s -> s * s
        | Rectangle(l, w) -> l * w

    interface IPrintable with
        member this.Print () =
            match this with
            | Circle r -> printfn "Circle with radius %f" r
            | EquilateralTriangle s -> printfn "Equilateral Triangle of side %f" s
            | Square s -> printfn "Square with side %f" s
            | Rectangle(l, w) -> printfn "Rectangle with length %f and width %f" l w
```

## <a name="common-attributes"></a>Общие атрибуты

Следующие атрибуты обычно наблюдаются в дискриминируемых союзах:

- `[<RequireQualifiedAccess>]`
- `[<NoEquality>]`
- `[<NoComparison>]`
- `[<Struct>]`

## <a name="see-also"></a>См. также раздел

- [Ссылка на язык F](index.md)
