---
title: Форматирование обычного текста
description: 'Узнайте, как использовать printf и другое форматирование в виде обычного текста в приложениях и скриптах F #.'
ms.date: 07/22/2020
ms.openlocfilehash: 90a861736dae69dfbc199a19e24f587c42404737
ms.sourcegitcommit: 7476c20d2f911a834a00b8a7f5e8926bae6804d9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2020
ms.locfileid: "88063787"
---
# <a name="plain-text-formatting"></a>Форматирование обычного текста

F # поддерживает форматирование с проверкой типа на обычный текст с помощью `printf` `printfn` функций,, `sprintf` и.
например следующие.

```console
dotnet fsi

> printfn "Hello %s, %d + %d is %d" "world" 2 2 (2+2);;
```

дает выходные данные

```fsharp
Hello world, 2 + 2 is 4
```

F # также позволяет форматировать структурированные значения в виде обычного текста.
Например, рассмотрим следующий пример, в котором выходные данные форматируются как отображение кортежей в виде матрицы.

```console
dotnet fsi

> printfn "%A" [ for i in 1 .. 5 -> [ for j in 1 .. 5 -> (i, j) ] ];;

[[(1, 1); (1, 2); (1, 3); (1, 4); (1, 5)];
 [(2, 1); (2, 2); (2, 3); (2, 4); (2, 5)];
 [(3, 1); (3, 2); (3, 3); (3, 4); (3, 5)];
 [(4, 1); (4, 2); (4, 3); (4, 4); (4, 5)];
 [(5, 1); (5, 2); (5, 3); (5, 4); (5, 5)]]
```

Структурированное форматирование обычного текста активируется при использовании `%A` формата в `printf` строках форматирования.
Он также активируется при форматировании выходных данных значений в F # Interactive, где выходные данные содержат дополнительные сведения, а также являются настраиваемыми.
Форматирование в виде обычного текста также наблюдаемое через вызовы в `x.ToString()` отношении объединения и записи F #, включая те, которые происходят неявно при отладке, ведении журнала и других средствах.

## <a name="checking-of-printf-format-strings"></a>Проверка `printf` строк формата

Если `printf` функция форматирования используется с аргументом, который не соответствует спецификаторам формата printf в строке формата, будет выведено сообщение об ошибке времени компиляции.  например следующие.

```fsharp
sprintf "Hello %s" (2+2)
```

дает выходные данные

```console
  sprintf "Hello %s" (2+2)
  ----------------------^

stdin(3,25): error FS0001: The type 'string' does not match the type 'int'
```

Технически говоря, при использовании `printf` и других связанных функций специальное правило в компиляторе F # проверяет строковый литерал, переданный в качестве строки формата, гарантируя, что последующие аргументы имеют правильный тип в соответствии с используемыми описателями формата.

## <a name="format-specifiers-for-printf"></a>Описатели формата для`printf`

Спецификации формата для `printf` форматов — это строки с `%` маркерами, которые указывают на формат. Заполнители формата состоят из того `%[flags][width][.precision][type]` места, где тип интерпретируется следующим образом:

| Описатель формата   | Типы (s)        | Remarks                      |
|:-------------------|:---------------|:-----------------------------|
| `%b`               | bool      | В формате `true` или`false`                |
| `%s`               | строка    | Отформатировано как Неэкранированное содержимое         |
| `%c`               | char      | Отформатировано как символьный литерал  |
| `%d`, `%i`         | Базовый целочисленный тип | Отформатировано как десятичное целое число, подписанное, если базовый целочисленный тип имеет знак |
| `%u`               | Базовый целочисленный тип | Отформатировано как десятичное целое число без знака   |
| `%x`, `%X`         | Базовый целочисленный тип | Отформатировано как шестнадцатеричное число без знака (a-f или A-F для шестнадцатеричных цифр соответственно)  |
|  `%o`              | Базовый целочисленный тип | Отформатировано как восьмеричное число без знака |
| `%e`, `%E`         | базовый тип с плавающей точкой | В виде значения со знаком, имеющего форму, `[-]d.dddde[sign]ddd` где d — одна десятичная цифра, dddd — одна или несколько десятичных цифр, DDD — ровно три десятичных цифры, а знак — `+` или`-` |
| `%f`               | базовый тип с плавающей точкой | Отформатировано как значение со знаком, имеющее форму `[-]dddd.dddd` , где `dddd` — одна или несколько десятичных цифр. Количество цифр перед десятичной запятой зависит от величины числа, а количество знаков после десятичной запятой зависит от указанной точности. |
| `%g`, `%G` | базовый тип с плавающей точкой |  Форматировано с использованием в качестве значения, напечатанного в `%f` `%e` формате или, в зависимости от того, какое значение является более компактным для заданного значения и точности. |
| `%M` | `System.Decimal`значение  |    Отформатировано с помощью `"G"` описателя формата для`System.Decimal.ToString(format)` |
| `%O` | любое значение  |   Отформатировано с помощью упаковки-преобразования объекта и вызова его `System.Object.ToString()` метода |
| `%A` | любое значение  |   Форматирование с использованием [структурированного форматирования обычного текста](plaintext-formatting.md) с параметрами макета по умолчанию |
| `%a` | любое значение  |   Требуется два аргумента: функция форматирования, принимающая параметр контекста и значение, и конкретное значение для печати |
| `%t` | любое значение  |   Требуется один аргумент: функция форматирования, принимающая параметр контекста, который либо выводит, либо возвращает соответствующий текст. |
| `%%` | (нет)  |   Не требует аргументов и выводит обычный знак процента:`%` |

Базовые целочисленные типы: `byte` ( `System.Byte` ), `sbyte` ( `System.SByte` ), `int16` ( `System.Int16` ), `uint16` ( `System.UInt16` ), `int32` ( `System.Int32` ), `uint32` ( `System.UInt32` ), `int64` ( `System.Int64` ), `uint64` (), () `System.UInt64` `nativeint` `System.IntPtr` и `unativeint` ( `System.UIntPtr` ).
Базовые типы с плавающей запятой: `float` ( `System.Double` ) и `float32` ( `System.Single` ).

Необязательная ширина — это целое число, указывающее минимальную ширину результата. Например, `%6d` выводит целое число, предваряя его пробелами, чтобы заполнить не менее шести символов. Если задано значение Width `*` , то для указания соответствующей ширины берется дополнительный целочисленный аргумент.

Допустимые флаги:

| Flag   | Действие        | Remarks                      |
|:-------------------|:---------------|:-----------------------------|
| `0`  | Добавьте нули вместо пробелов, чтобы сделать требуемую ширину |    |
| `-` |  Выровнять результат по левому краю указанной ширины |   |
| `+`  | Добавить `+` символ, если число является положительным (для соответствия `-` знаку отрицательных чисел) |   |
| символ пробела | Добавить дополнительный пробел, если число является положительным (для сопоставления знака "-" для отрицательных чисел) |

Флаг printf `#` является недопустимым, и при его использовании будет выводиться сообщение об ошибке во время компиляции.

Значения форматируются с использованием инвариантного языка и региональных параметров. Параметры языка и региональных параметров несущественны для `printf` форматирования, за исключением случаев, когда они влияют на результаты `%O` `%A` форматирования и. Дополнительные сведения см. в разделе [структурированное форматирование обычного текста](plaintext-formatting.md).

## <a name="a-formatting"></a>`%A`форматирован

`%A`Описатель формата используется для форматирования значений в удобочитаемом виде и может быть полезен для создания отчетов о диагностических данных.

### <a name="primitive-values"></a>Примитивные значения

При форматировании обычного текста с помощью `%A` спецификатора числовые значения F # форматируются с помощью суффикса и инвариантного языка и региональных параметров. Значения с плавающей запятой форматируются с использованием 10 точек точности с плавающей запятой. например следующие.

```fsharp
printfn "%A" (1L, 3n, 5u, 7, 4.03f, 5.000000001, 5.0000000001)
```

результатом

```console
(1L, 3n, 5u, 7, 4.03000021f, 5.000000001, 5.0)
```

При использовании `%A` спецификатора строки форматируются с помощью кавычек. Escape-коды не добавляются, а вместо них выводятся необработанные символы. например следующие.

```fsharp
printfn "%A" ("abc", "a\tb\nc\"d")

```

результатом

```console
("abc", "a      b
c"d")
```

### <a name="net-values"></a>Значения .NET

При форматировании обычного текста с помощью `%A` спецификатора объекты .NET, отличные от F #, форматируются с помощью `x.ToString()` параметров по умолчанию .NET, заданных в `System.Globalization.CultureInfo.CurrentCulture` и `System.Globalization.CultureInfo.CurrentUICulture` .  например следующие.

```fsharp
open System.Globalization

let date = System.DateTime(1999, 12, 31)

CultureInfo.CurrentCulture <- CultureInfo.GetCultureInfo("de-DE")
printfn "Culture 1: %A" date

CultureInfo.CurrentCulture <- CultureInfo.GetCultureInfo("en-US")
printfn "Culture 2: %A" date
```

результатом

```console
Culture 1: 31.12.1999 00:00:00
Culture 2: 12/31/1999 12:00:00 AM
```

### <a name="structured-values"></a>Структурированные значения

При форматировании обычного текста с помощью `%A` спецификатора для списков и кортежей F # используется отступ блока. Это показано в предыдущем примере.
Также используется структура массивов, включая многомерные массивы.  Одномерные массивы отображаются с `[| ... |]` синтаксисом. например следующие.

```fsharp
printfn "%A" [| for i in 1 .. 20 -> (i, i*i) |]
```

результатом

```console
[|(1, 1); (2, 4); (3, 9); (4, 16); (5, 25); (6, 36); (7, 49); (8, 64); (9, 81);
  (10, 100); (11, 121); (12, 144); (13, 169); (14, 196); (15, 225); (16, 256);
  (17, 289); (18, 324); (19, 361); (20, 400)|]
```

Ширина печати по умолчанию — 80.  Эту ширину можно настроить с помощью ширины печати в описателе формата. например следующие.

```fsharp
printfn "%10A" [| for i in 1 .. 5 -> (i, i*i) |]

printfn "%20A" [| for i in 1 .. 5 -> (i, i*i) |]

printfn "%50A" [| for i in 1 .. 5 -> (i, i*i) |]
```

результатом

```console
[|(1, 1);
  (2, 4);
  (3, 9);
  (4, 16);
  (5, 25)|]
[|(1, 1); (2, 4);
  (3, 9); (4, 16);
  (5, 25)|]
[|(1, 1); (2, 4); (3, 9); (4, 16); (5, 25)|]
```

Если задать ширину печати, равную 0, то ширина печати не будет использоваться. Будет выдаваться одна строка текста, за исключением тех случаев, когда в выходных данных содержатся разрывы строк.  Пример

```fsharp
printfn "%0A" [| for i in 1 .. 5 -> (i, i*i) |]

printfn "%0A" [| for i in 1 .. 5 -> "abc\ndef" |]
```

результатом

```console
[|(1, 1); (2, 4); (3, 9); (4, 16); (5, 25)|]
[|"abc
def"; "abc
def"; "abc
def"; "abc
def"; "abc
def"|]
```

Ограничение глубины 4 используется для значений Sequence ( `IEnumerable` ), которые отображаются как `seq { ...}` . Для списка и значений массива используется ограничение глубины 100.
например следующие.

```fsharp
printfn "%A" (seq { for i in 1 .. 10 -> (i, i*i) })
```

результатом

```console
seq [(1, 1); (2, 4); (3, 9); (4, 16); ...]
```

Отступ блока также используется для структуры общих значений записей и объединений. например следующие.

```fsharp
type R = { X : int list; Y : string list }

printfn "%A" { X =  [ 1;2;3 ]; Y = ["one"; "two"; "three"] }
```

результатом

```console
{ X = [1; 2; 3]
  Y = ["one"; "two"; "three"] }
```

Если `%+A` используется, то закрытая структура записей и объединений также раскрывается с помощью отражения. Пример

```fsharp
type internal R =
    { X : int list; Y : string list }
    override _.ToString() = "R"

let internal data = { X = [ 1;2;3 ]; Y = ["one"; "two"; "three"] }

printfn "external view:\n%A" data

printfn "internal view:\n%+A" data

```

результатом

```console
external view:
R

internal view:
{ X = [1; 2; 3]
  Y = ["one"; "two"; "three"] }
```

### <a name="large-cyclic-or-deeply-nested-values"></a>Большие, цикличные или глубоко вложенные значения

Большие структурированные значения форматируются до максимального общего числа узлов объектов в 10000.
Глубоко вложенные значения форматируются в глубину 100.  В обоих случаях `...` используется для елиде некоторых выходных данных.  например следующие.

```fsharp
type Tree =
    | Tip
    | Node of Tree * Tree

let rec make n =
    if n = 0 then
        Tip
    else
        Node(Tip, make (n-1))

printfn "%A" (make 1000)
```

создает большой выход с некоторыми частями неучтенный:

```console
Node(Tip, Node(Tip, ....Node (..., ...)...))
```

Циклы обнаруживаются на графах объектов и `...` используются в местах, где обнаруживаются циклы. Пример

```fsharp
type R = { mutable Links: R list }
let r = { Links = [] }
r.Links <- [r]
printfn "%A" r
```

результатом

```console
{ Links = [...] }
```

### <a name="lazy-null-and-function-values"></a>Значения "Lazy", "null" и "Function"

Отложенные значения выводятся в виде `Value is not created` или эквивалентного текста, если значение еще не было оценено.

Значения NULL выводятся, как `null` если только статический тип значения не определен как тип объединения, где `null` является разрешенным представлением.

Значения функции F # выводятся в виде имени для внутреннего создания, например `<fun:it@43-7>` .

### <a name="customize-plain-text-formatting-with-structuredformatdisplay"></a>Настроить форматирование обычного текста с помощью`StructuredFormatDisplay`

При использовании `%A` спецификатора `StructuredFormatDisplay` учитывается присутствие атрибута в объявлениях типов.  Это можно использовать для указания замещающего текста и свойства для вывода значения. Пример.

```fsharp
[<StructuredFormatDisplay("Counts({Clicks})")>]
type Counts = { Clicks:int list}

printfn "%20A" {Clicks=[0..20]}
```

результатом

```console
Counts([0; 1; 2; 3;
        4; 5; 6; 7;
        8; 9; 10; 11;
        12; 13; 14;
        15; 16; 17;
        18; 19; 20])
```

### <a name="customize-plain-text-formatting-by-overriding-tostring"></a>Настройка форматирования обычного текста путем переопределения`ToString`

Реализация по умолчанию `ToString` является наблюдаемой в программировании на F #. Часто результаты по умолчанию не подходят для использования в информации, отображаемой программистом, или в выходных данных пользователя, и поэтому обычно переопределяют реализацию по умолчанию.  

По умолчанию записи и типы объединения F # переопределяют реализацию `ToString` с реализацией, которая использует `sprintf "%+A"` .  например следующие.

```fsharp
type Counts = { Clicks:int list }

printfn "%s" ({Clicks=[0..10]}.ToString())
```

результатом

```console
{ Clicks = [0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10] }
```

Для типов классов реализация по умолчанию не `ToString` предоставляется, и используется значение по умолчанию .NET, которое сообщает имя типа. например следующие.

```fsharp
type MyClassType(clicks: int list) =
   member _.Clicks = clicks

let data = [ MyClassType([1..5]); MyClassType([1..5]) ]
printfn "Default structured print gives this:\n%A" data
printfn "Default ToString gives:\n%s" (data.ToString())
```

результатом

```console
Default structured print gives this:
[MyClassType; MyClassType]
Default ToString gives:
[MyClassType; MyClassType]
```

Добавление переопределения для `ToString` может обеспечить лучшее форматирование.

```fsharp
type MyClassType(clicks: int list) =
   member _.Clicks = clicks
   override _.ToString() = sprintf "MyClassType(%0A)" clicks

let data = [ MyClassType([1..5]); MyClassType([1..5]) ]
printfn "Now structured print gives this:\n%A" data
printfn "Now ToString gives:\n%s" (data.ToString())
```

результатом

```console
Now structured print gives this:
[MyClassType([1; 2; 3; 4; 5]); MyClassType([1; 2; 3; 4; 5])]
Now ToString gives:
[MyClassType([1; 2; 3; 4; 5]); MyClassType([1; 2; 3; 4; 5])]
```

## <a name="f-interactive-structured-printing"></a>F# Interactive структурированной печати

F# Interactive ( `dotnet fsi` ) использует расширенную версию структурированного форматирования обычного текста для передачи значений и обеспечивает дополнительную настраиваемость. Дополнительные сведения см. в разделе [F# Interactive](fsharp-interactive-options.md).

## <a name="customize-debug-displays"></a>Настройка отображения отладки

Отладчики для .NET используют атрибуты, такие как `DebuggerDisplay` и `DebuggerTypeProxy` , и они влияют на структурированное отображение объектов в окнах проверки отладчика.
Компилятор F # автоматически создал эти атрибуты для размеченных объединений и типов записей, но не для типов класса, интерфейса или структуры.

Эти атрибуты не учитываются в форматировании обычного текста F #, но может быть полезно реализовать эти методы для улучшения отображения при отладке типов F #.

## <a name="see-also"></a>См. также

- [Строки](strings.md)
- [Записи](records.md)
- [Размеченные объединения](discriminated-unions.md)
- [F# Interactive](fsharp-interactive-options.md)
