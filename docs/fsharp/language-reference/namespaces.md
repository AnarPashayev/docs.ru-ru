---
title: Пространства имен
description: 'Узнайте, как пространство имен F # позволяет организовать код в области связанных функций, позволяя присоединить имя к группированию элементов программы.'
ms.date: 12/08/2018
ms.openlocfilehash: bf71843349434a1ea91c58dbc0477373dbb0c449
ms.sourcegitcommit: de7f589de07a9979b6ac28f54c3e534a617d9425
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/05/2020
ms.locfileid: "82796136"
---
# <a name="namespaces"></a>Пространства имен

Пространство имен позволяет организовать код в области связанных функций, позволяя присоединить имя к группированию элементов программы F #. Пространства имен обычно являются элементами верхнего уровня в файлах F #.

## <a name="syntax"></a>Синтаксис

```fsharp
namespace [rec] [parent-namespaces.]identifier
```

## <a name="remarks"></a>Remarks

Если вы хотите поместить код в пространство имен, первое объявление в файле должно объявлять пространство имен. Содержимое всего файла затем становится частью пространства имен, если другое объявление пространств имен не существует в файле. В этом случае весь код наследуется до тех пор, пока следующее объявление пространства имен не станет частью первого пространства имен.

Пространства имен не могут содержать непосредственно значения и функции. Вместо этого значения и функции должны включаться в модули, а модули включаются в пространства имен. Пространства имен могут содержать типы, модули.

Комментарии XML doc можно объявить над пространством имен, но они не учитываются. Директивы компилятора также можно объявить над пространством имен.

Пространства имен могут быть объявлены явно с помощью ключевого слова namespace или неявно при объявлении модуля. Чтобы объявить пространство имен явным образом, используйте ключевое слово namespace, за которым следует имя пространства имен. В следующем примере показан файл кода, в котором объявляется пространство `Widgets` имен с типом и модулем, входящим в это пространство имен.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet6406.fs)]

Если все содержимое файла находится в одном модуле, можно также объявить пространства имен неявно, используя `module` ключевое слово и указав новое имя пространства имен в полном имени модуля. В следующем примере показан файл кода, в котором объявляется пространство `Widgets` имен и модуль `WidgetsModule`, который содержит функцию.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet6401.fs)]

Следующий код эквивалентен предыдущему коду, но модуль является объявлением локального модуля. В этом случае пространство имен должно располагаться в отдельной строке.

[!code-fsharp[Main](~/samples/snippets/fsharp/namespaces/snippet6402.fs)]

Если в одном файле или нескольких пространствах имен требуется несколько модулей, необходимо использовать объявления локальных модулей. При использовании объявлений локального модуля нельзя использовать полное пространство имен в объявлениях модуля. В следующем коде показан файл с объявлением пространства имен и двумя объявлениями локального модуля. В этом случае модули содержатся непосредственно в пространстве имен. не существует неявно созданного модуля, имя которого совпадает с именем файла. Любой другой код в файле, например `do` привязка, находится в пространстве имен, но не во внутренних модулях, поэтому необходимо уточнить элемент `widgetFunction` модуля, используя имя модуля.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet6403.fs)]

Выходные данные этого примера выглядят следующим образом.

```fsharp
Module1 10 20
Module2 5 6
```

Дополнительные сведения см. в разделе [модули](modules.md).

## <a name="nested-namespaces"></a>Вложенные пространства имен

При создании вложенного пространства имен необходимо полностью уточнить его. В противном случае создается новое пространство имен верхнего уровня. Отступ не учитывается в объявлениях пространств имен.

В следующем примере показано, как объявить вложенное пространство имен.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet6404.fs)]

## <a name="namespaces-in-files-and-assemblies"></a>Пространства имен в файлах и сборках

Пространства имен могут охватывать несколько файлов в одном проекте или компиляции. Фрагмент «термин *пространства имен* » описывает часть пространства имен, включенную в один файл. Пространства имен могут также охватывать несколько сборок. Например, `System` пространство имен включает в себя весь .NET Framework, охватывающий множество сборок и содержащий множество вложенных пространств имен.

## <a name="global-namespace"></a>Глобальное пространство имен

Для размещения имен в пространстве `global` имен .NET верхнего уровня используется предопределенное пространство имен.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet6407.fs)]

Можно также использовать Global для ссылки на пространство имен .NET верхнего уровня, например, чтобы разрешить конфликты имен с другими пространствами имен.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet6408.fs)]

## <a name="recursive-namespaces"></a>Рекурсивные пространства имен

Пространства имен также можно объявить как рекурсивные, чтобы обеспечить взаимную рекурсивную рекурсию для всего автономного кода.  Это делается с помощью `namespace rec`. Использование служб `namespace rec` может сократить некоторые трудности, не позволяя писать взаимно ссылочный код между типами и модулями. Ниже приведен пример.

```fsharp
namespace rec MutualReferences

type Orientation = Up | Down
type PeelState = Peeled | Unpeeled

// This exception depends on the type below.
exception DontSqueezeTheBananaException of Banana

type Banana(orientation : Orientation) =
    member val IsPeeled = false with get, set
    member val Orientation = orientation with get, set
    member val Sides: PeelState list = [ Unpeeled; Unpeeled; Unpeeled; Unpeeled] with get, set

    member self.Peel() = BananaHelpers.peel self // Note the dependency on the BananaHelpers module.
    member self.SqueezeJuiceOut() = raise (DontSqueezeTheBananaException self) // This member depends on the exception above.

module BananaHelpers =
    let peel (b: Banana) =
        let flip (banana: Banana) =
            match banana.Orientation with
            | Up ->
                banana.Orientation <- Down
                banana
            | Down -> banana

        let peelSides (banana: Banana) =
            banana.Sides
            |> List.map (function
                         | Unpeeled -> Peeled
                         | Peeled -> Peeled)

        match b.Orientation with
        | Up ->   b |> flip |> peelSides
        | Down -> b |> peelSides
```

Обратите внимание, `DontSqueezeTheBananaException` что исключение и `Banana` класс ссылаются друг на друга.  Кроме того, модуль `BananaHelpers` и класс `Banana` также ссылаются друг на друга. Если в F # вы удалили `rec` ключевое слово из `MutualReferences` пространства имен, это было бы невозможно выразить.

Эта функция также доступна для [модулей](modules.md)верхнего уровня.

## <a name="see-also"></a>См. также раздел

- [Справочник по языку F #](index.md)
- [Модули](modules.md)
- [F # RFC FS-1009-разрешить взаимно ссылочные типы и модули в более крупных областях внутри файлов](https://github.com/fsharp/fslang-design/blob/master/FSharp-4.1/FS-1009-mutually-referential-types-and-modules-single-scope.md)
