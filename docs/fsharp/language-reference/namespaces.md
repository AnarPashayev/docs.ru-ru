---
title: Пространства имен
description: Сведения о том F# , как пространство имен позволяет организовать код в области связанных функций, позволяя присоединить имя к группированию элементов программы.
ms.date: 12/08/2018
ms.openlocfilehash: a55da1592b04c64576b4c66de61b5ca137289a6f
ms.sourcegitcommit: 14ad34f7c4564ee0f009acb8bfc0ea7af3bc9541
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/01/2019
ms.locfileid: "73425049"
---
# <a name="namespaces"></a>Пространства имен

Пространство имен позволяет организовать код в области связанных функций, позволяя присоединить имя к группированию элементов F# программы. Пространства имен обычно являются элементами верхнего уровня в F# файлах.

## <a name="syntax"></a>Синтаксис

```fsharp
namespace [rec] [parent-namespaces.]identifier
```

## <a name="remarks"></a>Заметки

Если вы хотите поместить код в пространство имен, первое объявление в файле должно объявлять пространство имен. Содержимое всего файла затем становится частью пространства имен, если другое объявление пространств имен не существует в файле. В этом случае весь код наследуется до тех пор, пока следующее объявление пространства имен не станет частью первого пространства имен.

Пространства имен не могут содержать непосредственно значения и функции. Вместо этого значения и функции должны включаться в модули, а модули включаются в пространства имен. Пространства имен могут содержать типы, модули.

Комментарии XML doc можно объявить над пространством имен, но они не учитываются. Директивы компилятора также можно объявить над пространством имен.

Пространства имен могут быть объявлены явно с помощью ключевого слова namespace или неявно при объявлении модуля. Чтобы объявить пространство имен явным образом, используйте ключевое слово namespace, за которым следует имя пространства имен. В следующем примере показан файл кода, в котором объявляется пространство имен `Widgets` с типом и модулем, входящим в это пространство имен.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet6406.fs)]

Если все содержимое файла находится в одном модуле, можно также объявить пространства имен неявно, используя ключевое слово `module` и указав новое имя пространства имен в полном имени модуля. В следующем примере показан файл кода, в котором объявляется пространство имен `Widgets` и модуль `WidgetsModule`, который содержит функцию.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet6401.fs)]

Следующий код эквивалентен предыдущему коду, но модуль является объявлением локального модуля. В этом случае пространство имен должно располагаться в отдельной строке.

[!code-fsharp[Main](~/samples/snippets/fsharp/namespaces/snippet6402.fs)]

Если в одном файле или нескольких пространствах имен требуется несколько модулей, необходимо использовать объявления локальных модулей. При использовании объявлений локального модуля нельзя использовать полное пространство имен в объявлениях модуля. В следующем коде показан файл с объявлением пространства имен и двумя объявлениями локального модуля. В этом случае модули содержатся непосредственно в пространстве имен. не существует неявно созданного модуля, имя которого совпадает с именем файла. Любой другой код в файле, например привязка `do`, находится в пространстве имен, но не во внутренних модулях, поэтому необходимо уточнить члена модуля `widgetFunction` с помощью имени модуля.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet6403.fs)]

Выходные данные этого примера выглядят следующим образом.

```fsharp
Module1 10 20
Module2 5 6
```

Дополнительные сведения см. в разделе [модули](modules.md).

## <a name="nested-namespaces"></a>Вложенные пространства имен

При создании вложенного пространства имен необходимо полностью уточнить его. В противном случае создается новое пространство имен верхнего уровня. Отступ не учитывается в объявлениях пространств имен.

В следующем примере показано, как объявить вложенное пространство имен.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet6404.fs)]

## <a name="namespaces-in-files-and-assemblies"></a>Пространства имен в файлах и сборках

Пространства имен могут охватывать несколько файлов в одном проекте или компиляции. Фрагмент «термин *пространства имен* » описывает часть пространства имен, включенную в один файл. Пространства имен могут также охватывать несколько сборок. Например, пространство имен `System` включает в себя весь .NET Framework, который охватывает множество сборок и содержит множество вложенных пространств имен.

## <a name="global-namespace"></a>Глобальное пространство имен

Для размещения имен в пространстве имен .NET верхнего уровня используется предопределенное `global` пространства имен.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet6407.fs)]

Можно также использовать Global для ссылки на пространство имен .NET верхнего уровня, например, чтобы разрешить конфликты имен с другими пространствами имен.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet6408.fs)]

## <a name="recursive-namespaces"></a>Рекурсивные пространства имен

Пространства имен также можно объявить как рекурсивные, чтобы обеспечить взаимную рекурсивную рекурсию для всего автономного кода.  Это выполняется с помощью `namespace rec`. Использование `namespace rec` может сократить некоторые трудности, не позволяя писать взаимно ссылочный код между типами и модулями. Ниже приведен пример.

```fsharp
namespace rec MutualReferences

type Orientation = Up | Down
type PeelState = Peeled | Unpeeled

// This exception depends on the type below.
exception DontSqueezeTheBananaException of Banana

type BananaPeel() = class end

type Banana(orientation : Orientation) =
    member val IsPeeled = false with get, set
    member val Orientation = orientation with get, set
    member val Sides: PeelState list = [ Unpeeled; Unpeeled; Unpeeled; Unpeeled] with get, set

    member self.Peel() = BananaHelpers.peel self // Note the dependency on the BananaHelpers module.
    member self.SqueezeJuiceOut() = raise (DontSqueezeTheBananaException self) // This member depends on the exception above.

module BananaHelpers =
    let peel (b: Banana) =
        let flip (banana: Banana) =
            match banana.Orientation with
            | Up ->
                banana.Orientation <- Down
                banana
            | Down -> banana

        let peelSides (banana: Banana) =
            banana.Sides
            |> List.map (function
                         | Unpeeled -> Peeled
                         | Peeled -> Peeled)

        match b.Orientation with
        | Up ->   b |> flip |> peelSides
        | Down -> b |> peelSides
```

Обратите внимание, что исключение `DontSqueezeTheBananaException` и класс `Banana` оба ссылаются друг на друга.  Кроме того, модуль `BananaHelpers` и класс `Banana` также ссылаются друг на друга. Это было бы невозможно выразить в F# случае удаления ключевого слова `rec` из пространства имен `MutualReferences`.

Эта функция также доступна для [модулей](modules.md)верхнего уровня.

## <a name="see-also"></a>См. также

- [Справочник по языку F#](index.md)
- [Модули](modules.md)
- [F#RFC FS-1009 — разрешить взаимно ссылочные типы и модули в более крупных областях внутри файлов](https://github.com/fsharp/fslang-design/blob/master/FSharp-4.1/FS-1009-mutually-referential-types-and-modules-single-scope.md)
