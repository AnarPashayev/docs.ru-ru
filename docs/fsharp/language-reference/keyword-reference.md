---
title: Справочные сведения о ключевых словах
description: 'Найдите ссылки на сведения обо всех ключевых словах языка F #.'
f1_keywords:
- new_FS
- use_FS
- end_FS
- lsl_FS
- exception_FS
- asr_FS
- if_FS
- internal_FS
- default_FS
- in_FS
- lsr_FS
- open_FS
- static_FS
- assert_FS
- match_FS
- land_FS
- with_FS
- inherit_FS
- mutable_FS
- downto_FS
- false_FS
- sig_FS
- and_FS
- true_FS
- namespace_FS
- public_FS
- lxor_FS
- val_FS
- void_FS
- downcast_FS
- function_FS
- while_FS
- for_FS
- class_FS
- done_FS
- to_FS
- module_FS
- let_FS
- delegate_FS
- abstract_FS
- then_FS
- when_FS
- lazy_FS
- try_FS
- inline_FS
- do_FS
- upcast_FS
- begin_FS
- base_FS
- fun_FS
- struct_FS
- as_FS
- extern_FS
- null_FS
- lor_FS
- return_FS
- mod_FS
- private_FS
- of_FS
- or_FS
- member_FS
- type_FS
- rec_FS
- elif_FS
- override_FS
- interface_FS
- yield_FS
- else_FS
- finally_FS
- global_FS
- select_FS
- use!_FS
- const_FS
dev_langs:
- FSharp
ms.date: 08/15/2020
ms.openlocfilehash: 15505c123dd0d6497fbc80c8fc9f0910018911ea
ms.sourcegitcommit: 8bfeb5930ca48b2ee6053f16082dcaf24d46d221
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/18/2020
ms.locfileid: "88558105"
---
# <a name="keyword-reference"></a>Справочные сведения о ключевых словах

Этот раздел содержит ссылки на сведения обо всех ключевых словах языка F #.

## <a name="f-keyword-table"></a>Таблица ключевых слов F #

В следующей таблице показаны все ключевые слова F # в алфавитном порядке, а также краткие описания и ссылки на соответствующие разделы, содержащие дополнительные сведения.

|Ключевое слово|Ссылка|Описание|
|-------|----|-----------|
|`abstract`|[Участники](./members/index.md)<br /><br />[Абстрактные классы](abstract-classes.md)|Указывает метод, который либо не имеет реализации в типе, в котором он объявлен, либо является виртуальным и имеет реализацию по умолчанию.|
|`and`|[`let` Привязки](./functions/let-bindings.md)<br /><br />[Записи](records.md)<br /><br />[Участники](./members/index.md)<br /><br />[Учитывая](./generics/constraints.md)|Используется в взаимно рекурсивных привязках и записях, в объявлениях свойств и с несколькими ограничениями на универсальные параметры.|
|`as`|[Классы](classes.md)<br /><br />[Соответствие шаблону](Pattern-Matching.md)|Используется для присвоения объекту текущего класса имени объекта. Также используется для присвоения имени целому шаблону в соответствии с шаблоном.|
|`assert`|[Проверочные утверждения](assertions.md)|Используется для проверки кода во время отладки.|
|`base`|[Классы](classes.md)<br /><br />[Наследование](inheritance.md)|Используется в качестве имени объекта базового класса.|
|`begin`|[Подробный синтаксис](verbose-syntax.md)|В подробном синтаксисе обозначает начало блока кода.|
|`class`|[Классы](classes.md)|В подробном синтаксисе обозначает начало определения класса.|
|`default`|[Участники](./members/index.md)|Указывает реализацию абстрактного метода; используется вместе с объявлением абстрактного метода для создания виртуального метода.|
|`delegate`|[Делегаты](delegates.md)|Используется для объявления делегата.|
|`do`|[Привязки do](./functions/do-bindings.md)<br /><br />[Циклы: выражение `for...to`](loops-for-to-expression.md)<br /><br />[Циклы: выражение `for...in`](loops-for-in-expression.md)<br /><br />[Циклы: выражение `while...do`](loops-while-do-expression.md)|Используется в циклических конструкциях или для выполнения императивного кода.|
|`done`|[Подробный синтаксис](verbose-syntax.md)|В подробном синтаксисе обозначает конец блока кода в цикле выражения.|
|`downcast`|[Приведение и преобразование](casting-and-conversions.md)|Используется для преобразования в тип, который находится ниже в цепочке наследования.|
|`downto`|[Циклы: выражение `for...to`](loops-for-to-expression.md)|В `for` выражении используется при подсчете в обратную.|
|`elif`|[Условные выражения: `if...then...else`](conditional-expressions-if-then-else.md)|Используется в условном ветвлении. Краткая форма `else if` .|
|`else`|[Условные выражения: `if...then...else`](conditional-expressions-if-then-else.md)|Используется в условном ветвлении.|
|`end`|[Структуры](structures.md)<br /><br />[Размеченные объединения](discriminated-unions.md)<br /><br />[Записи](records.md)<br /><br />[Расширения типов](type-extensions.md)<br /><br />[Подробный синтаксис](verbose-syntax.md)|В определениях типов и расширениях типов указывает конец раздела в определениях элементов.<br /><br />В подробном синтаксисе используется для указания конца блока кода, который начинается с `begin` ключевого слова.|
|`exception`|[Обработка исключений](./exception-handling/index.md)<br /><br />[Типы исключения](./exception-handling/exception-types.md)|Используется для объявления типа исключения.|
|`extern`|[Внешние функции](./functions/external-functions.md)|Указывает, что объявленный элемент программы определен в другом двоичном файле или сборке.|
|`false`|[Примитивные типы](basic-types.md)|Используется в качестве логического литерала.|
|`finally`|[Исключения: выражение `try...finally`](./exception-handling/the-try-finally-expression.md)|Используется вместе с, `try` чтобы ввести блок кода, который выполняется независимо от того, возникает ли исключение.|
|`fixed`|[Фиксированная](fixed.md)|Используется для «закрепления» указателя на стеке, чтобы предотвратить сбор мусора.|
|`for`|[Циклы: выражение `for...to`](loops-for-to-expression.md)<br /><br />[Циклы: выражение for...in](loops-for-in-expression.md)|Используется в циклических конструкциях.|
|`fun`|[Лямбда-выражения: `fun` ключевое слово](./functions/lambda-expressions-the-fun-keyword.md)|Используется в лямбда-выражениях, также известных как анонимные функции.|
|`function`|[Выражения match](match-expressions.md)<br /><br />[Лямбда-выражения: ключевое слово Fun](./functions/lambda-expressions-the-fun-keyword.md)|Используется в качестве более короткой альтернативы `fun` ключевому слову и `match` выражению в лямбда-выражении, которое имеет сопоставление шаблонов для одного аргумента.|
|`global`|[Пространства имен](namespaces.md)|Используется для ссылки на пространство имен .NET верхнего уровня.|
|`if`|[Условные выражения: `if...then...else`](conditional-expressions-if-then-else.md)|Используется в конструкциях условного ветвления.|
|`in`|[Циклы: выражение for...in](loops-for-in-expression.md)<br /><br />[Подробный синтаксис](verbose-syntax.md)|Используется для выражений последовательности и, в подробном синтаксисе, для разделения выражений от привязок.|
|`inherit`|[Наследование](inheritance.md)|Используется для указания базового класса или базового интерфейса.|
|`inline`|[Функции](./functions/index.md)<br /><br />[Встраиваемые функции](./functions/inline-functions.md)|Используется для указания функции, которая должна быть интегрирована непосредственно в код вызывающего объекта.|
|`interface`|[Интерфейсы](interfaces.md)|Используется для объявления и реализации интерфейсов.|
|`internal`|[Управление доступом](access-control.md)|Используется для указания того, что элемент виден внутри сборки, но не за его пределами.|
|`lazy`|[Отложенные выражения](lazy-expressions.md)|Используется для указания выражения, которое должно выполняться, только если требуется результат.|
|`let`|[`let` Привязки](./functions/let-bindings.md)|Используется для связывания или привязки имени со значением или функцией.|
|`let!`|[Асинхронные рабочие потоки](asynchronous-workflows.md)<br /><br />[Выражения вычисления](computation-expressions.md)|Используется в асинхронных рабочих процессах для привязки имени к результату асинхронного вычисления или в других вычислительных выражениях, используемых для привязки имени к результату, который имеет тип вычисления.|
|`match`|[Выражения match](match-expressions.md)|Используется для ветвления путем сравнения значения с шаблоном.|
|`match!`|[Выражения вычисления](computation-expressions.md#match)|Используется для встраивания вызова в вычислительное выражение и сопоставления шаблона с его результатом.|
|`member`|[Участники](./members/index.md)|Используется для объявления свойства или метода в типе объекта.|
|`module`|[Модули](modules.md)|Используется для связывания имени с группой связанных типов, значений и функций, чтобы логически отделить ее от другого кода.|
|`mutable`|[Привязки let](./functions/let-bindings.md)|Используется для объявления переменной, то есть значения, которое может быть изменено.|
|`namespace`|[Пространства имен](namespaces.md)|Используется для связывания имени с группой связанных типов и модулей, чтобы логически отделить его от другого кода.|
|`new`|[Конструкторы](./members/constructors.md)<br /><br />[Учитывая](./generics/constraints.md)|Используется для объявления, определения или вызова конструктора, который создает или может создать объект.<br /><br />Также используется в ограничениях универсальных параметров для указания того, что у типа должен быть определенный конструктор.|
|`not`|[Справочник символов и операторов](./symbol-and-operator-reference/index.md)<br /><br />[Учитывая](./generics/constraints.md)|В действительности не является ключевым словом. Однако `not struct` в сочетании используется как ограничение универсального параметра.|
|`null`|[Значения NULL](./values/null-values.md)<br /><br />[Учитывая](./generics/constraints.md)|Указывает на отсутствие объекта.<br /><br />Также используется в ограничениях универсальных параметров.|
|`of`|[Размеченные объединения](discriminated-unions.md)<br /><br />[Делегаты](delegates.md)<br /><br />[Типы исключения](./exception-handling/exception-types.md)|Используется в размеченных объединениях для указания типа категорий значений, а также в объявлениях делегатов и исключений.|
|`open`|[Объявления импорта: ключевое слово `open`](import-declarations-the-open-keyword.md)|Используется, чтобы сделать содержимое пространства имен или модуля доступным без квалификации.|
|`or`|[Справочник символов и операторов](./symbol-and-operator-reference/index.md)<br /><br />[Учитывая](./generics/constraints.md)|Используется с логическими условиями в качестве логического `or` оператора. Аналогично параметру `||`.<br /><br />Также используется в ограничениях элементов.|
|`override`|[Участники](./members/index.md)|Используется для реализации версии абстрактного или виртуального метода, отличающегося от базовой версии.|
|`private`|[Управление доступом](access-control.md)|Разрешает доступ к элементу в коде в том же типе или модуле.|
|`public`|[Управление доступом](access-control.md)|Разрешает доступ к члену за пределами типа.|
|`rec`|[Функции](./functions/index.md)|Используется для указания, что функция является рекурсивной.|
|`return`|[Асинхронные рабочие потоки](Asynchronous-Workflows.md)<br /><br />[Выражения вычисления](computation-expressions.md)|Используется для указания значения, которое будет предоставлено в результате вычисления выражения.|
|`return!`|[Выражения вычисления](computation-expressions.md)<br /><br />[Асинхронные рабочие потоки](asynchronous-workflows.md)|Используется для указания вычислительного выражения, которое при вычислении предоставляет результат содержащего его вычислительного выражения.|
|`select`|[Выражения запросов](query-expressions.md)|Используется в выражениях запросов для указания полей или столбцов для извлечения. Обратите внимание, что это контекстное ключевое слово, означающее, что оно не является зарезервированным словом и действует как ключевое слово в соответствующем контексте.|
|`static`|[Участники](./members/index.md)|Используется для указания метода или свойства, которые могут вызываться без экземпляра типа, или элемента значения, совместно используемого всеми экземплярами типа.|
|`struct`|[Структуры](structures.md)<br /><br /> [Кортежи](tuples.md)<br/><br/>[Учитывая](./generics/constraints.md)|Используется для объявления типа структуры.<br /><br/>Используется для указания кортежа структуры.<br/><br />Также используется в ограничениях универсальных параметров.<br /><br />Используется для совместимости OCaml в определениях модулей.|
|`then`|[Условные выражения: `if...then...else`](conditional-expressions-if-then-else.md)<br /><br />[Конструкторы](./members/constructors.md)|Используется в условных выражениях.<br /><br />Также используется для выполнения побочных эффектов после создания объекта.|
|`to`|[Циклы: выражение `for...to`](loops-for-to-expression.md)|Используется в `for` циклах для обозначения диапазона.|
|`true`|[Примитивные типы](basic-types.md)|Используется в качестве логического литерала.|
|`try`|[Исключения: выражение try...with](./exception-handling/the-try-with-expression.md)<br /><br />[Выражения: выражение try...finally](./exception-handling/the-try-finally-expression.md)|Используется для представления блока кода, который может создать исключение. Используется совместно с `with` или `finally` .|
|`type`|[Типы языка F#](fsharp-types.md)<br /><br />[Классы](classes.md)<br /><br />[Записи](records.md)<br /><br />[Структуры](structures.md)<br /><br />[Перечисления](enumerations.md)<br /><br />[Размеченные объединения](discriminated-unions.md)<br /><br />[Сокращенные обозначения типов](type-abbreviations.md)<br /><br />[Единицы измерения](units-of-measure.md)|Используется для объявления класса, записи, структуры, размеченного объединения, типа перечисления, единицы измерения или аббревиатуры типа.|
|`upcast`|[Приведение и преобразование](casting-and-conversions.md)|Используется для преобразования в тип, который находится выше в цепочке наследования.|
|`use`|[Управление ресурсами: ключевое слово `use`](resource-management-the-use-keyword.md)|Используется вместо `let` для значений, которые необходимо `Dispose` вызывать для освобождения ресурсов.|
|`use!`|[Выражения вычисления](computation-expressions.md)<br /><br />[Асинхронные рабочие потоки](asynchronous-workflows.md)|Используется вместо `let!` в асинхронных рабочих процессах и других вычислительных выражениях для значений, которые необходимо `Dispose` вызывать для освобождения ресурсов.|
|`val`|[Явные поля: `val` ключевое слово](./members/explicit-fields-the-val-keyword.md)<br /><br />[Сигнатуры](signature-files.md)<br /><br />[Участники](./members/index.md)|Используется в сигнатуре для обозначения значения или в типе для объявления члена в ограниченных ситуациях.|
|`void`|[Примитивные типы](basic-types.md)|Указывает тип .NET `void` . Используется при взаимодействии с другими языками .NET.|
|`when`|[Учитывая](./generics/constraints.md)|Используется для логических условий (*Если*условия) соответствует шаблону и для ввода предложения ограничения для параметра универсального типа.|
|`while`|[Циклы: выражение `while...do`](loops-while-do-expression.md)|Вводит циклическую конструкцию.|
|`with`|[Выражения match](match-expressions.md)<br /><br />[Выражения объекта](object-expressions.md)<br /><br />[Копирование и обновление выражений записей](copy-and-update-record-expressions.md)<br /><br />[Расширения типов](type-extensions.md)<br /><br />[Исключения: выражение `try...with`](./exception-handling/the-try-with-expression.md)|Используется вместе с `match` ключевым словом в выражениях сопоставления шаблонов. Также используется в выражениях объектов, в выражениях копирования и расширениях типов для представления определений элементов и для ввода обработчиков исключений.|
|`yield`|[Списки](lists.md), [массивы](arrays.md), [последовательности](sequences.md)|Используется в выражении списка, массива или последовательности для получения значения для последовательности. Обычно можно опустить, так как в большинстве случаев это неявно.|
|`yield!`|[Выражения вычисления](computation-expressions.md)<br /><br />[Асинхронные рабочие потоки](asynchronous-workflows.md)|Используется в вычислительном выражении для добавления результата заданного вычислительного выражения в коллекцию результатов для содержащего его выражения.|
|`const`|[Поставщики типов](../tutorials/type-providers/index.md)| Поставщики типов позволяют использовать `const` в качестве ключевого слова для указания константного литерала в качестве аргумента параметра типа.|

В F # зарезервированы следующие токены, так как они являются ключевыми словами на языке OCaml:

- `asr`
- `land`
- `lor`
- `lsl`
- `lsr`
- `lxor`
- `mod`
- `sig`

Если используется `--mlcompatibility` параметр компилятора, указанные выше ключевые слова можно использовать в качестве идентификаторов.

Следующие токены зарезервированы в качестве ключевых слов для будущего расширения языка F #:

- `atomic`
- `break`
- `checked`
- `component`
- `const`
- `constraint`
- `constructor`
- `continue`
- `eager`
- `event`
- `external`
- `functor`
- `include`
- `method`
- `mixin`
- `object`
- `parallel`
- `process`
- `protected`
- `pure`
- `sealed`
- `tailcall`
- `trait`
- `virtual`
- `volatile`

## <a name="see-also"></a>См. также

- [Справочник по языку F#](index.md)
- [Справочник символов и операторов](./symbol-and-operator-reference/index.md)
- [Параметры компилятора](compiler-options.md)
