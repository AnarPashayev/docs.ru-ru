---
title: Свойства
description: Дополнительные сведения о F# свойства, которые являются членами, которые представляют значения, связанные с объектом.
ms.date: 05/16/2016
ms.openlocfilehash: bf605ee1135bd3b3561bde9a8ae66353497931b0
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61666369"
---
# <a name="properties"></a>Свойства

*Свойства* являются членами, которые представляют значения, связанные с объектом.

## <a name="syntax"></a>Синтаксис

```fsharp
// Property that has both get and set defined.
[ attributes ]
[ static ] member [accessibility-modifier] [self-identifier.]PropertyName
with [accessibility-modifier] get() =
    get-function-body
and [accessibility-modifier] set parameter =
    set-function-body

// Alternative syntax for a property that has get and set.
[ attributes-for-get ]
[ static ] member [accessibility-modifier-for-get] [self-identifier.]PropertyName =
    get-function-body
[ attributes-for-set ]
[ static ] member [accessibility-modifier-for-set] [self-identifier.]PropertyName
with set parameter =
    set-function-body

// Property that has get only.
[ attributes ]
[ static ] member [accessibility-modifier] [self-identifier.]PropertyName =
    get-function-body

// Alternative syntax for property that has get only.
[ attributes ]
[ static ] member [accessibility-modifier] [self-identifier.]PropertyName
with get() =
    get-function-body

// Property that has set only.
[ attributes ]
[ static ] member [accessibility-modifier] [self-identifier.]PropertyName
with set parameter =
    set-function-body

// Automatically implemented properties.
[ attributes ]
[ static ] member val [accessibility-modifier] PropertyName = initialization-expression [ with get, set ]
```

## <a name="remarks"></a>Примечания

Свойства представляют собой «имеет» связь в объектно ориентированное программирование, представляющий данные, связанные с экземплярами объекта, или для статических свойств, с типом.

Вы можете объявить свойства двумя способами, в зависимости от того, требуется ли явно указать базовое значение (также называется "резервным хранилищем") для свойства, или если вы хотите разрешить компилятору автоматически создавать резервное хранилище для вас. Как правило если свойство имеет только это простая оболочка для значениям либо переменным следует использовать более явным образом, если свойство имеет нетривиальный реализацию и автоматическим способом. Чтобы объявить свойство явно, используйте `member` ключевое слово. Этот декларативный синтаксис сопровождается синтаксис, определяющий `get` и `set` методы, именуемый *методы доступа*. Различные виды явного синтаксиса, показанного в разделе "синтаксис" используются для чтения и записи, только для чтения и только для записи свойств. Для свойства только для чтения, можно определить только `get` метода; для свойства только для записи, определите только `set` метод. Обратите внимание, что, когда свойство имеет оба `get` и `set` методы доступа, альтернативный синтаксис позволяет указать атрибуты и модификаторы доступа, которые различны для каждого метода доступа, как показано в следующем коде.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet3201.fs)]

Для свойства чтения/записи, которые имеют оба `get` и `set` метод, порядок `get` и `set` могли быть отменены. Кроме того, можно указать синтаксис, показанный для `get` только и синтаксис, показанный для `set` только для того, вместо использования комбинированного синтаксиса. Это облегчает закомментируйте отдельные `get` или `set` метод, если что-то может потребоваться сделать это. В следующем коде показан этот альтернативный вариант для использования комбинированного синтаксиса.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet3203.fs)]

Частные значения данных для свойств вызываются удержанием *резервными хранилищами*. Способ применения компилятора автоматического создания резервного хранилища, используйте ключевые слова `member val`, пропущен идентификатор самого себя, а затем задать выражение для инициализации свойства. Если свойство является изменяемым, включите `with get, set`. Например следующий тип класса включает два автоматически реализуемого свойства. `Property1` только для чтения и устанавливается равным аргумент, указанный для первичного конструктора, и `Property2` является настраиваемым свойством инициализации пустую строку:

```fsharp
type MyClass(property1 : int) =
member val Property1 = property1
member val Property2 = "" with get, set
```

Автоматически реализованные свойства являются частью инициализации типа, поэтому их необходимо включить перед другими определения членов, так же, как `let` привязок и `do` привязки в определении типа. Обратите внимание на то, что выражение для инициализации автоматически реализуемого свойства вычисляется только при инициализации, а не при каждом обращении к свойству. Это поведение отличается от поведения явно реализованные свойства. Что фактически означает, что код для инициализации этих свойств добавляется в конструктор класса. Рассмотрим следующий код, который показывает это различие:

```fsharp
type MyClass() =
    let random  = new System.Random()
    member val AutoProperty = random.Next() with get, set
    member this.ExplicitProperty = random.Next()

let class1 = new MyClass()

printfn "class1.AutoProperty = %d" class1.AutoProperty
printfn "class1.AutoProperty = %d" class1.AutoProperty
printfn "class1.ExplicitProperty = %d" class1.ExplicitProperty
printfn "class1.ExplicitProperty = %d" class1.ExplicitProperty
```

**Вывод**

```
class1.AutoProperty = 1853799794
class1.AutoProperty = 1853799794
class1.ExplicitProperty = 978922705
class1.ExplicitProperty = 1131210765
```

Выходные данные приведенного выше кода показывают, что значение AutoProperty остается неизменным при вызове многократно, тогда как ExplicitProperty изменяется каждый раз, когда он вызывается. Это показывает, что для автоматически реализуемого свойства выражение не вычисляется каждый раз, как метод получения явные свойства.

>[!WARNING]
>Существуют некоторые библиотеки, такие как Entity Framework (`System.Data.Entity`), которые выполняют пользовательских операций в конструкторы базовых классов, которые не подходят для инициализации автоматически реализуемого свойства. В таком случае попробуйте использовать явные свойства.

Свойства могут быть членами классов, структур, размеченные объединения, записи, интерфейсы и расширения типов и также могут определяться в выражениях объектов.

Атрибуты могут быть применены к свойствам. Чтобы применить атрибут к свойству, записи данного атрибута в отдельной строке перед свойством. Дополнительные сведения см. в разделе [Атрибуты](../attributes.md).

По умолчанию свойства являются открытыми. Модификаторы доступа могут также применяться к свойствам. Чтобы применить модификатор доступности, добавьте его непосредственно перед именем свойства, если он предназначен для применяются к обеим версиям `get` и `set` методов; добавьте его перед `get` и `set` ключевые слова, если разные уровни доступа является обязательным для каждого метода доступа. *Модификатор доступа* может принимать одно из следующих: `public`, `private`, `internal`. Дополнительные сведения см. в статье [Управление доступом](../access-control.md).

Реализации свойств выполняются каждый раз при обращении к свойству.

## <a name="static-and-instance-properties"></a>Статические и свойств экземпляра

Свойства могут быть статическими или свойств экземпляра. Статические свойства могут вызываться без экземпляра и используются для значений, связанный с типом, а не с отдельными объектами. Для статических свойств опустите идентификатор самого себя. Идентификатор самого себя является обязательным для свойств экземпляра.

Следующее определение статического свойства основан на сценарии, в котором имеется статическое поле `myStaticValue` то есть резервное хранилище для свойства.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet3204.fs)]

Свойства могут также быть-массив, в этом случае они называются *индексированных свойств*. Дополнительные сведения см. в разделе [индексированные свойства](indexed-properties.md).

## <a name="type-annotation-for-properties"></a>Заметка типа для свойства

Во многих случаях компилятор получает достаточные сведения для определения типа свойства из типа резервного хранилища, но можно задать тип явно, добавив аннотацию типа.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet3205.fs)]

## <a name="using-property-set-accessors"></a>С помощью свойства методы доступа set

Можно задать свойства, которые предоставляют `set` методы доступа с помощью `<-` оператор.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet3206.fs)]

Выходные данные **20**.

## <a name="abstract-properties"></a>Абстрактные свойства

Свойства могут быть абстрактными. Как и в случае с методами, `abstract` просто означает, что виртуальной диспетчеризации, связанное со свойством. Абстрактные свойства могут быть по-настоящему абстрактными, то есть без определения в том же классе. Таким образом, класс, который содержит такое свойство является абстрактным классом. Кроме того абстрактный просто может означать свойство является виртуальным, что в этом случае определение должно находиться в том же классе. Обратите внимание, что абстрактные свойства не должны быть закрытыми, а если один метод доступа является абстрактным, второй также должен быть абстрактным. Дополнительные сведения об абстрактных классах см. в разделе [абстрактные классы](../abstract-classes.md).

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet3207.fs)]

## <a name="see-also"></a>См. также

- [Члены](index.md)
- [Методы](methods.md)
