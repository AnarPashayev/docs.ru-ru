---
title: Свойства
description: 'Сведения о свойствах F #, являющихся элементами, которые представляют значения, связанные с объектом.'
ms.date: 05/16/2016
ms.openlocfilehash: a2a4fbfc88831dcb5cad7a2da701969b2e98b2e3
ms.sourcegitcommit: ecd9e9bb2225eb76f819722ea8b24988fe46f34c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/05/2020
ms.locfileid: "96740202"
---
# <a name="properties"></a>Свойства

*Свойства* — это члены, представляющие значения, связанные с объектом.

## <a name="syntax"></a>Синтаксис

```fsharp
// Property that has both get and set defined.
[ attributes ]
[ static ] member [accessibility-modifier] [self-identifier.]PropertyName
with [accessibility-modifier] get() =
    get-function-body
and [accessibility-modifier] set parameter =
    set-function-body

// Alternative syntax for a property that has get and set.
[ attributes-for-get ]
[ static ] member [accessibility-modifier-for-get] [self-identifier.]PropertyName =
    get-function-body
[ attributes-for-set ]
[ static ] member [accessibility-modifier-for-set] [self-identifier.]PropertyName
with set parameter =
    set-function-body

// Property that has get only.
[ attributes ]
[ static ] member [accessibility-modifier] [self-identifier.]PropertyName =
    get-function-body

// Alternative syntax for property that has get only.
[ attributes ]
[ static ] member [accessibility-modifier] [self-identifier.]PropertyName
with get() =
    get-function-body

// Property that has set only.
[ attributes ]
[ static ] member [accessibility-modifier] [self-identifier.]PropertyName
with set parameter =
    set-function-body

// Automatically implemented properties.
[ attributes ]
[ static ] member val [accessibility-modifier] PropertyName = initialization-expression [ with get, set ]
```

## <a name="remarks"></a>Remarks

Свойства представляют собой отношение "имеет" в объектно-ориентированном программировании, представляющее данные, связанные с экземплярами объектов, или для статических свойств с типом.

Свойства можно объявить двумя способами, в зависимости от того, нужно ли явно указать базовое значение (также называемое резервным хранилищем) для свойства, или если вы хотите разрешить компилятору автоматически создавать резервное хранилище. Как правило, следует использовать более явный способ, если свойство имеет нетривиальные реализации и автоматический способ, если свойство является просто простой оболочкой для значения или переменной. Чтобы объявить свойство явным образом, используйте `member` ключевое слово. За этим декларативным синтаксисом следует синтаксис, который задает `get` `set` методы и, а также именованные способы *доступа*. Различные формы явного синтаксиса, показанного в разделе синтаксиса, используются для свойств для чтения и записи, только для чтения и только для записи. Для свойств только для чтения определяется только `get` метод; для свойств только для записи определите только `set` метод. Обратите внимание, что если свойство `get` имеет `set` методы доступа и, альтернативный синтаксис позволяет указать атрибуты и модификаторы доступа, которые отличаются для каждого метода доступа, как показано в следующем коде.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet3201.fs)]

Для свойств чтения и записи, имеющих оба `get` `set` метода и, порядок `get` и `set` может быть отменен. Кроме того, можно указать синтаксис, отображаемый `get` только для, и синтаксис, отображаемый `set` только вместо использования объединенного синтаксиса. Это упрощает комментирование отдельных `get` `set` методов или, если это может потребоваться. В следующем коде показана альтернатива использованию объединенного синтаксиса.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet3203.fs)]

Закрытые значения, которые содержат данные для свойств, называются *резервными хранилищами*. Чтобы компилятор автоматически создает резервное хранилище, используйте ключевые слова `member val` , опустите сам себя, а затем укажите выражение для инициализации свойства. Если свойство должно быть изменяемым, включите `with get, set` . Например, следующий тип класса включает два автоматически реализуемых свойства. `Property1` параметр доступен только для чтения и инициализируется с аргументом, предоставленным первичному конструктору, и `Property2` является устанавливаемым свойством, инициализированным в виде пустой строки:

```fsharp
type MyClass(property1 : int) =
member val Property1 = property1
member val Property2 = "" with get, set
```

Автоматически реализованные свойства являются частью инициализации типа, поэтому они должны быть включены перед любыми другими определениями элементов, как `let` привязки и `do` привязки в определении типа. Обратите внимание, что выражение, которое инициализирует автоматически реализуемое свойство, вычисляется только при инициализации, а не всякий раз, когда осуществляется доступ к свойству. Это поведение отличается от поведения явно реализованного свойства. Это фактически означает, что код для инициализации этих свойств добавляется в конструктор класса. Рассмотрим следующий код, демонстрирующий это различие:

```fsharp
type MyClass() =
    let random  = new System.Random()
    member val AutoProperty = random.Next() with get, set
    member this.ExplicitProperty = random.Next()

let class1 = new MyClass()

printfn $"class1.AutoProperty = %d{class1.AutoProperty}"
printfn $"class1.ExplicitProperty = %d{class1.ExplicitProperty}"
```

**Выходные данные**

```console
class1.AutoProperty = 1853799794
class1.AutoProperty = 1853799794
class1.ExplicitProperty = 978922705
class1.ExplicitProperty = 1131210765
```

Выходные данные приведенного выше кода показывают, что значение автосвойства не изменяется при повторном вызове, в то время как ЕксплиЦитпроперти изменяется при каждом вызове. Это показывает, что выражение для автоматически реализуемого свойства не вычисляется каждый раз, как и метод считывания для явного свойства.

>[!WARNING]
>Существуют некоторые библиотеки, например Entity Framework ( `System.Data.Entity` ), выполняющие пользовательские операции в конструкторах базовых классов, которые не подходят для инициализации автоматически реализуемых свойств. В таких случаях попробуйте использовать явные свойства.

Свойства могут быть членами классов, структур, размеченных объединений, записей, интерфейсов и расширений типов, а также могут быть определены в выражениях объекта.

Атрибуты могут применяться к свойствам. Чтобы применить атрибут к свойству, запишите атрибут в отдельной строке перед свойством. Дополнительные сведения см. в разделе [Атрибуты](../attributes.md).

По умолчанию свойства являются открытыми. Модификаторы доступа также могут применяться к свойствам. Чтобы применить модификатор доступа, добавьте его непосредственно перед именем свойства, если оно должно применяться к `get` `set` методам и. Добавьте его перед `get` `set` ключевыми словами и, если для каждого метода доступа требуется разная доступность. *Модификатором Accessibility* может быть один из следующих: `public` , `private` , `internal` . Дополнительные сведения см. в статье [Управление доступом](../access-control.md).

Реализации свойств выполняются каждый раз при доступе к свойству.

## <a name="static-and-instance-properties"></a>Статические и свойства экземпляра

Свойства могут быть статическими или свойствами экземпляра. Статические свойства могут вызываться без экземпляра и использоваться для значений, связанных с типом, а не с отдельными объектами. Для статических свойств опустите собственный идентификатор. Для свойств экземпляра необходим собственный идентификатор.

Следующее Статическое определение свойства основано на сценарии, в котором имеется статическое поле `myStaticValue` , являющееся резервным хранилищем для свойства.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet3204.fs)]

Свойства также могут быть подобны массиву, в этом случае они называются *индексированными свойствами*. Дополнительные сведения см. в разделе [индексированные свойства](indexed-properties.md).

## <a name="type-annotation-for-properties"></a>Аннотация типа для свойств

Во многих случаях компилятор имеет достаточно информации для определения типа свойства из типа резервного хранилища, но можно явно задать тип, добавив аннотацию типа.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet3205.fs)]

## <a name="using-property-set-accessors"></a>Использование методов доступа set свойств

Свойства, предоставляющие методы доступа, можно задать `set` с помощью `<-` оператора.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet3206.fs)]

Выходные данные имеют значение **20**.

## <a name="abstract-properties"></a>Абстрактные свойства

Свойства могут быть абстрактными. Как и в случае с методами, `abstract` просто означает, что существует виртуальная диспетчеризация, связанная со свойством. Абстрактные свойства могут быть действительно абстрактными, то есть без определения в том же классе. Таким образом, класс, содержащий такое свойство, является абстрактным классом. Кроме того, abstract может означать, что свойство является виртуальным, и в этом случае определение должно присутствовать в том же классе. Обратите внимание, что абстрактные свойства не должны быть частными, и если один метод доступа является абстрактным, то другой также должен быть абстрактным. Дополнительные сведения о абстрактных классах см. в разделе [абстрактные классы](../abstract-classes.md).

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet3207.fs)]

## <a name="see-also"></a>См. также

- [Члены](index.md)
- [Методы](methods.md)
