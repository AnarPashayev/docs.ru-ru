---
title: Конструкторы
description: 'Узнайте, как определить и использовать конструкторы в F # для создания и инициализации объектов класса и структуры.'
ms.date: 05/16/2016
ms.openlocfilehash: be8fc3f1d82a9a7c778a6d094139f14150a28813
ms.sourcegitcommit: 6f58a5f75ceeb936f8ee5b786e9adb81a9a3bee9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/28/2020
ms.locfileid: "87303443"
---
# <a name="constructors"></a>Конструкторы

В этой статье описывается определение и использование конструкторов для создания и инициализации объектов класса и структуры.

## <a name="construction-of-class-objects"></a>Создание объектов класса

Объекты типов классов имеют конструкторы. Существует два вида конструкторов. Один из них является основным конструктором, параметры которого отображаются в круглых скобках сразу после имени типа. Другие, необязательные дополнительные конструкторы указываются с помощью `new` ключевого слова. Все такие дополнительные конструкторы должны вызывать первичный конструктор.

Первичный конструктор содержит `let` и `do` привязки, которые отображаются в начале определения класса. `let`Привязка объявляет закрытые поля и методы класса; `do` Привязка выполняет код. Дополнительные сведения о `let` привязках в конструкторах классов см. [ `let` в разделе привязки в классах](let-bindings-in-classes.md). Дополнительные сведения о `do` привязках в конструкторах см. [ `do` в разделе привязки в классах](do-bindings-in-classes.md).

Независимо от того, является ли конструктор, который необходимо вызвать, основным конструктором или дополнительным конструктором, можно создавать объекты с помощью `new` выражения с ключевым словом или без него `new` . Объекты инициализируются вместе с аргументами конструктора, путем перечисления аргументов по порядку и разделенных запятыми и заключенных в круглые скобки, а также с помощью именованных аргументов и значений в круглых скобках. Вы также можете задать свойства объекта во время создания объекта, используя имена свойств и назначив значения так же, как при использовании именованных аргументов конструктора.

В следующем коде показан класс, имеющий конструктор, и различные способы создания объектов:

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet3501.fs)]

Вывод выглядит следующим образом.

```console
Initialized object that has coordinates (1, 2, 3)
Initialized object that has coordinates (4, 5, 6)
Initialized object that has coordinates (7, 8, 9)
Initialized object that has coordinates (0, 0, 0)
```

## <a name="construction-of-structures"></a>Создание структур

Структуры соответствуют всем правилам классов. Поэтому у вас может быть первичный конструктор, и можно предоставить дополнительные конструкторы с помощью `new` . Однако существует одно важное различие между структурами и классами: структуры могут иметь конструктор без параметров (то есть один без аргументов), даже если первичный конструктор не определен. Конструктор без параметров инициализирует все поля значением по умолчанию для этого типа, обычно ноль или его эквивалент. Все конструкторы, определяемые для структур, должны иметь по крайней мере один аргумент, чтобы они не конфликтовали с конструктором без параметров.

Кроме того, структуры часто имеют поля, создаваемые с помощью `val` ключевого слова; классы также могут иметь эти поля. Структуры и классы, имеющие поля, определенные с помощью `val` ключевого слова, можно также инициализировать в дополнительных конструкторах с помощью выражений записи, как показано в следующем коде.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet3502.fs)]

Дополнительные сведения см. [в разделе явные поля: `val` ключевое слово](explicit-fields-the-val-keyword.md).

## <a name="executing-side-effects-in-constructors"></a>Исполнение побочных эффектов в конструкторах

Основной конструктор в классе может выполнять код в `do` привязке. Но что делать, если необходимо выполнить код в дополнительном конструкторе без `do` привязки? Для этого используется `then` ключевое слово.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet3503.fs)]

Побочные эффекты основного конструктора по-прежнему выполняются. Таким образом, выходные данные выглядят следующим образом:

```console
Created a person object.
Created a person object.
Created an invalid person object.
```

Причина, по которой `then` требуется, вместо другой, заключается в том `do` , что `do` ключевое слово имеет стандартное значение для разграничения `unit` выражения, возвращаемого при наличии в теле дополнительного конструктора. Он имеет только особое значение в контексте основных конструкторов.

## <a name="self-identifiers-in-constructors"></a>Собственные идентификаторы в конструкторах

В других элементах вы предоставляете имя для текущего объекта в определении каждого члена. Можно также разместить собственный идентификатор в первой строке определения класса с помощью `as` ключевого слова, непосредственно следующего за параметрами конструктора. Этот синтаксис показан в следующем примере.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet3504.fs)]

В дополнительных конструкторах можно также определить собственный идентификатор, поместив `as` предложение сразу после параметров конструктора. Этот синтаксис показан в следующем примере:

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet3505.fs)]

Проблемы могут возникать при попытке использования объекта до его полного определения. Таким образом, использование собственного идентификатора может привести к тому, что компилятор выдаст предупреждение и вставит дополнительные проверки, чтобы гарантировать, что элементы объекта не будут доступны до инициализации объекта. Собственный идентификатор следует использовать только в `do` привязках первичного конструктора или после `then` ключевого слова в дополнительных конструкторах.

Имя собственного идентификатора не обязательно должно быть `this` . Это может быть любой допустимый идентификатор.

## <a name="assigning-values-to-properties-at-initialization"></a>Присвоение значений свойствам при инициализации

Можно присвоить значения свойствам объекта класса в коде инициализации, добавив список назначений формы `property = value` в список аргументов для конструктора. Это показано в следующем примере кода:

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet3506.fs)]

Следующая версия предыдущего кода иллюстрирует сочетание обычных аргументов, необязательных аргументов и параметров свойств в одном вызове конструктора:

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet3507.fs)]

## <a name="constructors-in-inherited-class"></a>Конструкторы в унаследованном классе

При наследовании от базового класса, имеющего конструктор, необходимо указать его аргументы в предложении Inherit. Дополнительные сведения см. в разделе [конструкторы и наследование](../inheritance.md#constructors-and-inheritance).

## <a name="static-constructors-or-type-constructors"></a>Статические конструкторы или конструкторы типов

Помимо указания кода для создания объектов, статические `let` и `do` привязку можно создавать в типах классов, которые выполняются до первого использования типа для выполнения инициализации на уровне типа. Дополнительные сведения см. в разделе [ `let` привязки в классах](let-bindings-in-classes.md) и [ `do` привязках в классах](do-bindings-in-classes.md).

## <a name="see-also"></a>См. также

- [Члены](index.md)
