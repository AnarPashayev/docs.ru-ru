---
title: Конструкторы
description: Узнайте, как определить и использовать конструкторы в F# для создания и инициализации объектов классов и структур.
ms.date: 05/16/2016
ms.openlocfilehash: 47fb6e77ce369d7aa4fce3aa2c97ecf7df280c03
ms.sourcegitcommit: 8699383914c24a0df033393f55db3369db728a7b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/15/2019
ms.locfileid: "65645232"
---
# <a name="constructors"></a>Конструкторы

В этом разделе описывается определение и использование конструкторов для создания и инициализации объектов классов и структур.

## <a name="construction-of-class-objects"></a>Создание объектов классов

Объекты типов классов имеют конструкторы. Существует два типа конструкторов. Одним является первичный конструктор, параметры которого отображаются в скобках сразу после имени типа. Второй — необязательные дополнительные конструкторы, которые задаются с помощью `new` ключевое слово. Такие дополнительные конструкторы необходимо вызвать первичного конструктора.

Содержит первичный конструктор `let` и `do` привязок, которые отображаются в начале определения класса. Объект `let` привязка объявляет, закрытые поля и методы класса; `do` привязки выполняет код. Дополнительные сведения о `let` привязок в конструкторах классов см. в разделе [ `let` привязок в классах](let-bindings-in-classes.md). Дополнительные сведения о `do` привязок в конструкторах, см. в разделе [ `do` привязок в классах](do-bindings-in-classes.md).

Независимо от типа необходимо вызвать конструктор первичного конструктора или дополнительный конструктор, можно создать объекты с помощью `new` выражение, с или без дополнительного `new` ключевое слово. Инициализации объектов вместе с аргументами конструктора либо, перечисляя аргументы по порядку и разделены запятыми и заключены в круглые скобки, или с помощью именованных аргументов, а также значения в скобках. Вы можно также задать свойства объекта во время создания объекта, используя имена свойств и присвоение значений, так же, как именованные аргументы конструктора.

Следующий код иллюстрирует классом, имеющим конструктор и различные способы создания объектов.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-2/snippet3501.fs)]

Выходные данные выглядят следующим образом.

```console
Initialized object that has coordinates (1, 2, 3)
Initialized object that has coordinates (4, 5, 6)
Initialized object that has coordinates (7, 8, 9)
Initialized object that has coordinates (0, 0, 0)
```

## <a name="construction-of-structures"></a>Создание структур

Структуры следовать всем правилам классов. Таким образом, может иметь первичный конструктор, и можно задать дополнительные конструкторы с помощью `new`. Однако есть одно важное отличие между структурами и классами: структуры могут иметь конструктор по умолчанию (то есть без аргументов), даже если определен без первичного конструктора. Конструктор по умолчанию инициализирует все поля, значение по умолчанию для этого типа, обычно ноль или его эквивалент. Никакие конструкторы, которые задаются для структуры должны иметь по крайней мере один аргумент, таким образом, чтобы они не конфликтовали с помощью конструктора по умолчанию.

Кроме того, структуры часто имеют поля, которые создаются с помощью `val` ключевое слово; классы также могут иметь эти поля. Структуры и классы, имеющие поля, определенные с помощью `val` ключевого слова могут также инициализироваться в дополнительных конструкторов с помощью выражений записей, как показано в следующем коде.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-2/snippet3502.fs)]

Дополнительные сведения см. в разделе [явные поля: `val` Ключевое слово](explicit-fields-the-val-keyword.md).

## <a name="executing-side-effects-in-constructors"></a>Выполнение побочных эффектов в конструкторах

Первичный конструктор в классе может выполнять код в `do` привязки. Однако что делать, если у вас есть без выполнения кода в дополнительном конструкторе `do` привязки? Чтобы сделать это, используйте `then` ключевое слово.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-2/snippet3503.fs)]

Побочные эффекты главного конструктора по-прежнему выполняются. Таким образом выходные данные выглядят следующим образом.

```console
Created a person object.
Created a person object.
Created an invalid person object.
```

## <a name="self-identifiers-in-constructors"></a>Собственные идентификаторы в конструкторах

В других членах укажите имя для текущего объекта в определении каждого члена. Можно также включить собственный идентификатор первая часть определения класса с помощью `as` ключевое слово сразу после параметров конструктора. Следующий пример иллюстрирует этот синтаксис.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-2/snippet3504.fs)]

В дополнительных конструкторов также можно определить собственный идентификатор, поместив `as` предложение сразу же после параметров конструктора. Следующий пример иллюстрирует этот синтаксис.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-2/snippet3505.fs)]

Проблемы могут возникать при попытке использовать объект, пока она полностью определена. Таким образом использует собственный идентификатор может привести к компилятору выдавать предупреждение, а также вставлять дополнительные проверки, чтобы убедиться, что членам объекта не осуществляется до инициализации объекта. Следует использовать только собственный идентификатор в `do` привязки первичного конструктора или после `then` ключевое слово в дополнительных конструкторов.

Имя данного идентификатора не обязательно должны `this`. Это может быть любой допустимый идентификатор.

## <a name="assigning-values-to-properties-at-initialization"></a>Присвоение значений свойствам при инициализации

Можно назначить значения свойствам объекта класса в коде инициализации, добавив список назначений формы `property = value` в список аргументов для конструктора. Это показано в следующем примере кода.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-2/snippet3506.fs)]

Следующая версия предыдущего примера кода показано сочетание обычные аргументы, необязательные аргументы и параметры свойств в одном вызове конструктора.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-2/snippet3507.fs)]

## <a name="constructors-in-inherited-class"></a>Конструкторы в унаследованного класса

При наследовании от базового класса, который имеет конструктор, необходимо указать аргументы в предложении наследовать. Дополнительные сведения см. в разделе [конструкторы и наследование](../inheritance.md#constructors-and-inheritance).

## <a name="static-constructors-or-type-constructors"></a>Статические конструкторы или конструкторы типов

Помимо указания кода для создания объектов, статические `let` и `do` привязки могут разрабатываться в типах классов, которые выполняются до первого использования типа для инициализации на уровне типа. Дополнительные сведения см. в разделе [ `let` привязок в классах](let-bindings-in-classes.md) и [ `do` привязок в классах](do-bindings-in-classes.md).

## <a name="see-also"></a>См. также

- [Члены](index.md)
