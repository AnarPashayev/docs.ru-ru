---
title: Методы
description: Узнайте, как F# метод является функцией, связанной с типом, которые используются для предоставления и реализовать функциональность и поведение объектов и типов.
ms.date: 05/16/2016
ms.openlocfilehash: 03150cc67f79bfde58cf27e4a9d4dfa9e9ff3f55
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61666499"
---
# <a name="methods"></a>Методы

Объект *метод* — это функция, которая связана с типом. В объектно ориентированном программировании методы используются для предоставления и реализовать функциональность и поведение объектов и типов.

## <a name="syntax"></a>Синтаксис

```fsharp
// Instance method definition.
[ attributes ]
member [inline] self-identifier.method-name parameter-list [ : return-type ] =
    method-body

// Static method definition.
[ attributes ]
static member [inline] method-name parameter-list [ : return-type ] =
    method-body

// Abstract method declaration or virtual dispatch slot.
[ attributes ]
abstract member method-name : type-signature

// Virtual method declaration and default implementation.
[ attributes ]
abstract member method-name : type-signature
[ attributes ]
default self-identifier.method-name parameter-list [ : return-type ] =
    method-body

// Override of inherited virtual method.
[ attributes ]
override self-identifier.method-name parameter-list [ : return-type ] =
    method-body

// Optional and DefaultParameterValue attributes on input parameters
[ attributes ]
[ modifier ] member [inline] self-identifier.method-name ([<Optional; DefaultParameterValue( default-value )>] input) [ : return-type ]
```

## <a name="remarks"></a>Примечания

В приведенном выше синтаксисе вы увидите различные формы метод объявлений и определений. В телах длинных методов разрыв строки следует знак равенства (=), и все тело метода отображается с отступом.

Атрибуты могут применяться к любому объявлению метода. Они предшествовать синтаксис для определения метода и обычно отображается на отдельной строке. Дополнительные сведения см. в разделе [Атрибуты](../attributes.md).

Методы могут быть отмечены `inline`. Сведения о `inline` см. в статье [Встраиваемые функции](../functions/inline-functions.md).

Non встроенные методы можно рекурсивно использовать внутри типа; Нет необходимости явно использовать `rec` ключевое слово.

## <a name="instance-methods"></a>Методы экземпляра

Методы экземпляра должны быть объявлены с `member` ключевое слово и *собственный идентификатор*, а затем точку (.), имя метода и параметры. Как в случае `let` привязок, *список параметров* может быть шаблоном. Как правило, заключите его параметры в круглые скобки в форме кортежа, который является образом методы отображаются в метод F# при их создании на других языках .NET Framework. Тем не менее каррированные (параметров, разделенных пробелами) также характерен и также поддерживаются другие шаблоны.

Следующий пример иллюстрирует определение и использование метода экземпляра, не являющемся абстрактным.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet3401.fs)]

Внутри методы экземпляра не используйте собственный идентификатор для доступа к полям, определенный с помощью привязки let. При доступе к другие элементы и свойства, используйте собственный идентификатор.

## <a name="static-methods"></a>Статические методы

Ключевое слово `static` используется для указания, что метод может вызываться без экземпляра и не связан с экземпляром объекта. В противном случае методы являются методами экземпляра.

В примере в следующем разделе показаны поля, объявленные с `let` ключевое слово, свойства, объявленные с `member` ключевое слово и статический метод, объявленный с `static` ключевое слово.

Следующий пример иллюстрирует определение и использование статических методов. Предполагается, что определения этих методов — в `SomeType` класс в предыдущем разделе.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet3402.fs)]

## <a name="abstract-and-virtual-methods"></a>Абстрактные и виртуальные методы

Ключевое слово `abstract` указывает, что метод имеет виртуальная ячейка отправки и не может иметь определение в классе. Объект *виртуальная ячейка отправки* — это запись во внутренней таблице функций, используемый для поиска виртуальных функций во время выполнения вызовов в типе объектно ориентированного. Механизм виртуальной отправки — это механизм, который реализует *полиморфизм*, важной характеристикой объектно ориентированного программирования. Является классом, имеющим по крайней мере один абстрактный метод без определения *абстрактного класса*, что означает, что экземпляры не могут создаваться этого класса. Дополнительные сведения об абстрактных классах см. в разделе [абстрактные классы](../abstract-classes.md).

Объявления абстрактных методов не содержат тела метода. Вместо этого имя метода следует двоеточие (:) и сигнатура типа для метода. Сигнатура типа метода совпадает со значением, отображаемым с помощью IntelliSense при наведении указателя мыши на имени метода в редакторе кода Visual Studio, за исключением без имен параметров. Сигнатуры типов также отображаются интерпретатором fsi.exe, во время работы в интерактивном режиме. Сигнатура типа метода формируется перечислением типы параметров и типом возвращаемого значения, с соответствующими символами-разделителями. Разделенные каррированные параметры `->` и разделяются кортежах `*`. Возвращаемое значение всегда отделяется от аргументов по `->` символов. Можно использовать скобки для группирования сложные параметры, например, если типом функции параметра, или чтобы указать, когда обрабатывается кортеж в качестве единственного параметра, а не как два параметра.

Вы можете также давать абстрактные методы определения по умолчанию путем добавления определения класса и с помощью `default` ключевое слово, как показано в приведенном в этом разделе. Абстрактный метод, который определен в том же классе соответствует виртуальный метод на других языках .NET Framework. Существует ли определение, `abstract` ключевое слово создает новую ячейку отправки в таблице виртуальных функций для класса.

Независимо от того, является ли базовый класс реализует свои абстрактные методы производные классы могут предоставлять реализации абстрактных методов. Чтобы реализовать абстрактный метод в производном классе, определите метод, который имеет то же имя и подпись в производном классе, за исключением использования `override` или `default` ключевое слово и укажите основной части метода. Ключевые слова `override` и `default` означает то же. Используйте `override` Если новый метод переопределяет реализацию базового класса; используйте `default` при создании реализация в тот же класс как абстрактный исходного объявления. Не используйте `abstract` ключевое слово на метод, который реализует метод, объявленный в базовом классе как абстрактный.

В следующем примере показан абстрактный метод `Rotate` , имеет реализацию по умолчанию, эквивалент виртуальный метод .NET Framework.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet3403.fs)]

В следующем примере производный класс, который переопределяет метод базового класса. В этом случае переопределение изменяет поведение, чтобы метод не выполняет никаких действий.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet3404.fs)]

## <a name="overloaded-methods"></a>Перегруженные методы

Перегруженные методы являются методами, имеющие идентичные имена для данного типа, но разные аргументы. В F#, вместо перегруженных методов обычно используются необязательные аргументы. Тем не менее при условии, что аргументы имеют в форме кортежа, не каррированные перегруженные методы разрешены на языке.

## <a name="optional-arguments"></a>Необязательные аргументы

Начиная с F# 4.1, может также иметь необязательные аргументы со значением параметра по умолчанию в методах.  Это помогает упростить взаимодействие с кодом C#.  Следующий пример демонстрирует синтаксис:

```fsharp
// A class with a method M, which takes in an optional integer argument.
type C() =
    __.M([<Optional; DefaultParameterValue(12)>] i) = i + 1
```

Обратите внимание, что значение, переданное в для `DefaultParameterValue` должен совпадать с типом ввода.  В приведенном выше примере это `int`.  Попытка передать нецелочисленное значение в `DefaultParameterValue` приведет к ошибке компиляции.

## <a name="example-properties-and-methods"></a>Пример Свойства и методы

Следующий пример содержит тип, который содержит примеры полей, закрытые функции, свойства и статический метод.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet3406.fs)]

## <a name="see-also"></a>См. также

- [Члены](index.md)