---
title: Методы
description: Узнайте, как F# метод — это функция, связанная с типом, который используется для предоставления и реализации функциональности и поведения объектов и типов.
ms.date: 11/04/2019
ms.openlocfilehash: 6f5ae76ea450b07763eb58d0c95b18b30f634551
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/12/2019
ms.locfileid: "73976648"
---
# <a name="methods"></a>Методы

*Метод* — это функция, которая связана с типом. В объектно-ориентированном программировании методы используются для предоставления и реализации функциональных возможностей и поведения объектов и типов.

## <a name="syntax"></a>Синтаксис

```fsharp
// Instance method definition.
[ attributes ]
member [inline] self-identifier.method-name parameter-list [ : return-type ] =
    method-body

// Static method definition.
[ attributes ]
static member [inline] method-name parameter-list [ : return-type ] =
    method-body

// Abstract method declaration or virtual dispatch slot.
[ attributes ]
abstract member method-name : type-signature

// Virtual method declaration and default implementation.
[ attributes ]
abstract member method-name : type-signature
[ attributes ]
default self-identifier.method-name parameter-list [ : return-type ] =
    method-body

// Override of inherited virtual method.
[ attributes ]
override self-identifier.method-name parameter-list [ : return-type ] =
    method-body

// Optional and DefaultParameterValue attributes on input parameters
[ attributes ]
[ modifier ] member [inline] self-identifier.method-name ([<Optional; DefaultParameterValue( default-value )>] input) [ : return-type ]
```

## <a name="remarks"></a>Заметки

В предыдущем синтаксисе можно увидеть различные формы объявлений и определений методов. В более длинных теле метода разрыв строки следует за знаком равенства (=), а весь текст метода — с отступом.

Атрибуты могут применяться к любому объявлению метода. Они предшествуют синтаксису определения метода и обычно перечисляются в отдельной строке. Дополнительные сведения см. в разделе [Атрибуты](../attributes.md).

Методы могут быть помечены `inline`. Сведения о `inline` см. в статье [Встраиваемые функции](../functions/inline-functions.md).

Невстроенные методы можно использовать рекурсивно в пределах типа. нет необходимости явно использовать ключевое слово `rec`.

## <a name="instance-methods"></a>Методы экземпляра

Методы экземпляра объявляются с помощью ключевого слова `member` и *самоидентификатора*, за которым следует точка (.) и имя и параметры метода. Как и в случае с `let`ными привязками, *параметр-List* может быть шаблоном. Как правило, параметры метода заключаются в круглые скобки в форме кортежа, то есть методы отображаются в F# , когда они создаются на других языках .NET Framework. Однако также часто встречается каррированных формы (параметры, разделенные пробелами), а также поддерживаются и другие шаблоны.

В следующем примере показано определение и использование неабстрактного метода экземпляра.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet3401.fs)]

В методах экземпляра не используйте собственный идентификатор для доступа к полям, определенным с помощью привязок let. Используйте собственный идентификатор при доступе к другим членам и свойствам.

## <a name="static-methods"></a>Статические методы

Ключевое слово `static` используется, чтобы указать, что метод может быть вызван без экземпляра и не связан с экземпляром объекта. В противном случае методы являются методами экземпляра.

В примере в следующем разделе показаны поля, объявленные с ключевым словом `let`, членами свойств, объявленными с ключевым словом `member`, и статическим методом, объявленным с помощью ключевого слова `static`.

В следующем примере показано определение и использование статических методов. Предположим, что эти определения методов находятся в классе `SomeType` в предыдущем разделе.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet3402.fs)]

## <a name="abstract-and-virtual-methods"></a>Абстрактные и виртуальные методы

Ключевое слово `abstract` указывает, что метод имеет виртуальный слот диспетчеризации и может не иметь определения в классе. *Виртуальный слот диспетчеризации* — это запись во внутренней таблице функций, которая используется во время выполнения для поиска вызовов виртуальных функций в объектно-ориентированном типе. Виртуальный механизм диспетчеризации — это механизм, который реализует *полиморфизм*, важный компонент объектно-ориентированного программирования. Класс, имеющий по крайней мере один абстрактный метод без определения, является *абстрактным классом*, что означает, что экземпляры этого класса создавать нельзя. Дополнительные сведения о абстрактных классах см. в разделе [абстрактные классы](../abstract-classes.md).

Объявления абстрактных методов не включают тело метода. Вместо этого за именем метода следует двоеточие (:) и сигнатура типа для метода. Сигнатура типа метода такая же, как и при использовании IntelliSense при наведении указателя мыши на имя метода в редакторе Visual Studio Code, за исключением случаев, когда имена параметров не указаны. Сигнатуры типов также отображаются интерпретатором (FSI. exe) при работе в интерактивном режиме. Сигнатура типа метода формируется путем перечисления типов параметров, за которыми следует возвращаемый тип с соответствующими символами-разделителями. Каррированных параметра разделяются `->` и параметры кортежа разделяются `*`. Возвращаемое значение всегда отделяется от аргументов `->` символом. Круглые скобки можно использовать для группирования сложных параметров, например, если тип функции является параметром или чтобы указать, когда кортеж обрабатывается как один параметр, а не как два параметра.

Можно также предоставить определения абстрактных методов по умолчанию, добавив определение в класс и используя ключевое слово `default`, как показано в блоке синтаксиса в этом разделе. Абстрактный метод, имеющий определение в том же классе, эквивалентен виртуальному методу на других языках .NET Framework. Независимо от того, существует ли определение, ключевое слово `abstract` создает новый слот диспетчеризации в таблице виртуальной функции для класса.

Независимо от того, реализует ли базовый класс его абстрактные методы, производные классы могут предоставлять реализации абстрактных методов. Чтобы реализовать абстрактный метод в производном классе, определите метод с тем же именем и сигнатурой в производном классе, за исключением использования ключевого слова `override` или `default` и предоставления тела метода. Ключевые слова `override` и `default` означают точно то же самое. Используйте `override`, если новый метод переопределяет реализацию базового класса; Используйте `default` при создании реализации в том же классе, что и исходное абстрактное объявление. Не используйте ключевое слово `abstract` в методе, который реализует метод, объявленный абстрактным в базовом классе.

В следующем примере показан абстрактный метод `Rotate` с реализацией по умолчанию, эквивалентом виртуального метода .NET Framework.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet3403.fs)]

В следующем примере показан производный класс, переопределяющий метод базового класса. В этом случае переопределение изменяет поведение таким образом, чтобы метод не выполнит никаких действий.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet3404.fs)]

## <a name="overloaded-methods"></a>Перегруженные методы

Перегруженные методы — это методы, имеющие одинаковые имена в заданном типе, но имеющие разные аргументы. В F#необязательные аргументы обычно используются вместо перегруженных методов. Однако перегруженные методы разрешены на языке, при условии, что аргументы находятся в виде кортежа, а не в каррированных форме.

## <a name="optional-arguments"></a>Необязательные аргументы

Начиная с F# 4,1, можно также иметь необязательные аргументы со значением параметра по умолчанию в методах.  Это помогает упростить взаимодействие с C# кодом.  Следующий пример демонстрирует синтаксис:

```fsharp
// A class with a method M, which takes in an optional integer argument.
type C() =
    _.M([<Optional; DefaultParameterValue(12)>] i) = i + 1
```

Обратите внимание, что значение, передаваемое для `DefaultParameterValue`, должно соответствовать типу входных данных.  В приведенном выше примере это `int`.  Попытка передать нецелочисленное значение в `DefaultParameterValue` приведет к ошибке компиляции.

## <a name="example-properties-and-methods"></a>Пример: свойства и методы

В следующем примере содержится тип, который содержит примеры полей, закрытых функций, свойств и статического метода.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet3406.fs)]

## <a name="see-also"></a>См. также

- [Члены](index.md)
