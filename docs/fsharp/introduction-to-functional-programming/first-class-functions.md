---
title: Функции первого класса
description: 'Узнайте о функциях первого класса и о том, как они важны для функционального программирования в F #.'
ms.date: 10/29/2018
ms.openlocfilehash: 1dc8eae1655187282f05bf4e9501ecc8a17deba8
ms.sourcegitcommit: 9c45035b781caebc63ec8ecf912dc83fb6723b1f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/25/2020
ms.locfileid: "88810915"
---
# <a name="first-class-functions"></a>Функции первого класса

Определение характеристик языков функционального программирования — это повышение уровня функций до состояния первого класса. Вы должны иметь возможность выполнять функции, которые можно использовать со значениями других встроенных типов, и иметь возможность сделать это с сравнимой степенью усилий.

К типичным мерам состояния первого класса относятся следующие:

- Можно ли привязать функции к идентификаторам? То есть можно ли присвоить им имена?

- Можно ли хранить функции в структурах данных, например в списке?

- Можно ли передать функцию в качестве аргумента в вызове функции?

- Можно ли вернуть функцию из вызова функции?

Последние две меры определяют, что называются *операциями высшего порядка* или *функциями высшего порядка*. Функции высшего порядка принимают функции в качестве аргументов и возвращают функции в качестве значений вызовов функций. Эти операции поддерживают такие основ функционального программирования, как функции сопоставления и компоновка функций.

## <a name="give-the-value-a-name"></a>Присвоить значение имени

Если функция является значением первого класса, необходимо иметь возможность присвоить ей имя, точно так же, как целые числа, строки и другие встроенные типы. В литературе по функциональному программированию это называется привязкой идентификатора к значению. F # использует [ `let` привязки](../language-reference/functions/let-bindings.md) для привязки имен к значениям: `let <identifier> = <value>` . В следующем коде показаны два примера.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet20.fs)]

Вы можете легко присвоить имя функции. В следующем примере определяется функция с именем `squareIt` путем привязки идентификатора `squareIt` к [лямбда-выражению](../language-reference/functions/lambda-expressions-the-fun-keyword.md) `fun n -> n * n` . Функция `squareIt` имеет один параметр, `n` и возвращает квадрат этого параметра.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet21.fs)]

F # предоставляет следующий более краткий синтаксис для достижения того же результата с меньшей типизацией.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet22.fs)]

В приведенных ниже примерах используется первый стиль, `let <function-name> = <lambda-expression>` чтобы подчеркнуть сходство между объявлением функций и объявлением других типов значений. Однако все именованные функции также можно записать с помощью краткого синтаксиса. Некоторые примеры написаны обоими способами.

## <a name="store-the-value-in-a-data-structure"></a>Сохранение значения в структуре данных

Значение первого класса может храниться в структуре данных. В следующем коде показаны примеры хранения значений в списках и кортежах.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet23.fs)]

Чтобы убедиться, что имя функции, сохраненное в кортеже, фактически выполняет вычисление функции, в следующем примере используются `fst` `snd` операторы и для извлечения первого и второго элементов из кортежа `funAndArgTuple` . Первый элемент в кортеже имеет значение `squareIt` , а второй элемент — `num` . Идентификатор `num` привязывается в предыдущем примере к целому 10, допустимому аргументу для `squareIt` функции. Второе выражение применяет первый элемент кортежа ко второму элементу в кортеже: `squareIt num` .

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet24.fs)]

Точно так же, как идентификатор `num` и целое число 10, можно использовать взаимозаменяемость, поэтому может быть идентификатором `squareIt` и лямбда-выражением `fun n -> n * n` .

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet25.fs)]

## <a name="pass-the-value-as-an-argument"></a>Передать значение в качестве аргумента

Если значение имеет состояние первого класса в языке, можно передать его в качестве аргумента функции. Например, в качестве аргументов часто передаются целые числа и строки. В следующем коде показаны целые числа и строки, передаваемые в качестве аргументов в F #.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet26.fs)]

Если функции имеют состояние первого класса, необходимо иметь возможность передавать их как аргументы аналогичным образом. Помните, что это первая характеристика функций высшего порядка.

В следующем примере функция `applyIt` имеет два параметра: `op` и `arg` . Если вы отправляете в функцию, имеющую один параметр для `op` , и соответствующий аргумент функции `arg` , функция возвращает результат применения функции `op` к `arg` . В следующем примере аргументы функции и целочисленный аргумент отправляются одинаковым образом с использованием их имен.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet27.fs)]

Возможность отправки функции в качестве аргумента в другую функцию зависит от общих абстракций в языках функционального программирования, таких как операции Map или Filter. Операция Map, например, — это функция более высокого порядка, которая захватывает вычисления, совместно используемые функциями, которые пошагово проходят по списку, выполняют какие-либо действия с каждым элементом, а затем возвращают список результатов. Может потребоваться увеличить каждый элемент в списке целых чисел или квадратный каждый элемент или изменить каждый элемент в списке строк на верхний. Подверженная ошибкам часть вычислений является рекурсивным процессом, который проходит по списку и создает список возвращаемых результатов. Эта часть захватывается функцией сопоставления. Все, что необходимо написать для конкретного приложения, — это функция, которую необходимо применить к каждому элементу списка по отдельности (Добавление, возведение в изменяемый регистр). Эта функция отправляется в качестве аргумента функции сопоставления, так же как и `squareIt` `applyIt` в предыдущем примере.

F # предоставляет методы Map для большинства типов коллекций, включая [списки](../language-reference/lists.md), [массивы](../language-reference/arrays.md)и [последовательности](../language-reference/sequences.md). В следующих примерах используются списки. Синтаксис: `List.map <the function> <the list>`.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet28.fs)]

Дополнительные сведения см. в разделе [списки](../language-reference/lists.md).

## <a name="return-the-value-from-a-function-call"></a>Возврат значения из вызова функции

Наконец, если функция имеет состояние первого класса в языке, необходимо иметь возможность возвращать его как значение вызова функции, как и другие типы, такие как целые числа и строки.

Следующие вызовы функции возвращают целые числа и отображают их.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet29.fs)]

Следующий вызов функции возвращает строку.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet30.fs)]

Следующий вызов функции, объявленный встроенным, возвращает логическое значение. Отображаемое значение — `True` .

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet31.fs)]

Возможность возвращать функцию в качестве значения вызова функции — это вторая характеристика функций более высокого порядка. В следующем примере `checkFor` определяется как функция, принимающая один аргумент, `item` и возвращающая в качестве значения новую функцию. Возвращаемая функция принимает список в качестве аргумента, `lst` и выполняет поиск `item` в `lst` . Если имеется `item` , функция возвращает `true` . Если `item` параметр не указан, функция возвращает значение `false` . Как и в предыдущем разделе, следующий код использует предоставленную функцию списка [List. Exists](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-listmodule.html#exists)для поиска в списке.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet32.fs)]

Следующий код использует `checkFor` для создания новой функции, которая принимает один аргумент, список и выполняет поиск 7 в списке.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet33.fs)]

В следующем примере используется состояние первого класса функций в F # для объявления функции, `compose` которая возвращает композицию двух аргументов функции.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet34.fs)]

> [!NOTE]
> Более короткая версия см. в следующем разделе "каррированных функции".

Следующий код отправляет две функции в качестве аргументов в `compose` , оба из которых принимают один аргумент того же типа. Возвращаемое значение — это новая функция, которая представляет собой композицию двух аргументов функции.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet35.fs)]

> [!NOTE]
> F # предоставляет два оператора, `<<` и `>>` , которые образуют функции. Например, `let squareAndDouble2 = doubleIt << squareIt` эквивалентен `let squareAndDouble = compose doubleIt squareIt` в предыдущем примере.

Следующий пример возврата функции в качестве значения вызова функции создает простую игру подбора. Чтобы создать игру, вызовите метод `makeGame` с тем значением, в котором вы хотите угадать `target` . Возвращаемое значение функции `makeGame` — это функция, которая принимает один аргумент (Guess) и сообщает, верно ли предположение.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet36.fs)]

Следующий код вызывает метод `makeGame` , отправляя значение `7` для `target` . Идентификатор `playGame` привязан к возвращенному лямбда-выражению. Таким образом, `playGame` представляет собой функцию, принимающую в качестве одного аргумента значение для `guess` .

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet37.fs)]

## <a name="curried-functions"></a>Каррированных функции

Многие примеры в предыдущем разделе можно написать более кратко, используя преимущества неявного *карринг* в объявлениях функций F #. Карринг — это процесс, преобразуя функцию, имеющую несколько параметров, в ряд встроенных функций, каждый из которых имеет один параметр. В F # функции, имеющие более одного параметра, по сути являются каррированных. Например, `compose` из предыдущего раздела можно написать, как показано в следующем кратком стиле с тремя параметрами.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet38.fs)]

Однако результатом является функция одного параметра, возвращающая функцию одного параметра, которая, в свою очередь, возвращает другую функцию одного параметра, как показано в `compose4curried` .

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet39.fs)]

Доступ к этой функции можно получить несколькими способами. Каждый из следующих примеров возвращает и отображает 18. `compose4` `compose4curried` В любом из примеров можно заменить на.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet40.fs)]

Чтобы убедиться, что функция все еще работает, как и раньше, попробуйте повторить исходные тестовые случаи.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet41.fs)]

> [!NOTE]
> Можно ограничить карринг, заключив параметры в кортежи. Дополнительные сведения см. в разделе "Шаблоны параметров" раздела [Параметры и аргументы](../language-reference/parameters-and-arguments.md).

В следующем примере используется неявное карринг для записи более короткой версии `makeGame` . Сведения о том, как `makeGame` конструкции и возвращают `game` функцию, менее явны в этом формате, но можно проверить с помощью исходных тестовых случаев, в которых результат совпадает.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet42.fs)]

Дополнительные сведения о карринг см. в разделе "частичное применение аргументов" в [функциях](../language-reference/functions/index.md).

## <a name="identifier-and-function-definition-are-interchangeable"></a>Идентификатор и определение функции взаимозаменяемы

Имя переменной `num` в предыдущих примерах вычисляется как целое число 10, и это не удивительно, что `num` допустимо, 10 также является допустимым. То же самое касается идентификаторов функций и их значений: где можно использовать имя функции, можно использовать лямбда-выражение, к которому она привязана.

В следующем примере определяется `Boolean` функция с именем `isNegative` , а затем используется имя функции и определение взаимозаменяемой функции. В следующих трех примерах возвращаются и отображаются `False` .

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet43.fs)]

Чтобы сделать это на один шаг дальше, замените значение, `applyIt` привязанное к для `applyIt` .

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet44.fs)]

## <a name="functions-are-first-class-values-in-f"></a>Функции являются значениями первого класса в F\#

В примерах, приведенных в предыдущих разделах, показано, что функции в F # удовлетворяют критериям для значений первого класса в F #:

- Идентификатор можно привязать к определению функции.
[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet21.fs)]

- Функцию можно сохранить в структуре данных.
[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet45.fs)]

- Функцию можно передать в качестве аргумента.
[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet46.fs)]

- Функцию можно вернуть в качестве значения вызова функции.
[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet32.fs)]

Дополнительные сведения о F # см. в [справочнике по языку f #](../language-reference/index.md).

## <a name="example"></a>Пример

### <a name="description"></a>Описание

Следующий код содержит все примеры, приведенные в этом разделе.

### <a name="code"></a>Код

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet47.fs)]

## <a name="see-also"></a>См. также

- [Списки](../language-reference/lists.md)
- [Кортежи](../language-reference/tuples.md)
- [Функции](../language-reference/functions/index.md)
- [`let` Привязки](../language-reference/functions/let-bindings.md)
- [Лямбда-выражения: `fun` ключевое слово](../language-reference/functions/lambda-expressions-the-fun-keyword.md)
