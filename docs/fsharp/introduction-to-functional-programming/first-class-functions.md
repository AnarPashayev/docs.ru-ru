---
title: Функций первого класса
description: Дополнительные сведения о функций первого класса и как они важны для функционального программирования в F#.
ms.date: 10/29/2018
ms.openlocfilehash: 505ad686614b53d779cb617fc04ac74c2a88b31b
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61772766"
---
# <a name="first-class-functions"></a>Функций первого класса

Определяющей характеристикой языков функционального программирования является повышение функций первого класса состояния. Можно сделать с помощью функции, все, что можно сделать со значениями других встроенных типов и иметь возможность сделать это с сопоставимым усилий.

Ниже приведены типичные вопросы для первоклассному статусу:

- Можно ли привязать к идентификаторам функций? То есть можно можно давать их имена?

- Для хранения функций в структурах данных, например, в списке.

- Можно ли передать функции в качестве аргумента в вызове функции?

- Может возвращать функция из вызова функции?

Последние две меры определяют, что известно как *операции более высокого порядка* или *функции высшего порядка*. Функции высшего порядка принимают функции в качестве аргументов и возвращают функции в качестве значений из вызовов функций. Эти операции поддерживают такие основы функционального программирования, как функции сопоставления и объединение функций.

## <a name="give-the-value-a-name"></a>Присвойте значение имени

Если функция значения первого класса, необходимо присвоить ей имя так же, как целые числа, строки и другие встроенные типы данных. Это упоминается в литературе о функциональном программировании привязкой идентификатора значение. F#использует [ `let` привязки](../language-reference/functions/let-bindings.md) для привязки имен к значениям: `let <identifier> = <value>`. В следующем коде показано два примера.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet20.fs)]

Функция так же, как легко можно задать имя. В следующем примере определяется функция с именем `squareIt` , привязав идентификатор `squareIt` для [лямбда-выражение](../language-reference/functions/lambda-expressions-the-fun-keyword.md) `fun n -> n * n`. Функция `squareIt` имеет один параметр `n`, и она возвращает квадрат этого параметра.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet21.fs)]

F#предоставляет следующие более краткий синтаксис для достижения того же результата с облегчен.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet22.fs)]

Примерах главным образом используется первый стиль, `let <function-name> = <lambda-expression>`, чтобы подчеркнуть сходства объявления функций и объявления других типов значений. Тем не менее все именованные функции также могут записываться с сокращенный синтаксис. Некоторые примеры записываются в обоих направлениях.

## <a name="store-the-value-in-a-data-structure"></a>Значение в структуру данных Store

Значения первого класса могут храниться в структуре данных. В следующем коде показано примеры, которые сохраняют значения в списках и в кортежи.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet23.fs)]

Чтобы убедиться, что имя функции, хранимые в кортеже фактически выполняет вычисление функции, в следующем примере используется `fst` и `snd` операторов для извлечения элементов первого и второго из кортежа `funAndArgTuple`. Первый элемент в кортеже — `squareIt` и второй элемент — `num`. Идентификатор `num` привязана в предыдущем примере целое число 10, которое является допустимым аргументом для `squareIt` функции. Второе выражение применяется первый элемент в кортеже, второй элемент в кортеже: `squareIt num`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet24.fs)]

Точно так же просто, как идентификатор `num` и может принимать целое число 10 взаимозаменяемы, поэтому можно идентификатор `squareIt` и лямбда-выражение `fun n -> n * n`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet25.fs)]

## <a name="pass-the-value-as-an-argument"></a>Передайте значение в качестве аргумента

Если значение имеет состояние первого класса на языке, можно передать в качестве аргумента в функцию. Например довольно часто для передачи аргументов Integer и String. В следующем коде показано целые числа и строки, передаваемые в качестве аргументов в F#.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet26.fs)]

Если функции первого класса состояния, необходимо передать в качестве аргументов таким же образом. Помните, что это первая характеристика функций более высокого порядка.

В следующем примере функция `applyIt` имеет два параметра `op` и `arg`. Если отправить функцию, которая имеет один параметр для `op` и соответствующий аргумент для функции `arg`, функция возвращает результат применения `op` для `arg`. В следующем примере аргумент функции и целочисленный аргумент отправляются таким же образом, с помощью их имен.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet27.fs)]

Возможность передавать функции в качестве аргумента другой функции лежит в основе типичных абстракций в функциональных языках программирования, таких как операции сопоставления или фильтрации. Операция сопоставления, например, является функция высшего порядка, который фиксирует общее вычисление функций, которые проходят по списку, выполнять действия с каждым элементом и возвращается список результатов. Вы можете увеличить значение каждого элемента в список целых чисел, или квадрат каждого элемента или для изменения каждого элемента в список строк в верхний регистр. Ошибкам часть вычисления является рекурсивным процессом, который проходит по списку и строит список результатов для возвращения. Эта часть захватывается в функции сопоставления. Вам нужно написать для конкретного приложения — функция, которая будет применяться к каждому элементу списка по отдельности (Добавление, возведение в квадрат, изменение регистра). Эта функция отправляется в качестве аргумента в функцию сопоставления, так же, как `squareIt` отправляется `applyIt` в предыдущем примере.

F#Предоставляет методы сопоставления для большинства типов коллекций, включая [перечислены](../language-reference/lists.md), [массивы](../language-reference/arrays.md), и [последовательностей](../language-reference/sequences.md). В следующих примерах используются списки. Синтаксис `List.map <the function> <the list>`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet28.fs)]

Дополнительные сведения см. в разделе [перечислены](../language-reference/lists.md).

## <a name="return-the-value-from-a-function-call"></a>Возврат значения из вызова функции

И, наконец Если функция имеет состояние первого класса на языке, необходимо вернуть в качестве значения вызова функции, так же, как возвращать другие типы, такие как Integer и String.

Следующие вызовы функции возвращают целые числа и отобразить их.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet29.fs)]

При вызове следующей функции возвращает строку.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet30.fs)]

При вызове следующей функции, объявленные встроенными, возвращает значение типа Boolean. Отображаемое значение `True`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet31.fs)]

Для возврата функции в качестве значения вызова функции является второй характеристикой функций более высокого порядка. В следующем примере `checkFor` определяется как функцию, которая принимает один аргумент `item`и возвращает новую функцию в качестве его значения. Возвращаемая функция принимает список в качестве аргумента, `lst`и поиск `item` в `lst`. Если `item` присутствует, функция возвращает `true`. Если `item` не существует, функция возвращает `false`. Как и в предыдущем разделе, в следующем коде используется функция списка, [List.exists](https://msdn.microsoft.com/library/15a3ebd5-98f0-44c0-8220-7dedec3e68a8), для поиска в списке.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet32.fs)]

В следующем коде используется `checkFor` создать новую функцию, которая принимает один аргумент, список и выполняет поиск 7 в списке.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet33.fs)]

В следующем примере используется состояние первого класса функций в F# для объявления функции, `compose`, которая возвращает композицию двух аргументов функции.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet34.fs)]

> [!NOTE]
> Для более краткую версию см. в разделе «Curried функции».

Следующий код отправляет две функции в качестве аргументов `compose`, оба из которых принимает один аргумент того же типа. Возвращаемое значение имеет новую функцию, которая представляет собой сочетание двух аргументов функции.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet35.fs)]

> [!NOTE]
> F#предоставляет два оператора `<<` и `>>`, который объединяет функции. Например `let squareAndDouble2 = doubleIt << squareIt` эквивалентен `let squareAndDouble = compose doubleIt squareIt` в предыдущем примере.

В следующем примере возврата функции в качестве значения вызова функции создается простая игра по угадыванию. Чтобы создать игру, вызовите `makeGame` со значением возникает необходимость угадать, отправленным для `target`. Возвращаемое значение из функции `makeGame` является функцией, которая принимает один аргумент (предположение) и сообщает, является ли пробное значение правильно.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet36.fs)]

Следующий код вызывает `makeGame`, отправить значение `7` для `target`. Идентификатор `playGame` привязан к возвращаемому лямбда-выражению. Таким образом `playGame` — это функция, которая принимает в качестве единственного аргумента значение для `guess`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet37.fs)]

## <a name="curried-functions"></a>Каррированные функции

Во многих примерах в предыдущем разделе можно написать более кратко, используя преимущества неявного *каррирование* в F# объявления функции. Каррирование — это процесс преобразования функции, которая имеет более одного параметра на ряд встроенных функций, каждая из которых имеет один параметр. В F#, являются по своей природе каррированные функции, которые имеют более одного параметра. Например `compose` из предыдущего раздела может быть написано как показано в следующем кратком стиле, с тремя параметрами.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet38.fs)]

Тем не менее, результат зависит от один параметр, который возвращает функцию один параметр, который в свою очередь, возвращает другую функцию одного параметра, как показано в `compose4curried`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet39.fs)]

Можно получить доступ к этой функции несколькими способами. Каждый из следующих примеров возвращает и отображает 18. Вы можете заменить `compose4` с `compose4curried` во всех примерах.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet40.fs)]

Чтобы убедиться, что функция будет по-прежнему работать как и раньше, повторите попытку исходных тестовых случаев.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet41.fs)]

> [!NOTE]
> Можно ограничить каррирование, поместив параметры в кортежи. Дополнительные сведения см. в разделе «Шаблоны параметров» в [параметры и аргументы](../language-reference/parameters-and-arguments.md).

В следующем примере неявное каррирование записываемый краткая версия `makeGame`. Сведения о том, как `makeGame` создает и возвращает `game` функции являются менее явными в этот формат, но можно проверить с помощью исходных тестовых случаев, что результат будет такой же.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet42.fs)]

Дополнительные сведения о каррирование, см. в разделе «Частичное приложения из аргументы» в [функции](../language-reference/functions/index.md).

## <a name="identifier-and-function-definition-are-interchangeable"></a>Идентификатор и определение функции являются взаимозаменяемыми

Имя переменной `num` в предыдущем примеры имеет значение целого числа 10, и не удивительно, что где `num` является допустимым, 10 также является допустимым. То же самое относится и к идентификаторам функций и их значения: везде, где можно использовать имя функции, можно использовать лямбда-выражение, к которому он привязан.

В следующем примере определяется `Boolean` функция, вызываемая `isNegative`, а затем использует имя функции и определение функции являются взаимозаменяемыми. Следующие три примера возвращают и отображают `False`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet43.fs)]

Чтобы продвинуться на один шаг дальнейшей, заменить значение, `applyIt` привязан к для `applyIt`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet44.fs)]

## <a name="functions-are-first-class-values-in-f"></a>Функции являются значениями первого класса на языке f #\#

В примерах в предыдущих разделах показано, что функции в F# требованиям для значений первого класса F#:

- Идентификатор можно привязать к определению функции.
[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet21.fs)]

- Функцию можно хранить в структуре данных.
[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet45.fs)]

- Функцию можно передать в качестве аргумента.
[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet46.fs)]

- Функция может возвращать как значение вызова функции.
[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet32.fs)]

Дополнительные сведения о F#, см. в разделе [ F# Справочник по языку](../language-reference/index.md).

## <a name="example"></a>Пример

### <a name="description"></a>Описание

Следующий код содержит все примеры в этом разделе.

### <a name="code"></a>Код

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet47.fs)]

## <a name="see-also"></a>См. также

- [Списки](../language-reference/lists.md)
- [Кортежи](../language-reference/tuples.md)
- [Функции](../language-reference/functions/index.md)
- [`let` Привязки](../language-reference/functions/let-bindings.md)
- [Лямбда-выражения: Ключевое слово `fun`](../language-reference/functions/lambda-expressions-the-fun-keyword.md)
