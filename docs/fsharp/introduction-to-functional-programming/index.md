---
title: Введение в функциональное программирование на F#
description: Изучение основ функционального программирования в F#.
ms.date: 10/29/2018
ms.openlocfilehash: 84022e58c0f17b9e9875402c653c31e494e940da
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61772792"
---
# <a name="introduction-to-functional-programming-in-f"></a>Введение в функциональное программирование на языке f #\#

Функциональное программирование является стилем, который делается упор на использование функций и постоянные данные. Типизированный функциональное программирование является функционального программирования в сочетании с статические типы, такие как с F#. Как правило в функциональном программировании выделены следующие понятия:

* Функции как основными конструкциями, которые можно использовать
* Выражения вместо инструкций
* Постоянные значения, переменные
* Декларативную модель программирования через императивного программирования

В этой серии, на них рассматриваются концепции и шаблоны в функционального программирования, используя F#. Кроме того, вы узнаете о некоторых F# слишком.

## <a name="terminology"></a>Терминология

Функциональное программирование, как и других парадигм программирования, в состав словаря, который со временем необходимо будет узнать. Ниже приведены некоторые распространенные термины, вы увидите все время.

* **Функция** -функция представляет собой конструкцию, будет преобразовано в выходное при заданном входном. Более формально, его _сопоставляет_ набор из одного элемента к другому набору. Этот формализм она поднимается в конкретных во многих отношениях, особенно при использовании функции, которые работают с коллекциями данных. Это наиболее основных (и важный) концепции функционального программирования. 
* **Выражение** -выражение — это конструкция, в коде, который создает значение. В F#, это значение должно быть привязаны или явным образом игнорировать. Выражения могут быть просто заменены вызов функции.
* **Чистота** -чистоты является свойством функции, таким образом, что его возвращаемое значение всегда является одинаковым для те же аргументы, и что его вычисление не имеет побочных эффектов. Чистая функция полностью зависит от своих аргументов.
* **Ссылочной прозрачности** -ссылочной прозрачности является свойством выражений таким образом, что они могут быть заменены свои выходные данные без влияния на поведение программы.
* **Неизменность** -постоянство означает, что значение не может быть изменен на месте. Это отличает их от переменных, которые можно изменить на месте.

## <a name="examples"></a>Примеры

В следующих примерах демонстрируется следующих базовых понятиях.

### <a name="functions"></a>Функции

Наиболее распространенные и основные конструкции функционального программирования является функция. Ниже приведен простой функции, которая добавляет 1 к целое число.

```fsharp
let addOne x = x + 1
```

Сигнатура типа выглядит следующим образом:

```fsharp
val addOne: x:int -> int
```

Подпись может быть прочитан как, «`addOne` принимает `int` с именем `x` и создаст `int`«. Более формально `addOne` — _сопоставление_ значение из набора целых чисел в набор целых чисел. `->` Токен указывает на это сопоставление. В F#, обычно можно посмотреть на сигнатуру функции, чтобы понять, что она делает.

Таким образом, почему важен подпись? В типизированных функционального программирования, реализации функции меньше часто важным, чем фактический тип подписи! Тот факт, `addOne` добавляет значение в целое число 1 интересен во время выполнения, но при создании программы, тот факт, что он принимает и возвращает `int` является что информирует о том, как его можно использовать эту функцию. Кроме того, как только эта функция правильно (по отношению к его сигнатура типа), диагностики проблем можно сделать только в теле `addOne` функции. Это движущая сила типизированный функционального программирования.

### <a name="expressions"></a>Выражения

Выражения — это конструкции, которые возвращают значения. В отличие от инструкции, которые выполняют действия, выражения можно рассматривать выполняет действие, которое возвращает значение. Выражения используются почти всегда пользу инструкций в функциональном программировании.

Рассмотрим функцию предыдущих `addOne`. Тело `addOne` — это выражение:

```fsharp
// 'x + 1' is an expression!
let addOne x = x + 1
```

Она является результатом этого выражения, который определяет тип результата `addOne` функции. Например, выражение, которое представляет эта функция может измениться на быть другого типа, например `string`:

```fsharp
let addOne x = x.ToString() + "1"
```

Подпись функции теперь является:

```fsharp
val addOne: x:'a -> string
```

С момента любого типа в F# может иметь `ToString()` для нее тип `x` стала универсального (вызывается [Автоматическое обобщение](../language-reference/generics/automatic-generalization.md)), и результирующим типом является `string`.

Выражения не только тела функции. Может иметь выражений, возвращающих значение, которое можно использовать в другом месте. Он общий `if`:

```fsharp
// Checks if 'x' is odd by using the mod operator
let isOdd x = x % 2 <> 0

let addOneIfOdd input =
    let result =
        if isOdd input then
            input + 1
        else
            input

    result
```

`if` Выражение создает значение с именем `result`. Обратите внимание, что можно опустить `result` полностью, что делает `if` выражение текст из `addOneIfOdd` функции. Следует помнить о выражениях ключевой момент заключается в том, что они создают значение.

Есть особый тип `unit`, используемый при нет ничего для возврата. Например рассмотрим Эта простая функция:

```fsharp
let printString (str: string) =
    printfn "String is: %s" str
```

Подпись выглядит следующим образом:

```fsharp
val printString: str:string -> unit
```

`unit` Тип указывает, что фактическое значение не возвращается. Это полезно при наличии подпрограмму, которая должна «рабочая», несмотря на наличие значения, которое можно вернуть в результате этой работы.

Это существенно отличаются от императивного программирования, где эквивалент `if` конструкция является оператором, и создание значения часто выполняется с помощью изменения переменных. Например, в C#, код может быть написан следующим образом:

```csharp
bool IsOdd(int x) => x % 2 != 0;

int AddOneIfOdd(int input)
{
    var result = input;

    if (IsOdd(input))
    {
        result = input + 1;
    }

    return result;
}
```

Следует отметить, что C# и других языков в стиле C поддерживают [троичное выражение](../../csharp/language-reference/operators/conditional-operator.md), что позволяет условного программирование на основе выражения.

В функциональном программировании очень редко изменяемая значений с помощью инструкций. Несмотря на то, что некоторые функциональные языки поддерживают операторы и изменений, обычно не использовать эти концепции в функциональном программировании.

### <a name="pure-functions"></a>Чистые функции

Как упоминалось ранее, чистые функции являются функции, которые:

* Всегда возвращают значение то же значение для того же входа.
* Не имеют побочных эффектов.

Это можно представить математические функции в этом контексте. В математике функции зависят только от их аргументов и не оказывает никакого влияния. Математические функции `f(x) = x + 1`, значение `f(x)` зависит только от значение `x`. Чистые функции в функциональном программировании являются одинаково.

При написании чистой функции, функция должна зависеть только от своих аргументов и не выполнять никаких действий, которые приводят к побочный эффект.

Вот пример функция, изменяющая, так как он зависит от состояния глобального, изменяемый:

```fsharp
let mutable value = 1

let addOneToValue x = x + value
```

`addOneToValue` Функция четко "нечистыми", так как `value` могут быть изменены в любое время, чтобы иметь разное значение 1. Этот шаблон в зависимости от глобальное значение — избегать в функциональном программировании.

Вот еще один пример функции, не являющийся чистым, так как он выполняет побочный эффект:

```fsharp
let addOneToValue x = 
    printfn "x is %d" x
    x + 1
```

Несмотря на то, что эта функция не зависит от глобальное значение, он записывает значение `x` в выходные данные программы. Несмотря на то, что нет ничего плохого таким образом, это означает, что функция не является чисто. Если другой части программы зависит от программы, например выходной буфер, внешними факторами, затем вызов этой функции может повлиять на этот другой части программы.

Удаление `printfn` инструкция делает функцию чисто:

```fsharp
let addOneToValue x = x + 1
```

Несмотря на то, что данная функция не является по своей природе _лучше_ прежней версией с `printfn` инструкции, это гарантирует, что все этой функции будет возвращать значение. Вызов этой функции любое количество раз дает тот же результат: он просто создает значение. Предсказуемость, выданный чистоты является то, что многие функциональные программисты Стремитесь к.

### <a name="immutability"></a>Неизменность

Наконец одним из фундаментальных понятий типизированный функционального программирования является неизменяемости. В F#, все значения являются неизменяемыми по умолчанию. Это означает, что они не могут быть изменяемые локально, если только вы явным образом пометить их как изменяемые.

На практике работы с неизменяемыми значениями означает, что изменить ваш подход к программированию из «Необходимо изменить что-то», чтобы «мне нужно создать новое значение».

Например добавление 1 значение означает, что результатом является новый значение, не изменения существующего:

```fsharp
let value = 1
let secondValue = value + 1
```

В F#, показано в следующем коде **не** изменяет `value` функции; вместо этого он выполняет проверку равенства:

```fsharp
let value = 1
value = value + 1 // Produces a 'bool' value!
```

Некоторые языки функционального программирования вообще не поддерживают изменения. В F#, он поддерживается, но не значения по умолчанию.

Эта концепция расширяет еще дальше структур данных. В функциональном программировании неизменяемых структур данных такие как наборы (и многих других) имеют другую реализацию, чем изначально может ожидать. По сути, что-то, как добавить элемент в набор не приводит к изменению набора, он создает _новый_ набор с выгод. На самом деле это часто выполняется с другой структурой данных, позволяющий для эффективного отслеживания значение таким образом, чтобы в результате можно предоставить подходящее представление данных.

Этот стиль работы со значениями и структур данных крайне важен, как приходится обрабатывать любая операция, изменяющая что-то, как если бы он создает новую версию от этого. Это позволяет выполнять такие проверки на равенство и сравнимость согласованности в программах.

## <a name="next-steps"></a>Следующие шаги

Следующий раздел тщательно будут рассмотрены функции, исследует различные способы, их можно использовать в функциональном программировании.

[Функций первого класса](first-class-functions.md) рассматриваются функции глубоко, показывающий, как их можно использовать в различных контекстах.

## <a name="further-reading"></a>Дополнительные сведения

[Мышления функционально](https://fsharpforfunandprofit.com/posts/thinking-functionally-intro/) series – это еще один интересный ресурс, чтобы узнать о функциональное программирование на F#. Он охватывает основы функционального программирования в смысле практичные и простые для чтения, с помощью F# функции, чтобы продемонстрировать основные понятия.
