---
title: Введение в функциональное программирование на F#
description: Изучите основы функционального программирования в F#.
ms.date: 10/29/2018
ms.openlocfilehash: e1a0edc61dbe13012c48e166d490e22ebc70d6a0
ms.sourcegitcommit: 14ad34f7c4564ee0f009acb8bfc0ea7af3bc9541
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/01/2019
ms.locfileid: "73424702"
---
# <a name="introduction-to-functional-programming-in-f"></a>Введение в функциональное программирование в F\#

Функциональное программирование — это стиль программирования, который подчеркивает использование функций и неизменяемых данных. Типизированное функциональное программирование — это то, что функциональное программирование сочетается со F#статическими типами, например с. Как правило, в функциональном программировании используются следующие понятия:

* Функции в качестве основных используемых конструкций
* Выражения вместо операторов
* Неизменяемые значения для переменных
* Декларативное программирование по императивному программированию

В этой серии вы ознакомитесь с основными понятиями и шаблонами в F#функциональном программировании с помощью. Кроме того, вы также узнаете F# об этом.

## <a name="terminology"></a>Терминология

Функциональное программирование, как и другие парадигмы программирования, сопровождается словарем, который со временем потребуется изучить. Ниже приведены некоторые распространенные термины, которые можно увидеть все время:

* **Function** — функция — это конструкция, которая выдает выходные данные при наличии входных данных. Более формально он _сопоставляет_ элемент из одного набора с другим набором. Этот формальный метод ликвидируется в конкретную часть, особенно при использовании функций, которые работают с коллекциями данных. Это наиболее простое (и важное) понятие в функциональном программировании.
* **Expression** — выражение — это конструкция в коде, которая создает значение. В F#это значение должно быть привязано или явно игнорироваться. Выражение может быть тривиально заменено вызовом функции.
* **Чистота** — это свойство функции таким, что возвращаемое значение всегда одинаково для одних и тех же аргументов, и его оценка не имеет побочных эффектов. Чистая функция полностью зависит от своих аргументов.
* **Ссылочная** прозрачность — это свойство выражений таким образом, что их можно заменить на выходные данные, не влияя на поведение программы.
* **Неизменность** — это значение не может быть изменено на месте. Это отличается от переменных, которые могут измениться на месте.

## <a name="examples"></a>Примеры

В следующих примерах демонстрируются эти основные понятия.

### <a name="functions"></a>Функции

Наиболее распространенной и фундаментальной конструкцией функционального программирования является функция. Вот простая функция, которая добавляет 1 к целому числу:

```fsharp
let addOne x = x + 1
```

Сигнатура его типа выглядит следующим образом:

```fsharp
val addOne: x:int -> int
```

Сигнатура может считаться "`addOne` принимает `int` с именем `x` и создает `int`". Более формально, `addOne` _сопоставляет_ значение из набора целых чисел с набором целых чисел. Маркер `->` обозначает это сопоставление. В F#можно просмотреть сигнатуру функции, чтобы понять, что она делает.

Итак, почему сигнатура важна? В типизированном функциональном программировании реализация функции часто менее важна, чем фактическая сигнатура типа! Тот факт, что `addOne` добавляет значение 1 к целому числу, интересно во время выполнения, но при создании программы тот факт, что он принимает и возвращает `int`, — это то, что именно будет использоваться для этой функции. Кроме того, после правильного использования этой функции (по отношению к сигнатуре типа) Диагностика проблем может быть выполнена только в теле функции `addOne`. Это стимула за типизированное функциональное программирование.

### <a name="expressions"></a>Выражения

Выражения — это конструкции, результатом вычисления которых является значение. В отличие от операторов, выполняющих действие, выражения можно считать выполнением действия, которое возвращает значение. Выражения почти всегда используются в пользу операторов в функциональном программировании.

Рассмотрим предыдущую функцию, `addOne`. Тело `addOne` является выражением:

```fsharp
// 'x + 1' is an expression!
let addOne x = x + 1
```

Это результат выражения, определяющего тип результата функции `addOne`. Например, выражение, составляющее эту функцию, может быть изменено на другой тип, например `string`:

```fsharp
let addOne x = x.ToString() + "1"
```

Теперь сигнатура функции:

```fsharp
val addOne: x:'a -> string
```

Поскольку для любого типа F# в может быть вызван `ToString()`, тип `x` был сделан универсальным (называемым [автоматической обобщением](../language-reference/generics/automatic-generalization.md)), а результирующий тип — `string`.

Выражения — это не только тела функций. Можно использовать выражения, которые возвращают значение, которое используется в других местах. Общий `if`:

```fsharp
// Checks if 'x' is odd by using the mod operator
let isOdd x = x % 2 <> 0

let addOneIfOdd input =
    let result =
        if isOdd input then
            input + 1
        else
            input

    result
```

`if` выражение создает значение с именем `result`. Обратите внимание, что можно полностью опустить `result`, сделав `if` выражение телом функции `addOneIfOdd`. Ключевым моментом, который следует помнить о выражениях, является то, что они создают значение.

Существует специальный тип, `unit`, который используется при отсутствии возвращаемых результатов. Например, рассмотрим эту простую функцию:

```fsharp
let printString (str: string) =
    printfn "String is: %s" str
```

Подпись выглядит следующим образом:

```fsharp
val printString: str:string -> unit
```

Тип `unit` указывает, что фактическое значение не возвращается. Это полезно, если у вас есть подпрограммы, которые должны «работать», несмотря на отсутствие значения, возвращаемого в результате этой работы.

Это очень четкое отличие от императивного программирования, где эквивалентная `if` конструкция является оператором, а создание значений часто осуществляется с помощью изменения переменных. Например, в C#код может быть написан следующим образом:

```csharp
bool IsOdd(int x) => x % 2 != 0;

int AddOneIfOdd(int input)
{
    var result = input;

    if (IsOdd(input))
    {
        result = input + 1;
    }

    return result;
}
```

Стоит отметить, что C# и другие языки в стиле C поддерживают [выражение ternary](../../csharp/language-reference/operators/conditional-operator.md), которое обеспечивает условное программирование на основе выражений.

В функциональном программировании редко изменяются значения с помощью операторов. Хотя некоторые функциональные языки поддерживают инструкции и изменения, использование этих концепций в функциональном программировании не является распространенным.

### <a name="pure-functions"></a>Чистые функции

Как упоминалось ранее, чистые функции — это функции, которые:

* Всегда вычисляют одно и то же значение для одних и тех же входных данных.
* Не имеют побочных эффектов.

В этом контексте удобнее рассматривать математические функции. В математике функции зависят только от своих аргументов и не имеют побочных эффектов. В математической функции `f(x) = x + 1`значение `f(x)` зависит только от значения `x`. Чистые функции функционального программирования одинаковы.

При написании чистой функции функция должна зависеть только от своих аргументов и не выполнять никаких действий, которые приводят к побочному результату.

Ниже приведен пример функции, не являющейся чистой, так как она зависит от глобального изменяемого состояния:

```fsharp
let mutable value = 1

let addOneToValue x = x + value
```

Функция `addOneToValue` очевидной, поскольку `value` может быть изменена в любое время, чтобы иметь другое значение, отличное от 1. Этот шаблон в зависимости от глобального значения следует избегать в функциональном программировании.

Ниже приведен еще один пример функции, не являющейся чистой, поскольку она выполняет побочный результат:

```fsharp
let addOneToValue x =
    printfn "x is %d" x
    x + 1
```

Хотя эта функция не зависит от глобального значения, она записывает значение `x` в выходные данные программы. Хотя в этом нет ничего плохого, это означает, что функция не является чистой. Если другая часть программы зависит от объекта, внешнего для программы, например выходного буфера, то вызов этой функции может повлиять на другую часть программы.

Удаление оператора `printfn` делает функцию чистой:

```fsharp
let addOneToValue x = x + 1
```

Несмотря на то что эта функция не является _более лучшей_ по сравнению с предыдущей версией с помощью оператора `printfn`, она гарантирует, что вся эта функция возвращает значение. При вызове этой функции любое количество раз дает тот же результат: он просто создает значение. Предсказуемость, предоставляемая чистотой, — это что-то множество функциональных программистов, которые стремится.

### <a name="immutability"></a>Неизменяемости

Наконец, одна из самых фундаментальных концепций типизированного функционального программирования — неизменяемость. В F#все значения по умолчанию являются неизменяемыми. Это означает, что их нельзя изменить на месте, если явно не помечать их как изменяемые.

На практике работа с неизменяемыми значениями означает, что вы меняете подход на программирование с «мне нужно изменить что-нибудь» на «мне нужно получить новое значение».

Например, добавление 1 к значению означает создание нового значения, а не изменение существующего.

```fsharp
let value = 1
let secondValue = value + 1
```

В F#следующий код **не** изменяет функцию `value`. Вместо этого он выполняет проверку на равенство:

```fsharp
let value = 1
value = value + 1 // Produces a 'bool' value!
```

Некоторые языки функционального программирования не поддерживают изменения вообще. В F#поддерживается, но не является поведением по умолчанию для значений.

Эта концепция расширяется еще до структур данных. В функциональном программировании неизменяемые структуры данных, такие как наборы (и многие другие), имеют разную реализацию, чем может быть изначально ожидать. По сути, что-то вроде добавления элемента в набор не изменяет набор, он создает _Новый_ набор с добавленным значением. На самом деле это часто достигается с помощью другой структуры данных, которая позволяет эффективно отслеживать значение, чтобы в результате можно было получить соответствующее представление данных.

Этот стиль работы со значениями и структурами данных является критически важным, так как он заставляет обрабатывать любые операции, которые изменяют что-то, как при создании новой версии. Это позволяет обеспечить единообразие в программах, таких как равенство и сравнение.

## <a name="next-steps"></a>Следующие шаги

В следующем разделе будут тщательно рассмотрены функции, а также различные способы их использования в функциональном программировании.

[Функции первого класса](first-class-functions.md) анализируют функции глубоко, показывая, как их можно использовать в различных контекстах.

## <a name="further-reading"></a>Дополнительные сведения

[Помышление функционального](https://fsharpforfunandprofit.com/posts/thinking-functionally-intro/) ряда — еще один отличный ресурс для изучения функционального F#программирования с помощью. В нем рассматриваются основы функционального программирования на практичном и удобном для чтения виде, с использованием F# функций для иллюстрации концепций.
