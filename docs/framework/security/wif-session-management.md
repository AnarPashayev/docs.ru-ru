---
title: Управление сеансами WIF
ms.date: 03/30/2017
ms.assetid: 98bce126-18a9-401b-b20d-67ee462a5f8a
author: BrucePerlerMS
ms.openlocfilehash: 141eda509530cab1120d519c3cbc94693ef1cc51
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/22/2019
ms.locfileid: "69946234"
---
# <a name="wif-session-management"></a><span data-ttu-id="60c98-102">Управление сеансами WIF</span><span class="sxs-lookup"><span data-stu-id="60c98-102">WIF Session Management</span></span>
<span data-ttu-id="60c98-103">При первой попытке клиента получить доступ к защищенному ресурсу, размещаемому проверяющей стороной, этот клиент прежде всего должен пройти проверку подлинности в службе маркеров безопасности (STS), которая является доверенной для проверяющей стороны.</span><span class="sxs-lookup"><span data-stu-id="60c98-103">When a client first tries to access a protected resource that is hosted by a relying party, the client must first authenticate itself to a security token service (STS) that is trusted by the relying party.</span></span> <span data-ttu-id="60c98-104">Затем служба STS выдает клиенту токен безопасности.</span><span class="sxs-lookup"><span data-stu-id="60c98-104">The STS then issues a security token to the client.</span></span> <span data-ttu-id="60c98-105">Клиент предъявляет этот токен проверяющей стороне, и та предоставляет клиенту доступ к защищенному ресурсу.</span><span class="sxs-lookup"><span data-stu-id="60c98-105">The client presents this token to the relying party, which then grants the client access to the protected resource.</span></span> <span data-ttu-id="60c98-106">Однако такая ситуация, когда клиент вынужден повторно проходить проверку подлинности в службе STS для каждого запроса, является нежелательной, особенно с учетом того, что клиент и проверяющая сторона могут работать на разных компьютерах или в разных доменах.</span><span class="sxs-lookup"><span data-stu-id="60c98-106">However, you don’t want the client to have to re-authenticate to the STS for each request, especially because it might not even be on the same computer or in the same domain as the relying party.</span></span> <span data-ttu-id="60c98-107">Вместо этого WIF обеспечивает установку сеанса клиентом и проверяющей стороной, в ходе которого клиент использует токен безопасности сеанса в целях проверки своей подлинности для проверяющей стороны для всех запросов, следующих после первого запроса.</span><span class="sxs-lookup"><span data-stu-id="60c98-107">Instead, Windows Identity Foundation (WIF) has the client and relying party establish a session in which the client uses a session security token to authenticate itself to the relying party for all requests after the first request.</span></span> <span data-ttu-id="60c98-108">Проверяющая сторона может использовать этот токен, хранящийся в файле cookie, для воссоздания <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType> клиента.</span><span class="sxs-lookup"><span data-stu-id="60c98-108">The relying party can use this session security token, which is stored inside a cookie, to reconstruct the client’s <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="60c98-109">Служба STS определяет, какой тип проверки подлинности должен пройти клиент.</span><span class="sxs-lookup"><span data-stu-id="60c98-109">The STS defines what authentication the client must provide.</span></span> <span data-ttu-id="60c98-110">Однако у клиента может быть несколько наборов учетных данных, с помощью которых он может пройти проверку подлинности в службе STS.</span><span class="sxs-lookup"><span data-stu-id="60c98-110">However, the client might have multiple credentials with which it can authenticate itself to the STS.</span></span> <span data-ttu-id="60c98-111">Например, клиент может иметь токен из учетной записи Windows Live, имя пользователя и пароль, сертификат и смарт-ключ.</span><span class="sxs-lookup"><span data-stu-id="60c98-111">For example, it might have a token from Windows Live, a user name and password, a certificate, and a smartkey.</span></span> <span data-ttu-id="60c98-112">В этом случае служба STS предоставляет клиенту несколько удостоверений, каждое из которых соответствует одному набору учетных данных, предъявленных клиентом.</span><span class="sxs-lookup"><span data-stu-id="60c98-112">In that case, the STS grants the client several identities, with each identity corresponding to one of the credentials that the client presents.</span></span> <span data-ttu-id="60c98-113">Проверяющая сторона может использовать одно или несколько из этих удостоверений для предоставления клиенту того или иного уровня доступа.</span><span class="sxs-lookup"><span data-stu-id="60c98-113">The relying party can use one or more of these identities when it decides what level of access to grant the client.</span></span>  
  
 <span data-ttu-id="60c98-114">Токен <xref:System.IdentityModel.Tokens.SessionSecurityToken?displayProperty=nameWithType> используется для воссоздания объекта <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType> клиента, содержащего все удостоверения клиента в коллекции <xref:System.Security.Claims.ClaimsPrincipal.Identities%2A>.</span><span class="sxs-lookup"><span data-stu-id="60c98-114">The <xref:System.IdentityModel.Tokens.SessionSecurityToken?displayProperty=nameWithType> is used to reconstruct the client’s <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType>, which contains all of the client’s identities in <xref:System.Security.Claims.ClaimsPrincipal.Identities%2A>.</span></span> <span data-ttu-id="60c98-115">Каждое удостоверение <xref:System.Security.Claims.ClaimsIdentity?displayProperty=nameWithType> в коллекции содержит токены начальной загрузки, связанные с данным удостоверением.</span><span class="sxs-lookup"><span data-stu-id="60c98-115">Each <xref:System.Security.Claims.ClaimsIdentity?displayProperty=nameWithType> in the collection contains the bootstrap tokens that are associated with that identity.</span></span>  
  
 <span data-ttu-id="60c98-116">Если выдается новый токен сеанса с ИД сеанса исходного токена, обработчик <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler?displayProperty=nameWithType> не обновляет токен сеанса в кэше токенов.</span><span class="sxs-lookup"><span data-stu-id="60c98-116">If a new session token is issued with the session ID of the original session token, <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler?displayProperty=nameWithType> does not update the session token in the token cache.</span></span> <span data-ttu-id="60c98-117">Экземпляр токена сеанса всегда должен создаваться с уникальным ИД сеанса.</span><span class="sxs-lookup"><span data-stu-id="60c98-117">You should always instantiate a session token with a unique session ID.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="60c98-118">Session.SecurityTokenHandler.ReadToken вызывает исключение <xref:System.Xml.XmlException> в случае получения недопустимых входных данных, например если файл cookie, содержащий токен сеанса, поврежден.</span><span class="sxs-lookup"><span data-stu-id="60c98-118">Session.SecurityTokenHandler.ReadToken throws a <xref:System.Xml.XmlException> exception if it receives invalid input; for example, if the cookie that contains the session token is corrupted.</span></span> <span data-ttu-id="60c98-119">Рекомендуется перехватить это исключение и обеспечить соответствующую реакцию в приложении.</span><span class="sxs-lookup"><span data-stu-id="60c98-119">We recommend that you catch this exception and provide application-specific behavior.</span></span>  
  
 <span data-ttu-id="60c98-120">Если защищенная веб-страница содержит множество ресурсов (например, небольшие рисунки), которые также входят в защищенный домен, для скачивания каждого из этих ресурсов клиент должен пройти повторную проверку подлинности для проверяющей стороны.</span><span class="sxs-lookup"><span data-stu-id="60c98-120">If a protected Web page contains lots of resources (such as small graphics) that are also in the protected domain, the client must re-authenticate itself to the relying party to download each of those resources.</span></span> <span data-ttu-id="60c98-121">Использование токена проверки подлинности сеанса позволяет избежать прохождения проверки подлинности в службе STS для каждого запроса, однако по-прежнему отправляется множество файлов cookie.</span><span class="sxs-lookup"><span data-stu-id="60c98-121">Use of a session authentication token avoids the need to authenticate to the STS for each request, but it still means that many cookies are being sent over.</span></span> <span data-ttu-id="60c98-122">Веб-страницу можно настроить таким образом, чтобы важные данные и ресурсы хранились в защищенном домене, а менее существенные элементы — в незащищенном домене, к которому можно перейти по ссылкам на главной веб-странице.</span><span class="sxs-lookup"><span data-stu-id="60c98-122">You might want to set up the Web page so that the important data and resources are stored in the protected domain while minor items are stored in an unprotected domain and linked to from the main Web page.</span></span> <span data-ttu-id="60c98-123">Кроме того, можно задать путь к файлу cookie таким образом, чтобы он указывал только на защищенный домен.</span><span class="sxs-lookup"><span data-stu-id="60c98-123">Also, set the cookie path to reference only the protected domain.</span></span>  
  
 <span data-ttu-id="60c98-124">Для работы в режиме ссылки корпорация Майкрософт рекомендует реализовать обработчик события <xref:System.IdentityModel.Services.WSFederationAuthenticationModule.SessionSecurityTokenCreated> в файле **global.asax.cs** и задать свойство **IsReferenceMode** в токене, передаваемом в свойстве <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A>.</span><span class="sxs-lookup"><span data-stu-id="60c98-124">To operate in reference mode, Microsoft recommends providing a handler for the <xref:System.IdentityModel.Services.WSFederationAuthenticationModule.SessionSecurityTokenCreated> event in the **global.asax.cs** file and setting the **IsReferenceMode** property on the token passed in the <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A> property.</span></span> <span data-ttu-id="60c98-125">В результате этих изменений токен будет работать в режиме ссылки для каждого запроса. Использовать такой вариант предпочтительнее, чем просто задавать свойство <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A> в модуле проверки подлинности сеанса.</span><span class="sxs-lookup"><span data-stu-id="60c98-125">These updates will ensure that the session token operates in reference mode for every request and is favored over merely setting the  <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A> property on the Session Authentication Module.</span></span>  
  
## <a name="extensibility"></a><span data-ttu-id="60c98-126">Расширение среды</span><span class="sxs-lookup"><span data-stu-id="60c98-126">Extensibility</span></span>  
 <span data-ttu-id="60c98-127">Механизм управления сеансами можно расширить.</span><span class="sxs-lookup"><span data-stu-id="60c98-127">You can extend the session management mechanism.</span></span> <span data-ttu-id="60c98-128">Это может потребоваться, например, для повышения производительности.</span><span class="sxs-lookup"><span data-stu-id="60c98-128">One reason for this would be to improve the performance.</span></span> <span data-ttu-id="60c98-129">Допустим, требуется создать пользовательский обработчик файлов cookie, который будет преобразовывать или оптимизировать токен безопасности сеанса между его состоянием в памяти и содержимым файлов cookie.</span><span class="sxs-lookup"><span data-stu-id="60c98-129">For example, you could create a custom cookie handler that transforms or optimizes the session security token between its in-memory state and what goes into the cookie.</span></span> <span data-ttu-id="60c98-130">Для этого следует настроить свойство <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A?displayProperty=nameWithType> модуля <xref:System.IdentityModel.Services.SessionAuthenticationModule?displayProperty=nameWithType> для использования пользовательского обработчика файлов cookie, производного от <xref:System.IdentityModel.Services.CookieHandler?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60c98-130">To do so, you can configure the <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A?displayProperty=nameWithType> property of the <xref:System.IdentityModel.Services.SessionAuthenticationModule?displayProperty=nameWithType> to use a custom cookie handler that derives from <xref:System.IdentityModel.Services.CookieHandler?displayProperty=nameWithType>.</span></span> <span data-ttu-id="60c98-131"><xref:System.IdentityModel.Services.ChunkedCookieHandler?displayProperty=nameWithType> является обработчиком файлов cookie по умолчанию, так как размер этих файлов превышает допустимый размер для протокола HTTP. Если вместо этого применяется пользовательский обработчик, необходимо прибегнуть к разделению на блоки.</span><span class="sxs-lookup"><span data-stu-id="60c98-131"><xref:System.IdentityModel.Services.ChunkedCookieHandler?displayProperty=nameWithType> is the default cookie handler because the cookies exceed the allowable size for Hypertext Transfer Protocol (HTTP); if you use a custom cookie handler instead, you must implement chunking.</span></span>  
  
 <span data-ttu-id="60c98-132">Дополнительные сведения см. в разделе [клаимсаваревебфарм](https://go.microsoft.com/fwlink/?LinkID=248408) Sample.</span><span class="sxs-lookup"><span data-stu-id="60c98-132">For more information, see [ClaimsAwareWebFarm](https://go.microsoft.com/fwlink/?LinkID=248408) sample.</span></span> <span data-ttu-id="60c98-133">В этом примере демонстрируется готовый к применению в ферме кэш сеанса (вместо tokenreplycache), который позволяет использовать сеансы по ссылке, а не обмениваться большими файлами cookie. Также показан более простой способ защиты файлов cookie в ферме.</span><span class="sxs-lookup"><span data-stu-id="60c98-133">This sample shows a farm ready session cache (as opposed to a tokenreplycache) so that you can use sessions by reference instead of exchanging big cookies; this sample also demonstrates an easier way of securing cookies in a farm.</span></span> <span data-ttu-id="60c98-134">Кэш сеанса основан на WCF.</span><span class="sxs-lookup"><span data-stu-id="60c98-134">The session cache is WCF-based.</span></span> <span data-ttu-id="60c98-135">Что касается безопасности сеансов, в примере демонстрируется имеющаяся в WIF 4.5 новая возможность преобразования файлов cookie на основе MachineKey, которую можно активировать, просто вставив соответствующий фрагмент кода в файл web.config. Сам образец не размещен в ферме, однако показывает, что нужно сделать, чтобы приложение можно было использовать в ферме.</span><span class="sxs-lookup"><span data-stu-id="60c98-135">With regard to session securing, the sample demonstrates a new capability in WIF 4.5 of a cookie transform based on MachineKey, which can be activated by simply pasting the appropriate snippet in the web.config. The sample itself is not "farmed", but it demonstrates what you need for making your app farm-ready.</span></span>
