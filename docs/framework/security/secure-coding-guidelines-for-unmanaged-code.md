---
title: Защита правил кодирования для неуправляемого кода
ms.date: 03/30/2017
helpviewer_keywords:
- code security, unmanaged code
- unmanaged code, securing
- security [.NET Framework], unmanaged code
- secure coding, unmanaged code
ms.assetid: a8d15139-d368-4c9c-a747-ba757781117c
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 138713c4a1397369ea18792a3b2742389b107a6b
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/08/2019
ms.locfileid: "59143771"
---
# <a name="secure-coding-guidelines-for-unmanaged-code"></a>Защита правил кодирования для неуправляемого кода
Части библиотечного кода необходимо осуществлять вызовы неуправляемого кода (например, интерфейсов API машинного кода, таких как Win32). Так как при этом не работает система безопасности управляемого кода, необходимо соблюдать соответствующие меры предосторожности. Если код является нейтральным с точки зрения безопасности, то он, как и любой вызывающий его код, должен иметь разрешение неуправляемого кода (<xref:System.Security.Permissions.SecurityPermission> с указанием флага <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> ).  
  
 Однако часто нецелесообразно предоставлять вызывающему коду столь широкие полномочия. В этих случаях доверенный код может выступать в качестве посредника, аналогично управляемой оболочке или библиотечному коду, описанному в разделе [Безопасность кода программы-оболочки](../../../docs/framework/misc/securing-wrapper-code.md). Если базовая функциональность неуправляемого кода полностью безопасна, к нему можно предоставить прямой доступ. В противном случае сначала нужно осуществить проверку безопасности (требование).  
  
 Если код вызывает неуправляемый код, но не требует разрешений от вызывающих объектов на доступ к неуправляемому коду, необходимо утвердить эти права. Такое утверждение блокирует обход стека в кадре. Будьте внимательны, чтобы при этом не создать брешь в системе безопасности. Обычно это означает, что необходимо затребовать соответствующее разрешение у вызывающих объектов, а затем использовать неуправляемый код для выполнения исключительно тех действий, на которые у вызывающего объекта есть разрешение. В некоторых случаях (например, для функции запроса текущего времени) можно предоставлять вызывающим объектам прямой доступ к неуправляемому коду без использования каких-либо проверок безопасности. В любом случае код, использующий приведенный выше способ, должен отвечать за обеспечение безопасности.  
  
 Так как любой управляемый код, который предоставляет доступ к машинному коду, является потенциальной мишенью для атаки со стороны вредоносного кода, определение того, какой неуправляемый код можно безопасно использовать и каким именно образом, требует внимательнейшего отношения. В целом, никогда не следует предоставлять прямой доступ к неуправляемому коду частично доверенным вызывающим объектам. Существуют два основных аспекта при рассмотрении безопасности использования неуправляемого кода в библиотеках, которые могут вызываться частично доверенным кодом.  
  
-   **Функциональность**. Обеспечивает ли неуправляемый API безопасную функциональность, которая не позволяет вызывающим объектам осуществлять потенциально небезопасные операции? Управление доступом для кода использует разрешения для доступа к ресурсам, поэтому следует проверить, использует ли API файлы, пользовательский интерфейс, потоки или что-либо еще, позволяющее получить доступ к защищенной информации. Если это происходит, управляемый код, который является оболочкой для рассматриваемого API, должен требовать необходимые разрешения. Кроме того, доступ к памяти должен быть типобезопасным, хотя и отсутствует защита с использованием разрешений.  
  
-   **Проверка параметров**. Часто используемым способом атаки является передача неожиданных значений параметров методам API, реализованным в виде неуправляемого кода, с целью вызвать их функционирование непредусмотренным образом. Переполнение буфера с помощью значения индекса или смещения вне допустимого диапазона — типичный пример такого рода атак, наряду с применением параметров, использующих ошибки в базовом коде. Таким образом, даже если интерфейс API, представляющий собой неуправляемый код, функционально безопасен (после выполнения всех необходимых требований) для частично доверенных вызывающих объектов, управляемый код должен также досконально проверять правильность параметров, чтобы гарантировать невозможность вызовов со стороны вредоносного кода, использующего оболочку управляемого кода.  
  
## <a name="using-suppressunmanagedcodesecurityattribute"></a>Использование атрибута SuppressUnmanagedCodeSecurityAttribute  
 Использование утверждения и последующего вызова неуправляемого кода может влиять на производительность. При каждом таком вызове система безопасности автоматически требует разрешение неуправляемого кода, что приводит каждый раз к обходу стека. Если используется утверждение и сразу же вызывается неуправляемый код, обход стека не имеет смысла: стек состоит из вашего утверждения и вызова неуправляемого кода.  
  
 К точкам входа неуправляемого кода можно применить настраиваемый атрибут <xref:System.Security.SuppressUnmanagedCodeSecurityAttribute> , чтобы отключить обычную проверку безопасности, которая требует указания разрешения <xref:System.Security.Permissions.SecurityPermission> с <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> . При этом следует соблюдать особую осторожность, так как создается открытая точка доступа к неуправляемому коду, не предусматривающая проверок безопасности во время выполнения. Следует заметить, что даже если атрибут **SuppressUnmanagedCodeSecurityAttribute** указан, во время JIT-компиляции производится одноразовая проверка с целью подтверждения наличия у непосредственного вызывающего объекта прав вызова неуправляемого кода.  
  
 При использовании атрибута **SuppressUnmanagedCodeSecurityAttribute**необходимо учесть указанные ниже моменты.  
  
-   Сделайте точку входа в неуправляемый код внутренней или иным образом недоступной извне вашего кода.  
  
-   Любой вызов неуправляемого кода — это возможная брешь в системе безопасности. Убедитесь в том, что ваш код не является лазейкой, через которую вредоносный код может косвенно вызывать неуправляемый код в обход проверки безопасности. Требуйте разрешения, когда это имеет смысл.  
  
-   Используйте соглашение об именовании для того, чтобы явным образом указывать создание небезопасного пути доступа к неуправляемому коду, как описано в следующем разделе.  
  
## <a name="naming-convention-for-unmanaged-code-methods"></a>Соглашения об именовании для методов неуправляемого кода  
 Существуют установившиеся и весьма рекомендуемые к использованию соглашения об именовании методов неуправляемого кода. Все методы неуправляемого кода разделяются на три категории: **safe**, **native**и **unsafe**. Эти ключевые слова можно использовать как имена классов, внутри которых определяются различные виды точек входа в неуправляемый код. В исходном коде эти ключевые слова должны добавляться к именам классов, например `Safe.GetTimeOfDay`, `Native.Xyz`или `Unsafe.DangerousAPI`. Каждое из этих ключевых слов несет важную информацию для разработчиков, использующих данный класс, что раскрывается в таблице ниже.  
  
|Ключевое слово|Замечания по безопасности|  
|-------------|-----------------------------|  
|**safe**|Вызов полностью безопасен, даже если вызывающим объектом является вредоносный код. Код может использоваться так же, как и любой управляемый код. Например, функция, запрашивающая текущее время, обычно является безопасной.|  
|**в машинном коде**|Нейтральный с точки зрения безопасности, то есть неуправляемый код, который для вызова требует разрешение неуправляемого кода. Осуществляется проверка безопасности, что предотвращает несанкционированный вызов кода.|  
|**unsafe**|Потенциально небезопасная точка входа в неуправляемый код с пониженным уровнем безопасности. Разработчикам следует проявлять повышенную осторожность при использовании такого неуправляемого кода и всегда убеждаться в том, что включены другие механизмы защиты, позволяющие уменьшить уязвимость системы безопасности. Ответственность в этом случае несут разработчики, так как использование этого ключевого слова переопределяет систему безопасности.|  
  
## <a name="see-also"></a>См. также

- [Правила написания безопасного кода](../../../docs/standard/security/secure-coding-guidelines.md)
