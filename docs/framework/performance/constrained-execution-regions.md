---
title: области с ограничением выполнения
ms.date: 03/30/2017
helpviewer_keywords:
- constrained execution regions
- CERs
ms.assetid: 99354547-39c1-4b0b-8553-938e8f8d1808
ms.openlocfilehash: fde2bab99f156ddffec678022a58e7b14e0af01e
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2020
ms.locfileid: "75716168"
---
# <a name="constrained-execution-regions"></a>области с ограничением выполнения
Область ограниченного выполнения (CER) является одной из составляющих механизма создания надежного управляемого кода. В этой области общеязыковая среда выполнения (CLR) не может выдавать специализированные исключения, препятствующие полному выполнению заключенного в эту область кода. В этой области не может выполняться пользовательский код, в результате которого могут возникать специализированные исключения. Метод <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> указывается непосредственно перед блоком `try` и помечает блоки `catch`, `finally` и `fault` как области ограниченного выполнения. После определения области ограниченного выполнения код может вызывать только другой код со строгими контрактами надежности и не должен выделять память или выполнять виртуальные вызовы для неподготовленных или ненадежных методов, если в таком коде не предусмотрены механизмы обработки сбоев. Среда выполнения задерживает аварийные завершения потоков для кода, который выполняется в области ограниченного выполнения.  
  
 Области ограниченного выполнения применяются в среде CLR в различных формах, в том числе в указанном выше блоке `try`. Часто это могут быть критически важные методы завершения, которые выполняются в производных от <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> классах, или код, выполняемый в методе <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A>.  
  
## <a name="cer-advance-preparation"></a>Заблаговременная подготовка области ограниченного выполнения  
 Среда CLR подготавливает область ограниченного выполнения заранее, чтобы избежать ошибок, связанных с нехваткой памяти. Таким образом удается исключить нехватку памяти во время JIT-компиляции или загрузки типов.  
  
 Разработчик должен явно определить нужный фрагмент кода как область ограниченного выполнения:  
  
- Область ограниченного выполнения верхнего уровня и методы в полном графе вызовов, к которым применяется атрибут <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>, подготавливаются заранее. Атрибут <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> может гарантировать только состояния <xref:System.Runtime.ConstrainedExecution.Cer.Success> или <xref:System.Runtime.ConstrainedExecution.Cer.MayFail>.  
  
- Заблаговременная подготовка невозможна для вызовов, которые нельзя определить статически, таких как вызовы виртуальной диспетчеризации. В таких случаях следует использовать метод <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%2A>. При использовании метода <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> необходимо применять атрибут <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> для очистки кода.  
  
## <a name="constraints"></a>Ограничения  
 В области ограниченного выполнения можно использовать только код определенного типа. В допустимом коде не должны возникать специализированные исключения, например связанные с выполнением следующих операций:  
  
- Явное выделение памяти.  
  
- Упаковка-преобразование.  
  
- Получение блокировки.  
  
- Виртуальный вызов неподготовленных методов.  
  
- Вызов методов со слабым или отсутствующим контрактом надежности.  
  
 Для платформы .NET Framework версии 2.0 эти ограничения устанавливаются как правила. Для диагностики применяются средства анализа кода.  
  
## <a name="reliability-contracts"></a>Контракты надежности  
 Настраиваемый атрибут <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> определяет гарантированную надежность и состояние повреждения для указанного метода.  
  
### <a name="reliability-guarantees"></a>Гарантии надежности  
 Гарантии надежности представляются значениями перечисления <xref:System.Runtime.ConstrainedExecution.Cer> и определяют степень надежности указанного метода:  
  
- <xref:System.Runtime.ConstrainedExecution.Cer.MayFail>. Метод может завершиться сбоем в состоянии исключения. В этом случае метод возвращает вызывающему методу сведения об успешном или неудачном выполнении. Такой метод должен размещаться в области ограниченного выполнения, чтобы гарантированно передавать возвращаемое значение.  
  
- <xref:System.Runtime.ConstrainedExecution.Cer.None>. Метод, тип или сборка не поддерживает механизм области ограниченного выполнения и, скорее всего, не может безопасно вызываться в ней без надлежащих мер по исключению поврежденного состояния. Этот метод не использует преимущества гарантий для области ограниченного выполнения. В этом случае подразумевается следующее:  
  
    1. Метод может завершиться сбоем в состоянии исключения.  
  
    2. Метод не может гарантированно возвращать сообщение о сбое.  
  
    3. В большинстве случаев этот метод не предназначен для использования в областях ограниченного выполнения.  
  
    4. Если метод, тип или сборка не имеют явного определения успешного выполнения, они будут неявно определены как <xref:System.Runtime.ConstrainedExecution.Cer.None>.  
  
- <xref:System.Runtime.ConstrainedExecution.Cer.Success>. В состоянии исключения гарантируется успешное выполнение метода. Чтобы достичь этого уровня надежности, необходимо всегда строить область ограниченного выполнения вокруг метода, который вызывается, даже если он вызывается не из такой области. Состояние успеха достигается в том случае, если метод выполнил предусмотренные операции либо завершился успешно с субъективной точки зрения. Например, если метод Count отмечен как `ReliabilityContractAttribute(Cer.Success)`, подразумевается, что он выполняется в области ограниченного выполнения, всегда возвращает число элементов в <xref:System.Collections.ArrayList> и никогда не оставляет внутренние поля в неопределенном состоянии.  Тем не менее метод <xref:System.Threading.Interlocked.CompareExchange%2A> также помечен как успешный в том смысле, что его значение не может быть заменено новым из-за возникновения состояния гонки.  В этом случае важно, что метод функционирует в точном соответствии с задокументированным поведением. Соответственно, для него не нужно писать код области ограниченного выполнения для обработки возможных непредвиденных результатов, которые может давать правильно написанный, но не являющийся надежным код.  
  
### <a name="corruption-levels"></a>Уровни повреждения  
 Уровни повреждения представлены значениями перечисления <xref:System.Runtime.ConstrainedExecution.Consistency> и указывают возможную степень повреждения состояния в указанной среде:  
  
- <xref:System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain>. В состоянии исключения общеязыковая среда выполнения (CLR) не гарантирует обеспечение согласованности состояния в текущем домене приложения.  
  
- <xref:System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance>. В состоянии исключения метод может гарантировать, что повреждение состояния будет ограничено областью текущего экземпляра.  
  
- <xref:System.Runtime.ConstrainedExecution.Consistency.MayCorruptProcess>. В состоянии исключения среда CLR не гарантирует согласованность состояния, то есть такое условие может привести к повреждению процесса.  
  
- <xref:System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState>. В состоянии исключения гарантируется, что метод не приведет к повреждению состояния.  
  
## <a name="reliability-trycatchfinally"></a>Надежность блоков try/catch/finally  
 Надежность блоков `try/catch/finally` определяет механизм обработки исключений с тем же уровнем гарантий предсказуемости, что и неуправляемая версия. Блок `catch/finally` представляет собой область ограниченного выполнения. Методы в этом блоке подготавливаются заранее и не должны прерываться.  
  
 На платформе .NET Framework версии 2.0 код информирует среду выполнения о надежности блока try, вызывая <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> непосредственно перед этим блоком. <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> является членом вспомогательного класса компилятора <xref:System.Runtime.CompilerServices.RuntimeHelpers>. Ожидается реализация прямого вызова метода <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> посредством компиляторов.  
  
## <a name="noninterruptible-regions"></a>Непрерываемые области  
 Непрерываемая область служит для группировки набора инструкций в области ограниченного выполнения.  
  
 На платформе .NET Framework версии 2.0 (ожидается доступность посредством компиляторов) пользовательский код создает непрерываемые области с надежными блоками try/catch/finally, содержащие пустой блок try/catch block, которому предшествует вызов метода <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.  
  
## <a name="critical-finalizer-object"></a>Объект критически важного метода завершения  
 <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> гарантирует, что в методе завершения будет выполнена сборка мусора. После выделения памяти метод завершения и его граф вызовов подготавливаются заблаговременно. Метод завершения выполняется в области ограниченного выполнения и должен соответствовать всем ограничениям, которые применяются к таким областям и методам.  
  
 Для всех типов, наследуемых от <xref:System.Runtime.InteropServices.SafeHandle> и <xref:System.Runtime.InteropServices.CriticalHandle>, гарантируется выполнение метода завершения в области ограниченного выполнения. Для выполнения любого кода, для которого требуется высвобождение дескриптора, реализуйте <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> в производных от <xref:System.Runtime.InteropServices.SafeHandle> классах.  
  
## <a name="code-not-permitted-in-cers"></a>Код, который нельзя выполнять в областях ограниченного выполнения  
 В областях ограниченного выполнения не допускаются следующие операции:  
  
- Явное выделение памяти.  
  
- Получение блокировки.  
  
- Упаковка-преобразование.  
  
- Доступ к многомерным массивам.  
  
- Вызовы методов посредством отражения.  
  
- <xref:System.Threading.Monitor.Enter%2A> или <xref:System.IO.FileStream.Lock%2A>.  
  
- Проверки безопасности. Нельзя выполнять запросы, только требования ссылок.  
  
- <xref:System.Reflection.Emit.OpCodes.Isinst> и <xref:System.Reflection.Emit.OpCodes.Castclass> для COM-объектов и прокси-элементов.  
  
- Получение или установка полей для прозрачных прокси.  
  
- Сериализация.  
  
- Указатели на функции и делегаты.  
  
## <a name="see-also"></a>См. также:

- [Рекомендации по обеспечению надежности](reliability-best-practices.md)
