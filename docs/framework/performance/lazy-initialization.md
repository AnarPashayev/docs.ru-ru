---
title: Отложенная инициализация
description: Изучение отложенной инициализации в .NET — повышение производительности, означающее, что создание объекта откладывается до первого использования объекта.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lazy initialization in .NET, introduction
ms.assetid: 56b4ae5c-4745-44ff-ad78-ffe4fcde6b9b
ms.openlocfilehash: 355fa326fc19e9a50a74e21ace0a6353f5c740c5
ms.sourcegitcommit: 3824ff187947572b274b9715b60c11269335c181
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/17/2020
ms.locfileid: "84904238"
---
# <a name="lazy-initialization"></a><span data-ttu-id="e3886-103">Отложенная инициализация</span><span class="sxs-lookup"><span data-stu-id="e3886-103">Lazy Initialization</span></span>
<span data-ttu-id="e3886-104">*Отложенная инициализация* объекта означает, что его создание откладывается до первого использования.</span><span class="sxs-lookup"><span data-stu-id="e3886-104">*Lazy initialization* of an object means that its creation is deferred until it is first used.</span></span> <span data-ttu-id="e3886-105">(В этом разделе термины « *ленивая» инициализация* и « *ленивое» создание экземпляра* являются синонимами.) Отложенная инициализация в основном используется для повышения производительности, предотвращения непроизводительна вычислений и сокращения требований к памяти программы.</span><span class="sxs-lookup"><span data-stu-id="e3886-105">(For this topic, the terms *lazy initialization* and *lazy instantiation* are synonymous.) Lazy initialization is primarily used to improve performance, avoid wasteful computation, and reduce program memory requirements.</span></span> <span data-ttu-id="e3886-106">Ниже приведены наиболее распространенные сценарии.</span><span class="sxs-lookup"><span data-stu-id="e3886-106">These are the most common scenarios:</span></span>  
  
- <span data-ttu-id="e3886-107">При наличии объекта, создание которого требует много ресурсов и который, возможно, не будет использоваться программой.</span><span class="sxs-lookup"><span data-stu-id="e3886-107">When you have an object that is expensive to create, and the program might not use it.</span></span> <span data-ttu-id="e3886-108">Например, предположим, что в памяти находится объект `Customer`, у которого есть свойство `Orders`, содержащее большой массив объектов `Order`, инициализация которых требует подключения к базе данных.</span><span class="sxs-lookup"><span data-stu-id="e3886-108">For example, assume that you have in memory a `Customer` object that has an `Orders` property that contains a large array of `Order` objects that, to be initialized, requires a database connection.</span></span> <span data-ttu-id="e3886-109">Если пользователь никогда не отображает массив Orders и не использует его данные в расчетах, то нет смысла использовать системную память или такты процессора для создания этого массива.</span><span class="sxs-lookup"><span data-stu-id="e3886-109">If the user never asks to display the Orders or use the data in a computation, then there is no reason to use system memory or computing cycles to create it.</span></span> <span data-ttu-id="e3886-110">Используя `Lazy<Orders>`, чтобы объявить отложенную инициализацию объекта `Orders`, можно избежать расхода системных ресурсов на неиспользуемый объект.</span><span class="sxs-lookup"><span data-stu-id="e3886-110">By using `Lazy<Orders>` to declare the `Orders` object for lazy initialization, you can avoid wasting system resources when the object is not used.</span></span>  
  
- <span data-ttu-id="e3886-111">При наличии объекта, требующее много ресурсов создание которого желательно отложить до завершения других ресурсоемких операций.</span><span class="sxs-lookup"><span data-stu-id="e3886-111">When you have an object that is expensive to create, and you want to defer its creation until after other expensive operations have been completed.</span></span> <span data-ttu-id="e3886-112">Например, пусть программа во время запуска загружает несколько экземпляров объекта, но только часть из них требуется сразу.</span><span class="sxs-lookup"><span data-stu-id="e3886-112">For example, assume that your program loads several object instances when it starts, but only some of them are required immediately.</span></span> <span data-ttu-id="e3886-113">Можно повысить быстродействие программы при запуске, отложив инициализацию временно ненужных объектов до того, как они понадобятся.</span><span class="sxs-lookup"><span data-stu-id="e3886-113">You can improve the startup performance of the program by deferring initialization of the objects that are not required until the required objects have been created.</span></span>  
  
 <span data-ttu-id="e3886-114">Хотя вы можете написать свой код для выполнения отложенной инициализации, вместо этого рекомендуется использовать тип <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="e3886-114">Although you can write your own code to perform lazy initialization, we recommend that you use <xref:System.Lazy%601> instead.</span></span> <span data-ttu-id="e3886-115">Тип <xref:System.Lazy%601> и связанные с ним типы также поддерживают безопасность потоков и обеспечивают согласованную политику распространения исключений.</span><span class="sxs-lookup"><span data-stu-id="e3886-115"><xref:System.Lazy%601> and its related types also support thread-safety and provide a consistent exception propagation policy.</span></span>  
  
 <span data-ttu-id="e3886-116">В таблице ниже приведены типы, предоставляемые в .NET Framework версии 4 для поддержки отложенной инициализации в различных сценариях.</span><span class="sxs-lookup"><span data-stu-id="e3886-116">The following table lists the types that the .NET Framework version 4 provides to enable lazy initialization in different scenarios.</span></span>  
  
|<span data-ttu-id="e3886-117">Тип</span><span class="sxs-lookup"><span data-stu-id="e3886-117">Type</span></span>|<span data-ttu-id="e3886-118">Описание</span><span class="sxs-lookup"><span data-stu-id="e3886-118">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601>|<span data-ttu-id="e3886-119">Класс-оболочка, предоставляющий семантику отложенной инициализации для любого типа из библиотеки классов или пользовательского типа.</span><span class="sxs-lookup"><span data-stu-id="e3886-119">A wrapper class that provides lazy initialization semantics for any class library or user-defined type.</span></span>|  
|<xref:System.Threading.ThreadLocal%601>|<span data-ttu-id="e3886-120">Похож на тип <xref:System.Lazy%601> за исключением того, что предоставляет семантику отложенной инициализации на основе локального потока.</span><span class="sxs-lookup"><span data-stu-id="e3886-120">Resembles <xref:System.Lazy%601> except that it provides lazy initialization semantics on a thread-local basis.</span></span> <span data-ttu-id="e3886-121">У каждого потока есть доступ к собственному уникальному значению.</span><span class="sxs-lookup"><span data-stu-id="e3886-121">Every thread has access to its own unique value.</span></span>|  
|<xref:System.Threading.LazyInitializer>|<span data-ttu-id="e3886-122">Предоставляет расширенные методы `static` (`Shared` в Visual Basic) для отложенной инициализации объектов без дополнительных издержек для класса.</span><span class="sxs-lookup"><span data-stu-id="e3886-122">Provides advanced `static` (`Shared` in Visual Basic) methods for lazy initialization of objects without the overhead of a class.</span></span>|  
  
## <a name="basic-lazy-initialization"></a><span data-ttu-id="e3886-123">Базовая отложенная инициализация</span><span class="sxs-lookup"><span data-stu-id="e3886-123">Basic Lazy Initialization</span></span>  
 <span data-ttu-id="e3886-124">Чтобы определить тип с отложенной инициализацией, например `MyType`, используйте `Lazy<MyType>` (`Lazy(Of MyType)` в Visual Basic), как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="e3886-124">To define a lazy-initialized type, for example, `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic), as shown in the following example.</span></span> <span data-ttu-id="e3886-125">Если в конструктор <xref:System.Lazy%601> не передается делегат, при первом доступе к свойству значения заключенный в оболочку тип создается с помощью <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e3886-125">If no delegate is passed in the <xref:System.Lazy%601> constructor, the wrapped type is created by using <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> when the value property is first accessed.</span></span> <span data-ttu-id="e3886-126">Если у типа нет конструктора без параметров, возникает исключение времени выполнения.</span><span class="sxs-lookup"><span data-stu-id="e3886-126">If the type does not have a parameterless constructor, a run-time exception is thrown.</span></span>  
  
 <span data-ttu-id="e3886-127">В следующем примере предполагается, что `Orders` — это класс, содержащий массив объектов `Order`, извлекаемых из базы данных.</span><span class="sxs-lookup"><span data-stu-id="e3886-127">In the following example, assume that `Orders` is a class that contains an array of `Order` objects retrieved from a database.</span></span> <span data-ttu-id="e3886-128">Объект `Customer` содержит экземпляр `Orders`, но в зависимости от действий пользователя данные из объекта `Orders` могут и не понадобиться.</span><span class="sxs-lookup"><span data-stu-id="e3886-128">A `Customer` object contains an instance of `Orders`, but depending on user actions, the data from the `Orders` object might not be required.</span></span>  
  
 [!code-csharp[Lazy#1](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#1)]
 [!code-vb[Lazy#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#1)]  
  
 <span data-ttu-id="e3886-129">Можно также передать делегат в конструктор <xref:System.Lazy%601>, вызывающий во время создания особую перегруженную версию конструктора для заключенного в оболочку типа, и выполнить любые другие действия, необходимые для инициализации, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="e3886-129">You can also pass a delegate in the <xref:System.Lazy%601> constructor that invokes a specific constructor overload on the wrapped type at creation time, and perform any other initialization steps that are required, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#2](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#2)]
 [!code-vb[Lazy#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#2)]  
  
 <span data-ttu-id="e3886-130">После создания объекта Lazy экземпляр `Orders` не создается до первого доступа к свойству <xref:System.Lazy%601.Value%2A> переменной Lazy.</span><span class="sxs-lookup"><span data-stu-id="e3886-130">After the Lazy object is created, no instance of `Orders` is created until the <xref:System.Lazy%601.Value%2A> property of the Lazy variable is accessed for the first time.</span></span> <span data-ttu-id="e3886-131">При первом доступе заключенный в оболочку тип создается, возвращается и сохраняется для любого использования в будущем.</span><span class="sxs-lookup"><span data-stu-id="e3886-131">On first access, the wrapped type is created and returned, and stored for any future access.</span></span>  
  
 [!code-csharp[Lazy#3](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#3)]
 [!code-vb[Lazy#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#3)]  
  
 <span data-ttu-id="e3886-132">Объект <xref:System.Lazy%601> всегда возвращает тот же объект или то же значение, которые использовались для его инициализации.</span><span class="sxs-lookup"><span data-stu-id="e3886-132">A <xref:System.Lazy%601> object always returns the same object or value that it was initialized with.</span></span> <span data-ttu-id="e3886-133">Следовательно, свойство <xref:System.Lazy%601.Value%2A> доступно только для чтения.</span><span class="sxs-lookup"><span data-stu-id="e3886-133">Therefore, the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="e3886-134">Если в свойстве <xref:System.Lazy%601.Value%2A> хранится ссылочный тип, нельзя присвоить этому свойству новый объект.</span><span class="sxs-lookup"><span data-stu-id="e3886-134">If <xref:System.Lazy%601.Value%2A> stores a reference type, you cannot assign a new object to it.</span></span> <span data-ttu-id="e3886-135">(Однако можно изменить значения его устанавливаемых общих полей и свойств.) Если <xref:System.Lazy%601.Value%2A> хранит тип значения, его значение изменить нельзя.</span><span class="sxs-lookup"><span data-stu-id="e3886-135">(However, you can change the value of its settable public fields and properties.) If <xref:System.Lazy%601.Value%2A> stores a value type, you cannot modify its value.</span></span> <span data-ttu-id="e3886-136">Тем не менее можно создать новую переменную, вызвав конструктор переменной еще раз с новыми аргументами.</span><span class="sxs-lookup"><span data-stu-id="e3886-136">Nevertheless, you can create a new variable by invoking the variable constructor again by using new arguments.</span></span>  
  
 [!code-csharp[Lazy#4](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#4)]
 [!code-vb[Lazy#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#4)]  
  
 <span data-ttu-id="e3886-137">Новый экземпляр с отложенной инициализацией, как и предыдущий, не будет инициализировать `Orders` до первого обращения к его свойству <xref:System.Lazy%601.Value%2A>.</span><span class="sxs-lookup"><span data-stu-id="e3886-137">The new lazy instance, like the earlier one, does not instantiate `Orders` until its <xref:System.Lazy%601.Value%2A> property is first accessed.</span></span>  
  
### <a name="thread-safe-initialization"></a><span data-ttu-id="e3886-138">Потокобезопасная инициализация</span><span class="sxs-lookup"><span data-stu-id="e3886-138">Thread-Safe Initialization</span></span>  
 <span data-ttu-id="e3886-139">По умолчанию объекты <xref:System.Lazy%601> являются потокобезопасными.</span><span class="sxs-lookup"><span data-stu-id="e3886-139">By default, <xref:System.Lazy%601> objects are thread-safe.</span></span> <span data-ttu-id="e3886-140">То есть если конструктор не задает тип потокобезопасности, создаваемые им объекты <xref:System.Lazy%601> являются потокобезопасными.</span><span class="sxs-lookup"><span data-stu-id="e3886-140">That is, if the constructor does not specify the kind of thread safety, the <xref:System.Lazy%601> objects it creates are thread-safe.</span></span> <span data-ttu-id="e3886-141">В сценариях с несколькими потоками первый поток, обращающийся к свойству <xref:System.Lazy%601.Value%2A> потокобезопасного объекта <xref:System.Lazy%601>, инициализирует его для всех последующих случаев доступа из всех потоков, и все потоки совместно используют одни и те же данные.</span><span class="sxs-lookup"><span data-stu-id="e3886-141">In multi-threaded scenarios, the first thread to access the <xref:System.Lazy%601.Value%2A> property of a thread-safe <xref:System.Lazy%601> object initializes it for all subsequent accesses on all threads, and all threads share the same data.</span></span> <span data-ttu-id="e3886-142">Следовательно, неважно, какой поток инициализирует объект, и состояния гонки являются мягкими.</span><span class="sxs-lookup"><span data-stu-id="e3886-142">Therefore, it does not matter which thread initializes the object, and race conditions are benign.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e3886-143">Можно повысить эту устойчивость к ошибкам путем кэширования исключений.</span><span class="sxs-lookup"><span data-stu-id="e3886-143">You can extend this consistency to error conditions by using exception caching.</span></span> <span data-ttu-id="e3886-144">Дополнительные сведения см. в следующем разделе [Исключения в объектах с отложенной инициализацией](lazy-initialization.md#ExceptionsInLazyObjects).</span><span class="sxs-lookup"><span data-stu-id="e3886-144">For more information, see the next section, [Exceptions in Lazy Objects](lazy-initialization.md#ExceptionsInLazyObjects).</span></span>  
  
 <span data-ttu-id="e3886-145">В приведенном ниже примере показано, что один и тот же экземпляр `Lazy<int>` обладает одним и тем же значением для трех отдельных потоков.</span><span class="sxs-lookup"><span data-stu-id="e3886-145">The following example shows that the same `Lazy<int>` instance has the same value for three separate threads.</span></span>  
  
 [!code-csharp[Lazy#8](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#8)]
 [!code-vb[Lazy#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#8)]  
  
 <span data-ttu-id="e3886-146">Если для каждого потока требуются собственные данные, используйте тип <xref:System.Threading.ThreadLocal%601>, описанный в этом разделе ранее.</span><span class="sxs-lookup"><span data-stu-id="e3886-146">If you require separate data on each thread, use the <xref:System.Threading.ThreadLocal%601> type, as described later in this topic.</span></span>  
  
 <span data-ttu-id="e3886-147">Некоторые конструкторы <xref:System.Lazy%601> обладают логическим параметром с именем `isThreadSafe`, используемым для определения того, будет ли свойство <xref:System.Lazy%601.Value%2A> доступно из нескольких потоков.</span><span class="sxs-lookup"><span data-stu-id="e3886-147">Some <xref:System.Lazy%601> constructors have a Boolean parameter named `isThreadSafe` that is used to specify whether the <xref:System.Lazy%601.Value%2A> property will be accessed from multiple threads.</span></span> <span data-ttu-id="e3886-148">Если предполагается, что свойство будет доступно только из одного потока, передайте значение `false`, чтобы получить небольшой выигрыш в быстродействии.</span><span class="sxs-lookup"><span data-stu-id="e3886-148">If you intend to access the property from just one thread, pass in `false` to obtain a modest performance benefit.</span></span> <span data-ttu-id="e3886-149">Если предполагается доступ к свойству из нескольких потоков, передайте значение `true`, чтобы указать экземпляру <xref:System.Lazy%601> на необходимость правильно обрабатывать состояния гонки, в которых один поток создает исключение во время инициализации.</span><span class="sxs-lookup"><span data-stu-id="e3886-149">If you intend to access the property from multiple threads, pass in `true` to instruct the <xref:System.Lazy%601> instance to correctly handle race conditions in which one thread throws an exception at initialization time.</span></span>  
  
 <span data-ttu-id="e3886-150">Некоторые конструкторы <xref:System.Lazy%601> имеют параметр <xref:System.Threading.LazyThreadSafetyMode> с именем `mode`.</span><span class="sxs-lookup"><span data-stu-id="e3886-150">Some <xref:System.Lazy%601> constructors have a <xref:System.Threading.LazyThreadSafetyMode> parameter named `mode`.</span></span> <span data-ttu-id="e3886-151">Эти конструкторы предоставляют дополнительный режим потокобезопасности.</span><span class="sxs-lookup"><span data-stu-id="e3886-151">These constructors provide an additional thread safety mode.</span></span> <span data-ttu-id="e3886-152">В приведенной ниже таблице показано, как на потокобезопасность объекта <xref:System.Lazy%601> влияют параметры конструктора, задающие потокобезопасность.</span><span class="sxs-lookup"><span data-stu-id="e3886-152">The following table shows how the thread safety of a <xref:System.Lazy%601> object is affected by constructor parameters that specify thread safety.</span></span> <span data-ttu-id="e3886-153">Каждый конструктор имеет не более одного такого параметра.</span><span class="sxs-lookup"><span data-stu-id="e3886-153">Each constructor has at most one such parameter.</span></span>  
  
|<span data-ttu-id="e3886-154">Потокобезопасность объекта</span><span class="sxs-lookup"><span data-stu-id="e3886-154">Thread safety of the object</span></span>|<span data-ttu-id="e3886-155">`LazyThreadSafetyMode``mode`параметр</span><span class="sxs-lookup"><span data-stu-id="e3886-155">`LazyThreadSafetyMode` `mode` parameter</span></span>|<span data-ttu-id="e3886-156">Логический параметр `isThreadSafe`</span><span class="sxs-lookup"><span data-stu-id="e3886-156">Boolean `isThreadSafe` parameter</span></span>|<span data-ttu-id="e3886-157">Без параметров потокобезопасности</span><span class="sxs-lookup"><span data-stu-id="e3886-157">No thread safety parameters</span></span>|  
|---------------------------------|---------------------------------------------|--------------------------------------|---------------------------------|  
|<span data-ttu-id="e3886-158">Полностью потокобезопасный; только один поток пытается инициализировать значение в определенный момент времени.</span><span class="sxs-lookup"><span data-stu-id="e3886-158">Fully thread-safe; only one thread at a time tries to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|<span data-ttu-id="e3886-159">Да.</span><span class="sxs-lookup"><span data-stu-id="e3886-159">Yes.</span></span>|  
|<span data-ttu-id="e3886-160">Не является потокобезопасным.</span><span class="sxs-lookup"><span data-stu-id="e3886-160">Not thread-safe.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|<span data-ttu-id="e3886-161">Неприменимо.</span><span class="sxs-lookup"><span data-stu-id="e3886-161">Not applicable.</span></span>|  
|<span data-ttu-id="e3886-162">Полностью потокобезопасный; потоки состязаются за право инициализации значения.</span><span class="sxs-lookup"><span data-stu-id="e3886-162">Fully thread-safe; threads race to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|<span data-ttu-id="e3886-163">Неприменимо.</span><span class="sxs-lookup"><span data-stu-id="e3886-163">Not applicable.</span></span>|<span data-ttu-id="e3886-164">Неприменимо.</span><span class="sxs-lookup"><span data-stu-id="e3886-164">Not applicable.</span></span>|  
  
 <span data-ttu-id="e3886-165">Как показано в таблице, указание <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> для параметра `mode` равносильно указанию `true` для параметра `isThreadSafe`, а указание <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> равносильно указанию `false`.</span><span class="sxs-lookup"><span data-stu-id="e3886-165">As the table shows, specifying <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> for the `mode` parameter is the same as specifying `true` for the `isThreadSafe` parameter, and specifying <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> is the same as specifying `false`.</span></span>  
  
 <span data-ttu-id="e3886-166">При указании <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> допускается, чтобы несколько потоков пытались инициализировать экземпляр <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="e3886-166">Specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> allows multiple threads to attempt to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="e3886-167">Только один поток может выиграть это состязание, и все другие потоки получают значение, которое было инициализировано успешным потоком.</span><span class="sxs-lookup"><span data-stu-id="e3886-167">Only one thread can win this race, and all the other threads receive the value that was initialized by the successful thread.</span></span> <span data-ttu-id="e3886-168">Если во время инициализации в потоке создается исключение, этот поток не получает значение, установленное успешным потоком.</span><span class="sxs-lookup"><span data-stu-id="e3886-168">If an exception is thrown on a thread during initialization, that thread does not receive the value set by the successful thread.</span></span> <span data-ttu-id="e3886-169">Исключения не кэшируются, поэтому повторная попытка доступа к свойству <xref:System.Lazy%601.Value%2A> может привести к успешной инициализации.</span><span class="sxs-lookup"><span data-stu-id="e3886-169">Exceptions are not cached, so a subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property can result in successful initialization.</span></span> <span data-ttu-id="e3886-170">Это отличается от способа обработки исключений в других режимах, которые описаны в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="e3886-170">This differs from the way exceptions are treated in other modes, which is described in the following section.</span></span> <span data-ttu-id="e3886-171">Дополнительные сведения см. в описании перечисления <xref:System.Threading.LazyThreadSafetyMode>.</span><span class="sxs-lookup"><span data-stu-id="e3886-171">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
<a name="ExceptionsInLazyObjects"></a>
## <a name="exceptions-in-lazy-objects"></a><span data-ttu-id="e3886-172">Исключения в объектах с отложенной инициализацией</span><span class="sxs-lookup"><span data-stu-id="e3886-172">Exceptions in Lazy Objects</span></span>  
 <span data-ttu-id="e3886-173">Как упоминалось выше, объект <xref:System.Lazy%601> всегда возвращает тот же объект или то же значение, которые использовались для его инициализации, следовательно, свойство <xref:System.Lazy%601.Value%2A> доступно только для чтения.</span><span class="sxs-lookup"><span data-stu-id="e3886-173">As stated earlier, a <xref:System.Lazy%601> object always returns the same object or value that it was initialized with, and therefore the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="e3886-174">Если включено кэширование исключений, эта неизменность также распространяется на поведение исключений.</span><span class="sxs-lookup"><span data-stu-id="e3886-174">If you enable exception caching, this immutability also extends to exception behavior.</span></span> <span data-ttu-id="e3886-175">Если объект с отложенной инициализацией включает кэширование исключений и создает исключение из метода инициализации при <xref:System.Lazy%601.Value%2A> первом обращении к свойству, то это же исключение создается при каждой последующей попытке доступа к <xref:System.Lazy%601.Value%2A> свойству.</span><span class="sxs-lookup"><span data-stu-id="e3886-175">If a lazy-initialized object has exception caching enabled and throws an exception from its initialization method when the <xref:System.Lazy%601.Value%2A> property is first accessed, that same exception is thrown on every subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property.</span></span> <span data-ttu-id="e3886-176">Другими словами, конструктор заключенного в оболочку типа никогда не вызывается повторно даже в сценариях с несколькими потоками.</span><span class="sxs-lookup"><span data-stu-id="e3886-176">In other words, the constructor of the wrapped type is never re-invoked, even in multithreaded scenarios.</span></span> <span data-ttu-id="e3886-177">Следовательно, объект <xref:System.Lazy%601> не может создавать исключение при одной попытке доступа и возвращать значение при последующих попытках доступа.</span><span class="sxs-lookup"><span data-stu-id="e3886-177">Therefore, the <xref:System.Lazy%601> object cannot throw an exception on one access and return a value on a subsequent access.</span></span>  
  
 <span data-ttu-id="e3886-178">Кэширование исключений включено, если используется какой-либо конструктор <xref:System.Lazy%601?displayProperty=nameWithType>, принимающий метод инициализации (параметр `valueFactory`); например, оно включено при использовании конструктора `Lazy(T)(Func(T))`.</span><span class="sxs-lookup"><span data-stu-id="e3886-178">Exception caching is enabled when you use any <xref:System.Lazy%601?displayProperty=nameWithType> constructor that takes an initialization method (`valueFactory` parameter); for example, it is enabled when you use the `Lazy(T)(Func(T))`constructor.</span></span> <span data-ttu-id="e3886-179">Если конструктор также принимает значение <xref:System.Threading.LazyThreadSafetyMode> (параметр `mode`), укажите <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> или <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e3886-179">If the constructor also takes a <xref:System.Threading.LazyThreadSafetyMode> value (`mode` parameter), specify <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> or <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e3886-180">Указание метода инициализации включает кэширование исключений для этих двух режимов.</span><span class="sxs-lookup"><span data-stu-id="e3886-180">Specifying an initialization method enables exception caching for these two modes.</span></span> <span data-ttu-id="e3886-181">Метод инициализации может быть очень простым.</span><span class="sxs-lookup"><span data-stu-id="e3886-181">The initialization method can be very simple.</span></span> <span data-ttu-id="e3886-182">Например, он может вызвать конструктор без параметров для `T` : `new Lazy<Contents>(() => new Contents(), mode)` в C# или `New Lazy(Of Contents)(Function() New Contents())` в Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="e3886-182">For example, it might call the parameterless constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic.</span></span> <span data-ttu-id="e3886-183">Если вы используете конструктор <xref:System.Lazy%601?displayProperty=nameWithType>, который не указывает метод инициализации, исключения, вызываемые конструктором без параметров для `T`, не кэшируются.</span><span class="sxs-lookup"><span data-stu-id="e3886-183">If you use a <xref:System.Lazy%601?displayProperty=nameWithType> constructor that does not specify an initialization method, exceptions that are thrown by the parameterless constructor for `T` are not cached.</span></span> <span data-ttu-id="e3886-184">Дополнительные сведения см. в описании перечисления <xref:System.Threading.LazyThreadSafetyMode>.</span><span class="sxs-lookup"><span data-stu-id="e3886-184">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e3886-185">Если создается объект <xref:System.Lazy%601> с параметром конструктора `isThreadSafe`, установленным в значение `false`, или с параметром конструктора `mode`, установленным в значение <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, обращаться к объекту <xref:System.Lazy%601> необходимо из одного потока или обеспечить свою собственную синхронизацию.</span><span class="sxs-lookup"><span data-stu-id="e3886-185">If you create a <xref:System.Lazy%601> object with the `isThreadSafe` constructor parameter set to `false` or the `mode` constructor parameter set to <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, you must access the <xref:System.Lazy%601> object from a single thread or provide your own synchronization.</span></span> <span data-ttu-id="e3886-186">Это относится ко всем аспектам объекта, включая кэширование исключений.</span><span class="sxs-lookup"><span data-stu-id="e3886-186">This applies to all aspects of the object, including exception caching.</span></span>  
  
 <span data-ttu-id="e3886-187">Как отмечалось в предыдущем разделе, объекты <xref:System.Lazy%601>, созданные путем указания <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, обрабатывают исключения иначе.</span><span class="sxs-lookup"><span data-stu-id="e3886-187">As noted in the previous section, <xref:System.Lazy%601> objects created by specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> treat exceptions differently.</span></span> <span data-ttu-id="e3886-188">В случае с <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly> за инициализацию экземпляра <xref:System.Lazy%601> могут конкурировать несколько потоков.</span><span class="sxs-lookup"><span data-stu-id="e3886-188">With <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, multiple threads can compete to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="e3886-189">В этом случае исключения не кэшируются, и попытки доступа к свойству <xref:System.Lazy%601.Value%2A> могут продолжаться до успешной инициализации.</span><span class="sxs-lookup"><span data-stu-id="e3886-189">In this case, exceptions are not cached, and attempts to access the <xref:System.Lazy%601.Value%2A> property can continue until initialization is successful.</span></span>  
  
 <span data-ttu-id="e3886-190">В приведенной ниже таблице описывается способ, которым конструкторы <xref:System.Lazy%601> управляют кэшированием исключений.</span><span class="sxs-lookup"><span data-stu-id="e3886-190">The following table summarizes the way the <xref:System.Lazy%601> constructors control exception caching.</span></span>  
  
|<span data-ttu-id="e3886-191">Конструктор</span><span class="sxs-lookup"><span data-stu-id="e3886-191">Constructor</span></span>|<span data-ttu-id="e3886-192">Потокобезопасный режим</span><span class="sxs-lookup"><span data-stu-id="e3886-192">Thread safety mode</span></span>|<span data-ttu-id="e3886-193">Использует метод инициализации</span><span class="sxs-lookup"><span data-stu-id="e3886-193">Uses initialization method</span></span>|<span data-ttu-id="e3886-194">Исключения кэшируются</span><span class="sxs-lookup"><span data-stu-id="e3886-194">Exceptions are cached</span></span>|  
|-----------------|------------------------|--------------------------------|---------------------------|  
|<span data-ttu-id="e3886-195">Lazy(T)()</span><span class="sxs-lookup"><span data-stu-id="e3886-195">Lazy(T)()</span></span>|<span data-ttu-id="e3886-196">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="e3886-196">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="e3886-197">нет</span><span class="sxs-lookup"><span data-stu-id="e3886-197">No</span></span>|<span data-ttu-id="e3886-198">нет</span><span class="sxs-lookup"><span data-stu-id="e3886-198">No</span></span>|  
|<span data-ttu-id="e3886-199">Lazy(T)(Func(T))</span><span class="sxs-lookup"><span data-stu-id="e3886-199">Lazy(T)(Func(T))</span></span>|<span data-ttu-id="e3886-200">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="e3886-200">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="e3886-201">Да</span><span class="sxs-lookup"><span data-stu-id="e3886-201">Yes</span></span>|<span data-ttu-id="e3886-202">Да</span><span class="sxs-lookup"><span data-stu-id="e3886-202">Yes</span></span>|  
|<span data-ttu-id="e3886-203">Lazy(T)(Boolean)</span><span class="sxs-lookup"><span data-stu-id="e3886-203">Lazy(T)(Boolean)</span></span>|<span data-ttu-id="e3886-204">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) или `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="e3886-204">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="e3886-205">нет</span><span class="sxs-lookup"><span data-stu-id="e3886-205">No</span></span>|<span data-ttu-id="e3886-206">нет</span><span class="sxs-lookup"><span data-stu-id="e3886-206">No</span></span>|  
|<span data-ttu-id="e3886-207">Lazy(T)(Func(T), Boolean)</span><span class="sxs-lookup"><span data-stu-id="e3886-207">Lazy(T)(Func(T), Boolean)</span></span>|<span data-ttu-id="e3886-208">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) или `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="e3886-208">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="e3886-209">Да</span><span class="sxs-lookup"><span data-stu-id="e3886-209">Yes</span></span>|<span data-ttu-id="e3886-210">Да</span><span class="sxs-lookup"><span data-stu-id="e3886-210">Yes</span></span>|  
|<span data-ttu-id="e3886-211">Lazy(T)(LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="e3886-211">Lazy(T)(LazyThreadSafetyMode)</span></span>|<span data-ttu-id="e3886-212">Указывается пользователем</span><span class="sxs-lookup"><span data-stu-id="e3886-212">User-specified</span></span>|<span data-ttu-id="e3886-213">нет</span><span class="sxs-lookup"><span data-stu-id="e3886-213">No</span></span>|<span data-ttu-id="e3886-214">нет</span><span class="sxs-lookup"><span data-stu-id="e3886-214">No</span></span>|  
|<span data-ttu-id="e3886-215">Lazy(T)(Func(T), LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="e3886-215">Lazy(T)(Func(T), LazyThreadSafetyMode)</span></span>|<span data-ttu-id="e3886-216">Указывается пользователем</span><span class="sxs-lookup"><span data-stu-id="e3886-216">User-specified</span></span>|<span data-ttu-id="e3886-217">Да</span><span class="sxs-lookup"><span data-stu-id="e3886-217">Yes</span></span>|<span data-ttu-id="e3886-218">Нет, если пользователь задает <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; в остальных случаях — да.</span><span class="sxs-lookup"><span data-stu-id="e3886-218">No if user specifies <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; otherwise, yes.</span></span>|  
  
## <a name="implementing-a-lazy-initialized-property"></a><span data-ttu-id="e3886-219">Реализация свойства с отложенной инициализацией</span><span class="sxs-lookup"><span data-stu-id="e3886-219">Implementing a Lazy-Initialized Property</span></span>  
 <span data-ttu-id="e3886-220">Для реализации открытого свойства с помощью отложенной инициализации определите резервное поле свойства как <xref:System.Lazy%601> и верните свойство <xref:System.Lazy%601.Value%2A> из метода доступа `get` этого свойства.</span><span class="sxs-lookup"><span data-stu-id="e3886-220">To implement a public property by using lazy initialization, define the backing field of the property as a <xref:System.Lazy%601>, and return the <xref:System.Lazy%601.Value%2A> property from the `get` accessor of the property.</span></span>  
  
 [!code-csharp[Lazy#5](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#5)]
 [!code-vb[Lazy#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#5)]  
  
 <span data-ttu-id="e3886-221">Свойство <xref:System.Lazy%601.Value%2A> доступно только для чтения, следовательно, у свойства, предоставляющего его, нет метода доступа `set`.</span><span class="sxs-lookup"><span data-stu-id="e3886-221">The <xref:System.Lazy%601.Value%2A> property is read-only; therefore, the property that exposes it has no `set` accessor.</span></span> <span data-ttu-id="e3886-222">Если требуется свойство для чтения и записи, резервируемое объектом <xref:System.Lazy%601>, метод доступа `set` должен создать объект <xref:System.Lazy%601> и присвоить его резервному хранилищу.</span><span class="sxs-lookup"><span data-stu-id="e3886-222">If you require a read/write property backed by a <xref:System.Lazy%601> object, the `set` accessor must create a new <xref:System.Lazy%601> object and assign it to the backing store.</span></span> <span data-ttu-id="e3886-223">Метод доступа `set` должен создать лямбда-выражение, возвращающее новое значение свойства, которое было передано методу доступа `set`, и передать это лямбда-выражение конструктору нового объекта <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="e3886-223">The `set` accessor must create a lambda expression that returns the new property value that was passed to the `set` accessor, and pass that lambda expression to the constructor for the new <xref:System.Lazy%601> object.</span></span> <span data-ttu-id="e3886-224">Следующее обращение к свойству <xref:System.Lazy%601.Value%2A> вызовет инициализацию нового объекта <xref:System.Lazy%601>, и его свойство <xref:System.Lazy%601.Value%2A> после этого будет возвращать новое значение, присвоенное этому свойству.</span><span class="sxs-lookup"><span data-stu-id="e3886-224">The next access of the <xref:System.Lazy%601.Value%2A> property will cause initialization of the new <xref:System.Lazy%601>, and its <xref:System.Lazy%601.Value%2A> property will thereafter return the new value that was assigned to the property.</span></span> <span data-ttu-id="e3886-225">Эта сложная структура требуется для сохранения средств защиты многопоточности, встроенных в <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="e3886-225">The reason for this convoluted arrangement is to preserve the multithreading protections built into <xref:System.Lazy%601>.</span></span> <span data-ttu-id="e3886-226">В противном случае методам доступа к свойству пришлось бы кэшировать первое значение, возвращаемое свойством <xref:System.Lazy%601.Value%2A>, и изменять только кэшированное значение, а вам пришлось бы писать для этого собственный потокобезопасный код.</span><span class="sxs-lookup"><span data-stu-id="e3886-226">Otherwise, the property accessors would have to cache the first value returned by the <xref:System.Lazy%601.Value%2A> property and only modify the cached value, and you would have to write your own thread-safe code to do that.</span></span> <span data-ttu-id="e3886-227">Из-за дополнительных инициализаций, необходимых для свойства чтения и записи, резервируемого объектом <xref:System.Lazy%601>, производительность может стать неприемлемой.</span><span class="sxs-lookup"><span data-stu-id="e3886-227">Because of the additional initializations required by a read/write property backed by a <xref:System.Lazy%601> object, the performance might not be acceptable.</span></span> <span data-ttu-id="e3886-228">Более того, в зависимости от конкретного сценария может потребоваться дополнительная координация, чтобы избежать состояний гонки между методами задания и получения значений.</span><span class="sxs-lookup"><span data-stu-id="e3886-228">Furthermore, depending on the specific scenario, additional coordination might be required to avoid race conditions between setters and getters.</span></span>  
  
## <a name="thread-local-lazy-initialization"></a><span data-ttu-id="e3886-229">Локальная по отношению к потоку отложенная инициализация</span><span class="sxs-lookup"><span data-stu-id="e3886-229">Thread-Local Lazy Initialization</span></span>  
 <span data-ttu-id="e3886-230">В некоторых сценариях с несколькими потоками может понадобиться, чтобы каждый поток работал со своими собственными закрытыми данными.</span><span class="sxs-lookup"><span data-stu-id="e3886-230">In some multithreaded scenarios, you might want to give each thread its own private data.</span></span> <span data-ttu-id="e3886-231">Такие данные называются *локальными по отношению к потоку*.</span><span class="sxs-lookup"><span data-stu-id="e3886-231">Such data is called *thread-local data*.</span></span> <span data-ttu-id="e3886-232">В .NET Framework версии 3.5 и предыдущих версий можно было применить к статической переменной атрибут `ThreadStatic`, чтобы сделать ее локальной по отношению к потоку.</span><span class="sxs-lookup"><span data-stu-id="e3886-232">In the .NET Framework version 3.5 and earlier, you could apply the `ThreadStatic` attribute to a static variable to make it thread-local.</span></span> <span data-ttu-id="e3886-233">Однако использование атрибута `ThreadStatic` может привести к скрытым ошибкам.</span><span class="sxs-lookup"><span data-stu-id="e3886-233">However, using the `ThreadStatic` attribute can lead to subtle errors.</span></span> <span data-ttu-id="e3886-234">Например, даже основные операторы инициализации могут привести к инициализации переменной только для первого обратившегося к ней потока, как показано в приведенном ниже примере.</span><span class="sxs-lookup"><span data-stu-id="e3886-234">For example, even basic initialization statements will cause the variable to be initialized only on the first thread that accesses it, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#6](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#6)]
 [!code-vb[Lazy#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#6)]  
  
 <span data-ttu-id="e3886-235">Во всех остальных потоках переменная будет инициализирована своим значением по умолчанию (нулем).</span><span class="sxs-lookup"><span data-stu-id="e3886-235">On all other threads, the variable will be initialized by using its default value (zero).</span></span> <span data-ttu-id="e3886-236">В качестве альтернативы в .NET Framework версии 4 можно использовать тип <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType>, чтобы создать локальную по отношению к потоку переменную на основе экземпляра, инициализируемую во всех потоках с помощью предоставленного вами делегата <xref:System.Action%601>.</span><span class="sxs-lookup"><span data-stu-id="e3886-236">As an alternative in the .NET Framework version 4, you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> type to create an instance-based, thread-local variable that is initialized on all threads by the <xref:System.Action%601> delegate that you provide.</span></span> <span data-ttu-id="e3886-237">В приведенном ниже примере во всех потоках, обращающихся к счетчику `counter`, начальное значение этого счетчика будет равно 1.</span><span class="sxs-lookup"><span data-stu-id="e3886-237">In the following example, all threads that access `counter` will see its starting value as 1.</span></span>  
  
 [!code-csharp[Lazy#7](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#7)]
 [!code-vb[Lazy#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#7)]  
  
 <span data-ttu-id="e3886-238"><xref:System.Threading.ThreadLocal%601> заключает свой объект в оболочку в основном так же, как и <xref:System.Lazy%601>, с перечисленными ниже важными различиями.</span><span class="sxs-lookup"><span data-stu-id="e3886-238"><xref:System.Threading.ThreadLocal%601> wraps its object in much the same way as <xref:System.Lazy%601>, with these essential differences:</span></span>  
  
- <span data-ttu-id="e3886-239">Каждый поток инициализирует локальную по отношению к потоку переменную, используя собственные закрытые данные, недоступные другим потокам.</span><span class="sxs-lookup"><span data-stu-id="e3886-239">Each thread initializes the thread-local variable by using its own private data that is not accessible from other threads.</span></span>  
  
- <span data-ttu-id="e3886-240">Свойство <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> доступно для чтения и записи и может быть изменено любое количество раз.</span><span class="sxs-lookup"><span data-stu-id="e3886-240">The <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> property is read-write, and can be modified any number of times.</span></span> <span data-ttu-id="e3886-241">Это может повлиять на распространение исключений. Так, одна операция `get` может создать исключение, а следующая — успешно инициализировать значение.</span><span class="sxs-lookup"><span data-stu-id="e3886-241">This can affect exception propagation, for example, one `get` operation can raise an exception but the next one can successfully initialize the value.</span></span>  
  
- <span data-ttu-id="e3886-242">Если делегат для инициализации не предоставлен, <xref:System.Threading.ThreadLocal%601> будет инициализировать соответствующий заключенный в оболочку тип, используя значение по умолчанию для этого типа.</span><span class="sxs-lookup"><span data-stu-id="e3886-242">If no initialization delegate is provided, <xref:System.Threading.ThreadLocal%601> will initialize its wrapped type by using the default value of the type.</span></span> <span data-ttu-id="e3886-243">В этом отношении <xref:System.Threading.ThreadLocal%601> согласуется с атрибутом <xref:System.ThreadStaticAttribute>.</span><span class="sxs-lookup"><span data-stu-id="e3886-243">In this regard, <xref:System.Threading.ThreadLocal%601> is consistent with the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
 <span data-ttu-id="e3886-244">В приведенном ниже примере показано, как каждый поток, обращающийся к экземпляру `ThreadLocal<int>`, получает собственную уникальную копию данных.</span><span class="sxs-lookup"><span data-stu-id="e3886-244">The following example demonstrates that every thread that accesses the `ThreadLocal<int>` instance gets its own unique copy of the data.</span></span>  
  
 [!code-csharp[Lazy#9](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#9)]
 [!code-vb[Lazy#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#9)]  
  
## <a name="thread-local-variables-in-parallelfor-and-foreach"></a><span data-ttu-id="e3886-245">Локальные по отношению к потоку переменные в методах Parallel.For и ForEach</span><span class="sxs-lookup"><span data-stu-id="e3886-245">Thread-Local Variables in Parallel.For and ForEach</span></span>  
 <span data-ttu-id="e3886-246">При использовании метода <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> или метода <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> для параллельной итерации источников данных можно применить перегруженные версии со встроенной поддержкой локальных по отношению к потоку данных.</span><span class="sxs-lookup"><span data-stu-id="e3886-246">When you use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method or <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to iterate over data sources in parallel, you can use the overloads that have built-in support for thread-local data.</span></span> <span data-ttu-id="e3886-247">В этих методах локальность по отношению к потоку достигается с помощью локальных делегатов, используемых для создания данных, доступа к ним и их очистки.</span><span class="sxs-lookup"><span data-stu-id="e3886-247">In these methods, the thread-locality is achieved by using local delegates to create, access, and clean up the data.</span></span> <span data-ttu-id="e3886-248">Дополнительные сведения см. в разделах [Практическое руководство. Написание цикла Parallel.For с локальными переменными потока](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) и [Практическое руководство. Написание цикла Parallel.ForEach с локальными переменными раздела](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="e3886-248">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Partition-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span></span>  
  
## <a name="using-lazy-initialization-for-low-overhead-scenarios"></a><span data-ttu-id="e3886-249">Использование отложенной инициализации для сценариев с низкими издержками</span><span class="sxs-lookup"><span data-stu-id="e3886-249">Using Lazy Initialization for Low-Overhead Scenarios</span></span>  
 <span data-ttu-id="e3886-250">Если необходимо использовать отложенную инициализацию для большого числа объектов, может оказаться, что заключение каждого объекта в оболочку <xref:System.Lazy%601> требует слишком много памяти или вычислительных ресурсов.</span><span class="sxs-lookup"><span data-stu-id="e3886-250">In scenarios where you have to lazy-initialize a large number of objects, you might decide that wrapping each object in a <xref:System.Lazy%601> requires too much memory or too many computing resources.</span></span> <span data-ttu-id="e3886-251">Либо могут предъявляться строгие требования к предоставлению отложенной инициализации.</span><span class="sxs-lookup"><span data-stu-id="e3886-251">Or, you might have stringent requirements about how lazy initialization is exposed.</span></span> <span data-ttu-id="e3886-252">В таких случаях можно использовать методы `static` (`Shared` в Visual Basic) класса <xref:System.Threading.LazyInitializer?displayProperty=nameWithType>, чтобы выполнить отложенную инициализацию каждого объекта, не заключая его в экземпляр <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="e3886-252">In such cases, you can use the `static` (`Shared` in Visual Basic) methods of the <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> class to lazy-initialize each object without wrapping it in an instance of <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="e3886-253">В приведенном ниже примере предполагается, что вместо заключения в оболочку всего объекта `Orders` в одном объекте <xref:System.Lazy%601> выполняется отложенная инициализация отдельных объектов `Order` только в случае их необходимости.</span><span class="sxs-lookup"><span data-stu-id="e3886-253">In the following example, assume that, instead of wrapping an entire `Orders` object in one <xref:System.Lazy%601> object, you have lazy-initialized individual `Order` objects only if they are required.</span></span>  
  
 [!code-csharp[Lazy#10](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#10)]
 [!code-vb[Lazy#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#10)]  
  
 <span data-ttu-id="e3886-254">В этом примере обратите внимание на то, что процедура инициализации вызывается для каждой итерации цикла.</span><span class="sxs-lookup"><span data-stu-id="e3886-254">In this example, notice that the initialization procedure is invoked on every iteration of the loop.</span></span> <span data-ttu-id="e3886-255">В сценариях с несколькими потоками первый поток, вызывающий процедуру инициализации, определяет значение, которое будет доступно всем потокам.</span><span class="sxs-lookup"><span data-stu-id="e3886-255">In multi-threaded scenarios, the first thread to invoke the initialization procedure is the one whose value is seen by all threads.</span></span> <span data-ttu-id="e3886-256">Последующие потоки также вызывают процедуру инициализации, но их результаты не используются.</span><span class="sxs-lookup"><span data-stu-id="e3886-256">Later threads also invoke the initialization procedure, but their results are not used.</span></span> <span data-ttu-id="e3886-257">Если этот вид возможного состояния гонки является недопустимым, используйте перегруженную версию типа <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType>, которой передается логический аргумент и объект синхронизации.</span><span class="sxs-lookup"><span data-stu-id="e3886-257">If this kind of potential race condition is not acceptable, use the overload of <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> that takes a Boolean argument and a synchronization object.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e3886-258">См. также раздел</span><span class="sxs-lookup"><span data-stu-id="e3886-258">See also</span></span>

- [<span data-ttu-id="e3886-259">Основы управляемых потоков</span><span class="sxs-lookup"><span data-stu-id="e3886-259">Managed Threading Basics</span></span>](../../standard/threading/managed-threading-basics.md)
- [<span data-ttu-id="e3886-260">Потоки и работа с потоками</span><span class="sxs-lookup"><span data-stu-id="e3886-260">Threads and Threading</span></span>](../../standard/threading/threads-and-threading.md)
- [<span data-ttu-id="e3886-261">Библиотека параллельных задач (TPL)</span><span class="sxs-lookup"><span data-stu-id="e3886-261">Task Parallel Library (TPL)</span></span>](../../standard/parallel-programming/task-parallel-library-tpl.md)
- [<span data-ttu-id="e3886-262">Практическое руководство. Неактивная инициализация объектов</span><span class="sxs-lookup"><span data-stu-id="e3886-262">How to: Perform Lazy Initialization of Objects</span></span>](how-to-perform-lazy-initialization-of-objects.md)
