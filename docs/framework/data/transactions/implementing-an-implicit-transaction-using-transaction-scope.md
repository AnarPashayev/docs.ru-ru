---
title: Реализация неявной транзакции с использованием области транзакции
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 49d1706a-1e0c-4c85-9704-75c908372eb9
ms.openlocfilehash: 33b51cf26a35bbdda70582d86db6ac39c22597da
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79174398"
---
# <a name="implementing-an-implicit-transaction-using-transaction-scope"></a><span data-ttu-id="f1582-102">Реализация неявной транзакции с использованием области транзакции</span><span class="sxs-lookup"><span data-stu-id="f1582-102">Implementing an Implicit Transaction using Transaction Scope</span></span>
<span data-ttu-id="f1582-103">Класс <xref:System.Transactions.TransactionScope> предоставляет простой способ пометки блока кода как участвующего в транзакции без необходимости взаимодействия с самой транзакцией.</span><span class="sxs-lookup"><span data-stu-id="f1582-103">The <xref:System.Transactions.TransactionScope> class provides a simple way to mark a block of code as participating in a transaction, without requiring you to interact with the transaction itself.</span></span> <span data-ttu-id="f1582-104">Область транзакции может автоматически выбирать внешнюю транзакцию и управлять ей.</span><span class="sxs-lookup"><span data-stu-id="f1582-104">A transaction scope can select and manage the ambient transaction automatically.</span></span> <span data-ttu-id="f1582-105">В целях обеспечения простоты использования и эффективности при разработке транзакционного приложения рекомендуется использовать класс <xref:System.Transactions.TransactionScope>.</span><span class="sxs-lookup"><span data-stu-id="f1582-105">Due to its ease of use and efficiency, it is recommended that you use the <xref:System.Transactions.TransactionScope> class when developing a transaction application.</span></span>  
  
 <span data-ttu-id="f1582-106">Кроме того, явно зачислять ресурсы в транзакцию не требуется.</span><span class="sxs-lookup"><span data-stu-id="f1582-106">In addition, you do not need to enlist resources explicitly with the transaction.</span></span> <span data-ttu-id="f1582-107">Любой диспетчер ресурсов <xref:System.Transactions> (например SQL Server 2005) может обнаружить существование внешней транзакции, созданной областью, и автоматически зачислиться в эту транзакцию.</span><span class="sxs-lookup"><span data-stu-id="f1582-107">Any <xref:System.Transactions> resource manager (such as SQL Server 2005) can detect the existence of an ambient transaction created by the scope and automatically enlist.</span></span>  
  
## <a name="creating-a-transaction-scope"></a><span data-ttu-id="f1582-108">Создание области транзакции</span><span class="sxs-lookup"><span data-stu-id="f1582-108">Creating a transaction scope</span></span>  
 <span data-ttu-id="f1582-109">Ниже представлен простой пример использования класса <xref:System.Transactions.TransactionScope>.</span><span class="sxs-lookup"><span data-stu-id="f1582-109">The following sample shows a simple usage of the <xref:System.Transactions.TransactionScope> class.</span></span>  
  
 [!code-csharp[TransactionScope#1](../../../../samples/snippets/csharp/VS_Snippets_Remoting/TransactionScope/cs/ScopeWithSQL.cs#1)]
 [!code-vb[TransactionScope#1](../../../../samples/snippets/visualbasic/VS_Snippets_Remoting/TransactionScope/vb/ScopeWithSQL.vb#1)]  
  
 <span data-ttu-id="f1582-110">Область транзакций запускается после <xref:System.Transactions.TransactionScope> создания нового объекта.</span><span class="sxs-lookup"><span data-stu-id="f1582-110">The transaction scope is started once you create a new <xref:System.Transactions.TransactionScope> object.</span></span>  <span data-ttu-id="f1582-111">Как показано в примере кода, рекомендуется создавать области `using` с помощью оператора.</span><span class="sxs-lookup"><span data-stu-id="f1582-111">As illustrated in the code sample, it is recommended that you create scopes with a `using` statement.</span></span> <span data-ttu-id="f1582-112">Заявление `using` доступно как в СИ, так и в `try`Visual Basic, и работает как ... `finally` блок, чтобы убедиться, что область удаляется должным образом.</span><span class="sxs-lookup"><span data-stu-id="f1582-112">The `using` statement is available both in C# and in Visual Basic, and works like a `try`...`finally` block to ensure that the scope is disposed of properly.</span></span>  
  
 <span data-ttu-id="f1582-113">При создании экземпляра <xref:System.Transactions.TransactionScope> диспетчер транзакций определяет, в какой транзакции следует участвовать.</span><span class="sxs-lookup"><span data-stu-id="f1582-113">When you instantiate <xref:System.Transactions.TransactionScope>, the transaction manager determines which transaction to participate in.</span></span> <span data-ttu-id="f1582-114">После определения область всегда участвует в этой транзакции.</span><span class="sxs-lookup"><span data-stu-id="f1582-114">Once determined, the scope always participates in that transaction.</span></span> <span data-ttu-id="f1582-115">Решение принимается на основе двух факторов: значения параметра `TransactionScopeOption` в конструкторе и наличия внешней транзакции.</span><span class="sxs-lookup"><span data-stu-id="f1582-115">The decision is based on two factors: whether an ambient transaction is present and the value of the `TransactionScopeOption` parameter in the constructor.</span></span> <span data-ttu-id="f1582-116">Внешняя транзакция - это транзакция, в рамках которой выполняется ваш код.</span><span class="sxs-lookup"><span data-stu-id="f1582-116">The ambient transaction is the transaction within which your code executes.</span></span> <span data-ttu-id="f1582-117">Ссылку на внешнюю транзакцию можно получить, вызвав статическое свойство <xref:System.Transactions.Transaction.Current%2A?displayProperty=nameWithType> класса <xref:System.Transactions.Transaction>.</span><span class="sxs-lookup"><span data-stu-id="f1582-117">You can obtain a reference to the ambient transaction by calling the static <xref:System.Transactions.Transaction.Current%2A?displayProperty=nameWithType> property of the <xref:System.Transactions.Transaction> class.</span></span> <span data-ttu-id="f1582-118">Для получения дополнительной информации о том, как этот параметр используется, [см.](#ManageTxFlow)</span><span class="sxs-lookup"><span data-stu-id="f1582-118">For more information on how this parameter is used, see the [Managing transaction flow using TransactionScopeOption](#ManageTxFlow) section of this topic.</span></span>  
  
## <a name="completing-a-transaction-scope"></a><span data-ttu-id="f1582-119">Завершение области транзакции</span><span class="sxs-lookup"><span data-stu-id="f1582-119">Completing a transaction scope</span></span>  
 <span data-ttu-id="f1582-120">Когда приложение завершает все операции, подлежащие выполнению в транзакции, следует вызвать метод <xref:System.Transactions.TransactionScope.Complete%2A?displayProperty=nameWIthType> только один раз, чтобы информировать диспетчер транзакций о возможности фиксации данной транзакции.</span><span class="sxs-lookup"><span data-stu-id="f1582-120">When your application completes all the work it wants to perform in a transaction, you should call the <xref:System.Transactions.TransactionScope.Complete%2A?displayProperty=nameWIthType> method only once to inform the transaction manager that it is acceptable to commit the transaction.</span></span> <span data-ttu-id="f1582-121">Это очень хорошая практика, <xref:System.Transactions.TransactionScope.Complete%2A> чтобы поставить вызов `using` в качестве последнего заявления в блоке.</span><span class="sxs-lookup"><span data-stu-id="f1582-121">It is very good practice to put the call to <xref:System.Transactions.TransactionScope.Complete%2A> as the last statement in the `using` block.</span></span>  
  
 <span data-ttu-id="f1582-122">Неспособность вызвать этот метод прерывает транзакцию, поскольку менеджер транзакции интерпретирует это как сбой системы или эквивалент новое исключение, выброшенное в область транзакции.</span><span class="sxs-lookup"><span data-stu-id="f1582-122">Failing to call this method aborts the transaction, because the transaction manager interprets this as a system failure, or equivalent to an exception thrown within the scope of the transaction.</span></span> <span data-ttu-id="f1582-123">Однако вызов этого метода не гарантирует, что транзакция будет зафиксирована.</span><span class="sxs-lookup"><span data-stu-id="f1582-123">However, calling this method does not guarantee that the transaction wil be committed.</span></span> <span data-ttu-id="f1582-124">Это просто способ информирования диспетчера транзакций о состоянии.</span><span class="sxs-lookup"><span data-stu-id="f1582-124">It is merely a way of informing the transaction manager of your status.</span></span> <span data-ttu-id="f1582-125">После вызова метода <xref:System.Transactions.TransactionScope.Complete%2A> доступ к внешней транзакции с помощью свойства <xref:System.Transactions.Transaction.Current%2A> невозможен. При попытке такого доступа возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="f1582-125">After calling the <xref:System.Transactions.TransactionScope.Complete%2A> method, you can no longer access the ambient transaction by using the <xref:System.Transactions.Transaction.Current%2A> property, and attempting to do so will result in an exception being thrown.</span></span>  
  
 <span data-ttu-id="f1582-126">Если <xref:System.Transactions.TransactionScope> объект создал транзакцию изначально, фактическая работа по совершению транзакции менеджером транзакции происходит после последней строки кода в блоке. `using`</span><span class="sxs-lookup"><span data-stu-id="f1582-126">If the <xref:System.Transactions.TransactionScope> object created the transaction initially, the actual work of committing the transaction by the transaction manager occurs after the last line of code in the `using` block.</span></span> <span data-ttu-id="f1582-127">Если транзакция создана не этим объектом, фиксация происходит при каждом вызове метода <xref:System.Transactions.CommittableTransaction.Commit%2A> владельцем объекта <xref:System.Transactions.CommittableTransaction>.</span><span class="sxs-lookup"><span data-stu-id="f1582-127">If it did not create the transaction, the commit occurs whenever <xref:System.Transactions.CommittableTransaction.Commit%2A> is called by the owner of the <xref:System.Transactions.CommittableTransaction> object.</span></span> <span data-ttu-id="f1582-128">В этот момент менеджер транзакций звонит менеджерам ресурсов и информирует их <xref:System.Transactions.TransactionScope.Complete%2A> о фиксации <xref:System.Transactions.TransactionScope> или откате, в зависимости от того, был ли метод вызван на объект.</span><span class="sxs-lookup"><span data-stu-id="f1582-128">At that point the transaction manager calls the resource managers and informs them to either commit or rollback, based on whether the <xref:System.Transactions.TransactionScope.Complete%2A> method was called on the <xref:System.Transactions.TransactionScope> object.</span></span>  
  
 <span data-ttu-id="f1582-129">Заявление `using` гарантирует, что <xref:System.Transactions.TransactionScope.Dispose%2A> метод <xref:System.Transactions.TransactionScope> объекта вызывается даже в случае возникновения исключения.</span><span class="sxs-lookup"><span data-stu-id="f1582-129">The `using` statement ensures that the <xref:System.Transactions.TransactionScope.Dispose%2A> method of the <xref:System.Transactions.TransactionScope> object is called even if an exception occurs.</span></span> <span data-ttu-id="f1582-130">Вызов метода <xref:System.Transactions.TransactionScope.Dispose%2A> отмечает конец области транзакции.</span><span class="sxs-lookup"><span data-stu-id="f1582-130">The <xref:System.Transactions.TransactionScope.Dispose%2A> method marks the end of the transaction scope.</span></span> <span data-ttu-id="f1582-131">Исключения, возникающие после вызова данного метода, могут не воздействовать на транзакцию.</span><span class="sxs-lookup"><span data-stu-id="f1582-131">Exceptions that occur after calling this method may not affect the transaction.</span></span> <span data-ttu-id="f1582-132">Данный метод также восстанавливает предыдущее состояние внешней транзакции.</span><span class="sxs-lookup"><span data-stu-id="f1582-132">This method also restores the ambient transaction to it previous state.</span></span>  
  
 <span data-ttu-id="f1582-133">Если область создает транзакцию и эта транзакция прерывается, возникает исключение <xref:System.Transactions.TransactionAbortedException>.</span><span class="sxs-lookup"><span data-stu-id="f1582-133">A <xref:System.Transactions.TransactionAbortedException> is thrown if the scope creates the transaction, and the transaction is aborted.</span></span> <span data-ttu-id="f1582-134">Если диспетчер транзакций не может принять решение о фиксации, возникает исключение <xref:System.Transactions.TransactionInDoubtException>.</span><span class="sxs-lookup"><span data-stu-id="f1582-134">A <xref:System.Transactions.TransactionInDoubtException> is thrown if the transaction manager cannot reach a Commit decision.</span></span> <span data-ttu-id="f1582-135">В случае фиксации транзакции исключения не возникают.</span><span class="sxs-lookup"><span data-stu-id="f1582-135">No exception is thrown if the transaction is committed.</span></span>  
  
## <a name="rolling-back-a-transaction"></a><span data-ttu-id="f1582-136">Откат транзакции</span><span class="sxs-lookup"><span data-stu-id="f1582-136">Rolling back a transaction</span></span>  
 <span data-ttu-id="f1582-137">Если требуется откатить транзакцию, не следует вызывать метод <xref:System.Transactions.TransactionScope.Complete%2A> в пределах области транзакции.</span><span class="sxs-lookup"><span data-stu-id="f1582-137">If you want to rollback a transaction, you should not call the <xref:System.Transactions.TransactionScope.Complete%2A> method within the transaction scope.</span></span> <span data-ttu-id="f1582-138">Например, можно вызвать исключение в пределах области.</span><span class="sxs-lookup"><span data-stu-id="f1582-138">For example, you can throw an exception within the scope.</span></span> <span data-ttu-id="f1582-139">При этом будет выполнен откат транзакции, в которой участвует область.</span><span class="sxs-lookup"><span data-stu-id="f1582-139">The transaction in which it participates in will be rolled back.</span></span>  
  
## <a name="managing-transaction-flow-using-transactionscopeoption"></a><a name="ManageTxFlow"></a><span data-ttu-id="f1582-140">Управление потоком транзакций с помощью TransactionScopeOption</span><span class="sxs-lookup"><span data-stu-id="f1582-140">Managing transaction flow using TransactionScopeOption</span></span>  
 <span data-ttu-id="f1582-141">Область транзакции можно сделать вложенной, вызвав метод, использующий объект <xref:System.Transactions.TransactionScope>, из метода, использующего собственную область, как в случае метода `RootMethod` в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="f1582-141">Transaction scope can be nested by calling a method that uses a <xref:System.Transactions.TransactionScope> from within a method that uses its own scope, as is the case with the `RootMethod` method in the following example,</span></span>  
  
```csharp  
void RootMethod()
{
    using(TransactionScope scope = new TransactionScope())
    {
        /* Perform transactional work here */
        SomeMethod();
        scope.Complete();
    }
}

void SomeMethod()
{
    using(TransactionScope scope = new TransactionScope())
    {
        /* Perform transactional work here */
        scope.Complete();
    }
}
```  
  
 <span data-ttu-id="f1582-142">Самая верхняя область транзакции называется корневой областью.</span><span class="sxs-lookup"><span data-stu-id="f1582-142">The top-most transaction scope is referred to as the root scope.</span></span>  
  
 <span data-ttu-id="f1582-143">Класс <xref:System.Transactions.TransactionScope> предоставляет несколько перегруженных конструкторов, принимающих перечисление <xref:System.Transactions.TransactionScopeOption>, которое определяет поведение области транзакции.</span><span class="sxs-lookup"><span data-stu-id="f1582-143">The <xref:System.Transactions.TransactionScope> class provides several overloaded constructors that accept an enumeration of the type <xref:System.Transactions.TransactionScopeOption>, which defines the transactional behavior of the scope.</span></span>  
  
 <span data-ttu-id="f1582-144">Предусмотрено три варианта поведения объекта <xref:System.Transactions.TransactionScope>:</span><span class="sxs-lookup"><span data-stu-id="f1582-144">A <xref:System.Transactions.TransactionScope> object has three options:</span></span>  
  
- <span data-ttu-id="f1582-145">присоединиться к внешней транзакции или создать новую транзакцию, если она не существует;</span><span class="sxs-lookup"><span data-stu-id="f1582-145">Join the ambient transaction, or create a new one if one does not exist.</span></span>  
  
- <span data-ttu-id="f1582-146">стать новой корневой областью, т. е. запустить новую транзакцию, представляющую собой новую внешнюю транзакцию внутри собственной области;</span><span class="sxs-lookup"><span data-stu-id="f1582-146">Be a new root scope, that is, start a new transaction and have that transaction be the new ambient transaction inside its own scope.</span></span>  
  
- <span data-ttu-id="f1582-147">не принимать участие в транзакции,</span><span class="sxs-lookup"><span data-stu-id="f1582-147">Not take part in a transaction at all.</span></span> <span data-ttu-id="f1582-148">в результате внешняя транзакция отсутствует.</span><span class="sxs-lookup"><span data-stu-id="f1582-148">There is no ambient transaction as a result.</span></span>  
  
 <span data-ttu-id="f1582-149">Если область создана со значением <xref:System.Transactions.TransactionScopeOption.Required> и внешняя транзакция существует, область присоединяется к этой транзакции.</span><span class="sxs-lookup"><span data-stu-id="f1582-149">If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.Required>, and an ambient transaction is present, the scope joins that transaction.</span></span> <span data-ttu-id="f1582-150">Если внешняя транзакция отсутствует, область создает новую транзакцию и становится корневой областью.</span><span class="sxs-lookup"><span data-stu-id="f1582-150">If, on the other hand, there is no ambient transaction, then the scope creates a new transaction, and become the root scope.</span></span> <span data-ttu-id="f1582-151">Это значение по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f1582-151">This is the default value.</span></span> <span data-ttu-id="f1582-152">В случае использования значения <xref:System.Transactions.TransactionScopeOption.Required> поведение кода, находящегося внутри области, должно быть одинаковым в обоих случаях: область является корневой или</span><span class="sxs-lookup"><span data-stu-id="f1582-152">When <xref:System.Transactions.TransactionScopeOption.Required> is used, the code inside the scope does not need to behave differently whether it is the root or just joining the ambient transaction.</span></span> <span data-ttu-id="f1582-153">область только присоединяется к транзакции.</span><span class="sxs-lookup"><span data-stu-id="f1582-153">It should operate identically in both cases.</span></span>  
  
 <span data-ttu-id="f1582-154">Если область создана со значением <xref:System.Transactions.TransactionScopeOption.RequiresNew>, она является корневой областью.</span><span class="sxs-lookup"><span data-stu-id="f1582-154">If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.RequiresNew>, it is always the root scope.</span></span> <span data-ttu-id="f1582-155">Область запускает новую транзакцию, которая становится новой внешней транзакцией внутри области.</span><span class="sxs-lookup"><span data-stu-id="f1582-155">It starts a new transaction, and its transaction becomes the new ambient transaction inside the scope.</span></span>  
  
 <span data-ttu-id="f1582-156">Если область создана со значением <xref:System.Transactions.TransactionScopeOption.Suppress>, она не принимает участие в транзакции независимо от существования внешней транзакции.</span><span class="sxs-lookup"><span data-stu-id="f1582-156">If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.Suppress>, it never takes part in a transaction, regardless of whether an ambient transaction is present.</span></span> <span data-ttu-id="f1582-157">Область, мгновенно связанная с этим `null` значением, всегда имеет в качестве своей транзакции.</span><span class="sxs-lookup"><span data-stu-id="f1582-157">A scope instantiated with this value always have `null` as its ambient transaction.</span></span>  
  
 <span data-ttu-id="f1582-158">Сводка рассмотренных выше значений представлена в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="f1582-158">The above options are summarized in the following table.</span></span>  
  
|<span data-ttu-id="f1582-159">TransactionScopeOption</span><span class="sxs-lookup"><span data-stu-id="f1582-159">TransactionScopeOption</span></span>|<span data-ttu-id="f1582-160">Внешняя транзакция</span><span class="sxs-lookup"><span data-stu-id="f1582-160">Ambient Transaction</span></span>|<span data-ttu-id="f1582-161">Транзакция, в которой участвует область</span><span class="sxs-lookup"><span data-stu-id="f1582-161">The scope takes part in</span></span>|  
|----------------------------|-------------------------|-----------------------------|  
|<span data-ttu-id="f1582-162">Обязательно</span><span class="sxs-lookup"><span data-stu-id="f1582-162">Required</span></span>|<span data-ttu-id="f1582-163">нет</span><span class="sxs-lookup"><span data-stu-id="f1582-163">No</span></span>|<span data-ttu-id="f1582-164">Новая транзакция (область станет корневой)</span><span class="sxs-lookup"><span data-stu-id="f1582-164">New Transaction (will be the root)</span></span>|  
|<span data-ttu-id="f1582-165">RequiresNew</span><span class="sxs-lookup"><span data-stu-id="f1582-165">Requires New</span></span>|<span data-ttu-id="f1582-166">нет</span><span class="sxs-lookup"><span data-stu-id="f1582-166">No</span></span>|<span data-ttu-id="f1582-167">Новая транзакция (область станет корневой)</span><span class="sxs-lookup"><span data-stu-id="f1582-167">New Transaction (will be the root)</span></span>|  
|<span data-ttu-id="f1582-168">Подавление</span><span class="sxs-lookup"><span data-stu-id="f1582-168">Suppress</span></span>|<span data-ttu-id="f1582-169">нет</span><span class="sxs-lookup"><span data-stu-id="f1582-169">No</span></span>|<span data-ttu-id="f1582-170">Транзакция отсутствует</span><span class="sxs-lookup"><span data-stu-id="f1582-170">No Transaction</span></span>|  
|<span data-ttu-id="f1582-171">Обязательно</span><span class="sxs-lookup"><span data-stu-id="f1582-171">Required</span></span>|<span data-ttu-id="f1582-172">Да</span><span class="sxs-lookup"><span data-stu-id="f1582-172">Yes</span></span>|<span data-ttu-id="f1582-173">Внешняя транзакция</span><span class="sxs-lookup"><span data-stu-id="f1582-173">Ambient  Transaction</span></span>|  
|<span data-ttu-id="f1582-174">RequiresNew</span><span class="sxs-lookup"><span data-stu-id="f1582-174">Requires New</span></span>|<span data-ttu-id="f1582-175">Да</span><span class="sxs-lookup"><span data-stu-id="f1582-175">Yes</span></span>|<span data-ttu-id="f1582-176">Новая транзакция (область станет корневой)</span><span class="sxs-lookup"><span data-stu-id="f1582-176">New Transaction (will be the root)</span></span>|  
|<span data-ttu-id="f1582-177">Подавление</span><span class="sxs-lookup"><span data-stu-id="f1582-177">Suppress</span></span>|<span data-ttu-id="f1582-178">Да</span><span class="sxs-lookup"><span data-stu-id="f1582-178">Yes</span></span>|<span data-ttu-id="f1582-179">Транзакция отсутствует</span><span class="sxs-lookup"><span data-stu-id="f1582-179">No Transaction</span></span>|  
  
 <span data-ttu-id="f1582-180">После присоединения объекта <xref:System.Transactions.TransactionScope> к существующей внешней транзакции удаление объекта области может не привести к завершению транзакции, если только область не прервет транзакцию.</span><span class="sxs-lookup"><span data-stu-id="f1582-180">When a <xref:System.Transactions.TransactionScope> object joins an existing ambient transaction, disposing of the scope object may not end the transaction, unless the scope aborts the transaction.</span></span> <span data-ttu-id="f1582-181">Если внешняя транзакция была создана корневой областью, метод <xref:System.Transactions.CommittableTransaction.Commit%2A> вызывается для транзакции только после удаления корневой области.</span><span class="sxs-lookup"><span data-stu-id="f1582-181">If the ambient transaction was created by a root scope, only when the root scope is disposed of, does <xref:System.Transactions.CommittableTransaction.Commit%2A> get called on the transaction.</span></span> <span data-ttu-id="f1582-182">Если транзакция была создана вручную, она завершается в случае прерывания или в случае фиксации ее создателем.</span><span class="sxs-lookup"><span data-stu-id="f1582-182">If the transaction was created manually, the transaction ends when it is either aborted, or committed by its creator.</span></span>  
  
 <span data-ttu-id="f1582-183">В следующем примере показан объект <xref:System.Transactions.TransactionScope>, создающий три вложенных объекта области с разными значениями перечисления <xref:System.Transactions.TransactionScopeOption>.</span><span class="sxs-lookup"><span data-stu-id="f1582-183">The following example shows a <xref:System.Transactions.TransactionScope> object that creates three nested scope objects, each instantiated with a different <xref:System.Transactions.TransactionScopeOption> value.</span></span>  
  
```csharp  
using(TransactionScope scope1 = new TransactionScope())
//Default is Required
{
    using(TransactionScope scope2 = new TransactionScope(TransactionScopeOption.Required))
    {
        //...
    }

    using(TransactionScope scope3 = new TransactionScope(TransactionScopeOption.RequiresNew))
    {
        //...  
    }
  
    using(TransactionScope scope4 = new TransactionScope(TransactionScopeOption.Suppress))
    {
        //...  
    }
}
```  
  
 <span data-ttu-id="f1582-184">В примере показан блок кода без внешней транзакции, создающий новую область (`scope1`) со значением <xref:System.Transactions.TransactionScopeOption.Required>.</span><span class="sxs-lookup"><span data-stu-id="f1582-184">The example shows a code block without any ambient transaction creating a new scope (`scope1`) with <xref:System.Transactions.TransactionScopeOption.Required>.</span></span> <span data-ttu-id="f1582-185">Область `scope1` является корневой, поскольку она создает новую транзакцию (транзакцию A) и делает ее внешней транзакцией.</span><span class="sxs-lookup"><span data-stu-id="f1582-185">The scope `scope1` is a root scope as it creates a new transaction (Transaction A) and makes Transaction A the ambient transaction.</span></span> <span data-ttu-id="f1582-186">`Scope1`затем создает еще три объекта, <xref:System.Transactions.TransactionScopeOption> каждый из которых имеет различное значение.</span><span class="sxs-lookup"><span data-stu-id="f1582-186">`Scope1` then creates three more objects, each with a different <xref:System.Transactions.TransactionScopeOption> value.</span></span> <span data-ttu-id="f1582-187">Например, объект `scope2` создается со значением <xref:System.Transactions.TransactionScopeOption.Required>; поскольку существует внешняя транзакция, этот объект присоединяется к первой транзакции, созданной объектом `scope1`.</span><span class="sxs-lookup"><span data-stu-id="f1582-187">For example, `scope2` is created with <xref:System.Transactions.TransactionScopeOption.Required>, and since there is an ambient transaction, it joins the first transaction created by `scope1`.</span></span> <span data-ttu-id="f1582-188">Обратите внимание, что `scope3` является корневой областью новой транзакции, а `scope4` не имеет внешней транзакции.</span><span class="sxs-lookup"><span data-stu-id="f1582-188">Note that `scope3` is the root scope of a new transaction, and that `scope4` has no ambient transaction.</span></span>  
  
 <span data-ttu-id="f1582-189">Несмотря на то что значение по умолчанию <xref:System.Transactions.TransactionScopeOption> является наиболее часто используемым значением перечисления <xref:System.Transactions.TransactionScopeOption.Required>, каждое из остальных значений имеет свое уникальное назначение.</span><span class="sxs-lookup"><span data-stu-id="f1582-189">Although the default and most commonly used value of <xref:System.Transactions.TransactionScopeOption> is <xref:System.Transactions.TransactionScopeOption.Required>, each of the other values has its unique purpose.</span></span>  

### <a name="non-transactional-code-inside-a-transaction-scope"></a><span data-ttu-id="f1582-190">Нетранзакционный код внутри сферы транзакций</span><span class="sxs-lookup"><span data-stu-id="f1582-190">Non-transactional code inside a transaction scope</span></span>

 <span data-ttu-id="f1582-191"><xref:System.Transactions.TransactionScopeOption.Suppress>полезно, если требуется сохранить операции, выполняемые разделом кода, и не хотите прерывать транзакцию в случае сбоя операций.</span><span class="sxs-lookup"><span data-stu-id="f1582-191"><xref:System.Transactions.TransactionScopeOption.Suppress> is useful when you want to preserve the operations performed by the code section, and do not want to abort the ambient transaction if the operations fail.</span></span> <span data-ttu-id="f1582-192">(например, если требуется выполнить операции аудита или ведения журнала либо опубликовать события для подписчиков независимо от результата завершения внешней транзакции [фиксация или откат]).</span><span class="sxs-lookup"><span data-stu-id="f1582-192">For example, when you want to perform logging or audit operations, or when you want to publish events to subscribers regardless of whether your ambient transaction commits or aborts.</span></span> <span data-ttu-id="f1582-193">Это значение позволяет использовать раздел кода, не относящийся к транзакции, внутри области транзакции, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="f1582-193">This value allows you to have a non-transactional code section inside a transaction scope, as shown in the following example.</span></span>  
  
```csharp  
using(TransactionScope scope1 = new TransactionScope())
{
    try
    {
        //Start of non-transactional section
        using(TransactionScope scope2 = new
            TransactionScope(TransactionScopeOption.Suppress))  
        {  
            //Do non-transactional work here  
        }  
        //Restores ambient transaction here
   }
   catch {}  
   //Rest of scope1
}
```  
  
### <a name="voting-inside-a-nested-scope"></a><span data-ttu-id="f1582-194">Голосование во вложенной области</span><span class="sxs-lookup"><span data-stu-id="f1582-194">Voting inside a nested scope</span></span>  
 <span data-ttu-id="f1582-195">Несмотря на то что вложенная область может присоединяться к внешней транзакции корневой области, вызов метода <xref:System.Transactions.TransactionScope.Complete%2A> во вложенной области не оказывает воздействия на корневую область.</span><span class="sxs-lookup"><span data-stu-id="f1582-195">Although a nested scope can join the ambient transaction of the root scope, calling <xref:System.Transactions.TransactionScope.Complete%2A> in the nested scope has no affect on the root scope.</span></span> <span data-ttu-id="f1582-196">Транзакция будет зафиксирована, только если все области из корневой области вплоть до последней вложенной области проголосуют за фиксацию транзакции.</span><span class="sxs-lookup"><span data-stu-id="f1582-196">Only if all the scopes from the root scope down to the last nested scope vote to commit the transaction, will the transaction be committed.</span></span> <span data-ttu-id="f1582-197">Если не вызвать метод <xref:System.Transactions.TransactionScope.Complete%2A> во вложенной области, то включающая транзакция будет немедленно прекращена, что отразится на корневой области.</span><span class="sxs-lookup"><span data-stu-id="f1582-197">Not calling <xref:System.Transactions.TransactionScope.Complete%2A> in a nested scope will affect the root scope as the ambient transaction will immediately be aborted.</span></span>  
  
## <a name="setting-the-transactionscope-timeout"></a><span data-ttu-id="f1582-198">Задание времени ожидания для объекта TransactionScope</span><span class="sxs-lookup"><span data-stu-id="f1582-198">Setting the TransactionScope timeout</span></span>  
 <span data-ttu-id="f1582-199">Некоторые перегруженные конструкторы объекта <xref:System.Transactions.TransactionScope> принимают значение типа <xref:System.TimeSpan>, которое используется для контроля времени ожидания транзакции.</span><span class="sxs-lookup"><span data-stu-id="f1582-199">Some of the overloaded constructors of <xref:System.Transactions.TransactionScope> accept a value of type <xref:System.TimeSpan>, which is used to control the timeout of the transaction.</span></span> <span data-ttu-id="f1582-200">Нулевое значение указывает на бесконечное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="f1582-200">A timeout set to zero means an infinite timeout.</span></span> <span data-ttu-id="f1582-201">Значение бесконечного времени ожидания в основном полезно использовать при отладке, когда требуется изолировать проблему в бизнес-логике путем пошагового выполнения кода, но не требуется, чтобы истекло время ожидания отлаживаемой транзакции, пока осуществляется поиск проблемы.</span><span class="sxs-lookup"><span data-stu-id="f1582-201">Infinite timeout is useful mostly for debugging, when you want to isolate a problem in your business logic by stepping through your code, and you do not want the transaction you debug to time out while you attempt to locate the problem.</span></span> <span data-ttu-id="f1582-202">При использовании значения бесконечного времени ожидания во всех остальных случаях будьте чрезвычайно осторожны, поскольку оно переопределяет механизмы защиты от взаимоблокировок транзакций.</span><span class="sxs-lookup"><span data-stu-id="f1582-202">Be extremely careful using the infinite timeout value in all other cases, because it overrides the safeguards against transaction deadlocks.</span></span>  
  
 <span data-ttu-id="f1582-203">Как правило, при задании времени ожидания для объекта <xref:System.Transactions.TransactionScope> значения, отличные от значения по умолчанию, используются в двух случаях.</span><span class="sxs-lookup"><span data-stu-id="f1582-203">You typically set the <xref:System.Transactions.TransactionScope> timeout to values other than default in two cases.</span></span> <span data-ttu-id="f1582-204">Первый случай относится к процессу разработки, когда требуется проверить, как приложение обрабатывает прерванные транзакции.</span><span class="sxs-lookup"><span data-stu-id="f1582-204">The first is during development, when you want to test the way your application handles aborted transactions.</span></span> <span data-ttu-id="f1582-205">Задав малое значение времени ожидания (например, равное одной миллисекунде), можно вызвать прерывание транзакции и проверить код обработки ошибки.</span><span class="sxs-lookup"><span data-stu-id="f1582-205">By setting the timeout to a small value (such as one millisecond), you cause your transaction to fail and can thus observe your error handling code.</span></span> <span data-ttu-id="f1582-206">Второй случай относится к проверке участия области в состязании за ресурсы, приводящем к взаимоблокировкам; эта проверка заключается в задании времени ожидания, которое меньше значения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f1582-206">The second case in which you set the value to be less than the default timeout is when you believe that the scope is involved in resource contention, resulting in deadlocks.</span></span> <span data-ttu-id="f1582-207">В этом случае требуется как можно скорее прервать транзакцию без ожидания истечения времени ожидания по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f1582-207">In that case, you want to abort the transaction as soon as possible and not wait for the default timeout to expire.</span></span>  
  
 <span data-ttu-id="f1582-208">Если область присоединяется к внешней транзакции и задает время ожидания, меньшее заданного для внешней транзакции, к объекту <xref:System.Transactions.TransactionScope> применяется новое (меньшее) значение времени ожидания; при этом область должна завершиться в указанное время, иначе транзакция будет прервана автоматически.</span><span class="sxs-lookup"><span data-stu-id="f1582-208">When a scope joins an ambient transaction but specifies a smaller timeout than the one the ambient transaction is set to, the new, shorter timeout is enforced on the <xref:System.Transactions.TransactionScope> object, and the scope must end within the nested time specified, or the transaction is automatically aborted.</span></span> <span data-ttu-id="f1582-209">Если значение времени ожидания вложенной области превышает значение времени ожидания внешней транзакции, первое не оказывает никакого воздействия.</span><span class="sxs-lookup"><span data-stu-id="f1582-209">If the nested scope's timeout is more than that of the ambient transaction, it has no effect.</span></span>  
  
## <a name="setting-the-transactionscope-isolation-level"></a><span data-ttu-id="f1582-210">Задание уровня изоляции для объекта TransactionScope</span><span class="sxs-lookup"><span data-stu-id="f1582-210">Setting the TransactionScope isolation level</span></span>  
 <span data-ttu-id="f1582-211">Некоторые перегруженные конструкторы объекта <xref:System.Transactions.TransactionScope> принимают структуру типа <xref:System.Transactions.TransactionOptions>, позволяющую задать уровень изоляции в дополнение к значению времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="f1582-211">Some of the overloaded constructors of <xref:System.Transactions.TransactionScope> accept a structure of type <xref:System.Transactions.TransactionOptions> to specify an isolation level, in addition to a timeout value.</span></span> <span data-ttu-id="f1582-212">По умолчанию транзакция выполняется со значением уровня изоляции <xref:System.Transactions.IsolationLevel.Serializable>.</span><span class="sxs-lookup"><span data-stu-id="f1582-212">By default, the transaction executes with isolation level set to <xref:System.Transactions.IsolationLevel.Serializable>.</span></span> <span data-ttu-id="f1582-213">Значения, отличные от <xref:System.Transactions.IsolationLevel.Serializable>, обычно используются в случае систем, в которых преобладают операции чтения.</span><span class="sxs-lookup"><span data-stu-id="f1582-213">Selecting an isolation level other than <xref:System.Transactions.IsolationLevel.Serializable> is commonly used for read-intensive systems.</span></span> <span data-ttu-id="f1582-214">Это требует глубокого понимания теории обработки транзакций и семантики транзакций, проблем параллелизма, а также последствий, влияющих на целостность системы.</span><span class="sxs-lookup"><span data-stu-id="f1582-214">This requires a solid understanding of transaction processing theory and the semantics of the transaction itself, the concurrency issues involved, and the consequences for system consistency.</span></span>  
  
 <span data-ttu-id="f1582-215">Кроме того, не все диспетчеры ресурсов поддерживают все уровни изоляции; диспетчеры ресурсов могут решить участвовать в транзакции на более высоком уровне, чем настроенный.</span><span class="sxs-lookup"><span data-stu-id="f1582-215">In addition, not all resource managers support all levels of isolation, and they may elect to take part in the transaction at a higher level than the one configured.</span></span>  
  
 <span data-ttu-id="f1582-216">Каждый уровень изоляции, кроме <xref:System.Transactions.IsolationLevel.Serializable>, сопряжен с проблемой нарушения целостности, возникающей в результате доступа других транзакций к тем же самым данным.</span><span class="sxs-lookup"><span data-stu-id="f1582-216">Every isolation level besides <xref:System.Transactions.IsolationLevel.Serializable> is susceptible to inconsistency resulting from other transactions accessing the same information.</span></span> <span data-ttu-id="f1582-217">Разница между различными уровнями изоляции заключается в порядке использования блокировок для чтения и блокировок для записи.</span><span class="sxs-lookup"><span data-stu-id="f1582-217">The difference between the different isolation levels is in the way read and write locks are used.</span></span> <span data-ttu-id="f1582-218">Блокировка может действовать только во время доступа транзакции к данным в диспетчере ресурсов или пока транзакция не будет зафиксирована или прервана.</span><span class="sxs-lookup"><span data-stu-id="f1582-218">A lock can be held only when the transaction accesses the data in the resource manager, or it can be held until the transaction is committed or aborted.</span></span> <span data-ttu-id="f1582-219">Первый вариант обеспечивает более высокую производительность, второй - более высокую согласованность.</span><span class="sxs-lookup"><span data-stu-id="f1582-219">The former is better for throughput, the latter for consistency.</span></span> <span data-ttu-id="f1582-220">Два вида блокировок и два вида операций (чтение/запись) образуют четыре базовых уровня изоляции.</span><span class="sxs-lookup"><span data-stu-id="f1582-220">The two kinds of locks and the two kinds of operations (read/write) give four basic isolation levels.</span></span> <span data-ttu-id="f1582-221">Подробнее см. в разделе <xref:System.Transactions.IsolationLevel>.</span><span class="sxs-lookup"><span data-stu-id="f1582-221">See <xref:System.Transactions.IsolationLevel> for more information.</span></span>  
  
 <span data-ttu-id="f1582-222">При использовании вложенных объектов <xref:System.Transactions.TransactionScope> все вложенные области следует настроить на использование строго одного уровня изоляции, если им необходимо присоединиться к внешней транзакции.</span><span class="sxs-lookup"><span data-stu-id="f1582-222">When using nested <xref:System.Transactions.TransactionScope> objects, all nested scopes must be configured to use exactly the same isolation level if they want to join the ambient transaction.</span></span> <span data-ttu-id="f1582-223">Если при попытке присоединения вложенного объекта <xref:System.Transactions.TransactionScope> к внешней транзакции обнаруживается, что для него задан другой уровень изоляции, возникает исключение <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="f1582-223">If a nested <xref:System.Transactions.TransactionScope> object tries to join the ambient transaction yet it specifies a different isolation level, an <xref:System.ArgumentException> is thrown.</span></span>  
  
## <a name="interop-with-com"></a><span data-ttu-id="f1582-224">Взаимодействие с транзакциями COM+</span><span class="sxs-lookup"><span data-stu-id="f1582-224">Interop with COM+</span></span>  
 <span data-ttu-id="f1582-225">Чтобы задать способ взаимодействия с транзакциями COM+ при создании нового экземпляра <xref:System.Transactions.TransactionScope>, можно использовать перечисление <xref:System.Transactions.EnterpriseServicesInteropOption> в одном из конструкторов.</span><span class="sxs-lookup"><span data-stu-id="f1582-225">When you create a new <xref:System.Transactions.TransactionScope> instance, you can use the <xref:System.Transactions.EnterpriseServicesInteropOption> enumeration in one of the constructors to specify how to interact with COM+.</span></span> <span data-ttu-id="f1582-226">Для получения более подробной информации об этом [см.](interoperability-with-enterprise-services-and-com-transactions.md)</span><span class="sxs-lookup"><span data-stu-id="f1582-226">For more information on this, see [Interoperability with Enterprise Services and COM+ Transactions](interoperability-with-enterprise-services-and-com-transactions.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f1582-227">См. также раздел</span><span class="sxs-lookup"><span data-stu-id="f1582-227">See also</span></span>

- <xref:System.Transactions.Transaction.Clone%2A>
- <xref:System.Transactions.TransactionScope>
