---
title: Реализация неявной транзакции с использованием области транзакции
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 49d1706a-1e0c-4c85-9704-75c908372eb9
ms.openlocfilehash: 3a6dd2cc4565cd4f8716b691d564a782887be1e0
ms.sourcegitcommit: 2d792961ed48f235cf413d6031576373c3050918
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/31/2019
ms.locfileid: "70205925"
---
# <a name="implementing-an-implicit-transaction-using-transaction-scope"></a>Реализация неявной транзакции с использованием области транзакции
Класс <xref:System.Transactions.TransactionScope> предоставляет простой способ пометки блока кода как участвующего в транзакции без необходимости взаимодействия с самой транзакцией. Область транзакции может автоматически выбирать внешнюю транзакцию и управлять ей. В целях обеспечения простоты использования и эффективности при разработке транзакционного приложения рекомендуется использовать класс <xref:System.Transactions.TransactionScope>.  
  
 Кроме того, явно зачислять ресурсы в транзакцию не требуется. Любой диспетчер ресурсов <xref:System.Transactions> (например SQL Server 2005) может обнаружить существование внешней транзакции, созданной областью, и автоматически зачислиться в эту транзакцию.  
  
## <a name="creating-a-transaction-scope"></a>Создание области транзакции  
 Ниже представлен простой пример использования класса <xref:System.Transactions.TransactionScope>.  
  
 [!code-csharp[TransactionScope#1](../../../../samples/snippets/csharp/VS_Snippets_Remoting/TransactionScope/cs/ScopeWithSQL.cs#1)]
 [!code-vb[TransactionScope#1](../../../../samples/snippets/visualbasic/VS_Snippets_Remoting/TransactionScope/vb/ScopeWithSQL.vb#1)]  
  
 Область транзакции запускается после создания нового <xref:System.Transactions.TransactionScope> объекта.  Как показано в примере кода, рекомендуется создавать области с помощью оператора **using** . Оператор **using** доступен как в C# , так и в Visual Basic и работает как **try... Finally** , чтобы обеспечить правильную удаленность области.  
  
 При создании экземпляра <xref:System.Transactions.TransactionScope> диспетчер транзакций определяет, в какой транзакции следует участвовать. После определения область всегда участвует в этой транзакции. Решение зависит от двух факторов: от наличия внешней транзакции и значения параметра **трансактионскопеоптион** в конструкторе. Внешняя транзакция - это транзакция, в рамках которой выполняется ваш код. Ссылку на внешнюю транзакцию можно получить, вызвав статическое свойство <xref:System.Transactions.Transaction.Current%2A?displayProperty=nameWithType> класса <xref:System.Transactions.Transaction>. Дополнительные сведения об использовании этого параметра см. в подразделе [Управление потоком транзакций с помощью трансактионскопеоптион](#ManageTxFlow) этой статьи.  
  
## <a name="completing-a-transaction-scope"></a>Завершение области транзакции  
 Когда приложение завершает все операции, подлежащие выполнению в транзакции, следует вызвать метод <xref:System.Transactions.TransactionScope.Complete%2A?displayProperty=nameWIthType> только один раз, чтобы информировать диспетчер транзакций о возможности фиксации данной транзакции. Очень целесообразно поставить вызов в <xref:System.Transactions.TransactionScope.Complete%2A> качестве последней инструкции в блоке **using** .  
  
 Если не вызвать этот метод, транзакция прерывается, так как диспетчер транзакций интерпретирует это как сбой системы или эквивалент исключения, вызываемого в области транзакции. Однако вызов этого метода не гарантирует, что транзакция будет зафиксирована. Это просто способ информирования диспетчера транзакций о состоянии. После вызова метода <xref:System.Transactions.TransactionScope.Complete%2A> доступ к внешней транзакции с помощью свойства <xref:System.Transactions.Transaction.Current%2A> невозможен. При попытке такого доступа возникает исключение.  
  
 Если объект изначально создал транзакцию, фактическая работа по фиксации транзакции диспетчером транзакций происходит после последней строки кода в блоке **using.** <xref:System.Transactions.TransactionScope> Если транзакция создана не этим объектом, фиксация происходит при каждом вызове метода <xref:System.Transactions.CommittableTransaction.Commit%2A> владельцем объекта <xref:System.Transactions.CommittableTransaction>. На этом этапе диспетчер транзакций вызывает диспетчеры ресурсов и уведомляет их <xref:System.Transactions.TransactionScope.Complete%2A> <xref:System.Transactions.TransactionScope> о фиксации или откате в зависимости от того, был ли вызван метод для объекта.  
  
 Оператор **using** гарантирует, что <xref:System.Transactions.TransactionScope.Dispose%2A> метод <xref:System.Transactions.TransactionScope> объекта будет вызываться даже при возникновении исключения. Вызов метода <xref:System.Transactions.TransactionScope.Dispose%2A> отмечает конец области транзакции. Исключения, возникающие после вызова данного метода, могут не воздействовать на транзакцию. Данный метод также восстанавливает предыдущее состояние внешней транзакции.  
  
 Если область создает транзакцию и эта транзакция прерывается, возникает исключение <xref:System.Transactions.TransactionAbortedException>. Если диспетчер транзакций не может принять решение о фиксации, возникает исключение <xref:System.Transactions.TransactionInDoubtException>. В случае фиксации транзакции исключения не возникают.  
  
## <a name="rolling-back-a-transaction"></a>Откат транзакции  
 Если требуется откатить транзакцию, не следует вызывать метод <xref:System.Transactions.TransactionScope.Complete%2A> в пределах области транзакции. Например, можно вызвать исключение в пределах области. При этом будет выполнен откат транзакции, в которой участвует область.  
  
## <a name="ManageTxFlow"></a>Управление потоком транзакций с помощью Трансактионскопеоптион  
 Область транзакции можно сделать вложенной, вызвав метод, использующий объект <xref:System.Transactions.TransactionScope>, из метода, использующего собственную область, как в случае метода `RootMethod` в следующем примере.  
  
```csharp  
void RootMethod()
{
    using(TransactionScope scope = new TransactionScope())
    {
        /* Perform transactional work here */
        SomeMethod();
        scope.Complete();
    }
}

void SomeMethod()
{
    using(TransactionScope scope = new TransactionScope())
    {
        /* Perform transactional work here */
        scope.Complete();
    }
}
```  
  
 Самая верхняя область транзакции называется корневой областью.  
  
 Класс <xref:System.Transactions.TransactionScope> предоставляет несколько перегруженных конструкторов, принимающих перечисление <xref:System.Transactions.TransactionScopeOption>, которое определяет поведение области транзакции.  
  
 Предусмотрено три варианта поведения объекта <xref:System.Transactions.TransactionScope>:  
  
- присоединиться к внешней транзакции или создать новую транзакцию, если она не существует;  
  
- стать новой корневой областью, т. е. запустить новую транзакцию, представляющую собой новую внешнюю транзакцию внутри собственной области;  
  
- не принимать участие в транзакции, в результате внешняя транзакция отсутствует.  
  
 Если область создана со значением <xref:System.Transactions.TransactionScopeOption.Required> и внешняя транзакция существует, область присоединяется к этой транзакции. Если внешняя транзакция отсутствует, область создает новую транзакцию и становится корневой областью. Это значение по умолчанию. В случае использования значения <xref:System.Transactions.TransactionScopeOption.Required> поведение кода, находящегося внутри области, должно быть одинаковым в обоих случаях: область является корневой или область только присоединяется к транзакции.  
  
 Если область создана со значением <xref:System.Transactions.TransactionScopeOption.RequiresNew>, она является корневой областью. Область запускает новую транзакцию, которая становится новой внешней транзакцией внутри области.  
  
 Если область создана со значением <xref:System.Transactions.TransactionScopeOption.Suppress>, она не принимает участие в транзакции независимо от существования внешней транзакции. Область, созданная с помощью этого значения, всегда имеет значение **null** в качестве внешней транзакции.  
  
 Сводка рассмотренных выше значений представлена в следующей таблице.  
  
|TransactionScopeOption|Внешняя транзакция|Транзакция, в которой участвует область|  
|----------------------------|-------------------------|-----------------------------|  
|Обязательно|Нет|Новая транзакция (область станет корневой)|  
|RequiresNew|Нет|Новая транзакция (область станет корневой)|  
|Suppress|Нет|Транзакция отсутствует|  
|Обязательно|Да|Внешняя транзакция|  
|RequiresNew|Да|Новая транзакция (область станет корневой)|  
|Suppress|Да|Транзакция отсутствует|  
  
 После присоединения объекта <xref:System.Transactions.TransactionScope> к существующей внешней транзакции удаление объекта области может не привести к завершению транзакции, если только область не прервет транзакцию. Если внешняя транзакция была создана корневой областью, метод <xref:System.Transactions.CommittableTransaction.Commit%2A> вызывается для транзакции только после удаления корневой области. Если транзакция была создана вручную, она завершается в случае прерывания или в случае фиксации ее создателем.  
  
 В следующем примере показан объект <xref:System.Transactions.TransactionScope>, создающий три вложенных объекта области с разными значениями перечисления <xref:System.Transactions.TransactionScopeOption>.  
  
```csharp  
using(TransactionScope scope1 = new TransactionScope())
//Default is Required
{
    using(TransactionScope scope2 = new TransactionScope(TransactionScopeOption.Required))
    {
        //...
    }

    using(TransactionScope scope3 = new TransactionScope(TransactionScopeOption.RequiresNew))   
    {
        //...  
    }
  
    using(TransactionScope scope4 = new TransactionScope(TransactionScopeOption.Suppress))
    {
        //...  
    }
}
```  
  
 В примере показан блок кода без внешней транзакции, создающий новую область (`scope1`) со значением <xref:System.Transactions.TransactionScopeOption.Required>. Область `scope1` является корневой, поскольку она создает новую транзакцию (транзакцию A) и делает ее внешней транзакцией. `Scope1`затем создает еще три объекта, каждый из которых имеет <xref:System.Transactions.TransactionScopeOption> другое значение. Например, объект `scope2` создается со значением <xref:System.Transactions.TransactionScopeOption.Required>; поскольку существует внешняя транзакция, этот объект присоединяется к первой транзакции, созданной объектом `scope1`. Обратите внимание, что `scope3` является корневой областью новой транзакции, а `scope4` не имеет внешней транзакции.  
  
 Несмотря на то что значение по умолчанию <xref:System.Transactions.TransactionScopeOption> является наиболее часто используемым значением перечисления <xref:System.Transactions.TransactionScopeOption.Required>, каждое из остальных значений имеет свое уникальное назначение.  

### <a name="non-transactional-code-inside-a-transaction-scope"></a>Нетранзакционный код в области транзакции

 <xref:System.Transactions.TransactionScopeOption.Suppress>полезен, если необходимо сохранить операции, выполняемые в разделе кода, и не прерывать внешнюю транзакцию в случае сбоя операций. (например, если требуется выполнить операции аудита или ведения журнала либо опубликовать события для подписчиков независимо от результата завершения внешней транзакции [фиксация или откат]). Это значение позволяет использовать раздел кода, не относящийся к транзакции, внутри области транзакции, как показано в следующем примере.  
  
```csharp  
using(TransactionScope scope1 = new TransactionScope())
{
    try
    {
        //Start of non-transactional section
        using(TransactionScope scope2 = new
            TransactionScope(TransactionScopeOption.Suppress))  
        {  
            //Do non-transactional work here  
        }  
        //Restores ambient transaction here
   }
   catch {}  
   //Rest of scope1
}
```  
  
### <a name="voting-inside-a-nested-scope"></a>Голосование во вложенной области  
 Несмотря на то что вложенная область может присоединяться к внешней транзакции корневой области, вызов метода <xref:System.Transactions.TransactionScope.Complete%2A> во вложенной области не оказывает воздействия на корневую область. Транзакция будет зафиксирована, только если все области из корневой области вплоть до последней вложенной области проголосуют за фиксацию транзакции. Если не вызвать метод <xref:System.Transactions.TransactionScope.Complete%2A> во вложенной области, то включающая транзакция будет немедленно прекращена, что отразится на корневой области.  
  
## <a name="setting-the-transactionscope-timeout"></a>Задание времени ожидания для объекта TransactionScope  
 Некоторые перегруженные конструкторы объекта <xref:System.Transactions.TransactionScope> принимают значение типа <xref:System.TimeSpan>, которое используется для контроля времени ожидания транзакции. Нулевое значение указывает на бесконечное время ожидания. Значение бесконечного времени ожидания в основном полезно использовать при отладке, когда требуется изолировать проблему в бизнес-логике путем пошагового выполнения кода, но не требуется, чтобы истекло время ожидания отлаживаемой транзакции, пока осуществляется поиск проблемы. При использовании значения бесконечного времени ожидания во всех остальных случаях будьте чрезвычайно осторожны, поскольку оно переопределяет механизмы защиты от взаимоблокировок транзакций.  
  
 Как правило, при задании времени ожидания для объекта <xref:System.Transactions.TransactionScope> значения, отличные от значения по умолчанию, используются в двух случаях. Первый случай относится к процессу разработки, когда требуется проверить, как приложение обрабатывает прерванные транзакции. Задав малое значение времени ожидания (например, равное одной миллисекунде), можно вызвать прерывание транзакции и проверить код обработки ошибки. Второй случай относится к проверке участия области в состязании за ресурсы, приводящем к взаимоблокировкам; эта проверка заключается в задании времени ожидания, которое меньше значения по умолчанию. В этом случае требуется как можно скорее прервать транзакцию без ожидания истечения времени ожидания по умолчанию.  
  
 Если область присоединяется к внешней транзакции и задает время ожидания, меньшее заданного для внешней транзакции, к объекту <xref:System.Transactions.TransactionScope> применяется новое (меньшее) значение времени ожидания; при этом область должна завершиться в указанное время, иначе транзакция будет прервана автоматически. Если значение времени ожидания вложенной области превышает значение времени ожидания внешней транзакции, первое не оказывает никакого воздействия.  
  
## <a name="setting-the-transactionscope-isolation-level"></a>Задание уровня изоляции для объекта TransactionScope  
 Некоторые перегруженные конструкторы объекта <xref:System.Transactions.TransactionScope> принимают структуру типа <xref:System.Transactions.TransactionOptions>, позволяющую задать уровень изоляции в дополнение к значению времени ожидания. По умолчанию транзакция выполняется со значением уровня изоляции <xref:System.Transactions.IsolationLevel.Serializable>. Значения, отличные от <xref:System.Transactions.IsolationLevel.Serializable>, обычно используются в случае систем, в которых преобладают операции чтения. Это требует глубокого понимания теории обработки транзакций и семантики транзакций, проблем параллелизма, а также последствий, влияющих на целостность системы.  
  
 Кроме того, не все диспетчеры ресурсов поддерживают все уровни изоляции; диспетчеры ресурсов могут решить участвовать в транзакции на более высоком уровне, чем настроенный.  
  
 Каждый уровень изоляции, кроме <xref:System.Transactions.IsolationLevel.Serializable>, сопряжен с проблемой нарушения целостности, возникающей в результате доступа других транзакций к тем же самым данным. Разница между различными уровнями изоляции заключается в порядке использования блокировок для чтения и блокировок для записи. Блокировка может действовать только во время доступа транзакции к данным в диспетчере ресурсов или пока транзакция не будет зафиксирована или прервана. Первый вариант обеспечивает более высокую производительность, второй - более высокую согласованность. Два вида блокировок и два вида операций (чтение/запись) образуют четыре базовых уровня изоляции. Дополнительные сведения см. в разделе <xref:System.Transactions.IsolationLevel>.  
  
 При использовании вложенных объектов <xref:System.Transactions.TransactionScope> все вложенные области следует настроить на использование строго одного уровня изоляции, если им необходимо присоединиться к внешней транзакции. Если при попытке присоединения вложенного объекта <xref:System.Transactions.TransactionScope> к внешней транзакции обнаруживается, что для него задан другой уровень изоляции, возникает исключение <xref:System.ArgumentException>.  
  
## <a name="interop-with-com"></a>Взаимодействие с транзакциями COM+  
 Чтобы задать способ взаимодействия с транзакциями COM+ при создании нового экземпляра <xref:System.Transactions.TransactionScope>, можно использовать перечисление <xref:System.Transactions.EnterpriseServicesInteropOption> в одном из конструкторов. Дополнительные сведения см. в статье [взаимодействие с корпоративными службами и транзакциями COM+](interoperability-with-enterprise-services-and-com-transactions.md).  
  
## <a name="see-also"></a>См. также

- <xref:System.Transactions.Transaction.Clone%2A>
- <xref:System.Transactions.TransactionScope>
