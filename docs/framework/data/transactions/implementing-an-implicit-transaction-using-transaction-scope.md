---
title: Реализация неявной транзакции с использованием области транзакции
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 49d1706a-1e0c-4c85-9704-75c908372eb9
ms.openlocfilehash: e9e5e09bdde82c7b818fd47275bdbfeda5850682
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2019
ms.locfileid: "64645754"
---
# <a name="implementing-an-implicit-transaction-using-transaction-scope"></a>Реализация неявной транзакции с использованием области транзакции
Класс <xref:System.Transactions.TransactionScope> предоставляет простой способ пометки блока кода как участвующего в транзакции без необходимости взаимодействия с самой транзакцией. Область транзакции может автоматически выбирать внешнюю транзакцию и управлять ей. В целях обеспечения простоты использования и эффективности при разработке транзакционного приложения рекомендуется использовать класс <xref:System.Transactions.TransactionScope>.  
  
 Кроме того, явно зачислять ресурсы в транзакцию не требуется. Любой диспетчер ресурсов <xref:System.Transactions> (например SQL Server 2005) может обнаружить существование внешней транзакции, созданной областью, и автоматически зачислиться в эту транзакцию.  
  
## <a name="creating-a-transaction-scope"></a>Создание области транзакции  
 Ниже представлен простой пример использования класса <xref:System.Transactions.TransactionScope>.  
  
 [!code-csharp[TransactionScope#1](../../../../samples/snippets/csharp/VS_Snippets_Remoting/TransactionScope/cs/ScopeWithSQL.cs#1)]
 [!code-vb[TransactionScope#1](../../../../samples/snippets/visualbasic/VS_Snippets_Remoting/TransactionScope/vb/ScopeWithSQL.vb#1)]  
  
 Область транзакции начинает действовать после создания новый <xref:System.Transactions.TransactionScope> объекта.  Как показано в следующем образце кода, рекомендуется при создании областей с **с помощью** инструкции. **С помощью** инструкция доступна как в C# и в Visual Basic и действует как **try... finally** блок, чтобы убедиться, что область правильное удаление.  
  
 При создании экземпляра <xref:System.Transactions.TransactionScope> диспетчер транзакций определяет, в какой транзакции следует участвовать. После определения область всегда участвует в этой транзакции. Решение зависит от двух факторов: присутствует ли внешнюю транзакцию и значение **TransactionScopeOption** параметр в конструкторе. Внешняя транзакция - это транзакция, в рамках которой выполняется ваш код. Ссылку на внешнюю транзакцию можно получить, вызвав статическое свойство <xref:System.Transactions.Transaction.Current%2A?displayProperty=nameWithType> класса <xref:System.Transactions.Transaction>. Дополнительные сведения об использовании этого параметра см. в разделе [управление потоком транзакций с помощью объекта TransactionScopeOption](#ManageTxFlow) этого раздела.  
  
## <a name="completing-a-transaction-scope"></a>Завершение области транзакции  
 Когда приложение завершает все операции, подлежащие выполнению в транзакции, следует вызвать метод <xref:System.Transactions.TransactionScope.Complete%2A?displayProperty=nameWIthType> только один раз, чтобы информировать диспетчер транзакций о возможности фиксации данной транзакции. Это очень хорошей практикой поместить вызов <xref:System.Transactions.TransactionScope.Complete%2A> в последнем операторе в **с помощью** блока.  
  
 Если этот метод не вызывается, транзакция прерывается, поскольку диспетчер транзакций интерпретирует это как сбой системы или возникновение исключения, созданного в пределах транзакции. Однако вызов этого метода не гарантирует, что транзакция будет зафиксирована. Это просто способ информирования диспетчера транзакций о состоянии. После вызова метода <xref:System.Transactions.TransactionScope.Complete%2A> доступ к внешней транзакции с помощью свойства <xref:System.Transactions.Transaction.Current%2A> невозможен. При попытке такого доступа возникает исключение.  
  
 Если <xref:System.Transactions.TransactionScope> объекта транзакция создана, фактическая Фиксация транзакции диспетчер транзакций происходит после последней строки кода в **с помощью** блока. Если транзакция создана не этим объектом, фиксация происходит при каждом вызове метода <xref:System.Transactions.CommittableTransaction.Commit%2A> владельцем объекта <xref:System.Transactions.CommittableTransaction>. После этого диспетчер транзакций вызывает диспетчеры ресурсов и сообщает им, чтобы commit или rollback, в зависимости от <xref:System.Transactions.TransactionScope.Complete%2A> метод был вызван для <xref:System.Transactions.TransactionScope> объекта.  
  
 **С помощью** инструкции гарантирует, что <xref:System.Transactions.TransactionScope.Dispose%2A> метод <xref:System.Transactions.TransactionScope> объект называется даже при возникновении исключения. Вызов метода <xref:System.Transactions.TransactionScope.Dispose%2A> отмечает конец области транзакции. Исключения, возникающие после вызова данного метода, могут не воздействовать на транзакцию. Данный метод также восстанавливает предыдущее состояние внешней транзакции.  
  
 Если область создает транзакцию и эта транзакция прерывается, возникает исключение <xref:System.Transactions.TransactionAbortedException>. Если диспетчер транзакций не может принять решение о фиксации, возникает исключение <xref:System.Transactions.TransactionInDoubtException>. В случае фиксации транзакции исключения не возникают.  
  
## <a name="rolling-back-a-transaction"></a>Откат транзакции  
 Если требуется откатить транзакцию, не следует вызывать метод <xref:System.Transactions.TransactionScope.Complete%2A> в пределах области транзакции. Например, можно вызвать исключение в пределах области. При этом будет выполнен откат транзакции, в которой участвует область.  
  
## <a name="ManageTxFlow"></a> Управление потоком транзакций с помощью объекта TransactionScopeOption  
 Область транзакции можно сделать вложенной, вызвав метод, использующий объект <xref:System.Transactions.TransactionScope>, из метода, использующего собственную область, как в случае метода `RootMethod` в следующем примере.  
  
```csharp  
void RootMethod()  
{  
     using(TransactionScope scope = new TransactionScope())  
     {  
          /* Perform transactional work here */  
          SomeMethod();  
          scope.Complete();  
     }  
}  
  
void SomeMethod()  
{  
     using(TransactionScope scope = new TransactionScope())  
     {  
          /* Perform transactional work here */  
          scope.Complete();  
     }  
}  
```  
  
 Самая верхняя область транзакции называется корневой областью.  
  
 Класс <xref:System.Transactions.TransactionScope> предоставляет несколько перегруженных конструкторов, принимающих перечисление <xref:System.Transactions.TransactionScopeOption>, которое определяет поведение области транзакции.  
  
 Предусмотрено три варианта поведения объекта <xref:System.Transactions.TransactionScope>:  
  
- присоединиться к внешней транзакции или создать новую транзакцию, если она не существует;  
  
- стать новой корневой областью, т. е. запустить новую транзакцию, представляющую собой новую внешнюю транзакцию внутри собственной области;  
  
- не принимать участие в транзакции, в результате внешняя транзакция отсутствует.  
  
 Если область создана со значением <xref:System.Transactions.TransactionScopeOption.Required> и внешняя транзакция существует, область присоединяется к этой транзакции. Если внешняя транзакция отсутствует, область создает новую транзакцию и становится корневой областью. Это значение по умолчанию. В случае использования значения <xref:System.Transactions.TransactionScopeOption.Required> поведение кода, находящегося внутри области, должно быть одинаковым в обоих случаях: область является корневой или область только присоединяется к транзакции.  
  
 Если область создана со значением <xref:System.Transactions.TransactionScopeOption.RequiresNew>, она является корневой областью. Область запускает новую транзакцию, которая становится новой внешней транзакцией внутри области.  
  
 Если область создана со значением <xref:System.Transactions.TransactionScopeOption.Suppress>, она не принимает участие в транзакции независимо от существования внешней транзакции. Области, созданной с этим значением, всегда имеют **null** качестве внешней транзакции.  
  
 Сводка рассмотренных выше значений представлена в следующей таблице.  
  
|TransactionScopeOption|Внешняя транзакция|Транзакция, в которой участвует область|  
|----------------------------|-------------------------|-----------------------------|  
|Обязательно|Нет|Новая транзакция (область станет корневой)|  
|RequiresNew|Нет|Новая транзакция (область станет корневой)|  
|Suppress|Нет|Транзакция отсутствует|  
|Обязательно|Да|Внешняя транзакция|  
|RequiresNew|Да|Новая транзакция (область станет корневой)|  
|Suppress|Да|Транзакция отсутствует|  
  
 После присоединения объекта <xref:System.Transactions.TransactionScope> к существующей внешней транзакции удаление объекта области может не привести к завершению транзакции, если только область не прервет транзакцию. Если внешняя транзакция была создана корневой областью, метод <xref:System.Transactions.CommittableTransaction.Commit%2A> вызывается для транзакции только после удаления корневой области. Если транзакция была создана вручную, она завершается в случае прерывания или в случае фиксации ее создателем.  
  
 В следующем примере показан объект <xref:System.Transactions.TransactionScope>, создающий три вложенных объекта области с разными значениями перечисления <xref:System.Transactions.TransactionScopeOption>.  
  
```csharp  
using(TransactionScope scope1 = new TransactionScope())   
//Default is Required   
{   
     using(TransactionScope scope2 = new   
      TransactionScope(TransactionScopeOption.Required))   
     {  
     ...  
     }   
  
     using(TransactionScope scope3 = new TransactionScope(TransactionScopeOption.RequiresNew))   
     {  
     ...  
     }   
  
     using(TransactionScope scope4 = new   
        TransactionScope(TransactionScopeOption.Suppress))   
    {  
     ...  
    }   
}  
```  
  
 В примере показан блок кода без внешней транзакции, создающий новую область (`scope1`) со значением <xref:System.Transactions.TransactionScopeOption.Required>. Область `scope1` является корневой, поскольку она создает новую транзакцию (транзакцию A) и делает ее внешней транзакцией. `Scope1` затем создает три дополнительных объекта с разными <xref:System.Transactions.TransactionScopeOption> значение. Например, объект `scope2` создается со значением <xref:System.Transactions.TransactionScopeOption.Required>; поскольку существует внешняя транзакция, этот объект присоединяется к первой транзакции, созданной объектом `scope1`. Обратите внимание, что `scope3` является корневой областью новой транзакции, а `scope4` не имеет внешней транзакции.  
  
 Несмотря на то что значение по умолчанию <xref:System.Transactions.TransactionScopeOption> является наиболее часто используемым значением перечисления <xref:System.Transactions.TransactionScopeOption.Required>, каждое из остальных значений имеет свое уникальное назначение.  
  
 <xref:System.Transactions.TransactionScopeOption.Suppress> полезно, когда требуется сохранить операции, выполняемые в разделе кода и не хотите прерывать внешнюю транзакцию в случае сбоя операции. (например, если требуется выполнить операции аудита или ведения журнала либо опубликовать события для подписчиков независимо от результата завершения внешней транзакции [фиксация или откат]). Это значение позволяет использовать раздел кода, не относящийся к транзакции, внутри области транзакции, как показано в следующем примере.  
  
```csharp  
using(TransactionScope scope1 = new TransactionScope())  
{  
     try  
     {  
          //Start of non-transactional section   
          using(TransactionScope scope2 = new  
             TransactionScope(TransactionScopeOption.Suppress))  
          {  
               //Do non-transactional work here  
          }  
          //Restores ambient transaction here  
   }  
     catch  
     {}  
   //Rest of scope1  
}  
```  
  
### <a name="voting-inside-a-nested-scope"></a>Голосование во вложенной области  
 Несмотря на то что вложенная область может присоединяться к внешней транзакции корневой области, вызов метода <xref:System.Transactions.TransactionScope.Complete%2A> во вложенной области не оказывает воздействия на корневую область. Транзакция будет зафиксирована, только если все области из корневой области вплоть до последней вложенной области проголосуют за фиксацию транзакции. Если не вызвать метод <xref:System.Transactions.TransactionScope.Complete%2A> во вложенной области, то включающая транзакция будет немедленно прекращена, что отразится на корневой области.  
  
## <a name="setting-the-transactionscope-timeout"></a>Задание времени ожидания для объекта TransactionScope  
 Некоторые перегруженные конструкторы объекта <xref:System.Transactions.TransactionScope> принимают значение типа <xref:System.TimeSpan>, которое используется для контроля времени ожидания транзакции. Нулевое значение указывает на бесконечное время ожидания. Значение бесконечного времени ожидания в основном полезно использовать при отладке, когда требуется изолировать проблему в бизнес-логике путем пошагового выполнения кода, но не требуется, чтобы истекло время ожидания отлаживаемой транзакции, пока осуществляется поиск проблемы. При использовании значения бесконечного времени ожидания во всех остальных случаях будьте чрезвычайно осторожны, поскольку оно переопределяет механизмы защиты от взаимоблокировок транзакций.  
  
 Как правило, при задании времени ожидания для объекта <xref:System.Transactions.TransactionScope> значения, отличные от значения по умолчанию, используются в двух случаях. Первый случай относится к процессу разработки, когда требуется проверить, как приложение обрабатывает прерванные транзакции. Задав малое значение времени ожидания (например, равное одной миллисекунде), можно вызвать прерывание транзакции и проверить код обработки ошибки. Второй случай относится к проверке участия области в состязании за ресурсы, приводящем к взаимоблокировкам; эта проверка заключается в задании времени ожидания, которое меньше значения по умолчанию. В этом случае требуется как можно скорее прервать транзакцию без ожидания истечения времени ожидания по умолчанию.  
  
 Если область присоединяется к внешней транзакции и задает время ожидания, меньшее заданного для внешней транзакции, к объекту <xref:System.Transactions.TransactionScope> применяется новое (меньшее) значение времени ожидания; при этом область должна завершиться в указанное время, иначе транзакция будет прервана автоматически. Если значение времени ожидания вложенной области превышает значение времени ожидания внешней транзакции, первое не оказывает никакого воздействия.  
  
## <a name="setting-the-transactionscope-isolation-level"></a>Задание уровня изоляции для объекта TransactionScope  
 Некоторые перегруженные конструкторы объекта <xref:System.Transactions.TransactionScope> принимают структуру типа <xref:System.Transactions.TransactionOptions>, позволяющую задать уровень изоляции в дополнение к значению времени ожидания. По умолчанию транзакция выполняется со значением уровня изоляции <xref:System.Transactions.IsolationLevel.Serializable>. Значения, отличные от <xref:System.Transactions.IsolationLevel.Serializable>, обычно используются в случае систем, в которых преобладают операции чтения. Это требует глубокого понимания теории обработки транзакций и семантики транзакций, проблем параллелизма, а также последствий, влияющих на целостность системы.  
  
 Кроме того, не все диспетчеры ресурсов поддерживают все уровни изоляции; диспетчеры ресурсов могут решить участвовать в транзакции на более высоком уровне, чем настроенный.  
  
 Каждый уровень изоляции, кроме <xref:System.Transactions.IsolationLevel.Serializable>, сопряжен с проблемой нарушения целостности, возникающей в результате доступа других транзакций к тем же самым данным. Разница между различными уровнями изоляции заключается в порядке использования блокировок для чтения и блокировок для записи. Блокировка может действовать только во время доступа транзакции к данным в диспетчере ресурсов или пока транзакция не будет зафиксирована или прервана. Первый вариант обеспечивает более высокую производительность, второй - более высокую согласованность. Два вида блокировок и два вида операций (чтение/запись) образуют четыре базовых уровня изоляции. Дополнительные сведения см. в разделе <xref:System.Transactions.IsolationLevel>.  
  
 При использовании вложенных объектов <xref:System.Transactions.TransactionScope> все вложенные области следует настроить на использование строго одного уровня изоляции, если им необходимо присоединиться к внешней транзакции. Если при попытке присоединения вложенного объекта <xref:System.Transactions.TransactionScope> к внешней транзакции обнаруживается, что для него задан другой уровень изоляции, возникает исключение <xref:System.ArgumentException>.  
  
## <a name="interop-with-com"></a>Взаимодействие с транзакциями COM+  
 Чтобы задать способ взаимодействия с транзакциями COM+ при создании нового экземпляра <xref:System.Transactions.TransactionScope>, можно использовать перечисление <xref:System.Transactions.EnterpriseServicesInteropOption> в одном из конструкторов. Дополнительные сведения об этом см. в разделе [взаимодействие с транзакциями COM + Enterprise Services и](../../../../docs/framework/data/transactions/interoperability-with-enterprise-services-and-com-transactions.md).  
  
## <a name="see-also"></a>См. также

- <xref:System.Transactions.Transaction.Clone%2A>
- <xref:System.Transactions.TransactionScope>
