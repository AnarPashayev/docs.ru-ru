---
title: Заполнение набора данных с помощью адаптера данных DataAdapter
description: Узнайте, как заполнить набор данных из DataAdapter в ADO.NET, который предоставляет постоянную реляционную модель программирования, не зависящую от источника данных.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 3fa0ac7d-e266-4954-bfac-3fbe2f913153
ms.openlocfilehash: 3d4da840e1d51ec6f309915787caa8891db3eb59
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/02/2020
ms.locfileid: "84286667"
---
# <a name="populating-a-dataset-from-a-dataadapter"></a><span data-ttu-id="61b2a-103">Заполнение набора данных с помощью адаптера данных DataAdapter</span><span class="sxs-lookup"><span data-stu-id="61b2a-103">Populating a DataSet from a DataAdapter</span></span>
<span data-ttu-id="61b2a-104">ADO.NET <xref:System.Data.DataSet> — это резидентное представление данных, предоставляющее единообразную реляционную модель программирования независимо от источника данных.</span><span class="sxs-lookup"><span data-stu-id="61b2a-104">The ADO.NET <xref:System.Data.DataSet> is a memory-resident representation of data that provides a consistent relational programming model independent of the data source.</span></span> <span data-ttu-id="61b2a-105">Набор данных `DataSet` представляет собой полную совокупность данных, которая включает таблицы, ограничения и связи между таблицами.</span><span class="sxs-lookup"><span data-stu-id="61b2a-105">The `DataSet` represents a complete set of data that includes tables, constraints, and relationships among the tables.</span></span> <span data-ttu-id="61b2a-106">Набор данных `DataSet` является независимым от источника данных, поэтому `DataSet` может включать данные, локальные по отношению к приложению, а также данные из нескольких источников данных.</span><span class="sxs-lookup"><span data-stu-id="61b2a-106">Because the `DataSet` is independent of the data source, a `DataSet` can include data local to the application, and data from multiple data sources.</span></span> <span data-ttu-id="61b2a-107">Управление взаимодействием с существующими источниками данных осуществляется с помощью `DataAdapter`.</span><span class="sxs-lookup"><span data-stu-id="61b2a-107">Interaction with existing data sources is controlled through the `DataAdapter`.</span></span>  
  
 <span data-ttu-id="61b2a-108">Свойство `SelectCommand` объекта `DataAdapter` представляет собой объект `Command` , получающий данные из источника данных.</span><span class="sxs-lookup"><span data-stu-id="61b2a-108">The `SelectCommand` property of the `DataAdapter` is a `Command` object that retrieves data from the data source.</span></span> <span data-ttu-id="61b2a-109">Свойства `InsertCommand`, `UpdateCommand`и `DeleteCommand` , принадлежащие `DataAdapter` , являются объектами `Command` , которые управляют обновлением данных в источнике данных в соответствии с изменениями данных в `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="61b2a-109">The `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties of the `DataAdapter` are `Command` objects that manage updates to the data in the data source according to modifications made to the data in the `DataSet`.</span></span> <span data-ttu-id="61b2a-110">Эти свойства более подробно описаны в статье [Обновление источников данных с помощью DataAdapter](updating-data-sources-with-dataadapters.md).</span><span class="sxs-lookup"><span data-stu-id="61b2a-110">These properties are covered in more detail in [Updating Data Sources with DataAdapters](updating-data-sources-with-dataadapters.md).</span></span>  
  
 <span data-ttu-id="61b2a-111">Метод `Fill` объекта `DataAdapter` служит для заполнения набора данных `DataSet` результатами выполнения метода `SelectCommand` объекта `DataAdapter`.</span><span class="sxs-lookup"><span data-stu-id="61b2a-111">The `Fill` method of the `DataAdapter` is used to populate a `DataSet` with the results of the `SelectCommand` of the `DataAdapter`.</span></span> <span data-ttu-id="61b2a-112">Метод`Fill` принимает в качестве аргумента подлежащий заполнению набор данных `DataSet` , а также объект `DataTable` или имя объекта `DataTable` , который должен быть заполнен строками, возвращенными методом `SelectCommand`.</span><span class="sxs-lookup"><span data-stu-id="61b2a-112">`Fill` takes as its arguments a `DataSet` to be populated, and a `DataTable` object, or the name of the `DataTable` to be filled with the rows returned from the `SelectCommand`.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="61b2a-113">Использование `DataAdapter` для получения всей таблицы требует времени, особенно при наличии в ней большого числа строк.</span><span class="sxs-lookup"><span data-stu-id="61b2a-113">Using the `DataAdapter` to retrieve all of a table takes time, especially if there are many rows in the table.</span></span> <span data-ttu-id="61b2a-114">Это происходит вследствие того, что обращение к базе данных, обнаружение и обработка данных, а также передача данных клиенту занимают длительное время.</span><span class="sxs-lookup"><span data-stu-id="61b2a-114">This is because accessing the database, locating and processing the data, and then transferring the data to the client is time-consuming.</span></span> <span data-ttu-id="61b2a-115">Передача по запросу всей таблицы клиенту приводит также к блокировке всех строк на сервере.</span><span class="sxs-lookup"><span data-stu-id="61b2a-115">Pulling all of the table to the client also locks all of the rows on the server.</span></span> <span data-ttu-id="61b2a-116">Для повышения производительности можно использовать предложение `WHERE` , что позволяет значительно уменьшить количество строк, возвращаемых клиенту.</span><span class="sxs-lookup"><span data-stu-id="61b2a-116">To improve performance, you can use the `WHERE` clause to greatly reduce the number of rows returned to the client.</span></span> <span data-ttu-id="61b2a-117">Можно также уменьшить количество данных, возвращаемых клиенту, с помощью явно заданного списка требуемых столбцов в инструкции `SELECT` .</span><span class="sxs-lookup"><span data-stu-id="61b2a-117">You can also reduce the amount of data returned to the client by only explicitly listing required columns in the `SELECT` statement.</span></span> <span data-ttu-id="61b2a-118">Еще одним хорошим решением проблемы является получение строк в пакетах (например, содержащих несколько сотен строк одновременно), а также получение следующего пакета только после завершения обработки текущего.</span><span class="sxs-lookup"><span data-stu-id="61b2a-118">Another good workaround is to retrieve the rows in batches (such as several hundred rows at a time) and only retrieve the next batch when the client is finished with the current batch.</span></span>  
  
 <span data-ttu-id="61b2a-119">Метод `Fill` неявно использует объект `DataReader` для возврата имен и типов столбцов, используемых для создания таблиц в `DataSet`, и данных для заполнения строк таблиц в `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="61b2a-119">The `Fill` method uses the `DataReader` object implicitly to return the column names and types that are used to create the tables in the `DataSet`, and the data to populate the rows of the tables in the `DataSet`.</span></span> <span data-ttu-id="61b2a-120">Таблицы и столбцы создаются только в том случае, если они еще не существуют. В противном случае метод `Fill` использует существующую схему `DataSet` .</span><span class="sxs-lookup"><span data-stu-id="61b2a-120">Tables and columns are only created if they do not already exist; otherwise `Fill` uses the existing `DataSet` schema.</span></span> <span data-ttu-id="61b2a-121">Типы столбцов создаются как типы .NET Framework в соответствии с таблицами в [сопоставлении типов данных в ADO.NET](data-type-mappings-in-ado-net.md).</span><span class="sxs-lookup"><span data-stu-id="61b2a-121">Column types are created as .NET Framework types according to the tables in [Data Type Mappings in ADO.NET](data-type-mappings-in-ado-net.md).</span></span> <span data-ttu-id="61b2a-122">Первичные ключи не создаются, если они не существуют в источнике данных и `DataAdapter` **.**`MissingSchemaAction`</span><span class="sxs-lookup"><span data-stu-id="61b2a-122">Primary keys are not created unless they exist in the data source and `DataAdapter`**.**`MissingSchemaAction`</span></span> <span data-ttu-id="61b2a-123">имеет значение `MissingSchemaAction` **.** `AddWithKey` .</span><span class="sxs-lookup"><span data-stu-id="61b2a-123">is set to `MissingSchemaAction`**.**`AddWithKey`.</span></span> <span data-ttu-id="61b2a-124">Если `Fill` обнаруживает, что для таблицы существует первичный ключ, то данные в `DataSet` для строк, в которых значения столбцов первичного ключа совпадают со значениями в строках, возвращенных из источника данных, будут перезаписаны данными из источника данных.</span><span class="sxs-lookup"><span data-stu-id="61b2a-124">If `Fill` finds that a primary key exists for a table, it will overwrite data in the `DataSet` with data from the data source for rows where the primary key column values match those of the row returned from the data source.</span></span> <span data-ttu-id="61b2a-125">Если первичный ключ не найден, то данные добавляются в таблицы `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="61b2a-125">If no primary key is found, the data is appended to the tables in the `DataSet`.</span></span> <span data-ttu-id="61b2a-126">`Fill`использует любые сопоставления, которые могут существовать при заполнении `DataSet` (см. [таблицу DataAdapter DataTable и сопоставления DataColumn](dataadapter-datatable-and-datacolumn-mappings.md)).</span><span class="sxs-lookup"><span data-stu-id="61b2a-126">`Fill` uses any mappings that may exist when you populate the `DataSet` (see [DataAdapter DataTable and DataColumn Mappings](dataadapter-datatable-and-datacolumn-mappings.md)).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="61b2a-127">Если `SelectCommand` возвращает результаты OUTER JOIN, то `DataAdapter` не задает значение `PrimaryKey` для результирующего объекта `DataTable`.</span><span class="sxs-lookup"><span data-stu-id="61b2a-127">If the `SelectCommand` returns the results of an OUTER JOIN, the `DataAdapter` does not set a `PrimaryKey` value for the resulting `DataTable`.</span></span> <span data-ttu-id="61b2a-128">Чтобы обеспечить правильное обнаружение повторяющихся строк, пользователь должен определить первичный ключ, `PrimaryKey` .</span><span class="sxs-lookup"><span data-stu-id="61b2a-128">You must define the `PrimaryKey` yourself to make sure that duplicate rows are resolved correctly.</span></span> <span data-ttu-id="61b2a-129">Дополнительные сведения см. в разделе [Определение первичных ключей](./dataset-datatable-dataview/defining-primary-keys.md).</span><span class="sxs-lookup"><span data-stu-id="61b2a-129">For more information, see [Defining Primary Keys](./dataset-datatable-dataview/defining-primary-keys.md).</span></span>  
  
 <span data-ttu-id="61b2a-130">В следующем примере кода создается экземпляр <xref:System.Data.SqlClient.SqlDataAdapter> , в котором используется соединение <xref:System.Data.SqlClient.SqlConnection> для базы данных `Northwind` Microsoft SQL Server и заполняется <xref:System.Data.DataTable> в наборе данных `DataSet` списком клиентов.</span><span class="sxs-lookup"><span data-stu-id="61b2a-130">The following code example creates an instance of a <xref:System.Data.SqlClient.SqlDataAdapter> that uses a <xref:System.Data.SqlClient.SqlConnection> to the Microsoft SQL Server `Northwind` database and populates a <xref:System.Data.DataTable> in a `DataSet` with the list of customers.</span></span> <span data-ttu-id="61b2a-131">Инструкция SQL и аргументы <xref:System.Data.SqlClient.SqlConnection> , переданные в конструктор <xref:System.Data.SqlClient.SqlDataAdapter> , используются для создания свойства <xref:System.Data.SqlClient.SqlDataAdapter.SelectCommand%2A> объекта <xref:System.Data.SqlClient.SqlDataAdapter>.</span><span class="sxs-lookup"><span data-stu-id="61b2a-131">The SQL statement and <xref:System.Data.SqlClient.SqlConnection> arguments passed to the <xref:System.Data.SqlClient.SqlDataAdapter> constructor are used to create the <xref:System.Data.SqlClient.SqlDataAdapter.SelectCommand%2A> property of the <xref:System.Data.SqlClient.SqlDataAdapter>.</span></span>  
  
## <a name="example"></a><span data-ttu-id="61b2a-132">Пример</span><span class="sxs-lookup"><span data-stu-id="61b2a-132">Example</span></span>  
  
```vb  
' Assumes that connection is a valid SqlConnection object.  
Dim queryString As String = _  
  "SELECT CustomerID, CompanyName FROM dbo.Customers"  
Dim adapter As SqlDataAdapter = New SqlDataAdapter( _  
  queryString, connection)  
  
Dim customers As DataSet = New DataSet  
adapter.Fill(customers, "Customers")  
```  
  
```csharp  
// Assumes that connection is a valid SqlConnection object.  
string queryString =
  "SELECT CustomerID, CompanyName FROM dbo.Customers";  
SqlDataAdapter adapter = new SqlDataAdapter(queryString, connection);  
  
DataSet customers = new DataSet();  
adapter.Fill(customers, "Customers");  
```  
  
> [!NOTE]
> <span data-ttu-id="61b2a-133">Код, показанный в данном примере, не открывает и закрывает `Connection`явным образом.</span><span class="sxs-lookup"><span data-stu-id="61b2a-133">The code shown in this example does not explicitly open and close the `Connection`.</span></span> <span data-ttu-id="61b2a-134">Если соединение еще не открыто, то метод `Fill` неявно открывает `Connection` , которое используется `DataAdapter` .</span><span class="sxs-lookup"><span data-stu-id="61b2a-134">The `Fill` method implicitly opens the `Connection` that the `DataAdapter` is using if it finds that the connection is not already open.</span></span> <span data-ttu-id="61b2a-135">Если операция `Fill` открыла соединение, она также закрывает его при завершении `Fill` .</span><span class="sxs-lookup"><span data-stu-id="61b2a-135">If `Fill` opened the connection, it also closes the connection when `Fill` is finished.</span></span> <span data-ttu-id="61b2a-136">Это позволяет упростить код при использовании отдельной операции, такой как `Fill` или `Update`.</span><span class="sxs-lookup"><span data-stu-id="61b2a-136">This can simplify your code when you deal with a single operation such as a `Fill` or an `Update`.</span></span> <span data-ttu-id="61b2a-137">Однако при выполнении нескольких операций, требующих открытого соединения, можно повысить производительность приложения путем явного вызова метода `Open` объекта `Connection`, выполнения операций с источником данных и последующего вызова метода `Close` объекта `Connection`.</span><span class="sxs-lookup"><span data-stu-id="61b2a-137">However, if you are performing multiple operations that require an open connection, you can improve the performance of your application by explicitly calling the `Open` method of the `Connection`, performing the operations against the data source, and then calling the `Close` method of the `Connection`.</span></span> <span data-ttu-id="61b2a-138">Необходимо сохранять соединения с источником данных лишь на такое короткое время, насколько это возможно, освобождая ресурсы для использования другими клиентскими приложениями.</span><span class="sxs-lookup"><span data-stu-id="61b2a-138">You should try to keep connections to the data source open as briefly as possible to free resources for use by other client applications.</span></span>  
  
## <a name="multiple-result-sets"></a><span data-ttu-id="61b2a-139">Несколько результирующих наборов</span><span class="sxs-lookup"><span data-stu-id="61b2a-139">Multiple Result Sets</span></span>  
 <span data-ttu-id="61b2a-140">Если объект `DataAdapter` обнаруживает несколько результирующих наборов, то создает несколько таблиц в `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="61b2a-140">If the `DataAdapter` encounters multiple result sets, it creates multiple tables in the `DataSet`.</span></span> <span data-ttu-id="61b2a-141">Таблицы получают добавочное имя по умолчанию Table*N*, для Table0 начинающееся с «Table».</span><span class="sxs-lookup"><span data-stu-id="61b2a-141">The tables are given an incremental default name of Table*N*, starting with "Table" for Table0.</span></span> <span data-ttu-id="61b2a-142">Если имя таблицы передается в качестве аргумента методу `Fill` , то таблицы получают по умолчанию имя TableName*N*с последовательно увеличивающимся суффиксом, но начиная с «TableName», а не с TableName0.</span><span class="sxs-lookup"><span data-stu-id="61b2a-142">If a table name is passed as an argument to the `Fill` method, the tables are given an incremental default name of TableName*N*, starting with "TableName" for TableName0.</span></span>  
  
## <a name="populating-a-dataset-from-multiple-dataadapters"></a><span data-ttu-id="61b2a-143">Заполнение DataSet из нескольких адаптеров данных DataAdapter</span><span class="sxs-lookup"><span data-stu-id="61b2a-143">Populating a DataSet from Multiple DataAdapters</span></span>  
 <span data-ttu-id="61b2a-144">`DataAdapter`С можно использовать любое количество объектов `DataSet` .</span><span class="sxs-lookup"><span data-stu-id="61b2a-144">Any number of `DataAdapter` objects can be used with a `DataSet`.</span></span> <span data-ttu-id="61b2a-145">Каждый объект `DataAdapter` может использоваться для заполнения одного или более объектов `DataTable` и разрешения обновлений в соответствующем источнике данных.</span><span class="sxs-lookup"><span data-stu-id="61b2a-145">Each `DataAdapter` can be used to fill one or more `DataTable` objects and resolve updates back to the relevant data source.</span></span> <span data-ttu-id="61b2a-146">Объекты`DataRelation` и `Constraint` могут быть добавлены к `DataSet` локально, что позволяет связывать данные из разнородных источников данных.</span><span class="sxs-lookup"><span data-stu-id="61b2a-146">`DataRelation` and `Constraint` objects can be added to the `DataSet` locally, which enables you to relate data from dissimilar data sources.</span></span> <span data-ttu-id="61b2a-147">Например, `DataSet` может содержать данные из базы данных Microsoft SQL Server, из базы данных IBM DB2, доступ к которой предоставляется с помощью OLE DB, и источника данных, предназначенного для получения XML-данных в виде потока.</span><span class="sxs-lookup"><span data-stu-id="61b2a-147">For example, a `DataSet` can contain data from a Microsoft SQL Server database, an IBM DB2 database exposed through OLE DB, and a data source that streams XML.</span></span> <span data-ttu-id="61b2a-148">Один или несколько объектов `DataAdapter` могут обрабатывать соединение с каждым источником данных.</span><span class="sxs-lookup"><span data-stu-id="61b2a-148">One or more `DataAdapter` objects can handle communication to each data source.</span></span>  
  
### <a name="example"></a><span data-ttu-id="61b2a-149">Пример</span><span class="sxs-lookup"><span data-stu-id="61b2a-149">Example</span></span>  
 <span data-ttu-id="61b2a-150">В следующем примере кода заполняется список клиентов из базы данных `Northwind` Microsoft SQL Server и список заказов из базы данных `Northwind` , который хранится в Microsoft Access 2000.</span><span class="sxs-lookup"><span data-stu-id="61b2a-150">The following code example populates a list of customers from the `Northwind` database on Microsoft SQL Server, and a list of orders from the `Northwind` database stored in Microsoft Access 2000.</span></span> <span data-ttu-id="61b2a-151">Заполненные таблицы связываются с помощью `DataRelation`, и список клиентов отображает заказы данного клиента.</span><span class="sxs-lookup"><span data-stu-id="61b2a-151">The filled tables are related with a `DataRelation`, and the list of customers is then displayed with the orders for that customer.</span></span> <span data-ttu-id="61b2a-152">Дополнительные сведения об `DataRelation` объектах см. в [разделе Добавление связей](./dataset-datatable-dataview/adding-datarelations.md) DataRelation и [Навигация по связям](./dataset-datatable-dataview/navigating-datarelations.md)данных.</span><span class="sxs-lookup"><span data-stu-id="61b2a-152">For more information about `DataRelation` objects, see [Adding DataRelations](./dataset-datatable-dataview/adding-datarelations.md) and [Navigating DataRelations](./dataset-datatable-dataview/navigating-datarelations.md).</span></span>  
  
```vb  
' Assumes that customerConnection is a valid SqlConnection object.  
' Assumes that orderConnection is a valid OleDbConnection object.  
Dim custAdapter As SqlDataAdapter = New SqlDataAdapter( _  
  "SELECT * FROM dbo.Customers", customerConnection)  
  
Dim ordAdapter As OleDbDataAdapter = New OleDbDataAdapter( _  
  "SELECT * FROM Orders", orderConnection)  
  
Dim customerOrders As DataSet = New DataSet()  
custAdapter.Fill(customerOrders, "Customers")  
ordAdapter.Fill(customerOrders, "Orders")  
  
Dim relation As DataRelation = _  
  customerOrders.Relations.Add("CustOrders", _  
  customerOrders.Tables("Customers").Columns("CustomerID"), _
  customerOrders.Tables("Orders").Columns("CustomerID"))  
  
Dim pRow, cRow As DataRow  
For Each pRow In customerOrders.Tables("Customers").Rows  
  Console.WriteLine(pRow("CustomerID").ToString())  
  
  For Each cRow In pRow.GetChildRows(relation)  
    Console.WriteLine(vbTab & cRow("OrderID").ToString())  
  Next  
Next  
```  
  
```csharp  
// Assumes that customerConnection is a valid SqlConnection object.  
// Assumes that orderConnection is a valid OleDbConnection object.  
SqlDataAdapter custAdapter = new SqlDataAdapter(  
  "SELECT * FROM dbo.Customers", customerConnection);  
OleDbDataAdapter ordAdapter = new OleDbDataAdapter(  
  "SELECT * FROM Orders", orderConnection);  
  
DataSet customerOrders = new DataSet();  
  
custAdapter.Fill(customerOrders, "Customers");  
ordAdapter.Fill(customerOrders, "Orders");  
  
DataRelation relation = customerOrders.Relations.Add("CustOrders",  
  customerOrders.Tables["Customers"].Columns["CustomerID"],  
  customerOrders.Tables["Orders"].Columns["CustomerID"]);  
  
foreach (DataRow pRow in customerOrders.Tables["Customers"].Rows)  
{  
  Console.WriteLine(pRow["CustomerID"]);  
   foreach (DataRow cRow in pRow.GetChildRows(relation))  
    Console.WriteLine("\t" + cRow["OrderID"]);  
}  
```  
  
## <a name="sql-server-decimal-type"></a><span data-ttu-id="61b2a-153">Тип decimal SQL Server</span><span class="sxs-lookup"><span data-stu-id="61b2a-153">SQL Server Decimal Type</span></span>  
 <span data-ttu-id="61b2a-154">По умолчанию `DataSet` данные хранятся с помощью .NET Frameworkных типов данных.</span><span class="sxs-lookup"><span data-stu-id="61b2a-154">By default, the `DataSet` stores data by using .NET Framework data types.</span></span> <span data-ttu-id="61b2a-155">Для большинства приложений благодаря этому появляется удобный способ представления сведений об источнике данных.</span><span class="sxs-lookup"><span data-stu-id="61b2a-155">For most applications, these provide a convenient representation of data source information.</span></span> <span data-ttu-id="61b2a-156">Однако данное представление может вызвать проблему, если типом данных в источнике данных является применяемый в SQL Server тип decimal или numeric.</span><span class="sxs-lookup"><span data-stu-id="61b2a-156">However, this representation may cause a problem when the data type in the data source is a SQL Server decimal or numeric data type.</span></span> <span data-ttu-id="61b2a-157">`decimal`Тип данных .NET Framework допускает не более 28 значащих цифр, а SQL Server `decimal` тип данных допускает 38 значащих цифр.</span><span class="sxs-lookup"><span data-stu-id="61b2a-157">The .NET Framework `decimal` data type allows a maximum of 28 significant digits, whereas the SQL Server `decimal` data type allows 38 significant digits.</span></span> <span data-ttu-id="61b2a-158">Если во время операции `SqlDataAdapter``Fill` определяет, что точность поля `decimal` SQL Server больше 28 символов, текущая строка не добавляется в `DataTable`.</span><span class="sxs-lookup"><span data-stu-id="61b2a-158">If the `SqlDataAdapter` determines during a `Fill` operation that the precision of a SQL Server `decimal` field is larger than 28 characters, the current row is not added to the `DataTable`.</span></span> <span data-ttu-id="61b2a-159">Вместо этого происходит событие `FillError` , которое позволяет определить, произойдет ли потеря точности, и предпринять соответствующие действия.</span><span class="sxs-lookup"><span data-stu-id="61b2a-159">Instead the `FillError` event occurs, which enables you to determine whether a loss of precision will occur, and respond appropriately.</span></span> <span data-ttu-id="61b2a-160">Дополнительные сведения о `FillError` событии см. в разделе [Обработка событий DataAdapter](handling-dataadapter-events.md).</span><span class="sxs-lookup"><span data-stu-id="61b2a-160">For more information about the `FillError` event, see [Handling DataAdapter Events](handling-dataadapter-events.md).</span></span> <span data-ttu-id="61b2a-161">Для получения значения типа `decimal` SQL Server можно также использовать объект <xref:System.Data.SqlClient.SqlDataReader> и вызывать метод <xref:System.Data.SqlClient.SqlDataReader.GetSqlDecimal%2A> .</span><span class="sxs-lookup"><span data-stu-id="61b2a-161">To get the SQL Server `decimal` value, you can also use a <xref:System.Data.SqlClient.SqlDataReader> object and call the <xref:System.Data.SqlClient.SqlDataReader.GetSqlDecimal%2A> method.</span></span>  
  
 <span data-ttu-id="61b2a-162">В ADO.NET 2,0 введена Улучшенная поддержка <xref:System.Data.SqlTypes> в `DataSet` .</span><span class="sxs-lookup"><span data-stu-id="61b2a-162">ADO.NET 2.0 introduced enhanced support for <xref:System.Data.SqlTypes> in the `DataSet`.</span></span> <span data-ttu-id="61b2a-163">Дополнительные сведения см. в разделе [SqlTypes and the DataSet](./sql/sqltypes-and-the-dataset.md).</span><span class="sxs-lookup"><span data-stu-id="61b2a-163">For more information, see [SqlTypes and the DataSet](./sql/sqltypes-and-the-dataset.md).</span></span>  
  
## <a name="ole-db-chapters"></a><span data-ttu-id="61b2a-164">Разделы OLE DB</span><span class="sxs-lookup"><span data-stu-id="61b2a-164">OLE DB Chapters</span></span>  
 <span data-ttu-id="61b2a-165">Иерархические наборы строк, или разделы (тип `DBTYPE_HCHAPTER`в OLE DB, тип `adChapter`в ADO), могут использоваться для заполнения содержимого `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="61b2a-165">Hierarchical rowsets, or chapters (OLE DB type `DBTYPE_HCHAPTER`, ADO type `adChapter`) can be used to fill the contents of a `DataSet`.</span></span> <span data-ttu-id="61b2a-166">Когда <xref:System.Data.OleDb.OleDbDataAdapter> во время операции `Fill` обнаруживает столбец, разбитый на разделы, для этого столбца создается `DataTable` , данная таблица заполняется столбцами и строками из раздела.</span><span class="sxs-lookup"><span data-stu-id="61b2a-166">When the <xref:System.Data.OleDb.OleDbDataAdapter> encounters a chaptered column during a `Fill` operation, a `DataTable` is created for the chaptered column, and that table is filled with the columns and rows from the chapter.</span></span> <span data-ttu-id="61b2a-167">Таблице, созданной для разбитого на разделы столбца, присваивается имя, состоящее из имени родительской таблицы и имени разбитого на разделы столбца, в форме «*ParentTableNameChapteredColumnName*».</span><span class="sxs-lookup"><span data-stu-id="61b2a-167">The table created for the chaptered column is named by using both the parent table name and the chaptered column name in the form "*ParentTableNameChapteredColumnName*".</span></span> <span data-ttu-id="61b2a-168">Если в наборе данных `DataSet` уже содержится таблица, имя которой согласуется с именем разбитого на разделы столбца, то данными раздела заполняется текущая таблица.</span><span class="sxs-lookup"><span data-stu-id="61b2a-168">If a table already exists in the `DataSet` that matches the name of the chaptered column, the current table is filled with the chapter data.</span></span> <span data-ttu-id="61b2a-169">Если в существующей таблице нет столбца, совпадающего со столбцом, содержащимся в разделе, то добавляется новый столбец.</span><span class="sxs-lookup"><span data-stu-id="61b2a-169">If there is no column in an existing table that matches a column found in the chapter, a new column is added.</span></span>  
  
 <span data-ttu-id="61b2a-170">Перед заполнением таблиц в `DataSet` данными, содержащимися в разбитых на разделы столбцах, между родительской и дочерней таблицами иерархического набора строк создается связь путем добавления целочисленного столбца к родительской и дочерней таблицам, установки родительского столбца на автоприращение и создания `DataRelation` с помощью добавленных из обеих таблиц столбцов.</span><span class="sxs-lookup"><span data-stu-id="61b2a-170">Before the tables in the `DataSet` are filled with the data in the chaptered columns, a relation is created between the parent and child tables of the hierarchical rowset by adding an integer column to both the parent and child table, setting the parent column to auto-increment, and creating a `DataRelation` using the added columns from both tables.</span></span> <span data-ttu-id="61b2a-171">Добавленной связи присваивается имя с использованием имен родительской таблицы и разбитого на разделы столбца в виде «*ParentTableNameChapterColumnName*».</span><span class="sxs-lookup"><span data-stu-id="61b2a-171">The added relation is named by using the parent table and chapter column names in the form "*ParentTableNameChapterColumnName*".</span></span>  
  
 <span data-ttu-id="61b2a-172">Обратите внимание, что связанный столбец существует только в `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="61b2a-172">Note that the related column only exists in the `DataSet`.</span></span> <span data-ttu-id="61b2a-173">Дальнейшее заполнение из источника данных может вызвать добавление к таблицам новых строк вместо внесения изменений в существующие строки.</span><span class="sxs-lookup"><span data-stu-id="61b2a-173">Subsequent fills from the data source can cause new rows to be added to the tables instead of changes being merged into existing rows.</span></span>  
  
 <span data-ttu-id="61b2a-174">Обратите внимание, что при использовании перегруженного метода `DataAdapter.Fill` , который принимает `DataTable`в качестве аргумента, заполняется только эта таблица.</span><span class="sxs-lookup"><span data-stu-id="61b2a-174">Note also that, if you use the `DataAdapter.Fill` overload that takes a `DataTable`, only that table will be filled.</span></span> <span data-ttu-id="61b2a-175">Целочисленный столбец с автоприращением все еще можно добавить в таблицу, но нельзя создать или заполнить дочернюю таблицу, а также нельзя создать связь.</span><span class="sxs-lookup"><span data-stu-id="61b2a-175">An auto-incrementing integer column will still be added to the table, but no child table will be created or filled, and no relation will be created.</span></span>  
  
 <span data-ttu-id="61b2a-176">В следующем примере используется поставщик MSDataShape для создания разбитого на разделы столбца для каждого клиента из списка клиентов.</span><span class="sxs-lookup"><span data-stu-id="61b2a-176">The following example uses the MSDataShape Provider to generate a chapter column of orders for each customer in a list of customers.</span></span> <span data-ttu-id="61b2a-177">После этого `DataSet` заполняется данными.</span><span class="sxs-lookup"><span data-stu-id="61b2a-177">A `DataSet` is then filled with the data.</span></span>  
  
```vb  
Using connection As OleDbConnection = New OleDbConnection( _  
  "Provider=MSDataShape;Data Provider=SQLOLEDB;" & _  
  "Data Source=(local);Integrated " & _  
  "Security=SSPI;Initial Catalog=northwind")  
  
Dim adapter As OleDbDataAdapter = New OleDbDataAdapter( _  
  "SHAPE {SELECT CustomerID, CompanyName FROM Customers} " & _  
  "APPEND ({SELECT CustomerID, OrderID FROM Orders} AS Orders " & _  
  "RELATE CustomerID TO CustomerID)", connection)  
  
Dim customers As DataSet = New DataSet()  
  
adapter.Fill(customers, "Customers")  
End Using  
```  
  
```csharp  
using (OleDbConnection connection = new OleDbConnection("Provider=MSDataShape;Data Provider=SQLOLEDB;" +  
  "Data Source=(local);Integrated Security=SSPI;Initial Catalog=northwind"))  
{  
OleDbDataAdapter adapter = new OleDbDataAdapter("SHAPE {SELECT CustomerID, CompanyName FROM Customers} " +  
  "APPEND ({SELECT CustomerID, OrderID FROM Orders} AS Orders " +  
  "RELATE CustomerID TO CustomerID)", connection);  
  
DataSet customers = new DataSet();  
adapter.Fill(customers, "Customers");  
}  
```  
  
 <span data-ttu-id="61b2a-178">Когда операция `Fill` завершена, набор данных `DataSet` содержит две таблицы: `Customers` и `CustomersOrders`, в которых `CustomersOrders` представляет столбец, разбитый на разделы.</span><span class="sxs-lookup"><span data-stu-id="61b2a-178">When the `Fill` operation is complete, the `DataSet` contains two tables: `Customers` and `CustomersOrders`, where `CustomersOrders` represents the chaptered column.</span></span> <span data-ttu-id="61b2a-179">Дополнительный столбец с именем `Orders` добавляется к таблице `Customers` , а дополнительный столбец с именем `CustomersOrders` добавляется к таблице `CustomersOrders` .</span><span class="sxs-lookup"><span data-stu-id="61b2a-179">An additional column named `Orders` is added to the `Customers` table, and an additional column named `CustomersOrders` is added to the `CustomersOrders` table.</span></span> <span data-ttu-id="61b2a-180">Столбец `Orders` в таблице `Customers` устанавливается на автоприращение.</span><span class="sxs-lookup"><span data-stu-id="61b2a-180">The `Orders` column in the `Customers` table is set to auto-increment.</span></span> <span data-ttu-id="61b2a-181">`DataRelation`, `CustomersOrders`, создается с помощью столбцов, которые были добавлены к таблицам с `Customers` в виде дочерней таблицы.</span><span class="sxs-lookup"><span data-stu-id="61b2a-181">A `DataRelation`, `CustomersOrders`, is created by using the columns that were added to the tables with `Customers` as the parent table.</span></span> <span data-ttu-id="61b2a-182">Следующие таблицы показывают некоторые образцы результатов.</span><span class="sxs-lookup"><span data-stu-id="61b2a-182">The following tables show some sample results.</span></span>  
  
### <a name="tablename-customers"></a><span data-ttu-id="61b2a-183">TableName: Customers</span><span class="sxs-lookup"><span data-stu-id="61b2a-183">TableName: Customers</span></span>  
  
|<span data-ttu-id="61b2a-184">CustomerID</span><span class="sxs-lookup"><span data-stu-id="61b2a-184">CustomerID</span></span>|<span data-ttu-id="61b2a-185">CompanyName</span><span class="sxs-lookup"><span data-stu-id="61b2a-185">CompanyName</span></span>|<span data-ttu-id="61b2a-186">Orders</span><span class="sxs-lookup"><span data-stu-id="61b2a-186">Orders</span></span>|  
|----------------|-----------------|------------|  
|<span data-ttu-id="61b2a-187">ALFKI</span><span class="sxs-lookup"><span data-stu-id="61b2a-187">ALFKI</span></span>|<span data-ttu-id="61b2a-188">Alfreds Futterkiste</span><span class="sxs-lookup"><span data-stu-id="61b2a-188">Alfreds Futterkiste</span></span>|<span data-ttu-id="61b2a-189">0</span><span class="sxs-lookup"><span data-stu-id="61b2a-189">0</span></span>|  
|<span data-ttu-id="61b2a-190">ANATR</span><span class="sxs-lookup"><span data-stu-id="61b2a-190">ANATR</span></span>|<span data-ttu-id="61b2a-191">Ana Trujillo Emparedados y helados</span><span class="sxs-lookup"><span data-stu-id="61b2a-191">Ana Trujillo Emparedados y helados</span></span>|<span data-ttu-id="61b2a-192">1</span><span class="sxs-lookup"><span data-stu-id="61b2a-192">1</span></span>|  
  
### <a name="tablename-customersorders"></a><span data-ttu-id="61b2a-193">TableName: CustomersOrders</span><span class="sxs-lookup"><span data-stu-id="61b2a-193">TableName: CustomersOrders</span></span>  
  
|<span data-ttu-id="61b2a-194">CustomerID</span><span class="sxs-lookup"><span data-stu-id="61b2a-194">CustomerID</span></span>|<span data-ttu-id="61b2a-195">OrderID</span><span class="sxs-lookup"><span data-stu-id="61b2a-195">OrderID</span></span>|<span data-ttu-id="61b2a-196">CustomersOrders</span><span class="sxs-lookup"><span data-stu-id="61b2a-196">CustomersOrders</span></span>|  
|----------------|-------------|---------------------|  
|<span data-ttu-id="61b2a-197">ALFKI</span><span class="sxs-lookup"><span data-stu-id="61b2a-197">ALFKI</span></span>|<span data-ttu-id="61b2a-198">10643</span><span class="sxs-lookup"><span data-stu-id="61b2a-198">10643</span></span>|<span data-ttu-id="61b2a-199">0</span><span class="sxs-lookup"><span data-stu-id="61b2a-199">0</span></span>|  
|<span data-ttu-id="61b2a-200">ALFKI</span><span class="sxs-lookup"><span data-stu-id="61b2a-200">ALFKI</span></span>|<span data-ttu-id="61b2a-201">10692</span><span class="sxs-lookup"><span data-stu-id="61b2a-201">10692</span></span>|<span data-ttu-id="61b2a-202">0</span><span class="sxs-lookup"><span data-stu-id="61b2a-202">0</span></span>|  
|<span data-ttu-id="61b2a-203">ANATR</span><span class="sxs-lookup"><span data-stu-id="61b2a-203">ANATR</span></span>|<span data-ttu-id="61b2a-204">10308</span><span class="sxs-lookup"><span data-stu-id="61b2a-204">10308</span></span>|<span data-ttu-id="61b2a-205">1</span><span class="sxs-lookup"><span data-stu-id="61b2a-205">1</span></span>|  
|<span data-ttu-id="61b2a-206">ANATR</span><span class="sxs-lookup"><span data-stu-id="61b2a-206">ANATR</span></span>|<span data-ttu-id="61b2a-207">10625</span><span class="sxs-lookup"><span data-stu-id="61b2a-207">10625</span></span>|<span data-ttu-id="61b2a-208">1</span><span class="sxs-lookup"><span data-stu-id="61b2a-208">1</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="61b2a-209">См. также</span><span class="sxs-lookup"><span data-stu-id="61b2a-209">See also</span></span>

- [<span data-ttu-id="61b2a-210">Объекты DataAdapter и DataReader</span><span class="sxs-lookup"><span data-stu-id="61b2a-210">DataAdapters and DataReaders</span></span>](dataadapters-and-datareaders.md)
- [<span data-ttu-id="61b2a-211">Сопоставления типов данных в ADO.NET</span><span class="sxs-lookup"><span data-stu-id="61b2a-211">Data Type Mappings in ADO.NET</span></span>](data-type-mappings-in-ado-net.md)
- [<span data-ttu-id="61b2a-212">Изменение данных с помощью DbDataAdapter</span><span class="sxs-lookup"><span data-stu-id="61b2a-212">Modifying Data with a DbDataAdapter</span></span>](modifying-data-with-a-dbdataadapter.md)
- [<span data-ttu-id="61b2a-213">Режим MARS</span><span class="sxs-lookup"><span data-stu-id="61b2a-213">Multiple Active Result Sets (MARS)</span></span>](./sql/multiple-active-result-sets-mars.md)
- [<span data-ttu-id="61b2a-214">Общие сведения об ADO.NET</span><span class="sxs-lookup"><span data-stu-id="61b2a-214">ADO.NET Overview</span></span>](ado-net-overview.md)
