---
title: Известные проблемы SqlClient для Entity Framework
ms.date: 03/30/2017
ms.assetid: 48fe4912-4d0f-46b6-be96-3a42c54780f6
ms.openlocfilehash: 0938c57f48a062082fe973a670eb6a9b9fc4ed3c
ms.sourcegitcommit: 2e95559d957a1a942e490c5fd916df04b39d73a9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/16/2019
ms.locfileid: "72395517"
---
# <a name="known-issues-in-sqlclient-for-entity-framework"></a>Известные проблемы SqlClient для Entity Framework
В данном разделе описаны известные проблемы, связанные с поставщиком данных .NET Framework для SQL Server (SqlClient).  
  
## <a name="trailing-spaces-in-string-functions"></a>Конечные пробелы в строковых функциях  
 SQL Server игнорирует конечные пробелы в строковых значениях. Таким образом, передача конечных пробелов в строку может привести к непредсказуемым результатам и даже сбоям.  
  
 Если в строке должны находиться конечные пробелы, следует рассмотреть возможность добавления символа пробела в конец, чтобы SQL Server не обрезать строку. Если конечные пробелы не требуются, их следует усекать до их последующей передачи по конвейеру запросов.  
  
## <a name="right-function"></a>RIGHT, функция  
 Если в `null`, 0`RIGHT(nvarchar(max)` или `)`, 0`RIGHT(varchar(max)` в качестве первого аргумента передается значение, отличное от `)`, а в качестве второго аргумента передается значение, равное 0, то вместо строки `NULL` будет возвращено значение типа `empty`.  
  
## <a name="cross-and-outer-apply-operators"></a>Операторы CROSS APPLY и OUTER APPLY  
 Операторы пересечения и НАРУЖного применения появились в SQL Server 2005. В некоторых случаях конвейер запросов может сформировать инструкцию Transact-SQL, содержащую операторы CROSS APPLY и OUTER APPLY. Поскольку некоторые серверные поставщики, включая версии SQL Server более ранние, чем SQL Server 2005, не поддерживают эти операторы, такие запросы не могут выполняться на этих внутренних поставщиках.  
  
 Далее показаны некоторые стандартные сценарии, которые могут привести к появлению операторов CROSS APPLY и OUTER APPLY в выходном запросе.  
  
- Связанный вложенный запрос с разбиением на страницы.  
  
- `AnyElement` над коррелированным вложенным запросом или коллекцией, сформированной навигацией.  
  
- LINQ-запросы, использующие методы группирования, принимающие элемент selector.  
  
- Запрос, в котором явно указан оператор CROSS APPLY или OUTER APPLY.  
  
- Запрос, имеющий конструкцию DEREF над конструкцией REF.  
  
## <a name="skip-operator"></a>Оператор SKIP  
 Если используется SQL Server 2000, использование инструкции SKIP с предложением ORDER BY в неключевых столбцах может привести к возврату неверных результатов. Если неключевой столбец содержит повторяющиеся данные, то может быть пропущено больше указанного числа строк. Это происходит из-за преобразования SKIP для SQL Server 2000. Например, в следующем запросе более пяти строк может быть пропущено, если `E.NonKeyColumn` содержит дублирующиеся значения:  
  
```  
SELECT [E] FROM Container.EntitySet AS [E] ORDER BY [E].[NonKeyColumn] DESC SKIP 5L  
```  
  
## <a name="targeting-the-correct-sql-server-version"></a>Нацеливание на правильную версию SQL Server  
 Entity Framework предназначен для запроса Transact-SQL на основе версии SQL Server, указанной в атрибуте `ProviderManifestToken` элемента Schema в файле модели хранения (. SSDL). Данная версия может отличаться от фактической версии SQL Server, с которой в данный момент осуществлено соединение. Например, если вы используете SQL Server 2005, но атрибут `ProviderManifestToken` имеет значение 2008, созданный запрос Transact-SQL может не выполняться на сервере. Например, запрос, который использует новые типы даты и времени, представленные в SQL Server 2008, не будет выполняться в предыдущих версиях SQL Server. Если вы используете SQL Server 2005, но атрибут `ProviderManifestToken` имеет значение 2000, созданный запрос Transact-SQL может оказаться менее оптимизированным, иначе может возникнуть исключение, сообщающее, что запрос не поддерживается. Дополнительные сведения см. в разделе «Операторы CROSS и OUTER APPLY», приведенном выше в данной теме.  
  
 Некоторые варианты поведения базы данных зависят от уровня совместимости, установленного на базе данных. Если атрибут `ProviderManifestToken` имеет значение 2005, а версия SQL Server — 2005, но для уровня совместимости базы данных задано значение "80" (SQL Server 2000), то созданный Transact-SQL будет нацеливанием SQL Server 2005, но может не выполняться должным образом из-за параметр уровня совместимости. Например, если имя столбца в списке ORDER BY совпадает с именем столбца в селекторе, то можно потерять данные об упорядочивании.  
  
## <a name="nested-queries-in-projection"></a>Вложенные запросы в проекции  
 Вложенные запросы в предложении проекции могут быть переведены в запросы декартовых произведений на сервере. На некоторых внутренних серверах, в том числе SQL Server, это может привести к тому, что таблица TempDB будет иметь довольно большой размер. Это может снизить производительность сервера.  
  
 Далее приведен пример вложенного запроса в предложении проекции:  
  
```  
SELECT c, (SELECT c, (SELECT c FROM AdventureWorksModel.Vendor AS c  ) As Inner2 FROM AdventureWorksModel.JobCandidate AS c  ) As Inner1 FROM AdventureWorksModel.EmployeeDepartmentHistory AS c  
```  
  
## <a name="server-generated-guid-identity-values"></a>Формируемые сервером значения идентификаторов GUID  
 Entity Framework поддерживает генерируемые сервером значения идентификаторов типа GUID, но поставщик должен поддерживать возврат сформированного сервером значения идентификатора после вставки строки. Начиная с SQL Server 2005, можно вернуть созданный сервером тип GUID в базе данных SQL Server с помощью [предложения OUTPUT](https://go.microsoft.com/fwlink/?LinkId=169400) .  
  
## <a name="see-also"></a>См. также

- [SqlClient для Entity Framework](sqlclient-for-the-entity-framework.md)
- [Рекомендации и известные проблемы в LINQ to Entities](./language-reference/known-issues-and-considerations-in-linq-to-entities.md)
