---
title: FROM (Entity SQL)
ms.date: 03/30/2017
ms.assetid: ff3e3048-0d5d-4502-ae5c-9187fcbd0514
ms.openlocfilehash: 3cc02b4c51b32d0faace4d89d0c6c1f6923dd138
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/08/2019
ms.locfileid: "59119838"
---
# <a name="from-entity-sql"></a>FROM (Entity SQL)
Указывает коллекцию, используемую в [ВЫБЕРИТЕ](../../../../../../docs/framework/data/adonet/ef/language-reference/select-entity-sql.md) инструкций.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
FROM expression [ ,...n ] as C  
```  
  
## <a name="arguments"></a>Аргументы  
 `expression`  
 Любое допустимое выражение запроса, возвращающее коллекцию, которая используется как источник в инструкции `SELECT`.  
  
## <a name="remarks"></a>Примечания  
 Предложение `FROM` - это список с разделителями-запятыми из одного или нескольких элементов предложения `FROM`. Предложение `FROM` может быть использовано, чтобы указать один или несколько источников для инструкции `SELECT`. Самая простая форма предложения `FROM` - единственное выражение запроса, которое определяет коллекцию и псевдоним, использованные как источники в инструкции `SELECT`, как показано в следующем примере.  
  
 `FROM C as c`  
  
## <a name="from-clause-items"></a>Элементы предложения FROM  
 Каждый элемент предложения `FROM` ссылается на исходную коллекцию в запросе [!INCLUDE[esql](../../../../../../includes/esql-md.md)]. [!INCLUDE[esql](../../../../../../includes/esql-md.md)] поддерживает следующие классы `FROM` элементов предложения: простой `FROM` элементов предложения `JOIN FROM` элементов предложения и `APPLY FROM` элементов предложения. Каждый из этих элементов предложения `FROM` более подробно описан в следующих разделах.  
  
### <a name="simple-from-clause-item"></a>Простой элемент предложения FROM  
 Самый простой элемент предложения `FROM` - единственное выражение, которое определяет коллекцию и псевдоним. Выражение может быть просто набором сущностей, вложенным запросом или другим выражением, которое относится к типу коллекции. Ниже представлен пример такого кода.  
  
```  
LOB.Customers as c  
```  
  
 Спецификация псевдонима является необязательным элементом. Альтернативная спецификация приведенного выше элемента предложения from может быть следующей:  
  
```  
LOB.Customers  
```  
  
 Если псевдоним не задан, то [!INCLUDE[esql](../../../../../../includes/esql-md.md)] попытается сформировать псевдоним на основе выражения коллекции.  
  
### <a name="join-from-clause-item"></a>Элемент предложения JOIN FROM  
 Элемент предложения `JOIN FROM` представляет соединение между двумя элементами предложения `FROM`. [!INCLUDE[esql](../../../../../../includes/esql-md.md)] поддерживает перекрестные соединения, внутренние соединения, левые и правые внешние соединения и полные внешние соединения. Все эти соединения поддерживаются подобно тому, как они поддерживались в [!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]. Как в [!INCLUDE[tsql](../../../../../../includes/tsql-md.md)], два элемента предложения `FROM`, задействованные в `JOIN`, должны быть независимыми (т. е. они не могут быть коррелированными). В этих случаях можно использовать операторы `CROSS APPLY` или `OUTER APPLY`.  
  
#### <a name="cross-joins"></a>Перекрестные соединения  
 Выражение запроса `CROSS JOIN` формируют декартово произведение двух коллекций, как показано в следующем примере:  
  
 `FROM C AS c CROSS JOIN D as d`  
  
#### <a name="inner-joins"></a>Внутренние соединения  
 Оператор `INNER JOIN` формирует ограниченное декартово произведение двух коллекций, как показано в следующем примере:  
  
 `FROM C AS c [INNER] JOIN D AS d ON e`  
  
 Предшествующее выражение запроса обрабатывает сочетание каждого элемента коллекции слева, сопоставленного каждому элементу коллекции справа, где условие `ON` имеет значение TRUE. Если не указано условие `ON`, соединение `INNER JOIN` вырождается в `CROSS JOIN`.  
  
#### <a name="left-outer-joins-and-right-outer-joins"></a>Левые и правые внешние соединения  
 Выражение запроса `OUTER JOIN` формирует ограниченное декартово произведение двух коллекций, как показано в следующем примере:  
  
 `FROM C AS c LEFT OUTER JOIN D AS d ON e`  
  
 Предшествующее выражение запроса обрабатывает сочетание каждого элемента коллекции слева, сопоставленного каждому элементу коллекции справа, где условие `ON` имеет значение TRUE. Если условие `ON` не выполняется, выражение все же обрабатывает единственный экземпляр элемента слева, поставленный в соответствие элементу справа, со значением NULL.  
  
 Оператор `RIGHT OUTER JOIN` можно выразить аналогичным способом.  
  
#### <a name="full-outer-joins"></a>Полные внешние соединения  
 Явное соединение `FULL OUTER JOIN` формирует ограниченное декартово произведение двух коллекций, как показано в следующем примере:  
  
 `FROM C AS c FULL OUTER JOIN D AS d ON e`  
  
 Предшествующее выражение запроса обрабатывает сочетание каждого элемента коллекции слева, сопоставленного каждому элементу коллекции справа, где условие `ON` имеет значение TRUE. Если условие `ON` не выполняется, выражение все же обрабатывает один экземпляр элемента слева, поставленный в соответствие элементу справа, со значением NULL. Выражение также обрабатывает один экземпляр элемента справа, сопоставленный с элементом слева, со значением NULL.  
  
> [!NOTE]
>  Чтобы сохранить совместимость с SQL-92, в языке [!INCLUDE[tsql](../../../../../../includes/tsql-md.md)] ключевое слово OUTER не является обязательным. Поэтому `LEFT JOIN`, `RIGHT JOIN` и `FULL JOIN` являются синонимами для `LEFT OUTER JOIN`, `RIGHT OUTER JOIN` и `FULL OUTER JOIN`.  
  
### <a name="apply-clause-item"></a>Элемент предложения APPLY  
 [!INCLUDE[esql](../../../../../../includes/esql-md.md)] поддерживает два типа из `APPLY`: `CROSS APPLY` и `OUTER APPLY`.  
  
 `CROSS APPLY` формирует уникальную пару каждого элемента коллекции слева с элементом коллекции, полученным путем вычисления выражения справа. При использовании оператора `CROSS APPLY`, выражение справа функционально зависимо от элемента слева, как показано в следующем примере связанной коллекции:  
  
 `SELECT c, f FROM C AS c CROSS APPLY c.Assoc AS f`  
  
 Поведение `CROSS APPLY` аналогично поведению списка соединения. Если выражение справа принимает значение пустой коллекции, оператор `CROSS APPLY` не формирует пар для этого экземпляра элемента слева.  
  
 Оператор `OUTER APPLY` похож на `CROSS APPLY`, но пары формируются, даже если выражение справа принимает значение пустой коллекции. Ниже приведен пример оператора `OUTER APPLY`:  
  
 `SELECT c, f FROM C AS c OUTER APPLY c.Assoc AS f`  
  
> [!NOTE]
>  В отличие от языка [!INCLUDE[tsql](../../../../../../includes/tsql-md.md)], в [!INCLUDE[esql](../../../../../../includes/esql-md.md)] не требуется явный шаг для устранения вложенности.  
  
> [!NOTE]
>  `CROSS` и `OUTER APPLY` операторы были представлены в [!INCLUDE[ssVersion2005](../../../../../../includes/ssversion2005-md.md)]. В некоторых случаях конвейер запросов может сформировать код Transact-SQL, который содержит операторы `CROSS APPLY` и `OUTER APPLY`. Так как некоторые внутренние поставщики, включая версии SQL Server более ранней, чем [!INCLUDE[ssVersion2005](../../../../../../includes/ssversion2005-md.md)], не поддерживают данные операторы, эти запросы нельзя выполнить на данных поставщиках.  
>   
>  Некоторыми типичными сценариями, которые бы могли привести к появлению операторов `CROSS APPLY` и (или) `OUTER APPLY` в выходном запросе, являются: связанный вложенный запрос с подкачкой страниц; AnyElement со связанным вложенным запросом или с коллекцией, полученной путем навигации; запросы LINQ, в которых используются методы группирования, принимающие селектор элементов; запрос, в котором явно указан оператор `CROSS APPLY` или `OUTER APPLY`; запрос с конструкцией `DEREF` для конструкции `REF`.  
  
## <a name="multiple-collections-in-the-from-clause"></a>Несколько коллекций в предложении FROM  
 Предложение `FROM` может содержать одну и более коллекций, разделенных запятыми. В таких случаях коллекции считаются объединенными. Такую структуру можно считать n-сторонним соединением CROSS JOIN.  
  
 В следующем примере `C` и `D` являются независимыми коллекциями, но `c.Names` зависит от `C`.  
  
```  
FROM C AS c, D AS d, c.Names AS e  
```  
  
 Предыдущий пример логически эквивалентен следующему примеру:  
  
 `FROM (C AS c JOIN D AS d) CROSS APPLY c.Names AS e`  
  
## <a name="left-correlation"></a>Левая корреляция  
 Элементы в предложении `FROM` могут ссылаться на элементы, указанные в более ранних предложениях. В следующем примере `C` и `D` являются независимыми коллекциями, но `c.Names` зависит от `C`:  
  
```  
from C as c, D as d, c.Names as e  
```  
  
 Это логически равносильно:  
  
```  
from (C as c join D as d) cross apply c.Names as e  
```  
  
## <a name="semantics"></a>Семантика  
 Логически предполагается, что коллекции в предложении `FROM` - часть `n`-стороннего перекрестного соединения (за исключением случая 1-стороннего перекрестного соединения). Псевдонимы в предложении `FROM` обрабатываются слева направо и добавляются в текущую область для последующего применения. Предполагается, что предложение `FROM` формирует мультинабор строк. В предложении `FROM` будет одно поле для каждого элемента, которое представляет единственный элемент из этого элемента сбора.  
  
 Предложение `FROM` логически формирует мультинабор строк типа Row(c, d, e); при этом предполагается, что поля c, d и e являются элементами типа `C`, `D` и `c.Names`.  
  
 [!INCLUDE[esql](../../../../../../includes/esql-md.md)] появился псевдоним для каждого простого `FROM` элемент предложения в области видимости. Например, в следующем фрагменте предложения FROM в область введены имена c, d и e.  
  
```  
from (C as c join D as d) cross apply c.Names as e  
```  
  
 В [!INCLUDE[esql](../../../../../../includes/esql-md.md)] (в отличие от [!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]) предложение `FROM` только вводит псевдонимы в область. Любые обращения к столбцам (свойствам) этих коллекций нужно уточнить с помощью псевдонима.  
  
## <a name="pulling-up-keys-from-nested-queries"></a>Извлечение ключей из вложенных запросов  
 Определенные типы запросов, для которых требуется извлечь ключи из вложенного запроса, не поддерживаются. Например, допустим следующий запрос:  
  
```  
select c.Orders from Customers as c   
```  
  
 Однако следующий запрос является недопустимым, так как вложенный запрос не содержит ключей:  
  
```  
select {1} from {2, 3}  
```  
  
## <a name="see-also"></a>См. также

- [Справочник по Entity SQL](../../../../../../docs/framework/data/adonet/ef/language-reference/entity-sql-reference.md)
- [Выражения запросов](../../../../../../docs/framework/data/adonet/ef/language-reference/query-expressions-entity-sql.md)
- [Допускающие значения NULL структурированные типы](../../../../../../docs/framework/data/adonet/ef/language-reference/nullable-structured-types-entity-sql.md)
