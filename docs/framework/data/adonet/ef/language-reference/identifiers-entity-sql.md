---
title: Идентификаторы (Entity SQL)
ms.date: 03/30/2017
ms.assetid: d58a5edd-7b5c-48e1-b5d7-a326ff426aa4
ms.openlocfilehash: 702a9c69c37b572fde18dd57c44608678174fb15
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/08/2019
ms.locfileid: "59204904"
---
# <a name="identifiers-entity-sql"></a>Идентификаторы (Entity SQL)
В языке [!INCLUDE[esql](../../../../../../includes/esql-md.md)] идентификаторы используются для представления псевдонимов выражений запросов, ссылок на переменные, свойств объектов, функций и т. д. [!INCLUDE[esql](../../../../../../includes/esql-md.md)] имеются два вида идентификаторов: простые идентификаторы и заключенные в кавычки идентификаторы.  
  
## <a name="simple-identifiers"></a>Простые идентификаторы  
 Простой идентификатор в [!INCLUDE[esql](../../../../../../includes/esql-md.md)] — это последовательность алфавитно-цифровых символов и подчеркиваний. Первым символом в идентификаторе должен быть алфавитный символ (a-z или A-Z).  
  
## <a name="quoted-identifiers"></a>Заключенные в кавычки идентификаторы  
 Заключенный в кавычки идентификатор - это любая последовательность символов, заключенная в квадратные скобки ([]). Заключенные в кавычки идентификаторы позволяют задавать идентификаторы с символами, которые нельзя использовать в простых идентификаторах. Все символы внутри квадратных скобок становятся частью идентификатора, включая все пробелы.  
  
 Заключенный в кавычки идентификатор не может содержать следующие символы.  
  
-   Перевод строки.  
  
-   Возврат каретки.  
  
-   Табуляция.  
  
-   Возврат на одну позицию назад.  
  
-   Дополнительные квадратные скобки (то есть квадратные скобки внутри квадратных скобок, выделяющих идентификатор).  
  
 Заключенный в кавычки идентификатор может содержать символы Юникода.  
  
 Как показано в следующем примере, заключенные в кавычки идентификаторы позволяют создавать символы для имен свойств, которые нельзя использовать в простых идентификаторах:  
  
 `SELECT c.ContactName AS [Contact Name] FROM customers AS c`  
  
 Заключенные в кавычки идентификаторы можно также использовать, чтобы задавать идентификаторы, которые являются зарезервированными ключевыми словами [!INCLUDE[esql](../../../../../../includes/esql-md.md)]. Например, если у типа `Email` есть свойство «From», то при помощи квадратных скобок его можно отличить от зарезервированного ключевого слова FROM следующим образом:  
  
 `SELECT e.[From] FROM emails AS e`  
  
 Заключенный в кавычки идентификатор можно использовать в правой части оператора «точка» (.).  
  
 `SELECT t FROM ts as t WHERE t.[property] == 2`  
  
 Чтобы использовать в идентификаторе квадратную скобку, добавьте дополнительную квадратную скобку. В следующем примере «`abc]`» является идентификатором.  
  
 `SELECT t from ts as t WHERE t.[abc]]] == 2`  
  
 Семантика сравнения заключенный в кавычки идентификатор, см. в разделе [набор символов ввода](../../../../../../docs/framework/data/adonet/ef/language-reference/input-character-set-entity-sql.md).  
  
## <a name="aliasing-rules"></a>Правила присвоения псевдонимов  
 Рекомендуется задавать псевдонимы в [!INCLUDE[esql](../../../../../../includes/esql-md.md)] запрашивает при необходимости, включая следующие [!INCLUDE[esql](../../../../../../includes/esql-md.md)] конструкции:  
  
-   Поля конструктора строк.  
  
-   Элементы в предложении FROM выражения запроса.  
  
-   Элементы в предложении SELECT выражения запроса.  
  
-   Элементы в предложении GROUP BY выражения запроса.  
  
### <a name="valid-aliases"></a>Допустимые псевдонимы  
 Допустимые псевдонимы в [!INCLUDE[esql](../../../../../../includes/esql-md.md)] являются любой простой или заключенный в кавычки идентификатор.  
  
### <a name="alias-generation"></a>Создание псевдонима  
 Если псевдоним не указан в [!INCLUDE[esql](../../../../../../includes/esql-md.md)] выражение запроса, [!INCLUDE[esql](../../../../../../includes/esql-md.md)] попытается сформировать псевдоним на основе следующих простых правил:  
  
-   Если выражение запроса (в котором не задан псевдоним) является простым или заключенным в кавычки идентификатором, то он используется в качестве псевдонима. Например, запись `ROW(a, [b])` преобразуется в `ROW(a AS a, [b] AS [b])`.  
  
-   Если выражение запроса более сложное, но последним его компонентом является простой идентификатор, тогда в качестве псевдонима используется этот идентификатор. Например, запись `ROW(a.a1, b.[b1])` преобразуется в `ROW(a.a1 AS a1, b.[b1] AS [b1])`.  
  
 Если в будущем планируется использование псевдонима, не рекомендуется прибегать к неявному присвоению псевдонимов. Результатом любого конфликта псевдонимов (неявных или явных) или их повторения в одной области будет ошибка компиляции. Неявный псевдоним пройдет компиляцию при наличии явного или неявного псевдонима с таким же именем.  
  
 Неявные псевдонимы формируются автоматически на основе ввода пользователя. Например, следующая строка кода сформирует для обоих столбцов псевдоним NAME, что приведет к конфликту.  
  
```  
SELECT product.NAME, person.NAME  
```  
  
 Следующая строка кода, в которой использованы явные псевдонимы, также завершится неудачно. Однако, прочитав код, можно яснее увидеть ошибку.  
  
```  
SELECT 1 AS X, 2 AS X …  
```  
  
## <a name="scoping-rules"></a>Правила области видимости  
 [!INCLUDE[esql](../../../../../../includes/esql-md.md)] Определяет правила выбора области, которые определяют, когда конкретные переменные являются видимыми в языке запросов. Некоторые выражения или инструкции вводят новые имена. Правила области определяют, где можно использовать эти имена, а также когда и где новая декларация с таким же именем, как у другой, может скрывать предшествующую ей декларацию.  
  
 Если имена определяются в [!INCLUDE[esql](../../../../../../includes/esql-md.md)] запроса, они называются определены в области. Область охватывает весь регион запроса. Все выражения или ссылки на имена в конкретной области могут видеть имена, определенные в этой области. На имена, определенные в данной области, нельзя ссылаться до начала области и после ее конца.  
  
 Области могут быть вложенными. Части [!INCLUDE[esql](../../../../../../includes/esql-md.md)] вводят новые области, охватывающие регионы целиком, а эти регионы могут содержать другие [!INCLUDE[esql](../../../../../../includes/esql-md.md)] выражений, которые также вводят области. Когда есть вложенные области, можно ссылаться на имена, определенные в самой глубоко вложенной области, которая содержит ссылку. Также можно создавать ссылки на любые имена, определенные в любых внешних областях. Любые две области, находящиеся внутри одной области, считаются областями одного уровня. Нельзя создавать ссылки на имена, определенные в разных областях одного уровня.  
  
 Если имя, объявленное во внутренней области, совпадает с именем, объявленным во внешней области, ссылки внутри этой внутренней области или внутри областей, объявленных внутри этой области, указывают только на вновь объявленное имя. Имя во внешней области скрыто.  
  
 Нельзя создавать ссылки на имена до их объявления, даже внутри одной области.  
  
 Глобальные имена могут существовать как часть среды выполнения. Это могут быть имена постоянных коллекций или переменных среды. Чтобы имя стало глобальным, его необходимо объявить в наиболее внешней области.  
  
 Параметры не входят в области. Поскольку ссылки на параметры содержат специальный синтаксис, имена параметров никогда не конфликтуют с другими именами в запросе.  
  
### <a name="query-expressions"></a>Выражения запросов  
 [!INCLUDE[esql](../../../../../../includes/esql-md.md)] Выражение вводит новую область запроса. Имена, определенные в предложении FROM, вводятся в область from в порядке появления, слева направо. В списке соединений выражения могут ссылаться на имена, которые определены в списке ранее. Открытые свойства (поля и так далее) элементов, идентифицированных в предложении FROM, в область from не добавляются. В ссылке на них следует всегда использовать имя псевдонима. Обычно считается, что все части выражения SELECT находятся в области from.  
  
 Предложение GROUP BY также вводит новую область одного уровня. Каждая группа может иметь имя группы, которое ссылается на коллекцию элементов в группе. Каждое выражение группирования также вводит новое имя в область группы. Кроме того, в эту область также добавляется статистическое выражение вложения (или группа с именем). Сами выражения группирования находятся в области from. Однако при использовании предложения GROUP BY считается, что список выбора (проекция), предложение HAVING и предложение ORDER BY находятся в области группы, а не в области from. Статистические выражения обрабатываются особым образом, как описано в следующем маркированном списке.  
  
 Далее приведены дополнительные замечания об областях.  
  
-   Список выбора может вводить в область новые имена по порядку. Расположенные справа выражения проекций могут ссылаться на имена в проекциях слева.  
  
-   Предложение ORDER BY может ссылаться на имена (псевдонимы), указанные в списке выбора.  
  
-   Порядок оценки предложений внутри выражения SELECT определяет порядок, в котором имена вводятся в область. Первым оценивается предложение FROM, затем предложения WHERE, GROUP BY, HAVING, SELECT и, наконец, предложение ORDER BY.  
  
### <a name="aggregate-handling"></a>Обработка статистических выражений  
 [!INCLUDE[esql](../../../../../../includes/esql-md.md)] поддерживает две формы статистических выражений: статистические выражения на базе коллекции и статистические функции на основе группы. В [!INCLUDE[esql](../../../../../../includes/esql-md.md)] статистические выражения на базе коллекции являются предпочтительными конструкциями, а статистические выражения на базе группы поддерживаются для совместимости с SQL.  
  
 При разрешении статистического выражения, [!INCLUDE[esql](../../../../../../includes/esql-md.md)] сначала пытается обработать его как статистическое выражение на основе коллекций. В случае неудачи [!INCLUDE[esql](../../../../../../includes/esql-md.md)] преобразует агрегатной входные данные в ссылку на статистическое выражение вложения и пытается разрешить новое выражение, как показано в следующем примере.  
  
 `AVG(t.c) becomes AVG(group..(t.c))`  
  
## <a name="see-also"></a>См. также

- [Справочник по Entity SQL](../../../../../../docs/framework/data/adonet/ef/language-reference/entity-sql-reference.md)
- [Общие сведения об Entity SQL](../../../../../../docs/framework/data/adonet/ef/language-reference/entity-sql-overview.md)
- [Набор символов ввода](../../../../../../docs/framework/data/adonet/ef/language-reference/input-character-set-entity-sql.md)
