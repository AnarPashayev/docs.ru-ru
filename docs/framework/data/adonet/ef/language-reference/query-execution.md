---
title: Выполнение запроса
description: Узнайте о различных способах выполнения запроса LINQ to Entities, включая отложенное выполнение запроса, немедленное выполнение запросов и выполнение хранилища.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: c0e6cf23-63ac-47dd-bfe9-d5bdca826fac
ms.openlocfilehash: e5961330eab5f25508319f276df1e9b4572f49ee
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/24/2020
ms.locfileid: "91189309"
---
# <a name="query-execution"></a><span data-ttu-id="a7a07-103">Выполнение запроса</span><span class="sxs-lookup"><span data-stu-id="a7a07-103">Query Execution</span></span>

<span data-ttu-id="a7a07-104">После создания пользователем запрос LINQ преобразуется в дерево команд.</span><span class="sxs-lookup"><span data-stu-id="a7a07-104">After a LINQ query is created by a user, it is converted to a command tree.</span></span> <span data-ttu-id="a7a07-105">Дерево команд является представлением запроса, совместимым с платформой Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="a7a07-105">A command tree is a representation of a query that is compatible with the Entity Framework.</span></span> <span data-ttu-id="a7a07-106">Затем дерево команд выполняется в источнике данных.</span><span class="sxs-lookup"><span data-stu-id="a7a07-106">The command tree is then executed against the data source.</span></span> <span data-ttu-id="a7a07-107">Во время выполнения запроса вычисляются все включенные в него выражения (компоненты запроса), в том числе выражения для материализации запроса.</span><span class="sxs-lookup"><span data-stu-id="a7a07-107">At query execution time, all query expressions (that is, all components of the query) are evaluated, including those expressions that are used in result materialization.</span></span>  
  
 <span data-ttu-id="a7a07-108">Выражения выполняются в различные моменты времени.</span><span class="sxs-lookup"><span data-stu-id="a7a07-108">At what point query expressions are executed can vary.</span></span> <span data-ttu-id="a7a07-109">Запросы LINQ всегда выполняются во время прохода по переменной запроса, а не в момент ее создания.</span><span class="sxs-lookup"><span data-stu-id="a7a07-109">LINQ queries are always executed when the query variable is iterated over, not when the query variable is created.</span></span> <span data-ttu-id="a7a07-110">Это называется *отложенным выполнением*.</span><span class="sxs-lookup"><span data-stu-id="a7a07-110">This is called *deferred execution*.</span></span> <span data-ttu-id="a7a07-111">Существует возможность принудительно выполнить запрос немедленно - это может оказаться полезным для кэширования результатов запроса.</span><span class="sxs-lookup"><span data-stu-id="a7a07-111">You can also force a query to execute immediately, which is useful for caching query results.</span></span> <span data-ttu-id="a7a07-112">Этот вопрос обсуждается ниже в данном разделе.</span><span class="sxs-lookup"><span data-stu-id="a7a07-112">This is described later in this topic.</span></span>  
  
 <span data-ttu-id="a7a07-113">При выполнении запроса в технологии LINQ to Entities некоторые выражения запроса могут выполняться на сервере, а некоторые части — локально, на клиенте.</span><span class="sxs-lookup"><span data-stu-id="a7a07-113">When a LINQ to Entities query is executed, some expressions in the query might be executed on the server and some parts might be executed locally on the client.</span></span> <span data-ttu-id="a7a07-114">Вычисление выражения на клиенте происходит до выполнения запроса на сервере.</span><span class="sxs-lookup"><span data-stu-id="a7a07-114">Client-side evaluation of an expression takes place before the query is executed on the server.</span></span> <span data-ttu-id="a7a07-115">Если выражение вычисляется на клиенте, результат этого вычисления подставляется в запрос вместо выражения, после чего запрос выполняется на сервере.</span><span class="sxs-lookup"><span data-stu-id="a7a07-115">If an expression is evaluated on the client, the result of that evaluation is substituted for the expression in the query, and the query is then executed on the server.</span></span> <span data-ttu-id="a7a07-116">Запросы выполняются применительно к источнику данных, поэтому конфигурация источника данных переопределяет правила работы, заданные на клиенте.</span><span class="sxs-lookup"><span data-stu-id="a7a07-116">Because queries are executed on the data source, the data source configuration overrides the behavior specified in the client.</span></span> <span data-ttu-id="a7a07-117">Например, порядок обработки значений NULL и точность числа зависят от параметров настройки сервера.</span><span class="sxs-lookup"><span data-stu-id="a7a07-117">For example, null value handling and numerical precision depend on the server settings.</span></span> <span data-ttu-id="a7a07-118">Все исключения, возникшие на сервере во время выполнения запроса, передаются непосредственно клиенту.</span><span class="sxs-lookup"><span data-stu-id="a7a07-118">Any exceptions thrown during query execution on the server are passed directly up to the client.</span></span>  

> [!TIP]
> <span data-ttu-id="a7a07-119">Удобную сводку по операторам запросов в табличном формате, которая позволяет быстро определить поведение оператора, см. в разделе [классификация стандартных операторов запросов по способам выполнения (C#)](../../../../../csharp/programming-guide/concepts/linq/classification-of-standard-query-operators-by-manner-of-execution.md).</span><span class="sxs-lookup"><span data-stu-id="a7a07-119">For a convenient summary of query operators in table format, which lets you quickly identify an operator's execution behavior, see [Classification of Standard Query Operators by Manner of Execution (C#)](../../../../../csharp/programming-guide/concepts/linq/classification-of-standard-query-operators-by-manner-of-execution.md).</span></span>

## <a name="deferred-query-execution"></a><span data-ttu-id="a7a07-120">Отложенное выполнение запроса</span><span class="sxs-lookup"><span data-stu-id="a7a07-120">Deferred query execution</span></span>  

 <span data-ttu-id="a7a07-121">В запросе, возвращающем последовательность значений, переменная запроса никогда не содержит результаты запроса, а только хранит его команды.</span><span class="sxs-lookup"><span data-stu-id="a7a07-121">In a query that returns a sequence of values, the query variable itself never holds the query results and only stores the query commands.</span></span> <span data-ttu-id="a7a07-122">Выполнение запроса откладывается, пока переменная запроса используется в циклах `foreach` или `For Each`.</span><span class="sxs-lookup"><span data-stu-id="a7a07-122">Execution of the query is deferred until the query variable is iterated over in a `foreach` or `For Each` loop.</span></span> <span data-ttu-id="a7a07-123">Это называется *отложенным выполнением*; Это значит, что выполнение запроса происходит через некоторое время после создания запроса.</span><span class="sxs-lookup"><span data-stu-id="a7a07-123">This is known as *deferred execution*; that is, query execution occurs some time after the query is constructed.</span></span> <span data-ttu-id="a7a07-124">Это означает, что запрос можно выполнять настолько часто, насколько это необходимо.</span><span class="sxs-lookup"><span data-stu-id="a7a07-124">This means that you can execute a query as frequently as you want to.</span></span> <span data-ttu-id="a7a07-125">Такое свойство полезно, например, если имеется база данных, которая обновляется другими приложениями.</span><span class="sxs-lookup"><span data-stu-id="a7a07-125">This is useful when, for example, you have a database that is being updated by other applications.</span></span> <span data-ttu-id="a7a07-126">В собственном приложении можно создать запрос, который регулярно выполняется, каждый раз получая последние обновленные данные.</span><span class="sxs-lookup"><span data-stu-id="a7a07-126">In your application, you can create a query to retrieve the latest information and repeatedly execute the query, returning the updated information every time.</span></span>  
  
 <span data-ttu-id="a7a07-127">Отложенное выполнение позволяет объединять несколько запросов или расширять один запрос.</span><span class="sxs-lookup"><span data-stu-id="a7a07-127">Deferred execution enables multiple queries to be combined or a query to be extended.</span></span> <span data-ttu-id="a7a07-128">При расширении запроса он изменяется, включая в себя новые операции, а последующее выполнение отразит эти изменения.</span><span class="sxs-lookup"><span data-stu-id="a7a07-128">When a query is extended, it is modified to include the new operations, and the eventual execution will reflect the changes.</span></span> <span data-ttu-id="a7a07-129">В следующем примере первый запрос возвращает все продукты.</span><span class="sxs-lookup"><span data-stu-id="a7a07-129">In the following example, the first query returns all the products.</span></span> <span data-ttu-id="a7a07-130">Второй запрос расширяет первый, используя предложение `Where`, чтобы возвратить все продукты с размером «L»:</span><span class="sxs-lookup"><span data-stu-id="a7a07-130">The second query extends the first by using `Where` to return all the products of size "L":</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#Composing1](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#composing1)]
 [!code-vb[DP L2E Conceptual Examples#Composing1](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#composing1)]  
  
 <span data-ttu-id="a7a07-131">После выполнения запроса во всех последующих запросах будут использоваться операторы LINQ из памяти.</span><span class="sxs-lookup"><span data-stu-id="a7a07-131">After a query has been executed all successive queries will use the in-memory LINQ operators.</span></span> <span data-ttu-id="a7a07-132">Изменение переменной запроса в цикле с помощью инструкции `foreach` или `For Each` либо путем вызова одного из операторов преобразования LINQ приводит к немедленному выполнению запроса.</span><span class="sxs-lookup"><span data-stu-id="a7a07-132">Iterating over the query variable by using a `foreach` or `For Each` statement or by calling one of the LINQ conversion operators will cause immediate execution.</span></span> <span data-ttu-id="a7a07-133">Эти операторы преобразования включают: <xref:System.Linq.Enumerable.ToList%2A>, <xref:System.Linq.Enumerable.ToArray%2A>, <xref:System.Linq.Enumerable.ToLookup%2A> и <xref:System.Linq.Enumerable.ToDictionary%2A>.</span><span class="sxs-lookup"><span data-stu-id="a7a07-133">These conversion operators include the following: <xref:System.Linq.Enumerable.ToList%2A>, <xref:System.Linq.Enumerable.ToArray%2A>, <xref:System.Linq.Enumerable.ToLookup%2A>, and <xref:System.Linq.Enumerable.ToDictionary%2A>.</span></span>  
  
## <a name="immediate-query-execution"></a><span data-ttu-id="a7a07-134">Немедленное выполнение запроса</span><span class="sxs-lookup"><span data-stu-id="a7a07-134">Immediate Query Execution</span></span>  

 <span data-ttu-id="a7a07-135">В отличие от отложенного выполнения запросов, возвращающих последовательность значений, запросы, возвращающие одноэлементное значение, выполняются немедленно.</span><span class="sxs-lookup"><span data-stu-id="a7a07-135">In contrast to the deferred execution of queries that produce a sequence of values, queries that return a singleton value are executed immediately.</span></span> <span data-ttu-id="a7a07-136">Примерами одноэлементных запросов являются <xref:System.Linq.Enumerable.Average%2A>, <xref:System.Linq.Enumerable.Count%2A>, <xref:System.Linq.Enumerable.First%2A> и <xref:System.Linq.Enumerable.Max%2A>.</span><span class="sxs-lookup"><span data-stu-id="a7a07-136">Some examples of singleton queries are <xref:System.Linq.Enumerable.Average%2A>, <xref:System.Linq.Enumerable.Count%2A>, <xref:System.Linq.Enumerable.First%2A>, and <xref:System.Linq.Enumerable.Max%2A>.</span></span> <span data-ttu-id="a7a07-137">Они выполняются немедленно, потому что запрос должен создать последовательность, чтобы вычислить одноэлементный результат.</span><span class="sxs-lookup"><span data-stu-id="a7a07-137">These execute immediately because the query must produce a sequence to calculate the singleton result.</span></span> <span data-ttu-id="a7a07-138">Можно также принудительно вызвать немедленное выполнение.</span><span class="sxs-lookup"><span data-stu-id="a7a07-138">You can also force immediate execution.</span></span> <span data-ttu-id="a7a07-139">Это может оказаться полезным в тех случаях, когда результаты запроса необходимо поместить в кэш.</span><span class="sxs-lookup"><span data-stu-id="a7a07-139">This is useful when you want to cache the results of a query.</span></span> <span data-ttu-id="a7a07-140">Чтобы немедленно выполнить запрос, который не возвращает одноэлементное значение, можно вызвать метод <xref:System.Linq.Enumerable.ToList%2A>, <xref:System.Linq.Enumerable.ToDictionary%2A> или <xref:System.Linq.Enumerable.ToArray%2A> запроса или переменной запроса.</span><span class="sxs-lookup"><span data-stu-id="a7a07-140">To force immediate execution of a query that does not produce a singleton value, you can call the <xref:System.Linq.Enumerable.ToList%2A> method, the <xref:System.Linq.Enumerable.ToDictionary%2A> method, or the <xref:System.Linq.Enumerable.ToArray%2A> method on a query or query variable.</span></span> <span data-ttu-id="a7a07-141">В следующем примере метод <xref:System.Linq.Enumerable.ToArray%2A> вызывается для немедленного вычисления последовательности с получением массива.</span><span class="sxs-lookup"><span data-stu-id="a7a07-141">The following example uses the <xref:System.Linq.Enumerable.ToArray%2A> method to immediately evaluate a sequence into an array.</span></span>  
  
 [!code-csharp[DP L2E Examples#ToArray](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Examples/CS/Program.cs#toarray)]
 [!code-vb[DP L2E Examples#ToArray](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Examples/VB/Module1.vb#toarray)]  
  
 <span data-ttu-id="a7a07-142">Можно также принудительно вызвать выполнение, поместив цикл `foreach` или `For Each` сразу после выражения запроса, однако при вызове метода <xref:System.Linq.Enumerable.ToList%2A> или <xref:System.Linq.Enumerable.ToArray%2A> все данные будут помещены в кэш в одном объекте коллекции.</span><span class="sxs-lookup"><span data-stu-id="a7a07-142">You could also force execution by putting the `foreach` or `For Each` loop immediately after the query expression, but by calling <xref:System.Linq.Enumerable.ToList%2A> or <xref:System.Linq.Enumerable.ToArray%2A> you cache all the data in a single collection object.</span></span>  
  
## <a name="store-execution"></a><span data-ttu-id="a7a07-143">Выполнение в хранилище</span><span class="sxs-lookup"><span data-stu-id="a7a07-143">Store Execution</span></span>  

 <span data-ttu-id="a7a07-144">Как правило, выражения LINQ to Entities вычисляются на сервере, и не следует ожидать, что поведение выражений будет соответствовать семантике среды CLR; вместо этого применяется семантика источника данных.</span><span class="sxs-lookup"><span data-stu-id="a7a07-144">In general, expressions in LINQ to Entities are evaluated on the server, and the behavior of the expression should not be expected to follow common language runtime (CLR) semantics, but those of the data source.</span></span> <span data-ttu-id="a7a07-145">Однако из этого правила существуют исключения, например, когда выражение выполняется на клиенте.</span><span class="sxs-lookup"><span data-stu-id="a7a07-145">There are exceptions to this, however, such as when the expression is executed on the client.</span></span> <span data-ttu-id="a7a07-146">Это может привести к непредвиденным результатам, например, когда сервер и клиент находятся в разных часовых поясах.</span><span class="sxs-lookup"><span data-stu-id="a7a07-146">This could cause unexpected results, for example when the server and client are in different time zones.</span></span>  
  
 <span data-ttu-id="a7a07-147">Некоторые выражения запроса могут выполняться на клиенте.</span><span class="sxs-lookup"><span data-stu-id="a7a07-147">Some expressions in the query might be executed on the client.</span></span> <span data-ttu-id="a7a07-148">Большинство операций по выполнению запроса выполняются на сервере.</span><span class="sxs-lookup"><span data-stu-id="a7a07-148">In general, most query execution is expected to occur on the server.</span></span> <span data-ttu-id="a7a07-149">Помимо методов, выполняемых применительно к элементам запроса, сопоставленным с источником данных, в запросе часто существуют выражения, которые могут быть выполнены локально.</span><span class="sxs-lookup"><span data-stu-id="a7a07-149">Aside from methods executed against query elements mapped to the data source, there are often expressions in the query that can be executed locally.</span></span> <span data-ttu-id="a7a07-150">Локальное выполнение выражения запроса возвращает значение, которое можно использовать для выполнения запроса или построения результата.</span><span class="sxs-lookup"><span data-stu-id="a7a07-150">Local execution of a query expression yields a value that can be used in the query execution or result construction.</span></span>  
  
 <span data-ttu-id="a7a07-151">Некоторые операции всегда выполняются на клиенте, например, привязка значений, вложенные выражения, вложенные запросы из замыканий и материализация объектов в результаты запроса.</span><span class="sxs-lookup"><span data-stu-id="a7a07-151">Certain operations are always executed on the client, such as binding of values, sub expressions, sub queries from closures, and materialization of objects into query results.</span></span> <span data-ttu-id="a7a07-152">В итоге получается, что эти элементы (например, значения параметров) не могут обновляться во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="a7a07-152">The net effect of this is that these elements (for example, parameter values) cannot be updated during the execution.</span></span> <span data-ttu-id="a7a07-153">Анонимные типы могут быть созданы прямо внутри источника данных, однако лучше этого не делать.</span><span class="sxs-lookup"><span data-stu-id="a7a07-153">Anonymous types can be constructed inline on the data source, but should not be assumed to do so.</span></span> <span data-ttu-id="a7a07-154">В источнике данных можно также создавать встроенные группирования, однако не следует это делать в каждом экземпляре.</span><span class="sxs-lookup"><span data-stu-id="a7a07-154">Inline groupings can be constructed in the data source, as well, but this should not be assumed in every instance.</span></span> <span data-ttu-id="a7a07-155">Как правило, лучше не делать никаких предположений относительно объектов, создаваемых на сервере.</span><span class="sxs-lookup"><span data-stu-id="a7a07-155">In general, it is best not to make any assumptions about what is constructed on the server.</span></span>  
  
 <span data-ttu-id="a7a07-156">В этом разделе описаны сценарии, в которых код выполняется локально на клиенте.</span><span class="sxs-lookup"><span data-stu-id="a7a07-156">This section describes the scenarios in which code is executed locally on the client.</span></span> <span data-ttu-id="a7a07-157">Дополнительные сведения о типах выражений, выполняемых локально, см. [в разделе выражения в запросах LINQ to Entities](expressions-in-linq-to-entities-queries.md).</span><span class="sxs-lookup"><span data-stu-id="a7a07-157">For more information about which types of expressions are executed locally, see [Expressions in LINQ to Entities Queries](expressions-in-linq-to-entities-queries.md).</span></span>  
  
### <a name="literals-and-parameters"></a><span data-ttu-id="a7a07-158">Литералы и параметры</span><span class="sxs-lookup"><span data-stu-id="a7a07-158">Literals and Parameters</span></span>  

 <span data-ttu-id="a7a07-159">Локальные переменные (например, переменная `orderID` в приведенном ниже примере) вычисляются на клиенте.</span><span class="sxs-lookup"><span data-stu-id="a7a07-159">Local variables, such as the `orderID` variable in the following example, are evaluated on the client.</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#LiteralParameter1](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#literalparameter1)]
 [!code-vb[DP L2E Conceptual Examples#LiteralParameter1](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#literalparameter1)]  
  
 <span data-ttu-id="a7a07-160">Параметры методов также вычисляются на клиенте.</span><span class="sxs-lookup"><span data-stu-id="a7a07-160">Method parameters are also evaluated on the client.</span></span> <span data-ttu-id="a7a07-161">Например, ниже показан параметр `orderID`, передаваемый методу `MethodParameterExample`.</span><span class="sxs-lookup"><span data-stu-id="a7a07-161">The `orderID` parameter passed into the `MethodParameterExample` method, below, is an example.</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#MethodParameterExample](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#methodparameterexample)]
 [!code-vb[DP L2E Conceptual Examples#MethodParameterExample](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#methodparameterexample)]  
  
### <a name="casting-literals-on-the-client"></a><span data-ttu-id="a7a07-162">Приведение литералов на клиенте</span><span class="sxs-lookup"><span data-stu-id="a7a07-162">Casting Literals on the Client</span></span>  

 <span data-ttu-id="a7a07-163">Приведение значения `null` к типу CLR выполняется на клиенте.</span><span class="sxs-lookup"><span data-stu-id="a7a07-163">Casting from `null` to a CLR type is executed on the client:</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#NullCastToString](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#nullcasttostring)]
 [!code-vb[DP L2E Conceptual Examples#NullCastToString](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#nullcasttostring)]  
  
 <span data-ttu-id="a7a07-164">Приведение к типу, допускающему значение NULL (например, <xref:System.Decimal>), выполняется на клиенте.</span><span class="sxs-lookup"><span data-stu-id="a7a07-164">Casting to a type, such as a nullable <xref:System.Decimal>, is executed on the client:</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#CastToNullable](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#casttonullable)]
 [!code-vb[DP L2E Conceptual Examples#CastToNullable](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#casttonullable)]  
  
### <a name="constructors-for-literals"></a><span data-ttu-id="a7a07-165">Конструкторы для литералов</span><span class="sxs-lookup"><span data-stu-id="a7a07-165">Constructors for Literals</span></span>  

 <span data-ttu-id="a7a07-166">Новые типы CLR, которые могут быть сопоставлены с типами концептуальной модели, выполняются на клиенте.</span><span class="sxs-lookup"><span data-stu-id="a7a07-166">New CLR types that can be mapped to conceptual model types are executed on the client:</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#ConstructorForLiteral](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#constructorforliteral)]
 [!code-vb[DP L2E Conceptual Examples#ConstructorForLiteral](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#constructorforliteral)]  
  
 <span data-ttu-id="a7a07-167">Новые массивы также выполняются на клиенте.</span><span class="sxs-lookup"><span data-stu-id="a7a07-167">New arrays are also executed on the client.</span></span>  
  
## <a name="store-exceptions"></a><span data-ttu-id="a7a07-168">Исключения в хранилище</span><span class="sxs-lookup"><span data-stu-id="a7a07-168">Store Exceptions</span></span>  

 <span data-ttu-id="a7a07-169">Все ошибки хранилища, обнаруженные во время выполнения запроса, передаются клиенту без сопоставления и обработки.</span><span class="sxs-lookup"><span data-stu-id="a7a07-169">Any store errors that are encountered during query execution are passed up to the client, and are not mapped or handled.</span></span>  
  
## <a name="store-configuration"></a><span data-ttu-id="a7a07-170">Конфигурация хранилища</span><span class="sxs-lookup"><span data-stu-id="a7a07-170">Store Configuration</span></span>  

 <span data-ttu-id="a7a07-171">Когда запрос выполняется в хранилище, конфигурация хранилища переопределяет все правила, заданные на клиенте и для всех операций и выражений применяется семантика хранилища.</span><span class="sxs-lookup"><span data-stu-id="a7a07-171">When the query executes on the store, the store configuration overrides all client behaviors, and store semantics are expressed for all operations and expressions.</span></span> <span data-ttu-id="a7a07-172">Это может привести к тому, что выполнение будет производиться по-разному в среде CLR и в хранилище для таких областей, как сравнение со значением NULL, упорядочение идентификаторов GUID, точность операций, в которых участвуют неточные типы данных (например, типы с плавающей запятой или <xref:System.DateTime>), а также строковые операции.</span><span class="sxs-lookup"><span data-stu-id="a7a07-172">This can result in a difference in behavior between CLR and store execution in areas such as null comparisons, GUID ordering, precision and accuracy of operations involving non-precise data types (such as floating point types or <xref:System.DateTime>), and string operations.</span></span> <span data-ttu-id="a7a07-173">Важно помнить об этом при изучении результатов запроса.</span><span class="sxs-lookup"><span data-stu-id="a7a07-173">It is important to keep this in mind when examining query results.</span></span>  
  
 <span data-ttu-id="a7a07-174">Например, ниже представлены некоторые отличия в работе среды CLR и SQL Server.</span><span class="sxs-lookup"><span data-stu-id="a7a07-174">For example, the following are some differences in behavior between the CLR and SQL Server:</span></span>  
  
- <span data-ttu-id="a7a07-175">SQL Server упорядочивает идентификаторы GUID иначе, чем среда CLR.</span><span class="sxs-lookup"><span data-stu-id="a7a07-175">SQL Server orders GUIDs differently than the CLR.</span></span>  
  
- <span data-ttu-id="a7a07-176">Кроме того, возможны различия в точности результатов при работе с типом Decimal в SQL Server.</span><span class="sxs-lookup"><span data-stu-id="a7a07-176">There can also be differences in result precision when dealing with the Decimal type on SQL Server.</span></span> <span data-ttu-id="a7a07-177">Это происходит из-за требований к фиксированной к точности для десятичного типа данных в SQL Server.</span><span class="sxs-lookup"><span data-stu-id="a7a07-177">This is due to the fixed precision requirements of the SQL Server decimal type.</span></span> <span data-ttu-id="a7a07-178">Например, арифметическое среднее трех значений типа <xref:System.Decimal> - 0,0, 0,0 и 1,0 в памяти на клиенте будет равно 0,3333333333333333333333333333, а в хранилище - 0,333333 (согласно точности по умолчанию для типа Decimal в SQL Server).</span><span class="sxs-lookup"><span data-stu-id="a7a07-178">For example, the average of <xref:System.Decimal> values 0.0, 0.0, and 1.0 is 0.3333333333333333333333333333 in memory on the client, but 0.333333 in the store (based on the default precision for SQL Server’s decimal type).</span></span>  
  
- <span data-ttu-id="a7a07-179">Некоторые операции сравнения строк также обрабатываются в SQL Server иначе, чем в среде CLR.</span><span class="sxs-lookup"><span data-stu-id="a7a07-179">Some string comparison operations are also handled differently in SQL Server than in the CLR.</span></span> <span data-ttu-id="a7a07-180">Это связано с тем, что порядок сравнения строк зависит от параметров сортировки на сервере.</span><span class="sxs-lookup"><span data-stu-id="a7a07-180">String comparison behavior depends on the collation settings on the server.</span></span>  
  
- <span data-ttu-id="a7a07-181">Вызовы функций или методов, включенных в запрос LINQ to Entities, сопоставляются с каноническими функциями платформы Entity Framework, которые затем преобразуются в Transact-SQL и выполняются в базе данных SQL Server.</span><span class="sxs-lookup"><span data-stu-id="a7a07-181">Function or method calls, when included in a LINQ to Entities query, are mapped to canonical functions in the Entity Framework, which are then translated to Transact-SQL and executed on the SQL Server database.</span></span> <span data-ttu-id="a7a07-182">Бывают ситуации, когда сопоставленные функции работают иначе, чем реализации в библиотеках базовых классов.</span><span class="sxs-lookup"><span data-stu-id="a7a07-182">There are cases when the behavior these mapped functions exhibit might differ from the implementation in the base class libraries.</span></span> <span data-ttu-id="a7a07-183">Например, при вызове метода <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A> или <xref:System.String.EndsWith%2A> с пустой строкой в качестве параметра при выполнении в среде CLR возвратит значение `true`, а при выполнении в SQL Server - значение `false`.</span><span class="sxs-lookup"><span data-stu-id="a7a07-183">For example, calling the <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, and <xref:System.String.EndsWith%2A> methods with an empty string as a parameter will return `true` when executed in the CLR, but will return `false` when executed in SQL Server.</span></span> <span data-ttu-id="a7a07-184">Кроме того, при вызове метода <xref:System.String.EndsWith%2A> также могут вернуться различные результаты, поскольку SQL Server считает равными две строки, различающиеся только конечными пробелами, в то время как с точки зрения среды CLR эти строки не равны.</span><span class="sxs-lookup"><span data-stu-id="a7a07-184">The <xref:System.String.EndsWith%2A> method can also return different results because SQL Server considers two strings to be equal if they only differ in trailing white space, whereas the CLR considers them to be not equal.</span></span> <span data-ttu-id="a7a07-185">Это продемонстрировано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="a7a07-185">This is illustrated by the following example:</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#CanonicalFuncVsCLRBaseType](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#canonicalfuncvsclrbasetype)]
 [!code-vb[DP L2E Conceptual Examples#CanonicalFuncVsCLRBaseType](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#canonicalfuncvsclrbasetype)]
