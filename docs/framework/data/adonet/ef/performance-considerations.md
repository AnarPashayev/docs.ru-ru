---
title: Сведения о производительности (Entity Framework)
ms.date: 03/30/2017
ms.assetid: 61913f3b-4f42-4d9b-810f-2a13c2388a4a
ms.openlocfilehash: 0ff018fe0d8199dcd790bcd3de18751662e0a92b
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79149743"
---
# <a name="performance-considerations-entity-framework"></a>Сведения о производительности (Entity Framework)
В этом подразделе описаны характеристики производительности платформы ADO.NET Entity Framework, а также приведены соображения по повышению производительности приложений платформы Entity Framework.  
  
## <a name="stages-of-query-execution"></a>Этапы выполнения запросов  
 Чтобы лучше понять специфику производительности запросов платформы Entity Framework, необходимо разобраться с операциями, которые совершаются при выполнении запроса к концептуальной модели и при возврате данных в виде объектов. В следующей таблице описан этот ряд операций.  
  
|Операция|Относительные затраты|Частота|Комментарии|  
|---------------|-------------------|---------------|--------------|  
|Загрузка метаданных|Средний|По одному разу в каждом домене приложения.|Метаданные модели и сопоставления, используемые платформой Entity Framework, загружаются в <xref:System.Data.Metadata.Edm.MetadataWorkspace>. Эти метаданные собираются глобально и доступны другим экземплярам <xref:System.Data.Objects.ObjectContext> в том же домене приложения.|  
|Открытие подключения базы данных|Умеренный<sup>1</sup>|При необходимости.|Поскольку открытое подключение к базе данных потребляет ценный ресурс, рамочная сущность открывает и закрывает соединение базы данных только по мере необходимости. Кроме того, соединение можно открыть явно. Для получения дополнительной информации [см.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))|  
|Создание представлений...|Высокий|По одному разу в каждом домене приложения. (могут создаваться предварительно.)|Прежде чем платформа Entity Framework сможет выполнять запросы к концептуальной модели или сохранять изменения в источнике данных, ей необходимо создать набор локальных представлений запросов для доступа к базе данных. В связи с высокими затратами на создание этих представлений их можно создать заранее и добавить в проект во время разработки. Для получения дополнительной информации [см.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100))|  
|Подготовка запроса|Умеренный<sup>2</sup>|Один раз для каждого уникального запроса.|Включает затраты на создание команды запроса, создание дерева команд на базе метаданных модели и сопоставления, а также определение вида возвращаемых данных. Теперь как команды запросов Entity SQL, так и запросы LINQ кэшируются, поэтому при последующем выполнении один и тот же запрос занимает еще меньше времени. Можно по-прежнему использовать скомпилированные запросы LINQ для снижения затрат при последующем выполнении, и скомпилированные запросы могут быть более эффективными, чем запросы LINQ, которые автоматически сохраняются в кэше. Для получения дополнительной [информации см.](./language-reference/compiled-queries-linq-to-entities.md) Для получения общей информации о [LINQ to Entities](./language-reference/linq-to-entities.md)выполнении запроса LIN's см. **Примечание:**  Запросы на сущности, `Enumerable.Contains` которые применяют оператора к коллекциям в памяти, автоматически не кэшируются. Также в скомпилированных запросах LINQ не допускаются коллекции в памяти с параметрами.|  
|Выполнение запроса|Низкий<sup>2</sup>|Один раз для каждого запроса.|Затраты на выполнение команды к источнику данных с помощью поставщика данных ADO.NET. Поскольку большинство источников данных кэширует планы запросов, при последующем выполнении один и тот же запрос может занимать меньше времени.|  
|Загрузка и проверка типов|Низкий<sup>3</sup>|Один раз для каждого элемента <xref:System.Data.Objects.ObjectContext>.|Типы загружаются и проверяются относительно типов, определенных в концептуальной модели.|  
|Отслеживание|Низкий<sup>3</sup>|Один раз для каждого объекта, возвращаемого запросом. <sup>4</sup>|Если запрос использует параметр слияния <xref:System.Data.Objects.MergeOption.NoTracking>, то этот шаг не влияет на производительность.<br /><br /> Если запрос использует параметры слияния <xref:System.Data.Objects.MergeOption.AppendOnly>, <xref:System.Data.Objects.MergeOption.PreserveChanges> или <xref:System.Data.Objects.MergeOption.OverwriteChanges>, то результаты запроса отслеживаются в <xref:System.Data.Objects.ObjectStateManager>. Для каждого отслеживаемого объекта, возвращаемого запросом, создается ключ <xref:System.Data.EntityKey>, который используется для создания <xref:System.Data.Objects.ObjectStateEntry> в <xref:System.Data.Objects.ObjectStateManager>. Если для <xref:System.Data.Objects.ObjectStateEntry> можно найти существующий объект <xref:System.Data.EntityKey>, то возвращается существующий объект. Если используется параметр <xref:System.Data.Objects.MergeOption.PreserveChanges> или <xref:System.Data.Objects.MergeOption.OverwriteChanges>, то объект обновляется до возвращения.<br /><br /> Для получения дополнительной информации [см.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100))|  
|Материализация объектов|Умеренный<sup>3</sup>|Один раз для каждого объекта, возвращаемого запросом. <sup>4</sup>|Процесс считывания возвращенного объекта <xref:System.Data.Common.DbDataReader>, создания объектов и установки значений свойств, основанных на значениях в каждом экземпляре класса <xref:System.Data.Common.DbDataRecord>. Если объект уже существует в классе <xref:System.Data.Objects.ObjectContext> и в запросе используются параметры слияния <xref:System.Data.Objects.MergeOption.AppendOnly> или <xref:System.Data.Objects.MergeOption.PreserveChanges>, то этот шаг не влияет на производительность. Для получения дополнительной информации [см.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100))|  
  
 <sup>1</sup> Когда поставщик источников данных реализует объединение соединений, стоимость открытия соединения распределяется по пулу. Поставщик .NET для SQL Server поддерживает организацию пулов соединений.  
  
 <sup>2</sup> Стоимость увеличивается с увеличением сложности запроса.  
  
 <sup>3</sup> Общая стоимость увеличивается пропорционально количеству объектов, возвращенных запросом.  
  
 <sup>4</sup> Эти накладные расходы не требуются для запросов EntityClient, поскольку запросы EntityClient возвращают <xref:System.Data.EntityClient.EntityDataReader> вместо объектов. Для получения дополнительной [EntityClient Provider for the Entity Framework](entityclient-provider-for-the-entity-framework.md)информации см.  
  
## <a name="additional-considerations"></a>Дополнительные сведения  
 Ниже приведены дополнительные соображения по факторам, способным влиять на производительность приложений Entity Framework.  
  
### <a name="query-execution"></a>Выполнение запроса  
 Поскольку запросы могут быть ресурсоемкими, учитывайте, в каком участке кода и на каком компьютере выполняется запрос.  
  
#### <a name="deferred-versus-immediate-execution"></a>Отложенное или немедленное выполнение  
 При создании запроса <xref:System.Data.Objects.ObjectQuery%601> или LINQ запрос может выполняться не сразу. Выполнение запроса откладывается до тех пор, пока не понадобятся его результаты, например результаты перечисления `foreach` (C#) или `For Each` (Visual Basic), либо если запрос должен заполнить коллекцию <xref:System.Collections.Generic.List%601>. Выполнение запроса начинается немедленно при вызове метода <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> в <xref:System.Data.Objects.ObjectQuery%601> либо при вызове метода LINQ, возвращающего одноэлементный запрос, например <xref:System.Linq.Enumerable.First%2A> или <xref:System.Linq.Enumerable.Any%2A>. Для получения дополнительной [информации](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)) [Query Execution (LINQ to Entities)](./language-reference/query-execution.md)см.  
  
#### <a name="client-side-execution-of-linq-queries"></a>Выполнение запросов LINQ на стороне клиента  
 Хотя запрос LINQ выполняется на том компьютере, где размещен источник данных, некоторые части запроса LINQ могут обрабатываться на клиентском компьютере. Для получения дополнительной информации ознакомьтесь с разделом «Выполнение хранилища» в разделе [«Выполнение запросов» (LIN)](./language-reference/query-execution.md)с видом на объекты.  
  
### <a name="query-and-mapping-complexity"></a>Сложность запросов и сопоставления  
 Сложность отдельных запросов и сопоставления в модели сущности значительно влияет на производительность запросов.  
  
#### <a name="mapping-complexity"></a>Сложность сопоставления  
 Модели, более сложные, чем простое однозначное сопоставление между сущностями в концептуальной модели и таблицах в режиме хранилища, приводят к созданию более сложных команд, чем модели с однозначным сопоставлением.  
  
#### <a name="query-complexity"></a>Сложность запросов  
 Запросы, требующие большого числа соединений в командах, выполняемых с источником данных или возвращающих большой объем данных, могут влиять на производительность следующим образом:  
  
- Запросы к концептуальной модели, которые кажутся простыми, могут приводить к выполнению более сложных запросов к источнику данных. Это может происходить как следствие преобразования платформой Entity Framework запроса к концептуальной модели в эквивалентный запрос к источнику данных. Если один набор сущностей, заданный в концептуальной модели, сопоставляется с несколькими таблицами источника данных либо если связь между сущностями сопоставлена с соединяемой таблицей, то команда запроса к источнику данных может потребовать одного или нескольких соединений.  
  
    > [!NOTE]
    > Чтобы просмотреть команды, выполняемые по источнику данных для данного запроса, воспользуйтесь методом <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> классов <xref:System.Data.Objects.ObjectQuery%601> или <xref:System.Data.EntityClient.EntityCommand>. Для получения дополнительной [информации](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100))см.  
  
- Вложенные запросы Entity SQL могут создавать соединения на сервере, а также возвращать большое количество строк.  
  
     Далее приведен пример вложенного запроса в предложении проекции:  
  
    ```sql  
    SELECT c, (SELECT c, (SELECT c FROM AdventureWorksModel.Vendor AS c  ) As Inner2
        FROM AdventureWorksModel.JobCandidate AS c  ) As Inner1
        FROM AdventureWorksModel.EmployeeDepartmentHistory AS c  
    ```  
  
     Кроме того, подобные запросы заставляют конвейер запросов создавать одиночный запрос с дублированием объектов во вложенных запросах. В результате одиночный столбец может дублироваться несколько раз. В некоторых базах данных, в том числе SQL Server, это может приводить к чрезмерному значительному разрастанию таблицы TempDB, что снижает производительность сервера. Вложенные запросы следует выполнять с осторожностью.  
  
- Любые запросы, возвращающие большие объемы данных, могут снижать производительность, если клиент выполняет операции, использующие ресурсы пропорционально объему результирующего набора. В таких случаях, возможно, стоит ограничить объем данных, возвращаемых запросом. Для получения дополнительной информации [см.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100))  
  
 Любые команды, автоматически созданные платформой Entity Framework, могут оказываться сложнее аналогичных команд, написанных вручную разработчиком базы данных. Если требуется явный контроль над командами, выполняемыми с источником данных, подумайте об определении сопоставления с возвращающей табличное значение функцией или хранимой процедурой.  
  
#### <a name="relationships"></a>Связи  
 Для оптимальной производительности запросов необходимо определить связи между сущностями как в виде ассоциаций в модели сущности, так и в виде логических связей в источнике данных.  
  
### <a name="query-paths"></a>Пути запроса  
 По умолчанию при выполнении запроса <xref:System.Data.Objects.ObjectQuery%601> связанные объекты не возвращаются (хотя возвращаются объекты, представляющие сами связи). Связанные объекты можно загрузить одним из трех способов.  
  
1. Задайте путь запроса до выполнения <xref:System.Data.Objects.ObjectQuery%601>.  
  
2. Вызовите метод `Load` для свойства навигации, доступного для объекта.  
  
3. Установите параметр <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> объекта <xref:System.Data.Objects.ObjectContext> в значение `true`. Обратите внимание, что это делается автоматически при генерации кода объектного слоя с [помощью модели Entity Data Model Designer.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100)) Для получения дополнительной информации [см.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100))  
  
 При выборе параметра помните, что придется соблюдать баланс между числом запросов к базе данных и объемом данных, возвращаемых в одном запросе. Для получения дополнительной информации [см.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100))  
  
#### <a name="using-query-paths"></a>Использование путей запроса  
 Пути запроса определяют граф объектов, возвращаемых запросом. При указании пути запроса для возврата всех определенных в нем объектов требуется только один запрос к базе данных. Использование путей запроса может привести к тому, что над источником данных будут выполняться сложные команды из, на первый взгляд, простых запросов к объектам. Происходит это потому, что для возвращения связанных объектов в рамках одного запроса требуется одно или несколько соединений. Сложность будет выше в запросах к сложным моделям сущностей, таким как, например, сущность с наследованием или путь, содержащий связи «многие ко многим».  
  
> [!NOTE]
> Используйте метод <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A>, чтобы увидеть команду, которая будет сформирована методом <xref:System.Data.Objects.ObjectQuery%601>. Для получения дополнительной [информации](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100))см.  
  
 Когда путь запроса содержит слишком много связанных объектов или эти объекты содержат слишком много строковых данных, источник данных может оказаться не в состоянии выполнить запрос. Это происходит, если запросу требуется промежуточное временное хранилище, которое превышает возможности источника данных. В этом случае можно снизить сложность запроса к источнику данных путем явной загрузки связанных объектов.  
  
#### <a name="explicitly-loading-related-objects"></a>Явная загрузка связанных объектов  
 Явно загрузить связанные объекты можно, вызвав метод `Load` для свойства навигации, возвращающего <xref:System.Data.Objects.DataClasses.EntityCollection%601> или <xref:System.Data.Objects.DataClasses.EntityReference%601>. При явной загрузке объектов требуется выполнять цикл обмена данными с базой данных при каждом вызове метода `Load`.  
  
> [!NOTE]
> Если при циклической обработке коллекции возвращенных объектов, например при использовании инструкции `Load` (`foreach` в Visual Basic), вызывается метод `For Each`, поставщик для каждого конкретного источника данных должен поддерживать несколько активных результирующих наборов на одном соединении. Для базы данных SQL Server в строке подключения поставщика необходимо указать значение `MultipleActiveResultSets = true`.  
  
 Можно также использовать метод <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>, если сущности не имеют свойств <xref:System.Data.Objects.DataClasses.EntityCollection%601> и <xref:System.Data.Objects.DataClasses.EntityReference%601>. Это может оказаться полезным в том случае, если используются сущности POCO.  
  
 Хотя явная загрузка связанных объектов сократит число соединений и объем избыточных данных, метод `Load` потребует повторного соединения к базе данных, что может привести к повышении накладных расходов при загрузке большого числа объектов.  
  
### <a name="saving-changes"></a>Сохранение изменений  
 При вызове метода <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> для <xref:System.Data.Objects.ObjectContext> для каждого добавленного, обновленного или удаленного объекта в контексте создается отдельная команда создания, обновления или удаления. Эти команды выполняются для источника данных в единой транзакции. Как и в случае с запросами, производительность операций создания, обновления и удаления зависит от сложности сопоставления в концептуальной модели.  
  
### <a name="distributed-transactions"></a>Распределенные транзакции  
 Операции в явной транзакции, требующие ресурсов, управляемых координатором распределенных транзакций (DTC), будут гораздо затратнее, чем схожая операция, не требующая его использования. Повышение уровня явных транзакций до DTC будет происходить в следующих случаях.  
  
- Явная транзакция с операцией для базы данных SQL Server 2000 или другого источника данных, который всегда повышает уровень явных транзакций до DTC.  
  
- Явная транзакция с операцией против S'L Server 2005, когда соединение управляется Рамочой сущности. Это происходит потому, что S'L Server 2005 продвигает сяdд DTC всякий раз, когда соединение закрывается и вновь открывается в рамках одной транзакции, что является поведением по умолчанию в рамках Entity. Такое повышение уровня до DTC не происходит при использовании SQL Server 2008. Чтобы избежать такого повышения уровня при работе с SQL Server 2005, необходимо явно открывать и закрывать соединение в пределах одной транзакции. Для получения дополнительной информации [см.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))  
  
 Явная транзакция используется, если в пределах транзакции <xref:System.Transactions> выполняется одна или несколько операций. Для получения дополнительной информации [см.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))  
  
## <a name="strategies-for-improving-performance"></a>Стратегии повышения производительности  
 Ниже перечислены методики, позволяющие повысить общую производительность запросов платформы Entity Framework.  
  
#### <a name="pre-generate-views"></a>Предварительное создание представлений  
 Создание представлений на базе модели сущностей - это значительная статья расходов при первом выполнении запроса приложением. С помощью программы EdmGen.exe можно заранее создавать представления в виде файлов с кодом Visual Basic или C#, которые будут добавляться в проект во время проектирования. Можно также использовать средства преобразования текстовых шаблонов для создания представлений до компиляции. Предварительно созданные представления во время выполнения будут проверяться на согласованность с текущей версией указанной модели сущностей. Для получения дополнительной информации [см.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100))
  
 При работе с очень большими моделями нужно принимать во внимание следующие соображения.  
  
 Формат метаданных .NET ограничивает число символов пользовательской строки в заданном двоичном блоке до 16 777 215 (0xFFFFFF). Если вы генерируете представления для очень большой модели и файл представления достигает этого предела размера, вы получите "Нет логического пространства слева для создания большего числа строк пользователя". компилировать ошибку. Это ограничение имеет силу для всех управляемых библиотек. Для получения дополнительной информации смотрите [блог,](https://docs.microsoft.com/archive/blogs/appfabriccat/solving-the-no-logical-space-left-to-create-more-user-strings-error-and-improving-performance-of-pre-generated-views-in-visual-studio-net4-entity-framework) который демонстрирует, как избежать ошибки при работе с большими и сложными моделями.  
  
#### <a name="consider-using-the-notracking-merge-option-for-queries"></a>Рассмотрите возможность использования параметра слияния NoTracking для запросов  
 Для отслеживания возвращаемых объектов в контексте объекта требуются определенные затраты. Для распознавания изменений в объектах и гарантии того, что несколько запросов к одной логической сущности возвратят один экземпляр объекта, требуется, чтобы объекты были присоединены к экземпляру <xref:System.Data.Objects.ObjectContext>. Если вы не планируете делать обновления или удалять объекты <xref:System.Data.Objects.MergeOption.NoTracking> и не требуетуправления идентификационным данными, рассмотрите возможность использования вариантов слияния при выполнении запросов.  
  
#### <a name="return-the-correct-amount-of-data"></a>Возвращение правильного объема данных  
 В некоторых случаях указание пути запроса с помощью метода <xref:System.Data.Objects.ObjectQuery%601.Include%2A> выполняется гораздо быстрее, поскольку требуется меньше циклов обмена данными с базой данных. Однако в других сценариях дополнительные циклы обмена данными с базой данных при загрузке связанных объектов могут выполняться быстрее, поскольку более простые запросы с меньшим количеством соединений ведут к меньшей избыточности данных. В связи с этим рекомендуется проверять производительность разных способов получения связанных объектов. Для получения дополнительной информации [см.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100))  
  
 Чтобы избежать возвращения слишком большого объема данных в одном запросе, можно прибегнуть к подкачке страниц результатов запроса, что даст более простые в управлении группы. Для получения дополнительной информации [см.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100))  
  
#### <a name="limit-the-scope-of-the-objectcontext"></a>Ограничение области объекта ObjectContext  
 В большинстве случаев следует создавать экземпляр <xref:System.Data.Objects.ObjectContext> внутри инструкции `using` (`Using…End Using` в Visual Basic). Это может повысить производительность, поскольку гарантирует автоматическое удаление ресурсов, связанных с контекстом объекта, при выходе из блока инструкции в коде. Однако, если элементы управления привязаны к объектам, управляемым контекстом объекта, экземпляр <xref:System.Data.Objects.ObjectContext> следует сохранять до тех пор, пока требуется привязка, а удалять его - вручную. Для получения дополнительной информации [см.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))  
  
#### <a name="consider-opening-the-database-connection-manually"></a>Рассмотрите возможность подключения базы данных вручную  
 Когда приложение выполняет ряд запросов объектов <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> или часто вызывает сохранение для создания, обновления и удаления операций в источнике данных, рамочная entity должна постоянно открывать и закрывать соединение с источником данных. В таких случаях следует попробовать вручную открывать соединение в начале этих операций и либо закрывать, либо удалять соединение по их завершении. Для получения дополнительной информации [см.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))  
  
## <a name="performance-data"></a>Данные производительности  
 Некоторые данные о производительности для Системы сущности публикуются в следующих постах в [блоге ADO.NET команды:](https://docs.microsoft.com/archive/blogs/adonet/)  
  
- [Exploring the Performance of the ADO.NET Entity Framework - Part 1](https://docs.microsoft.com/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-1)  
  
- [Exploring the Performance of the ADO.NET Entity Framework - Part 2](https://docs.microsoft.com/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-2)  
  
- [ADO.NET Entity Framework Performance Comparison](https://docs.microsoft.com/archive/blogs/adonet/ado-net-entity-framework-performance-comparison)  
  
## <a name="see-also"></a>См. также раздел

- [Вопросы разработки и развертывания](development-and-deployment-considerations.md)
