---
title: Сведения о производительности (Entity Framework)
ms.date: 03/30/2017
ms.assetid: 61913f3b-4f42-4d9b-810f-2a13c2388a4a
ms.openlocfilehash: 6cd12948d16eea66efb6ee4b427a2c979e0aab3d
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2019
ms.locfileid: "64641284"
---
# <a name="performance-considerations-entity-framework"></a>Сведения о производительности (Entity Framework)
В этом подразделе описаны характеристики производительности платформы ADO.NET Entity Framework, а также приведены соображения по повышению производительности приложений платформы Entity Framework.  
  
## <a name="stages-of-query-execution"></a>Этапы выполнения запросов  
 Чтобы лучше понять специфику производительности запросов платформы Entity Framework, необходимо разобраться с операциями, которые совершаются при выполнении запроса к концептуальной модели и при возврате данных в виде объектов. В следующей таблице описан этот ряд операций.  
  
|Операция|Относительные затраты|Частота|Комментарии|  
|---------------|-------------------|---------------|--------------|  
|Загрузка метаданных|Средняя|По одному разу в каждом домене приложения.|Метаданные модели и сопоставления, используемые платформой Entity Framework, загружаются в <xref:System.Data.Metadata.Edm.MetadataWorkspace>. Эти метаданные собираются глобально и доступны другим экземплярам <xref:System.Data.Objects.ObjectContext> в том же домене приложения.|  
|Открытие подключения базы данных|Средняя<sup>1</sup>|При необходимости.|Поскольку открытое подключение к базе данных потребляет значительные ресурсы, [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] открывает и закрывает подключение к базе данных только при необходимости. Кроме того, соединение можно открыть явно. Дополнительные сведения см. в разделе [Управление соединениями и транзакциями](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).|  
|Создание представлений...|High|По одному разу в каждом домене приложения. (могут создаваться предварительно.)|Прежде чем платформа Entity Framework сможет выполнять запросы к концептуальной модели или сохранять изменения в источнике данных, ей необходимо создать набор локальных представлений запросов для доступа к базе данных. В связи с высокими затратами на создание этих представлений их можно создать заранее и добавить в проект во время разработки. Дополнительные сведения см. в разделе [Как Предварительное создание представлений для повышения производительности запросов](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).|  
|Подготовка запроса|Средняя<sup>2</sup>|Один раз для каждого уникального запроса.|Включает затраты на создание команды запроса, создание дерева команд на базе метаданных модели и сопоставления, а также определение вида возвращаемых данных. Теперь как команды запросов Entity SQL, так и запросы LINQ кэшируются, поэтому при последующем выполнении один и тот же запрос занимает еще меньше времени. Можно по-прежнему использовать скомпилированные запросы LINQ для снижения затрат при последующем выполнении, и скомпилированные запросы могут быть более эффективными, чем запросы LINQ, которые автоматически сохраняются в кэше. Дополнительные сведения см. в разделе [компилированные запросы (LINQ to Entities)](../../../../../docs/framework/data/adonet/ef/language-reference/compiled-queries-linq-to-entities.md). Общие сведения о выполнении запросов LINQ см. в разделе [LINQ to Entities](../../../../../docs/framework/data/adonet/ef/language-reference/linq-to-entities.md). **Примечание.**  Тем не менее запросы LINQ to Entities, которые применяют оператор `Enumerable.Contains` к коллекции в памяти, автоматически не кэшируются. Также в скомпилированных запросах LINQ не допускаются коллекции в памяти с параметрами.|  
|Выполнение запроса|Низкий<sup>2</sup>|Один раз для каждого запроса.|Затраты на выполнение команды к источнику данных с помощью поставщика данных ADO.NET. Поскольку большинство источников данных кэширует планы запросов, при последующем выполнении один и тот же запрос может занимать меньше времени.|  
|Загрузка и проверка типов|Низкий<sup>3</sup>|Один раз для каждого элемента <xref:System.Data.Objects.ObjectContext>.|Типы загружаются и проверяются относительно типов, определенных в концептуальной модели.|  
|Отслеживание|Низкий<sup>3</sup>|Один раз для каждого объекта, возвращаемого запросом. <sup>4</sup>|Если запрос использует параметр слияния <xref:System.Data.Objects.MergeOption.NoTracking>, то этот шаг не влияет на производительность.<br /><br /> Если запрос использует параметры слияния <xref:System.Data.Objects.MergeOption.AppendOnly>, <xref:System.Data.Objects.MergeOption.PreserveChanges> или <xref:System.Data.Objects.MergeOption.OverwriteChanges>, то результаты запроса отслеживаются в <xref:System.Data.Objects.ObjectStateManager>. Для каждого отслеживаемого объекта, возвращаемого запросом, создается ключ <xref:System.Data.EntityKey>, который используется для создания <xref:System.Data.Objects.ObjectStateEntry> в <xref:System.Data.Objects.ObjectStateManager>. Если для <xref:System.Data.Objects.ObjectStateEntry> можно найти существующий объект <xref:System.Data.EntityKey>, то возвращается существующий объект. Если используется параметр <xref:System.Data.Objects.MergeOption.PreserveChanges> или <xref:System.Data.Objects.MergeOption.OverwriteChanges>, то объект обновляется до возвращения.<br /><br /> Дополнительные сведения см. в разделе [разрешение идентичности, управление состоянием и отслеживание изменений](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).|  
|Материализация объектов|Средняя<sup>3</sup>|Один раз для каждого объекта, возвращаемого запросом. <sup>4</sup>|Процесс считывания возвращенного объекта <xref:System.Data.Common.DbDataReader>, создания объектов и установки значений свойств, основанных на значениях в каждом экземпляре класса <xref:System.Data.Common.DbDataRecord>. Если объект уже существует в классе <xref:System.Data.Objects.ObjectContext> и в запросе используются параметры слияния <xref:System.Data.Objects.MergeOption.AppendOnly> или <xref:System.Data.Objects.MergeOption.PreserveChanges>, то этот шаг не влияет на производительность. Дополнительные сведения см. в разделе [разрешение идентичности, управление состоянием и отслеживание изменений](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).|  
  
 <sup>1</sup> при поставщик источника данных реализована организация пулов соединений, затраты на открытие подключения распространяется по всему пулу. Поставщик .NET для SQL Server поддерживает организацию пулов соединений.  
  
 <sup>2</sup> затраты возрастают с повышением сложности запросов.  
  
 <sup>3</sup> общие затраты возрастают пропорционально числу объектов, возвращенных запросом.  
  
 <sup>4</sup> эти издержки не нужны для запросов EntityClient, поскольку они возвращают <xref:System.Data.EntityClient.EntityDataReader> вместо объектов. Дополнительные сведения см. в разделе [поставщик EntityClient для Entity Framework](../../../../../docs/framework/data/adonet/ef/entityclient-provider-for-the-entity-framework.md).  
  
## <a name="additional-considerations"></a>Дополнительные сведения  
 Ниже приведены дополнительные соображения по факторам, способным влиять на производительность приложений Entity Framework.  
  
### <a name="query-execution"></a>Выполнение запроса  
 Поскольку запросы могут быть ресурсоемкими, учитывайте, в каком участке кода и на каком компьютере выполняется запрос.  
  
#### <a name="deferred-versus-immediate-execution"></a>Отложенное или немедленное выполнение  
 При создании запроса <xref:System.Data.Objects.ObjectQuery%601> или LINQ запрос может выполняться не сразу. Выполнение запроса откладывается до тех пор, пока не понадобятся его результаты, например результаты перечисления `foreach` (C#) или `For Each` (Visual Basic), либо если запрос должен заполнить коллекцию <xref:System.Collections.Generic.List%601>. Выполнение запроса начинается немедленно при вызове метода <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> в <xref:System.Data.Objects.ObjectQuery%601> либо при вызове метода LINQ, возвращающего одноэлементный запрос, например <xref:System.Linq.Enumerable.First%2A> или <xref:System.Linq.Enumerable.Any%2A>. Дополнительные сведения см. в разделе [запросы объектов](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)) и [выполнение запросов (LINQ to Entities)](../../../../../docs/framework/data/adonet/ef/language-reference/query-execution.md).  
  
#### <a name="client-side-execution-of-linq-queries"></a>Выполнение запросов LINQ на стороне клиента  
 Хотя запрос LINQ выполняется на том компьютере, где размещен источник данных, некоторые части запроса LINQ могут обрабатываться на клиентском компьютере. Дополнительные сведения см. в разделе выполнения Store [выполнение запросов (LINQ to Entities)](../../../../../docs/framework/data/adonet/ef/language-reference/query-execution.md).  
  
### <a name="query-and-mapping-complexity"></a>Сложность запросов и сопоставления  
 Сложность отдельных запросов и сопоставления в модели сущности значительно влияет на производительность запросов.  
  
#### <a name="mapping-complexity"></a>Сложность сопоставления  
 Модели, более сложные, чем простое однозначное сопоставление между сущностями в концептуальной модели и таблицах в режиме хранилища, приводят к созданию более сложных команд, чем модели с однозначным сопоставлением.  
  
#### <a name="query-complexity"></a>Сложность запросов  
 Запросы, требующие большого числа соединений в командах, выполняемых с источником данных или возвращающих большой объем данных, могут влиять на производительность следующим образом:  
  
- Запросы к концептуальной модели, которые кажутся простыми, могут приводить к выполнению более сложных запросов к источнику данных. Это может происходить как следствие преобразования платформой Entity Framework запроса к концептуальной модели в эквивалентный запрос к источнику данных. Если один набор сущностей, заданный в концептуальной модели, сопоставляется с несколькими таблицами источника данных либо если связь между сущностями сопоставлена с соединяемой таблицей, то команда запроса к источнику данных может потребовать одного или нескольких соединений.  
  
    > [!NOTE]
    >  Чтобы просмотреть команды, выполняемые по источнику данных для данного запроса, воспользуйтесь методом <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> классов <xref:System.Data.Objects.ObjectQuery%601> или <xref:System.Data.EntityClient.EntityCommand>. Дополнительные сведения см. в разделе [Как Просмотреть команды Store](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).  
  
- Вложенные запросы Entity SQL могут создавать соединения на сервере, а также возвращать большое количество строк.  
  
     Далее приведен пример вложенного запроса в предложении проекции:  
  
    ```  
    SELECT c, (SELECT c, (SELECT c FROM AdventureWorksModel.Vendor AS c  ) As Inner2   
        FROM AdventureWorksModel.JobCandidate AS c  ) As Inner1   
        FROM AdventureWorksModel.EmployeeDepartmentHistory AS c  
    ```  
  
     Кроме того, подобные запросы заставляют конвейер запросов создавать одиночный запрос с дублированием объектов во вложенных запросах. В результате одиночный столбец может дублироваться несколько раз. В некоторых базах данных, в том числе SQL Server, это может приводить к чрезмерному значительному разрастанию таблицы TempDB, что снижает производительность сервера. Вложенные запросы следует выполнять с осторожностью.  
  
- Любые запросы, возвращающие большие объемы данных, могут снижать производительность, если клиент выполняет операции, использующие ресурсы пропорционально объему результирующего набора. В таких случаях, возможно, стоит ограничить объем данных, возвращаемых запросом. Дополнительные сведения см. в разделе [Как Постранично просмотреть результаты запроса](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).  
  
 Любые команды, автоматически созданные платформой Entity Framework, могут оказываться сложнее аналогичных команд, написанных вручную разработчиком базы данных. Если требуется явный контроль над командами, выполняемыми с источником данных, подумайте об определении сопоставления с возвращающей табличное значение функцией или хранимой процедурой.  
  
#### <a name="relationships"></a>Отношения  
 Для оптимальной производительности запросов необходимо определить связи между сущностями как в виде ассоциаций в модели сущности, так и в виде логических связей в источнике данных.  
  
### <a name="query-paths"></a>Пути запроса  
 По умолчанию при выполнении запроса <xref:System.Data.Objects.ObjectQuery%601> связанные объекты не возвращаются (хотя возвращаются объекты, представляющие сами связи). Связанные объекты можно загрузить одним из трех способов.  
  
1. Задайте путь запроса до выполнения <xref:System.Data.Objects.ObjectQuery%601>.  
  
2. Вызовите метод `Load` для свойства навигации, доступного для объекта.  
  
3. Установите параметр <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> объекта <xref:System.Data.Objects.ObjectContext> в значение `true`. Обратите внимание, что это выполняется автоматически при создании кода уровня объекта с [конструктора моделей EDM](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100)). Дополнительные сведения см. в разделе [созданные общие сведения о коде](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100)).  
  
 При выборе параметра помните, что придется соблюдать баланс между числом запросов к базе данных и объемом данных, возвращаемых в одном запросе. Дополнительные сведения см. в разделе [загрузка связанных объектов](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).  
  
#### <a name="using-query-paths"></a>Использование путей запроса  
 Пути запроса определяют граф объектов, возвращаемых запросом. При указании пути запроса для возврата всех определенных в нем объектов требуется только один запрос к базе данных. Использование путей запроса может привести к тому, что над источником данных будут выполняться сложные команды из, на первый взгляд, простых запросов к объектам. Происходит это потому, что для возвращения связанных объектов в рамках одного запроса требуется одно или несколько соединений. Сложность будет выше в запросах к сложным моделям сущностей, таким как, например, сущность с наследованием или путь, содержащий связи «многие ко многим».  
  
> [!NOTE]
>  Используйте метод <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A>, чтобы увидеть команду, которая будет сформирована методом <xref:System.Data.Objects.ObjectQuery%601>. Дополнительные сведения см. в разделе [Как Просмотреть команды Store](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).  
  
 Когда путь запроса содержит слишком много связанных объектов или эти объекты содержат слишком много строковых данных, источник данных может оказаться не в состоянии выполнить запрос. Это происходит, если запросу требуется промежуточное временное хранилище, которое превышает возможности источника данных. В этом случае можно снизить сложность запроса к источнику данных путем явной загрузки связанных объектов.  
  
#### <a name="explicitly-loading-related-objects"></a>Явная загрузка связанных объектов  
 Явно загрузить связанные объекты можно, вызвав метод `Load` для свойства навигации, возвращающего <xref:System.Data.Objects.DataClasses.EntityCollection%601> или <xref:System.Data.Objects.DataClasses.EntityReference%601>. При явной загрузке объектов требуется выполнять цикл обмена данными с базой данных при каждом вызове метода `Load`.  
  
> [!NOTE]
>  Если при циклической обработке коллекции возвращенных объектов, например при использовании инструкции `Load` (`foreach` в Visual Basic), вызывается метод `For Each`, поставщик для каждого конкретного источника данных должен поддерживать несколько активных результирующих наборов на одном соединении. Для базы данных SQL Server в строке подключения поставщика необходимо указать значение `MultipleActiveResultSets = true`.  
  
 Можно также использовать метод <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>, если сущности не имеют свойств <xref:System.Data.Objects.DataClasses.EntityCollection%601> и <xref:System.Data.Objects.DataClasses.EntityReference%601>. Это может оказаться полезным в том случае, если используются сущности POCO.  
  
 Хотя явная загрузка связанных объектов сократит число соединений и объем избыточных данных, метод `Load` потребует повторного соединения к базе данных, что может привести к повышении накладных расходов при загрузке большого числа объектов.  
  
### <a name="saving-changes"></a>Сохранение изменений  
 При вызове метода <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> для <xref:System.Data.Objects.ObjectContext> для каждого добавленного, обновленного или удаленного объекта в контексте создается отдельная команда создания, обновления или удаления. Эти команды выполняются для источника данных в единой транзакции. Как и в случае с запросами, производительность операций создания, обновления и удаления зависит от сложности сопоставления в концептуальной модели.  
  
### <a name="distributed-transactions"></a>Распределенные транзакции  
 Операции в явной транзакции, требующие ресурсов, управляемых координатором распределенных транзакций (DTC), будут гораздо затратнее, чем схожая операция, не требующая его использования. Повышение уровня явных транзакций до DTC будет происходить в следующих случаях.  
  
- Явная транзакция с операцией для базы данных SQL Server 2000 или другого источника данных, который всегда повышает уровень явных транзакций до DTC.  
  
- Явная транзакция с операцией для SQL Server 2005, если соединение управляется [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]. Причина этого заключается в том, что SQL Server 2005 передает транзакцию в DTC при каждом закрытии и повторном открытии соединения в пределах одной транзакции, что является поведением [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] по умолчанию. Такое повышение уровня до DTC не происходит при использовании SQL Server 2008. Чтобы избежать такого повышения уровня при работе с SQL Server 2005, необходимо явно открывать и закрывать соединение в пределах одной транзакции. Дополнительные сведения см. в разделе [Управление соединениями и транзакциями](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).  
  
 Явная транзакция используется, если в пределах транзакции <xref:System.Transactions> выполняется одна или несколько операций. Дополнительные сведения см. в разделе [Управление соединениями и транзакциями](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).  
  
## <a name="strategies-for-improving-performance"></a>Стратегии повышения производительности  
 Ниже перечислены методики, позволяющие повысить общую производительность запросов платформы Entity Framework.  
  
#### <a name="pre-generate-views"></a>Предварительное создание представлений  
 Создание представлений на базе модели сущностей - это значительная статья расходов при первом выполнении запроса приложением. С помощью программы EdmGen.exe можно заранее создавать представления в виде файлов с кодом Visual Basic или C#, которые будут добавляться в проект во время проектирования. Можно также использовать средства преобразования текстовых шаблонов для создания представлений до компиляции. Предварительно созданные представления во время выполнения будут проверяться на согласованность с текущей версией указанной модели сущностей. Дополнительные сведения см. в разделе [Как Предварительное создание представлений для повышения производительности запросов](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).
  
 При работе с очень большими моделями нужно принимать во внимание следующие соображения.  
  
 Формат метаданных .NET ограничивает число символов пользовательской строки в заданном двоичном блоке до 16 777 215 (0xFFFFFF). Если при создании представлений для очень большой модели файл представления достигает ограничения размера, вы получите «не осталось логического пространства для создания дополнительных пользовательских строк.» Ошибка компиляции. Это ограничение имеет силу для всех управляемых библиотек. Дополнительные сведения см. в разделе [блог](https://go.microsoft.com/fwlink/?LinkId=201476) показано, как избежать ошибок при работе с большими и сложными моделями.  
  
#### <a name="consider-using-the-notracking-merge-option-for-queries"></a>Рассмотрите возможность использования параметра слияния NoTracking для запросов  
 Для отслеживания возвращаемых объектов в контексте объекта требуются определенные затраты. Для распознавания изменений в объектах и гарантии того, что несколько запросов к одной логической сущности возвратят один экземпляр объекта, требуется, чтобы объекты были присоединены к экземпляру <xref:System.Data.Objects.ObjectContext>. Если вы не планируете для обновления или удаления объектов и не требуют управления удостоверениями, рассмотрите возможность использования <xref:System.Data.Objects.MergeOption.NoTracking> параметры слияния, при выполнении запросов.  
  
#### <a name="return-the-correct-amount-of-data"></a>Возвращение правильного объема данных  
 В некоторых случаях указание пути запроса с помощью метода <xref:System.Data.Objects.ObjectQuery%601.Include%2A> выполняется гораздо быстрее, поскольку требуется меньше циклов обмена данными с базой данных. Однако в других сценариях дополнительные циклы обмена данными с базой данных при загрузке связанных объектов могут выполняться быстрее, поскольку более простые запросы с меньшим количеством соединений ведут к меньшей избыточности данных. В связи с этим рекомендуется проверять производительность разных способов получения связанных объектов. Дополнительные сведения см. в разделе [загрузка связанных объектов](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).  
  
 Чтобы избежать возвращения слишком большого объема данных в одном запросе, можно прибегнуть к подкачке страниц результатов запроса, что даст более простые в управлении группы. Дополнительные сведения см. в разделе [Как Постранично просмотреть результаты запроса](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).  
  
#### <a name="limit-the-scope-of-the-objectcontext"></a>Ограничение области объекта ObjectContext  
 В большинстве случаев следует создавать экземпляр <xref:System.Data.Objects.ObjectContext> внутри инструкции `using` (`Using…End Using` в Visual Basic). Это может повысить производительность, поскольку гарантирует автоматическое удаление ресурсов, связанных с контекстом объекта, при выходе из блока инструкции в коде. Однако, если элементы управления привязаны к объектам, управляемым контекстом объекта, экземпляр <xref:System.Data.Objects.ObjectContext> следует сохранять до тех пор, пока требуется привязка, а удалять его - вручную. Дополнительные сведения см. в разделе [Управление соединениями и транзакциями](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).  
  
#### <a name="consider-opening-the-database-connection-manually"></a>Рассмотрите возможность подключения базы данных вручную  
 Если приложение выполняет серию запросов объектов или часто вызывает метод <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> для сохранения создания, обновления и удаления, выполняемых к источнику данных, [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] приходится постоянно открывать и закрывать соединение с источником данных. В таких случаях следует попробовать вручную открывать соединение в начале этих операций и либо закрывать, либо удалять соединение по их завершении. Дополнительные сведения см. в разделе [Управление соединениями и транзакциями](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).  
  
## <a name="performance-data"></a>Данные производительности  
 Некоторые данные производительности для платформы Entity Framework опубликованы в приведенных ниже сообщениях на [блога группы разработчиков ADO.NET](https://go.microsoft.com/fwlink/?LinkId=91905):  
  
- [Обзор производительности платформы ADO.NET Entity Framework — часть 1](https://go.microsoft.com/fwlink/?LinkId=123907)  
  
- [Обзор производительности платформы ADO.NET Entity Framework — часть 2](https://go.microsoft.com/fwlink/?LinkId=123909)  
  
- [Сравнение производительности платформы ADO.NET Entity Framework](https://go.microsoft.com/fwlink/?LinkID=123913)  
  
## <a name="see-also"></a>См. также

- [Вопросы разработки и развертывания](../../../../../docs/framework/data/adonet/ef/development-and-deployment-considerations.md)
