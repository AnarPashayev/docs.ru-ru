---
title: Извлечение идентификации или значений автонумерации
description: Узнайте, как извлекать идентификаторы и значения автонумерации первичных ключей в реляционных базах данных, а затем объединять новые значения идентификаторов в ADO.NET.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: d6b7f9cb-81be-44e1-bb94-56137954876d
ms.openlocfilehash: dbbc013a5b6c83391a29109beca44120c68d827f
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/02/2020
ms.locfileid: "84286576"
---
# <a name="retrieving-identity-or-autonumber-values"></a><span data-ttu-id="437c2-103">Извлечение идентификации или значений автонумерации</span><span class="sxs-lookup"><span data-stu-id="437c2-103">Retrieving Identity or Autonumber Values</span></span>

<span data-ttu-id="437c2-104">Первичным ключом в реляционной базе данных является столбец или сочетание столбцов, которые всегда содержат уникальные значения.</span><span class="sxs-lookup"><span data-stu-id="437c2-104">A primary key in a relational database is a column or combination of columns that always contain unique values.</span></span> <span data-ttu-id="437c2-105">Если известно значение первичного ключа, то можно найти строку, которая содержит это значение.</span><span class="sxs-lookup"><span data-stu-id="437c2-105">Knowing the primary key value allows you to locate the row that contains it.</span></span> <span data-ttu-id="437c2-106">Такие СУРБД, как SQL Server, Oracle и Microsoft Access/Jet, поддерживают создание столбцов с автоматически увеличивающимися значениями, которые могут назначаться в качестве первичных ключей.</span><span class="sxs-lookup"><span data-stu-id="437c2-106">Relational database engines, such as SQL Server, Oracle, and Microsoft Access/Jet support the creation of automatically incrementing columns that can be designated as primary keys.</span></span> <span data-ttu-id="437c2-107">Эти значения формируются сервером по мере добавления строк в таблицу.</span><span class="sxs-lookup"><span data-stu-id="437c2-107">These values are generated by the server as rows are added to a table.</span></span> <span data-ttu-id="437c2-108">В SQL Server задается свойство идентификатора столбца, в Oracle создается последовательность Sequence, а в Microsoft Access создается столбец AutoNumber.</span><span class="sxs-lookup"><span data-stu-id="437c2-108">In SQL Server, you set the identity property of a column, in Oracle you create a Sequence, and in Microsoft Access you create an AutoNumber column.</span></span>

<span data-ttu-id="437c2-109">Для формирования автоматически увеличивающихся значений также можно использовать объект <xref:System.Data.DataColumn>, присвоив его свойству <xref:System.Data.DataColumn.AutoIncrement%2A> значение true.</span><span class="sxs-lookup"><span data-stu-id="437c2-109">A <xref:System.Data.DataColumn> can also be used to generate automatically incrementing values by setting the <xref:System.Data.DataColumn.AutoIncrement%2A> property to true.</span></span> <span data-ttu-id="437c2-110">Но это может привести к появлению повторяющихся значений в отдельных экземплярах <xref:System.Data.DataTable>, если в нескольких клиентских приложениях будут независимо формироваться автоматически увеличивающиеся значения.</span><span class="sxs-lookup"><span data-stu-id="437c2-110">However, you might end up with duplicate values in separate instances of a <xref:System.Data.DataTable>, if multiple client applications are independently generating automatically incrementing values.</span></span> <span data-ttu-id="437c2-111">Применение сервера для формирования автоматически увеличивающихся значений позволяет устранить потенциальные конфликты, поскольку каждый пользователь может получать создаваемые сервером значения для каждой вставляемой строки.</span><span class="sxs-lookup"><span data-stu-id="437c2-111">Having the server generate automatically incrementing values eliminates potential conflicts by allowing each user to retrieve the generated value for each inserted row.</span></span>

<span data-ttu-id="437c2-112">Во время вызова метода `Update` объекта `DataAdapter` база данных может отправлять данные обратно в приложение ADO.NET в качестве выходных параметров или в виде первой возвращенной записи результирующего набора инструкции SELECT, выполняемой в том же пакете, что и инструкция INSERT.</span><span class="sxs-lookup"><span data-stu-id="437c2-112">During a call to the `Update` method of a `DataAdapter`, the database can send data back to your ADO.NET application as output parameters or as the first returned record of the result set of a SELECT statement executed in the same batch as the INSERT statement.</span></span> <span data-ttu-id="437c2-113">Среда ADO.NET позволяет получать эти значения и обновлять соответствующие столбцы в обновляемом объекте <xref:System.Data.DataRow>.</span><span class="sxs-lookup"><span data-stu-id="437c2-113">ADO.NET can retrieve these values and update the corresponding columns in the <xref:System.Data.DataRow> being updated.</span></span>

<span data-ttu-id="437c2-114">Некоторые СУБД, такие как Microsoft Access Jet, не поддерживают выходные параметры и не могут обрабатывать несколько инструкций в одном пакете.</span><span class="sxs-lookup"><span data-stu-id="437c2-114">Some database engines, such as the Microsoft Access Jet database engine, do not support output parameters and cannot process multiple statements in a single batch.</span></span> <span data-ttu-id="437c2-115">Работая с ядром базы данных Jet, новое значение AutoNumber, создаваемое для вставленной строки, можно получить, выполнив отдельную команду SELECT в обработчике событий `RowUpdated` объекта `DataAdapter`.</span><span class="sxs-lookup"><span data-stu-id="437c2-115">When working with the Jet database engine, you can retrieve the new AutoNumber value generated for an inserted row by executing a separate SELECT command in an event handler for the `RowUpdated` event of the `DataAdapter`.</span></span>

> [!NOTE]
> <span data-ttu-id="437c2-116">Подход, альтернативный по отношению к использованию автоматически увеличивающегося значения, состоит в применении метода <xref:System.Guid.NewGuid%2A> объекта <xref:System.Guid> для формирования идентификатора GUID (глобально уникального идентификатора) на клиентском компьютере, который может копироваться на сервер при вставке каждой новой строки.</span><span class="sxs-lookup"><span data-stu-id="437c2-116">An alternative to using an auto incrementing value is to use the <xref:System.Guid.NewGuid%2A> method of a <xref:System.Guid> object to generate a GUID, or globally unique identifier, on the client computer that can be copied to the server as each new row is inserted.</span></span> <span data-ttu-id="437c2-117">Метод `NewGuid` формирует 16-байтовое двоичное значение с помощью алгоритма, который обеспечивает высокую вероятность того, что ни одно из полученных значений не будет повторяться.</span><span class="sxs-lookup"><span data-stu-id="437c2-117">The `NewGuid` method generates a 16-byte binary value that is created using an algorithm that provides a high probability that no value will be duplicated.</span></span> <span data-ttu-id="437c2-118">В базе данных SQL Server идентификатор GUID хранится в столбце `uniqueidentifier`, который может автоматически создаваться в SQL Server с помощью функции `NEWID()` языка Transact-SQL.</span><span class="sxs-lookup"><span data-stu-id="437c2-118">In a SQL Server database, a GUID is stored in a `uniqueidentifier` column which SQL Server can automatically generate using the Transact-SQL `NEWID()` function.</span></span> <span data-ttu-id="437c2-119">Использование идентификатора GUID в качестве первичного ключа может привести к снижению производительности.</span><span class="sxs-lookup"><span data-stu-id="437c2-119">Using a GUID as a primary key can adversely affect performance.</span></span> <span data-ttu-id="437c2-120">SQL Server обеспечивает поддержку `NEWSEQUENTIALID()` функции, которая создает последовательный идентификатор GUID, который не обязательно должен быть глобально уникальным, но может индексироваться более эффективно.</span><span class="sxs-lookup"><span data-stu-id="437c2-120">SQL Server provides support for the `NEWSEQUENTIALID()` function, which generates a sequential GUID that is not guaranteed to be globally unique but that can be indexed more efficiently.</span></span>

## <a name="retrieving-sql-server-identity-column-values"></a><span data-ttu-id="437c2-121">Получение значений столбца идентификатора в базе данных SQL Server</span><span class="sxs-lookup"><span data-stu-id="437c2-121">Retrieving SQL Server Identity Column Values</span></span>

<span data-ttu-id="437c2-122">При работе с Microsoft SQL Server можно создать хранимую процедуру с выходным параметром, возвращающим значение идентификатора для вставленной строки.</span><span class="sxs-lookup"><span data-stu-id="437c2-122">When working with Microsoft SQL Server, you can create a stored procedure with an output parameter to return the identity value for an inserted row.</span></span> <span data-ttu-id="437c2-123">В следующей таблице описаны три функции Transact-SQL, применимые в SQL Server, с помощью которых можно извлекать значения столбцов идентификаторов.</span><span class="sxs-lookup"><span data-stu-id="437c2-123">The following table describes the three Transact-SQL functions in SQL Server that can be used to retrieve identity column values.</span></span>

|<span data-ttu-id="437c2-124">Компонент</span><span class="sxs-lookup"><span data-stu-id="437c2-124">Function</span></span>|<span data-ttu-id="437c2-125">Описание</span><span class="sxs-lookup"><span data-stu-id="437c2-125">Description</span></span>|
|--------------|-----------------|
|<span data-ttu-id="437c2-126">SCOPE_IDENTITY</span><span class="sxs-lookup"><span data-stu-id="437c2-126">SCOPE_IDENTITY</span></span>|<span data-ttu-id="437c2-127">Возвращает последнее значение идентификатора в текущей области выполнения.</span><span class="sxs-lookup"><span data-stu-id="437c2-127">Returns the last identity value within the current execution scope.</span></span> <span data-ttu-id="437c2-128">В большинстве случаев рекомендуется использовать SCOPE_IDENTITY.</span><span class="sxs-lookup"><span data-stu-id="437c2-128">SCOPE_IDENTITY is recommended for most scenarios.</span></span>|
|<span data-ttu-id="437c2-129">@@IDENTITY</span><span class="sxs-lookup"><span data-stu-id="437c2-129">@@IDENTITY</span></span>|<span data-ttu-id="437c2-130">Содержит последнее значение идентификатора, сформированного в любой таблице в текущем сеансе.</span><span class="sxs-lookup"><span data-stu-id="437c2-130">Contains the last identity value generated in any table in the current session.</span></span> <span data-ttu-id="437c2-131">на @ @IDENTITY могут воздействовать триггеры и не возвращать желаемое значение идентификатора.</span><span class="sxs-lookup"><span data-stu-id="437c2-131">@@IDENTITY can be affected by triggers and may not return the identity value that you expect.</span></span>|
|<span data-ttu-id="437c2-132">IDENT_CURRENT</span><span class="sxs-lookup"><span data-stu-id="437c2-132">IDENT_CURRENT</span></span>|<span data-ttu-id="437c2-133">Возвращает последнее значение идентификатора, сформированное для указанной таблицы в любом сеансе и любой области.</span><span class="sxs-lookup"><span data-stu-id="437c2-133">Returns the last identity value generated for a specific table in any session and any scope.</span></span>|

 <span data-ttu-id="437c2-134">В следующей хранимой процедуре показано, как вставить строку в таблицу **Categories** и использовать выходной параметр для возврата нового значения Identity, созданного функцией TRANSACT-SQL SCOPE_IDENTITY ().</span><span class="sxs-lookup"><span data-stu-id="437c2-134">The following stored procedure demonstrates how to insert a row into the **Categories** table and use an output parameter to return the new identity value generated by the Transact-SQL SCOPE_IDENTITY() function.</span></span>

```sql
CREATE PROCEDURE dbo.InsertCategory
  @CategoryName nvarchar(15),
  @Identity int OUT
AS
INSERT INTO Categories (CategoryName) VALUES(@CategoryName)
SET @Identity = SCOPE_IDENTITY()
```

<span data-ttu-id="437c2-135">После этого данную хранимую процедуру можно указать в качестве источника <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A> объекта <xref:System.Data.SqlClient.SqlDataAdapter>.</span><span class="sxs-lookup"><span data-stu-id="437c2-135">The stored procedure can then be specified as the source of the <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A> of a <xref:System.Data.SqlClient.SqlDataAdapter> object.</span></span> <span data-ttu-id="437c2-136">Свойство <xref:System.Data.SqlClient.SqlCommand.CommandType%2A> объекта <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A> должно иметь значение <xref:System.Data.CommandType.StoredProcedure>.</span><span class="sxs-lookup"><span data-stu-id="437c2-136">The <xref:System.Data.SqlClient.SqlCommand.CommandType%2A> property of the <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A> must be set to <xref:System.Data.CommandType.StoredProcedure>.</span></span> <span data-ttu-id="437c2-137">Получение выходного значения идентификатора осуществляется путем создания объекта <xref:System.Data.SqlClient.SqlParameter>, который имеет свойство <xref:System.Data.ParameterDirection> со значением <xref:System.Data.ParameterDirection.Output>.</span><span class="sxs-lookup"><span data-stu-id="437c2-137">The identity output is retrieved by creating a <xref:System.Data.SqlClient.SqlParameter> that has a <xref:System.Data.ParameterDirection> of <xref:System.Data.ParameterDirection.Output>.</span></span> <span data-ttu-id="437c2-138">Когда `InsertCommand` обрабатывается, автоматически увеличивающееся значение идентификатора возвращается и помещается в столбец **CategoryID** текущей строки, если <xref:System.Data.SqlClient.SqlCommand.UpdatedRowSource%2A> для свойства команды INSERT задано значение `UpdateRowSource.OutputParameters` или `UpdateRowSource.Both` .</span><span class="sxs-lookup"><span data-stu-id="437c2-138">When the `InsertCommand` is processed, the auto-incremented identity value is returned and placed in the **CategoryID** column of the current row if you set the <xref:System.Data.SqlClient.SqlCommand.UpdatedRowSource%2A> property of the insert command to `UpdateRowSource.OutputParameters` or to `UpdateRowSource.Both`.</span></span>

<span data-ttu-id="437c2-139">Если в команде вставки выполняется пакет, который включает и инструкцию INSERT, и инструкцию SELECT, возвращающую новое значение идентификатора, то это новое значение можно получить, задав свойство `UpdatedRowSource` команды вставки, равное `UpdateRowSource.FirstReturnedRecord`.</span><span class="sxs-lookup"><span data-stu-id="437c2-139">If your insert command executes a batch that includes both an INSERT statement and a SELECT statement that returns the new identity value, then you can retrieve the new value by setting the `UpdatedRowSource` property of the insert command to `UpdateRowSource.FirstReturnedRecord`.</span></span>

[!code-csharp[DataWorks SqlClient.RetrieveIdentityStoredProcedure#1](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlClient.RetrieveIdentityStoredProcedure/CS/source.cs#1)]
[!code-vb[DataWorks SqlClient.RetrieveIdentityStoredProcedure#1](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlClient.RetrieveIdentityStoredProcedure/VB/source.vb#1)]

## <a name="merging-new-identity-values"></a><span data-ttu-id="437c2-140">Слияние новых значений идентификаторов</span><span class="sxs-lookup"><span data-stu-id="437c2-140">Merging New Identity Values</span></span>

<span data-ttu-id="437c2-141">Распространенный сценарий состоит в вызове метода `GetChanges` объекта `DataTable` для создания копии, которая содержит только изменившиеся строки, после чего эта новая копия используется при вызове метода `Update` объекта `DataAdapter`.</span><span class="sxs-lookup"><span data-stu-id="437c2-141">A common scenario is to call the `GetChanges` method of a `DataTable` to create a copy that contains only changed rows, and to use the new copy when calling the `Update` method of a `DataAdapter`.</span></span> <span data-ttu-id="437c2-142">Это особенно удобно, если требуется маршалировать и передать изменившиеся строки для отдельного компонента, который выполняет обновление.</span><span class="sxs-lookup"><span data-stu-id="437c2-142">This is especially useful when you need to marshal the changed rows to a separate component that performs the update.</span></span> <span data-ttu-id="437c2-143">После обновления эта копия может содержать новые значения идентификаторов, которые затем должны быть переданы обратно в оригинал `DataTable` для слияния.</span><span class="sxs-lookup"><span data-stu-id="437c2-143">Following the update, the copy can contain new identity values that must then be merged back into the original `DataTable`.</span></span> <span data-ttu-id="437c2-144">Причем новые значения идентификаторов, по всей вероятности, будут отличаться от исходных значений в `DataTable`.</span><span class="sxs-lookup"><span data-stu-id="437c2-144">The new identity values are likely to be different from the original values in the `DataTable`.</span></span> <span data-ttu-id="437c2-145">Чтобы выполнить слияние, исходные значения столбцов **AutoIncrement** в копии должны быть сохранены, чтобы иметь возможность размещать и обновлять существующие строки в исходном виде `DataTable` , а не добавлять новые строки, содержащие новые значения идентификаторов.</span><span class="sxs-lookup"><span data-stu-id="437c2-145">To accomplish the merge, the original values of the **AutoIncrement** columns in the copy must be preserved, in order to be able to locate and update existing rows in the original `DataTable`, rather than appending new rows containing the new identity values.</span></span> <span data-ttu-id="437c2-146">Однако по умолчанию эти первоначальные значения теряются после вызова метода `Update` объекта `DataAdapter`, поскольку для каждой обновляемой строки `AcceptChanges` неявно вызывается метод `DataRow`.</span><span class="sxs-lookup"><span data-stu-id="437c2-146">However, by default those original values are lost after a call to the `Update` method of a `DataAdapter`, because `AcceptChanges` is implicitly called for each updated `DataRow`.</span></span>

<span data-ttu-id="437c2-147">Существует два способа сохранения первоначальных значений `DataColumn` в объекте `DataRow` во время обновления `DataAdapter`.</span><span class="sxs-lookup"><span data-stu-id="437c2-147">There are two ways to preserve the original values of a `DataColumn` in a `DataRow` during a `DataAdapter` update:</span></span>

- <span data-ttu-id="437c2-148">Первый способ сохранения первоначальных значений состоит в присвоении свойству `AcceptChangesDuringUpdate` объекта `DataAdapter` значения `false`.</span><span class="sxs-lookup"><span data-stu-id="437c2-148">The first method of preserving the original values is to set the `AcceptChangesDuringUpdate` property of the `DataAdapter` to `false`.</span></span> <span data-ttu-id="437c2-149">Это влияет на каждый объект `DataRow` в обновляемом объекте `DataTable`.</span><span class="sxs-lookup"><span data-stu-id="437c2-149">This affects every `DataRow` in the `DataTable` being updated.</span></span> <span data-ttu-id="437c2-150">Дополнительные сведения и пример кода см. в разделе <xref:System.Data.Common.DataAdapter.AcceptChangesDuringUpdate%2A>.</span><span class="sxs-lookup"><span data-stu-id="437c2-150">For more information and a code example, see <xref:System.Data.Common.DataAdapter.AcceptChangesDuringUpdate%2A>.</span></span>

- <span data-ttu-id="437c2-151">Второй способ предусматривает применение в обработчике событий `RowUpdated` объекта `DataAdapter` кода, в котором свойству <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> присваивается значение <xref:System.Data.UpdateStatus.SkipCurrentRow>.</span><span class="sxs-lookup"><span data-stu-id="437c2-151">The second method is to write code in the `RowUpdated` event handler of the `DataAdapter` to set the <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> to <xref:System.Data.UpdateStatus.SkipCurrentRow>.</span></span> <span data-ttu-id="437c2-152">Значение `DataRow` обновляется, но первоначальное значение каждого объекта `DataColumn` сохраняется.</span><span class="sxs-lookup"><span data-stu-id="437c2-152">The `DataRow` is updated but the original value of each `DataColumn` is preserved.</span></span> <span data-ttu-id="437c2-153">Этот способ позволяет сохранять первоначальные значения одних строк, но не других.</span><span class="sxs-lookup"><span data-stu-id="437c2-153">This method enables you to preserve the original values for some rows and not for others.</span></span> <span data-ttu-id="437c2-154">Например, в коде можно сохранить первоначальные значения добавляемых строк, а не изменяемых или удаляемых строк путем проверки значения <xref:System.Data.Common.RowUpdatedEventArgs.StatementType%2A> с последующим присваиванием свойству <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> значения <xref:System.Data.UpdateStatus.SkipCurrentRow> только для строк со свойством `StatementType` равным `Insert`.</span><span class="sxs-lookup"><span data-stu-id="437c2-154">For example, your code can preserve the original values for added rows and not for edited or deleted rows by first checking the <xref:System.Data.Common.RowUpdatedEventArgs.StatementType%2A> and then setting <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> to <xref:System.Data.UpdateStatus.SkipCurrentRow> only for rows with a `StatementType` of `Insert`.</span></span>

<span data-ttu-id="437c2-155">Если любой из этих способов используется для сохранения первоначальных значений в объекте `DataRow` во время обновления `DataAdapter`, то в приложении ADO.NET выполняется ряд действий по замене текущих значений `DataRow` на новые значения, возвращаемые в качестве выходных параметров или в виде первой возвращаемой строки результирующего набора, с сохранением первоначального значения в каждом `DataColumn`.</span><span class="sxs-lookup"><span data-stu-id="437c2-155">When either of these methods is used to preserve original values in a `DataRow` during a `DataAdapter` update, ADO.NET performs a series of actions to set the current values of the `DataRow` to new values returned by output parameters or by the first returned row of a result set, while still preserving the original value in each `DataColumn`.</span></span> <span data-ttu-id="437c2-156">Сначала вызывается метод `AcceptChanges` объекта `DataRow` для сохранения текущих значений в качестве первоначальных значений, а затем присваиваются новые значения.</span><span class="sxs-lookup"><span data-stu-id="437c2-156">First, the `AcceptChanges` method of the `DataRow` is called to preserve the current values as original values, and then the new values are assigned.</span></span> <span data-ttu-id="437c2-157">После этого у объектов `DataRows`, у которых свойство <xref:System.Data.DataRow.RowState%2A> равно <xref:System.Data.DataRowState.Added>, значение этого свойства `RowState` заменяется на <xref:System.Data.DataRowState.Modified>, что может не соответствовать ожиданиям.</span><span class="sxs-lookup"><span data-stu-id="437c2-157">Following these actions, `DataRows` that had their <xref:System.Data.DataRow.RowState%2A> property set to <xref:System.Data.DataRowState.Added> will have their `RowState` property set to <xref:System.Data.DataRowState.Modified>, which may be unexpected.</span></span>

<span data-ttu-id="437c2-158">Способ применения результатов команды к каждому обновляемому объекту <xref:System.Data.DataRow> определяется свойством <xref:System.Data.Common.DbCommand.UpdatedRowSource%2A> каждой команды <xref:System.Data.Common.DbCommand>.</span><span class="sxs-lookup"><span data-stu-id="437c2-158">How the command results are applied to each <xref:System.Data.DataRow> being updated is determined by the <xref:System.Data.Common.DbCommand.UpdatedRowSource%2A> property of each <xref:System.Data.Common.DbCommand>.</span></span> <span data-ttu-id="437c2-159">Это свойство задается равным одному из значений из перечисления `UpdateRowSource`.</span><span class="sxs-lookup"><span data-stu-id="437c2-159">This property is set to a value from the `UpdateRowSource` enumeration.</span></span>

<span data-ttu-id="437c2-160">В следующей таблице приведено описание того, как значения перечисления `UpdateRowSource` влияют на свойство <xref:System.Data.DataRow.RowState%2A> обновленных строк.</span><span class="sxs-lookup"><span data-stu-id="437c2-160">The following table describes how the `UpdateRowSource` enumeration values affect the <xref:System.Data.DataRow.RowState%2A> property of updated rows.</span></span>

|<span data-ttu-id="437c2-161">Имя члена</span><span class="sxs-lookup"><span data-stu-id="437c2-161">Member name</span></span>|<span data-ttu-id="437c2-162">Описание</span><span class="sxs-lookup"><span data-stu-id="437c2-162">Description</span></span>|
|-----------------|-----------------|
|<xref:System.Data.UpdateRowSource.Both>|<span data-ttu-id="437c2-163">Вызывается метод `AcceptChanges`, после чего значения выходных параметров и (или) значения из первой строки любого возвращенного результирующего набора помещаются в обновляемый объект `DataRow`.</span><span class="sxs-lookup"><span data-stu-id="437c2-163">`AcceptChanges` is called and both output parameter values and/or the values in the first row of any returned result set are placed in the `DataRow` being updated.</span></span> <span data-ttu-id="437c2-164">Если применимые значения отсутствуют, то `RowState` становится равным <xref:System.Data.DataRowState.Unchanged>.</span><span class="sxs-lookup"><span data-stu-id="437c2-164">If there are no values to apply, the `RowState` will be <xref:System.Data.DataRowState.Unchanged>.</span></span>|
|<xref:System.Data.UpdateRowSource.FirstReturnedRecord>|<span data-ttu-id="437c2-165">Если возвращена строка, вызывается метод `AcceptChanges`, и эта строка сопоставляется с измененной строкой в `DataTable`, в связи с чем свойству `RowState` присваивается значение `Modified`.</span><span class="sxs-lookup"><span data-stu-id="437c2-165">If a row was returned, `AcceptChanges` is called and the row is mapped to the changed row in the `DataTable`, setting the `RowState` to `Modified`.</span></span> <span data-ttu-id="437c2-166">Если не возвращена ни одна строка, то метод `AcceptChanges` не вызывается, и `RowState` остается равным `Added`.</span><span class="sxs-lookup"><span data-stu-id="437c2-166">If no row is returned, then `AcceptChanges` is not called and the `RowState` remains `Added`.</span></span>|
|<xref:System.Data.UpdateRowSource.None>|<span data-ttu-id="437c2-167">Любые возвращенные параметры или строки пропускаются.</span><span class="sxs-lookup"><span data-stu-id="437c2-167">Any returned parameters or rows are ignored.</span></span> <span data-ttu-id="437c2-168">Метод `AcceptChanges` не вызывается, и `RowState` остается равным `Added`.</span><span class="sxs-lookup"><span data-stu-id="437c2-168">There is no call to `AcceptChanges` and the `RowState` remains `Added`.</span></span>|
|<xref:System.Data.UpdateRowSource.OutputParameters>|<span data-ttu-id="437c2-169">Вызывается метод `AcceptChanges`, и все выходные параметры сопоставляются с измененной строкой в `DataTable`, в связи с чем свойству `RowState` присваивается значение `Modified`.</span><span class="sxs-lookup"><span data-stu-id="437c2-169">`AcceptChanges` is called and any output parameters are mapped to the changed row in the `DataTable`, setting the `RowState` to `Modified`.</span></span> <span data-ttu-id="437c2-170">Если выходные параметры отсутствуют, то `RowState` становится равным `Unchanged`.</span><span class="sxs-lookup"><span data-stu-id="437c2-170">If there are no output parameters, the `RowState` will be `Unchanged`.</span></span>|

### <a name="example"></a><span data-ttu-id="437c2-171">Пример</span><span class="sxs-lookup"><span data-stu-id="437c2-171">Example</span></span>

<span data-ttu-id="437c2-172">В этом примере демонстрируется извлечение измененных строк из `DataTable` и использование объекта <xref:System.Data.SqlClient.SqlDataAdapter> для обновления источника данных и получения нового значения столбца идентификаторов.</span><span class="sxs-lookup"><span data-stu-id="437c2-172">This example demonstrates extracting changed rows from a `DataTable` and using a <xref:System.Data.SqlClient.SqlDataAdapter> to update the data source and retrieve a new identity column value.</span></span> <span data-ttu-id="437c2-173">В <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A> выполняются две инструкции Transact-SQL; первая из них представляет собой инструкцию INSERT, а вторая является инструкцией SELECT, в которой для получения значения идентификатора используется функция SCOPE_IDENTITY.</span><span class="sxs-lookup"><span data-stu-id="437c2-173">The <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A> executes two Transact-SQL statements; the first one is the INSERT statement, and the second one is a SELECT statement that uses the SCOPE_IDENTITY function to retrieve the identity value.</span></span>

```sql
INSERT INTO dbo.Shippers (CompanyName)
VALUES (@CompanyName);
SELECT ShipperID, CompanyName FROM dbo.Shippers
WHERE ShipperID = SCOPE_IDENTITY();
```

<span data-ttu-id="437c2-174">Свойство `UpdatedRowSource` команды вставки задается равным `UpdateRowSource.FirstReturnedRow`, а свойство <xref:System.Data.MissingSchemaAction> объекта `DataAdapter` задается равным `MissingSchemaAction.AddWithKey`.</span><span class="sxs-lookup"><span data-stu-id="437c2-174">The `UpdatedRowSource` property of the insert command is set to `UpdateRowSource.FirstReturnedRow` and the <xref:System.Data.MissingSchemaAction> property of the `DataAdapter` is set to `MissingSchemaAction.AddWithKey`.</span></span> <span data-ttu-id="437c2-175">Объект `DataTable` заполняется, и в коде происходит добавление новой строки к `DataTable`.</span><span class="sxs-lookup"><span data-stu-id="437c2-175">The `DataTable` is filled and the code adds a new row to the `DataTable`.</span></span> <span data-ttu-id="437c2-176">Затем измененные строки извлекаются в новый объект `DataTable`, передаваемый в `DataAdapter`, с помощью которого после этого происходит обновление на сервере.</span><span class="sxs-lookup"><span data-stu-id="437c2-176">The changed rows are then extracted into a new `DataTable`, which is passed to the `DataAdapter`, which then updates the server.</span></span>

[!code-csharp[DataWorks SqlClient.MergeIdentity#1](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlClient.MergeIdentity/CS/source.cs#1)]
[!code-vb[DataWorks SqlClient.MergeIdentity#1](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlClient.MergeIdentity/VB/source.vb#1)]

<span data-ttu-id="437c2-177">В обработчике событий `OnRowUpdated` проверяется значение <xref:System.Data.Common.RowUpdatedEventArgs.StatementType%2A> свойства <xref:System.Data.SqlClient.SqlRowUpdatedEventArgs>, чтобы определить, была ли вставлена данная строка.</span><span class="sxs-lookup"><span data-stu-id="437c2-177">The `OnRowUpdated` event handler checks the <xref:System.Data.Common.RowUpdatedEventArgs.StatementType%2A> of the <xref:System.Data.SqlClient.SqlRowUpdatedEventArgs> to determine if the row is an insert.</span></span> <span data-ttu-id="437c2-178">Если результат этой проверки является положительным, то свойство <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> задается равным <xref:System.Data.UpdateStatus.SkipCurrentRow>.</span><span class="sxs-lookup"><span data-stu-id="437c2-178">If it is, then the <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> property is set to <xref:System.Data.UpdateStatus.SkipCurrentRow>.</span></span> <span data-ttu-id="437c2-179">Строка обновляется, но первоначальные значения в строке сохраняются.</span><span class="sxs-lookup"><span data-stu-id="437c2-179">The row is updated, but the original values in the row are preserved.</span></span> <span data-ttu-id="437c2-180">В основной части рассматриваемой процедуры вызывается метод <xref:System.Data.DataSet.Merge%2A> для слияния нового значения идентификатора с оригинальным значением `DataTable`, и в конечном счете вызывается метод `AcceptChanges`.</span><span class="sxs-lookup"><span data-stu-id="437c2-180">In the main body of the procedure, the <xref:System.Data.DataSet.Merge%2A> method is called to merge the new identity value into the original `DataTable`, and finally `AcceptChanges` is called.</span></span>

[!code-csharp[DataWorks SqlClient.MergeIdentity#2](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlClient.MergeIdentity/CS/source.cs#2)]
[!code-vb[DataWorks SqlClient.MergeIdentity#2](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlClient.MergeIdentity/VB/source.vb#2)]

## <a name="retrieving-microsoft-access-autonumber-values"></a><span data-ttu-id="437c2-181">Получение значений Autonumber в программе Microsoft Access</span><span class="sxs-lookup"><span data-stu-id="437c2-181">Retrieving Microsoft Access Autonumber Values</span></span>

<span data-ttu-id="437c2-182">В этом разделе представлен образец, показывающий, как получить значения `Autonumber` из базы данных Jet 4.0.</span><span class="sxs-lookup"><span data-stu-id="437c2-182">This section includes a sample that shows how to retrieve `Autonumber` values from a Jet 4.0 database.</span></span> <span data-ttu-id="437c2-183">Ядро базы данных Jet не поддерживает выполнение нескольких инструкций в пакете или использование выходных параметров, поэтому использовать какой-либо из описанных выше методов для возврата нового значения `Autonumber`, присвоенного вставленной строке, нельзя.</span><span class="sxs-lookup"><span data-stu-id="437c2-183">The Jet database engine does not support the execution of multiple statements in a batch or the use of output parameters, so it is not possible to use either of these techniques to return the new `Autonumber` value assigned to an inserted row.</span></span> <span data-ttu-id="437c2-184">Однако можно добавить код в `RowUpdated` обработчик событий, выполняющий отдельную @IDENTITY инструкцию SELECT @ для получения нового `Autonumber` значения.</span><span class="sxs-lookup"><span data-stu-id="437c2-184">However, you can add code to the `RowUpdated` event handler that executes a separate SELECT @@IDENTITY statement to retrieve the new `Autonumber` value.</span></span>

### <a name="example"></a><span data-ttu-id="437c2-185">Пример</span><span class="sxs-lookup"><span data-stu-id="437c2-185">Example</span></span>

<span data-ttu-id="437c2-186">Вместо добавления сведений о схеме с использованием `MissingSchemaAction.AddWithKey` в этом примере конфигурация `DataTable` настраивается с помощью правильной схемы до вызова <xref:System.Data.OleDb.OleDbDataAdapter> для заполнения `DataTable`.</span><span class="sxs-lookup"><span data-stu-id="437c2-186">Instead of adding schema information using `MissingSchemaAction.AddWithKey`, this example configures a `DataTable` with the correct schema prior to calling the <xref:System.Data.OleDb.OleDbDataAdapter> to fill the `DataTable`.</span></span> <span data-ttu-id="437c2-187">В этом случае столбец **CategoryID** настроен для уменьшения значения, присвоенного каждой вставляемой строке, начиная с нуля, присвоив <xref:System.Data.DataColumn.AutoIncrement%2A> значение `true` <xref:System.Data.DataColumn.AutoIncrementSeed%2A> 0 и <xref:System.Data.DataColumn.AutoIncrementStep%2A> равным-1.</span><span class="sxs-lookup"><span data-stu-id="437c2-187">In this case, the **CategoryID** column is configured to decrement the value assigned each inserted row starting from zero, by setting <xref:System.Data.DataColumn.AutoIncrement%2A> to `true`, <xref:System.Data.DataColumn.AutoIncrementSeed%2A> to 0, and <xref:System.Data.DataColumn.AutoIncrementStep%2A> to -1.</span></span> <span data-ttu-id="437c2-188">После этого производится добавление двух новых строк и вызывается метод `GetChanges` для добавления изменившихся строк в новый объект `DataTable`, который передан методу `Update`.</span><span class="sxs-lookup"><span data-stu-id="437c2-188">The code then adds two new rows and uses `GetChanges` to add the changed rows to a new `DataTable` that is passed to the `Update` method.</span></span>

[!code-csharp[DataWorks OleDb.JetAutonumberMerge#1](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks OleDb.JetAutonumberMerge/CS/source.cs#1)]
[!code-vb[DataWorks OleDb.JetAutonumberMerge#1](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks OleDb.JetAutonumberMerge/VB/source.vb#1)]

<span data-ttu-id="437c2-189">В обработчике событий `RowUpdated` используется то же открытое соединение <xref:System.Data.OleDb.OleDbConnection>, что и в инструкции `Update` объекта `OleDbDataAdapter`.</span><span class="sxs-lookup"><span data-stu-id="437c2-189">The `RowUpdated` event handler uses the same open <xref:System.Data.OleDb.OleDbConnection> as the `Update` statement of the `OleDbDataAdapter`.</span></span> <span data-ttu-id="437c2-190">В нем происходит проверка значения `StatementType` свойства <xref:System.Data.OleDb.OleDbRowUpdatedEventArgs> для вставленных строк.</span><span class="sxs-lookup"><span data-stu-id="437c2-190">It checks the `StatementType` of the <xref:System.Data.OleDb.OleDbRowUpdatedEventArgs> for inserted rows.</span></span> <span data-ttu-id="437c2-191">Для каждой вставленной строки <xref:System.Data.OleDb.OleDbCommand> создается новая функция для выполнения инструкции SELECT @ @IDENTITY в соединении, возвращающей новое `Autonumber` значение, которое помещается в столбец **CategoryID** объекта `DataRow` .</span><span class="sxs-lookup"><span data-stu-id="437c2-191">For each inserted row a new <xref:System.Data.OleDb.OleDbCommand> is created to execute the SELECT @@IDENTITY statement on the connection, returning the new `Autonumber` value, which is placed in the **CategoryID** column of the `DataRow`.</span></span> <span data-ttu-id="437c2-192">Затем свойству `Status` присваивается значение `UpdateStatus.SkipCurrentRow`, что позволяет блокировать скрытый вызов `AcceptChanges`.</span><span class="sxs-lookup"><span data-stu-id="437c2-192">The `Status` property is then set to `UpdateStatus.SkipCurrentRow` to suppress the hidden call to `AcceptChanges`.</span></span> <span data-ttu-id="437c2-193">В основной части процедуры вызывается метод `Merge` для слияния этих двух объектов `DataTable`, и в конечном счете вызывается `AcceptChanges`.</span><span class="sxs-lookup"><span data-stu-id="437c2-193">In the main body of the procedure, the `Merge` method is called to merge the two `DataTable` objects, and finally `AcceptChanges` is called.</span></span>

[!code-csharp[DataWorks OleDb.JetAutonumberMerge#2](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks OleDb.JetAutonumberMerge/CS/source.cs#2)]
[!code-vb[DataWorks OleDb.JetAutonumberMerge#2](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks OleDb.JetAutonumberMerge/VB/source.vb#2)]

### <a name="retrieving-identity-values"></a><span data-ttu-id="437c2-194">Извлечение значений идентификаторов</span><span class="sxs-lookup"><span data-stu-id="437c2-194">Retrieving Identity Values</span></span>

<span data-ttu-id="437c2-195">Мы часто задаем столбец как идентификатор, когда значения в столбце должны быть уникальными.</span><span class="sxs-lookup"><span data-stu-id="437c2-195">We often set the column as identity when the values in the column must be unique.</span></span> <span data-ttu-id="437c2-196">А иногда нам требуется значение идентификатора для новых данных.</span><span class="sxs-lookup"><span data-stu-id="437c2-196">And sometimes we need the identity value of new data.</span></span> <span data-ttu-id="437c2-197">В этом примере показано, как извлекать значения идентификаторов:</span><span class="sxs-lookup"><span data-stu-id="437c2-197">This sample demonstrates how to retrieve identity values:</span></span>

- <span data-ttu-id="437c2-198">Создает хранимую процедуру для вставки данных и возвращения значения идентификатора.</span><span class="sxs-lookup"><span data-stu-id="437c2-198">Creates a stored procedure to insert data and return an identity value.</span></span>

- <span data-ttu-id="437c2-199">Выполняет команду для вставки новых данных и отображения результата.</span><span class="sxs-lookup"><span data-stu-id="437c2-199">Executes a command to insert the new data and display the result.</span></span>

- <span data-ttu-id="437c2-200">Использует <xref:System.Data.SqlClient.SqlDataAdapter> для вставки новых данных и отображения результата.</span><span class="sxs-lookup"><span data-stu-id="437c2-200">Uses <xref:System.Data.SqlClient.SqlDataAdapter> to insert new data and display the result.</span></span>

<span data-ttu-id="437c2-201">Перед компиляцией и выполнением образца необходимо создать образец базы данных с помощью следующего скрипта:</span><span class="sxs-lookup"><span data-stu-id="437c2-201">Before you compile and run the sample, you must create the sample database, using the following script:</span></span>

```sql
USE [master]
GO

CREATE DATABASE [MySchool]
GO

USE [MySchool]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [dbo].[CourseExtInfo] @CourseId int
as
select c.CourseID,c.Title,c.Credits,d.Name as DepartmentName
from Course as c left outer join Department as d on c.DepartmentID=d.DepartmentID
where c.CourseID=@CourseId

GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create procedure [dbo].[DepartmentInfo] @DepartmentId int,@CourseCount int output
as
select @CourseCount=Count(c.CourseID)
from course as c
where c.DepartmentID=@DepartmentId

select d.DepartmentID,d.Name,d.Budget,d.StartDate,d.Administrator
from Department as d
where d.DepartmentID=@DepartmentId

GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
Create PROCEDURE [dbo].[GetDepartmentsOfSpecifiedYear]
@Year int,@BudgetSum money output
AS
BEGIN
        SELECT @BudgetSum=SUM([Budget])
  FROM [MySchool].[dbo].[Department]
  Where YEAR([StartDate])=@Year

SELECT [DepartmentID]
      ,[Name]
      ,[Budget]
      ,[StartDate]
      ,[Administrator]
  FROM [MySchool].[dbo].[Department]
  Where YEAR([StartDate])=@Year

END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[GradeOfStudent]
-- Add the parameters for the stored procedure here
@CourseTitle nvarchar(100),@FirstName nvarchar(50),
@LastName nvarchar(50),@Grade decimal(3,2) output
AS
BEGIN
select @Grade=Max(Grade)
from [dbo].[StudentGrade] as s join [dbo].[Course] as c on
s.CourseID=c.CourseID join [dbo].[Person] as p on s.StudentID=p.PersonID
where c.Title=@CourseTitle and p.FirstName=@FirstName
and p.LastName= @LastName
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[InsertPerson]
-- Add the parameters for the stored procedure here
@FirstName nvarchar(50),@LastName nvarchar(50),
@PersonID int output
AS
BEGIN
    insert [dbo].[Person](LastName,FirstName) Values(@LastName,@FirstName)

    set @PersonID=SCOPE_IDENTITY()
END
Go

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Course]([CourseID] [nvarchar](10) NOT NULL,
[Year] [smallint] NOT NULL,
[Title] [nvarchar](100) NOT NULL,
[Credits] [int] NOT NULL,
[DepartmentID] [int] NOT NULL,
 CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED
(
[CourseID] ASC,
[Year] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]

GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Department]([DepartmentID] [int] IDENTITY(1,1) NOT NULL,
[Name] [nvarchar](50) NOT NULL,
[Budget] [money] NOT NULL,
[StartDate] [datetime] NOT NULL,
[Administrator] [int] NULL,
 CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED
(
[DepartmentID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]

GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[Person]([PersonID] [int] IDENTITY(1,1) NOT NULL,
[LastName] [nvarchar](50) NOT NULL,
[FirstName] [nvarchar](50) NOT NULL,
[HireDate] [datetime] NULL,
[EnrollmentDate] [datetime] NULL,
[Picture] [varbinary](max) NULL,
 CONSTRAINT [PK_School.Student] PRIMARY KEY CLUSTERED
(
[PersonID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[StudentGrade]([EnrollmentID] [int] IDENTITY(1,1) NOT NULL,
[CourseID] [nvarchar](10) NOT NULL,
[StudentID] [int] NOT NULL,
[Grade] [decimal](3, 2) NOT NULL,
 CONSTRAINT [PK_StudentGrade] PRIMARY KEY CLUSTERED
(
[EnrollmentID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]

GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create view [dbo].[EnglishCourse]
as
select c.CourseID,c.Title,c.Credits,c.DepartmentID
from Course as c join Department as d on c.DepartmentID=d.DepartmentID
where d.Name=N'English'

GO
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)
SET IDENTITY_INSERT [dbo].[Department] ON

INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)
SET IDENTITY_INSERT [dbo].[Department] OFF
SET IDENTITY_INSERT [dbo].[Person] ON

INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (1, N'Hu', N'Nan', NULL, CAST(0x0000A0BF00000000 AS DateTime))
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (2, N'Norman', N'Laura', NULL, CAST(0x0000A0BF00000000 AS DateTime))
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (3, N'Olivotto', N'Nino', NULL, CAST(0x0000A0BF00000000 AS DateTime))
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (4, N'Anand', N'Arturo', NULL, CAST(0x0000A0BF00000000 AS DateTime))
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (5, N'Jai', N'Damien', NULL, CAST(0x0000A0BF00000000 AS DateTime))
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (6, N'Holt', N'Roger', CAST(0x000097F100000000 AS DateTime), NULL)
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (7, N'Martin', N'Randall', CAST(0x00008B1A00000000 AS DateTime), NULL)
SET IDENTITY_INSERT [dbo].[Person] OFF
SET IDENTITY_INSERT [dbo].[StudentGrade] ON

INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (1, N'C1045', 1, CAST(3.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (2, N'C1045', 2, CAST(3.00 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (3, N'C1045', 3, CAST(2.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (4, N'C1045', 4, CAST(4.00 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (5, N'C1045', 5, CAST(3.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (6, N'C1061', 1, CAST(4.00 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (7, N'C1061', 3, CAST(3.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (8, N'C1061', 4, CAST(2.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (9, N'C1061', 5, CAST(1.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (10, N'C2021', 1, CAST(2.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (11, N'C2021', 2, CAST(3.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (12, N'C2021', 4, CAST(3.00 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (13, N'C2021', 5, CAST(3.00 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (14, N'C2042', 1, CAST(2.00 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (15, N'C2042', 2, CAST(3.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (16, N'C2042', 3, CAST(4.00 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (17, N'C2042', 5, CAST(3.00 AS Decimal(3, 2)))
SET IDENTITY_INSERT [dbo].[StudentGrade] OFF
ALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])
REFERENCES [dbo].[Department] ([DepartmentID])
GO
ALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]
GO
ALTER TABLE [dbo].[StudentGrade]  WITH CHECK ADD  CONSTRAINT [FK_StudentGrade_Student] FOREIGN KEY([StudentID])
REFERENCES [dbo].[Person] ([PersonID])
GO
ALTER TABLE [dbo].[StudentGrade] CHECK CONSTRAINT [FK_StudentGrade_Student]
GO
```

<span data-ttu-id="437c2-202">Код имеет следующий вид:</span><span class="sxs-lookup"><span data-stu-id="437c2-202">The code listing follows:</span></span>

> [!TIP]
> <span data-ttu-id="437c2-203">Листинг кода относится к файлу базы данных Access, который называется MySchool.mdb.</span><span class="sxs-lookup"><span data-stu-id="437c2-203">The code listing refers to an Access database file called MySchool.mdb.</span></span> <span data-ttu-id="437c2-204">Вы можете скачать Мисчул. mdb (в составе всего примера проекта C# или Visual Basic) из [Code.MSDN.Microsoft.com](https://code.msdn.microsoft.com/How-to-Retrieve-the-511acece).</span><span class="sxs-lookup"><span data-stu-id="437c2-204">You can download MySchool.mdb (as part of the full C# or Visual Basic sample project) from [code.msdn.microsoft.com](https://code.msdn.microsoft.com/How-to-Retrieve-the-511acece).</span></span>

```csharp
using System;
using System.Data;
using System.Data.OleDb;
using System.Data.SqlClient;

class Program {
   static void Main(string[] args) {
      String SqlDbConnectionString = "Data Source=(local);Initial Catalog=MySchool;Integrated Security=True;Asynchronous Processing=true;";

      InsertPerson(SqlDbConnectionString, "Janice", "Galvin");
      Console.WriteLine();

      InsertPersonInAdapter(SqlDbConnectionString, "Peter", "Krebs");
      Console.WriteLine();

      String oledbConnectionString = "Provider=Microsoft.Jet.OLEDB.4.0; Data Source=Database\\MySchool.mdb";
      InsertPersonInJet4Database(oledbConnectionString, "Janice", "Galvin");
      Console.WriteLine();

      Console.WriteLine("Please press any key to exit.....");
      Console.ReadKey();
   }

   // Using stored procedure to insert a new row and retrieve the identity value
   static void InsertPerson(String connectionString, String firstName, String lastName) {
      String commandText = "dbo.InsertPerson";

      using (SqlConnection conn = new SqlConnection(connectionString)) {
         using (SqlCommand cmd = new SqlCommand(commandText, conn)) {
            cmd.CommandType = CommandType.StoredProcedure;

            cmd.Parameters.Add(new SqlParameter("@FirstName", firstName));
            cmd.Parameters.Add(new SqlParameter("@LastName", lastName));
            SqlParameter personId = new SqlParameter("@PersonID", SqlDbType.Int);
            personId.Direction = ParameterDirection.Output;
            cmd.Parameters.Add(personId);

            conn.Open();
            cmd.ExecuteNonQuery();

            Console.WriteLine("Person Id of new person:{0}", personId.Value);
         }
      }
   }

   // Using stored procedure in adapter to insert new rows and update the identity value.
   static void InsertPersonInAdapter(String connectionString, String firstName, String lastName) {
      String commandText = "dbo.InsertPerson";
      using (SqlConnection conn = new SqlConnection(connectionString)) {
         SqlDataAdapter mySchool = new SqlDataAdapter("Select PersonID,FirstName,LastName from [dbo].[Person]", conn);

         mySchool.InsertCommand = new SqlCommand(commandText, conn);
         mySchool.InsertCommand.CommandType = CommandType.StoredProcedure;

         mySchool.InsertCommand.Parameters.Add(
             new SqlParameter("@FirstName", SqlDbType.NVarChar, 50, "FirstName"));
         mySchool.InsertCommand.Parameters.Add(
             new SqlParameter("@LastName", SqlDbType.NVarChar, 50, "LastName"));

         SqlParameter personId = mySchool.InsertCommand.Parameters.Add(new SqlParameter("@PersonID", SqlDbType.Int, 0, "PersonID"));
         personId.Direction = ParameterDirection.Output;

         DataTable persons = new DataTable();
         mySchool.Fill(persons);

         DataRow newPerson = persons.NewRow();
         newPerson["FirstName"] = firstName;
         newPerson["LastName"] = lastName;
         persons.Rows.Add(newPerson);

         mySchool.Update(persons);
         Console.WriteLine("Show all persons:");
         ShowDataTable(persons, 14);
      }
   }

   /// For a Jet 4.0 database, we need use the single statement and event handler to insert new rows and retrieve the identity value.
   static void InsertPersonInJet4Database(String connectionString, String firstName, String lastName) {
      String commandText = "Insert into Person(FirstName,LastName) Values(?,?)";
      using (OleDbConnection conn = new OleDbConnection(connectionString)) {
         OleDbDataAdapter mySchool = new OleDbDataAdapter("Select PersonID,FirstName,LastName from Person", conn);

         // Create Insert Command
         mySchool.InsertCommand = new OleDbCommand(commandText, conn);
         mySchool.InsertCommand.CommandType = CommandType.Text;

         mySchool.InsertCommand.Parameters.Add(new OleDbParameter("@FirstName", OleDbType.VarChar, 50, "FirstName"));
         mySchool.InsertCommand.Parameters.Add(new OleDbParameter("@LastName", OleDbType.VarChar, 50, "LastName"));
         mySchool.InsertCommand.UpdatedRowSource = UpdateRowSource.Both;

         DataTable persons = CreatePersonsTable();

         mySchool.Fill(persons);

         DataRow newPerson = persons.NewRow();
         newPerson["FirstName"] = firstName;
         newPerson["LastName"] = lastName;
         persons.Rows.Add(newPerson);

         DataTable dataChanges = persons.GetChanges();

         mySchool.RowUpdated += OnRowUpdated;

         mySchool.Update(dataChanges);

         Console.WriteLine("Data before merging:");
         ShowDataTable(persons, 14);
         Console.WriteLine();

         persons.Merge(dataChanges);
         persons.AcceptChanges();

         Console.WriteLine("Data after merging");
         ShowDataTable(persons, 14);
      }
   }

   static void OnRowUpdated(object sender, OleDbRowUpdatedEventArgs e) {
      if (e.StatementType == StatementType.Insert) {
         // Retrieve the identity value
         OleDbCommand cmdNewId = new OleDbCommand("Select @@IDENTITY", e.Command.Connection);
         e.Row["PersonID"] = (Int32)cmdNewId.ExecuteScalar();

         // After the status is changed, the original values in the row are preserved. And the
         // Merge method will be called to merge the new identity value into the original DataTable.
         e.Status = UpdateStatus.SkipCurrentRow;
      }
   }

   // Create the Persons table before filling.
   private static DataTable CreatePersonsTable() {
      DataTable persons = new DataTable();

      DataColumn personId = new DataColumn();
      personId.DataType = Type.GetType("System.Int32");
      personId.ColumnName = "PersonID";
      personId.AutoIncrement = true;
      personId.AutoIncrementSeed = 0;
      personId.AutoIncrementStep = -1;
      persons.Columns.Add(personId);

      DataColumn firstName = new DataColumn();
      firstName.DataType = Type.GetType("System.String");
      firstName.ColumnName = "FirstName";
      persons.Columns.Add(firstName);

      DataColumn lastName = new DataColumn();
      lastName.DataType = Type.GetType("System.String");
      lastName.ColumnName = "LastName";
      persons.Columns.Add(lastName);

      DataColumn[] pkey = { personId };
      persons.PrimaryKey = pkey;

      return persons;
   }

   private static void ShowDataTable(DataTable table, Int32 length) {
      foreach (DataColumn col in table.Columns) {
         Console.Write("{0,-" + length + "}", col.ColumnName);
      }
      Console.WriteLine();

      foreach (DataRow row in table.Rows) {
         foreach (DataColumn col in table.Columns) {
            if (col.DataType.Equals(typeof(DateTime)))
               Console.Write("{0,-" + length + ":d}", row[col]);
            else if (col.DataType.Equals(typeof(Decimal)))
               Console.Write("{0,-" + length + ":C}", row[col]);
            else
               Console.Write("{0,-" + length + "}", row[col]);
         }

         Console.WriteLine();
      }
   }
}
```

## <a name="see-also"></a><span data-ttu-id="437c2-205">См. также</span><span class="sxs-lookup"><span data-stu-id="437c2-205">See also</span></span>

- [<span data-ttu-id="437c2-206">Извлечение и изменение данных в ADO.NET</span><span class="sxs-lookup"><span data-stu-id="437c2-206">Retrieving and Modifying Data in ADO.NET</span></span>](retrieving-and-modifying-data.md)
- [<span data-ttu-id="437c2-207">Объекты DataAdapter и DataReader</span><span class="sxs-lookup"><span data-stu-id="437c2-207">DataAdapters and DataReaders</span></span>](dataadapters-and-datareaders.md)
- [<span data-ttu-id="437c2-208">Состояния и версии строк</span><span class="sxs-lookup"><span data-stu-id="437c2-208">Row States and Row Versions</span></span>](./dataset-datatable-dataview/row-states-and-row-versions.md)
- [<span data-ttu-id="437c2-209">AcceptChanges и RejectChanges</span><span class="sxs-lookup"><span data-stu-id="437c2-209">AcceptChanges and RejectChanges</span></span>](./dataset-datatable-dataview/acceptchanges-and-rejectchanges.md)
- [<span data-ttu-id="437c2-210">Слияние содержимого набора данных</span><span class="sxs-lookup"><span data-stu-id="437c2-210">Merging DataSet Contents</span></span>](./dataset-datatable-dataview/merging-dataset-contents.md)
- [<span data-ttu-id="437c2-211">Обновление источников данных с объектами DataAdapter</span><span class="sxs-lookup"><span data-stu-id="437c2-211">Updating Data Sources with DataAdapters</span></span>](updating-data-sources-with-dataadapters.md)
- [<span data-ttu-id="437c2-212">Общие сведения об ADO.NET</span><span class="sxs-lookup"><span data-stu-id="437c2-212">ADO.NET Overview</span></span>](ado-net-overview.md)
