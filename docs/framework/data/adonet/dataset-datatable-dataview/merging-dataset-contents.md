---
title: Слияние содержимого набора данных
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: e5e9309a-3ebb-4a9c-9d78-21c4e2bafc5b
ms.openlocfilehash: 153c96860005046e4cc16d5a965bd569e3519b52
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61607934"
---
# <a name="merging-dataset-contents"></a><span data-ttu-id="945f1-102">Слияние содержимого набора данных</span><span class="sxs-lookup"><span data-stu-id="945f1-102">Merging DataSet Contents</span></span>

<span data-ttu-id="945f1-103">Метод <xref:System.Data.DataSet.Merge%2A> можно использовать для объединения содержимого массива <xref:System.Data.DataSet>, <xref:System.Data.DataTable> или <xref:System.Data.DataRow> с существующим `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="945f1-103">You can use the <xref:System.Data.DataSet.Merge%2A> method to merge the contents of a <xref:System.Data.DataSet>, <xref:System.Data.DataTable>, or <xref:System.Data.DataRow> array into an existing `DataSet`.</span></span> <span data-ttu-id="945f1-104">Несколько факторов и параметров влияют на то, как новые данные объединяются с существующим `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="945f1-104">Several factors and options affect how new data is merged into an existing `DataSet`.</span></span>

## <a name="primary-keys"></a><span data-ttu-id="945f1-105">Первичные ключи</span><span class="sxs-lookup"><span data-stu-id="945f1-105">Primary Keys</span></span>

<span data-ttu-id="945f1-106">Если таблица, получающая в результате слияния новые данные и схему, имеет первичный ключ, новые строки входных данных сравниваются с существующими строками, имеющими такие же значения первичного ключа <xref:System.Data.DataRowVersion.Original>, что и во входных данных.</span><span class="sxs-lookup"><span data-stu-id="945f1-106">If the table receiving new data and schema from a merge has a primary key, new rows from the incoming data are matched with existing rows that have the same <xref:System.Data.DataRowVersion.Original> primary key values as those in the incoming data.</span></span> <span data-ttu-id="945f1-107">Если столбцы из входной схемы соответствуют столбцам существующей схемы, данные в существующих строках изменяются.</span><span class="sxs-lookup"><span data-stu-id="945f1-107">If the columns from the incoming schema match those of the existing schema, the data in the existing rows is modified.</span></span> <span data-ttu-id="945f1-108">Столбцы, не соответствующие существующей схеме, либо пропускаются, либо добавляются на основании параметра <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A>.</span><span class="sxs-lookup"><span data-stu-id="945f1-108">Columns that do not match the existing schema are either ignored or added based on the <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> parameter.</span></span> <span data-ttu-id="945f1-109">Новые строки со значениями первичного ключа, которые не соответствуют существующим строкам, добавляются к существующей таблице.</span><span class="sxs-lookup"><span data-stu-id="945f1-109">New rows with primary key values that do not match any existing rows are appended to the existing table.</span></span>

<span data-ttu-id="945f1-110">Если входные или существующие строки имеют состояние <xref:System.Data.DataRowState.Added>, значения их первичных ключей согласуются с использованием значения первичного ключа <xref:System.Data.DataRowVersion.Current> строки `Added`, т. к. не существует версии строки `Original`.</span><span class="sxs-lookup"><span data-stu-id="945f1-110">If incoming or existing rows have a row state of <xref:System.Data.DataRowState.Added>, their primary key values are matched using the <xref:System.Data.DataRowVersion.Current> primary key value of the `Added` row because no `Original` row version exists.</span></span>

<span data-ttu-id="945f1-111">Если входная таблица и существующая таблица содержат столбцы с одинаковым именем, но разных типов данных, возникает исключение и инициируется событие <xref:System.Data.DataSet.MergeFailed> объекта `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="945f1-111">If an incoming table and an existing table contain a column with the same name but different data types, an exception is thrown and the <xref:System.Data.DataSet.MergeFailed> event of the `DataSet` is raised.</span></span> <span data-ttu-id="945f1-112">Если входная таблица и существующая таблица обе имеют определенные ключи, но первичные ключи относятся к разным столбцам, возникает исключение и инициируется событие `MergeFailed` объекта `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="945f1-112">If an incoming table and an existing table both have defined keys, but the primary keys are for different columns, an exception is thrown and the `MergeFailed` event of the `DataSet` is raised.</span></span>

<span data-ttu-id="945f1-113">Если таблица, получающая новые данные в результате объединения, не имеет первичного ключа, новые строки входных данных не могут быть сопоставлены существующим строкам в таблице и вместо этого присоединяются к существующей таблице.</span><span class="sxs-lookup"><span data-stu-id="945f1-113">If the table receiving new data from a merge does not have a primary key, new rows from the incoming data cannot be matched to existing rows in the table and are instead appended to the existing table.</span></span>

## <a name="table-names-and-namespaces"></a><span data-ttu-id="945f1-114">Имена таблиц и пространства имен</span><span class="sxs-lookup"><span data-stu-id="945f1-114">Table Names and Namespaces</span></span>

<span data-ttu-id="945f1-115">Объектам <xref:System.Data.DataTable> может быть, если необходимо, присвоено значение свойства <xref:System.Data.DataTable.Namespace%2A>.</span><span class="sxs-lookup"><span data-stu-id="945f1-115"><xref:System.Data.DataTable> objects can optionally be assigned a <xref:System.Data.DataTable.Namespace%2A> property value.</span></span> <span data-ttu-id="945f1-116">Когда присваиваются значения <xref:System.Data.DataTable.Namespace%2A>, <xref:System.Data.DataSet> может содержать несколько объектов <xref:System.Data.DataTable> с одинаковым значением <xref:System.Data.DataTable.TableName%2A>.</span><span class="sxs-lookup"><span data-stu-id="945f1-116">When <xref:System.Data.DataTable.Namespace%2A> values are assigned, a <xref:System.Data.DataSet> can contain multiple <xref:System.Data.DataTable> objects with the same <xref:System.Data.DataTable.TableName%2A> value.</span></span> <span data-ttu-id="945f1-117">Во время операции слияния и <xref:System.Data.DataTable.TableName%2A>, и <xref:System.Data.DataTable.Namespace%2A> используются для идентификации цели слияния.</span><span class="sxs-lookup"><span data-stu-id="945f1-117">During merge operations, both <xref:System.Data.DataTable.TableName%2A> and <xref:System.Data.DataTable.Namespace%2A> are used to identify the target of a merge.</span></span> <span data-ttu-id="945f1-118">Если <xref:System.Data.DataTable.Namespace%2A> не назначено, только <xref:System.Data.DataTable.TableName%2A> используется для идентификации цели слияния.</span><span class="sxs-lookup"><span data-stu-id="945f1-118">If no <xref:System.Data.DataTable.Namespace%2A> has been assigned, only the <xref:System.Data.DataTable.TableName%2A> is used to identify the target of a merge.</span></span>

> [!NOTE]
> <span data-ttu-id="945f1-119">Это поведение в .NET Framework версии 2.0 изменяется.</span><span class="sxs-lookup"><span data-stu-id="945f1-119">This behavior changed in version 2.0 of the .NET Framework.</span></span> <span data-ttu-id="945f1-120">В версии 1.1 пространства имен поддерживались, но во время операций слияния не учитывались.</span><span class="sxs-lookup"><span data-stu-id="945f1-120">In version 1.1, namespaces were supported but were ignored during merge operations.</span></span> <span data-ttu-id="945f1-121">По этой причине <xref:System.Data.DataSet>, который использует значения свойства <xref:System.Data.DataTable.Namespace%2A>, будет иметь разные характеристики в зависимости от того, какая версия .NET Framework выполняется.</span><span class="sxs-lookup"><span data-stu-id="945f1-121">For this reason, a <xref:System.Data.DataSet> that uses <xref:System.Data.DataTable.Namespace%2A> property values will have different behaviors depending on which version of the .NET Framework you are running.</span></span> <span data-ttu-id="945f1-122">Например, предположим, имеются два `DataSets`, содержащие `DataTables` с одинаковыми значениями свойства <xref:System.Data.DataTable.TableName%2A>, но с разными значениями свойства <xref:System.Data.DataTable.Namespace%2A>.</span><span class="sxs-lookup"><span data-stu-id="945f1-122">For example, suppose you have two `DataSets` containing `DataTables` with the same <xref:System.Data.DataTable.TableName%2A> property values but different <xref:System.Data.DataTable.Namespace%2A> property values.</span></span> <span data-ttu-id="945f1-123">В .NET Framework версии 1.1 разные имена <xref:System.Data.DataTable.Namespace%2A> пропускаются, когда объединяются два объекта <xref:System.Data.DataSet>.</span><span class="sxs-lookup"><span data-stu-id="945f1-123">In version 1.1 of the .NET Framework, the different <xref:System.Data.DataTable.Namespace%2A> names will be ignored when merging the two <xref:System.Data.DataSet> objects.</span></span> <span data-ttu-id="945f1-124">Однако, начиная с версии 2.0, слияние приводит к созданию в целевом объекте `DataTables` двух новых объектов <xref:System.Data.DataSet>.</span><span class="sxs-lookup"><span data-stu-id="945f1-124">However, starting with version 2.0, merging causes two new `DataTables` to be created in the target <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="945f1-125">Исходные таблицы `DataTables` объединением не затрагиваются.</span><span class="sxs-lookup"><span data-stu-id="945f1-125">The original `DataTables` will be unaffected by the merge.</span></span>

## <a name="preservechanges"></a><span data-ttu-id="945f1-126">Флаг PreserveChanges</span><span class="sxs-lookup"><span data-stu-id="945f1-126">PreserveChanges</span></span>

<span data-ttu-id="945f1-127">Когда `DataSet`, `DataTable` или `DataRow` передается в метод `Merge`, можно включить необязательные параметры, указывающие, сохранять ли изменения в существующем объекте `DataSet` и как обрабатывать элементы новой схемы в исходных данных.</span><span class="sxs-lookup"><span data-stu-id="945f1-127">When you pass a `DataSet`, `DataTable`, or `DataRow` array to the `Merge` method, you can include optional parameters that specify whether or not to preserve changes in the existing `DataSet`, and how to handle new schema elements found in the incoming data.</span></span> <span data-ttu-id="945f1-128">Первым из этих параметров после входных данных является логический флаг <xref:System.Data.LoadOption.PreserveChanges>, который задает, сохранять ли изменения в существующем `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="945f1-128">The first of these parameters after the incoming data is a Boolean flag, <xref:System.Data.LoadOption.PreserveChanges>, which specifies whether or not to preserve the changes in the existing `DataSet`.</span></span> <span data-ttu-id="945f1-129">Если флаг `PreserveChanges` установлен в `true`, входные значения не переопределяют существующие значения в версии `Current` текущей строки.</span><span class="sxs-lookup"><span data-stu-id="945f1-129">If the `PreserveChanges` flag is set to `true`, incoming values do not overwrite existing values in the `Current` row version of the existing row.</span></span> <span data-ttu-id="945f1-130">Если флаг `PreserveChanges` установлен в `false`, входные значения переопределяют существующие значения в версии `Current` текущей строки.</span><span class="sxs-lookup"><span data-stu-id="945f1-130">If the `PreserveChanges` flag is set to `false`, incoming values do overwrite the existing values in the `Current` row version of the existing row.</span></span> <span data-ttu-id="945f1-131">Если флаг `PreserveChanges` не задан, по умолчанию он устанавливается в `false`.</span><span class="sxs-lookup"><span data-stu-id="945f1-131">If the `PreserveChanges` flag is not specified, it is set to `false` by default.</span></span> <span data-ttu-id="945f1-132">Дополнительные сведения о версиях строк см. в разделе [строки состояния и версии строк](../../../../../docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).</span><span class="sxs-lookup"><span data-stu-id="945f1-132">For more information about row versions, see [Row States and Row Versions](../../../../../docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).</span></span>

<span data-ttu-id="945f1-133">Если `PreserveChanges` имеет значение `true`, данные из существующей строки сохраняются в версии <xref:System.Data.DataRowVersion.Current> текущей строки, в то время как данные из версии <xref:System.Data.DataRowVersion.Original> существующей строки переопределяются данными из версии `Original` входной строки.</span><span class="sxs-lookup"><span data-stu-id="945f1-133">When `PreserveChanges` is `true`, the data from the existing row is maintained in the <xref:System.Data.DataRowVersion.Current> row version of the existing row, while the data from the <xref:System.Data.DataRowVersion.Original> row version of the existing row is overwritten with the data from the `Original` row version of the incoming row.</span></span> <span data-ttu-id="945f1-134"><xref:System.Data.DataRow.RowState%2A> существующей строки установлен в <xref:System.Data.DataRowState.Modified>.</span><span class="sxs-lookup"><span data-stu-id="945f1-134">The <xref:System.Data.DataRow.RowState%2A> of the existing row is set to <xref:System.Data.DataRowState.Modified>.</span></span> <span data-ttu-id="945f1-135">Применяются следующие исключения:</span><span class="sxs-lookup"><span data-stu-id="945f1-135">The following exceptions apply:</span></span>

- <span data-ttu-id="945f1-136">Если существующая строка имеет версию `RowState``Deleted`, это `RowState` остается `Deleted` и не устанавливается в `Modified`.</span><span class="sxs-lookup"><span data-stu-id="945f1-136">If the existing row has a `RowState` of `Deleted`, this `RowState` remains `Deleted` and is not set to `Modified`.</span></span> <span data-ttu-id="945f1-137">В этом случае данные из входной строки будут сохраняться в версии `Original` существующей строки, переопределяя версию `Original` существующей строки (если только входная строка не имеет `RowState`, равное `Added`).</span><span class="sxs-lookup"><span data-stu-id="945f1-137">In this case, the data from the incoming row will still be stored in the `Original` row version of the existing row, overwriting the `Original` row version of the existing row (unless the incoming row has a `RowState` of `Added`).</span></span>

- <span data-ttu-id="945f1-138">Если входная строка имеет состояние `RowState`, равное `Added`, данные из версии `Original` существующей строки не переопределяются данными из входной строки, т. к. входная строка не имеет версии `Original`.</span><span class="sxs-lookup"><span data-stu-id="945f1-138">If the incoming row has a `RowState` of `Added`, the data from the `Original` row version of the existing row will not be overwritten with data from the incoming row, because the incoming row does not have an `Original` row version.</span></span>

<span data-ttu-id="945f1-139">Если `PreserveChanges` равно `false`, версии строк `Current` и `Original` в существующей строке переопределяются данными из входной строки, а состояние `RowState` существующей строки устанавливается в состояние `RowState` входной строки.</span><span class="sxs-lookup"><span data-stu-id="945f1-139">When `PreserveChanges` is `false`, both the `Current` and `Original` row versions in the existing row are overwritten with the data from the incoming row, and the `RowState` of the existing row is set to the `RowState` of the incoming row.</span></span> <span data-ttu-id="945f1-140">Применяются следующие исключения:</span><span class="sxs-lookup"><span data-stu-id="945f1-140">The following exceptions apply:</span></span>

- <span data-ttu-id="945f1-141">Если входная строка имеет значение `RowState`, равное `Unchanged`, а существующая строка имеет значение `RowState`, равное `Modified`, `Deleted` или `Added`, состояние `RowState` существующей строки устанавливается в `Modified`.</span><span class="sxs-lookup"><span data-stu-id="945f1-141">If the incoming row has a `RowState` of `Unchanged` and the existing row has a `RowState` of `Modified`, `Deleted`, or `Added`, the `RowState` of the existing row is set to `Modified`.</span></span>

- <span data-ttu-id="945f1-142">Если входная строка имеет состояние `RowState`, равное `Added`, а существующая строка имеет состояние `RowState`, равное `Unchanged`, `Modified` или `Deleted`, состояние `RowState` существующей строки устанавливается в `Modified`.</span><span class="sxs-lookup"><span data-stu-id="945f1-142">If the incoming row has a `RowState` of `Added`, and the existing row has a `RowState` of `Unchanged`, `Modified`, or `Deleted`, the `RowState` of the existing row is set to `Modified`.</span></span> <span data-ttu-id="945f1-143">Также данные из версии `Original` существующей строки не переопределяются данными из входной строки, т. к. входная строка не имеет версии `Original`.</span><span class="sxs-lookup"><span data-stu-id="945f1-143">Also, the data from the `Original` row version of the existing row is not overwritten with data from the incoming row, because the incoming row does not have an `Original` row version.</span></span>

## <a name="missingschemaaction"></a><span data-ttu-id="945f1-144">Параметр MissingSchemaAction</span><span class="sxs-lookup"><span data-stu-id="945f1-144">MissingSchemaAction</span></span>

<span data-ttu-id="945f1-145">Можно использовать необязательный параметр <xref:System.Data.MissingSchemaAction> метода `Merge` для задания того, как `Merge` будет обрабатывать элементы схемы во входных данных, не являющихся частью существующего объекта `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="945f1-145">You can use the optional <xref:System.Data.MissingSchemaAction> parameter of the `Merge` method to specify how `Merge` will handle schema elements in the incoming data that are not part of the existing `DataSet`.</span></span>

<span data-ttu-id="945f1-146">В следующей таблице описываются параметры для `MissingSchemaAction`.</span><span class="sxs-lookup"><span data-stu-id="945f1-146">The following table describes the options for `MissingSchemaAction`.</span></span>

|<span data-ttu-id="945f1-147">Параметр MissingSchemaAction</span><span class="sxs-lookup"><span data-stu-id="945f1-147">MissingSchemaAction option</span></span>|<span data-ttu-id="945f1-148">Описание</span><span class="sxs-lookup"><span data-stu-id="945f1-148">Description</span></span>|
|--------------------------------|-----------------|
|<xref:System.Data.MissingSchemaAction.Add>|<span data-ttu-id="945f1-149">Добавление новых данных схемы в объект `DataSet` и заполнение новых столбцов входными значениями.</span><span class="sxs-lookup"><span data-stu-id="945f1-149">Add the new schema information to the `DataSet` and populate the new columns with the incoming values.</span></span> <span data-ttu-id="945f1-150">Это значение по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="945f1-150">This is the default.</span></span>|
|<xref:System.Data.MissingSchemaAction.AddWithKey>|<span data-ttu-id="945f1-151">Добавление новых данных схемы и первичного ключа в объект `DataSet` и заполнение новых столбцов входными значениями.</span><span class="sxs-lookup"><span data-stu-id="945f1-151">Add the new schema and primary key information to the `DataSet` and populate the new columns with the incoming values.</span></span>|
|<xref:System.Data.MissingSchemaAction.Error>|<span data-ttu-id="945f1-152">Инициация исключения, если встречаются несовпадающие данные схемы.</span><span class="sxs-lookup"><span data-stu-id="945f1-152">Throw an exception if mismatched schema information is encountered.</span></span>|
|<xref:System.Data.MissingSchemaAction.Ignore>|<span data-ttu-id="945f1-153">Пропуск новых данных схемы.</span><span class="sxs-lookup"><span data-stu-id="945f1-153">Ignore the new schema information.</span></span>|

## <a name="constraints"></a><span data-ttu-id="945f1-154">Ограничения</span><span class="sxs-lookup"><span data-stu-id="945f1-154">Constraints</span></span>

<span data-ttu-id="945f1-155">При выполнении метода `Merge` ограничения не проверяются, пока все новые данные не будут добавлены в существующий объект `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="945f1-155">With the `Merge` method, constraints are not checked until all new data has been added to the existing `DataSet`.</span></span> <span data-ttu-id="945f1-156">После добавления данных ограничения принудительно применяются на текущих значениях в объекте `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="945f1-156">Once the data has been added, constraints are enforced on the current values in the `DataSet`.</span></span> <span data-ttu-id="945f1-157">Необходимо быть уверенным в том, что код обрабатывает все исключения, которые могут инициироваться из-за нарушений ограничений.</span><span class="sxs-lookup"><span data-stu-id="945f1-157">You must ensure that your code handles any exceptions that might be thrown due to constraint violations.</span></span>

<span data-ttu-id="945f1-158">Рассмотрим случай, когда существующая строка в `DataSet` является строкой `Unchanged` со значением первичного ключа, равным 1.</span><span class="sxs-lookup"><span data-stu-id="945f1-158">Consider a case where an existing row in a `DataSet` is an `Unchanged` row with a primary key value of 1.</span></span> <span data-ttu-id="945f1-159">Во время выполнения операции слияния с входной строкой `Modified` со значением первичного ключа `Original`, равным 2, и значением первичного ключа `Current`, равным 1, существующая строка и входная строка не считаются совпадающими, так как различаются значения первичных ключей `Original`.</span><span class="sxs-lookup"><span data-stu-id="945f1-159">During a merge operation with a `Modified` incoming row with an `Original` primary key value of 2 and a `Current` primary key value of 1, the existing row and the incoming row are not considered matching because the `Original` primary key values differ.</span></span> <span data-ttu-id="945f1-160">Однако после завершения объединения и проверки ограничений появится исключение, т. к. значения первичного ключа `Current` нарушают ограничение уникальности для столбца первичного ключа.</span><span class="sxs-lookup"><span data-stu-id="945f1-160">However, when the merge is completed and constraints are checked, an exception will be thrown because the `Current` primary key values violate the unique constraint for the primary key column.</span></span>

> [!NOTE]
> <span data-ttu-id="945f1-161">Если строки вставляются в таблицу базы данных, содержащую столбец, автоматически увеличивающий свое значение, например столбец идентификаторов, то возвращаемое вставкой значение столбца идентификаторов может не совпадать со значением в объекте `DataSet`, в результате чего возвращаемые строки не объединяются, а присоединяются.</span><span class="sxs-lookup"><span data-stu-id="945f1-161">When rows are inserted into a database table containing an auto incrementing column such as an identity column, the identity column value returned by the insert may not match the value in the `DataSet`, causing the returned rows to be appended instead of merged.</span></span> <span data-ttu-id="945f1-162">Дополнительные сведения см. в разделе [извлечение идентификации или значений автонумерации](../../../../../docs/framework/data/adonet/retrieving-identity-or-autonumber-values.md).</span><span class="sxs-lookup"><span data-stu-id="945f1-162">For more information, see [Retrieving Identity or Autonumber Values](../../../../../docs/framework/data/adonet/retrieving-identity-or-autonumber-values.md).</span></span>

<span data-ttu-id="945f1-163">В следующем примере кода выполняет слияние двух `DataSet` объектов с разными схемами в одну `DataSet` с объединенный схемами двух входных `DataSet` объектов.</span><span class="sxs-lookup"><span data-stu-id="945f1-163">The following code example merges two `DataSet` objects with different schemas into one `DataSet` with the combined schemas of the two incoming `DataSet` objects.</span></span>

[!code-csharp[DataWorks DataSet.Merge#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.Merge/CS/source.cs#1)]
[!code-vb[DataWorks DataSet.Merge#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.Merge/VB/source.vb#1)]

<span data-ttu-id="945f1-164">В следующем примере кода берется существующий объект `DataSet` с обновлениями и эти обновления передаются в `DataAdapter`, чтобы выполнить обработку в источнике данных.</span><span class="sxs-lookup"><span data-stu-id="945f1-164">The following code example takes an existing `DataSet` with updates and passes those updates to a `DataAdapter` to be processed at the data source.</span></span> <span data-ttu-id="945f1-165">Затем результаты объединяются в исходный объект `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="945f1-165">The results are then merged into the original `DataSet`.</span></span> <span data-ttu-id="945f1-166">После отклонения изменений, в результате которых возникла ошибка, объединенные изменения фиксируются при помощи `AcceptChanges`.</span><span class="sxs-lookup"><span data-stu-id="945f1-166">After rejecting changes that resulted in an error, the merged changes are committed with `AcceptChanges`.</span></span>

[!code-csharp[DataWorks DataSet.MergeAcceptChanges#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/CS/source.cs#1)]
[!code-vb[DataWorks DataSet.MergeAcceptChanges#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/VB/source.vb#1)]

[!code-csharp[DataWorks DataSet.MergeAcceptChanges#2](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/CS/source.cs#2)]
[!code-vb[DataWorks DataSet.MergeAcceptChanges#2](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/VB/source.vb#2)]

## <a name="see-also"></a><span data-ttu-id="945f1-167">См. также</span><span class="sxs-lookup"><span data-stu-id="945f1-167">See also</span></span>

- [<span data-ttu-id="945f1-168">Наборы данных, таблицы данных и объекты DataView</span><span class="sxs-lookup"><span data-stu-id="945f1-168">DataSets, DataTables, and DataViews</span></span>](../../../../../docs/framework/data/adonet/dataset-datatable-dataview/index.md)
- [<span data-ttu-id="945f1-169">Состояния и версии строк</span><span class="sxs-lookup"><span data-stu-id="945f1-169">Row States and Row Versions</span></span>](../../../../../docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)
- [<span data-ttu-id="945f1-170">Объекты DataAdapter и DataReader</span><span class="sxs-lookup"><span data-stu-id="945f1-170">DataAdapters and DataReaders</span></span>](../../../../../docs/framework/data/adonet/dataadapters-and-datareaders.md)
- [<span data-ttu-id="945f1-171">Извлечение и изменение данных в ADO.NET</span><span class="sxs-lookup"><span data-stu-id="945f1-171">Retrieving and Modifying Data in ADO.NET</span></span>](../../../../../docs/framework/data/adonet/retrieving-and-modifying-data.md)
- [<span data-ttu-id="945f1-172">Извлечение идентификации или значений автонумерации</span><span class="sxs-lookup"><span data-stu-id="945f1-172">Retrieving Identity or Autonumber Values</span></span>](../../../../../docs/framework/data/adonet/retrieving-identity-or-autonumber-values.md)
- [<span data-ttu-id="945f1-173">Центр разработчиков наборов данных и управляемых поставщиков ADO.NET</span><span class="sxs-lookup"><span data-stu-id="945f1-173">ADO.NET Managed Providers and DataSet Developer Center</span></span>](https://go.microsoft.com/fwlink/?LinkId=217917)
