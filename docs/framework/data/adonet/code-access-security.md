---
title: Управление доступом для кода
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 93e099eb-daa1-4f1e-b031-c1e10a996f88
ms.openlocfilehash: 7b0f269bd4dce8ddaaaa72c3760a4d7a0e3eb8b9
ms.sourcegitcommit: 62285ec11fa8e8424bab00511a90760c60e63c95
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/20/2020
ms.locfileid: "81646016"
---
# <a name="code-access-security-and-adonet"></a>Управление доступом для кода и ADO.NET
Платформа .NET Framework предлагает безопасность на основе ролей, а также управление доступом для кода (CAS). Оба средства реализуются при помощи общей инфраструктуры, предоставленной средой CLR. В области неуправляемого кода большинство приложений выполняются с правами доступа пользователя или участника. В результате, когда вредоносное программное обеспечение или программы с ошибками запускаются пользователем с повышенными правами доступа, компьютерные системы могут повреждаться, а личные данные - похищаться.  
  
 В отличие от этого выполнение управляемого кода в платформе .NET Framework включает управление доступом для кода, которое применяется только к коду. Разрешено ли выполнение этого кода или нет, зависит от источника кода или других аспектов происхождения кода, а не только идентификатора участника. Это снижает вероятность неправильного использования управляемого кода.  
  
## <a name="code-access-permissions"></a>Разрешения для доступа к коду  
 При выполнении кода он предоставляет свидетельство, которое проверяется системой безопасности CLR. Обычно это свидетельство состоит из источника кода, включая URL-адрес, узел и зону, а также цифровые сигнатуры, которые подтверждают происхождение сборки.  
  
 Среда CLR позволяет коду выполнять только те операции, на которые у него есть права. Код может запросить права доступа, и эти запросы удовлетворяются, исходя из политики безопасности, заданной администратором.  
  
> [!NOTE]
> Код, выполняющийся в среде CLR, не может предоставлять права доступа самому себе. Например, код может запросить и предоставить меньшие права доступа, чем позволено политикой безопасности, при этом он никогда не получить больше прав доступа. При предоставлении прав доступа следует начинать с нуля и добавлять минимальные необходимые права для каждой выполняемой задачи. Если начать с предоставления всех прав, а затем удалять отдельные их них, то приложение окажется небезопасным. В нем могут возникать неожиданные бреши в системе безопасности из-за предоставления больших прав доступа, чем необходимо. Для получения дополнительной информации [см.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/7c9c2y1w(v=vs.100)) [Security Policy Management](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/c1k0eed6(v=vs.100))  
  
 Существует три типа прав доступа для кода.  
  
- `Code access permissions` получаются из класса <xref:System.Security.CodeAccessPermission>. Права доступа требуются для использования защищенных ресурсов, например файлов и переменных среды, а также для выполнения защищенных операций, например для доступа к неуправляемому коду.  
  
- `Identity permissions` представляют собой характеристики, определяющие сборку. Права доступа предоставляются сборке, исходя из свидетельства, которое может содержать такие элементы, как цифровая сигнатура или сведения об источнике кода. Права доступа для удостоверения также являются производными от базового класса <xref:System.Security.CodeAccessPermission>.  
  
- `Role-based security permissions` основаны на том, имеет ли участник указанное свидетельство или является ли членом указанной роли. Класс <xref:System.Security.Permissions.PrincipalPermission> позволяет проводить декларативные и императивные проверки прав доступа по активному участнику.  
  
 Система безопасности среды выполнения просматривает стек вызова, сравнивая разрешения, предоставленные каждому вызывающему, с запрашиваемым разрешением, чтобы определить, разрешено ли коду иметь доступ к ресурсу. Если какой-либо вызывающий объект в стеке вызова не имеет запрашиваемого разрешения, формируется исключение <xref:System.Security.SecurityException> и ему отказывается в доступе.  
  
### <a name="requesting-permissions"></a>Запрос прав доступа  
 Цель запроса прав доступа состоит в том, чтобы проинформировать среду выполнения о том, какие права доступа требуются данному приложению для работы, а также чтобы обеспечить получение им только тех прав доступа, которые ему действительно нужны. Например, если приложению требуется записать данные на локальный диск, ему необходимо право доступа <xref:System.Security.Permissions.FileIOPermission>. Если это право доступа не было предоставлено, при попытке приложения записать данные на диск произойдет сбой. Однако если приложение запрашивает право доступа `FileIOPermission` и не получает его, то в результате оно формирует исключение и не загружается.  
  
 В том случае, когда приложению требуется только считать данные с диска, можно потребовать, чтобы ему никогда не предоставлялись права доступа для записи. При возникновении ошибки или атаки злоумышленника код не сможет повредить данные, с которыми он работает. Для получения дополнительной [информации см.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/yd267cce(v=vs.100))  
  
## <a name="role-based-security-and-cas"></a>Безопасность на основе ролей и CAS  
 Реализация безопасности на основе ролей и управления доступом для кода (CAS) повышает общую безопасность приложения. Безопасность на основе ролей может основываться на учетных записях Windows или пользовательских удостоверениях, которые предоставляют сведения об участнике безопасности текущему потоку. Кроме того, часто требуется, чтобы приложения предоставляли доступ к данным или ресурсам, исходя из учетных данных, переданных пользователем. Такие приложения обычно проверяют роль пользователя и предоставляют доступ к ресурсам на основании этих ролей.  
  
 Безопасность на основе ролей позволяет компоненту идентифицировать текущих пользователей и их роли во время выполнения. Затем эти сведения сопоставляются при помощи политики CAS, чтобы определить набор прав доступа, предоставляемых во время выполнения. Ведущее приложение может изменить политику безопасности на основе ролей по умолчанию и задать участника безопасности по умолчанию, который представляет пользователя и роли, связанные с этим пользователем, для указанного домена приложения.  
  
 В среде CLR для реализации своего механизма применения ограничений для управляемого кода используются права доступа. Права доступа на основе ролей предоставляют механизм для определения, имеет ли пользователь (или агент, действующий от имени пользователя) конкретное удостоверение или является ли он членом указанной роли. Для получения дополнительной [информации см.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/5ba4k1c5(v=vs.100))  
  
 В зависимости от типа создаваемого приложения также следует рассмотреть возможность реализации в базе данных прав доступа на основе ролей. Для получения более подробной информации о ролевой безопасности в сервере [S'L,](./sql/sql-server-security.md)см.  
  
## <a name="assemblies"></a>Сборки  
 Сборки представляют собой базовый элемент развертывания, управления версиями, повторного использования, назначения областей активации и прав доступа для приложения .NET Framework. Сборка предоставляет коллекцию типов и ресурсов, которые предназначены для совместной работы и формируют логическую единицу функциональности. В среде CLR типы не существуют вне контекста сборки. Для получения дополнительной информации о создании и развертывании сборок [см.](../../../standard/assembly/index.md)  
  
### <a name="strong-naming-assemblies"></a>Назначение строгих имен сборкам  
 Строгое имя или цифровая сигнатура состоит из идентификатора сборки, в который входит ее простое текстовое имя, номер версии и сведения о языке и региональных настройках (если указано) плюс открытый ключ и цифровая сигнатура. Цифровая сигнатура формируется из файла сборки при помощи соответствующего закрытого ключа. В файле сборки содержится манифест сборки, в котором указаны имена и хэши всех файлов, составляющих эту сборку.  
  
 Строгое имя сборки дает приложению или компоненту уникальный идентификатор, который может использоваться другими программами явной ссылки на сборку. Строгие имена предотвращают имитацию сборок со стороны сборок, содержащих вредоносный код. Строгие имена также обеспечивают согласованность разных версий компонента. Сборки, которые будут установлены в глобальный кэш сборок, должны получать строгие имена. Дополнительные сведения см. в разделе [Создание и использование сборок со строгими именами](../../../standard/assembly/create-use-strong-named.md).  
  
## <a name="partial-trust-in-adonet-20"></a>Частичный уровень доверия в ADO.NET 2.0  
 Теперь в ADO.NET 2.0 поставщик данных .NET Framework для SQL Server, поставщик данных .NET Framework для OLE DB, поставщик данных .NET Framework для ODBC и поставщик данных .NET Framework для Oracle могут работать в частично доверенных средах. В предыдущих версиях платформы .NET Framework в приложениях с неполным доверием поддерживался только клиент <xref:System.Data.SqlClient>.  
  
 У частично доверенного приложения, использующего поставщик the SQL Server, как минимум, должно быть право доступа для выполнения и право доступа <xref:System.Data.SqlClient.SqlClientPermission>.  
  
### <a name="permission-attribute-properties-for-partial-trust"></a>Свойства атрибута разрешения для частичного уровня доверия  
 Чтобы еще сильнее ограничить возможности поставщика данных .NET Framework для SQL Server, в сценариях с частичным уровнем доверия можно использовать члены <xref:System.Data.SqlClient.SqlClientPermissionAttribute>.  
  
 В следующей таблице содержится список имеющихся свойств <xref:System.Data.SqlClient.SqlClientPermissionAttribute> и их описания.  
  
|Свойство атрибута разрешения|Описание|  
|-----------------------------------|-----------------|  
|`Action`|Возвращает или задает действие по обеспечению безопасности. Наследуется от <xref:System.Security.Permissions.SecurityAttribute>.|  
|`AllowBlankPassword`|Разрешает или запрещает использование пустого пароля в строке соединения. Допустимые значения - `true` (чтобы разрешить использование пустых паролей) и `false` (чтобы запретить использование пустых паролей). Наследуется от <xref:System.Data.Common.DBDataPermissionAttribute>.|  
|`ConnectionString`|Определяет допустимую строку соединения. Можно определить несколько строк соединения. **Примечание:**  Не включайте идентификатор пользователя или пароль в строку подключения. В этой версии изменение ограничений строки соединения при помощи средства настройки .NET Framework невозможно. <br /><br /> Наследуется от <xref:System.Data.Common.DBDataPermissionAttribute>.|  
|`KeyRestrictions`|Определяет допустимые или недопустимые параметры строки соединения. Параметры строки соединения идентифицируются в * \<названии параметра*формы>. Можно указать несколько параметров, разделив их точкой с запятой (;). **Примечание:**  Если вы не `KeyRestrictions`указали, `KeyRestrictionBehavior` но `AllowOnly` `PreventUsage`вы установите свойство или, никаких дополнительных параметров строки соединения не допускаются. Наследуется от <xref:System.Data.Common.DBDataPermissionAttribute>.|  
|`KeyRestrictionBehavior`|Определяет единственно допустимые дополнительные параметры строки соединения (`AllowOnly`) или определяет недопустимые дополнительные параметры (`PreventUsage`). Значение по умолчанию — `AllowOnly`. Наследуется от <xref:System.Data.Common.DBDataPermissionAttribute>.|  
|`TypeID`|Возвращает уникальный идентификатор для этого атрибута при реализации в производном классе. Наследуется от <xref:System.Attribute>.|  
|`Unrestricted`|Указывает, объявлено ли неограниченное право доступа к ресурсу. Наследуется от <xref:System.Security.Permissions.SecurityAttribute>.|  
  
#### <a name="connectionstring-syntax"></a>Синтаксис ConnectionString  
 В следующем примере показывается, как использовать элемент `connectionStrings` файла конфигурации, чтобы разрешить использование только определенной строки соединения. Дополнительную информацию о хранении и извлечении строк соединения из файлов конфигурации можно найти в [строках Connection Strings.](connection-strings.md)  
  
```xml  
<connectionStrings>  
  <add name="DatabaseConnection"
    connectionString="Data Source=(local);Initial
    Catalog=Northwind;Integrated Security=true;" />  
</connectionStrings>  
```  
  
#### <a name="keyrestrictions-syntax"></a>Синтаксис KeyRestrictions  
 Следующий пример позволяет одну и ту же `Encrypt` `Packet Size` строку соединения, позволяет использовать параметры строки соединения и соединения, но ограничивает использование любых других параметров строки соединения.  
  
```xml  
<connectionStrings>  
  <add name="DatabaseConnection"
    connectionString="Data Source=(local);Initial
    Catalog=Northwind;Integrated Security=true;"  
    KeyRestrictions="Encrypt=;Packet Size=;"  
    KeyRestrictionBehavior="AllowOnly" />  
</connectionStrings>  
```  
  
#### <a name="keyrestrictionbehavior-with-preventusage-syntax"></a>Синтаксис KeyRestrictionBehavior с PreventUsage  
 В следующем примере включается та же строка соединения и разрешается использование всех остальных параметров строки соединения, за исключением `User Id`, `Password` и `Persist Security Info`.  
  
```xml  
<connectionStrings>  
  <add name="DatabaseConnection"
    connectionString="Data Source=(local);Initial
    Catalog=Northwind;Integrated Security=true;"  
    KeyRestrictions="User Id=;Password=;Persist Security Info=;"  
    KeyRestrictionBehavior="PreventUsage" />  
</connectionStrings>  
```  
  
#### <a name="keyrestrictionbehavior-with-allowonly-syntax"></a>Синтаксис KeyRestrictionBehavior с AllowOnly  
 В следующем примере включаются две строки соединения, которые также содержат параметры `Initial Catalog`, `Connection Timeout`, `Encrypt` и `Packet Size`. Использование всех остальных параметров строки соединения запрещено.  
  
```xml  
<connectionStrings>  
  <add name="DatabaseConnection"
    connectionString="Data Source=(local);Initial
    Catalog=Northwind;Integrated Security=true;"  
    KeyRestrictions="Initial Catalog;Connection Timeout=;  
       Encrypt=;Packet Size=;"
    KeyRestrictionBehavior="AllowOnly" />  
  
  <add name="DatabaseConnection2"
    connectionString="Data Source=SqlServer2;Initial
    Catalog=Northwind2;Integrated Security=true;"  
    KeyRestrictions="Initial Catalog;Connection Timeout=;  
       Encrypt=;Packet Size=;"
    KeyRestrictionBehavior="AllowOnly" />  
</connectionStrings>  
```  
  
### <a name="enabling-partial-trust-with-a-custom-permission-set"></a>Разрешение частичного уровня доверия при помощи пользовательских наборов прав доступа  
 Чтобы включить использование прав доступа <xref:System.Data.SqlClient> для определенной зоны, системный администратор должен создать пользовательский набор прав доступа и задать его в качестве набора прав доступа для конкретной зоны. Наборы прав доступа по умолчанию, например `LocalIntranet`, изменять нельзя. Например, включить <xref:System.Data.SqlClient> разрешения на <xref:System.Security.Policy.Zone> `LocalIntranet`код, который имеет , системный администратор `LocalIntranet`может скопировать набор разрешений для, переименовать его в "CustomLocalIntranet", добавить <xref:System.Data.SqlClient> разрешения, импортировать CustomLocalIntranet разрешения набор `LocalIntranet_Zone` с помощью [Caspol.exe (инструмент политики безопасности доступа кода)](../../tools/caspol-exe-code-access-security-policy-tool.md), и установить набор разрешений для CustomLocalIntranet .  
  
### <a name="sample-permission-set"></a>Образец набора прав доступа   
 Далее приведен образец набора прав доступа для поставщика данных .NET Framework для SQL Server в частично доверенном сценарии. Для получения информации о [Configuring Permission Sets Using Caspol.exe](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/4ybs46y6(v=vs.100))создании пользовательских наборов разрешений см.  
  
```xml  
<PermissionSet class="System.Security.NamedPermissionSet"  
  version="1"  
  Name="CustomLocalIntranet"  
  Description="Custom permission set given to applications on  
    the local intranet">  
  
<IPermission class="System.Data.SqlClient.SqlClientPermission, System.Data, Version=2.0.0000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"  
version="1"  
AllowBlankPassword="False">  
<add ConnectionString="Data Source=(local);Integrated Security=true;"  
 KeyRestrictions="Initial Catalog=;Connection Timeout=;  
   Encrypt=;Packet Size=;"
 KeyRestrictionBehavior="AllowOnly" />  
 </IPermission>  
</PermissionSet>  
```  
  
## <a name="verifying-adonet-code-access-using-security-permissions"></a>Проверка доступа к коду ADO.NET при помощи прав доступа Security Permissions  
 В сценариях с частичным доверием для некоторых методов в коде можно затребовать права доступа CAS, указав <xref:System.Data.SqlClient.SqlClientPermissionAttribute>. Если предоставление этого права доступа запрещено действующей политикой безопасности, перед выполнением кода формируется исключение. Для получения дополнительной информации о политике [Security Policy Best Practices](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/sa4se9bc(v=vs.100))безопасности [см.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/c1k0eed6(v=vs.100))  
  
### <a name="example"></a>Пример  
 В следующем примере демонстрируется, как написать код, в котором требуется определенная строка соединения. В нем имитируется запрет на неограниченные права доступа для <xref:System.Data.SqlClient>, который в реальной среде реализуется системным администратором при помощи политики CAS.  
  
> [!IMPORTANT]
> При разработке прав доступа CAS для ADO.NET рекомендуется начинать с наиболее жестких ограничений (полное отсутствие прав доступа), а затем добавлять определенные права доступа, необходимые конкретной задаче, которую требуется выполнить коду. Противоположный подход, когда начинают с предоставления всех прав доступа, а затем удаляют определенные права, не является безопасным, поскольку существует много способов выражения одинаковой строки соединения. Например, если начать с предоставления всех прав доступа, а затем попытаться запретить использование строки соединения «server=someserver», то строка «server=someserver.mycompany.com» останется допустимой. Начиная с отсутствия предоставленных прав, можно сократить вероятность появления уязвимостей, связанных с набором прав доступа.  
  
 В следующем коде демонстрируется, как `SqlClient` выполняет запрос на право доступа, который формирует исключение <xref:System.Security.SecurityException> при отсутствии соответствующих прав доступа CAS. Исключение <xref:System.Security.SecurityException> отображается в консольном окне.  
  
 [!code-csharp[DataWorks SqlClient.CAS#1](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlClient.CAS/CS/source.cs#1)]
 [!code-vb[DataWorks SqlClient.CAS#1](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlClient.CAS/VB/source.vb#1)]  
  
 Вот что должно отобразиться в консольном окне:  
  
```output  
Failed, as expected: <IPermission class="System.Data.SqlClient.  
SqlClientPermission, System.Data, Version=2.0.0.0,
  Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1"  
  AllowBlankPassword="False">  
<add ConnectionString="Data Source=(local);Initial Catalog=  
  Northwind;Integrated Security=SSPI" KeyRestrictions=""  
KeyRestrictionBehavior="AllowOnly"/>  
</IPermission>  
  
Connection opened, as expected.  
Failed, as expected: Request failed.  
```  
  
## <a name="interoperability-with-unmanaged-code"></a>Совместимость с неуправляемым кодом  
 Код, который выполняется вне среды CLR, называется неуправляемым. Поэтому применять к неуправляемому коду такие механизмы безопасности, как CAS, нельзя. Примерами неуправляемого кода являются компоненты COM, интерфейсы ActiveX и функции Windows API. При выполнении неуправляемого кода возникают особые вопросы безопасности, с тем чтобы не подвергать риску общую безопасность приложения. Дополнительные сведения см. в разделе [Взаимодействие с неуправляемым кодом](../../interop/index.md).  
  
 Платформа .NET Framework также поддерживает обратную совместимость с существующими COM-компонентами, предоставляя доступ через COM-взаимодействие. COM-компоненты можно встраивать в приложение .NET Framework, используя средства COM-взаимодействия для импорта соответствующих типов COM. Типы COM готовы к использованию сразу после импорта. COM-взаимодействие также позволяет клиентам COM получать доступ к управляемому коду путем экспорта метаданных сборки в библиотеку типов и регистрации управляемого компонента в виде COM-компонента. Для получения дополнительной информации [см.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bd9cdfyx(v=vs.100))  
  
## <a name="see-also"></a>См. также раздел

- [Защита приложений ADO.NET](securing-ado-net-applications.md)
- [Безопасность в машинном коде и коде .NET Framework](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2010/1787tk12(v=vs.100))
- [Безопасность на основе ролей](../../../standard/security/role-based-security.md)
- [Общие сведения о ADO.NET](ado-net-overview.md)
