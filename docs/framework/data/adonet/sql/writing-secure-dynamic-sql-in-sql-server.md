---
title: Написание безопасного динамического кода SQL в SQL Server
ms.date: 03/30/2017
ms.assetid: df5512b0-c249-40d2-82f9-f9a2ce6665bc
ms.openlocfilehash: 236fd925740d37c2cccabfcebfb7fcb46361489d
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/08/2019
ms.locfileid: "59107358"
---
# <a name="writing-secure-dynamic-sql-in-sql-server"></a>Написание безопасного динамического кода SQL в SQL Server
Внедрение кода SQL - это процесс, посредством которого пользователь-злоумышленник вводит инструкции языка Transact-SQL вместо допустимых входных данных. Если входные данные передаются непосредственно на сервер без проверки, и если в приложении не приняты меры против выполнения внедренного кода, то появляется возможность осуществлять злонамеренные действия для повреждения или уничтожения данных.  
  
 Любая процедура, создающая инструкции SQL, должна рассматриваться на предмет уязвимости к внедрению небезопасного кода, поскольку SQL Server выполняет все получаемые синтаксически правильные запросы. Даже параметризованные данные могут стать предметом манипуляций опытного и решительного злоумышленника. В случае применения динамического кода SQL следует обязательно параметризовать применяемые команды и никогда не включать значения параметров непосредственно в строку запроса.  
  
## <a name="anatomy-of-a-sql-injection-attack"></a>Принцип осуществления атаки путем внедрения кода SQL  
 Атака осуществляется посредством преждевременного завершения текстовой строки и присоединения к ней новой команды. Поскольку к вставленной команде перед выполнением могут быть добавлены дополнительные строки, злоумышленник заканчивает внедряемую строку меткой комментария «--». Весь последующий текст во время выполнения не учитывается. Вставка нескольких команд осуществляется с помощью разделителя - точки с запятой (;).  
  
 Если вставленный код SQL синтаксически верен, искаженные данные нельзя выявить программно. Поэтому необходимо проверять правильность всех вводимых пользователями данных, а также внимательно просматривать код, выполняющий созданные SQL-команды на сервере. Никогда не объединяйте введенные пользователем данные без проверки. Объединение строк является основной точкой входа для внедрения кода в скрипте.  
  
 Ниже приведены некоторые полезные рекомендации.  
  
-   Ни в коем случае не следует формировать инструкции Transact-SQL непосредственно на основании данных, введенных пользователем. Используйте хранимые процедуры для проверки ввода данных пользователем.  
  
-   Всегда проверяйте все данные, вводимые пользователем, выполняя проверку типа, длины, формата и диапазона данных. Применяйте функцию QUOTENAME() языка Transact-SQL для экранирования системных имен или функцию REPLACE() для экранирования любого символа в строке.  
  
-   Реализуйте несколько уровней проверки в каждом уровне приложения.  
  
-   Проверяйте размер и тип вводимых данных и устанавливайте соответствующие ограничения. Это поможет предотвратить преднамеренное переполнение буфера.  
  
-   Проверяйте содержимое строковых переменных и принимайте только ожидаемые значения. Отклоняйте записи, содержащие двоичные данные, управляющие последовательности и символы комментариев.  
  
-   При работе с XML-документами проверяйте все вводимые данные на соответствие схеме.  
  
-   В многоуровневых средах все данные должны проверяться перед передачей в доверенную зону.  
  
-   Не допускайте использование в полях следующих строк, из которых могут быть созданы имена файлов: AUX, CLOCK$, COM1–COM8, CON, CONFIG$, LPT1–LPT8, NUL и PRN.  
  
-   Используйте объекты <xref:System.Data.SqlClient.SqlParameter> с хранимыми процедурами и командами для обеспечения контроля типов и проверки длины.  
  
-   Используйте выражения <xref:System.Text.RegularExpressions.Regex> в клиентском коде для фильтрации недопустимых символов.  
  
## <a name="dynamic-sql-strategies"></a>Стратегии применения динамического кода SQL  
 Выполнение динамически создаваемых инструкций SQL в процедурном коде нарушает цепочку владения, в результате чего SQL Server приходится проверять разрешения вызывающего объекта на объекты, доступ к которым осуществляется в динамическом коде SQL.  
  
 В SQL Server имеются методы предоставления пользователям доступа к данным с помощью хранимых процедур и определяемых пользователем функций, в которых выполняется динамический код SQL.  
  
-   Использование олицетворения с предложением Transact-SQL EXECUTE AS, как описано в разделе [Настройка разрешений с олицетворением в SQL Server](../../../../../docs/framework/data/adonet/sql/customizing-permissions-with-impersonation-in-sql-server.md).  
  
-   Подписывание хранимых процедур с помощью сертификатов, как описано в разделе [Подписывание хранимых процедур в SQL Server](../../../../../docs/framework/data/adonet/sql/signing-stored-procedures-in-sql-server.md).  
  
### <a name="execute-as"></a>EXECUTE AS  
 Предложение EXECUTE AS заменяет разрешения вызывающего объекта разрешениями пользователя, указанного в предложении EXECUTE AS. Вложенные хранимые процедуры или триггеры выполняются в контексте безопасности пользователя-посредника. Это может привести к нарушению работы приложений, которые основаны на использовании средств безопасности уровня строки или требуют аудита. Некоторые функции, возвращающие идентификатор пользователя, возвращают данные о пользователе, указанном в предложении EXECUTE AS, а не данные первоначального вызывающего объекта. Контекст выполнения переходит к вызывающему объекту только после выполнения процедуры или при выполнении инструкции REVERT.  
  
### <a name="certificate-signing"></a>Подпись сертификата  
 При выполнении хранимой процедуры, подписанной с помощью сертификата, разрешения, предоставленные пользователю сертификата, объединяются с разрешениями вызывающего объекта. Контекст выполнения остается тем же; пользователь сертификата не олицетворяет вызывающий объект. Для подписания хранимых процедур необходимо выполнить несколько действий. После каждого изменения процедуры должно быть проведено ее повторное подписание.  
  
### <a name="cross-database-access"></a>Доступ к объектам в нескольких базах данных  
 Межбазовые цепочки владения не работают при выполнении динамически создаваемых инструкций SQL. Это можно обойти в SQL Server, создав хранимую процедуру для доступа к данным другой базы данных и подписав эту процедуру сертификатом, существующим в обеих базах данных. Это предоставляет пользователям доступ к используемым процедурой ресурсам базы данных без предоставления им доступа к базе данных или разрешений на нее.  
  
## <a name="external-resources"></a>Внешние ресурсы  
 Дополнительные сведения см. в следующих ресурсах.  
  
|Ресурс|Описание|  
|--------------|-----------------|  
|[Хранимые процедуры](/sql/relational-databases/stored-procedures/stored-procedures-database-engine) и [Внедрение кода SQL](/sql/relational-databases/security/sql-injection) в электронной документации на SQL Server|Разделы описывают, как создавать хранимые процедуры и как работает внедрение кода SQL.|  
  
## <a name="see-also"></a>См. также

- [Защита приложений ADO.NET](../../../../../docs/framework/data/adonet/securing-ado-net-applications.md)
- [Общие сведения о безопасности SQL Server](../../../../../docs/framework/data/adonet/sql/overview-of-sql-server-security.md)
- [Сценарии безопасности приложений в SQL Server](../../../../../docs/framework/data/adonet/sql/application-security-scenarios-in-sql-server.md)
- [Управление разрешениями с использованием хранимых процедур в SQL Server](../../../../../docs/framework/data/adonet/sql/managing-permissions-with-stored-procedures-in-sql-server.md)
- [Подписывание хранимых процедур в SQL Server](../../../../../docs/framework/data/adonet/sql/signing-stored-procedures-in-sql-server.md)
- [Настройка разрешений с олицетворением в SQL Server](../../../../../docs/framework/data/adonet/sql/customizing-permissions-with-impersonation-in-sql-server.md)
- [Управляемые поставщики ADO.NET и центр разработчиков DataSet](https://go.microsoft.com/fwlink/?LinkId=217917)
