---
title: Изоляция снимков в SQL Server
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 43ae5dd3-50f5-43a8-8d01-e37a61664176
ms.openlocfilehash: 8313ffc8eef70c1e5efc24b09a160edb7cec1595
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79174268"
---
# <a name="snapshot-isolation-in-sql-server"></a><span data-ttu-id="ef529-102">Изоляция снимков в SQL Server</span><span class="sxs-lookup"><span data-stu-id="ef529-102">Snapshot Isolation in SQL Server</span></span>
<span data-ttu-id="ef529-103">Изоляция моментальных снимков улучшает параллелизм для приложений OLTP.</span><span class="sxs-lookup"><span data-stu-id="ef529-103">Snapshot isolation enhances concurrency for OLTP applications.</span></span>  
  
## <a name="understanding-snapshot-isolation-and-row-versioning"></a><span data-ttu-id="ef529-104">Основные сведения об изоляции моментального снимка и управлении версиями строк</span><span class="sxs-lookup"><span data-stu-id="ef529-104">Understanding Snapshot Isolation and Row Versioning</span></span>  
 <span data-ttu-id="ef529-105">После включения изоляции моментального снимка необходимо поддерживать обновленные версии строкдляй для каждой транзакции.</span><span class="sxs-lookup"><span data-stu-id="ef529-105">Once snapshot isolation is enabled, updated row versions for each transaction must be maintained.</span></span>  <span data-ttu-id="ef529-106">До s'L Server 2019 эти версии хранились в **tempdb**.</span><span class="sxs-lookup"><span data-stu-id="ef529-106">Prior to SQL Server 2019, these versions were stored in **tempdb**.</span></span> <span data-ttu-id="ef529-107">S'L Server 2019 представляет новую функцию Ускоренное восстановление базы данных (ADR), которая требует своего собственного набора версий строк.</span><span class="sxs-lookup"><span data-stu-id="ef529-107">SQL Server 2019 introduces a new feature, Accelerated Database Recovery (ADR) which requires its own set of row versions.</span></span>  <span data-ttu-id="ef529-108">Таким образом, по состоянию на 2019 г. S'L Server, если ADR не включен, строки версии хранятся в **tempdb,** как всегда.</span><span class="sxs-lookup"><span data-stu-id="ef529-108">So, as of SQL Server 2019, if ADR is not enabled, row versions are kept in **tempdb** as always.</span></span>  <span data-ttu-id="ef529-109">Если ADR включен, то все версии строки, как связанные с изоляцией моментального снимка, так и ADR, хранятся в магазине постоянных версий ADR (PVS), который находится в базе данных пользователя в файловой группе, которую пользователь определяет.</span><span class="sxs-lookup"><span data-stu-id="ef529-109">If ADR is enabled, then all row versions, both related to snapshot isolation and ADR, are kept in ADR's Persistent Version Store (PVS), which is located in the user database in a filegroup which the user specifies.</span></span> <span data-ttu-id="ef529-110">Уникальный порядковый номер транзакции идентифицирует каждую транзакцию, и эти уникальные числа записываются для каждой версии строки.</span><span class="sxs-lookup"><span data-stu-id="ef529-110">A unique transaction sequence number identifies each transaction, and these unique numbers are recorded for each row version.</span></span> <span data-ttu-id="ef529-111">Транзакция работает с последними версиями строк, порядковый номер которых предшествует порядковому номеру транзакции.</span><span class="sxs-lookup"><span data-stu-id="ef529-111">The transaction works with the most recent row versions having a sequence number before the sequence number of the transaction.</span></span> <span data-ttu-id="ef529-112">Транзакция игнорирует более новые версии строк, созданные после начала транзакции.</span><span class="sxs-lookup"><span data-stu-id="ef529-112">Newer row versions created after the transaction has begun are ignored by the transaction.</span></span>  
  
 <span data-ttu-id="ef529-113">Термин "моментальный снимок" означает, что все запросы в транзакции имеют одну и ту же версию или моментальный снимок базы данных, исходя из состояния базы данных в момент начала транзакции.</span><span class="sxs-lookup"><span data-stu-id="ef529-113">The term "snapshot" reflects the fact that all queries in the transaction see the same version, or snapshot, of the database, based on the state of the database at the moment in time when the transaction begins.</span></span> <span data-ttu-id="ef529-114">Транзакция моментального снимка не требует блокировок базовых строк или страниц данных, что позволяет выполнять другую транзакцию без ее блокировки предыдущей незавершенной транзакцией.</span><span class="sxs-lookup"><span data-stu-id="ef529-114">No locks are acquired on the underlying data rows or data pages in a snapshot transaction, which permits other transactions to execute without being blocked by a prior uncompleted transaction.</span></span> <span data-ttu-id="ef529-115">Транзакции, изменяющие данные, не блокируют транзакции, считывающие данные, а транзакции, считывающие данные, не блокируют транзакции, которые записывают данные, так как в SQL Server они обычно находятся на стандартном уровне изоляции READ COMMITTED.</span><span class="sxs-lookup"><span data-stu-id="ef529-115">Transactions that modify data do not block transactions that read data, and transactions that read data do not block transactions that write data, as they normally would under the default READ COMMITTED isolation level in SQL Server.</span></span> <span data-ttu-id="ef529-116">Такое неблокирующее поведение также значительно снижает вероятность взаимоблокировок в сложных транзакциях.</span><span class="sxs-lookup"><span data-stu-id="ef529-116">This non-blocking behavior also significantly reduces the likelihood of deadlocks for complex transactions.</span></span>  
  
 <span data-ttu-id="ef529-117">Изоляция моментальных снимков использует модель оптимистической блокировки.</span><span class="sxs-lookup"><span data-stu-id="ef529-117">Snapshot isolation uses an optimistic concurrency model.</span></span> <span data-ttu-id="ef529-118">Если транзакция моментального снимка пытается зафиксировать изменения в данных, которые имели место с момента начала транзакции, произойдет откат транзакции и возникнет ошибка.</span><span class="sxs-lookup"><span data-stu-id="ef529-118">If a snapshot transaction attempts to commit modifications to data that has changed since the transaction began, the transaction will roll back and an error will be raised.</span></span> <span data-ttu-id="ef529-119">Этого можно избежать, используя указания UPDLOCK для инструкций SELECT, обращающихся к изменяемым данным.</span><span class="sxs-lookup"><span data-stu-id="ef529-119">You can avoid this by using UPDLOCK hints for SELECT statements that access data to be modified.</span></span> <span data-ttu-id="ef529-120">Дополнительные сведения см. в разделе об указаниях блокировок в электронной документации по SQL Server.</span><span class="sxs-lookup"><span data-stu-id="ef529-120">See "Locking Hints" in SQL Server Books Online for more information.</span></span>  
  
 <span data-ttu-id="ef529-121">Для использования изоляции моментальных снимков в транзакции необходимо включить эту функцию с помощью параметра ALLOW_SNAPSHOT_ISOLATION ON базы данных.</span><span class="sxs-lookup"><span data-stu-id="ef529-121">Snapshot isolation must be enabled by setting the ALLOW_SNAPSHOT_ISOLATION ON database option before it is used in transactions.</span></span> <span data-ttu-id="ef529-122">Это приводит к активизации механизма сохранения версий строк во временной базе данных (**tempdb**).</span><span class="sxs-lookup"><span data-stu-id="ef529-122">This activates the mechanism for storing row versions in the temporary database (**tempdb**).</span></span> <span data-ttu-id="ef529-123">Необходимо включить изоляцию моментальных снимков в каждой использующей ее базе данных с помощью инструкции Transact-SQL ALTER DATABASE.</span><span class="sxs-lookup"><span data-stu-id="ef529-123">You must enable snapshot isolation in each database that uses it with the Transact-SQL ALTER DATABASE statement.</span></span> <span data-ttu-id="ef529-124">В этом отношении изоляция моментальных снимков отличается от традиционных уровней изоляции READ COMMITTED, REPEATABLE READ, SERIALIZABLE и READ UNCOMMITTED, которые не требуется настраивать.</span><span class="sxs-lookup"><span data-stu-id="ef529-124">In this respect, snapshot isolation differs from the traditional isolation levels of READ COMMITTED, REPEATABLE READ, SERIALIZABLE, and READ UNCOMMITTED, which require no configuration.</span></span> <span data-ttu-id="ef529-125">Следующие инструкции активируют изоляцию моментальных снимков и заменяют зафиксированное поведение по умолчанию READ COMMITTED на SNAPSHOT:</span><span class="sxs-lookup"><span data-stu-id="ef529-125">The following statements activate snapshot isolation and replace the default READ COMMITTED behavior with SNAPSHOT:</span></span>  
  
```sql  
ALTER DATABASE MyDatabase  
SET ALLOW_SNAPSHOT_ISOLATION ON  
  
ALTER DATABASE MyDatabase  
SET READ_COMMITTED_SNAPSHOT ON  
```  
  
 <span data-ttu-id="ef529-126">Включение параметра READ_COMMITTED_SNAPSHOT (ON) позволяет получить доступ к строкам с контролем версий на стандартном уровне изоляции READ COMMITTED.</span><span class="sxs-lookup"><span data-stu-id="ef529-126">Setting the READ_COMMITTED_SNAPSHOT ON option allows access to versioned rows under the default READ COMMITTED isolation level.</span></span> <span data-ttu-id="ef529-127">Если параметр READ_COMMITTED_SNAPSHOT имеет значение OFF, необходимо явно задать уровень изоляции моментального снимка для каждого сеанса, чтобы получить доступ к строкам с версиями.</span><span class="sxs-lookup"><span data-stu-id="ef529-127">If the READ_COMMITTED_SNAPSHOT option is set to OFF, you must explicitly set the Snapshot isolation level for each session in order to access versioned rows.</span></span>  
  
## <a name="managing-concurrency-with-isolation-levels"></a><span data-ttu-id="ef529-128">Управление параллелизмом с помощью уровней изоляции</span><span class="sxs-lookup"><span data-stu-id="ef529-128">Managing Concurrency with Isolation Levels</span></span>  
 <span data-ttu-id="ef529-129">Уровень изоляции, при котором выполняется инструкция Transact-SQL, определяет поведение блокировки и управления версиями строк.</span><span class="sxs-lookup"><span data-stu-id="ef529-129">The isolation level under which a Transact-SQL statement executes determines its locking and row versioning behavior.</span></span> <span data-ttu-id="ef529-130">Уровень изоляции имеет область действия на уровне подключения, и после установки подключения с помощью инструкции SET TRANSACTION ISOLATION LEVEL он действует до тех пор, пока подключение не будет разорвано или не будет установлен другой уровень изоляции.</span><span class="sxs-lookup"><span data-stu-id="ef529-130">An isolation level has connection-wide scope, and once set for a connection with the SET TRANSACTION ISOLATION LEVEL statement, it remains in effect until the connection is closed or another isolation level is set.</span></span> <span data-ttu-id="ef529-131">После разрыва подключения и возвращения в пул сохраняется уровень изоляции из последней инструкции SET TRANSACTION ISOLATION LEVEL.</span><span class="sxs-lookup"><span data-stu-id="ef529-131">When a connection is closed and returned to the pool, the isolation level from the last SET TRANSACTION ISOLATION LEVEL statement is retained.</span></span> <span data-ttu-id="ef529-132">Последующие подключения, использующие подключение из пула, применяют уровень изоляции, действовавший в момент добавления подключения в пул.</span><span class="sxs-lookup"><span data-stu-id="ef529-132">Subsequent connections reusing a pooled connection use the isolation level that was in effect at the time the connection is pooled.</span></span>  
  
 <span data-ttu-id="ef529-133">Отдельные запросы, выдаваемые в подключении, могут содержать указания блокировки, которые изменяют изоляцию для отдельной инструкции или транзакции, но не влияют на уровень изоляции подключения.</span><span class="sxs-lookup"><span data-stu-id="ef529-133">Individual queries issued within a connection can contain lock hints that modify the isolation for a single statement or transaction but do not affect the isolation level of the connection.</span></span> <span data-ttu-id="ef529-134">Уровни изоляции или указания блокировки, заданные в хранимых процедурах или функциях, не изменяют уровень изоляции вызывающего их подключения и действуют только во время выполнения хранимой процедуры или вызова функции.</span><span class="sxs-lookup"><span data-stu-id="ef529-134">Isolation levels or lock hints set in stored procedures or functions do not change the isolation level of the connection that calls them and are in effect only for the duration of the stored procedure or function call.</span></span>  
  
 <span data-ttu-id="ef529-135">В ранних версиях SQL Server поддерживались четыре уровня изоляции, определенные в стандарте SQL-92:</span><span class="sxs-lookup"><span data-stu-id="ef529-135">Four isolation levels defined in the SQL-92 standard were supported in early versions of SQL Server:</span></span>  
  
- <span data-ttu-id="ef529-136">READ UNCOMMITTED — это наименее строгий уровень изоляции, так как он игнорирует блокировки, размещенные другими транзакциями.</span><span class="sxs-lookup"><span data-stu-id="ef529-136">READ UNCOMMITTED is the least restrictive isolation level because it ignores locks placed by other transactions.</span></span> <span data-ttu-id="ef529-137">Транзакции, выполняемые с помощью инструкции READ UNCOMMITTED, могут считывать измененные значения данных, которые еще не были зафиксированы другими транзакциями. Такие операции чтения называются чтением "грязных" данных.</span><span class="sxs-lookup"><span data-stu-id="ef529-137">Transactions executing under READ UNCOMMITTED can read modified data values that have not yet been committed by other transactions; these are called "dirty" reads.</span></span>  
  
- <span data-ttu-id="ef529-138">READ COMMITTED является уровнем изоляции по умолчанию для SQL Server.</span><span class="sxs-lookup"><span data-stu-id="ef529-138">READ COMMITTED is the default isolation level for SQL Server.</span></span> <span data-ttu-id="ef529-139">Он предотвращает операции чтения "грязных" данных, указывая, что инструкции не могут считывать значения данных, которые были изменены, но еще не зафиксированы другими транзакциями.</span><span class="sxs-lookup"><span data-stu-id="ef529-139">It prevents dirty reads by specifying that statements cannot read data values that have been modified but not yet committed by other transactions.</span></span> <span data-ttu-id="ef529-140">Другие транзакции по-прежнему могут изменять, вставлять или удалять данные между выполнениями отдельных инструкций в текущей транзакции, результатом чего будет неповторяемое чтение или фантомные данные.</span><span class="sxs-lookup"><span data-stu-id="ef529-140">Other transactions can still modify, insert, or delete data between executions of individual statements within the current transaction, resulting in non-repeatable reads, or "phantom" data.</span></span>  
  
- <span data-ttu-id="ef529-141">REPEATABLE READ — это более строгий уровень изоляции, чем READ COMMITTED.</span><span class="sxs-lookup"><span data-stu-id="ef529-141">REPEATABLE READ is a more restrictive isolation level than READ COMMITTED.</span></span> <span data-ttu-id="ef529-142">Он включает в себя READ COMMITTED и дополнительно указывает, что никакие другие транзакции не могут изменять или удалять данные, которые были считаны текущей транзакцией, пока текущая транзакция не будет зафиксирована.</span><span class="sxs-lookup"><span data-stu-id="ef529-142">It encompasses READ COMMITTED and additionally specifies that no other transactions can modify or delete data that has been read by the current transaction until the current transaction commits.</span></span> <span data-ttu-id="ef529-143">Учитывая то, что совмещаемые блокировки на считываемых данных сохраняются до завершения транзакции и не снимаются в конце каждой инструкции, степень совпадений ниже, чем при уровне изоляции READ COMMITTED.</span><span class="sxs-lookup"><span data-stu-id="ef529-143">Concurrency is lower than for READ COMMITTED because shared locks on read data are held for the duration of the transaction instead of being released at the end of each statement.</span></span>  
  
- <span data-ttu-id="ef529-144">SERIALIZABLE — самый строгий уровень изоляции, поскольку он блокирует целые диапазоны ключей и сохраняет блокировку до завершения транзакции.</span><span class="sxs-lookup"><span data-stu-id="ef529-144">SERIALIZABLE is the most restrictive isolation level, because it locks entire ranges of keys and holds the locks until the transaction is complete.</span></span> <span data-ttu-id="ef529-145">Он включает в себя REPEATABLE READ и добавляет ограничение, запрещающее другим транзакциям вставлять новые строки в диапазоны, которые были прочитаны транзакцией, пока транзакция не будет завершена.</span><span class="sxs-lookup"><span data-stu-id="ef529-145">It encompasses REPEATABLE READ and adds the restriction that other transactions cannot insert new rows into ranges that have been read by the transaction until the transaction is complete.</span></span>  
  
 <span data-ttu-id="ef529-146">Дополнительные сведения: [Руководство по блокировке и управлению версиями строк транзакций](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide).</span><span class="sxs-lookup"><span data-stu-id="ef529-146">For more information, refer to the [Transaction Locking and Row Versioning Guide](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide).</span></span>  
  
### <a name="snapshot-isolation-level-extensions"></a><span data-ttu-id="ef529-147">Расширения уровня изоляции моментального снимка</span><span class="sxs-lookup"><span data-stu-id="ef529-147">Snapshot Isolation Level Extensions</span></span>  
 <span data-ttu-id="ef529-148">SQL Server предоставляет расширения уровней изоляции стандарта SQL-92 путем представления уровня изоляции SNAPSHOT и дополнительных изменений в READ COMMITTED.</span><span class="sxs-lookup"><span data-stu-id="ef529-148">SQL Server introduced extensions to the SQL-92 isolation levels with the introduction of the SNAPSHOT isolation level and an additional implementation of READ COMMITTED.</span></span> <span data-ttu-id="ef529-149">Уровень изоляции READ_COMMITTED_SNAPSHOT может прозрачно заменять READ COMMITTED для всех транзакций.</span><span class="sxs-lookup"><span data-stu-id="ef529-149">The READ_COMMITTED_SNAPSHOT isolation level can transparently replace READ COMMITTED for all transactions.</span></span>  
  
- <span data-ttu-id="ef529-150">Изоляция уровня SNAPSHOT указывает, что данные, считываемые в рамках транзакции, никогда не будут отражать изменения, внесенные другими одновременными транзакциями.</span><span class="sxs-lookup"><span data-stu-id="ef529-150">SNAPSHOT isolation specifies that data read within a transaction will never reflect changes made by other simultaneous transactions.</span></span> <span data-ttu-id="ef529-151">Транзакция использует версии строк данных, которые существуют в начале транзакции.</span><span class="sxs-lookup"><span data-stu-id="ef529-151">The transaction uses the data row versions that exist when the transaction begins.</span></span> <span data-ttu-id="ef529-152">При чтении данные не блокируются, поэтому транзакции моментальных снимков не блокируют запись данных другими транзакциями.</span><span class="sxs-lookup"><span data-stu-id="ef529-152">No locks are placed on the data when it is read, so SNAPSHOT transactions do not block other transactions from writing data.</span></span> <span data-ttu-id="ef529-153">Транзакции, осуществляющие запись данных, не блокируют считывание данных транзакциями моментальных снимков.</span><span class="sxs-lookup"><span data-stu-id="ef529-153">Transactions that write data do not block snapshot transactions from reading data.</span></span> <span data-ttu-id="ef529-154">Для использования изоляции моментальных снимков необходимо включить ее, настроив параметр базы данных ALLOW_SNAPSHOT_ISOLATION.</span><span class="sxs-lookup"><span data-stu-id="ef529-154">You need to enable snapshot isolation by setting the ALLOW_SNAPSHOT_ISOLATION database option in order to use it.</span></span>  
  
- <span data-ttu-id="ef529-155">Параметр базы данных READ_COMMITTED_SNAPSHOT определяет поведение стандартного уровня изоляции READ COMMITTED, если изоляция моментальных снимков включена в базе данных.</span><span class="sxs-lookup"><span data-stu-id="ef529-155">The READ_COMMITTED_SNAPSHOT database option determines the behavior of the default READ COMMITTED isolation level when snapshot isolation is enabled in a database.</span></span> <span data-ttu-id="ef529-156">Если не указать параметр READ_COMMITTED_SNAPSHOT явным образом, то для всех неявных транзакций применяется уровень READ COMMITTED.</span><span class="sxs-lookup"><span data-stu-id="ef529-156">If you do not explicitly specify READ_COMMITTED_SNAPSHOT ON, READ COMMITTED is applied to all implicit transactions.</span></span> <span data-ttu-id="ef529-157">Это приводит к тому же поведению, что и при использовании параметра READ_COMMITTED_SNAPSHOT (по умолчанию).</span><span class="sxs-lookup"><span data-stu-id="ef529-157">This produces the same behavior as setting READ_COMMITTED_SNAPSHOT OFF (the default).</span></span> <span data-ttu-id="ef529-158">Если действует параметр READ_COMMITTED_SNAPSHOT, ядро СУБД использует совмещаемые блокировки для применения уровня изоляции по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="ef529-158">When READ_COMMITTED_SNAPSHOT OFF is in effect, the Database Engine uses shared locks to enforce the default isolation level.</span></span> <span data-ttu-id="ef529-159">Если параметру базы данных READ_COMMITTED_SNAPSHOT присвоить значение ON, то ядро СУБД использует управление версиями строк и режим изоляции моментальных снимков по умолчанию вместо блокировок для защиты данных.</span><span class="sxs-lookup"><span data-stu-id="ef529-159">If you set the READ_COMMITTED_SNAPSHOT database option to ON, the database engine uses row versioning and snapshot isolation as the default, instead of using locks to protect the data.</span></span>  
  
## <a name="how-snapshot-isolation-and-row-versioning-work"></a><span data-ttu-id="ef529-160">Основные сведения о функционировании уровней изоляции моментального снимка и управлении версиями строк</span><span class="sxs-lookup"><span data-stu-id="ef529-160">How Snapshot Isolation and Row Versioning Work</span></span>  
 <span data-ttu-id="ef529-161">Если включен уровень изоляции SNAPSHOT, то при обновлении каждой строки компонент SQL Server Database Engine сохраняет копию исходной строки в базе данных **tempdb** и добавляет в строку порядковый номер транзакции.</span><span class="sxs-lookup"><span data-stu-id="ef529-161">When the SNAPSHOT isolation level is enabled, each time a row is updated, the SQL Server Database Engine stores a copy of the original row in **tempdb**, and adds a transaction sequence number to the row.</span></span> <span data-ttu-id="ef529-162">Ниже приведены происходящие события в последовательном порядке.</span><span class="sxs-lookup"><span data-stu-id="ef529-162">The following is the sequence of events that occurs:</span></span>  
  
- <span data-ttu-id="ef529-163">Инициируется новая транзакция, и ей назначается порядковый номер.</span><span class="sxs-lookup"><span data-stu-id="ef529-163">A new transaction is initiated, and it is assigned a transaction sequence number.</span></span>  
  
- <span data-ttu-id="ef529-164">Компонент Database Engine считывает строку внутри транзакции и получает версию строки из базы данных **tempdb**, чей порядковый номер наиболее близок и ниже порядкового номера транзакции.</span><span class="sxs-lookup"><span data-stu-id="ef529-164">The Database Engine reads a row within the transaction and retrieves the row version from **tempdb** whose sequence number is closest to, and lower than, the transaction sequence number.</span></span>  
  
- <span data-ttu-id="ef529-165">Ядро СУБД проверяет, не находится ли порядковый номер транзакции в списке порядковых номеров незафиксированных транзакций, активных при запуске транзакции моментальных снимков.</span><span class="sxs-lookup"><span data-stu-id="ef529-165">The Database Engine checks to see if the transaction sequence number is not in the list of transaction sequence numbers of the uncommitted transactions active when the snapshot transaction started.</span></span>  
  
- <span data-ttu-id="ef529-166">Транзакция считывает версию строки, которая была текущей во время запуска транзакции, из базы данных **tempdb**.</span><span class="sxs-lookup"><span data-stu-id="ef529-166">The transaction reads the version of the row from **tempdb** that was current as of the start of the transaction.</span></span> <span data-ttu-id="ef529-167">Новые строки, вставленные после запуска транзакции, не будут видны, так как эти порядковые номера будут выше, чем значение порядкового номера транзакции.</span><span class="sxs-lookup"><span data-stu-id="ef529-167">It will not see new rows inserted after the transaction was started because those sequence number values will be higher than the value of the transaction sequence number.</span></span>  
  
- <span data-ttu-id="ef529-168">Текущая транзакция обнаруживает строки, которые были удалены после ее запуска, поскольку версия любой строки в базе данных **tempdb** имеет меньшее значение порядкового номера, чем транзакция.</span><span class="sxs-lookup"><span data-stu-id="ef529-168">The current transaction will see rows that were deleted after the transaction began, because there will be a row version in **tempdb** with a lower sequence number value.</span></span>  
  
 <span data-ttu-id="ef529-169">Конечный результат изоляции моментального снимка заключается в том, что транзакция видит все данные в том виде, в котором они существовали в начале транзакции, без учета или размещения каких-либо блокировок в базовых таблицах.</span><span class="sxs-lookup"><span data-stu-id="ef529-169">The net effect of snapshot isolation is that the transaction sees all of the data as it existed at the start of the transaction, without honoring or placing any locks on the underlying tables.</span></span> <span data-ttu-id="ef529-170">Это может привести к улучшению производительности в ситуациях, когда возникает состязание.</span><span class="sxs-lookup"><span data-stu-id="ef529-170">This can result in performance improvements in situations where there is contention.</span></span>  
  
 <span data-ttu-id="ef529-171">Транзакция моментального снимка всегда использует управление оптимистической блокировкой, удерживая все блокировки, которые препятствуют обновлению строк другими транзакциями.</span><span class="sxs-lookup"><span data-stu-id="ef529-171">A snapshot transaction always uses optimistic concurrency control, withholding any locks that would prevent other transactions from updating rows.</span></span> <span data-ttu-id="ef529-172">Если транзакция моментального снимка пытается зафиксировать обновление строки, которая была изменена после начала транзакции, то выполняется откат транзакции и возникает ошибка.</span><span class="sxs-lookup"><span data-stu-id="ef529-172">If a snapshot transaction attempts to commit an update to a row that was changed after the transaction began, the transaction is rolled back, and an error is raised.</span></span>  
  
## <a name="working-with-snapshot-isolation-in-adonet"></a><span data-ttu-id="ef529-173">Работа с изоляцией моментального снимка в ADO.NET</span><span class="sxs-lookup"><span data-stu-id="ef529-173">Working with Snapshot Isolation in ADO.NET</span></span>  
 <span data-ttu-id="ef529-174">Изоляция моментальных снимков поддерживается в ADO.NET классом <xref:System.Data.SqlClient.SqlTransaction>.</span><span class="sxs-lookup"><span data-stu-id="ef529-174">Snapshot isolation is supported in ADO.NET by the <xref:System.Data.SqlClient.SqlTransaction> class.</span></span> <span data-ttu-id="ef529-175">Если в базе данных включена изоляция моментального снимка, но настройка конфигурации не выполнена с учетом параметра READ_COMMITTED_SNAPSHOT со значением ON, то необходимо инициировать транзакцию <xref:System.Data.SqlClient.SqlTransaction> с помощью значения перечисления **IsolationLevel.Snapshot** при вызове метода <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A>.</span><span class="sxs-lookup"><span data-stu-id="ef529-175">If a database has been enabled for snapshot isolation but is not configured for READ_COMMITTED_SNAPSHOT ON, you must initiate a <xref:System.Data.SqlClient.SqlTransaction> using the **IsolationLevel.Snapshot** enumeration value when calling the <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> method.</span></span> <span data-ttu-id="ef529-176">В этом фрагменте кода предполагается, что подключение является открытым объектом <xref:System.Data.SqlClient.SqlConnection>.</span><span class="sxs-lookup"><span data-stu-id="ef529-176">This code fragment assumes that connection is an open <xref:System.Data.SqlClient.SqlConnection> object.</span></span>  
  
```vb  
Dim sqlTran As SqlTransaction = _  
  connection.BeginTransaction(IsolationLevel.Snapshot)  
```  
  
```csharp  
SqlTransaction sqlTran =
  connection.BeginTransaction(IsolationLevel.Snapshot);  
```  
  
### <a name="example"></a><span data-ttu-id="ef529-177">Пример</span><span class="sxs-lookup"><span data-stu-id="ef529-177">Example</span></span>  
 <span data-ttu-id="ef529-178">В следующем примере демонстрируется поведение различных уровней изоляции при попытке доступа к заблокированным данным. Этот пример не предназначен для использования в рабочем коде.</span><span class="sxs-lookup"><span data-stu-id="ef529-178">The following example demonstrates how the different isolation levels behave by attempting to access locked data, and it is not intended to be used in production code.</span></span>  
  
 <span data-ttu-id="ef529-179">В коде устанавливается соединение с образцом базы данных **AdventureWorks** в SQL Server, создается таблица с именем **TestSnapshot** и производится вставка одной строки данных.</span><span class="sxs-lookup"><span data-stu-id="ef529-179">The code connects to the **AdventureWorks** sample database in SQL Server and creates a table named **TestSnapshot** and inserts one row of data.</span></span> <span data-ttu-id="ef529-180">В коде используется инструкция ALTER DATABASE Transact-SQL, чтобы включить изоляцию моментального снимка для базы данных, но не задан параметр READ_COMMITTED_SNAPSHOT. При этом действует поведение стандартного уровня изоляции READ COMMITTED.</span><span class="sxs-lookup"><span data-stu-id="ef529-180">The code uses the ALTER DATABASE Transact-SQL statement to turn on snapshot isolation for the database, but it does not set the READ_COMMITTED_SNAPSHOT option, leaving the default READ COMMITTED isolation-level behavior in effect.</span></span> <span data-ttu-id="ef529-181">Затем код выполняет следующие действия.</span><span class="sxs-lookup"><span data-stu-id="ef529-181">The code then performs the following actions:</span></span>  
  
- <span data-ttu-id="ef529-182">Он начинает, но не завершает транзакцию sqlTransaction1, которая использует уровень изоляции SERIALIZABLE для запуска транзакции обновления.</span><span class="sxs-lookup"><span data-stu-id="ef529-182">It begins, but does not complete, sqlTransaction1, which uses the SERIALIZABLE isolation level to start an update transaction.</span></span> <span data-ttu-id="ef529-183">При этом блокируется таблица.</span><span class="sxs-lookup"><span data-stu-id="ef529-183">This has the effect of locking the table.</span></span>  
  
- <span data-ttu-id="ef529-184">В коде открывается второе соединение и инициируется вторая транзакция с использованием уровня изоляции SNAPSHOT для чтения данных из таблицы **TestSnapshot**.</span><span class="sxs-lookup"><span data-stu-id="ef529-184">It opens a second connection and initiates a second transaction using the SNAPSHOT isolation level to read the data in the **TestSnapshot** table.</span></span> <span data-ttu-id="ef529-185">Так как изоляция моментальных снимков включена, эта транзакция может считывать данные, существовавшие до начала транзакции sqlTransaction1.</span><span class="sxs-lookup"><span data-stu-id="ef529-185">Because snapshot isolation is enabled, this transaction can read the data that existed before sqlTransaction1 started.</span></span>  
  
- <span data-ttu-id="ef529-186">В коде открывается третье подключение и инициируется транзакция с использованием уровня изоляции READ COMMITTED для чтения данных из таблицы.</span><span class="sxs-lookup"><span data-stu-id="ef529-186">It opens a third connection and initiates a transaction using the READ COMMITTED isolation level to attempt to read the data in the table.</span></span> <span data-ttu-id="ef529-187">В этом случае код не может прочитать данные, поскольку он не может прочитать прошлые блокировки, размещенные на столе в первой транзакции и время выхода. Тот же результат будет происходить, если бы были использованы уровни изоляции REPEATABLE READ и SERIAL-ABLE, поскольку эти уровни изоляции также не могут прочитать блокировки, помещенные в первую транзакцию.</span><span class="sxs-lookup"><span data-stu-id="ef529-187">In this case, the code cannot read the data because it cannot read past the locks placed on the table in the first transaction and times out. The same result would occur if the REPEATABLE READ and SERIALIZABLE isolation levels were used because these isolation levels also cannot read past the locks placed in the first transaction.</span></span>  
  
- <span data-ttu-id="ef529-188">В коде открывается четвертое подключение и инициируется еще одна транзакция с использованием уровня изоляции READ UNCOMMITTED, которая выполняет "грязное" чтение незафиксированного значения в sqlTransaction1.</span><span class="sxs-lookup"><span data-stu-id="ef529-188">It opens a fourth connection and initiates a transaction using the READ UNCOMMITTED isolation level, which performs a dirty read of the uncommitted value in sqlTransaction1.</span></span> <span data-ttu-id="ef529-189">Это значение может фактически не существовать в базе данных, если первая транзакция не будет зафиксирована.</span><span class="sxs-lookup"><span data-stu-id="ef529-189">This value may never actually exist in the database if the first transaction is not committed.</span></span>  
  
- <span data-ttu-id="ef529-190">В нем выполняется откат первой транзакции и производится чистка путем удаления таблицы **TestSnapshot** и выключения изоляции моментального снимка в базе данных **AdventureWorks**.</span><span class="sxs-lookup"><span data-stu-id="ef529-190">It rolls back the first transaction and cleans up by deleting the **TestSnapshot** table and turning off snapshot isolation for the **AdventureWorks** database.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="ef529-191">В следующих примерах используется та же строка подключения, в которой отключено использование пулов подключений.</span><span class="sxs-lookup"><span data-stu-id="ef529-191">The following examples use the same connection string with connection pooling turned off.</span></span> <span data-ttu-id="ef529-192">Если подключение входит в пул, сброс его уровня изоляции не приводит к сбросу уровня изоляции на сервере.</span><span class="sxs-lookup"><span data-stu-id="ef529-192">If a connection is pooled, resetting its isolation level does not reset the isolation level at the server.</span></span> <span data-ttu-id="ef529-193">В результате последующие подключения, использующие одно и то же внутреннее подключение в составе пула, запускаются с уровнями изоляции, заданными для подключения в пуле.</span><span class="sxs-lookup"><span data-stu-id="ef529-193">As a result, subsequent connections that use the same pooled inner connection start with their isolation levels set to that of the pooled connection.</span></span> <span data-ttu-id="ef529-194">Вместо отключения пулов подключений можно явно задать уровень изоляции для каждого подключения.</span><span class="sxs-lookup"><span data-stu-id="ef529-194">An alternative to turning off connection pooling is to set the isolation level explicitly for each connection.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/VB/source.vb#1)]  
  
### <a name="example"></a><span data-ttu-id="ef529-195">Пример</span><span class="sxs-lookup"><span data-stu-id="ef529-195">Example</span></span>  
 <span data-ttu-id="ef529-196">В следующем примере демонстрируется поведение изоляции моментального снимка в случае изменения данных.</span><span class="sxs-lookup"><span data-stu-id="ef529-196">The following example demonstrates the behavior of snapshot isolation when data is being modified.</span></span> <span data-ttu-id="ef529-197">Код выполняет следующие действия.</span><span class="sxs-lookup"><span data-stu-id="ef529-197">The code performs the following actions:</span></span>  
  
- <span data-ttu-id="ef529-198">Соединяется с образцом базы данных **AdventureWorks** и включает уровень изоляции SNAPSHOT.</span><span class="sxs-lookup"><span data-stu-id="ef529-198">Connects to the **AdventureWorks** sample database and enables SNAPSHOT isolation.</span></span>  
  
- <span data-ttu-id="ef529-199">Создает таблицу с именем **TestSnapshotUpdate** и вставляет три строки из образца данных.</span><span class="sxs-lookup"><span data-stu-id="ef529-199">Creates a table named **TestSnapshotUpdate** and inserts three rows of sample data.</span></span>  
  
- <span data-ttu-id="ef529-200">Транзакция sqlTransaction1 запускается, но не завершается с использованием изоляции SNAPSHOT.</span><span class="sxs-lookup"><span data-stu-id="ef529-200">Begins, but does not complete, sqlTransaction1 using SNAPSHOT isolation.</span></span> <span data-ttu-id="ef529-201">В транзакции выбираются три строки данных.</span><span class="sxs-lookup"><span data-stu-id="ef529-201">Three rows of data are selected in the transaction.</span></span>  
  
- <span data-ttu-id="ef529-202">Открывает второе соединение **SqlConnection** с базой данных **AdventureWorks** и создает вторую транзакцию, используя уровень изоляции READ COMMITTED, который обновляет значение в одной из строк, выбранных в sqlTransaction1.</span><span class="sxs-lookup"><span data-stu-id="ef529-202">Creates a second **SqlConnection** to **AdventureWorks** and creates a second transaction using the READ COMMITTED isolation level that updates a value in one of the rows selected in sqlTransaction1.</span></span>  
  
- <span data-ttu-id="ef529-203">Транзакция sqlTransaction2 фиксируется.</span><span class="sxs-lookup"><span data-stu-id="ef529-203">Commits sqlTransaction2.</span></span>  
  
- <span data-ttu-id="ef529-204">Выполняется возврат к транзакции sqlTransaction1, и осуществляется попытка обновить ту же строку, которая уже зафиксирована в sqlTransaction1.</span><span class="sxs-lookup"><span data-stu-id="ef529-204">Returns to sqlTransaction1 and attempts to update the same row that sqlTransaction1 already committed.</span></span> <span data-ttu-id="ef529-205">Возникает ошибка 3960, и для транзакции sqlTransaction1 выполняется автоматический откат.</span><span class="sxs-lookup"><span data-stu-id="ef529-205">Error 3960 is raised, and sqlTransaction1 is rolled back automatically.</span></span> <span data-ttu-id="ef529-206">Сообщения **SqlException.Number** и **SqlException.Message** отображаются в окне консоли.</span><span class="sxs-lookup"><span data-stu-id="ef529-206">The **SqlException.Number** and **SqlException.Message** are displayed in the Console window.</span></span>  
  
- <span data-ttu-id="ef529-207">Выполняет код очистки для выключения изоляции моментального снимка в **AdventureWorks** и удаления таблицы **TestSnapshotUpdate**.</span><span class="sxs-lookup"><span data-stu-id="ef529-207">Executes clean-up code to turn off snapshot isolation in **AdventureWorks** and delete the **TestSnapshotUpdate** table.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/VB/source.vb#1)]  
  
### <a name="using-lock-hints-with-snapshot-isolation"></a><span data-ttu-id="ef529-208">Использование подсказок блокировок с изоляцией моментального снимка</span><span class="sxs-lookup"><span data-stu-id="ef529-208">Using Lock Hints with Snapshot Isolation</span></span>  
 <span data-ttu-id="ef529-209">В предыдущем примере первая транзакция выбирает данные, а вторая обновляет данные до того, как первая транзакция сможет завершиться, что приведет к конфликту обновления, когда первая транзакция попытается обновить одну и ту же строку.</span><span class="sxs-lookup"><span data-stu-id="ef529-209">In the previous example, the first transaction selects data, and a second transaction updates the data before the first transaction is able to complete, causing an update conflict when the first transaction tries to update the same row.</span></span> <span data-ttu-id="ef529-210">Можно уменьшить вероятность конфликтов обновления в длительных транзакциях моментальных снимков, предоставив указания блокировки в начале транзакции.</span><span class="sxs-lookup"><span data-stu-id="ef529-210">You can reduce the chance of update conflicts in long-running snapshot transactions by supplying lock hints at the beginning of the transaction.</span></span> <span data-ttu-id="ef529-211">Следующая инструкция SELECT использует указание UPDLOCK для блокировки выбранных строк:</span><span class="sxs-lookup"><span data-stu-id="ef529-211">The following SELECT statement uses the UPDLOCK hint to lock the selected rows:</span></span>  
  
```sql  
SELECT * FROM TestSnapshotUpdate WITH (UPDLOCK)
  WHERE PriKey BETWEEN 1 AND 3  
```  
  
 <span data-ttu-id="ef529-212">Использование указания блокировки UPDLOCK блокирует любые строки, пытающиеся обновить строки до завершения первой транзакции.</span><span class="sxs-lookup"><span data-stu-id="ef529-212">Using the UPDLOCK lock hint blocks any rows attempting to update the rows before the first transaction completes.</span></span> <span data-ttu-id="ef529-213">Это гарантирует, что выбранные строки не будут иметь конфликтов, когда они будут обновлены позже в транзакции.</span><span class="sxs-lookup"><span data-stu-id="ef529-213">This guarantees that the selected rows have no conflicts when they are updated later in the transaction.</span></span> <span data-ttu-id="ef529-214">Дополнительные сведения см. в разделе об указаниях блокировок в электронной документации по SQL Server.</span><span class="sxs-lookup"><span data-stu-id="ef529-214">See "Locking Hints" in SQL Server Books Online.</span></span>  
  
 <span data-ttu-id="ef529-215">Если в приложении много конфликтов, изоляцию моментальных снимков лучше не использовать.</span><span class="sxs-lookup"><span data-stu-id="ef529-215">If your application has many conflicts, snapshot isolation may not be the best choice.</span></span> <span data-ttu-id="ef529-216">Указания следует использовать, только если это действительно требуется.</span><span class="sxs-lookup"><span data-stu-id="ef529-216">Hints should only be used when really needed.</span></span> <span data-ttu-id="ef529-217">Приложение не должно быть спроектировано таким образом, чтобы оно постоянно полагалось на указания блокировки для своей работы.</span><span class="sxs-lookup"><span data-stu-id="ef529-217">Your application should not be designed so that it constantly relies on lock hints for its operation.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ef529-218">См. также раздел</span><span class="sxs-lookup"><span data-stu-id="ef529-218">See also</span></span>

- [<span data-ttu-id="ef529-219">SQL Server и ADO.NET</span><span class="sxs-lookup"><span data-stu-id="ef529-219">SQL Server and ADO.NET</span></span>](index.md)
- [<span data-ttu-id="ef529-220">Общие сведения об ADO.NET</span><span class="sxs-lookup"><span data-stu-id="ef529-220">ADO.NET Overview</span></span>](../ado-net-overview.md)
- [<span data-ttu-id="ef529-221">Руководство по блокировке и управлению версиями строк транзакций</span><span class="sxs-lookup"><span data-stu-id="ef529-221">Transaction Locking and Row Versioning Guide</span></span>](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)
