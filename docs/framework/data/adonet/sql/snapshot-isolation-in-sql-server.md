---
title: Изоляция снимков в SQL Server
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 43ae5dd3-50f5-43a8-8d01-e37a61664176
ms.openlocfilehash: c06ecd8626b148c4f2143efdfa1e143d6ab3d6bc
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61876360"
---
# <a name="snapshot-isolation-in-sql-server"></a>Изоляция снимков в SQL Server
Изоляция моментального снимка приводит к повышению параллелизма для приложений OLTP.  
  
## <a name="understanding-snapshot-isolation-and-row-versioning"></a>Основные сведения об изоляции моментального снимка и управлении версиями строк  
 После включения изоляции моментального снимка обновленные версии строк для каждой транзакции сохраняются в **tempdb**. Уникальный порядковый номер транзакции определяет каждую транзакцию, и эти уникальные номера записываются для каждой версии строки. Транзакция работает с последними версиями строк, имеющими порядковый номер, предшествующий порядковому номеру транзакции. Более новые версии строк, созданные после начала транзакции, не учитываются.  
  
 Термин «моментальный снимок» отражает тот факт, что все запросы в транзакции обнаруживают одинаковую версию, или моментальный снимок базы данных, который соответствует состоянию базы данных в момент начала транзакции. Транзакция моментального снимка не требует блокировок базовых строк или страниц данных, что позволяет выполнять другую транзакцию без ее блокировки предыдущей незавершенной транзакцией. Транзакции, изменяющие данные, не блокируют транзакции, в которых происходит чтение данных, а транзакции, считывающие данные, не блокируют транзакции, в которых происходит запись данных, что обычно также наблюдается при использовании уровня изоляции READ COMMITTED, заданного по умолчанию в SQL Server. Применение такого подхода, предусматривающего отказ от блокировок, способствует значительному снижению вероятности взаимоблокировок в сложных транзакциях.  
  
 В подходе с изоляцией моментального снимка используется модель оптимистического параллелизма. Если транзакция моментального снимка попытается зафиксировать изменения в данных, произошедшие после начала транзакции, то будет произведен откат транзакции и возникнет ошибка. Этого можно избежать, используя подсказки UPDLOCK для инструкций SELECT, которые обеспечивают доступ к измененным данным. Дополнительные сведения см. в разделе «Подсказки блокировок» электронной документации по SQL Server.  
  
 Перед использованием в транзакциях изоляция моментального снимка должна быть включена путем установки параметра базы данных ALLOW_SNAPSHOT_ISOLATION в значение ON. Это приводит к активизации механизма сохранения версий строк во временной базе данных (**tempdb**). Необходимо включить изоляцию моментального снимка в каждой использующей ее базе данных с помощью инструкции ALTER DATABASE языка Transact-SQL. В этом отношении изоляция моментального снимка отличается от традиционных уровней изоляции READ COMMITTED, REPEATABLE READ, SERIALIZABLE и READ UNCOMMITTED, которые не требуют настройки конфигурации. Следующие инструкции активируют изоляцию моментального снимка и заменяют поведение по умолчанию READ COMMITTED на SNAPSHOT:  
  
```sql  
ALTER DATABASE MyDatabase  
SET ALLOW_SNAPSHOT_ISOLATION ON  
  
ALTER DATABASE MyDatabase  
SET READ_COMMITTED_SNAPSHOT ON  
```  
  
 Установка параметра READ_COMMITTED_SNAPSHOT со значением ON обеспечивает доступ к версиям строк уровня изоляции по умолчанию READ COMMITTED. Если параметр READ_COMMITTED_SNAPSHOT установлен в значение OFF, то для получения доступа к версиям строк потребуется явно задавать уровень изоляции моментального снимка для каждого сеанса.  
  
## <a name="managing-concurrency-with-isolation-levels"></a>Управление параллелизмом с помощью уровней изоляции  
 Уровень изоляции, при котором выполняется инструкция Transact-SQL, определяет ее блокировку и поведение управления версиями строк. Уровень изоляции действует на уровне соединения и, будучи один раз заданным для соединения с помощью инструкции SET TRANSACTION ISOLATION LEVEL, остается в силе до закрытия соединения или установки другого уровня изоляции. После того как соединение закрывается и возвращается в пул, сохраняется уровень изоляции последней инструкции SET TRANSACTION ISOLATION LEVEL. В последующих соединениях, повторно использующих соединение из пула, применяется уровень изоляции, который был действителен в момент возврата соединения в пул.  
  
 Отдельные запросы, выполняемые внутри соединения, могут содержать подсказки блокировок, которые изменяют уровень изоляции для одной инструкции или транзакции, но не оказывают влияния на уровень изоляции соединения. Уровни изоляции или подсказки блокировок, установленные в хранимых процедурах или функциях, не изменяют уровень изоляции вызывающего их соединения и действительны только в течение их вызова.  
  
 В ранних версиях SQL Server поддерживались четыре уровня изоляции, определенные в стандарте SQL-92:  
  
- READ UNCOMMITTED является наименее строгим уровнем изоляции, поскольку при его использовании не учитываются блокировки, размещенные другими транзакциями. Транзакции, выполняемые в READ UNCOMMITTED, могут считывать измененные значения данных, которые еще не были зафиксированы другими транзакциями. Это называется чтением «грязных» данных.  
  
- READ COMMITTED является уровнем изоляции по умолчанию для SQL Server. Он запрещает чтение «грязных» данных путем задания условия, что инструкции не могут считывать измененные значения данных, которые еще не зафиксированы другими транзакциями. Другие транзакции все еще могут изменять, вставлять или удалять данные между выполнением отдельных инструкций внутри текущей транзакции, что приводит к выполнению операций чтения без возможности повторения или к получению «фантомных» данных.  
  
- REPEATABLE READ является более ограничительным уровнем изоляции, чем READ COMMITTED. Он включает в себя уровень изоляции READ COMMITTED и дополнительно указывает, что до завершения текущей транзакции ни одна прочая транзакция не может изменять или удалять данные, считанные текущей транзакцией. Параллелизм данного уровня изоляции ниже по сравнению с READ COMMITTED, поскольку совмещаемые блокировки при чтении данных сохраняются в течение транзакции, а не освобождаются после выполнения каждой инструкции.  
  
- SERIALIZABLE является самым строгим уровнем изоляции, поскольку при его использовании блокируются целые диапазоны ключей и блокировки сохраняются до завершения транзакции. Он включает в себя уровень изоляции REPEATABLE READ и добавляет ограничение, согласно которому до завершения транзакции другие транзакции не могут вставлять новые строки в диапазоны строк, чтение которых осуществляется в данной транзакции.  
  
 Дополнительные сведения см. [блокировки транзакций и руководство по управление версиями строк](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide).  
  
### <a name="snapshot-isolation-level-extensions"></a>Расширения уровня изоляции моментального снимка  
 SQL Server предоставляет расширения уровней изоляции стандарта SQL-92 путем представления уровня изоляции SNAPSHOT и дополнительных изменений в READ COMMITTED. Уровень изоляции READ_COMMITTED_SNAPSHOT может прозрачно заменять READ COMMITTED для всех транзакций.  
  
- Изоляция SNAPSHOT указывает, что данные, считанные внутри транзакции, никогда не отразят изменений, сделанных другими одновременными транзакциями. Транзакция использует версии строк данных, существующих при начале транзакции. При чтении данных на них не устанавливаются блокировки, иными словами, транзакции SNAPSHOT не блокируют операции записи данных, выполняемые другими транзакциями. Транзакции, осуществляющие запись данных, не блокируют чтение данных транзакциями моментального снимка. Для использования изоляции моментального снимка необходимо включить ее, установив параметр базы данных ALLOW_SNAPSHOT_ISOLATION.  
  
- Если изоляция моментального снимка включена в базе данных, то параметр базы данных READ_COMMITTED_SNAPSHOT определяет поведение уровня изоляции по умолчанию READ COMMITTED. Если параметр READ_COMMITTED_SNAPSHOT со значением ON не задан явно, то ко всем неявным транзакциям применяется уровень изоляции READ COMMITTED. Это аналогично организации работы, которая применяется при установке параметра READ_COMMITTED_SNAPSHOT со значением OFF (по умолчанию). Если действителен параметр READ_COMMITTED_SNAPSHOT со значением OFF, компонент Database Engine использует совмещаемые блокировки для принудительной установки уровня изоляции по умолчанию. Если параметр базы данных READ_COMMITTED_SNAPSHOT установлен в значение ON, компонент Database Engine использует управление версиями строк и изоляцию моментального снимка по умолчанию вместо применения блокировок для защиты данных.  
  
## <a name="how-snapshot-isolation-and-row-versioning-work"></a>Основные сведения о функционировании уровней изоляции моментального снимка и управлении версиями строк  
 Если уровень изоляции моментального СНИМКА включена, при каждом обновлении строки компонент SQL Server Database Engine сохраняет копию исходной строки в **tempdb**и добавляет порядковый номер транзакции в строку. Далее показана последовательность происходящих событий.  
  
- Инициируется новая транзакция, и ей присваивается порядковый номер.  
  
- Компонент Database Engine считывает строку внутри транзакции и получает версию строки из **tempdb** чей порядковый номер, ближайший к и ниже, чем порядковый номер транзакции.  
  
- При запуске транзакции моментального снимка компонент Database Engine проверяет, не находится ли порядковый номер транзакции в списке номеров активных незафиксированных транзакций.  
  
- Транзакция считывает версию строки из **tempdb** , была текущей на момент начала транзакции. Транзакция не обнаруживает новые строки, вставленные после ее запуска, поскольку эти строки имеют более высокие значения порядковых номеров по сравнению с порядковым номером транзакции.  
  
- Текущая транзакция будет см. в разделе строк, которые были удалены после начала транзакции, поскольку версия любой строки в **tempdb** с меньшее значение порядкового номера.  
  
 Суммарным эффектом изоляции моментального снимка является то, что транзакция обнаруживает все данные, существовавшие при ее запуске, без учета или установки каких-либо блокировок на базовых таблицах. Это может привести к повышению производительности в тех ситуациях, когда возникает конфликт.  
  
 В транзакции моментального снимка всегда используется оптимистическое управление параллелизмом, в котором предусматривается отказ от любых блокировок, запрещающих обновление строк другими транзакциями. Если транзакция моментального снимка попытается зафиксировать обновление строки, выполненное после запуска транзакции, будет произведен ее откат и возникнет ошибка.  
  
## <a name="working-with-snapshot-isolation-in-adonet"></a>Работа с изоляцией моментального снимка в ADO.NET  
 Изоляция моментального снимка поддерживается в ADO.NET с помощью класса <xref:System.Data.SqlClient.SqlTransaction>. Если база данных была включена для изоляции моментального снимка, но не настроен для READ_COMMITTED_SNAPSHOT со значением ON, необходимо инициировать <xref:System.Data.SqlClient.SqlTransaction> с помощью **IsolationLevel.Snapshot** значение перечисления, при вызове <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> метод. В данном фрагменте кода предполагается, что соединение представляет собой открытый объект <xref:System.Data.SqlClient.SqlConnection>.  
  
```vb  
Dim sqlTran As SqlTransaction = _  
  connection.BeginTransaction(IsolationLevel.Snapshot)  
```  
  
```csharp  
SqlTransaction sqlTran =   
  connection.BeginTransaction(IsolationLevel.Snapshot);  
```  
  
### <a name="example"></a>Пример  
 Следующий пример показывает, какие действия осуществляются при использовании различных уровней изоляции, если обнаруживается попытка получения доступа к заблокированным данным, и не предназначен для использования в коде производственного назначения.  
  
 Код подключается к **AdventureWorks** образца базы данных в SQL Server и создает таблицу с именем **TestSnapshot** и вставляет одну строку данных. В коде используется инструкция ALTER DATABASE языка Transact-SQL для включения изоляции моментального снимка базы данных, но не устанавливается параметр READ_COMMITTED_SNAPSHOT, поэтому остается в силе поведение уровня изоляции READ COMMITTED, применяемое по умолчанию. Затем в коде выполняются следующие действия.  
  
- В коде начинается, но не завершается транзакция sqlTransaction1, в которой используется уровень изоляции SERIALIZABLE для запуска транзакции обновления. Это приводит к блокировке таблицы.  
  
- Он открывается второе соединение и инициируется вторая транзакция с уровнем изоляции моментального СНИМКА для чтения данных в **TestSnapshot** таблицы. Поскольку изоляция моментального снимка включена, данная транзакция может считывать данные, существовавшие до запуска sqlTransaction1.  
  
- Код открывает третье соединение и инициирует транзакцию, используя уровень изоляции READ COMMITTED для осуществления попытки чтения данных из таблицы. В этом случае в коде исключается возможность считывать данные, поскольку чтение не может быть выполнено после установки блокировок на таблице в первой транзакции, поэтому код завершает свою работу в связи с истечением времени ожидания. Аналогичный результат был бы получен при использовании уровней изоляции REPEATABLE READ и SERIALIZABLE, поскольку эти уровни изоляции также не позволяют выполнять чтение после установки блокировок в первой транзакции.  
  
- Код открывает четвертое соединение и инициирует транзакцию, используя уровень изоляции READ UNCOMMITTED, который выполняет чтение незафиксированного значения в sqlTransaction1 как чтение «грязных» данных. Это значение может так и не появиться в базе данных, если первая транзакция не будет зафиксирована.  
  
- Он выполняет откат первой транзакции и чистка путем удаления **TestSnapshot** таблицы и выключения изоляции моментального снимка **AdventureWorks** базы данных.  
  
> [!NOTE]
>  В следующем примере используется аналогичная строка соединения с отключенным пулом соединений. Если соединение отправляется в пул, сброс его уровня изоляции не приводит к сбросу уровня изоляции на сервере. В результате последующие соединения, в которых используется то же помещенное в пул внутреннее соединение, запускаются с уровнем изоляции, заданным равным уровню изоляции этого соединения. Альтернативным вариантом по отношению к выключению пула соединений является явное задание уровня изоляции для каждого соединения.  
  
 [!code-csharp[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/VB/source.vb#1)]  
  
### <a name="example"></a>Пример  
 Следующий пример демонстрирует поведение изоляции моментального снимка при изменении данных. Код выполняет следующие действия.  
  
- Подключается к **AdventureWorks** образец базы данных и включение изоляции моментального СНИМКА.  
  
- Создает таблицу с именем **TestSnapshotUpdate** и вставляет три строки образца данных.  
  
- Начинает, но не завершает транзакцию sqlTransaction1 с использованием уровня изоляции SNAPSHOT. В транзакции выбираются три строки данных.  
  
- Создает второй **SqlConnection** для **AdventureWorks** и создает вторую транзакцию, используя уровень изоляции READ COMMITTED, который обновляет значение в одной из строк, выбранных в sqlTransaction1.  
  
- Фиксирует транзакцию sqlTransaction2.  
  
- Возвращается к транзакции sqlTransaction1 и выполняет попытку обновления той строки, которую sqlTransaction1 уже зафиксировала. Возникает ошибка 3960, и откат транзакции sqlTransaction1 производится автоматически. **SqlException.Number** и **SqlException.Message** отображаются в окне консоли.  
  
- Выполняет код очистки для выключения изоляции моментального снимка в **AdventureWorks** и удалить **TestSnapshotUpdate** таблицы.  
  
 [!code-csharp[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/VB/source.vb#1)]  
  
### <a name="using-lock-hints-with-snapshot-isolation"></a>Использование подсказок блокировок с изоляцией моментального снимка  
 В предыдущем примере первая транзакция выбирает данные, а вторая их обновляет до завершения первой, что вызывает конфликт обновления, когда первая транзакция пытается обновить ту же строку. Вероятность возникновения конфликтов обновления в продолжительных транзакциях моментального снимка можно снизить, задавая подсказки блокировок при запуске транзакции. Следующая инструкция SELECT использует подсказку UPDLOCK для блокировки выбранных строк:  
  
```sql  
SELECT * FROM TestSnapshotUpdate WITH (UPDLOCK)   
  WHERE PriKey BETWEEN 1 AND 3  
```  
  
 Использование подсказки блокировки UPDLOCK приводит к блокировке любых строк при попытке обновить эти строки до завершения первой транзакции. Это гарантирует, что в выбранных строках не будет конфликтов при их будущих обновлениях в транзакции. См. раздел «Подсказки блокировок» электронной документации по SQL Server.  
  
 Если приложение содержит множество конфликтов, то для него изоляция моментального снимка не лучший выбор. Подсказки должны использоваться, только если они действительно нужны. Приложение должно быть создано таким образом, чтобы в ходе его работы не нужно было постоянно полагаться на подсказки блокировок.  
  
## <a name="see-also"></a>См. также

- [SQL Server и ADO.NET](../../../../../docs/framework/data/adonet/sql/index.md)
- [Центр разработчиков наборов данных и управляемых поставщиков ADO.NET](https://go.microsoft.com/fwlink/?LinkId=217917)
- [Руководство по управление версиями строк и блокировке транзакций](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)
