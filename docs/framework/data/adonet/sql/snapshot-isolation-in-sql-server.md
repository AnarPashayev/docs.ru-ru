---
title: Изоляция снимков в SQL Server
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 43ae5dd3-50f5-43a8-8d01-e37a61664176
ms.openlocfilehash: c06ecd8626b148c4f2143efdfa1e143d6ab3d6bc
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61876360"
---
# <a name="snapshot-isolation-in-sql-server"></a><span data-ttu-id="2aad3-102">Изоляция снимков в SQL Server</span><span class="sxs-lookup"><span data-stu-id="2aad3-102">Snapshot Isolation in SQL Server</span></span>
<span data-ttu-id="2aad3-103">Изоляция моментального снимка приводит к повышению параллелизма для приложений OLTP.</span><span class="sxs-lookup"><span data-stu-id="2aad3-103">Snapshot isolation enhances concurrency for OLTP applications.</span></span>  
  
## <a name="understanding-snapshot-isolation-and-row-versioning"></a><span data-ttu-id="2aad3-104">Основные сведения об изоляции моментального снимка и управлении версиями строк</span><span class="sxs-lookup"><span data-stu-id="2aad3-104">Understanding Snapshot Isolation and Row Versioning</span></span>  
 <span data-ttu-id="2aad3-105">После включения изоляции моментального снимка обновленные версии строк для каждой транзакции сохраняются в **tempdb**.</span><span class="sxs-lookup"><span data-stu-id="2aad3-105">Once snapshot isolation is enabled, updated row versions for each transaction are maintained in **tempdb**.</span></span> <span data-ttu-id="2aad3-106">Уникальный порядковый номер транзакции определяет каждую транзакцию, и эти уникальные номера записываются для каждой версии строки.</span><span class="sxs-lookup"><span data-stu-id="2aad3-106">A unique transaction sequence number identifies each transaction, and these unique numbers are recorded for each row version.</span></span> <span data-ttu-id="2aad3-107">Транзакция работает с последними версиями строк, имеющими порядковый номер, предшествующий порядковому номеру транзакции.</span><span class="sxs-lookup"><span data-stu-id="2aad3-107">The transaction works with the most recent row versions having a sequence number before the sequence number of the transaction.</span></span> <span data-ttu-id="2aad3-108">Более новые версии строк, созданные после начала транзакции, не учитываются.</span><span class="sxs-lookup"><span data-stu-id="2aad3-108">Newer row versions created after the transaction has begun are ignored by the transaction.</span></span>  
  
 <span data-ttu-id="2aad3-109">Термин «моментальный снимок» отражает тот факт, что все запросы в транзакции обнаруживают одинаковую версию, или моментальный снимок базы данных, который соответствует состоянию базы данных в момент начала транзакции.</span><span class="sxs-lookup"><span data-stu-id="2aad3-109">The term "snapshot" reflects the fact that all queries in the transaction see the same version, or snapshot, of the database, based on the state of the database at the moment in time when the transaction begins.</span></span> <span data-ttu-id="2aad3-110">Транзакция моментального снимка не требует блокировок базовых строк или страниц данных, что позволяет выполнять другую транзакцию без ее блокировки предыдущей незавершенной транзакцией.</span><span class="sxs-lookup"><span data-stu-id="2aad3-110">No locks are acquired on the underlying data rows or data pages in a snapshot transaction, which permits other transactions to execute without being blocked by a prior uncompleted transaction.</span></span> <span data-ttu-id="2aad3-111">Транзакции, изменяющие данные, не блокируют транзакции, в которых происходит чтение данных, а транзакции, считывающие данные, не блокируют транзакции, в которых происходит запись данных, что обычно также наблюдается при использовании уровня изоляции READ COMMITTED, заданного по умолчанию в SQL Server.</span><span class="sxs-lookup"><span data-stu-id="2aad3-111">Transactions that modify data do not block transactions that read data, and transactions that read data do not block transactions that write data, as they normally would under the default READ COMMITTED isolation level in SQL Server.</span></span> <span data-ttu-id="2aad3-112">Применение такого подхода, предусматривающего отказ от блокировок, способствует значительному снижению вероятности взаимоблокировок в сложных транзакциях.</span><span class="sxs-lookup"><span data-stu-id="2aad3-112">This non-blocking behavior also significantly reduces the likelihood of deadlocks for complex transactions.</span></span>  
  
 <span data-ttu-id="2aad3-113">В подходе с изоляцией моментального снимка используется модель оптимистического параллелизма.</span><span class="sxs-lookup"><span data-stu-id="2aad3-113">Snapshot isolation uses an optimistic concurrency model.</span></span> <span data-ttu-id="2aad3-114">Если транзакция моментального снимка попытается зафиксировать изменения в данных, произошедшие после начала транзакции, то будет произведен откат транзакции и возникнет ошибка.</span><span class="sxs-lookup"><span data-stu-id="2aad3-114">If a snapshot transaction attempts to commit modifications to data that has changed since the transaction began, the transaction will roll back and an error will be raised.</span></span> <span data-ttu-id="2aad3-115">Этого можно избежать, используя подсказки UPDLOCK для инструкций SELECT, которые обеспечивают доступ к измененным данным.</span><span class="sxs-lookup"><span data-stu-id="2aad3-115">You can avoid this by using UPDLOCK hints for SELECT statements that access data to be modified.</span></span> <span data-ttu-id="2aad3-116">Дополнительные сведения см. в разделе «Подсказки блокировок» электронной документации по SQL Server.</span><span class="sxs-lookup"><span data-stu-id="2aad3-116">See "Locking Hints" in SQL Server Books Online for more information.</span></span>  
  
 <span data-ttu-id="2aad3-117">Перед использованием в транзакциях изоляция моментального снимка должна быть включена путем установки параметра базы данных ALLOW_SNAPSHOT_ISOLATION в значение ON.</span><span class="sxs-lookup"><span data-stu-id="2aad3-117">Snapshot isolation must be enabled by setting the ALLOW_SNAPSHOT_ISOLATION ON database option before it is used in transactions.</span></span> <span data-ttu-id="2aad3-118">Это приводит к активизации механизма сохранения версий строк во временной базе данных (**tempdb**).</span><span class="sxs-lookup"><span data-stu-id="2aad3-118">This activates the mechanism for storing row versions in the temporary database (**tempdb**).</span></span> <span data-ttu-id="2aad3-119">Необходимо включить изоляцию моментального снимка в каждой использующей ее базе данных с помощью инструкции ALTER DATABASE языка Transact-SQL.</span><span class="sxs-lookup"><span data-stu-id="2aad3-119">You must enable snapshot isolation in each database that uses it with the Transact-SQL ALTER DATABASE statement.</span></span> <span data-ttu-id="2aad3-120">В этом отношении изоляция моментального снимка отличается от традиционных уровней изоляции READ COMMITTED, REPEATABLE READ, SERIALIZABLE и READ UNCOMMITTED, которые не требуют настройки конфигурации.</span><span class="sxs-lookup"><span data-stu-id="2aad3-120">In this respect, snapshot isolation differs from the traditional isolation levels of READ COMMITTED, REPEATABLE READ, SERIALIZABLE, and READ UNCOMMITTED, which require no configuration.</span></span> <span data-ttu-id="2aad3-121">Следующие инструкции активируют изоляцию моментального снимка и заменяют поведение по умолчанию READ COMMITTED на SNAPSHOT:</span><span class="sxs-lookup"><span data-stu-id="2aad3-121">The following statements activate snapshot isolation and replace the default READ COMMITTED behavior with SNAPSHOT:</span></span>  
  
```sql  
ALTER DATABASE MyDatabase  
SET ALLOW_SNAPSHOT_ISOLATION ON  
  
ALTER DATABASE MyDatabase  
SET READ_COMMITTED_SNAPSHOT ON  
```  
  
 <span data-ttu-id="2aad3-122">Установка параметра READ_COMMITTED_SNAPSHOT со значением ON обеспечивает доступ к версиям строк уровня изоляции по умолчанию READ COMMITTED.</span><span class="sxs-lookup"><span data-stu-id="2aad3-122">Setting the READ_COMMITTED_SNAPSHOT ON option allows access to versioned rows under the default READ COMMITTED isolation level.</span></span> <span data-ttu-id="2aad3-123">Если параметр READ_COMMITTED_SNAPSHOT установлен в значение OFF, то для получения доступа к версиям строк потребуется явно задавать уровень изоляции моментального снимка для каждого сеанса.</span><span class="sxs-lookup"><span data-stu-id="2aad3-123">If the READ_COMMITTED_SNAPSHOT option is set to OFF, you must explicitly set the Snapshot isolation level for each session in order to access versioned rows.</span></span>  
  
## <a name="managing-concurrency-with-isolation-levels"></a><span data-ttu-id="2aad3-124">Управление параллелизмом с помощью уровней изоляции</span><span class="sxs-lookup"><span data-stu-id="2aad3-124">Managing Concurrency with Isolation Levels</span></span>  
 <span data-ttu-id="2aad3-125">Уровень изоляции, при котором выполняется инструкция Transact-SQL, определяет ее блокировку и поведение управления версиями строк.</span><span class="sxs-lookup"><span data-stu-id="2aad3-125">The isolation level under which a Transact-SQL statement executes determines its locking and row versioning behavior.</span></span> <span data-ttu-id="2aad3-126">Уровень изоляции действует на уровне соединения и, будучи один раз заданным для соединения с помощью инструкции SET TRANSACTION ISOLATION LEVEL, остается в силе до закрытия соединения или установки другого уровня изоляции.</span><span class="sxs-lookup"><span data-stu-id="2aad3-126">An isolation level has connection-wide scope, and once set for a connection with the SET TRANSACTION ISOLATION LEVEL statement, it remains in effect until the connection is closed or another isolation level is set.</span></span> <span data-ttu-id="2aad3-127">После того как соединение закрывается и возвращается в пул, сохраняется уровень изоляции последней инструкции SET TRANSACTION ISOLATION LEVEL.</span><span class="sxs-lookup"><span data-stu-id="2aad3-127">When a connection is closed and returned to the pool, the isolation level from the last SET TRANSACTION ISOLATION LEVEL statement is retained.</span></span> <span data-ttu-id="2aad3-128">В последующих соединениях, повторно использующих соединение из пула, применяется уровень изоляции, который был действителен в момент возврата соединения в пул.</span><span class="sxs-lookup"><span data-stu-id="2aad3-128">Subsequent connections reusing a pooled connection use the isolation level that was in effect at the time the connection is pooled.</span></span>  
  
 <span data-ttu-id="2aad3-129">Отдельные запросы, выполняемые внутри соединения, могут содержать подсказки блокировок, которые изменяют уровень изоляции для одной инструкции или транзакции, но не оказывают влияния на уровень изоляции соединения.</span><span class="sxs-lookup"><span data-stu-id="2aad3-129">Individual queries issued within a connection can contain lock hints that modify the isolation for a single statement or transaction but do not affect the isolation level of the connection.</span></span> <span data-ttu-id="2aad3-130">Уровни изоляции или подсказки блокировок, установленные в хранимых процедурах или функциях, не изменяют уровень изоляции вызывающего их соединения и действительны только в течение их вызова.</span><span class="sxs-lookup"><span data-stu-id="2aad3-130">Isolation levels or lock hints set in stored procedures or functions do not change the isolation level of the connection that calls them and are in effect only for the duration of the stored procedure or function call.</span></span>  
  
 <span data-ttu-id="2aad3-131">В ранних версиях SQL Server поддерживались четыре уровня изоляции, определенные в стандарте SQL-92:</span><span class="sxs-lookup"><span data-stu-id="2aad3-131">Four isolation levels defined in the SQL-92 standard were supported in early versions of SQL Server:</span></span>  
  
- <span data-ttu-id="2aad3-132">READ UNCOMMITTED является наименее строгим уровнем изоляции, поскольку при его использовании не учитываются блокировки, размещенные другими транзакциями.</span><span class="sxs-lookup"><span data-stu-id="2aad3-132">READ UNCOMMITTED is the least restrictive isolation level because it ignores locks placed by other transactions.</span></span> <span data-ttu-id="2aad3-133">Транзакции, выполняемые в READ UNCOMMITTED, могут считывать измененные значения данных, которые еще не были зафиксированы другими транзакциями. Это называется чтением «грязных» данных.</span><span class="sxs-lookup"><span data-stu-id="2aad3-133">Transactions executing under READ UNCOMMITTED can read modified data values that have not yet been committed by other transactions; these are called "dirty" reads.</span></span>  
  
- <span data-ttu-id="2aad3-134">READ COMMITTED является уровнем изоляции по умолчанию для SQL Server.</span><span class="sxs-lookup"><span data-stu-id="2aad3-134">READ COMMITTED is the default isolation level for SQL Server.</span></span> <span data-ttu-id="2aad3-135">Он запрещает чтение «грязных» данных путем задания условия, что инструкции не могут считывать измененные значения данных, которые еще не зафиксированы другими транзакциями.</span><span class="sxs-lookup"><span data-stu-id="2aad3-135">It prevents dirty reads by specifying that statements cannot read data values that have been modified but not yet committed by other transactions.</span></span> <span data-ttu-id="2aad3-136">Другие транзакции все еще могут изменять, вставлять или удалять данные между выполнением отдельных инструкций внутри текущей транзакции, что приводит к выполнению операций чтения без возможности повторения или к получению «фантомных» данных.</span><span class="sxs-lookup"><span data-stu-id="2aad3-136">Other transactions can still modify, insert, or delete data between executions of individual statements within the current transaction, resulting in non-repeatable reads, or "phantom" data.</span></span>  
  
- <span data-ttu-id="2aad3-137">REPEATABLE READ является более ограничительным уровнем изоляции, чем READ COMMITTED.</span><span class="sxs-lookup"><span data-stu-id="2aad3-137">REPEATABLE READ is a more restrictive isolation level than READ COMMITTED.</span></span> <span data-ttu-id="2aad3-138">Он включает в себя уровень изоляции READ COMMITTED и дополнительно указывает, что до завершения текущей транзакции ни одна прочая транзакция не может изменять или удалять данные, считанные текущей транзакцией.</span><span class="sxs-lookup"><span data-stu-id="2aad3-138">It encompasses READ COMMITTED and additionally specifies that no other transactions can modify or delete data that has been read by the current transaction until the current transaction commits.</span></span> <span data-ttu-id="2aad3-139">Параллелизм данного уровня изоляции ниже по сравнению с READ COMMITTED, поскольку совмещаемые блокировки при чтении данных сохраняются в течение транзакции, а не освобождаются после выполнения каждой инструкции.</span><span class="sxs-lookup"><span data-stu-id="2aad3-139">Concurrency is lower than for READ COMMITTED because shared locks on read data are held for the duration of the transaction instead of being released at the end of each statement.</span></span>  
  
- <span data-ttu-id="2aad3-140">SERIALIZABLE является самым строгим уровнем изоляции, поскольку при его использовании блокируются целые диапазоны ключей и блокировки сохраняются до завершения транзакции.</span><span class="sxs-lookup"><span data-stu-id="2aad3-140">SERIALIZABLE is the most restrictive isolation level, because it locks entire ranges of keys and holds the locks until the transaction is complete.</span></span> <span data-ttu-id="2aad3-141">Он включает в себя уровень изоляции REPEATABLE READ и добавляет ограничение, согласно которому до завершения транзакции другие транзакции не могут вставлять новые строки в диапазоны строк, чтение которых осуществляется в данной транзакции.</span><span class="sxs-lookup"><span data-stu-id="2aad3-141">It encompasses REPEATABLE READ and adds the restriction that other transactions cannot insert new rows into ranges that have been read by the transaction until the transaction is complete.</span></span>  
  
 <span data-ttu-id="2aad3-142">Дополнительные сведения см. [блокировки транзакций и руководство по управление версиями строк](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide).</span><span class="sxs-lookup"><span data-stu-id="2aad3-142">For more information, refer to the [Transaction Locking and Row Versioning Guide](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide).</span></span>  
  
### <a name="snapshot-isolation-level-extensions"></a><span data-ttu-id="2aad3-143">Расширения уровня изоляции моментального снимка</span><span class="sxs-lookup"><span data-stu-id="2aad3-143">Snapshot Isolation Level Extensions</span></span>  
 <span data-ttu-id="2aad3-144">SQL Server предоставляет расширения уровней изоляции стандарта SQL-92 путем представления уровня изоляции SNAPSHOT и дополнительных изменений в READ COMMITTED.</span><span class="sxs-lookup"><span data-stu-id="2aad3-144">SQL Server introduced extensions to the SQL-92 isolation levels with the introduction of the SNAPSHOT isolation level and an additional implementation of READ COMMITTED.</span></span> <span data-ttu-id="2aad3-145">Уровень изоляции READ_COMMITTED_SNAPSHOT может прозрачно заменять READ COMMITTED для всех транзакций.</span><span class="sxs-lookup"><span data-stu-id="2aad3-145">The READ_COMMITTED_SNAPSHOT isolation level can transparently replace READ COMMITTED for all transactions.</span></span>  
  
- <span data-ttu-id="2aad3-146">Изоляция SNAPSHOT указывает, что данные, считанные внутри транзакции, никогда не отразят изменений, сделанных другими одновременными транзакциями.</span><span class="sxs-lookup"><span data-stu-id="2aad3-146">SNAPSHOT isolation specifies that data read within a transaction will never reflect changes made by other simultaneous transactions.</span></span> <span data-ttu-id="2aad3-147">Транзакция использует версии строк данных, существующих при начале транзакции.</span><span class="sxs-lookup"><span data-stu-id="2aad3-147">The transaction uses the data row versions that exist when the transaction begins.</span></span> <span data-ttu-id="2aad3-148">При чтении данных на них не устанавливаются блокировки, иными словами, транзакции SNAPSHOT не блокируют операции записи данных, выполняемые другими транзакциями.</span><span class="sxs-lookup"><span data-stu-id="2aad3-148">No locks are placed on the data when it is read, so SNAPSHOT transactions do not block other transactions from writing data.</span></span> <span data-ttu-id="2aad3-149">Транзакции, осуществляющие запись данных, не блокируют чтение данных транзакциями моментального снимка.</span><span class="sxs-lookup"><span data-stu-id="2aad3-149">Transactions that write data do not block snapshot transactions from reading data.</span></span> <span data-ttu-id="2aad3-150">Для использования изоляции моментального снимка необходимо включить ее, установив параметр базы данных ALLOW_SNAPSHOT_ISOLATION.</span><span class="sxs-lookup"><span data-stu-id="2aad3-150">You need to enable snapshot isolation by setting the ALLOW_SNAPSHOT_ISOLATION database option in order to use it.</span></span>  
  
- <span data-ttu-id="2aad3-151">Если изоляция моментального снимка включена в базе данных, то параметр базы данных READ_COMMITTED_SNAPSHOT определяет поведение уровня изоляции по умолчанию READ COMMITTED.</span><span class="sxs-lookup"><span data-stu-id="2aad3-151">The READ_COMMITTED_SNAPSHOT database option determines the behavior of the default READ COMMITTED isolation level when snapshot isolation is enabled in a database.</span></span> <span data-ttu-id="2aad3-152">Если параметр READ_COMMITTED_SNAPSHOT со значением ON не задан явно, то ко всем неявным транзакциям применяется уровень изоляции READ COMMITTED.</span><span class="sxs-lookup"><span data-stu-id="2aad3-152">If you do not explicitly specify READ_COMMITTED_SNAPSHOT ON, READ COMMITTED is applied to all implicit transactions.</span></span> <span data-ttu-id="2aad3-153">Это аналогично организации работы, которая применяется при установке параметра READ_COMMITTED_SNAPSHOT со значением OFF (по умолчанию).</span><span class="sxs-lookup"><span data-stu-id="2aad3-153">This produces the same behavior as setting READ_COMMITTED_SNAPSHOT OFF (the default).</span></span> <span data-ttu-id="2aad3-154">Если действителен параметр READ_COMMITTED_SNAPSHOT со значением OFF, компонент Database Engine использует совмещаемые блокировки для принудительной установки уровня изоляции по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="2aad3-154">When READ_COMMITTED_SNAPSHOT OFF is in effect, the Database Engine uses shared locks to enforce the default isolation level.</span></span> <span data-ttu-id="2aad3-155">Если параметр базы данных READ_COMMITTED_SNAPSHOT установлен в значение ON, компонент Database Engine использует управление версиями строк и изоляцию моментального снимка по умолчанию вместо применения блокировок для защиты данных.</span><span class="sxs-lookup"><span data-stu-id="2aad3-155">If you set the READ_COMMITTED_SNAPSHOT database option to ON, the database engine uses row versioning and snapshot isolation as the default, instead of using locks to protect the data.</span></span>  
  
## <a name="how-snapshot-isolation-and-row-versioning-work"></a><span data-ttu-id="2aad3-156">Основные сведения о функционировании уровней изоляции моментального снимка и управлении версиями строк</span><span class="sxs-lookup"><span data-stu-id="2aad3-156">How Snapshot Isolation and Row Versioning Work</span></span>  
 <span data-ttu-id="2aad3-157">Если уровень изоляции моментального СНИМКА включена, при каждом обновлении строки компонент SQL Server Database Engine сохраняет копию исходной строки в **tempdb**и добавляет порядковый номер транзакции в строку.</span><span class="sxs-lookup"><span data-stu-id="2aad3-157">When the SNAPSHOT isolation level is enabled, each time a row is updated, the SQL Server Database Engine stores a copy of the original row in **tempdb**, and adds a transaction sequence number to the row.</span></span> <span data-ttu-id="2aad3-158">Далее показана последовательность происходящих событий.</span><span class="sxs-lookup"><span data-stu-id="2aad3-158">The following is the sequence of events that occurs:</span></span>  
  
- <span data-ttu-id="2aad3-159">Инициируется новая транзакция, и ей присваивается порядковый номер.</span><span class="sxs-lookup"><span data-stu-id="2aad3-159">A new transaction is initiated, and it is assigned a transaction sequence number.</span></span>  
  
- <span data-ttu-id="2aad3-160">Компонент Database Engine считывает строку внутри транзакции и получает версию строки из **tempdb** чей порядковый номер, ближайший к и ниже, чем порядковый номер транзакции.</span><span class="sxs-lookup"><span data-stu-id="2aad3-160">The Database Engine reads a row within the transaction and retrieves the row version from **tempdb** whose sequence number is closest to, and lower than, the transaction sequence number.</span></span>  
  
- <span data-ttu-id="2aad3-161">При запуске транзакции моментального снимка компонент Database Engine проверяет, не находится ли порядковый номер транзакции в списке номеров активных незафиксированных транзакций.</span><span class="sxs-lookup"><span data-stu-id="2aad3-161">The Database Engine checks to see if the transaction sequence number is not in the list of transaction sequence numbers of the uncommitted transactions active when the snapshot transaction started.</span></span>  
  
- <span data-ttu-id="2aad3-162">Транзакция считывает версию строки из **tempdb** , была текущей на момент начала транзакции.</span><span class="sxs-lookup"><span data-stu-id="2aad3-162">The transaction reads the version of the row from **tempdb** that was current as of the start of the transaction.</span></span> <span data-ttu-id="2aad3-163">Транзакция не обнаруживает новые строки, вставленные после ее запуска, поскольку эти строки имеют более высокие значения порядковых номеров по сравнению с порядковым номером транзакции.</span><span class="sxs-lookup"><span data-stu-id="2aad3-163">It will not see new rows inserted after the transaction was started because those sequence number values will be higher than the value of the transaction sequence number.</span></span>  
  
- <span data-ttu-id="2aad3-164">Текущая транзакция будет см. в разделе строк, которые были удалены после начала транзакции, поскольку версия любой строки в **tempdb** с меньшее значение порядкового номера.</span><span class="sxs-lookup"><span data-stu-id="2aad3-164">The current transaction will see rows that were deleted after the transaction began, because there will be a row version in **tempdb** with a lower sequence number value.</span></span>  
  
 <span data-ttu-id="2aad3-165">Суммарным эффектом изоляции моментального снимка является то, что транзакция обнаруживает все данные, существовавшие при ее запуске, без учета или установки каких-либо блокировок на базовых таблицах.</span><span class="sxs-lookup"><span data-stu-id="2aad3-165">The net effect of snapshot isolation is that the transaction sees all of the data as it existed at the start of the transaction, without honoring or placing any locks on the underlying tables.</span></span> <span data-ttu-id="2aad3-166">Это может привести к повышению производительности в тех ситуациях, когда возникает конфликт.</span><span class="sxs-lookup"><span data-stu-id="2aad3-166">This can result in performance improvements in situations where there is contention.</span></span>  
  
 <span data-ttu-id="2aad3-167">В транзакции моментального снимка всегда используется оптимистическое управление параллелизмом, в котором предусматривается отказ от любых блокировок, запрещающих обновление строк другими транзакциями.</span><span class="sxs-lookup"><span data-stu-id="2aad3-167">A snapshot transaction always uses optimistic concurrency control, withholding any locks that would prevent other transactions from updating rows.</span></span> <span data-ttu-id="2aad3-168">Если транзакция моментального снимка попытается зафиксировать обновление строки, выполненное после запуска транзакции, будет произведен ее откат и возникнет ошибка.</span><span class="sxs-lookup"><span data-stu-id="2aad3-168">If a snapshot transaction attempts to commit an update to a row that was changed after the transaction began, the transaction is rolled back, and an error is raised.</span></span>  
  
## <a name="working-with-snapshot-isolation-in-adonet"></a><span data-ttu-id="2aad3-169">Работа с изоляцией моментального снимка в ADO.NET</span><span class="sxs-lookup"><span data-stu-id="2aad3-169">Working with Snapshot Isolation in ADO.NET</span></span>  
 <span data-ttu-id="2aad3-170">Изоляция моментального снимка поддерживается в ADO.NET с помощью класса <xref:System.Data.SqlClient.SqlTransaction>.</span><span class="sxs-lookup"><span data-stu-id="2aad3-170">Snapshot isolation is supported in ADO.NET by the <xref:System.Data.SqlClient.SqlTransaction> class.</span></span> <span data-ttu-id="2aad3-171">Если база данных была включена для изоляции моментального снимка, но не настроен для READ_COMMITTED_SNAPSHOT со значением ON, необходимо инициировать <xref:System.Data.SqlClient.SqlTransaction> с помощью **IsolationLevel.Snapshot** значение перечисления, при вызове <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="2aad3-171">If a database has been enabled for snapshot isolation but is not configured for READ_COMMITTED_SNAPSHOT ON, you must initiate a <xref:System.Data.SqlClient.SqlTransaction> using the **IsolationLevel.Snapshot** enumeration value when calling the <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> method.</span></span> <span data-ttu-id="2aad3-172">В данном фрагменте кода предполагается, что соединение представляет собой открытый объект <xref:System.Data.SqlClient.SqlConnection>.</span><span class="sxs-lookup"><span data-stu-id="2aad3-172">This code fragment assumes that connection is an open <xref:System.Data.SqlClient.SqlConnection> object.</span></span>  
  
```vb  
Dim sqlTran As SqlTransaction = _  
  connection.BeginTransaction(IsolationLevel.Snapshot)  
```  
  
```csharp  
SqlTransaction sqlTran =   
  connection.BeginTransaction(IsolationLevel.Snapshot);  
```  
  
### <a name="example"></a><span data-ttu-id="2aad3-173">Пример</span><span class="sxs-lookup"><span data-stu-id="2aad3-173">Example</span></span>  
 <span data-ttu-id="2aad3-174">Следующий пример показывает, какие действия осуществляются при использовании различных уровней изоляции, если обнаруживается попытка получения доступа к заблокированным данным, и не предназначен для использования в коде производственного назначения.</span><span class="sxs-lookup"><span data-stu-id="2aad3-174">The following example demonstrates how the different isolation levels behave by attempting to access locked data, and it is not intended to be used in production code.</span></span>  
  
 <span data-ttu-id="2aad3-175">Код подключается к **AdventureWorks** образца базы данных в SQL Server и создает таблицу с именем **TestSnapshot** и вставляет одну строку данных.</span><span class="sxs-lookup"><span data-stu-id="2aad3-175">The code connects to the **AdventureWorks** sample database in SQL Server and creates a table named **TestSnapshot** and inserts one row of data.</span></span> <span data-ttu-id="2aad3-176">В коде используется инструкция ALTER DATABASE языка Transact-SQL для включения изоляции моментального снимка базы данных, но не устанавливается параметр READ_COMMITTED_SNAPSHOT, поэтому остается в силе поведение уровня изоляции READ COMMITTED, применяемое по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="2aad3-176">The code uses the ALTER DATABASE Transact-SQL statement to turn on snapshot isolation for the database, but it does not set the READ_COMMITTED_SNAPSHOT option, leaving the default READ COMMITTED isolation-level behavior in effect.</span></span> <span data-ttu-id="2aad3-177">Затем в коде выполняются следующие действия.</span><span class="sxs-lookup"><span data-stu-id="2aad3-177">The code then performs the following actions:</span></span>  
  
- <span data-ttu-id="2aad3-178">В коде начинается, но не завершается транзакция sqlTransaction1, в которой используется уровень изоляции SERIALIZABLE для запуска транзакции обновления.</span><span class="sxs-lookup"><span data-stu-id="2aad3-178">It begins, but does not complete, sqlTransaction1, which uses the SERIALIZABLE isolation level to start an update transaction.</span></span> <span data-ttu-id="2aad3-179">Это приводит к блокировке таблицы.</span><span class="sxs-lookup"><span data-stu-id="2aad3-179">This has the effect of locking the table.</span></span>  
  
- <span data-ttu-id="2aad3-180">Он открывается второе соединение и инициируется вторая транзакция с уровнем изоляции моментального СНИМКА для чтения данных в **TestSnapshot** таблицы.</span><span class="sxs-lookup"><span data-stu-id="2aad3-180">It opens a second connection and initiates a second transaction using the SNAPSHOT isolation level to read the data in the **TestSnapshot** table.</span></span> <span data-ttu-id="2aad3-181">Поскольку изоляция моментального снимка включена, данная транзакция может считывать данные, существовавшие до запуска sqlTransaction1.</span><span class="sxs-lookup"><span data-stu-id="2aad3-181">Because snapshot isolation is enabled, this transaction can read the data that existed before sqlTransaction1 started.</span></span>  
  
- <span data-ttu-id="2aad3-182">Код открывает третье соединение и инициирует транзакцию, используя уровень изоляции READ COMMITTED для осуществления попытки чтения данных из таблицы.</span><span class="sxs-lookup"><span data-stu-id="2aad3-182">It opens a third connection and initiates a transaction using the READ COMMITTED isolation level to attempt to read the data in the table.</span></span> <span data-ttu-id="2aad3-183">В этом случае в коде исключается возможность считывать данные, поскольку чтение не может быть выполнено после установки блокировок на таблице в первой транзакции, поэтому код завершает свою работу в связи с истечением времени ожидания. Аналогичный результат был бы получен при использовании уровней изоляции REPEATABLE READ и SERIALIZABLE, поскольку эти уровни изоляции также не позволяют выполнять чтение после установки блокировок в первой транзакции.</span><span class="sxs-lookup"><span data-stu-id="2aad3-183">In this case, the code cannot read the data because it cannot read past the locks placed on the table in the first transaction and times out. The same result would occur if the REPEATABLE READ and SERIALIZABLE isolation levels were used because these isolation levels also cannot read past the locks placed in the first transaction.</span></span>  
  
- <span data-ttu-id="2aad3-184">Код открывает четвертое соединение и инициирует транзакцию, используя уровень изоляции READ UNCOMMITTED, который выполняет чтение незафиксированного значения в sqlTransaction1 как чтение «грязных» данных.</span><span class="sxs-lookup"><span data-stu-id="2aad3-184">It opens a fourth connection and initiates a transaction using the READ UNCOMMITTED isolation level, which performs a dirty read of the uncommitted value in sqlTransaction1.</span></span> <span data-ttu-id="2aad3-185">Это значение может так и не появиться в базе данных, если первая транзакция не будет зафиксирована.</span><span class="sxs-lookup"><span data-stu-id="2aad3-185">This value may never actually exist in the database if the first transaction is not committed.</span></span>  
  
- <span data-ttu-id="2aad3-186">Он выполняет откат первой транзакции и чистка путем удаления **TestSnapshot** таблицы и выключения изоляции моментального снимка **AdventureWorks** базы данных.</span><span class="sxs-lookup"><span data-stu-id="2aad3-186">It rolls back the first transaction and cleans up by deleting the **TestSnapshot** table and turning off snapshot isolation for the **AdventureWorks** database.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2aad3-187">В следующем примере используется аналогичная строка соединения с отключенным пулом соединений.</span><span class="sxs-lookup"><span data-stu-id="2aad3-187">The following examples use the same connection string with connection pooling turned off.</span></span> <span data-ttu-id="2aad3-188">Если соединение отправляется в пул, сброс его уровня изоляции не приводит к сбросу уровня изоляции на сервере.</span><span class="sxs-lookup"><span data-stu-id="2aad3-188">If a connection is pooled, resetting its isolation level does not reset the isolation level at the server.</span></span> <span data-ttu-id="2aad3-189">В результате последующие соединения, в которых используется то же помещенное в пул внутреннее соединение, запускаются с уровнем изоляции, заданным равным уровню изоляции этого соединения.</span><span class="sxs-lookup"><span data-stu-id="2aad3-189">As a result, subsequent connections that use the same pooled inner connection start with their isolation levels set to that of the pooled connection.</span></span> <span data-ttu-id="2aad3-190">Альтернативным вариантом по отношению к выключению пула соединений является явное задание уровня изоляции для каждого соединения.</span><span class="sxs-lookup"><span data-stu-id="2aad3-190">An alternative to turning off connection pooling is to set the isolation level explicitly for each connection.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/VB/source.vb#1)]  
  
### <a name="example"></a><span data-ttu-id="2aad3-191">Пример</span><span class="sxs-lookup"><span data-stu-id="2aad3-191">Example</span></span>  
 <span data-ttu-id="2aad3-192">Следующий пример демонстрирует поведение изоляции моментального снимка при изменении данных.</span><span class="sxs-lookup"><span data-stu-id="2aad3-192">The following example demonstrates the behavior of snapshot isolation when data is being modified.</span></span> <span data-ttu-id="2aad3-193">Код выполняет следующие действия.</span><span class="sxs-lookup"><span data-stu-id="2aad3-193">The code performs the following actions:</span></span>  
  
- <span data-ttu-id="2aad3-194">Подключается к **AdventureWorks** образец базы данных и включение изоляции моментального СНИМКА.</span><span class="sxs-lookup"><span data-stu-id="2aad3-194">Connects to the **AdventureWorks** sample database and enables SNAPSHOT isolation.</span></span>  
  
- <span data-ttu-id="2aad3-195">Создает таблицу с именем **TestSnapshotUpdate** и вставляет три строки образца данных.</span><span class="sxs-lookup"><span data-stu-id="2aad3-195">Creates a table named **TestSnapshotUpdate** and inserts three rows of sample data.</span></span>  
  
- <span data-ttu-id="2aad3-196">Начинает, но не завершает транзакцию sqlTransaction1 с использованием уровня изоляции SNAPSHOT.</span><span class="sxs-lookup"><span data-stu-id="2aad3-196">Begins, but does not complete, sqlTransaction1 using SNAPSHOT isolation.</span></span> <span data-ttu-id="2aad3-197">В транзакции выбираются три строки данных.</span><span class="sxs-lookup"><span data-stu-id="2aad3-197">Three rows of data are selected in the transaction.</span></span>  
  
- <span data-ttu-id="2aad3-198">Создает второй **SqlConnection** для **AdventureWorks** и создает вторую транзакцию, используя уровень изоляции READ COMMITTED, который обновляет значение в одной из строк, выбранных в sqlTransaction1.</span><span class="sxs-lookup"><span data-stu-id="2aad3-198">Creates a second **SqlConnection** to **AdventureWorks** and creates a second transaction using the READ COMMITTED isolation level that updates a value in one of the rows selected in sqlTransaction1.</span></span>  
  
- <span data-ttu-id="2aad3-199">Фиксирует транзакцию sqlTransaction2.</span><span class="sxs-lookup"><span data-stu-id="2aad3-199">Commits sqlTransaction2.</span></span>  
  
- <span data-ttu-id="2aad3-200">Возвращается к транзакции sqlTransaction1 и выполняет попытку обновления той строки, которую sqlTransaction1 уже зафиксировала.</span><span class="sxs-lookup"><span data-stu-id="2aad3-200">Returns to sqlTransaction1 and attempts to update the same row that sqlTransaction1 already committed.</span></span> <span data-ttu-id="2aad3-201">Возникает ошибка 3960, и откат транзакции sqlTransaction1 производится автоматически.</span><span class="sxs-lookup"><span data-stu-id="2aad3-201">Error 3960 is raised, and sqlTransaction1 is rolled back automatically.</span></span> <span data-ttu-id="2aad3-202">**SqlException.Number** и **SqlException.Message** отображаются в окне консоли.</span><span class="sxs-lookup"><span data-stu-id="2aad3-202">The **SqlException.Number** and **SqlException.Message** are displayed in the Console window.</span></span>  
  
- <span data-ttu-id="2aad3-203">Выполняет код очистки для выключения изоляции моментального снимка в **AdventureWorks** и удалить **TestSnapshotUpdate** таблицы.</span><span class="sxs-lookup"><span data-stu-id="2aad3-203">Executes clean-up code to turn off snapshot isolation in **AdventureWorks** and delete the **TestSnapshotUpdate** table.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/VB/source.vb#1)]  
  
### <a name="using-lock-hints-with-snapshot-isolation"></a><span data-ttu-id="2aad3-204">Использование подсказок блокировок с изоляцией моментального снимка</span><span class="sxs-lookup"><span data-stu-id="2aad3-204">Using Lock Hints with Snapshot Isolation</span></span>  
 <span data-ttu-id="2aad3-205">В предыдущем примере первая транзакция выбирает данные, а вторая их обновляет до завершения первой, что вызывает конфликт обновления, когда первая транзакция пытается обновить ту же строку.</span><span class="sxs-lookup"><span data-stu-id="2aad3-205">In the previous example, the first transaction selects data, and a second transaction updates the data before the first transaction is able to complete, causing an update conflict when the first transaction tries to update the same row.</span></span> <span data-ttu-id="2aad3-206">Вероятность возникновения конфликтов обновления в продолжительных транзакциях моментального снимка можно снизить, задавая подсказки блокировок при запуске транзакции.</span><span class="sxs-lookup"><span data-stu-id="2aad3-206">You can reduce the chance of update conflicts in long-running snapshot transactions by supplying lock hints at the beginning of the transaction.</span></span> <span data-ttu-id="2aad3-207">Следующая инструкция SELECT использует подсказку UPDLOCK для блокировки выбранных строк:</span><span class="sxs-lookup"><span data-stu-id="2aad3-207">The following SELECT statement uses the UPDLOCK hint to lock the selected rows:</span></span>  
  
```sql  
SELECT * FROM TestSnapshotUpdate WITH (UPDLOCK)   
  WHERE PriKey BETWEEN 1 AND 3  
```  
  
 <span data-ttu-id="2aad3-208">Использование подсказки блокировки UPDLOCK приводит к блокировке любых строк при попытке обновить эти строки до завершения первой транзакции.</span><span class="sxs-lookup"><span data-stu-id="2aad3-208">Using the UPDLOCK lock hint blocks any rows attempting to update the rows before the first transaction completes.</span></span> <span data-ttu-id="2aad3-209">Это гарантирует, что в выбранных строках не будет конфликтов при их будущих обновлениях в транзакции.</span><span class="sxs-lookup"><span data-stu-id="2aad3-209">This guarantees that the selected rows have no conflicts when they are updated later in the transaction.</span></span> <span data-ttu-id="2aad3-210">См. раздел «Подсказки блокировок» электронной документации по SQL Server.</span><span class="sxs-lookup"><span data-stu-id="2aad3-210">See "Locking Hints" in SQL Server Books Online.</span></span>  
  
 <span data-ttu-id="2aad3-211">Если приложение содержит множество конфликтов, то для него изоляция моментального снимка не лучший выбор.</span><span class="sxs-lookup"><span data-stu-id="2aad3-211">If your application has many conflicts, snapshot isolation may not be the best choice.</span></span> <span data-ttu-id="2aad3-212">Подсказки должны использоваться, только если они действительно нужны.</span><span class="sxs-lookup"><span data-stu-id="2aad3-212">Hints should only be used when really needed.</span></span> <span data-ttu-id="2aad3-213">Приложение должно быть создано таким образом, чтобы в ходе его работы не нужно было постоянно полагаться на подсказки блокировок.</span><span class="sxs-lookup"><span data-stu-id="2aad3-213">Your application should not be designed so that it constantly relies on lock hints for its operation.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2aad3-214">См. также</span><span class="sxs-lookup"><span data-stu-id="2aad3-214">See also</span></span>

- [<span data-ttu-id="2aad3-215">SQL Server и ADO.NET</span><span class="sxs-lookup"><span data-stu-id="2aad3-215">SQL Server and ADO.NET</span></span>](../../../../../docs/framework/data/adonet/sql/index.md)
- [<span data-ttu-id="2aad3-216">Центр разработчиков наборов данных и управляемых поставщиков ADO.NET</span><span class="sxs-lookup"><span data-stu-id="2aad3-216">ADO.NET Managed Providers and DataSet Developer Center</span></span>](https://go.microsoft.com/fwlink/?LinkId=217917)
- [<span data-ttu-id="2aad3-217">Руководство по управление версиями строк и блокировке транзакций</span><span class="sxs-lookup"><span data-stu-id="2aad3-217">Transaction Locking and Row Versioning Guide</span></span>](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)
