---
title: Изоляция снимков в SQL Server
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 43ae5dd3-50f5-43a8-8d01-e37a61664176
ms.openlocfilehash: 6d85cc041850300d1d079b227dcb8ed9201a0502
ms.sourcegitcommit: 3094dcd17141b32a570a82ae3f62a331616e2c9c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/01/2019
ms.locfileid: "71699060"
---
# <a name="snapshot-isolation-in-sql-server"></a>Изоляция снимков в SQL Server
Изоляция моментального снимка приводит к повышению параллелизма для приложений OLTP.  
  
## <a name="understanding-snapshot-isolation-and-row-versioning"></a>Основные сведения об изоляции моментального снимка и управлении версиями строк  
 После включения изоляции моментальных снимков необходимо поддерживать обновленные версии строк для каждой транзакции.  До SQL Server 2019 эти версии хранились в **базе данных tempdb**. SQL Server 2019 представляет собой новую функцию с ускорением восстановления базы данных (ADR), для которой требуется собственный набор версий строк.  Таким образом, начиная с SQL Server 2019, если ADR не включен, версии строк хранятся в **базе данных tempdb** как всегда.  Если параметр ADR включен, все версии строк, которые связаны с изоляцией моментальных снимков и ADR, хранятся в постоянном хранилище версий ADR (постоянного хранилища версий), расположенном в пользовательской базе данных в файловой группе, которую указывает пользователь. Уникальный порядковый номер транзакции определяет каждую транзакцию, и эти уникальные номера записываются для каждой версии строки. Транзакция работает с последними версиями строк, имеющими порядковый номер, предшествующий порядковому номеру транзакции. Более новые версии строк, созданные после начала транзакции, не учитываются.  
  
 Термин «моментальный снимок» отражает тот факт, что все запросы в транзакции обнаруживают одинаковую версию, или моментальный снимок базы данных, который соответствует состоянию базы данных в момент начала транзакции. Транзакция моментального снимка не требует блокировок базовых строк или страниц данных, что позволяет выполнять другую транзакцию без ее блокировки предыдущей незавершенной транзакцией. Транзакции, изменяющие данные, не блокируют транзакции, в которых происходит чтение данных, а транзакции, считывающие данные, не блокируют транзакции, в которых происходит запись данных, что обычно также наблюдается при использовании уровня изоляции READ COMMITTED, заданного по умолчанию в SQL Server. Применение такого подхода, предусматривающего отказ от блокировок, способствует значительному снижению вероятности взаимоблокировок в сложных транзакциях.  
  
 В подходе с изоляцией моментального снимка используется модель оптимистического параллелизма. Если транзакция моментального снимка попытается зафиксировать изменения в данных, произошедшие после начала транзакции, то будет произведен откат транзакции и возникнет ошибка. Этого можно избежать, используя подсказки UPDLOCK для инструкций SELECT, которые обеспечивают доступ к измененным данным. Дополнительные сведения см. в разделе «Подсказки блокировок» электронной документации по SQL Server.  
  
 Перед использованием в транзакциях изоляция моментального снимка должна быть включена путем установки параметра базы данных ALLOW_SNAPSHOT_ISOLATION в значение ON. Это активирует механизм хранения версий строк во временной базе данных (**tempdb**). Необходимо включить изоляцию моментального снимка в каждой использующей ее базе данных с помощью инструкции ALTER DATABASE языка Transact-SQL. В этом отношении изоляция моментального снимка отличается от традиционных уровней изоляции READ COMMITTED, REPEATABLE READ, SERIALIZABLE и READ UNCOMMITTED, которые не требуют настройки конфигурации. Следующие инструкции активируют изоляцию моментального снимка и заменяют поведение по умолчанию READ COMMITTED на SNAPSHOT:  
  
```sql  
ALTER DATABASE MyDatabase  
SET ALLOW_SNAPSHOT_ISOLATION ON  
  
ALTER DATABASE MyDatabase  
SET READ_COMMITTED_SNAPSHOT ON  
```  
  
 Установка параметра READ_COMMITTED_SNAPSHOT со значением ON обеспечивает доступ к версиям строк уровня изоляции по умолчанию READ COMMITTED. Если параметр READ_COMMITTED_SNAPSHOT установлен в значение OFF, то для получения доступа к версиям строк потребуется явно задавать уровень изоляции моментального снимка для каждого сеанса.  
  
## <a name="managing-concurrency-with-isolation-levels"></a>Управление параллелизмом с помощью уровней изоляции  
 Уровень изоляции, при котором выполняется инструкция Transact-SQL, определяет ее блокировку и поведение управления версиями строк. Уровень изоляции действует на уровне соединения и, будучи один раз заданным для соединения с помощью инструкции SET TRANSACTION ISOLATION LEVEL, остается в силе до закрытия соединения или установки другого уровня изоляции. После того как соединение закрывается и возвращается в пул, сохраняется уровень изоляции последней инструкции SET TRANSACTION ISOLATION LEVEL. В последующих соединениях, повторно использующих соединение из пула, применяется уровень изоляции, который был действителен в момент возврата соединения в пул.  
  
 Отдельные запросы, выполняемые внутри соединения, могут содержать подсказки блокировок, которые изменяют уровень изоляции для одной инструкции или транзакции, но не оказывают влияния на уровень изоляции соединения. Уровни изоляции или подсказки блокировок, установленные в хранимых процедурах или функциях, не изменяют уровень изоляции вызывающего их соединения и действительны только в течение их вызова.  
  
 В ранних версиях SQL Server поддерживались четыре уровня изоляции, определенные в стандарте SQL-92:  
  
- READ UNCOMMITTED является наименее строгим уровнем изоляции, поскольку при его использовании не учитываются блокировки, размещенные другими транзакциями. Транзакции, выполняемые в READ UNCOMMITTED, могут считывать измененные значения данных, которые еще не были зафиксированы другими транзакциями. Это называется чтением «грязных» данных.  
  
- READ COMMITTED является уровнем изоляции по умолчанию для SQL Server. Он запрещает чтение «грязных» данных путем задания условия, что инструкции не могут считывать измененные значения данных, которые еще не зафиксированы другими транзакциями. Другие транзакции все еще могут изменять, вставлять или удалять данные между выполнением отдельных инструкций внутри текущей транзакции, что приводит к выполнению операций чтения без возможности повторения или к получению «фантомных» данных.  
  
- REPEATABLE READ является более ограничительным уровнем изоляции, чем READ COMMITTED. Он включает в себя уровень изоляции READ COMMITTED и дополнительно указывает, что до завершения текущей транзакции ни одна прочая транзакция не может изменять или удалять данные, считанные текущей транзакцией. Параллелизм данного уровня изоляции ниже по сравнению с READ COMMITTED, поскольку совмещаемые блокировки при чтении данных сохраняются в течение транзакции, а не освобождаются после выполнения каждой инструкции.  
  
- SERIALIZABLE является самым строгим уровнем изоляции, поскольку при его использовании блокируются целые диапазоны ключей и блокировки сохраняются до завершения транзакции. Он включает в себя уровень изоляции REPEATABLE READ и добавляет ограничение, согласно которому до завершения транзакции другие транзакции не могут вставлять новые строки в диапазоны строк, чтение которых осуществляется в данной транзакции.  
  
 Дополнительные сведения см. в руководстве по [блокировке транзакций и управлении версиями строк](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide).  
  
### <a name="snapshot-isolation-level-extensions"></a>Расширения уровня изоляции моментального снимка  
 SQL Server предоставляет расширения уровней изоляции стандарта SQL-92 путем представления уровня изоляции SNAPSHOT и дополнительных изменений в READ COMMITTED. Уровень изоляции READ_COMMITTED_SNAPSHOT может прозрачно заменять READ COMMITTED для всех транзакций.  
  
- Изоляция SNAPSHOT указывает, что данные, считанные внутри транзакции, никогда не отразят изменений, сделанных другими одновременными транзакциями. Транзакция использует версии строк данных, существующих при начале транзакции. При чтении данных на них не устанавливаются блокировки, иными словами, транзакции SNAPSHOT не блокируют операции записи данных, выполняемые другими транзакциями. Транзакции, осуществляющие запись данных, не блокируют чтение данных транзакциями моментального снимка. Для использования изоляции моментального снимка необходимо включить ее, установив параметр базы данных ALLOW_SNAPSHOT_ISOLATION.  
  
- Если изоляция моментального снимка включена в базе данных, то параметр базы данных READ_COMMITTED_SNAPSHOT определяет поведение уровня изоляции по умолчанию READ COMMITTED. Если параметр READ_COMMITTED_SNAPSHOT со значением ON не задан явно, то ко всем неявным транзакциям применяется уровень изоляции READ COMMITTED. Это аналогично организации работы, которая применяется при установке параметра READ_COMMITTED_SNAPSHOT со значением OFF (по умолчанию). Если действителен параметр READ_COMMITTED_SNAPSHOT со значением OFF, компонент Database Engine использует совмещаемые блокировки для принудительной установки уровня изоляции по умолчанию. Если параметр базы данных READ_COMMITTED_SNAPSHOT установлен в значение ON, компонент Database Engine использует управление версиями строк и изоляцию моментального снимка по умолчанию вместо применения блокировок для защиты данных.  
  
## <a name="how-snapshot-isolation-and-row-versioning-work"></a>Основные сведения о функционировании уровней изоляции моментального снимка и управлении версиями строк  
 Если уровень изоляции МОМЕНТАЛЬного СНИМКа включен, каждый раз при обновлении строки SQL Server ядро СУБД сохраняет копию исходной строки в **базе данных tempdb**и добавляет к строке порядковый номер транзакции. Далее показана последовательность происходящих событий.  
  
- Инициируется новая транзакция, и ей присваивается порядковый номер.  
  
- Ядро СУБД считывает строку внутри транзакции и извлекает версию строки из **базы данных tempdb** , порядковый номер которой ближе всего к, а ниже — порядковому номеру транзакции.  
  
- При запуске транзакции моментального снимка компонент Database Engine проверяет, не находится ли порядковый номер транзакции в списке номеров активных незафиксированных транзакций.  
  
- Транзакция считывает версию строки из **базы данных tempdb** , которая была текущей на момент начала транзакции. Транзакция не обнаруживает новые строки, вставленные после ее запуска, поскольку эти строки имеют более высокие значения порядковых номеров по сравнению с порядковым номером транзакции.  
  
- Текущая транзакция будет видеть строки, которые были удалены после начала транзакции, так как в **базе данных tempdb** будет использоваться версия строки с меньшим значением порядкового номера.  
  
 Суммарным эффектом изоляции моментального снимка является то, что транзакция обнаруживает все данные, существовавшие при ее запуске, без учета или установки каких-либо блокировок на базовых таблицах. Это может привести к повышению производительности в тех ситуациях, когда возникает конфликт.  
  
 В транзакции моментального снимка всегда используется оптимистическое управление параллелизмом, в котором предусматривается отказ от любых блокировок, запрещающих обновление строк другими транзакциями. Если транзакция моментального снимка попытается зафиксировать обновление строки, выполненное после запуска транзакции, будет произведен ее откат и возникнет ошибка.  
  
## <a name="working-with-snapshot-isolation-in-adonet"></a>Работа с изоляцией моментального снимка в ADO.NET  
 Изоляция моментального снимка поддерживается в ADO.NET с помощью класса <xref:System.Data.SqlClient.SqlTransaction>. Если для базы данных включена изоляция моментальных снимков, но для параметра READ_COMMITTED_SNAPSHOT не настроено значение ON, то при вызове метода <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> необходимо инициировать <xref:System.Data.SqlClient.SqlTransaction> с помощью значения перечисления **IsolationLevel. snapshot** . В данном фрагменте кода предполагается, что соединение представляет собой открытый объект <xref:System.Data.SqlClient.SqlConnection>.  
  
```vb  
Dim sqlTran As SqlTransaction = _  
  connection.BeginTransaction(IsolationLevel.Snapshot)  
```  
  
```csharp  
SqlTransaction sqlTran =   
  connection.BeginTransaction(IsolationLevel.Snapshot);  
```  
  
### <a name="example"></a>Пример  
 Следующий пример показывает, какие действия осуществляются при использовании различных уровней изоляции, если обнаруживается попытка получения доступа к заблокированным данным, и не предназначен для использования в коде производственного назначения.  
  
 Код подключается к образцу базы данных **AdventureWorks** в SQL Server и создает таблицу с именем **TestSnapshot** и вставляет одну строку данных. В коде используется инструкция ALTER DATABASE языка Transact-SQL для включения изоляции моментального снимка базы данных, но не устанавливается параметр READ_COMMITTED_SNAPSHOT, поэтому остается в силе поведение уровня изоляции READ COMMITTED, применяемое по умолчанию. Затем в коде выполняются следующие действия.  
  
- В коде начинается, но не завершается транзакция sqlTransaction1, в которой используется уровень изоляции SERIALIZABLE для запуска транзакции обновления. Это приводит к блокировке таблицы.  
  
- Он открывает второе соединение и инициирует вторую транзакцию, используя уровень изоляции SNAPSHOT для чтения данных в таблице **TestSnapshot** . Поскольку изоляция моментального снимка включена, данная транзакция может считывать данные, существовавшие до запуска sqlTransaction1.  
  
- Код открывает третье соединение и инициирует транзакцию, используя уровень изоляции READ COMMITTED для осуществления попытки чтения данных из таблицы. В этом случае в коде исключается возможность считывать данные, поскольку чтение не может быть выполнено после установки блокировок на таблице в первой транзакции, поэтому код завершает свою работу в связи с истечением времени ожидания. Аналогичный результат был бы получен при использовании уровней изоляции REPEATABLE READ и SERIALIZABLE, поскольку эти уровни изоляции также не позволяют выполнять чтение после установки блокировок в первой транзакции.  
  
- Код открывает четвертое соединение и инициирует транзакцию, используя уровень изоляции READ UNCOMMITTED, который выполняет чтение незафиксированного значения в sqlTransaction1 как чтение «грязных» данных. Это значение может так и не появиться в базе данных, если первая транзакция не будет зафиксирована.  
  
- Он выполняет откат первой транзакции и очищает ее, удаляя таблицу **TestSnapshot** и отключая изоляцию моментальных снимков для базы данных **AdventureWorks** .  
  
> [!NOTE]
> В следующем примере используется аналогичная строка соединения с отключенным пулом соединений. Если соединение отправляется в пул, сброс его уровня изоляции не приводит к сбросу уровня изоляции на сервере. В результате последующие соединения, в которых используется то же помещенное в пул внутреннее соединение, запускаются с уровнем изоляции, заданным равным уровню изоляции этого соединения. Альтернативным вариантом по отношению к выключению пула соединений является явное задание уровня изоляции для каждого соединения.  
  
 [!code-csharp[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/VB/source.vb#1)]  
  
### <a name="example"></a>Пример  
 Следующий пример демонстрирует поведение изоляции моментального снимка при изменении данных. Код выполняет следующие действия.  
  
- Подключается к образцу базы данных **AdventureWorks** и включает изоляцию моментального снимка.  
  
- Создает таблицу с именем **тестснапшотупдате** и вставляет три строки образца данных.  
  
- Начинает, но не завершает транзакцию sqlTransaction1 с использованием уровня изоляции SNAPSHOT. В транзакции выбираются три строки данных.  
  
- Создает второй объект **SqlConnection** для **AdventureWorks** и создает вторую транзакцию, используя уровень изоляции READ COMMITTED, который обновляет значение в одной из строк, выбранных в sqlTransaction1.  
  
- Фиксирует транзакцию sqlTransaction2.  
  
- Возвращается к транзакции sqlTransaction1 и выполняет попытку обновления той строки, которую sqlTransaction1 уже зафиксировала. Возникает ошибка 3960, и откат транзакции sqlTransaction1 производится автоматически. **SqlException. Number** и **SqlException. Message** отображаются в окне консоли.  
  
- Выполняет очистку кода, чтобы отключить изоляцию моментальных снимков в **AdventureWorks** и удалить таблицу **тестснапшотупдате** .  
  
 [!code-csharp[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/VB/source.vb#1)]  
  
### <a name="using-lock-hints-with-snapshot-isolation"></a>Использование подсказок блокировок с изоляцией моментального снимка  
 В предыдущем примере первая транзакция выбирает данные, а вторая их обновляет до завершения первой, что вызывает конфликт обновления, когда первая транзакция пытается обновить ту же строку. Вероятность возникновения конфликтов обновления в продолжительных транзакциях моментального снимка можно снизить, задавая подсказки блокировок при запуске транзакции. Следующая инструкция SELECT использует подсказку UPDLOCK для блокировки выбранных строк:  
  
```sql  
SELECT * FROM TestSnapshotUpdate WITH (UPDLOCK)   
  WHERE PriKey BETWEEN 1 AND 3  
```  
  
 Использование подсказки блокировки UPDLOCK приводит к блокировке любых строк при попытке обновить эти строки до завершения первой транзакции. Это гарантирует, что в выбранных строках не будет конфликтов при их будущих обновлениях в транзакции. См. раздел «Подсказки блокировок» электронной документации по SQL Server.  
  
 Если приложение содержит множество конфликтов, то для него изоляция моментального снимка не лучший выбор. Подсказки должны использоваться, только если они действительно нужны. Приложение должно быть создано таким образом, чтобы в ходе его работы не нужно было постоянно полагаться на подсказки блокировок.  
  
## <a name="see-also"></a>См. также

- [SQL Server и ADO.NET](index.md)
- [Общие сведения об ADO.NET](../ado-net-overview.md)
- [Инструкции по блокировке транзакций и управлении версиями строк](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)
