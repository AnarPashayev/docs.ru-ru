---
title: Вопросы и ответы
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 252ed666-0679-4eea-b71b-2f14117ef443
ms.openlocfilehash: 3cc879e97438138554f1d39cf588e01bfbba28a6
ms.sourcegitcommit: 7bc6887ab658550baa78f1520ea735838249345e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/03/2020
ms.locfileid: "75634707"
---
# <a name="frequently-asked-questions"></a>Вопросы и ответы

В следующих разделах содержатся ответы на некоторые распространенные проблемы, которые могут возникнуть при реализации LINQ.

Дополнительные проблемы описаны в [статье Устранение неполадок](troubleshooting.md).

## <a name="cannot-connect"></a>Не удается подключиться

Вопрос. Не удается соединиться с базой данных.

А. Убедитесь в правильности строки подключения и в том, что экземпляр SQL Server работает. Обратите внимание, что для [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] требуется включенный протокол именованных каналов. Дополнительные сведения см. [в разделе обучение по пошаговым руководствам](learning-by-walkthroughs.md).

## <a name="changes-to-database-lost"></a>Потеряны изменения, внесенные в базу данных

Вопрос. В базу данных были внесены изменения, однако при повторном запуске приложения их там не оказалось.

А. Проверьте, что для сохранения результатов в базе данных был вызван метод <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.

## <a name="database-connection-open-how-long"></a>Как долго сохраняется открытым соединение с базой данных?

Вопрос. Как долго соединение с базой данных будет оставаться открытым?

А. Как правило, подключение остается открытым до тех пор, пока не будут использованы результаты запроса. Если планируется выделить время для обработки и кэширования всех результатов, к запросу следует применить <xref:System.Linq.Enumerable.ToList%2A>. В типичных сценариях, где каждый объект обрабатывается только один раз, потоковая модель является предпочтительной в `DataReader` и [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)].

Точные сведения об использовании подключения зависят от следующих моментов.

- Состояние подключения, если <xref:System.Data.Linq.DataContext> создан с помощью объекта подключения.

- Параметры строки подключения (например, включение режима MARS). Дополнительные сведения см. в разделе [Несколько активных результирующих наборов (MARS)](../multiple-active-result-sets-mars.md).

## <a name="updating-without-querying"></a>Обновление без выполнения запросов

Вопрос. Можно ли обновить данные таблицы, не отправляя запрос в базу данных?

А. Хотя в [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] отсутствуют команды обновления на основе наборов, для обновления без выполнения запроса можно воспользоваться любым из следующих способов.

- Чтобы отправить код SQL, используйте <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>.

- Создайте новый экземпляр объекта и инициализируйте все текущие значения (поля), влияющие на обновление. Затем прикрепите объект к <xref:System.Data.Linq.DataContext> с помощью <xref:System.Data.Linq.Table%601.Attach%2A> и отредактируйте поле, которое нужно изменить.

## <a name="unexpected-query-results"></a>Неожиданные результаты запроса

Вопрос. Запрос возвращает непредвиденные результаты. Как узнать, что случилось?

А. [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] предусматривает несколько средств для проверки создаваемого кода SQL. Одним из наиболее важных <xref:System.Data.Linq.DataContext.Log%2A>. Дополнительные сведения см. в разделе [Поддержка отладки](debugging-support.md).

## <a name="unexpected-stored-procedure-results"></a>Неожиданные результаты хранимой процедуры

Вопрос. Имеется хранимая процедура, возвращаемое значение которой вычислено с помощью функции `MAX()`. При перетаскивании хранимой процедуры в область конструктора O/R возвращаемое значение неверно.

А. [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] обеспечивает два способа возврата значений, сформированных в базе данных, с помощью хранимых процедур.

- Путем именования выходного результата.

- Путем явного указания выходного параметра.

Ниже представлен пример неверных выходных данных. Поскольку [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] не может сопоставить результаты, он всегда возвращает 0.

```sql
create procedure proc2

as

begin

select max(i) from t where name like 'hello'

end
```

Ниже представлен пример правильных выходных данных с использованием выходного параметра.

```sql
create procedure proc2

@result int OUTPUT

as

select @result = MAX(i) from t where name like 'hello'

go
```

Ниже представлен пример правильных выходных данных с именованием выходного результата.

```sql
create procedure proc2

as

begin

select nax(i) AS MaxResult from t where name like 'hello'

end
```

Дополнительные сведения см. в разделе [Настройка операций с помощью хранимых процедур](customizing-operations-by-using-stored-procedures.md).

## <a name="serialization-errors"></a>Ошибки сериализации

Вопрос. При попытке сериализации возникает следующая ошибка: "тип" System. Data. LINQ. ChangeTracker + Стандардчанжетраккер "... не помечен как сериализуемый.

А. Формирование кода в [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] поддерживает сериализацию <xref:System.Runtime.Serialization.DataContractSerializer>. Оно не поддерживает <xref:System.Xml.Serialization.XmlSerializer> или <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>. Дополнительные сведения см. в разделе [Сериализация](serialization.md).

## <a name="multiple-dbml-files"></a>Несколько DBML-файлов

Вопрос. При работе с несколькими DBML-файлами, использующими общие таблицы, возникает ошибка компилятора.

А. Задайте для свойств **пространства имен контекста** и **пространства имен сущности** реляционный конструктор объектов различные значения для каждого DBML-файла. Это способ исключает конфликты имен/пространств имен.

## <a name="avoiding-explicit-setting-of-database-generated-values-on-insert-or-update"></a>Предупреждение явного задания значений, созданных базой данных, в Insert или Update

Вопрос. В базе данных имеется таблица со столбцом `DateCreated`, в качестве значения по умолчанию которой указана функция SQL `Getdate()`. При попытке вставить новую запись с помощью [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] возвращается значение `NULL`. Хотя ожидается заданное по умолчанию значение базы данных.

А. [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] автоматически обрабатывает данную ситуацию для столбцов identity (автоувеличение), rowguidcol (формируемые базой данных идентификаторы GUID) и timestamp. В других случаях следует вручную задать <xref:System.Data.Linq.Mapping.ColumnAttribute.IsDbGenerated%2A>=`true` и <xref:System.Data.Linq.Mapping.ColumnAttribute.AutoSync%2A>=<xref:System.Data.Linq.Mapping.AutoSync.Always>/<xref:System.Data.Linq.Mapping.AutoSync.OnInsert>/<xref:System.Data.Linq.Mapping.AutoSync.OnUpdate> свойства.

## <a name="multiple-dataloadoptions"></a>Несколько параметров DataLoadOptions

Вопрос. Можно ли задать дополнительные параметры загрузки, не переопределяя исходные?

А. Да, Исходные параметры не переопределяются, как показано в следующем примере.

```vb
Dim dlo As New DataLoadOptions()
dlo.LoadWith(Of Order)(Function(o As Order) o.Customer)
dlo.LoadWith(Of Order)(Function(o As Order) o.OrderDetails)
```

```csharp
DataLoadOptions dlo = new DataLoadOptions();
dlo.LoadWith<Order>(o => o.Customer);
dlo.LoadWith<Order>(o => o.OrderDetails);
```

## <a name="errors-using-sql-compact-35"></a>Ошибки при использовании SQL Compact 3.5

Вопрос. При перетаскивании таблиц из базы данных SQL Server Compact 3,5 возникает ошибка.

А. Реляционный конструктор объектов не поддерживает SQL Server Compact 3,5, хотя среда выполнения [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] делает. В этом случае необходимо создать собственные классы сущностей и добавить соответствующие атрибуты.

## <a name="errors-in-inheritance-relationships"></a>Ошибки в связях наследования

Вопрос. Я использовал фигуру наследования панели элементов в реляционный конструктор объектов для соединения двух сущностей, но выдает ошибки.

А. Простого создания связи недостаточно. Необходимо предоставить сведения, такие как столбец дискриминатора, значение дискриминатора базового класса и значение дискриминатора производного класса.

## <a name="provider-model"></a>Модель поставщика

Вопрос. Доступна ли модель общего поставщика?

А. Такая модель отсутствует. В настоящее время [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] поддерживает только SQL Server и SQL Server Compact 3,5.

## <a name="sql-injection-attacks"></a>Атаки путем внедрения кода SQL

Вопрос. Каким образом [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] защищен от атак путем внедрения кода SQL?

А. Внедрение SQL-кода представляло серьезную угрозу для традиционных SQL-запросов, создаваемых путем объединения данных, вводимых пользователем. [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] предотвращает подобное внедрение за счет использования в запросах объектов <xref:System.Data.SqlClient.SqlParameter>. Вводимые данные преобразуются в значения параметров. Этот способ исключает использование вредоносных команд из введенных данных.

## <a name="changing-read-only-flag-in-dbml-files"></a>Создание флага "Только чтение" в файлах DBML.

Вопрос. Как можно избавиться от некоторых методов задания свойств при создании объектной модели из файла DBM?

А. Выполните следующие действия.

1. В файле DBML измените свойство, присвоив флагу <xref:System.Data.Linq.ITable.IsReadOnly%2A> значение `True`.

2. Добавьте разделяемый класс. Создайте конструктор с параметрами для членов, доступных только для чтения.

3. Проверьте значение по умолчанию <xref:System.Data.Linq.Mapping.UpdateCheck> (<xref:System.Data.Linq.Mapping.UpdateCheck.Never>), чтобы определить, является ли оно правильным для приложения.

    > [!CAUTION]
    > Если вы используете реляционный конструктор объектов в Visual Studio, изменения могут быть перезаписаны.

## <a name="aptca"></a>APTCA

Вопрос. Помечена ли сборка System.Data.Linq для использования кодом с частичным доверием?

А. Да, сборка System. Data. LINQ. dll состоит из .NET Framework сборок, помеченных атрибутом <xref:System.Security.AllowPartiallyTrustedCallersAttribute>. Без этой маркировки сборки в .NET Framework предназначены для использования только полностью доверенным кодом.

Основной сценарий в [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] для разрешения частично доверенных вызывающих объектов заключается в том, чтобы обеспечить доступ к сборке [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] из веб-приложений, где конфигурация *доверия* является средней.

## <a name="mapping-data-from-multiple-tables"></a>Сопоставление данных из нескольких таблиц

Вопрос. Данные в сущность поступают из нескольких таблиц. Как их сопоставить?

А. В базе данных можно создать представление и сопоставить с ним сущность. [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] создает одинаковый SQL-код для представлений и таблиц.

> [!NOTE]
> В данном сценарии использование представлений имеет ограничения. Способ работает с максимальной безопасностью, если операции, выполняемые в <xref:System.Data.Linq.Table%601>, поддерживаются базовым представлением. Операции, которые предполагается использовать, известны только вам. Например, большинство приложений доступны только для чтения, а другой номер немалым выполняет `Create`/`Update`/`Delete` операций только с помощью хранимых процедур в представлениях.

## <a name="connection-pooling"></a>Пулы подключений

Вопрос. Существует ли конструкция, которая поможет в организации пула объектов <xref:System.Data.Linq.DataContext>?

А. Не пытайтесь повторно использовать экземпляры <xref:System.Data.Linq.DataContext>. Каждый <xref:System.Data.Linq.DataContext> сохраняет состояние (включая кэш идентификации) для одного определенного сеанса редактирования/запроса. Для получения новых экземпляров на основе текущего состояния базы данных используйте новый <xref:System.Data.Linq.DataContext>.

Вы по-прежнему можете использовать базовые пулы соединений ADO.NET. Дополнительные сведения см. в разделе [Пулы подключений SQL Server (ADO.NET)](../../sql-server-connection-pooling.md).

## <a name="second-datacontext-is-not-updated"></a>Не выполняется обновление второго DataContext

Вопрос. Для хранения значения в базе данных использовался один экземпляр <xref:System.Data.Linq.DataContext>. Однако второй <xref:System.Data.Linq.DataContext> в той же базе данных не отражает обновленные значения. Второй экземпляр <xref:System.Data.Linq.DataContext>, вероятно, возвращает кэшированные значения.

А. Это сделано намеренно. [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] по-прежнему возвращает те же экземпляры и значения, которые отображались в первом экземпляре. При выполнении обновлений используется оптимистическая блокировка. Для проверки текущего состояния базы данных используются исходные данные, которые подтверждают неизменность ее состояния. Если состояние изменилось, возникает конфликт, который должен быть устранен приложением. Одним вариантом является сброс исходного состояния до текущего состояния базы данных и повторная попытка обновления. Дополнительные сведения см. [в разделе руководство. Управление конфликтами изменений](how-to-manage-change-conflicts.md).

Кроме того, <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> можно задать значение «false», которое отключает кэширование и отслеживание изменений. После этого самые последние значения можно будет извлекать при каждом запросе.

## <a name="cannot-call-submitchanges-in-read-only-mode"></a>Не удается вызвать метод SubmitChanges в режиме "только чтение"

Вопрос. При попытке вызова метода <xref:System.Data.Linq.DataContext.SubmitChanges%2A> в режиме только для чтения возникает ошибка.

А. Режим только для чтения отключает для контекста возможность отслеживания изменений.

## <a name="see-also"></a>См. также:

- [Ссылки](reference.md)
- [Устранение неполадок](troubleshooting.md)
- [Безопасность в LINQ to SQL](security-in-linq-to-sql.md)
