---
title: Идентификация объектов
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: c788f2f9-65cc-4455-9907-e8388a268e00
ms.openlocfilehash: 0f1b6cf27101c2a7f55757b72b56b2291198404d
ms.sourcegitcommit: 0be8a279af6d8a43e03141e349d3efd5d35f8767
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/18/2019
ms.locfileid: "59200666"
---
# <a name="object-identity"></a>Идентификация объектов
Во время выполнения объекты получают уникальные идентификаторы. Две переменные, которые ссылаются на один объект, в действительности ссылаются на один экземпляр этого объекта. По этой причине изменения, произведенные посредством одной переменной, немедленно отображаются через вторую.  
  
 Строки в таблице реляционной базы данных не имеют уникальных идентификаторов. Поэтому каждой строке присвоен уникальный первичный ключ, который не совпадает с ключами других строк. Однако этот факт применим только к содержимому таблицы базы данных.  
  
 В действительности данные зачастую извлекаются из базы данных и отправляются на другой уровень, на котором с ними работает приложение. Именно такая модель поддерживается технологией [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]. Когда данные извлекаются из базы данных в виде строк, пользователь не может сделать никаких предположений относительного того, что две строки, представляющие идентичные данные, в действительности соответствуют одному экземпляру строки. Если дважды выполнить запрос на получение одного определенного клиента, будут извлечены две строки данных. Каждая строка содержит идентичные сведения.  
  
 В случае объектов процесс осуществляется совершенно иначе. Можно ожидать, что, несколько раз отправляя классу <xref:System.Data.Linq.DataContext> запрос на получений одной и той же информации, в действительности будет получен один и тот же экземпляр объекта. Это поведение реализуется по той причине, что объекты имеют особое значение для приложения и полученные данные ведут себя как объекты. Объекты создаются как иерархии или графы. Пользователь может быть уверен, что объекты будут извлечены именно в этом качестве. Он не получит множество реплицированных экземпляров только потому, что отправил несколько запросов на одни и те же сведения.  
  
 В [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] идентификациями объектов управляет класс <xref:System.Data.Linq.DataContext>. При получении новой строки из базы данных строка регистрируется в таблице идентификаций по своему первичному ключу и создается новый объект. При извлечении той же строки приложение отправляется исходный экземпляр объекта. Таким образом, класс <xref:System.Data.Linq.DataContext> преобразует понятие идентификации в контексте базы данных (то есть первичные ключи) в понятие идентификации в контексте языка программирования (то есть экземпляры). Объект представляется приложению только в состоянии, в котором он находился при первом получении. Если новые данные оказываются другими, они удаляются. Дополнительные сведения см. в разделе [извлечение объектов из кэша идентификаторов](../../../../../../docs/framework/data/adonet/sql/linq/retrieving-objects-from-the-identity-cache.md).  
  
 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] использует этот подход, чтобы обеспечивать целостность локальных объектов для поддержки обновлений оптимистичного параллелизма. Поскольку все изменения, происходящие после первого создания объекта, выполняются приложением, действия приложения строго определены. Если во время работы приложения изменения производятся из-за пределов его области действия, эти изменения определяются в момент вызова метода `SubmitChanges()`.  
  
> [!NOTE]
>  Если запрашиваемый объект легко определить как уже извлеченный, то запрос не выполняется. Таблица идентификаций действует как кэш всех ранее извлеченных объектов.  
  
## <a name="examples"></a>Примеры  
  
### <a name="object-caching-example-1"></a>Пример кэширования объекта 1  
 В данном примере, если дважды выполнить один и тот же запрос, каждый раз будет получена ссылка на один и тот же объект в памяти.  
  
 [!code-csharp[DLinqObjectIdentity#1](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqObjectIdentity/cs/Program.cs#1)]
 [!code-vb[DLinqObjectIdentity#1](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqObjectIdentity/vb/Module1.vb#1)]  
  
### <a name="object-caching-example-2"></a>Пример кэширования объекта 2  
 В данном примере, если дважды выполнить разные запросы, которые возвращают одну и ту же строку базы данных, каждый раз будет получена ссылка на один и тот же объект в памяти.  
  
 [!code-csharp[DLinqObjectIdentity#2](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqObjectIdentity/cs/Program.cs#2)]
 [!code-vb[DLinqObjectIdentity#2](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqObjectIdentity/vb/Module1.vb#2)]  
  
## <a name="see-also"></a>См. также

- [Основные сведения](../../../../../../docs/framework/data/adonet/sql/linq/background-information.md)
