---
title: Пример. Создание составного элемента управления с помощью C#
ms.date: 03/30/2017
dev_langs:
- CSharp
helpviewer_keywords:
- custom controls [C#]
- user controls [Windows Forms], creating with Visual C#
- UserControl class [Windows Forms], walkthroughs
- user controls [C#]
- custom controls [Windows Forms], creating
ms.assetid: f88481a8-c746-4a36-9479-374ce5f2e91f
author: jillre
ms.author: jillfra
manager: jillfra
ms.openlocfilehash: 3ad9aad026a1a6a1266845736d7651db77fd5d5c
ms.sourcegitcommit: 34dc3c0d0d0a1cc418abff259d9daa8078d00b81
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2020
ms.locfileid: "79546728"
---
# <a name="walkthrough-author-a-composite-control-with-c"></a>Пошаговая прогулка: Автор композитного управления с C\#

Составные элементы управления предоставляют средства для создания и повторного использования настраиваемых графических интерфейсов. Составной элемент управления — это компонент, имеющий визуальное представление. Таким образом, он может состоять из одного или нескольких элементов управления, компонентов или блоков кода Windows Forms, позволяющих расширить функциональные возможности за счет проверки введенных пользователем данных, изменения свойств отображения или выполнения других предусмотренных разработчиком действий. Составные элементы управления можно вставлять в Windows Forms точно так же, как другие элементы управления. В первой части этого пошагового руководства мы создадим простой составной элемент управления с именем `ctlClock`. Во второй части мы расширим функциональность `ctlClock` за счет наследования.

## <a name="create-the-project"></a>Создание проекта

Создавая проект, вы указываете для него имя, чтобы задать корневое пространство имен, имя сборки и имя проекта, и необходимо убедиться в том, что компонент по умолчанию попадет в нужное пространство имен.

### <a name="to-create-the-ctlclocklib-control-library-and-the-ctlclock-control"></a>Создание библиотеки элементов управления ctlClockLib и элемента управления ctlClock

1. В Visual Studio создайте новый проект **библиотеки управления формами Windows** и назовите его **ctlClockLib.**

     Имя проекта, `ctlClockLib`, по умолчанию также назначается корневому пространству имен. Корневое пространство имен используется для определения имен компонентов в сборке. Например, если в двух сборках содержатся компоненты с именем `ctlClock`, можно указать компонент `ctlClock`, используя `ctlClockLib.ctlClock.`.

2. В **Solution Explorer**, правой кнопкой мыши **UserControl1.cs**, а затем нажмите **Переименовать**. Измените имя файла на `ctlClock.cs`. Нажмите кнопку **"Да",** когда вас спросят, хотите ли вы переименовать все ссылки на элемент кода "UserControl1".

    > [!NOTE]
    > По умолчанию композитный элемент <xref:System.Windows.Forms.UserControl> управления наследует от класса, предоставляемого системой. Класс <xref:System.Windows.Forms.UserControl> предоставляет функциональность, требуемую всеми композитными элементами управления, и реализует стандартные методы и свойства.

3. Сохраните проект, открыв меню **Файл** и выбрав пункт **Сохранить все**.

## <a name="add-windows-controls-and-components-to-the-composite-control"></a>Добавление элементов управления Windows и компонентов в элемента «Управление композитом»

Визуальный интерфейс представляет собой важную часть составного элемента управления. Он реализуется путем добавления одного или нескольких элементов управления Windows на поверхность конструктора. В следующем примере мы добавим элементы управления Windows в составной элемент управления и напишем код для реализации функциональных возможностей.

### <a name="to-add-a-label-and-a-timer-to-your-composite-control"></a>Добавление метки и таймера в составной элемент управления

1. В **Solution Explorer**, правой кнопкой мыши **ctlClock.cs**, а затем нажмите **Посмотреть Дизайнер**.

2. В **Toolbox**расширьте узло **Общего контроля,** а затем дважды щелкните **этикетку.**

     Имя <xref:System.Windows.Forms.Label> `label1` элемента управления добавляется к вашему управлению на поверхности конструктора.

3. В дизайнере нажмите **label1**. В окне "Свойства" задайте следующие свойства.

    |Свойство|Измените на|
    |--------------|---------------|
    |**Название**|`lblDisplay`|
    |**Текст**|`(blank space)`|
    |**TextAlign**|`MiddleCenter`|
    |**Шрифт.Размер**|`14`|

4. На **панели элементов** разверните узел **Компоненты**, а затем дважды щелкните пункт **Таймер**.

     Поскольку <xref:System.Windows.Forms.Timer> компонент является компонентом, он не имеет визуального представления во время выполнения. Таким образом, он появляется не с элементами управления на поверхности конструктора, а скорее в **компоненте конструктора** (лоток в нижней части поверхности дизайнера).

5. В **компонент дизайнер**, нажмите **timer1**, а <xref:System.Windows.Forms.Timer.Enabled%2A> затем `true`установить свойство <xref:System.Windows.Forms.Timer.Interval%2A> `1000` и свойство .

     Свойство <xref:System.Windows.Forms.Timer.Interval%2A> контролирует частоту, <xref:System.Windows.Forms.Timer> с которой тикает компонент. При каждом такте `timer1` оно запускает код в событии `timer1_Tick`. Интервал представляет время между тактами в миллисекундах.

6. В **компонент дизайнер**, двойной клик **timer1,** чтобы пойти на `timer1_Tick` мероприятие для `ctlClock`.

7. Измените код, как показано в следующем примере. Измените модификатор доступа с `private` на `protected`.

    ```csharp
    protected void timer1_Tick(object sender, System.EventArgs e)
    {
        // Causes the label to display the current time.
        lblDisplay.Text = DateTime.Now.ToLongTimeString();
    }
    ```

     Этот код вызывает отображение текущего времени в `lblDisplay`. Поскольку для интервала `timer1` было задано значение `1000`, это событие возникает через каждую тысячу миллисекунд, а значит, текущее время обновляется каждую секунду.

8. Измените метод, разрешив его переопределение с помощью ключевого слова `virtual`. Дополнительные сведения см. ниже в разделе "Наследование из пользовательского элемента управления".

    ```csharp
    protected virtual void timer1_Tick(object sender, System.EventArgs e)
    ```

9. Сохраните проект, открыв меню **Файл** и выбрав пункт **Сохранить все**.

## <a name="add-properties-to-the-composite-control"></a>Добавление свойств в элементный контроль

Теперь управление часами инкапсулирует <xref:System.Windows.Forms.Label> элемент <xref:System.Windows.Forms.Timer> управления и компонент, каждый из которых имеет свой собственный набор присущих свойств. Несмотря на то что отдельные свойства этих элементов управления не будут доступны последующим пользователям вашего элемента управления, вы можете создать и предоставить настраиваемые свойства, написав соответствующие блоки кода. Выполняя следующую процедуру, вы добавите в элемент управления свойства, позволяющие пользователю изменять цвет фона и текста.

### <a name="to-add-a-property-to-your-composite-control"></a>Добавление свойства в составной элемент управления

1. В **Solution Explorer**, правой кнопкой мыши **ctlClock.cs**, а затем нажмите **Просмотреть код**.

     Открывается **редактор кода** для управления.

2. Найдите оператор `public partial class ctlClock`. Под открывающей скобкой (`{)` введите следующий код.

    ```csharp
    private Color colFColor;
    private Color colBColor;
    ```

     Эти операторы создают закрытые переменные для хранения значений свойств, которые вы собираетесь создать.

3. Введите или вставьте следующий код под переменными декларациями со шага 2.

    ```csharp
    // Declares the name and type of the property.
    public Color ClockBackColor
    {
        // Retrieves the value of the private variable colBColor.
        get
        {
            return colBColor;
        }
        // Stores the selected value in the private variable colBColor, and
        // updates the background color of the label control lblDisplay.
        set
        {
            colBColor = value;
            lblDisplay.BackColor = colBColor;
        }
    }
    // Provides a similar set of instructions for the foreground color.
    public Color ClockForeColor
    {
        get
        {
            return colFColor;
        }
        set
        {
            colFColor = value;
            lblDisplay.ForeColor = colFColor;
        }
    }
    ```

     Приведенный выше код обеспечивает доступ к двум настраиваемым свойствам, `ClockForeColor` и `ClockBackColor`, для последующих пользователей данного элемента управления. Операторы `get` и `set` позволяют хранить и извлекать значение свойства, а также предоставляют код для реализации соответствующих этому свойству функциональных возможностей.

4. Сохраните проект, открыв меню **Файл** и выбрав пункт **Сохранить все**.

## <a name="test-the-control"></a>Проверьте управление

Элементы управления не являются автономными приложениями и должны размещаться в контейнере. Проверьте поведение элемента управления в среде выполнения и испытайте его свойства в **тестовом контейнере пользовательских элементов управления**. Дополнительные сведения см. в разделе [Практическое руководство. Тестирование поведения элемента UserControl во время выполнения](how-to-test-the-run-time-behavior-of-a-usercontrol.md).

### <a name="to-test-your-control"></a>Проверка элемента управления

1. Нажмите **F5,** чтобы построить проект и запустить управление в **контейнере userControl Test Container.**

2. В таблице свойств тестового контейнера выберите свойство `ClockBackColor`, а затем свойство, чтобы открыть палитру цветов.

3. Щелкните нужный цвет.

   Цвет фона элемента управления изменится на выбранный.

4. Используя аналогичную последовательность событий, проверьте, функционирует ли свойство `ClockForeColor` должным образом.

   Из этого и предыдущих разделов вы узнали, как объединить компоненты и элементы управления Windows с кодом и упаковкой и, таким образом, предоставить настраиваемые функциональные возможности в виде составного элемента управления. Вы узнали, как вывести свойства в составной элемент управления и проверить элемент управления после того, как он будет готов. В следующем разделе вы узнаете, как сконструировать производный составной элемент управления, используя в качестве базы `ctlClock`.

## <a name="inherit-from-a-composite-control"></a>Унаследовать от композитного управления

В предыдущих разделах вы узнали, как объединить элементы управления, компоненты и код Windows в составные элементы управления, доступные для повторного использования. После этого составной элемент управления можно использовать как базу, на основе которой будут создаваться другие элементы управления. Процесс создания класса, производного от базового, называется *наследованием*. В этом разделе вы создадите составной элемент управления с именем `ctlAlarmClock`. Он будет производным от родительского элемента управления, `ctlClock`. Вы узнаете, как расширить функциональные возможности `ctlClock`, переопределив методы родительского класса и добавив новые методы и свойства.

Первый шаг в создании производного элемента управления — это его наследование из родительского элемента. Это действие создает новый элемент управления, обладающий всеми свойствами, методами и графическими характеристиками родительского элемента управления, а также может служить основой для добавления или изменения функциональных возможностей.

### <a name="to-create-the-inherited-control"></a>Создание производного элемента управления

1. В **Solution Explorer**, правой кнопкой мыши **ctlClockLib**, точка, чтобы **добавить,** а затем нажмите **пользовательский контроль**.

     Откроется диалоговое окно **Добавление нового элемента** .

2. Выберите шаблон **Производный пользовательский элемент управления**.

3. В поле **Имя** введите `ctlAlarmClock.cs` и нажмите кнопку **Добавить**.

     Откроется диалоговое окно **Выбор компонентов для наследования**.

4. В разделе **Имя компонента** дважды щелкните файл **ctlClock**.

5. В **Solution Explorer**просматривайте текущие проекты.

    > [!NOTE]
    > Файл с именем **элемент ctlAlarmClock. cs** будет добавлен в текущий проект.

### <a name="add-the-alarm-properties"></a>Добавить свойства сигнализации

Свойства, добавляются в производный элемент управления точно так же, как в составной элемент управления. Теперь, используя синтаксис объявления свойств, добавим в элемент управления два свойства: свойство `AlarmTime`, в котором хранится значение даты и времени отключения будильника, и свойство `AlarmSet`, определяющее время срабатывания будильника.

#### <a name="to-add-properties-to-your-composite-control"></a>Добавление свойств в составной элемент управления

1. В **Solution Explorer**, правой кнопкой мыши **ctlAlarmClock**, а затем нажмите **Просмотреть код**.

2. Найдите оператор `public class`. Обратите внимание, что элемент управления наследуется из `ctlClockLib.ctlClock`. Под открывающей скобкой оператора (`{)` введите следующий код.

    ```csharp
    private DateTime dteAlarmTime;
    private bool blnAlarmSet;
    // These properties will be declared as public to allow future
    // developers to access them.
    public DateTime AlarmTime
    {
        get
        {
            return dteAlarmTime;
        }
        set
        {
            dteAlarmTime = value;
        }
    }
    public bool AlarmSet
    {
        get
        {
            return blnAlarmSet;
        }
        set
        {
            blnAlarmSet = value;
        }
    }
    ```

### <a name="add-to-the-graphical-interface-of-the-control"></a>Добавить в графический интерфейс управления

Производный элемент управления получает такой же графический интерфейс, как у того элемента, из которого он наследуется. Кроме того, он включает те же составные элементы управления, что и родительский элемент управления, однако свойства этих составных элементов будут доступны, только если предоставить их напрямую. Графический интерфейс производного элемента управления добавляется точно так же, как и для любого составного элемента управления. Чтобы продолжить добавление графического интерфейса для будильника, добавим элемент управления Label, который будет мигать при срабатывании будильника.

#### <a name="to-add-the-label-control"></a>Добавление элемента управления Label

1. В **Solution Explorer**, правой кнопкой мыши **ctlAlarmClock**, а затем нажмите **Посмотреть Дизайнер**.

     Конструктор для `ctlAlarmClock` откроется в главном окне.

2. Нажмите на отображаемую область элемента управления и просмотрите окно свойств.

    > [!NOTE]
    > Все свойства отображаются, но недоступны. Это означает, что эти свойства являются собственными свойствами `lblDisplay`, в окне свойств изменить их или получить к ним доступ нельзя. По умолчанию элементы управления, входящие в составной элемент управления, имеют статус `private` и их свойства недоступны.

    > [!NOTE]
    > Чтобы последующие пользователи составного элемента управления получили доступ к входящим в него элементам управления, объявите их как `public` или `protected`. Это позволит вам задавать и изменять свойства элементов управления в составном элементе управления, используя соответствующий код.

3. Добавьте <xref:System.Windows.Forms.Label> элемент управления в композитный элемент управления.

4. Используя мышь, перетащите <xref:System.Windows.Forms.Label> элемент управления непосредственно под окном дисплея. В окне "Свойства" задайте следующие свойства.

    |Свойство|Параметр|
    |--------------|-------------|
    |**Название**|`lblAlarm`|
    |**Текст**|**Сигнализации!**|
    |**TextAlign**|`MiddleCenter`|
    |**Видны**|`false`|

### <a name="add-the-alarm-functionality"></a>Добавить функциональность сигнализации

Выполняя предыдущие процедуры, вы добавили свойства и элемент управления, которые обеспечат функциональность будильника в составном элементе управления. В ходе этой процедуры вы добавите код, который будет сравнивать текущее время со временем будильника и, если они совпадают, запускать мигающее оповещение. Переопределив метод `timer1_Tick` в `ctlClock` и добавив в него дополнительный код, вы расширите возможности `ctlAlarmClock`, сохранив при этом все унаследованные функции `ctlClock`.

#### <a name="to-override-the-timer1_tick-method-of-ctlclock"></a>Переопределение метода Timer1_Tick в ctlClock

1. В **редакторе кода** найдите оператор `private bool blnAlarmSet;`. Сразу после него добавьте следующий оператор.

    ```csharp
    private bool blnColorTicker;
    ```

2. В **редакторе кода** найдите закрывающую скобку (`})` в конце класса. Непосредственно перед скобкой добавьте следующий код.

    ```csharp
    protected override void timer1_Tick(object sender, System.EventArgs e)
    {
        // Calls the Timer1_Tick method of ctlClock.
        base.timer1_Tick(sender, e);
        // Checks to see if the alarm is set.
        if (AlarmSet == false)
            return;
        else
            // If the date, hour, and minute of the alarm time are the same as
            // the current time, flash an alarm.
        {
            if (AlarmTime.Date == DateTime.Now.Date && AlarmTime.Hour ==
                DateTime.Now.Hour && AlarmTime.Minute == DateTime.Now.Minute)
            {
                // Sets lblAlarmVisible to true, and changes the background color based on
                // the value of blnColorTicker. The background color of the label
                // will flash once per tick of the clock.
                lblAlarm.Visible = true;
                if (blnColorTicker == false)
                {
                    lblAlarm.BackColor = Color.Red;
                    blnColorTicker = true;
                }
                else
                {
                    lblAlarm.BackColor = Color.Blue;
                    blnColorTicker = false;
                }
            }
            else
            {
                // Once the alarm has sounded for a minute, the label is made
                // invisible again.
                lblAlarm.Visible = false;
            }
        }
    }
    ```

     Добавление этого кода решает сразу несколько задач. Оператор `override` указывает элементу управления использовать этот метод вместо метода, унаследованного из базового элемента управления. При вызове этого метода он вызывает переопределяемый метод, используя оператор `base.timer1_Tick`, и следит за тем, чтобы в этом элементе управления были реализованы все функции исходного элемента управления. Затем он выполняет дополнительный код, реализующий функции будильника. Когда будильник срабатывает, появляется мигающая метка.

     Элемент управления "Будильник" почти готов. Осталось реализовать только его отключение. Для этого нужно добавить код в метод `lblAlarm_Click`.

#### <a name="to-implement-the-shutoff-method"></a>Реализация метода отключения

1. В **Solution Explorer**, правой кнопкой мыши **ctlAlarmClock.cs**, а затем нажмите **Посмотреть Дизайнер**.

     Откроется конструктор.

2. Добавьте кнопку в элемент управления. Задайте свойства для этой кнопки следующим образом.

    |Свойство|Значение|
    |--------------|-----------|
    |**Название**|`btnAlarmOff`|
    |**Текст**|**Отключить оповещение**|

3. В конструкторе дважды щелкните элемент управления **btnAlarmOff**.

     Откроется **редактор кода** со строкой `private void btnAlarmOff_Click`.

4. Измените метод, как показано в следующем коде.

    ```csharp
    private void btnAlarmOff_Click(object sender, System.EventArgs e)
    {
        // Turns off the alarm.
        AlarmSet = false;
        // Hides the flashing label.
        lblAlarm.Visible = false;
    }
    ```

5. Сохраните проект, открыв меню **Файл** и выбрав пункт **Сохранить все**.

### <a name="use-the-inherited-control-on-a-form"></a>Используйте унаследованный контроль на форме

Вы можете проверить наследственный контроль так же, `ctlClock`как вы протестировали элемент управления базовым классом: Нажмите **F5,** чтобы построить проект и запустить управление в **контейнере userControl Test Container.** Дополнительные сведения см. в разделе [Практическое руководство. Тестирование поведения элемента UserControl во время выполнения](how-to-test-the-run-time-behavior-of-a-usercontrol.md).

Чтобы элемент управления можно было использовать, необходимо поместить его в форму. Производный составной элемент управления, как и стандартный, не может быть автономным и должен быть размещен в форме или другом контейнере. Поскольку `ctlAlarmClock` отличается более широкими функциональными возможностями, для его проверки требуется дополнительный код. В ходе этой процедуры вы напишете простую программу для проверки функциональных возможностей `ctlAlarmClock`. Вы напишете код, задающий и отображающий свойство `AlarmTime` в `ctlAlarmClock` и проверяющий его унаследованные функции.

#### <a name="to-build-and-add-your-control-to-a-test-form"></a>Сборка и добавление элемента управления в тестовую форму

1. В **Solution Explorer**, правой кнопкой мыши **ctlClockLib**, а затем нажмите **на сборку**.

2. Добавьте в решение новый проект **приложения Windows Forms** и назовите его **Test.**

3. В **Solution Explorer**, правой кнопкой **ссылки** узла для вашего тестового проекта. Щелкните **Добавить ссылку**, чтобы открыть диалоговое окно **Добавление ссылки**. Выберите вкладку **Проекты**. Проект `ctlClockLib` будет указан под полем **Имя проекта**. Дважды щелкните проект, чтобы добавить ссылку на тестовый проект.

4. В **Solution Explorer**, право-нажмите **тест**, а затем нажмите **на сборку**.

5. На **панели элементов** разверните узел **Компоненты ctlClockLib**.

6. Дважды щелкните **ctlAlarmClock**, чтобы добавить копию `ctlAlarmClock` в свою форму.

7. В **Toolbox**, найти и дважды щелкните **DateTimePicker,** чтобы добавить <xref:System.Windows.Forms.DateTimePicker> элемент управления в вашей форме, а затем добавить <xref:System.Windows.Forms.Label> контроль, дважды нажав **этикетке**.

8. С помощью мыши разместите элементы управления в удобном месте формы.

9. Задайте свойства этих элементов управления следующим образом.

    |Control|Свойство|Значение|
    |-------------|--------------|-----------|
    |`label1`|**Текст**|`(blank space)`|
    ||**Название**|`lblTest`|
    |`dateTimePicker1`|**Название**|`dtpTest`|
    ||**Формат**|<xref:System.Windows.Forms.DateTimePickerFormat.Time>|

10. В конструкторе дважды щелкните **dtpTest**.

     В **редакторе кода** откроется `private void dtpTest_ValueChanged`.

11. Измените код, как показано в следующем примере.

    ```csharp
    private void dtpTest_ValueChanged(object sender, System.EventArgs e)
    {
        ctlAlarmClock1.AlarmTime = dtpTest.Value;
        ctlAlarmClock1.AlarmSet = true;
        lblTest.Text = "Alarm Time is " +
            ctlAlarmClock1.AlarmTime.ToShortTimeString();
    }
    ```

12. В **Solution Explorer**, право-нажмите **тест**, а затем нажмите **Установить как StartUp проекта**.

13. В меню **Debug** щелкните **Start Debugging.**

     Запустится тестовая программа. Обратите внимание, что текущее `ctlAlarmClock` время обновляется в элементе <xref:System.Windows.Forms.DateTimePicker> управления, и что время начала отображается в элементе управления.

14. Нажмите <xref:System.Windows.Forms.DateTimePicker> на место отображения минут часа.

15. С помощью клавиатуры укажите значение минут, составляющее на одну минуту больше текущего времени, отображаемого `ctlAlarmClock`.

     Время включения будильника отображается в `lblTest`. Дождитесь момента, когда отображаемое время совпадет с установленным временем будильника. Когда это произойдет, `lblAlarm` начнет мигать.

16. Отключите сигнал, нажав `btnAlarmOff`. Теперь будильник можно сбросить.

Эта статья охватывает ряд ключевых концепций. Вы узнали, как создать составной элемент управления, объединив элементы управления и компоненты в контейнер составного элемента управления. Вы узнали, как добавить свойства в элемент управления и написать код для реализации настраиваемых функциональных возможностей. В последнем разделе вы узнали, как расширять функциональные возможности заданного составного элемента управления с помощью наследования и как изменять функциональные возможности методов узла путем переопределения методов.

## <a name="see-also"></a>См. также раздел

- [Создание собственных элементов управления](varieties-of-custom-controls.md)
- [Практическое руководство. Отображение элемента управления в диалоговом окне выбора элементов панели элементов](how-to-display-a-control-in-the-choose-toolbox-items-dialog-box.md)
- [Прохождение: Наследовать от управления формами Windows с визуальным C #](walkthrough-inheriting-from-a-windows-forms-control-with-visual-csharp.md)
