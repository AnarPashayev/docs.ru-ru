---
title: Копирование и закрепление
ms.date: 03/30/2017
helpviewer_keywords:
- pinning, interop marshaling
- copying, interop marshaling
- interop marshaling, copying
- interop marshaling, pinning
ms.assetid: 0059f576-e460-4e70-b257-668870e420b8
ms.openlocfilehash: f6db7d37293015911c1285d39e19bf7542a7ac59
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/30/2019
ms.locfileid: "73123645"
---
# <a name="copying-and-pinning"></a>Копирование и закрепление

При маршалировании данных маршалер может копировать или закреплять включаемые в процесс данные. В ходе этого процесса копия данных переносится из одного расположения в памяти в другое. На следующем рисунке показаны различия между копированием типа значения и типа, передаваемого по ссылке, из управляемой памяти в неуправляемую.

![Схема, на которой показано, как копируются тип значения и ссылочный тип.](./media/copying-and-pinning/interop-marshal-copy.gif)

Аргументы метода, передаваемые по значению, маршалируются в неуправляемый код как значения в стеке. Процесс копирования является прямым. Аргументы, передаваемые по ссылке, передаются как указатели на стек. Ссылочные типы также могут передаваться по значению и по ссылке. Как показано на следующем рисунке, ссылочные типы, передаваемые по значению, либо копируются, либо закрепляются.

![Схема, на которой показаны ссылочные типы, передаваемые по значению и по ссылке.](./media/copying-and-pinning/interop-marshal-reference-pin.gif)

При закреплении данные временно блокируются в текущем положении в памяти, в результате чего исключается их перемещение стандартным сборщиком мусора общеязыковой среды выполнения. Маршалер закрепляет данные, чтобы сократить затраты ресурсов на копирование и повысить производительность. Копирование или закрепление данных в рамках процесса маршалинга осуществляется в зависимости от типа этих данных.  Закрепление автоматически выполняется во время маршалинга для таких объектов, как <xref:System.String>. Также их можно закрепить вручную с использованием класса <xref:System.Runtime.InteropServices.GCHandle>.

## <a name="formatted-blittable-classes"></a>Форматированные непреобразуемые классы

Форматированные [непреобразуемые](blittable-and-non-blittable-types.md) классы имеют фиксированную структуру (форматирование) и общее представление данных как в управляемой, так и в неуправляемой памяти. Если требуется выполнить маршалинг таких типов, вызываемому объекту напрямую передается указатель на объект в куче. Вызываемый объект может изменять содержимое в расположении в памяти, на которое ссылается указатель.

> [!NOTE]
> Вызываемый объект может изменить содержимое памяти, если параметр помечен как out или in/out. В отличие от этого вызываемый объект должен избегать изменения содержимого, если параметру присвоено значение Marshal, как в, что является значением по умолчанию для отформатированных непреобразуемых типов. Если объект ввода изменяется, это может привести к проблемам при экспорте того же класса в библиотеку типов и его использовании для выполнения вызовов между подразделениями.

## <a name="formatted-non-blittable-classes"></a>Форматированные преобразуемые классы

Форматированные [преобразуемые](blittable-and-non-blittable-types.md) классы имеют фиксированную структуру (форматирование), но разное представление данных в управляемой и неуправляемой памяти. В следующих ситуациях может потребоваться преобразование данных:

- Если преобразуемый класс маршалируется по значению, вызываемый объект получает указатель на копию структуры данных.

- Если преобразуемый класс маршалируется по ссылке, вызываемый объект получает указатель на указатель на копию структуры данных.

- Если установлен атрибут <xref:System.Runtime.InteropServices.InAttribute>, для инициализации этой копии всегда используется состояние экземпляра и при необходимости выполняется маршалинг.

- Если установлен атрибут <xref:System.Runtime.InteropServices.OutAttribute>, состояние всегда копируется обратно в экземпляр при возврате и при необходимости выполняется маршалинг.

- Если установлены одновременно атрибуты **InAttribute** и **OutAttribute**, обе операции копирования выполняются обязательно. Если один из атрибутов опущен, в целях оптимизации маршалер может исключить другую операцию копирования.

## <a name="reference-types"></a>Ссылочные типы

Ссылочные типы могут передаваться по значению или по ссылке. При передаче по значению в стек передается указатель на тип. При передаче по ссылке в стек передается указатель на указатель на тип.

Ссылочные типы имеют следующие условные характеристики:

- Если ссылочный тип передается по значению и содержит члены преобразуемых типов, типы преобразуются дважды:

  - Когда аргумент передается в неуправляемый код.

  - При возврате из вызова.

  Чтобы исключить лишние операции копирования и преобразования, эти типы маршалируются как параметры ввода. Чтобы вызывающий объект мог видеть изменения, выполненные вызывающим объектом, необходимо явно применить атрибуты **InAttribute** и **OutAttribute** к аргументу.

- Если ссылочный тип передается по значению и содержит только члены непреобразуемых типов, он может быть закреплен в процессе маршалирования, а любые изменения членов типа, выполненные вызываемым объектом, будут видны вызывающему объекту. Чтобы реализовать такое поведение, явно примените атрибуты **InAttribute** и **OutAttribute**. Без этих атрибутов направления маршалер взаимодействия не экспортирует информацию о направлении в библиотеку типов (экспортируется как параметр ввода, то есть реализуется поведение по умолчанию), что может вызвать проблемы с маршалингом COM между подразделениями.

- Если ссылочный тип передается по ссылке, он будет по умолчанию маршалироваться как параметр ввода-вывода.

## <a name="systemstring-and-systemtextstringbuilder"></a>System.String и System.Text.StringBuilder

При маршалинге данных в неуправляемый код по значению или по ссылке маршалер обычно копирует данные во вторичный буфер (в процессе копирования может выполняться преобразование кодировки) и передает вызываемому объекту ссылку на буфер. Если ссылка не является объектом **BSTR** (для выделения используется **SysAllocString**), выделение памяти всегда осуществляется с помощью **CoTaskMemAlloc**.

В целях оптимизации при маршалинге строк любого типа по значению (например, строка символов Юникода) маршалер передает вызываемому объекту прямой указатель на управляемые строки во внутреннем буфере Юникода вместо копирования в новый буфер.

> [!CAUTION]
> Если строка передается по значению, вызываемый объект не должен изменять ссылку, передаваемую маршалером. Это может привести к повреждению управляемой кучи.

Если <xref:System.String?displayProperty=nameWithType> передается по ссылке, маршалер копирует содержимое строки во вторичный буфер, прежде чем выполнять вызов. После этого содержимое буфера копируется в новую строку при возврате из вызова. Такой подход гарантирует, что неизменяемая управляемая строка останется без изменений.

Если <xref:System.Text.StringBuilder?displayProperty=nameWithType> передается по значению, маршалер передает ссылку на внутренний буфер **StringBuilder** напрямую вызывающему объекту. Вызывающий и вызываемый объекты должны согласовывать размер буфера. Вызывающий объект отвечает за создание буфера **StringBuilder** соответствующей длины. Вызываемый объект должен принимать необходимые меры предосторожности, чтобы предотвратить переполнение буфера. **StringBuilder** является исключением из правила, согласно которому ссылочные типы, передаваемые по значению, по умолчанию передаются в виде параметра ввода. Он всегда передается как параметр ввода-вывода.

## <a name="see-also"></a>См. также

- [Характеристики маршалинга по умолчанию](default-marshaling-behavior.md)
- [Directional Attributes](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/77e6taeh(v=vs.100)) (Атрибуты направления)
- [Маршалинг взаимодействия](interop-marshaling.md)
