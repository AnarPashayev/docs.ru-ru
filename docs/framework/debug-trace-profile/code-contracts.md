---
title: Контракты для кода
description: Изучите контракты кода, которые предоставляют способ указания предусловий, постусловий и инвариантов объектов в коде .NET.
ms.date: 09/05/2018
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Code contracts
ms.assetid: 84526045-496f-489d-8517-a258cf76f040
ms.openlocfilehash: 60f794373af75bd3f745c224e0a8c7a84192e4c4
ms.sourcegitcommit: 3824ff187947572b274b9715b60c11269335c181
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/17/2020
ms.locfileid: "84904147"
---
# <a name="code-contracts"></a><span data-ttu-id="df62c-103">Контракты для кода</span><span class="sxs-lookup"><span data-stu-id="df62c-103">Code Contracts</span></span>

<span data-ttu-id="df62c-104">Контракты для кода предоставляют способ указания предусловий, постусловий и инвариантов объектов в коде.</span><span class="sxs-lookup"><span data-stu-id="df62c-104">Code contracts provide a way to specify preconditions, postconditions, and object invariants in your code.</span></span> <span data-ttu-id="df62c-105">Предусловия — это требования, которые должны быть выполнены при входе в метод или свойство.</span><span class="sxs-lookup"><span data-stu-id="df62c-105">Preconditions are requirements that must be met when entering a method or property.</span></span> <span data-ttu-id="df62c-106">Постусловия описывают ожидания во время выхода из кода метода или свойства.</span><span class="sxs-lookup"><span data-stu-id="df62c-106">Postconditions describe expectations at the time the method or property code exits.</span></span> <span data-ttu-id="df62c-107">Инварианты объектов описывают ожидаемое состояние класса, который находится в рабочем состоянии.</span><span class="sxs-lookup"><span data-stu-id="df62c-107">Object invariants describe the expected state for a class that is in a good state.</span></span>

<span data-ttu-id="df62c-108">Контракты для кода содержат классы для маркировки кода, статический анализатор для анализа во время компиляции и анализатор времени выполнения.</span><span class="sxs-lookup"><span data-stu-id="df62c-108">Code contracts include classes for marking your code, a static analyzer for compile-time analysis, and a runtime analyzer.</span></span> <span data-ttu-id="df62c-109">Классы для контрактов для кода можно найти в пространстве имен <xref:System.Diagnostics.Contracts>.</span><span class="sxs-lookup"><span data-stu-id="df62c-109">The classes for code contracts can be found in the <xref:System.Diagnostics.Contracts> namespace.</span></span>

<span data-ttu-id="df62c-110">Среди преимуществ контрактов для кода можно назвать следующие.</span><span class="sxs-lookup"><span data-stu-id="df62c-110">The benefits of code contracts include the following:</span></span>

- <span data-ttu-id="df62c-111">Улучшенное тестирование. Контракты для кода обеспечивают проверку статических контрактов, проверку во время выполнения и создание документации.</span><span class="sxs-lookup"><span data-stu-id="df62c-111">Improved testing: Code contracts provide static contract verification, runtime checking, and documentation generation.</span></span>

- <span data-ttu-id="df62c-112">Автоматические средства тестирования. Контракты для кода можно использовать для создания более осмысленных модульных тестов, отфильтровывая не имеющие значения аргументы тестирования, не удовлетворяющие предусловиям.</span><span class="sxs-lookup"><span data-stu-id="df62c-112">Automatic testing tools: You can use code contracts to generate more meaningful unit tests by filtering out meaningless test arguments that do not satisfy preconditions.</span></span>

- <span data-ttu-id="df62c-113">Статическая проверка. Средство статической проверки может определять, имеются ли нарушения контракта, без запуска программы.</span><span class="sxs-lookup"><span data-stu-id="df62c-113">Static verification: The static checker can decide whether there are any contract violations without running the program.</span></span> <span data-ttu-id="df62c-114">Оно проверяет неявные контракты, такие как пустые разыменования и границы массивов, а также явные контракты.</span><span class="sxs-lookup"><span data-stu-id="df62c-114">It checks for implicit contracts, such as null dereferences and array bounds, and explicit contracts.</span></span>

- <span data-ttu-id="df62c-115">Справочная документация. Генератор документации расширяет существующие XML-файлы документации, добавляя сведения о контрактах.</span><span class="sxs-lookup"><span data-stu-id="df62c-115">Reference documentation: The documentation generator augments existing XML documentation files with contract information.</span></span> <span data-ttu-id="df62c-116">Со средством [Sandcastle](https://github.com/EWSoftware/SHFB) также можно использовать таблицы стилей, чтобы сформированные страницы документации содержали разделы контрактов.</span><span class="sxs-lookup"><span data-stu-id="df62c-116">There are also style sheets that can be used with [Sandcastle](https://github.com/EWSoftware/SHFB) so that the generated documentation pages have contract sections.</span></span>

<span data-ttu-id="df62c-117">Все языки платформы .NET Framework могут немедленно воспользоваться преимуществами контрактов; не требуется создавать специальное средство синтаксического анализа или компилятор.</span><span class="sxs-lookup"><span data-stu-id="df62c-117">All .NET Framework languages can immediately take advantage of contracts; you do not have to write a special parser or compiler.</span></span> <span data-ttu-id="df62c-118">Надстройка Visual Studio позволяет задать уровень выполняемого анализа контракта для кода.</span><span class="sxs-lookup"><span data-stu-id="df62c-118">A Visual Studio add-in lets you specify the level of code contract analysis to be performed.</span></span> <span data-ttu-id="df62c-119">Анализаторы могут подтвердить, что контракты сформированы правильно (путем проверки типов и разрешения имен), и могут создавать скомпилированную форму контрактов в формате MSIL.</span><span class="sxs-lookup"><span data-stu-id="df62c-119">The analyzers can confirm that the contracts are well-formed (type checking and name resolution) and can produce a compiled form of the contracts in Microsoft intermediate language (MSIL) format.</span></span> <span data-ttu-id="df62c-120">Разработка контрактов в Visual Studio позволяет использовать преимущества стандартной технологии IntelliSense, предоставляемой этим средством.</span><span class="sxs-lookup"><span data-stu-id="df62c-120">Authoring contracts in Visual Studio lets you take advantage of the standard IntelliSense provided by the tool.</span></span>

<span data-ttu-id="df62c-121">Большинство методов в классе контракта являются условно скомпилированными; то есть компилятор выдает вызовы этих методов, только если вы задаете специальный символ, CONTRACTS_FULL, с помощью директивы `#define`.</span><span class="sxs-lookup"><span data-stu-id="df62c-121">Most methods in the contract class are conditionally compiled; that is, the compiler emits calls to these methods only when  you define a special symbol, CONTRACTS_FULL, by using the `#define` directive.</span></span> <span data-ttu-id="df62c-122">CONTRACTS_FULL позволяет писать контракты в коде без использования директивы `#ifdef`; вы можете создавать различные сборки, как с контрактами, так и без.</span><span class="sxs-lookup"><span data-stu-id="df62c-122">CONTRACTS_FULL lets you write contracts in your code without using `#ifdef` directives; you can produce different builds, some with contracts, and some without.</span></span>

<span data-ttu-id="df62c-123">Средства и подробные инструкции по использованию контрактов кода см. в разделе [контракты кода](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) на сайте Visual Studio Marketplace.</span><span class="sxs-lookup"><span data-stu-id="df62c-123">For tools and detailed instructions for using code contracts, see [Code Contracts](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) on the Visual Studio marketplace site.</span></span>

## <a name="preconditions"></a><span data-ttu-id="df62c-124">Preconditions</span><span class="sxs-lookup"><span data-stu-id="df62c-124">Preconditions</span></span>

<span data-ttu-id="df62c-125">Предусловия можно выразить с помощью метода <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="df62c-125">You can express preconditions by using the <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="df62c-126">Предусловия задают состояние при вызове метода.</span><span class="sxs-lookup"><span data-stu-id="df62c-126">Preconditions specify state when a method is invoked.</span></span> <span data-ttu-id="df62c-127">Обычно они используются для указания допустимых значений параметров.</span><span class="sxs-lookup"><span data-stu-id="df62c-127">They are generally used to specify valid parameter values.</span></span> <span data-ttu-id="df62c-128">Все члены, упомянутые в предусловиях, должны быть не менее доступны, чем сам метод; в противном случае предусловие может быть не понято всеми объектами, вызывающими метод.</span><span class="sxs-lookup"><span data-stu-id="df62c-128">All members that are mentioned in preconditions must be at least as accessible as the method itself; otherwise, the precondition might not be understood by all callers of a method.</span></span> <span data-ttu-id="df62c-129">Условие не должно иметь побочных эффектов.</span><span class="sxs-lookup"><span data-stu-id="df62c-129">The condition must have no side-effects.</span></span> <span data-ttu-id="df62c-130">Поведение невыполненных предусловий во время выполнения определяется анализатором времени выполнения.</span><span class="sxs-lookup"><span data-stu-id="df62c-130">The run-time behavior of failed preconditions is determined by the runtime analyzer.</span></span>

<span data-ttu-id="df62c-131">Например, следующее предусловие указывает, что параметр `x` не должен иметь значение null.</span><span class="sxs-lookup"><span data-stu-id="df62c-131">For example, the following precondition expresses that parameter `x` must be non-null.</span></span>

```csharp
Contract.Requires(x != null);
```

<span data-ttu-id="df62c-132">Если код должен вызывать конкретное исключение при сбое предусловия, можно использовать универсальную перегрузку <xref:System.Diagnostics.Contracts.Contract.Requires%2A> следующим образом.</span><span class="sxs-lookup"><span data-stu-id="df62c-132">If your code must throw a particular exception on failure of a precondition, you can use the generic overload of <xref:System.Diagnostics.Contracts.Contract.Requires%2A> as follows.</span></span>

```csharp
Contract.Requires<ArgumentNullException>(x != null, "x");
```

### <a name="legacy-requires-statements"></a><span data-ttu-id="df62c-133">Устаревшие операторы Requires</span><span class="sxs-lookup"><span data-stu-id="df62c-133">Legacy Requires Statements</span></span>

<span data-ttu-id="df62c-134">Большая часть кода содержит определенную проверку параметров в виде кода `if`-`then`-`throw`.</span><span class="sxs-lookup"><span data-stu-id="df62c-134">Most code contains some parameter validation in the form of `if`-`then`-`throw` code.</span></span> <span data-ttu-id="df62c-135">Средства контракта распознают эти операторы как предусловия в следующих случаях:</span><span class="sxs-lookup"><span data-stu-id="df62c-135">The contract tools recognize these statements as preconditions in the following cases:</span></span>

- <span data-ttu-id="df62c-136">эти операторы появляются перед всеми остальными операторами в методе;</span><span class="sxs-lookup"><span data-stu-id="df62c-136">The statements appear before any other statements in a method.</span></span>

- <span data-ttu-id="df62c-137">после всего набора таких операторов следует явный вызов метода <xref:System.Diagnostics.Contracts.Contract>, например вызов метода <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A> или <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>.</span><span class="sxs-lookup"><span data-stu-id="df62c-137">The entire set of such statements is followed by an explicit <xref:System.Diagnostics.Contracts.Contract> method call, such as a call to the <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, or <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> method.</span></span>

<span data-ttu-id="df62c-138">Если операторы `if`-`then`-`throw` появляются в этой форме, средства распознают их как устаревшие операторы `requires`.</span><span class="sxs-lookup"><span data-stu-id="df62c-138">When `if`-`then`-`throw` statements appear in this form, the tools recognize them as legacy `requires` statements.</span></span> <span data-ttu-id="df62c-139">Если за последовательностью `if`-`then`-`throw` не следуют никакие другие контракты, завершите код методом <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="df62c-139">If no other contracts follow the `if`-`then`-`throw` sequence, end the code with the <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=nameWithType> method.</span></span>

```csharp
if (x == null) throw new ...
Contract.EndContractBlock(); // All previous "if" checks are preconditions
```

<span data-ttu-id="df62c-140">Обратите внимание, что условие в предыдущем тесте является предусловием с отрицанием.</span><span class="sxs-lookup"><span data-stu-id="df62c-140">Note that the condition in the preceding test is a negated precondition.</span></span> <span data-ttu-id="df62c-141">(Фактическое предусловие будет иметь значение `x != null` .) Предварительное условие с отрицанием имеет высокий уровень ограничений: оно должно быть написано, как показано в предыдущем примере. то есть он не должен содержать никаких `else` предложений, а тело `then` предложения должно быть единственной `throw` инструкцией.</span><span class="sxs-lookup"><span data-stu-id="df62c-141">(The actual precondition would be `x != null`.) A negated precondition is highly restricted: It must be written as shown in the previous example; that is, it should contain no `else` clauses, and the body of the `then` clause must be a single `throw` statement.</span></span> <span data-ttu-id="df62c-142">Тест `if` подчиняется правилам чистоты и видимости (см. раздел [Правила использования](#usage_guidelines)), но выражение `throw` подчиняется только правилам чистоты.</span><span class="sxs-lookup"><span data-stu-id="df62c-142">The `if` test is subject to both purity and visibility rules (see [Usage Guidelines](#usage_guidelines)), but the `throw` expression is subject only to purity rules.</span></span> <span data-ttu-id="df62c-143">Однако тип вызываемого исключения должен быть так же видим, как и метод, в котором возникает контракт.</span><span class="sxs-lookup"><span data-stu-id="df62c-143">However, the type of the exception thrown must be as visible as the method in which the contract occurs.</span></span>

## <a name="postconditions"></a><span data-ttu-id="df62c-144">Постусловия</span><span class="sxs-lookup"><span data-stu-id="df62c-144">Postconditions</span></span>

<span data-ttu-id="df62c-145">Постусловия — это контракты для состояния метода при его завершении.</span><span class="sxs-lookup"><span data-stu-id="df62c-145">Postconditions are contracts for the state of a method when it terminates.</span></span> <span data-ttu-id="df62c-146">Постусловие проверяется непосредственно перед выходом из метода.</span><span class="sxs-lookup"><span data-stu-id="df62c-146">The postcondition is checked just before exiting a method.</span></span> <span data-ttu-id="df62c-147">Поведение невыполненных постусловий во время выполнения определяется анализатором времени выполнения.</span><span class="sxs-lookup"><span data-stu-id="df62c-147">The run-time behavior of failed postconditions is determined by the runtime analyzer.</span></span>

<span data-ttu-id="df62c-148">В отличие от предусловий постусловия могут ссылаться на члены с меньшей видимостью.</span><span class="sxs-lookup"><span data-stu-id="df62c-148">Unlike preconditions, postconditions may reference members with less visibility.</span></span> <span data-ttu-id="df62c-149">Клиент может быть не в состоянии понять или использовать некоторые сведения, выраженные постусловием с помощью закрытого состояния, но это не влияет на возможность клиента правильно использовать этот метод.</span><span class="sxs-lookup"><span data-stu-id="df62c-149">A client may not be able to understand or make use of some of the information expressed by a postcondition using private state, but this does not affect the client's ability to use the method correctly.</span></span>

### <a name="standard-postconditions"></a><span data-ttu-id="df62c-150">Стандартные постусловия</span><span class="sxs-lookup"><span data-stu-id="df62c-150">Standard Postconditions</span></span>

<span data-ttu-id="df62c-151">Стандартные постусловия можно выразить с помощью метода <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>.</span><span class="sxs-lookup"><span data-stu-id="df62c-151">You can express standard postconditions by using the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> method.</span></span> <span data-ttu-id="df62c-152">Постусловия выражают условие, которое должно быть `true` при нормальном завершении метода.</span><span class="sxs-lookup"><span data-stu-id="df62c-152">Postconditions express a condition that must be `true` upon normal termination of the method.</span></span>

```csharp
Contract.Ensures(this.F > 0);
```

### <a name="exceptional-postconditions"></a><span data-ttu-id="df62c-153">Исключительные постусловия</span><span class="sxs-lookup"><span data-stu-id="df62c-153">Exceptional Postconditions</span></span>

<span data-ttu-id="df62c-154">Исключительные постусловия — это постусловия, которые должны быть `true`, когда метод вызывает конкретное исключение.</span><span class="sxs-lookup"><span data-stu-id="df62c-154">Exceptional postconditions are postconditions that should be `true` when a particular exception is thrown by a method.</span></span> <span data-ttu-id="df62c-155">Эти постусловия можно задать с помощью метода <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=nameWithType>, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="df62c-155">You can specify these postconditions by using the <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=nameWithType> method, as the following example shows.</span></span>

```csharp
Contract.EnsuresOnThrow<T>(this.F > 0);
```

<span data-ttu-id="df62c-156">Аргумент является условием, которое должно быть `true` всякий раз, когда вызывается исключение, являющееся подтипом `T`.</span><span class="sxs-lookup"><span data-stu-id="df62c-156">The argument is the condition that must be `true` whenever an exception that is a subtype of `T` is thrown.</span></span>

<span data-ttu-id="df62c-157">Существует несколько типов исключений, которые сложно использовать в исключительном постусловии.</span><span class="sxs-lookup"><span data-stu-id="df62c-157">There are some exception types that are difficult to use in an exceptional postcondition.</span></span> <span data-ttu-id="df62c-158">Например, чтобы использовать тип <xref:System.Exception> для `T`, необходимо, чтобы метод гарантировал выполнение условия независимо от типа вызываемого им исключения, даже если оно является переполнением стека или другим неконтролируемым исключением.</span><span class="sxs-lookup"><span data-stu-id="df62c-158">For example, using the type <xref:System.Exception> for `T` requires the method to guarantee the condition regardless of the type of exception that is thrown, even if it is a stack overflow or other impossible-to-control exception.</span></span> <span data-ttu-id="df62c-159">Исключительные постусловия следует использовать только для определенных исключений, которые могут создаваться при вызове члена, например когда создается исключение <xref:System.InvalidTimeZoneException> для вызова метода <xref:System.TimeZoneInfo>.</span><span class="sxs-lookup"><span data-stu-id="df62c-159">You should use exceptional postconditions only for specific exceptions that might be thrown when a member is called, for example, when an <xref:System.InvalidTimeZoneException> is thrown for a <xref:System.TimeZoneInfo> method call.</span></span>

### <a name="special-postconditions"></a><span data-ttu-id="df62c-160">Особые постусловия</span><span class="sxs-lookup"><span data-stu-id="df62c-160">Special Postconditions</span></span>

<span data-ttu-id="df62c-161">Следующие методы могут использоваться только в постусловиях.</span><span class="sxs-lookup"><span data-stu-id="df62c-161">The following methods may be used only within postconditions:</span></span>

- <span data-ttu-id="df62c-162">Вы можете ссылаться на возвращаемые значения метода в постусловиях с помощью выражения `Contract.Result<T>()`, где `T` заменяется типом возвращаемого значения метода.</span><span class="sxs-lookup"><span data-stu-id="df62c-162">You can refer to method return values in postconditions by using the expression `Contract.Result<T>()`, where `T` is replaced by the return type of the method.</span></span> <span data-ttu-id="df62c-163">Когда компилятор не может вывести тип, необходимо предоставить его явно.</span><span class="sxs-lookup"><span data-stu-id="df62c-163">When the compiler is unable to infer the type, you must explicitly provide it.</span></span> <span data-ttu-id="df62c-164">Например, компилятор C# не может вывести типы для методов, которые не принимают аргументы, поэтому для него требуется следующее постусловие: `Contract.Ensures(0 <Contract.Result<int>())`. Методы с типом возвращаемого значения `void` не могут ссылаться на `Contract.Result<T>()` в своих постусловиях.</span><span class="sxs-lookup"><span data-stu-id="df62c-164">For example, the C# compiler is unable to infer types for methods that do not take any arguments, so it requires the following postcondition: `Contract.Ensures(0 <Contract.Result<int>())` Methods with a return type of `void` cannot refer to `Contract.Result<T>()` in their postconditions.</span></span>

- <span data-ttu-id="df62c-165">Значение предсостояния в постусловии ссылается на значение выражения в начале метода или свойства.</span><span class="sxs-lookup"><span data-stu-id="df62c-165">A prestate value in a postcondition refers to the value of an expression at the start of a method or property.</span></span> <span data-ttu-id="df62c-166">Оно использует выражение `Contract.OldValue<T>(e)`, где `T` — тип `e`.</span><span class="sxs-lookup"><span data-stu-id="df62c-166">It uses the expression `Contract.OldValue<T>(e)`, where `T` is the type of `e`.</span></span> <span data-ttu-id="df62c-167">Вы можете опустить аргумент универсального типа там, где компилятор способен вывести его тип.</span><span class="sxs-lookup"><span data-stu-id="df62c-167">You can omit the generic type argument whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="df62c-168">(Например, компилятор C# всегда определяет тип, так как он принимает аргумент.) Существует несколько ограничений на то, что может произойти в `e` , и о контекстах, в которых может отображаться старое выражение.</span><span class="sxs-lookup"><span data-stu-id="df62c-168">(For example, the C# compiler always infers the type because it takes an argument.) There are several restrictions on what can occur in `e` and the contexts in which an old expression may appear.</span></span> <span data-ttu-id="df62c-169">Старое выражение не может содержать другое старое выражение.</span><span class="sxs-lookup"><span data-stu-id="df62c-169">An old expression cannot contain another old expression.</span></span> <span data-ttu-id="df62c-170">Самое главное, старое выражение должно ссылаться на значение, существовавшее в состоянии предусловия метода.</span><span class="sxs-lookup"><span data-stu-id="df62c-170">Most importantly, an old expression must refer to a value that existed in the method's precondition state.</span></span> <span data-ttu-id="df62c-171">Другими словами, это должно быть выражение, которое можно вычислить, пока предусловие метода имеет значение `true`.</span><span class="sxs-lookup"><span data-stu-id="df62c-171">In other words, it must be an expression that can be evaluated as long as the method's precondition is `true`.</span></span> <span data-ttu-id="df62c-172">Вот несколько примеров этого правила.</span><span class="sxs-lookup"><span data-stu-id="df62c-172">Here are several instances of that rule.</span></span>

  - <span data-ttu-id="df62c-173">Значение должно существовать в состоянии предусловия метода.</span><span class="sxs-lookup"><span data-stu-id="df62c-173">The value must exist in the method's precondition state.</span></span> <span data-ttu-id="df62c-174">Чтобы сослаться на поле объекта, предусловия должны гарантировать, что объект всегда имеет значение, отличное от NULL.</span><span class="sxs-lookup"><span data-stu-id="df62c-174">In order to reference a field on an object, the preconditions must guarantee that the object is always non-null.</span></span>

  - <span data-ttu-id="df62c-175">Нельзя ссылаться на возвращаемое значение метода в старом выражении:</span><span class="sxs-lookup"><span data-stu-id="df62c-175">You cannot refer to the method's return value in an old expression:</span></span>

      ```csharp
      Contract.OldValue(Contract.Result<int>() + x) // ERROR
      ```

  - <span data-ttu-id="df62c-176">Нельзя ссылаться на параметры `out` в старом выражении.</span><span class="sxs-lookup"><span data-stu-id="df62c-176">You cannot refer to `out` parameters in an old expression.</span></span>

  - <span data-ttu-id="df62c-177">Старое выражение не может зависеть от переменной привязки квантификатора, если диапазон квантификатора зависит от возвращаемого значения метода:</span><span class="sxs-lookup"><span data-stu-id="df62c-177">An old expression cannot depend on the bound variable of a quantifier if the range of the quantifier depends on the return value of the method:</span></span>

      ```csharp
      Contract.ForAll(0, Contract.Result<int>(), i => Contract.OldValue(xs[i]) > 3); // ERROR
      ```

  - <span data-ttu-id="df62c-178">Старое выражение не может ссылаться на параметр анонимного делегата в вызове метода <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> или <xref:System.Diagnostics.Contracts.Contract.Exists%2A>, если он не используется как индексатор или аргумент вызова метода:</span><span class="sxs-lookup"><span data-stu-id="df62c-178">An old expression cannot refer to the parameter of the anonymous delegate in a <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> call unless it is used as an indexer or argument to a method call:</span></span>

      ```csharp
      Contract.ForAll(0, xs.Length, i => Contract.OldValue(xs[i]) > 3); // OK
      Contract.ForAll(0, xs.Length, i => Contract.OldValue(i) > 3); // ERROR
      ```

  - <span data-ttu-id="df62c-179">Старое выражение не может возникать в тексте анонимного делегата, если значение старого выражения зависит от какого-либо параметра этого анонимного делегата, кроме случая, когда этот анонимный делегат является аргументом метода <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> или <xref:System.Diagnostics.Contracts.Contract.Exists%2A>:</span><span class="sxs-lookup"><span data-stu-id="df62c-179">An old expression cannot occur in the body of an anonymous delegate if the value of the old expression depends on any of the parameters of the anonymous delegate, unless the anonymous delegate is an argument to the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> method:</span></span>

      ```csharp
      Method(... (T t) => Contract.OldValue(... t ...) ...); // ERROR
      ```

  - <span data-ttu-id="df62c-180">Параметры `Out` являются проблемой, так как контракты появляются до текста метода, и большинство компиляторов не разрешает ссылки на параметры `out`в постусловиях.</span><span class="sxs-lookup"><span data-stu-id="df62c-180">`Out` parameters present a problem because contracts appear before the body of the method, and most compilers do not allow references to `out` parameters in postconditions.</span></span> <span data-ttu-id="df62c-181">Для разрешения этой проблемы класс <xref:System.Diagnostics.Contracts.Contract> предоставляет метод <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A>, который позволяет постусловие на основе параметра `out`.</span><span class="sxs-lookup"><span data-stu-id="df62c-181">To solve this problem, the <xref:System.Diagnostics.Contracts.Contract> class provides the <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method, which allows a postcondition based on an `out` parameter.</span></span>

      ```csharp
      public void OutParam(out int x)
      {
          Contract.Ensures(Contract.ValueAtReturn(out x) == 3);
          x = 3;
      }
      ```

      <span data-ttu-id="df62c-182">Как и в методе <xref:System.Diagnostics.Contracts.Contract.OldValue%2A>, вы можете опустить параметр универсального типа там, где компилятор способен вывести его тип.</span><span class="sxs-lookup"><span data-stu-id="df62c-182">As with the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method, you can omit the generic type parameter whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="df62c-183">Модуль переопределения контракта заменяет вызов метода значением параметра `out`.</span><span class="sxs-lookup"><span data-stu-id="df62c-183">The contract rewriter replaces the method call with the value of the `out` parameter.</span></span> <span data-ttu-id="df62c-184">Метод <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> может появляться только в постусловиях.</span><span class="sxs-lookup"><span data-stu-id="df62c-184">The <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method may appear only in postconditions.</span></span> <span data-ttu-id="df62c-185">Аргумент метода должен быть параметром `out` или полем параметра `out` структуры.</span><span class="sxs-lookup"><span data-stu-id="df62c-185">The argument to the method must be an `out` parameter or a field of a structure `out` parameter.</span></span> <span data-ttu-id="df62c-186">Последний вариант также полезен при ссылке на поля в постусловии конструктора структуры.</span><span class="sxs-lookup"><span data-stu-id="df62c-186">The latter is also useful when referring to fields in the postcondition of a structure constructor.</span></span>

      > [!NOTE]
      > <span data-ttu-id="df62c-187">В настоящее время средства анализа контрактов для кода не проверяют правильность инициализации параметров `out` и игнорируют их упоминание в постусловии.</span><span class="sxs-lookup"><span data-stu-id="df62c-187">Currently, the code contract analysis tools do not check whether `out` parameters are initialized properly and disregard their mention in the postcondition.</span></span> <span data-ttu-id="df62c-188">Таким образом, если в предыдущем примере в строке после контракта использовалось значение `x` вместо назначения ей целого числа, компилятор не будет выдавать правильную ошибку.</span><span class="sxs-lookup"><span data-stu-id="df62c-188">Therefore, in the previous example, if the line after the contract had used the value of `x` instead of assigning an integer to it, a compiler would not issue the correct error.</span></span> <span data-ttu-id="df62c-189">Однако в сборке, в которой не определен символ препроцессора CONTRACTS_FULL (например, в сборке выпуска), компилятор выдаст ошибку.</span><span class="sxs-lookup"><span data-stu-id="df62c-189">However, on a build where the CONTRACTS_FULL preprocessor symbol is not defined (such asa release build), the compiler will issue an error.</span></span>

## <a name="invariants"></a><span data-ttu-id="df62c-190">Инварианты</span><span class="sxs-lookup"><span data-stu-id="df62c-190">Invariants</span></span>

<span data-ttu-id="df62c-191">Инварианты объектов — это условия, которые должны выполняться для каждого экземпляра класса всегда, когда этот объект является видимым для клиента.</span><span class="sxs-lookup"><span data-stu-id="df62c-191">Object invariants are conditions that should be true for each instance of a class whenever that object is visible to a client.</span></span> <span data-ttu-id="df62c-192">Они выражают условия, при которых объект считается правильным.</span><span class="sxs-lookup"><span data-stu-id="df62c-192">They express the conditions under which the object is considered to be correct.</span></span>

<span data-ttu-id="df62c-193">Методы инвариантов идентифицируются по пометке атрибутом <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute>.</span><span class="sxs-lookup"><span data-stu-id="df62c-193">The invariant methods are identified by being marked with the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute.</span></span> <span data-ttu-id="df62c-194">Методы инвариантов не должны содержать никакой код, кроме последовательности вызовов метода <xref:System.Diagnostics.Contracts.Contract.Invariant%2A>, каждый из которых определяет отдельный инвариант, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="df62c-194">The invariant methods must contain no code except for a sequence of calls to the <xref:System.Diagnostics.Contracts.Contract.Invariant%2A> method, each of which specifies an individual invariant, as shown in the following example.</span></span>

```csharp
[ContractInvariantMethod]
protected void ObjectInvariant ()
{
    Contract.Invariant(this.y >= 0);
    Contract.Invariant(this.x > this.y);
    ...
}
```

<span data-ttu-id="df62c-195">Инварианты условно определяются по символу препроцессора CONTRACTS_FULL.</span><span class="sxs-lookup"><span data-stu-id="df62c-195">Invariants are conditionally defined by the CONTRACTS_FULL preprocessor symbol.</span></span> <span data-ttu-id="df62c-196">При проверке во время выполнения инварианты проверяются в конце каждого открытого метода.</span><span class="sxs-lookup"><span data-stu-id="df62c-196">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="df62c-197">Если инвариант упоминает открытый метод в том же классе, проверка инварианта, которая обычно происходит в конце этого открытого метода, будет отключена.</span><span class="sxs-lookup"><span data-stu-id="df62c-197">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled.</span></span> <span data-ttu-id="df62c-198">Вместо этого проверка будет выполняться только в конце самого внешнего вызова метода для этого класса.</span><span class="sxs-lookup"><span data-stu-id="df62c-198">Instead, the check occurs only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="df62c-199">Это также происходит, если класс повторно вводится в результате вызова метода в другом классе.</span><span class="sxs-lookup"><span data-stu-id="df62c-199">This also happens if the class is re-entered because of a call to a method on another class.</span></span> <span data-ttu-id="df62c-200">Инварианты не проверяются на метод завершения объекта и <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> реализацию.</span><span class="sxs-lookup"><span data-stu-id="df62c-200">Invariants are not checked for an object finalizer and an <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>

<a name="usage_guidelines"></a>

## <a name="usage-guidelines"></a><span data-ttu-id="df62c-201">Правила использования</span><span class="sxs-lookup"><span data-stu-id="df62c-201">Usage Guidelines</span></span>

### <a name="contract-ordering"></a><span data-ttu-id="df62c-202">Упорядочение контрактов</span><span class="sxs-lookup"><span data-stu-id="df62c-202">Contract Ordering</span></span>

<span data-ttu-id="df62c-203">В следующей таблице приведен порядок элементов, который следует использовать при создании контрактов методов.</span><span class="sxs-lookup"><span data-stu-id="df62c-203">The following table shows the order of elements you should use when you write method contracts.</span></span>

|`If-then-throw statements`|<span data-ttu-id="df62c-204">Открытые предусловия с обратной совместимостью</span><span class="sxs-lookup"><span data-stu-id="df62c-204">Backward-compatible public preconditions</span></span>|
|-|-|
|<xref:System.Diagnostics.Contracts.Contract.Requires%2A>|<span data-ttu-id="df62c-205">Все открытые предусловия.</span><span class="sxs-lookup"><span data-stu-id="df62c-205">All public preconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|<span data-ttu-id="df62c-206">Все открытые (обычные) постусловия.</span><span class="sxs-lookup"><span data-stu-id="df62c-206">All public (normal) postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|<span data-ttu-id="df62c-207">Все открытые исключительные постусловия.</span><span class="sxs-lookup"><span data-stu-id="df62c-207">All public exceptional postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|<span data-ttu-id="df62c-208">Все закрытые/внутренние (обычные) постусловия.</span><span class="sxs-lookup"><span data-stu-id="df62c-208">All private/internal (normal) postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|<span data-ttu-id="df62c-209">Все закрытые/внутренние исключительные постусловия.</span><span class="sxs-lookup"><span data-stu-id="df62c-209">All private/internal exceptional postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>|<span data-ttu-id="df62c-210">При использовании предусловий типа `if`-`then`-`throw` без каких-либо других контрактов разместите вызов метода <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>, чтобы указать, что все предыдущие проверки if являются предусловиями.</span><span class="sxs-lookup"><span data-stu-id="df62c-210">If using `if`-`then`-`throw` style preconditions without any other contracts, place a call to <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> to indicate that all previous if checks are preconditions.</span></span>|

<a name="purity"></a>

### <a name="purity"></a><span data-ttu-id="df62c-211">Чистота</span><span class="sxs-lookup"><span data-stu-id="df62c-211">Purity</span></span>

<span data-ttu-id="df62c-212">Все методы, которые вызываются в контракте, должны быть чистыми, то есть они не должны обновлять никакие предварительно существующие состояния.</span><span class="sxs-lookup"><span data-stu-id="df62c-212">All methods that are called within a contract must be pure; that is, they must not update any preexisting state.</span></span> <span data-ttu-id="df62c-213">Чистому методу разрешается изменять объекты, которые были созданы после входа в этот чистый метод.</span><span class="sxs-lookup"><span data-stu-id="df62c-213">A pure method is allowed to modify objects that have been created after entry into the pure method.</span></span>

<span data-ttu-id="df62c-214">В настоящее время средства контрактов для кода предполагают, что чистыми являются следующие элементы кода.</span><span class="sxs-lookup"><span data-stu-id="df62c-214">Code contract tools currently assume that the following code elements are pure:</span></span>

- <span data-ttu-id="df62c-215">Методы, помеченные атрибутом <xref:System.Diagnostics.Contracts.PureAttribute>.</span><span class="sxs-lookup"><span data-stu-id="df62c-215">Methods that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute>.</span></span>

- <span data-ttu-id="df62c-216">Типы, помеченные атрибутом <xref:System.Diagnostics.Contracts.PureAttribute> (этот атрибут относится ко всем методам типа).</span><span class="sxs-lookup"><span data-stu-id="df62c-216">Types that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute> (the attribute applies to all the type's methods).</span></span>

- <span data-ttu-id="df62c-217">Методы доступа get свойства.</span><span class="sxs-lookup"><span data-stu-id="df62c-217">Property get accessors.</span></span>

- <span data-ttu-id="df62c-218">Операторы (статические методы, имена которых начинаются с op, имеющие один или два параметра и тип возвращаемого значения, отличный от void).</span><span class="sxs-lookup"><span data-stu-id="df62c-218">Operators (static methods whose names start with "op", and that have one or two parameters and a non-void return type).</span></span>

- <span data-ttu-id="df62c-219">Любой метод, полное имя которого начинается с System.Diagnostics.Contracts.Contract, System.String, System.IO.Path или System.Type.</span><span class="sxs-lookup"><span data-stu-id="df62c-219">Any method whose fully qualified name begins with "System.Diagnostics.Contracts.Contract", "System.String", "System.IO.Path", or "System.Type".</span></span>

- <span data-ttu-id="df62c-220">Любой вызванный делегат, при условии, что сам тип этого делегата помечен атрибутом <xref:System.Diagnostics.Contracts.PureAttribute>.</span><span class="sxs-lookup"><span data-stu-id="df62c-220">Any invoked delegate, provided that the delegate type itself is attributed with the <xref:System.Diagnostics.Contracts.PureAttribute>.</span></span> <span data-ttu-id="df62c-221">Типы делегата <xref:System.Predicate%601?displayProperty=nameWithType> и <xref:System.Comparison%601?displayProperty=nameWithType> считаются чистыми.</span><span class="sxs-lookup"><span data-stu-id="df62c-221">The delegate types <xref:System.Predicate%601?displayProperty=nameWithType> and <xref:System.Comparison%601?displayProperty=nameWithType> are considered pure.</span></span>

<a name="visibility"></a>

### <a name="visibility"></a><span data-ttu-id="df62c-222">Видимость</span><span class="sxs-lookup"><span data-stu-id="df62c-222">Visibility</span></span>

<span data-ttu-id="df62c-223">Все члены, упомянутые в контракте, должны быть не менее видимы, чем метод, в котором они появляются.</span><span class="sxs-lookup"><span data-stu-id="df62c-223">All members mentioned in a contract must be at least as visible as the method in which they appear.</span></span> <span data-ttu-id="df62c-224">Например, закрытое поле не может упоминаться в предусловии для открытого метода; клиенты не могут проверить такой контракт до вызова метода.</span><span class="sxs-lookup"><span data-stu-id="df62c-224">For example, a private field cannot be mentioned in a precondition for a public method; clients cannot validate such a contract before they call the method.</span></span> <span data-ttu-id="df62c-225">Однако если это поле помечено атрибутом <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute>, оно исключается из данных правил.</span><span class="sxs-lookup"><span data-stu-id="df62c-225">However, if the field is marked with the <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute>, it is exempt from these rules.</span></span>

## <a name="example"></a><span data-ttu-id="df62c-226">Пример</span><span class="sxs-lookup"><span data-stu-id="df62c-226">Example</span></span>

<span data-ttu-id="df62c-227">В следующем примере показано использование контрактов для кода.</span><span class="sxs-lookup"><span data-stu-id="df62c-227">The following example shows the use of code contracts.</span></span>

[!code-csharp[ContractExample#1](../../../samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#1)]
[!code-vb[ContractExample#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#1)]
