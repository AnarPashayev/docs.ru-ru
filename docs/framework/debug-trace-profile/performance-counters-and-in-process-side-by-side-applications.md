---
title: Счетчики производительности и внутрипроцессные параллельные приложения
description: Просматривать счетчики производительности и внутрипроцессный параллельно работающие приложения в .NET; Используйте Perfmon.exe, чтобы различать счетчики производительности на основе среды выполнения.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- performance counters
- performance counters,and in-process side-by-side applications
- performance,.NET Framework applications
- performance monitoring,counters
ms.assetid: 6888f9be-c65b-4b03-a07b-df7ebdee2436
ms.openlocfilehash: 5cc3951c65a0be37294324c767a00bc7a35634b8
ms.sourcegitcommit: 78eb25647b0c750cd80354ebd6ce83a60668e22c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/29/2021
ms.locfileid: "99065042"
---
# <a name="performance-counters-and-in-process-side-by-side-applications"></a>Счетчики производительности и внутрипроцессные параллельные приложения

С помощью системного монитора (Perfmon.exe) можно различать счетчики производительности на основе среды выполнения. В этом разделе описываются изменения в реестре, необходимые для включения этой функции.  
  
## <a name="the-default-behavior"></a>Поведение по умолчанию  

 По умолчанию системный монитор отображает счетчики производительности по приложениям. Тем не менее в двух случаях это может быть сопряжено с проблемами:  
  
- Отслеживание двух приложений с одинаковыми именами. Например, если оба приложения называются myapp.exe, они будут отображаться соответственно как **myapp** и **myapp#1** в столбце **Экземпляр**. В этом случае сложно сопоставить счетчик производительности с конкретным приложением. При этом неочевидно, относятся ли данные для **myapp#1** к первому или второму приложению myapp.exe.  
  
- Приложение, использующее несколько экземпляров общеязыковой среды выполнения. Платформа .NET Framework 4 поддерживает параллельные сценарии размещения в процессе; то есть один процесс или приложение может загрузить несколько экземпляров среды CLR. Если одно приложение с именем myapp.exe загружает два экземпляра среды выполнения, по умолчанию они будут обозначены в столбце **Экземпляр** как **myapp** и **myapp#1**. В этом случае также неясно, относятся ли **myapp** и **myapp#1** к двум одноименным приложениям или к одному приложению с двумя средами выполнения. Если несколько приложений загружают несколько сред выполнения, степень неоднозначности только возрастает.  
  
 Чтобы устранить подобное состояние, можно настроить соответствующий раздел реестра. Для приложений, разработанных с помощью платформа .NET Framework 4, это изменение реестра добавляет идентификатор процесса, за которым следует идентификатор экземпляра среды выполнения, в имя приложения в столбце **экземпляра** . Вместо #1 *приложения* или *приложения* приложение теперь определяется как *Application* _ `p` *processID* \_ `r` *рунтимеид* в столбце **экземпляра** . Если приложение было разработано с использованием предыдущей версии среды CLR, этот экземпляр представлен как идентификатор *приложения \_*, `p`  предоставленный для установки платформа .NET Framework 4.  
  
## <a name="performance-counters-for-in-process-side-by-side-applications"></a>Счетчики производительности для внутрипроцессных параллельных приложений  

 Чтобы использовать счетчики производительности для нескольких версий общеязыковой среды выполнения, размещаемых в одном приложении, необходимо изменить один параметр раздела реестра, как показано в следующей таблице.  
  
|||  
|-|-|  
|Имя ключа|HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\\.NETFramework\Performance|  
|Имя значения|ProcessNameFormat|  
|Тип значения|REG_DWORD|  
|Значение|2 (0x00000002)|
  
 Значение 0 для параметра `ProcessNameFormat` активирует поведение по умолчанию, при котором Perfmon.exe отображает счетчики производительности на основе приложений. Если это значение равно 2, Perfmon.exe различения несколько версий приложения и предоставляет счетчики производительности для каждой среды выполнения. Любые другие значения параметра раздела реестра `ProcessNameFormat` не поддерживаются и зарезервированы для будущего использования.
  
 Для корректной работы функции именования экземпляров после обновления параметра раздела реестра `ProcessNameFormat` необходимо перезапустить Perfmon.exe или любые другие компоненты, использующие счетчики производительности.  
  
 В следующем примере показано изменение значения `ProcessNameFormat` программным способом.  
  
 [!code-csharp[Conceptual.PerfCounters.InProSxS#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.perfcounters.inprosxs/cs/regsetting1.cs#1)]
 [!code-vb[Conceptual.PerfCounters.InProSxS#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.perfcounters.inprosxs/vb/regsetting1.vb#1)]  
  
 При внесении изменений в реестр и при установке платформа .NET Framework 4 или более поздней версии Perfmon.exe отображает имена приложений как *Application* _ `p` *processID*, где *приложение* — это имя приложения, а *processID* — идентификатор процесса приложения. Например, если приложение с именем myapp.exe загружает два экземпляра среды CLR, Perfmon.exe может обозначать один экземпляр как myapp_1416, а второй — как myapp_3160.
  
> [!NOTE]
> Идентификатор процесса позволяет устранить неоднозначность при идентификации двух приложений с одинаковыми именами, использующих более ранние версии среды выполнения. Идентификатор среды выполнения для более ранних версий общеязыковой среды выполнения не нужен, поскольку в них не поддерживаются сценарии параллельного размещения.  
  
 Если платформа .NET Framework 4 или более поздней версии не существует или была удалена, установка раздела реестра не оказывает никакого влияния. Это означает, что два приложения с одинаковым именем будут по-прежнему отображаться в программе Perfmon.exe как *приложение* и *приложение#1* (например, **myapp** и **myapp#1**).
