---
title: Помощник по отладке управляемого кода loaderLock
ms.date: 03/30/2017
helpviewer_keywords:
- deadlocks [.NET Framework]
- LoaderLock MDA
- MDAs (managed debugging assistants), loader locks
- managed debugging assistants (MDAs), loader locks
- operating system loader locks
- loader locks
- locks, threads
ms.assetid: 8c10fa02-1b9c-4be5-ab03-451d943ac1ee
author: mairaw
ms.author: mairaw
ms.openlocfilehash: c3e8769ec972ec76d04d2f22368fdde99de9c6de
ms.sourcegitcommit: 289e06e904b72f34ac717dbcc5074239b977e707
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/17/2019
ms.locfileid: "71052548"
---
# <a name="loaderlock-mda"></a><span data-ttu-id="6b5f7-102">Помощник по отладке управляемого кода loaderLock</span><span class="sxs-lookup"><span data-stu-id="6b5f7-102">loaderLock MDA</span></span>
<span data-ttu-id="6b5f7-103">Помощник по отладке управляемого кода `loaderLock` (MDA) определяет попытки выполнения управляемого кода в потоке, который удерживает блокировку загрузчика операционной системы Microsoft Windows.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-103">The `loaderLock` managed debugging assistant (MDA) detects attempts to execute managed code on a thread that holds the Microsoft Windows operating system loader lock.</span></span>  <span data-ttu-id="6b5f7-104">Любое подобное выполнение кода недопустимо, поскольку оно может привести к взаимоблокировке и использованию библиотек DLL до того, как они будут инициализированы загрузчиком операционной системы.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-104">Any such execution is illegal because it can lead to deadlocks and to use of DLLs before they have been initialized by the operating system's loader.</span></span>  
  
## <a name="symptoms"></a><span data-ttu-id="6b5f7-105">Симптомы</span><span class="sxs-lookup"><span data-stu-id="6b5f7-105">Symptoms</span></span>  
 <span data-ttu-id="6b5f7-106">Наиболее распространенная ошибка при выполнении кода во время блокировки загрузчика операционной системы состоит во взаимоблокировке потоков при попытке вызова других функций Win32, которым также требуется блокировка загрузчика.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-106">The most common failure when executing code inside the operating system's loader lock is that threads will deadlock when attempting to call other Win32 functions that also require the loader lock.</span></span>  <span data-ttu-id="6b5f7-107">Примерами таких функций являются `LoadLibrary`, `GetProcAddress`, `FreeLibrary` и `GetModuleHandle`.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-107">Examples of such functions are `LoadLibrary`, `GetProcAddress`, `FreeLibrary`, and `GetModuleHandle`.</span></span>  <span data-ttu-id="6b5f7-108">Приложение не может вызывать эти функции напрямую; общеязыковая среда выполнения (CLR) может вызывать эти функции в результате вызовов более высокого уровня, например <xref:System.Reflection.Assembly.Load%2A> или в качестве первого вызова метода неуправляемого кода.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-108">The application might not directly call these functions; the common language runtime (CLR) might call these functions as the result of a higher level call like <xref:System.Reflection.Assembly.Load%2A> or the first call to a platform invoke method.</span></span>  
  
 <span data-ttu-id="6b5f7-109">Взаимоблокировка также может возникнуть, если поток ожидает запуска или завершения другого потока.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-109">Deadlocks can also occur if a thread is waiting for another thread to start or finish.</span></span>  <span data-ttu-id="6b5f7-110">При запуске или завершении потока этот поток должен получить блокировку загрузчика операционной системы, чтобы передать события в связанные библиотеки DLL.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-110">When a thread starts or finishes executing, it must acquire the operating system's loader lock to deliver events to affected DLLs.</span></span>  
  
 <span data-ttu-id="6b5f7-111">Наконец, в некоторых случаях вызовы библиотек DLL могут происходить до того, как эти библиотеки были инициализированы загрузчиком операционной системы.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-111">Finally, there are cases where calls into DLLs can occur before those DLLs have been properly initialized by the operating system's loader.</span></span>  <span data-ttu-id="6b5f7-112">В отличие от сбоев по причине взаимоблокировки, которые можно определить, просмотрев стеки всех потоков, включенных во взаимоблокировку, выявить использование DLL-библиотек, которые не были инициализированы, без помощника по отладке управляемого кода очень трудно.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-112">Unlike the deadlock failures, which can be diagnosed by examining the stacks of all the threads involved in the deadlock, it is very difficult to diagnose the use of uninitialized DLLs without using this MDA.</span></span>  
  
## <a name="cause"></a><span data-ttu-id="6b5f7-113">Причина</span><span class="sxs-lookup"><span data-stu-id="6b5f7-113">Cause</span></span>  
 <span data-ttu-id="6b5f7-114">Смешанные сборки с управляемым и неуправляемым кодом C++ для .NET Framework версий 1.0 и 1.1 обычно пытаются выполнять управляемый код во время блокировки загрузчика, если не предпринималось специальных действий, например связывания с помощью **/NOENTRY**.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-114">Mixed managed/unmanaged C++ assemblies built for .NET Framework versions 1.0 or 1.1 generally attempt to execute managed code inside the loader lock unless special care has been taken, for example, linking with **/NOENTRY**.</span></span>
  
 <span data-ttu-id="6b5f7-115">Смешанные сборки с управляемым и неуправляемым кодом C++ для .NET Framework версии 2.0 менее подвержены влиянию этих проблем, но риск все равно сохраняется, так как приложения используют неуправляемые библиотеки DLL, которые нарушают правила операционной системы.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-115">Mixed managed/unmanaged C++ assemblies built for .NET Framework version 2.0 are less susceptible to these problems, having the same reduced risk as applications using unmanaged DLLs that violate the operating system's rules.</span></span>  <span data-ttu-id="6b5f7-116">Например, если точка входа неуправляемой библиотеки DLL `DllMain` вызывает `CoCreateInstance` для получения управляемого объекта, который был открыт для COM, то результатом такой операции станет попытка выполнения управляемого кода во время блокировки загрузчика.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-116">For example, if an unmanaged DLL's `DllMain` entry point calls `CoCreateInstance` to obtain a managed object that has been exposed to COM, the result is an attempt to execute managed code inside the loader lock.</span></span> <span data-ttu-id="6b5f7-117">Дополнительные сведения о проблеме блокировки загрузчика в платформе .NET Framework версии 2.0 и более поздней см. в разделе [Инициализация смешанных сборок](/cpp/dotnet/initialization-of-mixed-assemblies).</span><span class="sxs-lookup"><span data-stu-id="6b5f7-117">For more information about loader lock issues in the .NET Framework version 2.0 and later, see [Initialization of Mixed Assemblies](/cpp/dotnet/initialization-of-mixed-assemblies).</span></span>  
  
## <a name="resolution"></a><span data-ttu-id="6b5f7-118">Решение</span><span class="sxs-lookup"><span data-stu-id="6b5f7-118">Resolution</span></span>  
 <span data-ttu-id="6b5f7-119">В Visual C++ .NET 2002 и Visual C++ .NET 2003 библиотеки DLL, скомпилированные с использованием параметра `/clr`, могут случайным образом создать ситуацию взаимоблокировки при загрузке. Подобная ситуация называется проблемой загрузки смешанных библиотек DLL или проблемой блокировки загрузчика.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-119">In Visual C++ .NET 2002 and Visual C++ .NET 2003, DLLs compiled with the `/clr` compiler option could non-deterministically deadlock when loaded; this issue was called the mixed DLL loading or loader lock issue.</span></span> <span data-ttu-id="6b5f7-120">В Visual C++ 2005 и более поздней версии почти все недетерминированные ситуации при загрузке смешанных библиотек DLL исключены.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-120">In Visual C++ 2005 and later, almost all non-determinism has been removed from the mixed DLL loading process.</span></span> <span data-ttu-id="6b5f7-121">Однако остаются несколько определенных случаев, в которых может произойти блокировка загрузчика.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-121">However, there are a few remaining scenarios for which loader lock can (deterministically) occur.</span></span> <span data-ttu-id="6b5f7-122">Подробные сведения о причинах оставшихся проблем с блокировкой загрузчика и методах их решения см. в разделе [Инициализация смешанных сборок](/cpp/dotnet/initialization-of-mixed-assemblies).</span><span class="sxs-lookup"><span data-stu-id="6b5f7-122">For a detailed account of the causes and resolutions for the remaining loader lock issues, see [Initialization of Mixed Assemblies](/cpp/dotnet/initialization-of-mixed-assemblies).</span></span> <span data-ttu-id="6b5f7-123">Если определить проблему с блокировщиком с помощью этого раздела не удается, следует изучить стек потока, чтобы понять, почему происходит блокировка загрузчика и как решить эту проблему.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-123">If that topic does not identify your loader lock problem, you have to examine the thread's stack to determine why the loader lock is occurring and how to correct the problem.</span></span> <span data-ttu-id="6b5f7-124">Просмотрите трассировку стека для потока, который вызвал помощник по отладке управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-124">Look at the stack trace for the thread that has activated this MDA.</span></span>  <span data-ttu-id="6b5f7-125">Этот поток пытается выполнить недопустимый вызов управляемого кода во время блокировки загрузчика операционной системы.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-125">The thread is attempting to illegally call into managed code while holding the operating system's loader lock.</span></span>  <span data-ttu-id="6b5f7-126">Вы должны увидеть в стеке точку входа `DllMain` для библиотеки DLL или эквивалентную точку входа.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-126">You will probably see a DLL's `DllMain` or equivalent entry point on the stack.</span></span>  <span data-ttu-id="6b5f7-127">Правила операционной системы сильно ограничивают действия, которые допустимы в этой точке входа.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-127">The operating system's rules for what you can legally do from inside such an entry point are quite limited.</span></span>  <span data-ttu-id="6b5f7-128">Эти правила исключают любое выполнение управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-128">These rules preclude any managed execution.</span></span>  
  
## <a name="effect-on-the-runtime"></a><span data-ttu-id="6b5f7-129">Влияние на среду выполнения</span><span class="sxs-lookup"><span data-stu-id="6b5f7-129">Effect on the Runtime</span></span>  
 <span data-ttu-id="6b5f7-130">Как правило, блокировка возникает для нескольких потоков внутри процесса.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-130">Typically, several threads inside the process will deadlock.</span></span>  <span data-ttu-id="6b5f7-131">Один из этих потоков, скорее всего, будет отвечать за сборку мусора, поэтому взаимоблокировка может оказать значительное влияние на весь процесс.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-131">One of those threads is likely to be a thread responsible for performing a garbage collection, so this deadlock can have a major impact on the entire process.</span></span>  <span data-ttu-id="6b5f7-132">Кроме того, это приведет к невозможности выполнения дополнительных операций, требующих блокировки загрузчика операционной системы, таких как загрузка и выгрузка сборок или библиотек DLL и запуск или остановка потоков.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-132">Furthermore, it will prevent any additional operations that require the operating system's loader lock, like loading and unloading assemblies or DLLs and starting or stopping threads.</span></span>  
  
 <span data-ttu-id="6b5f7-133">В некоторых нетипичных случаях также возможно нарушение прав доступа или похожие проблемы в библиотеках DLL, которые вызываются до их инициализации.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-133">In some unusual cases, it is also possible for access violations or similar problems to be triggered in DLLs which are called before they have been initialized.</span></span>  
  
## <a name="output"></a><span data-ttu-id="6b5f7-134">Вывод</span><span class="sxs-lookup"><span data-stu-id="6b5f7-134">Output</span></span>  
 <span data-ttu-id="6b5f7-135">Помощник по отладке управляемого кода сообщает о попытке недопустимого выполнения управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-135">This MDA reports that an illegal managed execution is being attempted.</span></span>  <span data-ttu-id="6b5f7-136">Изучите стек потока, чтобы понять, почему происходит блокировка загрузчика и как решить эту проблему.</span><span class="sxs-lookup"><span data-stu-id="6b5f7-136">You need to examine the thread's stack to determine why the loader lock is occurring and how to correct the problem.</span></span>  
  
## <a name="configuration"></a><span data-ttu-id="6b5f7-137">Конфигурация</span><span class="sxs-lookup"><span data-stu-id="6b5f7-137">Configuration</span></span>  
  
```xml  
<mdaConfig>  
  <assistants>  
    <loaderLock/>  
  </assistants>  
</mdaConfig>  
```  
  
## <a name="see-also"></a><span data-ttu-id="6b5f7-138">См. также</span><span class="sxs-lookup"><span data-stu-id="6b5f7-138">See also</span></span>

- [<span data-ttu-id="6b5f7-139">Диагностика ошибок посредством помощников по отладке управляемого кода</span><span class="sxs-lookup"><span data-stu-id="6b5f7-139">Diagnosing Errors with Managed Debugging Assistants</span></span>](diagnosing-errors-with-managed-debugging-assistants.md)
