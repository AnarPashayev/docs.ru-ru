---
title: Области видимости имен XAML в WPF
ms.date: 03/30/2017
helpviewer_keywords:
- namescopes [WPF]
- styles [WPF], namescopes in
- templates [WPF], namescopes in
- APIs [WPF], name-related
- name-related APIs
- XAML [WPF], namescopes
- classes [WPF], FrameworkContentElement
ms.assetid: 52bbf4f2-15fc-40d4-837b-bb4c21ead7d4
ms.openlocfilehash: 97889b302aac06e118c93f2d000b0eeeed8b71bb
ms.sourcegitcommit: f8c36054eab877de4d40a705aacafa2552ce70e9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/31/2019
ms.locfileid: "75559941"
---
# <a name="wpf-xaml-namescopes"></a><span data-ttu-id="44d13-102">Области видимости имен XAML в WPF</span><span class="sxs-lookup"><span data-stu-id="44d13-102">WPF XAML Namescopes</span></span>
<span data-ttu-id="44d13-103">Области имен XAML — это понятие, которое идентифицирует объекты, определенные в XAML.</span><span class="sxs-lookup"><span data-stu-id="44d13-103">XAML namescopes are a concept that identifies objects that are defined in XAML.</span></span> <span data-ttu-id="44d13-104">Имена из области имен XAML можно использовать для установления связей между именами объектов, определенными в XAML, и эквивалентными им экземплярами из дерева объектов.</span><span class="sxs-lookup"><span data-stu-id="44d13-104">The names in a XAML namescope can be used to establish relationships between the XAML-defined names of objects and their instance equivalents in an object tree.</span></span> <span data-ttu-id="44d13-105">Области имен XAML в управляемом коде [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], как правило, создаются при загрузке отдельных корневых страниц XAML для приложения XAML.</span><span class="sxs-lookup"><span data-stu-id="44d13-105">Typically, XAML namescopes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] managed code are created when loading the individual XAML page roots for a XAML application.</span></span> <span data-ttu-id="44d13-106">Области имен XAML в качестве программного объекта определяются интерфейсом <xref:System.Windows.Markup.INameScope> и также реализуются практическим классом <xref:System.Windows.NameScope>.</span><span class="sxs-lookup"><span data-stu-id="44d13-106">XAML namescopes as the programming object are defined by the <xref:System.Windows.Markup.INameScope> interface and are also implemented by the practical class <xref:System.Windows.NameScope>.</span></span>  

<a name="Namescopes_in_Loaded_XAML_Applications"></a>   
## <a name="namescopes-in-loaded-xaml-applications"></a><span data-ttu-id="44d13-107">Области имен в загруженных приложениях XAML</span><span class="sxs-lookup"><span data-stu-id="44d13-107">Namescopes in Loaded XAML Applications</span></span>  
 <span data-ttu-id="44d13-108">В более широком контексте программирования или информатики в концепции программирования включается принцип уникального идентификатора или имени, которое можно использовать для доступа к объекту.</span><span class="sxs-lookup"><span data-stu-id="44d13-108">In a broader programming or computer science context, programming concepts often include the principle of a unique identifier or name that can be used to access an object.</span></span> <span data-ttu-id="44d13-109">В системах, где используются идентификаторы или имена, область имен определяет границы, в пределах которых процесс или технология ищет объект с запрошенным именем, или границы, в пределах которых применяются уникальные имена.</span><span class="sxs-lookup"><span data-stu-id="44d13-109">For systems that use identifiers or names, the namescope defines the boundaries within which a process or technique will search if an object of that name is requested, or the boundaries wherein uniqueness of identifying names is enforced.</span></span> <span data-ttu-id="44d13-110">Эти общие принципы действительны и для областей имен XAML.</span><span class="sxs-lookup"><span data-stu-id="44d13-110">These general principles are true for XAML namescopes.</span></span> <span data-ttu-id="44d13-111">В WPF области имен XAML создаются в корневом элементе страницы XAML при загрузке страницы.</span><span class="sxs-lookup"><span data-stu-id="44d13-111">In WPF, XAML namescopes are created on the root element for a XAML page when the page is loaded.</span></span> <span data-ttu-id="44d13-112">Каждое имя, указанное внутри страницы XAML, начиная с корневой страницы, добавляется в соответствующую область имен XAML.</span><span class="sxs-lookup"><span data-stu-id="44d13-112">Each name specified within the XAML page starting at the page root is added to a pertinent XAML namescope.</span></span>  
  
 <span data-ttu-id="44d13-113">В XAML WPF элементы, являющиеся общими корневыми элементами (такие как <xref:System.Windows.Controls.Page>и <xref:System.Windows.Window>), всегда управляют областью имен XAML.</span><span class="sxs-lookup"><span data-stu-id="44d13-113">In WPF XAML, elements that are common root elements (such as <xref:System.Windows.Controls.Page>, and <xref:System.Windows.Window>) always control a XAML namescope.</span></span> <span data-ttu-id="44d13-114">Если элемент, такой как <xref:System.Windows.FrameworkElement> или <xref:System.Windows.FrameworkContentElement>, является корневым элементом страницы в разметке, обработчик [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] добавляет неявный корень <xref:System.Windows.Controls.Page>, чтобы <xref:System.Windows.Controls.Page> мог предоставить рабочую область видимости имен XAML.</span><span class="sxs-lookup"><span data-stu-id="44d13-114">If an element such as <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> is the root element of the page in markup, a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor adds a <xref:System.Windows.Controls.Page> root implicitly so that the <xref:System.Windows.Controls.Page> can provide a working XAML namescope.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="44d13-115">Область имен XAML создается для рабочего приложения XAML при выполнении действий сборки WPF, даже если атрибуты `Name` и `x:Name` не определены в элементах разметки [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="44d13-115">WPF build actions create a XAML namescope for a XAML production even if no `Name` or `x:Name` attributes are defined on any elements in the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] markup.</span></span>  
  
 <span data-ttu-id="44d13-116">При попытке использования одного и того же имени дважды в любой области имен XAML будет вызвано исключение.</span><span class="sxs-lookup"><span data-stu-id="44d13-116">If you try to use the same name twice in any XAML namescope, an exception is raised.</span></span> <span data-ttu-id="44d13-117">Для кода XAML системы WPF, который содержит код программной части и является компонентом скомпилированного приложения, во время первоначальной компиляции разметки при создании сформированного класса для страницы вызывается исключение при выполнении действий сборки WPF.</span><span class="sxs-lookup"><span data-stu-id="44d13-117">For WPF XAML that has code-behind and is part of a compiled application, the exception is raised at build time by WPF build actions, when creating the generated class for the page during the initial markup compile.</span></span> <span data-ttu-id="44d13-118">Для кода XAML, разметка которого не скомпилирована действием сборки, исключения, связанные с проблемами области имен XAML, могут вызываться при загрузке кода XAML.</span><span class="sxs-lookup"><span data-stu-id="44d13-118">For XAML that is not markup-compiled by any build action, exceptions related to XAML namescope issues might be raised when the XAML is loaded.</span></span> <span data-ttu-id="44d13-119">Разработчики XAML должны также учитывать возможность возникновения проблем с областью имен XAML во время разработки.</span><span class="sxs-lookup"><span data-stu-id="44d13-119">XAML designers might also anticipate XAML namescope issues at design time.</span></span>  
  
### <a name="adding-objects-to-runtime-object-trees"></a><span data-ttu-id="44d13-120">Добавление объектов в деревья объектов среды выполнения</span><span class="sxs-lookup"><span data-stu-id="44d13-120">Adding Objects to Runtime Object Trees</span></span>  
 <span data-ttu-id="44d13-121">Область имен XAML системы WPF создается и определяется в момент синтаксического анализа кода XAML.</span><span class="sxs-lookup"><span data-stu-id="44d13-121">The moment that XAML is parsed represents the moment in time that a WPF XAML namescope is created and defined.</span></span> <span data-ttu-id="44d13-122">Если объект добавляется в дерево объектов уже после того, как выполнен синтаксический анализ кода XAML, сформировавшего это дерево, значение `Name` или `x:Name` нового объекта не приводит к автоматическому обновлению сведений из области имен XAML.</span><span class="sxs-lookup"><span data-stu-id="44d13-122">If you add an object to an object tree at a point in time after the XAML that produced that tree was parsed, a `Name` or `x:Name` value on the new object does not automatically update the information in a XAML namescope.</span></span> <span data-ttu-id="44d13-123">Чтобы добавить имя объекта в область имен XAML WPF после загрузки XAML, необходимо вызвать соответствующую реализацию <xref:System.Windows.Markup.INameScope.RegisterName%2A> для объекта, определяющего область имен XAML, которая обычно является корнем страницы XAML.</span><span class="sxs-lookup"><span data-stu-id="44d13-123">To add a name for an object into a WPF XAML namescope after XAML is loaded, you must call the appropriate implementation of <xref:System.Windows.Markup.INameScope.RegisterName%2A> on the object that defines the XAML namescope, which is typically the XAML page root.</span></span> <span data-ttu-id="44d13-124">Если имя не зарегистрировано, к добавленному объекту нельзя обращаться по имени с помощью таких методов, как <xref:System.Windows.FrameworkElement.FindName%2A>, и вы не можете использовать это имя для нацеленности на анимацию.</span><span class="sxs-lookup"><span data-stu-id="44d13-124">If the name is not registered, the added object cannot be referenced by name through methods such as <xref:System.Windows.FrameworkElement.FindName%2A>, and you cannot use that name for animation targeting.</span></span>  
  
 <span data-ttu-id="44d13-125">Наиболее распространенным сценарием для разработчиков приложений является то, что вы будете использовать <xref:System.Windows.FrameworkElement.RegisterName%2A> для регистрации имен в области имен XAML в текущем корне страницы.</span><span class="sxs-lookup"><span data-stu-id="44d13-125">The most common scenario for application developers is that you will use <xref:System.Windows.FrameworkElement.RegisterName%2A> to register names into the XAML namescope on the current root of the page.</span></span> <span data-ttu-id="44d13-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> является частью важного сценария для раскадровок, предназначенных для объектов анимации.</span><span class="sxs-lookup"><span data-stu-id="44d13-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> is part of an important scenario for storyboards that target objects for animations.</span></span> <span data-ttu-id="44d13-127">Дополнительные сведения см. в разделе [Общие сведения о Storyboard](../graphics-multimedia/storyboards-overview.md).</span><span class="sxs-lookup"><span data-stu-id="44d13-127">For more information, see [Storyboards Overview](../graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="44d13-128">При вызове <xref:System.Windows.FrameworkElement.RegisterName%2A> для объекта, отличного от объекта, определяющего область имен XAML, имя по-прежнему регистрируется в области имен XAML, в которой содержится вызывающий объект, как если бы вы вызывали <xref:System.Windows.FrameworkElement.RegisterName%2A> в объекте, определяющем область имен XAML.</span><span class="sxs-lookup"><span data-stu-id="44d13-128">If you call <xref:System.Windows.FrameworkElement.RegisterName%2A> on an object other than the object that defines the XAML namescope, the name is still registered to the XAML namescope that the calling object is held within, as if you had called <xref:System.Windows.FrameworkElement.RegisterName%2A> on the XAML namescope defining object.</span></span>  
  
### <a name="xaml-namescopes-in-code"></a><span data-ttu-id="44d13-129">Области имен XAML в коде</span><span class="sxs-lookup"><span data-stu-id="44d13-129">XAML Namescopes in Code</span></span>  
 <span data-ttu-id="44d13-130">Вы можете создавать и использовать области имен XAML в коде.</span><span class="sxs-lookup"><span data-stu-id="44d13-130">You can create and then use XAML namescopes in code.</span></span> <span data-ttu-id="44d13-131">Интерфейсы API и понятия, которые применяются при создании областей имен XAML, совпадают с применяемыми в чистом коде, так как обработчик XAML для [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] использует эти API и понятия при обработке самого кода XAML.</span><span class="sxs-lookup"><span data-stu-id="44d13-131">The APIs and the concepts involved in XAML namescope creation are the same even for a pure code usage, because the XAML processor for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses these APIs and concepts when it processes XAML itself.</span></span> <span data-ttu-id="44d13-132">Они существуют в основном для поиска объектов по имени в дереве объектов, которое, как правило, частично или полностью задано в XAML.</span><span class="sxs-lookup"><span data-stu-id="44d13-132">The concepts and API exist mainly for the purpose of being able to find objects by name within an object tree that is typically defined partially or entirely in XAML.</span></span>  
  
 <span data-ttu-id="44d13-133">Для приложений, которые создаются программно, а не из загруженного XAML, объект, определяющий область имен XAML, должен реализовывать <xref:System.Windows.Markup.INameScope>или быть <xref:System.Windows.FrameworkElement> или производным классом <xref:System.Windows.FrameworkContentElement>, чтобы поддерживать создание области видимости имен XAML в своих экземплярах.</span><span class="sxs-lookup"><span data-stu-id="44d13-133">For applications that are created programmatically, and not from loaded XAML, the object that defines a XAML namescope must implement <xref:System.Windows.Markup.INameScope>, or be a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> derived class, in order to support creation of a XAML namescope on its instances.</span></span>  
  
 <span data-ttu-id="44d13-134">Также для любого элемента, не загруженного и не обработанного обработчиком XAML, область имен XAML для объекта не создается и не инициализируется по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="44d13-134">Also, for any element that is not loaded and processed by a XAML processor, the XAML namescope for the object is not created or initialized by default.</span></span> <span data-ttu-id="44d13-135">Необходимо явным образом создать область имен XAML для любого объекта, в котором впоследствии требуется регистрировать имена.</span><span class="sxs-lookup"><span data-stu-id="44d13-135">You must explicitly create a new XAML namescope for any object that you intend to register names into subsequently.</span></span> <span data-ttu-id="44d13-136">Чтобы создать область имен XAML, вызовите статический метод <xref:System.Windows.NameScope.SetNameScope%2A>.</span><span class="sxs-lookup"><span data-stu-id="44d13-136">To create a XAML namescope, you call the static <xref:System.Windows.NameScope.SetNameScope%2A> method.</span></span> <span data-ttu-id="44d13-137">Укажите объект, который будет владельцем его в качестве параметра `dependencyObject`, и новый вызов конструктора <xref:System.Windows.NameScope.%23ctor%2A> в качестве параметра `value`.</span><span class="sxs-lookup"><span data-stu-id="44d13-137">Specify the object that will own it as the `dependencyObject` parameter, and a new <xref:System.Windows.NameScope.%23ctor%2A> constructor call as the `value` parameter.</span></span>  
  
 <span data-ttu-id="44d13-138">Если объект, предоставленный как `dependencyObject` для <xref:System.Windows.NameScope.SetNameScope%2A>, не является реализацией <xref:System.Windows.Markup.INameScope>, <xref:System.Windows.FrameworkElement> или <xref:System.Windows.FrameworkContentElement>, вызов <xref:System.Windows.FrameworkElement.RegisterName%2A> для всех дочерних элементов не будет действовать.</span><span class="sxs-lookup"><span data-stu-id="44d13-138">If the object provided as `dependencyObject` for <xref:System.Windows.NameScope.SetNameScope%2A> is not a <xref:System.Windows.Markup.INameScope> implementation, <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, calling <xref:System.Windows.FrameworkElement.RegisterName%2A> on any child elements will have no effect.</span></span> <span data-ttu-id="44d13-139">Если не удается явно создать область видимости имен XAML, то вызов метода <xref:System.Windows.FrameworkElement.RegisterName%2A> вызовет исключение.</span><span class="sxs-lookup"><span data-stu-id="44d13-139">If you fail to create the new XAML namescope explicitly, then calls to <xref:System.Windows.FrameworkElement.RegisterName%2A> will raise an exception.</span></span>  
  
 <span data-ttu-id="44d13-140">Пример использования интерфейсов API для области имен XAML в коде см. в разделе [Определение пространства имен](../graphics-multimedia/how-to-define-a-name-scope.md).</span><span class="sxs-lookup"><span data-stu-id="44d13-140">For an example of using XAML namescope APIs in code, see [Define a Name Scope](../graphics-multimedia/how-to-define-a-name-scope.md).</span></span>  
  
<a name="Namescopes_in_Styles_and_Templates"></a>   
## <a name="xaml-namescopes-in-styles-and-templates"></a><span data-ttu-id="44d13-141">Области имен XAML в стилях и шаблонах</span><span class="sxs-lookup"><span data-stu-id="44d13-141">XAML Namescopes in Styles and Templates</span></span>  
 <span data-ttu-id="44d13-142">Стили и шаблоны [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] позволяют повторно использовать и применять содержимое простым и понятным способом.</span><span class="sxs-lookup"><span data-stu-id="44d13-142">Styles and templates in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provide the ability to reuse and reapply content in a straightforward way.</span></span> <span data-ttu-id="44d13-143">Однако стили и шаблоны могут также включать элементы с именами XAML, определенными на уровне шаблона.</span><span class="sxs-lookup"><span data-stu-id="44d13-143">However, styles and templates might also include elements with XAML names defined at the template level.</span></span> <span data-ttu-id="44d13-144">Затем один и тот же шаблон может использоваться несколько раз на странице.</span><span class="sxs-lookup"><span data-stu-id="44d13-144">That same template might be used multiple times in a page.</span></span> <span data-ttu-id="44d13-145">По этой причине стили и шаблоны определяют свои собственные области имен XAML независимо от расположения в дереве объектов, где применяется стиль или шаблон.</span><span class="sxs-lookup"><span data-stu-id="44d13-145">For this reason, styles and templates both define their own XAML namescopes, independent of whatever location in an object tree where the style or template is applied.</span></span>  
  
 <span data-ttu-id="44d13-146">Рассмотрим следующий пример.</span><span class="sxs-lookup"><span data-stu-id="44d13-146">Consider the following example:</span></span>  
  
 [!code-xaml[XamlOvwSupport#NameScopeTemplates](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page6.xaml#namescopetemplates)]  
  
 <span data-ttu-id="44d13-147">Здесь один тот же шаблон применяется к двум разным кнопкам.</span><span class="sxs-lookup"><span data-stu-id="44d13-147">Here, the same template is applied to two different buttons.</span></span> <span data-ttu-id="44d13-148">Если у шаблонов не было дискретных областей имен XAML, имя `TheBorder`, используемое в шаблоне, вызовет конфликт имен в области имен XAML.</span><span class="sxs-lookup"><span data-stu-id="44d13-148">If templates did not have discrete XAML namescopes, the `TheBorder` name used in the template would cause a name collision in the XAML namescope.</span></span> <span data-ttu-id="44d13-149">Каждый экземпляр шаблона имеет свою собственную область имен XAML, поэтому в данном примере каждая область имен XAML экземпляра шаблона будет содержать ровно одно имя.</span><span class="sxs-lookup"><span data-stu-id="44d13-149">Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</span></span>  
  
 <span data-ttu-id="44d13-150">Стили также определяют собственные области имен XAML, в основном поэтому части раскадровок могут иметь присвоенные индивидуальные имена.</span><span class="sxs-lookup"><span data-stu-id="44d13-150">Styles also define their own XAML namescope, mostly so that parts of storyboards can have particular names assigned.</span></span> <span data-ttu-id="44d13-151">Эти имена включают конкретные расширения функциональности элемента управления, которые предназначены для элементов с таким именем, даже если шаблон был переопределен при настройке элемента управления.</span><span class="sxs-lookup"><span data-stu-id="44d13-151">These names enable control specific behaviors that will target elements of that name, even if the template was re-defined as part of control customization.</span></span>  
  
 <span data-ttu-id="44d13-152">Из-за независимых областей имен XAML поиск именованных элементов в шаблоне является более затратной задачей, чем поиск нешаблонного именованного элемента на странице.</span><span class="sxs-lookup"><span data-stu-id="44d13-152">Because of the separate XAML namescopes, finding named elements in a template is more challenging than finding a non-templated named element in a page.</span></span> <span data-ttu-id="44d13-153">Сначала необходимо определить примененный шаблон, получив значение свойства <xref:System.Windows.Controls.Control.Template%2A> элемента управления, в котором применяется шаблон.</span><span class="sxs-lookup"><span data-stu-id="44d13-153">You first need to determine the applied template, by getting the <xref:System.Windows.Controls.Control.Template%2A> property value of the control where the template is applied.</span></span> <span data-ttu-id="44d13-154">Затем вызывается версия шаблона <xref:System.Windows.FrameworkTemplate.FindName%2A>, передавая элемент управления, в котором шаблон был применен в качестве второго параметра.</span><span class="sxs-lookup"><span data-stu-id="44d13-154">Then, you call the template version of <xref:System.Windows.FrameworkTemplate.FindName%2A>, passing the control where the template was applied as the second parameter.</span></span>  
  
 <span data-ttu-id="44d13-155">Если вы являетесь автором элемента управления и создаете соглашение, в котором определенный именованный элемент в примененном шаблоне является целью для поведения, определяемого самим элементом управления, можно использовать метод <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> из кода реализации элемента управления.</span><span class="sxs-lookup"><span data-stu-id="44d13-155">If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method from your control implementation code.</span></span> <span data-ttu-id="44d13-156">Метод <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> защищен, поэтому доступ к нему имеют только автор элемента управления.</span><span class="sxs-lookup"><span data-stu-id="44d13-156">The <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method is protected, so only the control author has access to it.</span></span>  
  
 <span data-ttu-id="44d13-157">Если вы работаете в шаблоне и хотите перейти к области имен XAML, где применяется шаблон, получите значение <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, а затем вызовите <xref:System.Windows.FrameworkElement.FindName%2A> там.</span><span class="sxs-lookup"><span data-stu-id="44d13-157">If you are working from within a template, and need to get to the XAML namescope where the template is applied, get the value of <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, and then call <xref:System.Windows.FrameworkElement.FindName%2A> there.</span></span> <span data-ttu-id="44d13-158">В качестве примера работы в шаблоне можно привести ситуацию, когда пишется реализация обработчика событий, в котором событие будет вызвано из элемента в примененном шаблоне.</span><span class="sxs-lookup"><span data-stu-id="44d13-158">An example of working within the template would be if you are writing the event handler implementation where the event will be raised from an element in an applied template.</span></span>  
  
<a name="Namescopes_and_Name_related_APIs"></a>   
## <a name="xaml-namescopes-and-name-related-apis"></a><span data-ttu-id="44d13-159">Области имен XAML и интерфейсы API, связанные с именами</span><span class="sxs-lookup"><span data-stu-id="44d13-159">XAML Namescopes and Name-related APIs</span></span>  
 <span data-ttu-id="44d13-160"><xref:System.Windows.FrameworkElement> содержит методы <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> и <xref:System.Windows.FrameworkElement.UnregisterName%2A>.</span><span class="sxs-lookup"><span data-stu-id="44d13-160"><xref:System.Windows.FrameworkElement> has <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> and <xref:System.Windows.FrameworkElement.UnregisterName%2A> methods.</span></span> <span data-ttu-id="44d13-161">Если объект, для которого вызываются эти методы, имеет собственную область имен XAML, то методы вызывают методы соответствующей области имен XAML.</span><span class="sxs-lookup"><span data-stu-id="44d13-161">If the object you call these methods on owns a XAML namescope, the methods call into the methods of the relevant XAML namescope.</span></span> <span data-ttu-id="44d13-162">В противном случае выполняется проверка того, владеет ли родительский элемент областью имен XAML и этот процесс продолжается рекурсивно до тех пор, пока область имен XAML не будет найдена (из-за того что поведение обработчика XAML гарантирует наличие области имен XAML в корне).</span><span class="sxs-lookup"><span data-stu-id="44d13-162">Otherwise, the parent element is checked to see if it owns a XAML namescope, and this process continues recursively until a XAML namescope is found (because of the XAML processor behavior, there is guaranteed to be a XAML namescope at the root).</span></span> <span data-ttu-id="44d13-163"><xref:System.Windows.FrameworkContentElement> имеет аналогичные поведения, за исключением того, что ни одна из <xref:System.Windows.FrameworkContentElement> не владеет областью имен XAML.</span><span class="sxs-lookup"><span data-stu-id="44d13-163"><xref:System.Windows.FrameworkContentElement> has analogous behaviors, with the exception that no <xref:System.Windows.FrameworkContentElement> will ever own a XAML namescope.</span></span> <span data-ttu-id="44d13-164">Методы существуют в <xref:System.Windows.FrameworkContentElement>, чтобы вызовы могли пересылаться в конечном итоге в <xref:System.Windows.FrameworkElement> родительский элемент.</span><span class="sxs-lookup"><span data-stu-id="44d13-164">The methods exist on <xref:System.Windows.FrameworkContentElement> so that the calls can be forwarded eventually to a <xref:System.Windows.FrameworkElement> parent element.</span></span>  
  
 <span data-ttu-id="44d13-165"><xref:System.Windows.NameScope.SetNameScope%2A> используется для отображения новой области имен XAML для существующего объекта.</span><span class="sxs-lookup"><span data-stu-id="44d13-165"><xref:System.Windows.NameScope.SetNameScope%2A> is used to map a new XAML namescope to an existing object.</span></span> <span data-ttu-id="44d13-166">Можно вызвать <xref:System.Windows.NameScope.SetNameScope%2A> несколько раз, чтобы сбросить или очистить область имен XAML, но это не является распространенным использованием.</span><span class="sxs-lookup"><span data-stu-id="44d13-166">You can call <xref:System.Windows.NameScope.SetNameScope%2A> more than once in order to reset or clear the XAML namescope, but that is not a common usage.</span></span> <span data-ttu-id="44d13-167">Кроме того, <xref:System.Windows.NameScope.GetNameScope%2A> обычно не используется из кода.</span><span class="sxs-lookup"><span data-stu-id="44d13-167">Also, <xref:System.Windows.NameScope.GetNameScope%2A> is not typically used from code.</span></span>  
  
### <a name="xaml-namescope-implementations"></a><span data-ttu-id="44d13-168">Реализации области имен XAML</span><span class="sxs-lookup"><span data-stu-id="44d13-168">XAML Namescope Implementations</span></span>  
 <span data-ttu-id="44d13-169">Следующие классы реализуют <xref:System.Windows.Markup.INameScope> напрямую:</span><span class="sxs-lookup"><span data-stu-id="44d13-169">The following classes implement <xref:System.Windows.Markup.INameScope> directly:</span></span>  
  
- <xref:System.Windows.NameScope>  
  
- <xref:System.Windows.Style>  
  
- <xref:System.Windows.ResourceDictionary>  
  
- <xref:System.Windows.FrameworkTemplate>  
  
 <span data-ttu-id="44d13-170"><xref:System.Windows.ResourceDictionary> не использует имена или области видимости имен XAML; Вместо этого используются ключи, так как это реализация словаря.</span><span class="sxs-lookup"><span data-stu-id="44d13-170"><xref:System.Windows.ResourceDictionary> does not use XAML names or namescopes ; it uses keys instead, because it is a dictionary implementation.</span></span> <span data-ttu-id="44d13-171">Единственная причина, по которой <xref:System.Windows.ResourceDictionary> реализует <xref:System.Windows.Markup.INameScope>, заключается в том, что она может вызывать исключения в пользовательском коде, что позволяет объяснить различие между истинной областью видимости имен XAML и тем, как <xref:System.Windows.ResourceDictionary> обрабатывает ключи, а также гарантирует, что области имен XAML не применяются к <xref:System.Windows.ResourceDictionary> родительскими элементами.</span><span class="sxs-lookup"><span data-stu-id="44d13-171">The only reason that <xref:System.Windows.ResourceDictionary> implements <xref:System.Windows.Markup.INameScope> is so it can raise exceptions to user code that help clarify the distinction between a true XAML namescope and how a <xref:System.Windows.ResourceDictionary> handles keys, and also to assure that XAML namescopes are not applied to a <xref:System.Windows.ResourceDictionary> by parent elements.</span></span>  
  
 <span data-ttu-id="44d13-172"><xref:System.Windows.FrameworkTemplate> и <xref:System.Windows.Style> реализуйте <xref:System.Windows.Markup.INameScope> через явные определения интерфейса.</span><span class="sxs-lookup"><span data-stu-id="44d13-172"><xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> implement <xref:System.Windows.Markup.INameScope> through explicit interface definitions.</span></span> <span data-ttu-id="44d13-173">Явные реализации позволяют этим областям видимости имен XAML вести себя в соответствии с соглашениями, когда доступ к ним осуществляется через интерфейс <xref:System.Windows.Markup.INameScope>, который заключается в том, как области имен XAML взаимодействуют [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] внутренними процессами.</span><span class="sxs-lookup"><span data-stu-id="44d13-173">The explicit implementations allow these XAML namescopes to behave conventionally when they are accessed through the <xref:System.Windows.Markup.INameScope> interface, which is how XAML namescopes are communicated by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] internal processes.</span></span> <span data-ttu-id="44d13-174">Но явные определения интерфейсов не являются частью стандартной области API <xref:System.Windows.FrameworkTemplate> и <xref:System.Windows.Style>, так как редко приходится вызывать методы <xref:System.Windows.Markup.INameScope> для <xref:System.Windows.FrameworkTemplate> и <xref:System.Windows.Style> напрямую, а вместо этого использовать другие API, такие как <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span><span class="sxs-lookup"><span data-stu-id="44d13-174">But the explicit interface definitions are not part of the conventional API surface of <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style>, because you seldom need to call the <xref:System.Windows.Markup.INameScope> methods on <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> directly, and instead would use other API such as <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span></span>  
  
 <span data-ttu-id="44d13-175">Следующие классы определяют собственную область имен XAML с помощью вспомогательного класса <xref:System.Windows.NameScope?displayProperty=nameWithType> и подключаются к реализации области видимости имен XAML с помощью <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> присоединенного свойства:</span><span class="sxs-lookup"><span data-stu-id="44d13-175">The following classes define their own XAML namescope, by using the <xref:System.Windows.NameScope?displayProperty=nameWithType> helper class and connecting to its XAML namescope implementation through the <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> attached property:</span></span>  
  
- <xref:System.Windows.FrameworkElement>  
  
- <xref:System.Windows.FrameworkContentElement>  
  
## <a name="see-also"></a><span data-ttu-id="44d13-176">См. также:</span><span class="sxs-lookup"><span data-stu-id="44d13-176">See also</span></span>

- [<span data-ttu-id="44d13-177">Пространства имен XAML и сопоставление пространств имен для WPF XAML</span><span class="sxs-lookup"><span data-stu-id="44d13-177">XAML Namespaces and Namespace Mapping for WPF XAML</span></span>](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)
- [<span data-ttu-id="44d13-178">Директива x:Name</span><span class="sxs-lookup"><span data-stu-id="44d13-178">x:Name Directive</span></span>](../../../desktop-wpf/xaml-services/xname-directive.md)
