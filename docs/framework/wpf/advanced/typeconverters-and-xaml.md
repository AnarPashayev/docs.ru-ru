---
title: TypeConverters и XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [WPF], TypeConverter class
ms.assetid: f6313e4d-e89d-497d-ac87-b43511a1ae4b
ms.openlocfilehash: 94cfce44d5702e0550310723ec56184096165436
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79187297"
---
# <a name="typeconverters-and-xaml"></a><span data-ttu-id="9b085-102">TypeConverters и XAML</span><span class="sxs-lookup"><span data-stu-id="9b085-102">TypeConverters and XAML</span></span>
<span data-ttu-id="9b085-103">Этот раздел посвящен цели преобразования типов из строк — одной из основных функций языка XAML.</span><span class="sxs-lookup"><span data-stu-id="9b085-103">This topic introduces the purpose of type conversion from string as a general XAML language feature.</span></span> <span data-ttu-id="9b085-104">В рамках .NET <xref:System.ComponentModel.TypeConverter> класс служит определенной цели в рамках реализации управляемого пользовательского класса, который может быть использован в качестве значения свойства в использовании атрибутов XAML.</span><span class="sxs-lookup"><span data-stu-id="9b085-104">In the .NET Framework, the <xref:System.ComponentModel.TypeConverter> class serves a particular purpose as part of the implementation for a managed custom class that can be used as a property value in XAML attribute usage.</span></span> <span data-ttu-id="9b085-105">Если вы пишете пользовательский класс и хотите, чтобы экземпляры вашего класса были пригодны для удобого значений XAML settable, возможно, потребуется применить их <xref:System.ComponentModel.TypeConverterAttribute> к своему классу, написать пользовательский <xref:System.ComponentModel.TypeConverter> класс или и то, и другое.</span><span class="sxs-lookup"><span data-stu-id="9b085-105">If you write a custom class, and you want instances of your class to be usable as XAML settable attribute values, you might need to apply a <xref:System.ComponentModel.TypeConverterAttribute> to your class, write a custom <xref:System.ComponentModel.TypeConverter> class, or both.</span></span>  

## <a name="type-conversion-concepts"></a><span data-ttu-id="9b085-106">Понятия преобразования типов</span><span class="sxs-lookup"><span data-stu-id="9b085-106">Type Conversion Concepts</span></span>  
  
### <a name="xaml-and-string-values"></a><span data-ttu-id="9b085-107">XAML и строковые значения</span><span class="sxs-lookup"><span data-stu-id="9b085-107">XAML and String Values</span></span>  
 <span data-ttu-id="9b085-108">Когда задается значение атрибута в файле XAML, начальный тип этого значения — строка чистого текста.</span><span class="sxs-lookup"><span data-stu-id="9b085-108">When you set an attribute value in a XAML file, the initial type of that value is a string in pure text.</span></span> <span data-ttu-id="9b085-109">Даже другие примитивы, такие как <xref:System.Double> изначально текстовые строки для процессора XAML.</span><span class="sxs-lookup"><span data-stu-id="9b085-109">Even other primitives such as <xref:System.Double> are initially text strings to a XAML processor.</span></span>  
  
 <span data-ttu-id="9b085-110">XAML-обработчику требуется два сообщения для того, чтобы обработать значение атрибута.</span><span class="sxs-lookup"><span data-stu-id="9b085-110">A XAML processor needs two pieces of information in order to process an attribute value.</span></span> <span data-ttu-id="9b085-111">Первый из них — это тип значения свойства, которое должно быть задано.</span><span class="sxs-lookup"><span data-stu-id="9b085-111">The first piece of information is the value type of the property that is being set.</span></span> <span data-ttu-id="9b085-112">Любую строку, которая определяет значение атрибута и обрабатывается в XAML, в конечном счете необходимо преобразовать или разрешить в значение этого типа.</span><span class="sxs-lookup"><span data-stu-id="9b085-112">Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.</span></span> <span data-ttu-id="9b085-113">Если значение — примитивный тип, понятный средству синтаксического анализа XAML (например, числовое значение), выполняется попытка прямого преобразования строки.</span><span class="sxs-lookup"><span data-stu-id="9b085-113">If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.</span></span> <span data-ttu-id="9b085-114">Если значение является перечислением, то строка используется для проверки совпадения имени в этом перечислении с именем константы.</span><span class="sxs-lookup"><span data-stu-id="9b085-114">If the value is an enumeration, the string is used to check for a name match to a named constant in that enumeration.</span></span> <span data-ttu-id="9b085-115">Если значение не является ни примитивом, понятным средству синтаксического анализа, ни перечислением, то этот тип должен обладать возможностью предоставления экземпляра типа или значения, основанного на преобразованной строке.</span><span class="sxs-lookup"><span data-stu-id="9b085-115">If the value is neither a parser-understood primitive nor an enumeration, then the type in question must be able to provide an instance of the type, or a value, based on a converted string.</span></span> <span data-ttu-id="9b085-116">Это делается указанием класса преобразователя типов.</span><span class="sxs-lookup"><span data-stu-id="9b085-116">This is done by indicating a type converter class.</span></span> <span data-ttu-id="9b085-117">Преобразователь типов — это фактически вспомогательный класс, предоставляющий значения другого класса как сценариям XAML, так и потенциально вызовам из кода .NET.</span><span class="sxs-lookup"><span data-stu-id="9b085-117">The type converter is effectively a helper class for providing values of another class, both for the XAML scenario and also potentially for code calls in .NET code.</span></span>  
  
### <a name="using-existing-type-conversion-behavior-in-xaml"></a><span data-ttu-id="9b085-118">Использование поведения преобразования существующего типа в XAML</span><span class="sxs-lookup"><span data-stu-id="9b085-118">Using Existing Type Conversion Behavior in XAML</span></span>  
 <span data-ttu-id="9b085-119">В зависимости от уровня понимания концепций XAML, вы, возможно, уже используете преобразование типа в простом приложении XAML, не реализуя его.</span><span class="sxs-lookup"><span data-stu-id="9b085-119">Depending on your familiarity with the underlying XAML concepts, you may already be using type conversion behavior in basic application XAML without realizing it.</span></span> <span data-ttu-id="9b085-120">Например, WPF определяет буквально сотни свойств, которые <xref:System.Windows.Point>принимают значение типа.</span><span class="sxs-lookup"><span data-stu-id="9b085-120">For instance, WPF defines literally hundreds of properties that take a value of type <xref:System.Windows.Point>.</span></span> <span data-ttu-id="9b085-121">A <xref:System.Windows.Point> это значение, которое описывает координаты в двухмерном пространстве <xref:System.Windows.Point.X%2A> <xref:System.Windows.Point.Y%2A>координат, и это действительно просто имеет два важных свойства: и .</span><span class="sxs-lookup"><span data-stu-id="9b085-121">A <xref:System.Windows.Point> is a value that describes a coordinate in a two-dimensional coordinate space, and it really just has two important properties: <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A>.</span></span> <span data-ttu-id="9b085-122">Когда вы указываете точку в XAML, вы указываете ее как строку <xref:System.Windows.Point.X%2A> с <xref:System.Windows.Point.Y%2A> делимитером (обычно запятой) между и значениями, которые вы предоставляете.</span><span class="sxs-lookup"><span data-stu-id="9b085-122">When you specify a point in XAML, you specify it as a string with a delimiter (typically a comma) between the <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A> values you provide.</span></span> <span data-ttu-id="9b085-123">Например: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`.</span><span class="sxs-lookup"><span data-stu-id="9b085-123">For example: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`.</span></span>  
  
 <span data-ttu-id="9b085-124">Даже этот простой тип и его простое <xref:System.Windows.Point> использование в XAML включают в себя тип преобразователя.</span><span class="sxs-lookup"><span data-stu-id="9b085-124">Even this simple type of <xref:System.Windows.Point> and its simple usage in XAML involve a type converter.</span></span> <span data-ttu-id="9b085-125">В этом случае это <xref:System.Windows.PointConverter>класс.</span><span class="sxs-lookup"><span data-stu-id="9b085-125">In this case that is the class <xref:System.Windows.PointConverter>.</span></span>  
  
 <span data-ttu-id="9b085-126">Преобразователь <xref:System.Windows.Point> типа, определенный на уровне класса, упрощает <xref:System.Windows.Point>использование разметки всех свойств, которые принимают.</span><span class="sxs-lookup"><span data-stu-id="9b085-126">The type converter for <xref:System.Windows.Point> defined at the class level streamlines the markup usages of all properties that take <xref:System.Windows.Point>.</span></span> <span data-ttu-id="9b085-127">Без преобразователя типов для создания примера, показанного выше, требуется гораздо больше разметки.</span><span class="sxs-lookup"><span data-stu-id="9b085-127">Without a type converter here, you would need the following much more verbose markup for the same example shown previously:</span></span>  

```xaml
<LinearGradientBrush>
  <LinearGradientBrush.StartPoint>
    <Point X="0" Y="0"/>
  </LinearGradientBrush.StartPoint>
  <LinearGradientBrush.EndPoint>
    <Point X="1" Y="1"/>
  </LinearGradientBrush.EndPoint>
</LinearGradientBrush>
 ```
  
 <span data-ttu-id="9b085-128">Использовать преобразование типа строки или более многословный синтаксис — этот выбор диктуется только стилем написания кода.</span><span class="sxs-lookup"><span data-stu-id="9b085-128">Whether to use the type conversion string or a more verbose equivalent syntax is generally a coding style choice.</span></span> <span data-ttu-id="9b085-129">Инструментарий рабочего процесса XAML также может оказывать влияние на то, как задаются значения.</span><span class="sxs-lookup"><span data-stu-id="9b085-129">Your XAML tooling workflow might also influence how values are set.</span></span> <span data-ttu-id="9b085-130">Некоторые инструменты XAML склонны создавать очень подробную разметку, так как это облегчает переключение между представлениями конструктора и собственным механизмом сериализации.</span><span class="sxs-lookup"><span data-stu-id="9b085-130">Some XAML tools tend to emit the most verbose form of the markup because it is easier to round-trip to designer views or its own serialization mechanism.</span></span>  
  
 <span data-ttu-id="9b085-131">Существующие преобразователи типа обычно могут быть обнаружены на типах WPF и <xref:System.ComponentModel.TypeConverterAttribute>.NET Framework, проверяя класс (или свойство) на наличие прикладного.</span><span class="sxs-lookup"><span data-stu-id="9b085-131">Existing type converters can generally be discovered on WPF and .NET Framework types by checking a class (or property) for the presence of an applied <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="9b085-132">Этот атрибут содержит имя класса, поддерживающего преобразование для данного типа, как для XAML, так потенциально и для других целей.</span><span class="sxs-lookup"><span data-stu-id="9b085-132">This attribute will name the class that is the supporting type converter for values of that type, for XAML purposes as well as potentially other purposes.</span></span>  
  
### <a name="type-converters-and-markup-extensions"></a><span data-ttu-id="9b085-133">Преобразователи типов и расширения разметки</span><span class="sxs-lookup"><span data-stu-id="9b085-133">Type Converters and Markup Extensions</span></span>  
 <span data-ttu-id="9b085-134">Расширения разметки и преобразователи типов играют ортогональные роли в терминах поведения обработчика XAML и сценариев, к которым они применяются.</span><span class="sxs-lookup"><span data-stu-id="9b085-134">Markup extensions and type converters fill orthogonal roles in terms of XAML processor behavior and the scenarios that they are applied to.</span></span> <span data-ttu-id="9b085-135">Хотя для расширения разметки контекст доступен, поведение преобразования типов свойств, когда расширение разметки предоставляет значение, обычно не включается в реализацию расширения разметки.</span><span class="sxs-lookup"><span data-stu-id="9b085-135">Although context is available for markup extension usages, type conversion behavior of properties where a markup extension provides a value is generally is not checked in the markup extension implementations.</span></span> <span data-ttu-id="9b085-136">Другими словами, даже если расширение разметки возвращает текстовую строку в качестве выходных данных `ProvideValue`, преобразование типа для этой строки относительно конкретного свойства или типа значения свойства не применяется. Обычно целью расширения разметки является обработка строки и возврат объекта без использования какого бы то ни было преобразователя типов.</span><span class="sxs-lookup"><span data-stu-id="9b085-136">In other words, even if a markup extension returns a text string as its `ProvideValue` output, type conversion behavior on that string as applied to a specific property or property value type is not invoked, Generally, the purpose of a markup extension is to process a string and return an object without any type converter involved.</span></span>  
  
 <span data-ttu-id="9b085-137">Одна общая ситуация, где необходимо расширение разметки, а не преобразователь типов, заключается в создании ссылки на объект, который уже существует.</span><span class="sxs-lookup"><span data-stu-id="9b085-137">One common situation where a markup extension is necessary rather than a type converter is to make a reference to an object that already exists.</span></span> <span data-ttu-id="9b085-138">В лучшем случае преобразователь типов с неопределенным состоянием может только создать новый экземпляр, что может быть нежелательно.</span><span class="sxs-lookup"><span data-stu-id="9b085-138">At best, a stateless type converter could only generate a new instance, which might not be desirable.</span></span> <span data-ttu-id="9b085-139">Дополнительные сведения о расширениях разметки см. в разделе [Расширения разметки и XAML WPF](markup-extensions-and-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="9b085-139">For more information on markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span>  
  
### <a name="native-type-converters"></a><span data-ttu-id="9b085-140">Собственные преобразователи типа</span><span class="sxs-lookup"><span data-stu-id="9b085-140">Native Type Converters</span></span>  
 <span data-ttu-id="9b085-141">В реализации средства синтаксического анализа XAML в WPF и платформе .NET Framework существуют несколько типов, поддерживающих собственную обработку преобразования типа, но нет типов, которые можно рассматривать как примитивы.</span><span class="sxs-lookup"><span data-stu-id="9b085-141">In the WPF and .NET Framework implementation of the XAML parser, there are certain types that have native type conversion handling, yet are not types that might conventionally be thought of as primitives.</span></span> <span data-ttu-id="9b085-142">Пример такого типа — <xref:System.DateTime>.</span><span class="sxs-lookup"><span data-stu-id="9b085-142">An example of such a type is <xref:System.DateTime>.</span></span> <span data-ttu-id="9b085-143">Причина этого основана на том, как работает архитектура .NET Framework: тип <xref:System.DateTime> определяется в mscorlib, самой основной библиотеке в .NET.</span><span class="sxs-lookup"><span data-stu-id="9b085-143">The reason for this is based on how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET.</span></span> <span data-ttu-id="9b085-144"><xref:System.DateTime>не разрешается приписывать атрибут, который исходит от другой сборки,<xref:System.ComponentModel.TypeConverterAttribute> которая вводит зависимость (из системы), поэтому обычный механизм обнаружения преобразователя типа путем приписывания не может быть поддержан.</span><span class="sxs-lookup"><span data-stu-id="9b085-144"><xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System) so the usual type converter discovery mechanism by attributing cannot be supported.</span></span> <span data-ttu-id="9b085-145">Вместо этого в средстве синтаксического анализа XAML имеется список типов, для которых необходима такая встроенная обработка; такие типы обрабатываются так же, как настоящие примитивы.</span><span class="sxs-lookup"><span data-stu-id="9b085-145">Instead, the XAML parser has a list of types that need such native processing and processes these similarly to how the true primitives are processed.</span></span> <span data-ttu-id="9b085-146">(В случае <xref:System.DateTime> этого включает в <xref:System.DateTime.Parse%2A>себя вызов .)</span><span class="sxs-lookup"><span data-stu-id="9b085-146">(In the case of <xref:System.DateTime> this involves a call to <xref:System.DateTime.Parse%2A>.)</span></span>  
  
<a name="Implementing_a_Type_Converter"></a>
## <a name="implementing-a-type-converter"></a><span data-ttu-id="9b085-147">Реализация преобразователя типов</span><span class="sxs-lookup"><span data-stu-id="9b085-147">Implementing a Type Converter</span></span>  
  
### <a name="typeconverter"></a><span data-ttu-id="9b085-148">TypeConverter</span><span class="sxs-lookup"><span data-stu-id="9b085-148">TypeConverter</span></span>  
 <span data-ttu-id="9b085-149">В <xref:System.Windows.Point> приведенном ранее примере был упомянут класс. <xref:System.Windows.PointConverter></span><span class="sxs-lookup"><span data-stu-id="9b085-149">In the <xref:System.Windows.Point> example given previously, the class <xref:System.Windows.PointConverter> was mentioned.</span></span> <span data-ttu-id="9b085-150">Для реализации XAML .NET все преобразователи типа, используемые для целей <xref:System.ComponentModel.TypeConverter>XAML, являются классами, которые вытекают из базового класса.</span><span class="sxs-lookup"><span data-stu-id="9b085-150">For .NET implementations of XAML, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="9b085-151">Класс <xref:System.ComponentModel.TypeConverter> существовал в версиях .NET Framework, которые предшествуют существованию XAML; одним из его первоначальных обычаев было обеспечить преобразование строки для диалога свойств в визуальных дизайнеров.</span><span class="sxs-lookup"><span data-stu-id="9b085-151">The <xref:System.ComponentModel.TypeConverter> class existed in versions of .NET Framework that precede the existence of XAML; one of its original usages was to provide string conversion for property dialogs in visual designers.</span></span> <span data-ttu-id="9b085-152">Для XAML роль <xref:System.ComponentModel.TypeConverter> расширена, включив в него базовый класс для конверсий строки и из строки, которые позволяют анализировать значение атрибута строки и, возможно, обрабатывать значение затрат ы времени конкретного свойства объекта обратно в строку для сериализации в качестве атрибута.</span><span class="sxs-lookup"><span data-stu-id="9b085-152">For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded to include being the base class for to-string and from-string conversions that enable parsing a string attribute value, and possibly processing a run-time value of a particular object property back into a string for serialization as an attribute.</span></span>  
  
 <span data-ttu-id="9b085-153"><xref:System.ComponentModel.TypeConverter>определяет четыре участника, которые имеют отношение к преобразованию в и из строк для целей обработки XAML:</span><span class="sxs-lookup"><span data-stu-id="9b085-153"><xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to and from strings for XAML processing purposes:</span></span>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>  
  
 <span data-ttu-id="9b085-154">Из них, наиболее <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>важным методом является .</span><span class="sxs-lookup"><span data-stu-id="9b085-154">Of these, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span></span> <span data-ttu-id="9b085-155">Этот метод преобразует входную строку к требуемому типу объекта.</span><span class="sxs-lookup"><span data-stu-id="9b085-155">This method converts the input string to the required object type.</span></span> <span data-ttu-id="9b085-156">Строго говоря, <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> метод может быть реализован для преобразования гораздо более широкого диапазона типов в тип назначения преобразователя и, таким образом, служить целям, которые выходят за рамки XAML, такие как поддержка конверсий времени выполнения, но для целей XAML это только путь кода, который может обрабатывать <xref:System.String> входные данные, которые имеют значение.</span><span class="sxs-lookup"><span data-stu-id="9b085-156">Strictly speaking, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method could be implemented to convert a much wider range of types into the converter's intended destination type, and thus serve purposes that extend beyond XAML such as supporting run-time conversions, but for XAML purposes it is only the code path that can process a <xref:System.String> input that matters.</span></span>  
  
 <span data-ttu-id="9b085-157">Следующим наиболее <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>важным методом является .</span><span class="sxs-lookup"><span data-stu-id="9b085-157">The next most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span> <span data-ttu-id="9b085-158">Если приложение преобразуется в представление разметки (например, если оно сохранено в XAML как файл), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> отвечает за создание представления разметки.</span><span class="sxs-lookup"><span data-stu-id="9b085-158">If an application is converted to a markup representation (for instance, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is responsible for producing a markup representation.</span></span> <span data-ttu-id="9b085-159">В этом случае, путь кода, который имеет значение `destinationType` для <xref:System.String> XAML, когда вы проходите из .</span><span class="sxs-lookup"><span data-stu-id="9b085-159">In this case, the code path that matters for XAML is when you pass a `destinationType` of <xref:System.String> .</span></span>  
  
 <span data-ttu-id="9b085-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> и <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> — это вспомогательные методы, используемые, когда служба запрашивает возможности реализации <xref:System.ComponentModel.TypeConverter> .</span><span class="sxs-lookup"><span data-stu-id="9b085-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation.</span></span> <span data-ttu-id="9b085-161">Вам необходимо реализовать эти методы для возврата `true` для определенных типов. Они аналогичны методам преобразования для поддержки вашего преобразователя.</span><span class="sxs-lookup"><span data-stu-id="9b085-161">You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support.</span></span> <span data-ttu-id="9b085-162">В целях XAML обычно это означает тип <xref:System.String> .</span><span class="sxs-lookup"><span data-stu-id="9b085-162">For XAML purposes, this generally means the <xref:System.String> type.</span></span>  
  
### <a name="culture-information-and-type-converters-for-xaml"></a><span data-ttu-id="9b085-163">Сведения о языке и преобразователи типов для XAML</span><span class="sxs-lookup"><span data-stu-id="9b085-163">Culture Information and Type Converters for XAML</span></span>  

 <span data-ttu-id="9b085-164">Каждая <xref:System.ComponentModel.TypeConverter> реализация может иметь свою собственную интерпретацию того, что представляет собой действительную строку для преобразования, а также может использовать или игнорировать описание типа, передаваемые в качестве параметров.</span><span class="sxs-lookup"><span data-stu-id="9b085-164">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description passed as parameters.</span></span> <span data-ttu-id="9b085-165">Важное замечание относительно языка и региональных параметров и преобразования типов XAML.</span><span class="sxs-lookup"><span data-stu-id="9b085-165">There is an important consideration with regard to culture and XAML type conversion.</span></span> <span data-ttu-id="9b085-166">Использование локализуемых строк в качестве значений атрибутов полностью поддерживается в XAML.</span><span class="sxs-lookup"><span data-stu-id="9b085-166">Using localizable strings as attribute values is entirely supported by XAML.</span></span> <span data-ttu-id="9b085-167">Но использование локализуемых строк в качестве входных данных преобразователя типов с учетом индивидуальных требований для языка и региональных параметров не поддерживается, так как преобразователи типов значений атрибутов XAML по необходимости выполняют анализ с фиксированным языком, используя язык и региональные параметры `en-US`.</span><span class="sxs-lookup"><span data-stu-id="9b085-167">But using that localizable string as type converter input with specific culture requirements is not supported, because type converters for XAML attribute values involve a necessarily fixed-language parsing behavior, using `en-US` culture.</span></span> <span data-ttu-id="9b085-168">Для получения дополнительной информации о причинах этого ограничения необходимо ознакомиться со спецификацией языка XAML[\[(MS-XAML.\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf)</span><span class="sxs-lookup"><span data-stu-id="9b085-168">For more information on the design reasons for this restriction, you should consult the XAML language specification ([\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf).</span></span>  
  
 <span data-ttu-id="9b085-169">Пример того, что учет языка и региональных параметров может быть важен: некоторые языки и региональные параметры используют запятую в качестве десятичного разделителя.</span><span class="sxs-lookup"><span data-stu-id="9b085-169">As an example where culture can be an issue, some cultures use a comma as their decimal point delimiter for numbers.</span></span> <span data-ttu-id="9b085-170">Это входит в противоречие с поведением многих преобразователей типов WPF XAML, которые используют запятую в качестве разделителя (исторически в обычной форме X,Y или в списках, разделенных запятыми).</span><span class="sxs-lookup"><span data-stu-id="9b085-170">This will collide with the behavior that many of the WPF XAML type converters have, which is to use a comma as a delimiter (based on historical precedents such as the common X,Y form, or comma delimited lists).</span></span> <span data-ttu-id="9b085-171">Даже передача языка и региональных параметров в окружающий XAML (установка параметра `Language` или `xml:lang` в значение `sl-SI`, как пример языка и региональных параметров, использующих запятую в качестве десятичного разделителя) не решает проблемы.</span><span class="sxs-lookup"><span data-stu-id="9b085-171">Even passing a culture in the surrounding XAML (setting `Language` or `xml:lang` to the `sl-SI` culture, an example of a culture that uses a comma for decimal in this way) does not solve the issue.</span></span>  
  
### <a name="implementing-convertfrom"></a><span data-ttu-id="9b085-172">Реализация ConvertFrom</span><span class="sxs-lookup"><span data-stu-id="9b085-172">Implementing ConvertFrom</span></span>  
 <span data-ttu-id="9b085-173">Для использования в качестве реализации <xref:System.ComponentModel.TypeConverter> , поддерживающей XAML, метод <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> данного преобразователя должен принимать строку как параметр `value` .</span><span class="sxs-lookup"><span data-stu-id="9b085-173">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter.</span></span> <span data-ttu-id="9b085-174">Если строка была в действительном формате <xref:System.ComponentModel.TypeConverter> и может быть преобразована реализацией, то возвращенный объект должен поддерживать отливку к типу, ожидаемому свойством.</span><span class="sxs-lookup"><span data-stu-id="9b085-174">If the string was in valid format, and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, then the returned object must support a cast to the type expected by the property.</span></span> <span data-ttu-id="9b085-175">В противном случае реализация <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> должна возвращать `null`.</span><span class="sxs-lookup"><span data-stu-id="9b085-175">Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.</span></span>  
  
 <span data-ttu-id="9b085-176">Каждая <xref:System.ComponentModel.TypeConverter> реализация может иметь свое собственное толкование того, что представляет собой действительную строку для преобразования, а также может использовать или игнорировать описание типа или контексты культуры, передаваемые в качестве параметров.</span><span class="sxs-lookup"><span data-stu-id="9b085-176">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description or culture contexts passed as parameters.</span></span> <span data-ttu-id="9b085-177">Тем не менее обработка WPF XAML может не передать значения в контекст описания типа во всех случаях, а также может не передать язык и региональные параметры на основе `xml:lang`.</span><span class="sxs-lookup"><span data-stu-id="9b085-177">However, the WPF XAML processing might not pass values to the type description context in all cases, and also might not pass culture based on `xml:lang`.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9b085-178">Не используйте фигурные скобки, особенно {, как возможный элемент формата строки.</span><span class="sxs-lookup"><span data-stu-id="9b085-178">Do not use the curly brace characters, particularly {, as a possible element of your string format.</span></span> <span data-ttu-id="9b085-179">Эти символы зарезервированы как вход и выход для последовательности расширения разметки.</span><span class="sxs-lookup"><span data-stu-id="9b085-179">These characters are reserved as the entry and exit for a markup extension sequence.</span></span>  
  
### <a name="implementing-convertto"></a><span data-ttu-id="9b085-180">Реализация ConvertTo</span><span class="sxs-lookup"><span data-stu-id="9b085-180">Implementing ConvertTo</span></span>  
 <span data-ttu-id="9b085-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> может использоваться для поддержки сериализации.</span><span class="sxs-lookup"><span data-stu-id="9b085-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support.</span></span> <span data-ttu-id="9b085-182">Поддержка сериализации с помощью <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> для пользовательского типа и его преобразователя типов не обязательна.</span><span class="sxs-lookup"><span data-stu-id="9b085-182">Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement.</span></span> <span data-ttu-id="9b085-183">Тем не менее, при реализации элемента управления или использовании сериализации как часть функций или класса, необходимо реализовать <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="9b085-183">However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span>  
  
 <span data-ttu-id="9b085-184">Чтобы быть пригодным <xref:System.ComponentModel.TypeConverter> для реализации в <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> качестве реализации, поддерживающей XAML, метод для этого преобразователя должен принять экземпляр типа (или значение), поддерживаемый в `value` качестве параметра.</span><span class="sxs-lookup"><span data-stu-id="9b085-184">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) being supported as the `value` parameter.</span></span> <span data-ttu-id="9b085-185">Когда `destinationType` параметр типа, <xref:System.String>то возвращенный объект должен быть <xref:System.String>в состоянии быть отлиты как.</span><span class="sxs-lookup"><span data-stu-id="9b085-185">When the `destinationType` parameter is the type <xref:System.String>, then the returned object must be able to be cast as <xref:System.String>.</span></span> <span data-ttu-id="9b085-186">Возвращаемая строка должна представлять сериализованное значение `value`.</span><span class="sxs-lookup"><span data-stu-id="9b085-186">The returned string must represent a serialized value of `value`.</span></span> <span data-ttu-id="9b085-187">В идеале формат сериализации, который вы выбираете, должен быть способен <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> генерировать такое же значение, если эта строка была передана в реализацию того же конвертера без значительной потери информации.</span><span class="sxs-lookup"><span data-stu-id="9b085-187">Ideally, the serialization format you choose should be capable of generating the same value if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.</span></span>  
  
 <span data-ttu-id="9b085-188">Если значение не может быть сериализовано или преобразователь не поддерживает сериализацию, <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> реализация должна вернуться, `null`и в этом случае разрешается выбросить исключение.</span><span class="sxs-lookup"><span data-stu-id="9b085-188">If the value cannot be serialized, or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null`, and is permitted to throw an exception in this case.</span></span> <span data-ttu-id="9b085-189">Но если вы делаете исключения, вы должны сообщить о невозможности использования этого преобразования как части реализации, <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> так что наилучшая практика проверки с <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> первую, чтобы избежать исключений поддерживается.</span><span class="sxs-lookup"><span data-stu-id="9b085-189">But if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.</span></span>  
  
 <span data-ttu-id="9b085-190">Если `destinationType` параметр не <xref:System.String>имеет типа, вы можете выбрать свой собственный конвертер обработки.</span><span class="sxs-lookup"><span data-stu-id="9b085-190">If `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling.</span></span> <span data-ttu-id="9b085-191">Как правило, вы возвращаетесь к базовой <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> обработке реализации, которая в базовом случае вызывает конкретное исключение.</span><span class="sxs-lookup"><span data-stu-id="9b085-191">Typically, you would revert to base implementation handling, which in the basemost <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.</span></span>  
  
### <a name="implementing-canconvertto"></a><span data-ttu-id="9b085-192">Реализация CanConvertTo</span><span class="sxs-lookup"><span data-stu-id="9b085-192">Implementing CanConvertTo</span></span>  
 <span data-ttu-id="9b085-193">Ваша реализация <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> должна возвращать `true` для `destinationType` типа <xref:System.String>, а в противном случае обращаться к базовой реализации.</span><span class="sxs-lookup"><span data-stu-id="9b085-193">Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
### <a name="implementing-canconvertfrom"></a><span data-ttu-id="9b085-194">Реализация CanConvertFrom</span><span class="sxs-lookup"><span data-stu-id="9b085-194">Implementing CanConvertFrom</span></span>  
 <span data-ttu-id="9b085-195">Ваша реализация <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> должна возвращать `true` для `sourceType` типа <xref:System.String>, а в противном случае обращаться к базовой реализации.</span><span class="sxs-lookup"><span data-stu-id="9b085-195">Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
<a name="Applying_the_TypeConverterAttribute"></a>
## <a name="applying-the-typeconverterattribute"></a><span data-ttu-id="9b085-196">Применение TypeConverterAttribute</span><span class="sxs-lookup"><span data-stu-id="9b085-196">Applying the TypeConverterAttribute</span></span>  
 <span data-ttu-id="9b085-197">Для того, чтобы конвертер пользовательского типа использовался в качестве преобразователя типа действия <xref:System.ComponentModel.TypeConverterAttribute> для пользовательского класса процессором XAML, необходимо применить его к определению класса.</span><span class="sxs-lookup"><span data-stu-id="9b085-197">In order for your custom type converter to be used as the acting type converter for a custom class by a XAML processor, you must apply the <xref:System.ComponentModel.TypeConverterAttribute> to your class definition.</span></span> <span data-ttu-id="9b085-198">Имя <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> , указываемое в атрибуте, должно быть именем типа пользовательского преобразователя типов.</span><span class="sxs-lookup"><span data-stu-id="9b085-198">The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter.</span></span> <span data-ttu-id="9b085-199">Если этот атрибут применен, то в случае, когда обработчик XAML обрабатывает значения, в которых тип свойства использует тип пользовательского класса, обработчик может ввести строки и вернуть экземпляры объекта.</span><span class="sxs-lookup"><span data-stu-id="9b085-199">With this attribute applied, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.</span></span>  
  
 <span data-ttu-id="9b085-200">Вы также можете предоставить преобразователь типов для отдельных свойств.</span><span class="sxs-lookup"><span data-stu-id="9b085-200">You can also provide a type converter on a per-property basis.</span></span> <span data-ttu-id="9b085-201">Вместо того, <xref:System.ComponentModel.TypeConverterAttribute> чтобы применять определение класса, примените его к определению свойства (основное определение, а не `get` / `set` реализации в нем).</span><span class="sxs-lookup"><span data-stu-id="9b085-201">Instead of applying a <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it).</span></span> <span data-ttu-id="9b085-202">Тип свойства должен соответствовать типу, который обрабатывается пользовательским преобразователем типов.</span><span class="sxs-lookup"><span data-stu-id="9b085-202">The type of the property must match the type that is processed by your custom type converter.</span></span> <span data-ttu-id="9b085-203">Если этот атрибут применяется, обработчик XAML может обработать входные строки и вернуть экземпляры объекта при работе со значениями этого свойства.</span><span class="sxs-lookup"><span data-stu-id="9b085-203">With this attribute applied, when a XAML processor handles values of that property, it can process input strings and return object instances.</span></span> <span data-ttu-id="9b085-204">Метод конвертера типа в свойстве особенно полезен, если вы решите использовать тип свойств из Microsoft .NET Framework <xref:System.ComponentModel.TypeConverterAttribute> или из какой-либо другой библиотеки, где вы не можете контролировать определение класса и не можете применить его.</span><span class="sxs-lookup"><span data-stu-id="9b085-204">The per-property type converter technique is particularly useful if you choose to use a property type from Microsoft .NET Framework or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9b085-205">См. также раздел</span><span class="sxs-lookup"><span data-stu-id="9b085-205">See also</span></span>

- <xref:System.ComponentModel.TypeConverter>
- [<span data-ttu-id="9b085-206">Обзор XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="9b085-206">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="9b085-207">Расширения разметки и XAML WPF</span><span class="sxs-lookup"><span data-stu-id="9b085-207">Markup Extensions and WPF XAML</span></span>](markup-extensions-and-wpf-xaml.md)
- [<span data-ttu-id="9b085-208">Подробное описание синтаксиса XAML</span><span class="sxs-lookup"><span data-stu-id="9b085-208">XAML Syntax In Detail</span></span>](xaml-syntax-in-detail.md)
