---
title: TypeConverters и XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [WPF], TypeConverter class
ms.assetid: f6313e4d-e89d-497d-ac87-b43511a1ae4b
ms.openlocfilehash: aac6c347886b2c29e599952d7642fbe76441b617
ms.sourcegitcommit: 944ddc52b7f2632f30c668815f92b378efd38eea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/03/2019
ms.locfileid: "73458912"
---
# <a name="typeconverters-and-xaml"></a>TypeConverters и XAML
Этот раздел посвящен цели преобразования типов из строк — одной из основных функций языка XAML. В .NET Framework класс <xref:System.ComponentModel.TypeConverter> служит в качестве части реализации управляемого пользовательского класса, который можно использовать в качестве значения свойства в использовании атрибута XAML. При написании пользовательского класса и необходимости использовать экземпляры класса в качестве значений атрибутов, устанавливаемых в XAML, может потребоваться применить к классу <xref:System.ComponentModel.TypeConverterAttribute>, написать пользовательский класс <xref:System.ComponentModel.TypeConverter> или и то, и другое.  

## <a name="type-conversion-concepts"></a>Понятия преобразования типов  
  
### <a name="xaml-and-string-values"></a>XAML и строковые значения  
 Когда задается значение атрибута в файле XAML, начальный тип этого значения — строка чистого текста. Даже другие примитивы, такие как <xref:System.Double>, являются исходными текстовыми строками для обработчика XAML.  
  
 XAML-обработчику требуется два сообщения для того, чтобы обработать значение атрибута. Первый из них — это тип значения свойства, которое должно быть задано. Любую строку, которая определяет значение атрибута и обрабатывается в XAML, в конечном счете необходимо преобразовать или разрешить в значение этого типа. Если значение — примитивный тип, понятный средству синтаксического анализа XAML (например, числовое значение), выполняется попытка прямого преобразования строки. Если значение является перечислением, то строка используется для проверки совпадения имени в этом перечислении с именем константы. Если значение не является ни примитивом, понятным средству синтаксического анализа, ни перечислением, то этот тип должен обладать возможностью предоставления экземпляра типа или значения, основанного на преобразованной строке. Это делается указанием класса преобразователя типов. Преобразователь типов — это фактически вспомогательный класс, предоставляющий значения другого класса как сценариям XAML, так и потенциально вызовам из кода .NET.  
  
### <a name="using-existing-type-conversion-behavior-in-xaml"></a>Использование поведения преобразования существующего типа в XAML  
 В зависимости от уровня понимания концепций XAML, вы, возможно, уже используете преобразование типа в простом приложении XAML, не реализуя его. Например, WPF определяет буквально сотни свойств, которые принимают значение типа <xref:System.Windows.Point>. <xref:System.Windows.Point> — это значение, описывающее координату в двухмерном пространстве координат и имеющее только два важных свойства: <xref:System.Windows.Point.X%2A> и <xref:System.Windows.Point.Y%2A>. При указании точки в XAML она указывается в виде строки с разделителем (обычно запятой) между <xref:System.Windows.Point.X%2A> и <xref:System.Windows.Point.Y%2A> указанными значениями. Пример: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`.  
  
 Даже этот простой тип <xref:System.Windows.Point> и его простое использование в XAML — это преобразователь типов. В этом случае это класс <xref:System.Windows.PointConverter>.  
  
 Преобразователь типов для <xref:System.Windows.Point>, определенный на уровне класса, упрощает использование разметки всех свойств, которые принимают <xref:System.Windows.Point>. Без преобразователя типов для создания примера, показанного выше, требуется гораздо больше разметки.  

```xaml
<LinearGradientBrush>
  <LinearGradientBrush.StartPoint>
    <Point X="0" Y="0"/>
  </LinearGradientBrush.StartPoint>
  <LinearGradientBrush.EndPoint>
    <Point X="1" Y="1"/>
  </LinearGradientBrush.EndPoint>
</LinearGradientBrush>
 ```
  
 Использовать преобразование типа строки или более многословный синтаксис — этот выбор диктуется только стилем написания кода. Инструментарий рабочего процесса XAML также может оказывать влияние на то, как задаются значения. Некоторые инструменты XAML склонны создавать очень подробную разметку, так как это облегчает переключение между представлениями конструктора и собственным механизмом сериализации.  
  
 Существующие преобразователи типов обычно можно обнаружить на типах WPF и .NET Framework, проверив класс (или свойство) на наличие примененной <xref:System.ComponentModel.TypeConverterAttribute>. Этот атрибут содержит имя класса, поддерживающего преобразование для данного типа, как для XAML, так потенциально и для других целей.  
  
### <a name="type-converters-and-markup-extensions"></a>Преобразователи типов и расширения разметки  
 Расширения разметки и преобразователи типов играют ортогональные роли в терминах поведения обработчика XAML и сценариев, к которым они применяются. Хотя для расширения разметки контекст доступен, поведение преобразования типов свойств, когда расширение разметки предоставляет значение, обычно не включается в реализацию расширения разметки. Другими словами, даже если расширение разметки возвращает текстовую строку в качестве выходных данных `ProvideValue`, преобразование типа для этой строки относительно конкретного свойства или типа значения свойства не применяется. Обычно целью расширения разметки является обработка строки и возврат объекта без использования какого бы то ни было преобразователя типов.  
  
 Одна общая ситуация, где необходимо расширение разметки, а не преобразователь типов, заключается в создании ссылки на объект, который уже существует. В лучшем случае преобразователь типов с неопределенным состоянием может только создать новый экземпляр, что может быть нежелательно. Дополнительные сведения о расширениях разметки см. в разделе [Расширения разметки и XAML WPF](markup-extensions-and-wpf-xaml.md).  
  
### <a name="native-type-converters"></a>Собственные преобразователи типа  
 В реализации средства синтаксического анализа XAML в WPF и платформе .NET Framework существуют несколько типов, поддерживающих собственную обработку преобразования типа, но нет типов, которые можно рассматривать как примитивы. Пример такого типа — <xref:System.DateTime>. Причина этого зависит от того, как работает архитектура .NET Framework: тип <xref:System.DateTime> определен в mscorlib, самой простой библиотеке в .NET. <xref:System.DateTime> не разрешено использовать атрибут, поступающий из другой сборки, которая вводит зависимость (<xref:System.ComponentModel.TypeConverterAttribute> из системы), поэтому стандартный механизм обнаружения преобразователя типов с помощью атрибутов не поддерживается. Вместо этого в средстве синтаксического анализа XAML имеется список типов, для которых необходима такая встроенная обработка; такие типы обрабатываются так же, как настоящие примитивы. (В случае <xref:System.DateTime> это включает вызов <xref:System.DateTime.Parse%2A>.)  
  
<a name="Implementing_a_Type_Converter"></a>   
## <a name="implementing-a-type-converter"></a>Реализация преобразователя типов  
  
### <a name="typeconverter"></a>TypeConverter  
 В <xref:System.Windows.Point> примере, приведенном ранее, был упомянут класс <xref:System.Windows.PointConverter>. Для реализаций XAML в .NET все преобразователи типов, используемые для целей XAML, являются классами, производными от базового класса <xref:System.ComponentModel.TypeConverter>. Класс <xref:System.ComponentModel.TypeConverter> существовал в версиях .NET Framework, предшествующих существованию XAML; одним из его первоначальных применений было преобразование строк для диалоговых окон свойств в визуальных конструкторах. Для XAML роль <xref:System.ComponentModel.TypeConverter> расширяется, чтобы включать в себя базовый класс для преобразований в строковые и из строк, которые позволяют анализировать значение атрибута String, и, возможно, обработку значения времени выполнения определенного свойства объекта обратно в строку для Сериализация в качестве атрибута.  
  
 <xref:System.ComponentModel.TypeConverter> определяет четыре элемента, которые относятся к преобразованию в строки и из строк для целей обработки XAML:  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>  
  
 Наиболее важным методом является <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>. Этот метод преобразует входную строку к требуемому типу объекта. Строго говоря, метод <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> может быть реализован для преобразования более широкого диапазона типов в предполагаемый целевой тип преобразователя. Таким образом, он обеспечивает более широкие возможности, чем XAML, например поддерживающие преобразования во время выполнения, но для XAML это только путь кода, который может обработать <xref:System.String> входные данные, имеющие значение.  
  
 Следующий самый важный метод — <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>. Если приложение преобразуется в представление разметки (например, если оно сохраняется в XAML как файл), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> отвечает за создание представления разметки. В этом случае путь кода, который важен для XAML, — при передаче `destinationType` <xref:System.String>.  
  
 <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> и <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> — это вспомогательные методы, используемые, когда служба запрашивает возможности реализации <xref:System.ComponentModel.TypeConverter> . Вам необходимо реализовать эти методы для возврата `true` для определенных типов. Они аналогичны методам преобразования для поддержки вашего преобразователя. В целях XAML обычно это означает тип <xref:System.String> .  
  
### <a name="culture-information-and-type-converters-for-xaml"></a>Сведения о языке и преобразователи типов для XAML  
 Каждая реализация <xref:System.ComponentModel.TypeConverter> может иметь собственную интерпретацию того, что составляет допустимую строку для преобразования, а также может использовать или игнорировать описание типа, передаваемое в качестве параметров. Важное замечание относительно языка и региональных параметров и преобразования типов XAML. Использование локализуемых строк в качестве значений атрибутов полностью поддерживается в XAML. Но использование локализуемых строк в качестве входных данных преобразователя типов с учетом индивидуальных требований для языка и региональных параметров не поддерживается, так как преобразователи типов значений атрибутов XAML по необходимости выполняют анализ с фиксированным языком, используя язык и региональные параметры `en-US`. Дополнительные сведения о причинах этого ограничения с точки зрения проектирования см. в спецификации языка XAML ([\[MS-XAML\]](https://go.microsoft.com/fwlink/?LinkId=114525)).  
  
 Пример того, что учет языка и региональных параметров может быть важен: некоторые языки и региональные параметры используют запятую в качестве десятичного разделителя. Это входит в противоречие с поведением многих преобразователей типов WPF XAML, которые используют запятую в качестве разделителя (исторически в обычной форме X,Y или в списках, разделенных запятыми). Даже передача языка и региональных параметров в окружающий XAML (установка параметра `Language` или `xml:lang` в значение `sl-SI`, как пример языка и региональных параметров, использующих запятую в качестве десятичного разделителя) не решает проблемы.  
  
### <a name="implementing-convertfrom"></a>Реализация ConvertFrom  
 Для использования в качестве реализации <xref:System.ComponentModel.TypeConverter> , поддерживающей XAML, метод <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> данного преобразователя должен принимать строку как параметр `value` . Если строка находилась в допустимом формате и может быть преобразована реализацией <xref:System.ComponentModel.TypeConverter>, возвращаемый объект должен поддерживать приведение к типу, ожидаемому свойством. В противном случае реализация <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> должна возвращать `null`.  
  
 Каждая реализация <xref:System.ComponentModel.TypeConverter> может иметь собственную интерпретацию того, что составляет допустимую строку для преобразования, а также может использовать или игнорировать описание типа или контекстов языка и региональных параметров, переданных в качестве параметров. Тем не менее обработка WPF XAML может не передать значения в контекст описания типа во всех случаях, а также может не передать язык и региональные параметры на основе `xml:lang`.  
  
> [!NOTE]
> Не используйте фигурные скобки, особенно {, как возможный элемент формата строки. Эти символы зарезервированы как вход и выход для последовательности расширения разметки.  
  
### <a name="implementing-convertto"></a>Реализация ConvertTo  
 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> может использоваться для поддержки сериализации. Поддержка сериализации с помощью <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> для пользовательского типа и его преобразователя типов не обязательна. Тем не менее, при реализации элемента управления или использовании сериализации как часть функций или класса, необходимо реализовать <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.  
  
 Для использования в качестве <xref:System.ComponentModel.TypeConverter>ной реализации, поддерживающей XAML, метод <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> для этого преобразователя должен принимать экземпляр типа (или значения), поддерживаемый в качестве параметра `value`. Если параметр `destinationType` имеет тип <xref:System.String>, возвращаемый объект должен иметь возможность приведения <xref:System.String>. Возвращаемая строка должна представлять сериализованное значение `value`. В идеале выбранный формат сериализации должен иметь возможность создания того же значения, если эта строка была передана <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>ной реализации того же преобразователя без значительной потери информации.  
  
 Если значение не может быть сериализовано или преобразователь не поддерживает сериализацию, <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> реализация должна возвращать `null`и в данном случае может вызываться исключение. Но если вы выдаете исключения, следует сообщить о невозможности использовать это преобразование как часть реализации <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>, чтобы лучше проверяться с <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> во избежание исключений.  
  
 Если параметр `destinationType` не имеет тип <xref:System.String>, можно выбрать собственную обработку преобразователя. Как правило, возвращается к базовой обработке реализации, которая в <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> басемост создает определенное исключение.  
  
### <a name="implementing-canconvertto"></a>Реализация CanConvertTo  
 Ваша реализация <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> должна возвращать `true` для `destinationType` типа <xref:System.String>, а в противном случае обращаться к базовой реализации.  
  
### <a name="implementing-canconvertfrom"></a>Реализация CanConvertFrom  
 Ваша реализация <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> должна возвращать `true` для `sourceType` типа <xref:System.String>, а в противном случае обращаться к базовой реализации.  
  
<a name="Applying_the_TypeConverterAttribute"></a>   
## <a name="applying-the-typeconverterattribute"></a>Применение TypeConverterAttribute  
 Чтобы пользовательский преобразователь типов мог использоваться в качестве преобразователя для действующего типа для пользовательского класса обработчиком XAML, необходимо применить <xref:System.ComponentModel.TypeConverterAttribute> к определению класса. Имя <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> , указываемое в атрибуте, должно быть именем типа пользовательского преобразователя типов. Если этот атрибут применен, то в случае, когда обработчик XAML обрабатывает значения, в которых тип свойства использует тип пользовательского класса, обработчик может ввести строки и вернуть экземпляры объекта.  
  
 Вы также можете предоставить преобразователь типов для отдельных свойств. Вместо применения <xref:System.ComponentModel.TypeConverterAttribute> к определению класса примените его к определению свойства (основное определение, а не `get`/`set` реализации внутри него). Тип свойства должен соответствовать типу, который обрабатывается пользовательским преобразователем типов. Если этот атрибут применяется, обработчик XAML может обработать входные строки и вернуть экземпляры объекта при работе со значениями этого свойства. Использование преобразователя типов для каждого свойства особенно полезно, если вы решили использовать тип свойства из Microsoft .NET Framework или из другой библиотеки, где нельзя управлять определением класса и не применять <xref:System.ComponentModel.TypeConverterAttribute> там.  
  
## <a name="see-also"></a>См. также

- <xref:System.ComponentModel.TypeConverter>
- [Общие сведения о языке XAML (WPF)](../../../desktop-wpf/fundamentals/xaml.md)
- [Расширения разметки и XAML WPF](markup-extensions-and-wpf-xaml.md)
- [Подробное описание синтаксиса XAML](xaml-syntax-in-detail.md)
