---
title: TypeConverters и XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [WPF], TypeConverter class
ms.assetid: f6313e4d-e89d-497d-ac87-b43511a1ae4b
ms.openlocfilehash: 94cfce44d5702e0550310723ec56184096165436
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79187297"
---
# <a name="typeconverters-and-xaml"></a>TypeConverters и XAML
Этот раздел посвящен цели преобразования типов из строк — одной из основных функций языка XAML. В рамках .NET <xref:System.ComponentModel.TypeConverter> класс служит определенной цели в рамках реализации управляемого пользовательского класса, который может быть использован в качестве значения свойства в использовании атрибутов XAML. Если вы пишете пользовательский класс и хотите, чтобы экземпляры вашего класса были пригодны для удобого значений XAML settable, возможно, потребуется применить их <xref:System.ComponentModel.TypeConverterAttribute> к своему классу, написать пользовательский <xref:System.ComponentModel.TypeConverter> класс или и то, и другое.  

## <a name="type-conversion-concepts"></a>Понятия преобразования типов  
  
### <a name="xaml-and-string-values"></a>XAML и строковые значения  
 Когда задается значение атрибута в файле XAML, начальный тип этого значения — строка чистого текста. Даже другие примитивы, такие как <xref:System.Double> изначально текстовые строки для процессора XAML.  
  
 XAML-обработчику требуется два сообщения для того, чтобы обработать значение атрибута. Первый из них — это тип значения свойства, которое должно быть задано. Любую строку, которая определяет значение атрибута и обрабатывается в XAML, в конечном счете необходимо преобразовать или разрешить в значение этого типа. Если значение — примитивный тип, понятный средству синтаксического анализа XAML (например, числовое значение), выполняется попытка прямого преобразования строки. Если значение является перечислением, то строка используется для проверки совпадения имени в этом перечислении с именем константы. Если значение не является ни примитивом, понятным средству синтаксического анализа, ни перечислением, то этот тип должен обладать возможностью предоставления экземпляра типа или значения, основанного на преобразованной строке. Это делается указанием класса преобразователя типов. Преобразователь типов — это фактически вспомогательный класс, предоставляющий значения другого класса как сценариям XAML, так и потенциально вызовам из кода .NET.  
  
### <a name="using-existing-type-conversion-behavior-in-xaml"></a>Использование поведения преобразования существующего типа в XAML  
 В зависимости от уровня понимания концепций XAML, вы, возможно, уже используете преобразование типа в простом приложении XAML, не реализуя его. Например, WPF определяет буквально сотни свойств, которые <xref:System.Windows.Point>принимают значение типа. A <xref:System.Windows.Point> это значение, которое описывает координаты в двухмерном пространстве <xref:System.Windows.Point.X%2A> <xref:System.Windows.Point.Y%2A>координат, и это действительно просто имеет два важных свойства: и . Когда вы указываете точку в XAML, вы указываете ее как строку <xref:System.Windows.Point.X%2A> с <xref:System.Windows.Point.Y%2A> делимитером (обычно запятой) между и значениями, которые вы предоставляете. Например: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`.  
  
 Даже этот простой тип и его простое <xref:System.Windows.Point> использование в XAML включают в себя тип преобразователя. В этом случае это <xref:System.Windows.PointConverter>класс.  
  
 Преобразователь <xref:System.Windows.Point> типа, определенный на уровне класса, упрощает <xref:System.Windows.Point>использование разметки всех свойств, которые принимают. Без преобразователя типов для создания примера, показанного выше, требуется гораздо больше разметки.  

```xaml
<LinearGradientBrush>
  <LinearGradientBrush.StartPoint>
    <Point X="0" Y="0"/>
  </LinearGradientBrush.StartPoint>
  <LinearGradientBrush.EndPoint>
    <Point X="1" Y="1"/>
  </LinearGradientBrush.EndPoint>
</LinearGradientBrush>
 ```
  
 Использовать преобразование типа строки или более многословный синтаксис — этот выбор диктуется только стилем написания кода. Инструментарий рабочего процесса XAML также может оказывать влияние на то, как задаются значения. Некоторые инструменты XAML склонны создавать очень подробную разметку, так как это облегчает переключение между представлениями конструктора и собственным механизмом сериализации.  
  
 Существующие преобразователи типа обычно могут быть обнаружены на типах WPF и <xref:System.ComponentModel.TypeConverterAttribute>.NET Framework, проверяя класс (или свойство) на наличие прикладного. Этот атрибут содержит имя класса, поддерживающего преобразование для данного типа, как для XAML, так потенциально и для других целей.  
  
### <a name="type-converters-and-markup-extensions"></a>Преобразователи типов и расширения разметки  
 Расширения разметки и преобразователи типов играют ортогональные роли в терминах поведения обработчика XAML и сценариев, к которым они применяются. Хотя для расширения разметки контекст доступен, поведение преобразования типов свойств, когда расширение разметки предоставляет значение, обычно не включается в реализацию расширения разметки. Другими словами, даже если расширение разметки возвращает текстовую строку в качестве выходных данных `ProvideValue`, преобразование типа для этой строки относительно конкретного свойства или типа значения свойства не применяется. Обычно целью расширения разметки является обработка строки и возврат объекта без использования какого бы то ни было преобразователя типов.  
  
 Одна общая ситуация, где необходимо расширение разметки, а не преобразователь типов, заключается в создании ссылки на объект, который уже существует. В лучшем случае преобразователь типов с неопределенным состоянием может только создать новый экземпляр, что может быть нежелательно. Дополнительные сведения о расширениях разметки см. в разделе [Расширения разметки и XAML WPF](markup-extensions-and-wpf-xaml.md).  
  
### <a name="native-type-converters"></a>Собственные преобразователи типа  
 В реализации средства синтаксического анализа XAML в WPF и платформе .NET Framework существуют несколько типов, поддерживающих собственную обработку преобразования типа, но нет типов, которые можно рассматривать как примитивы. Пример такого типа — <xref:System.DateTime>. Причина этого основана на том, как работает архитектура .NET Framework: тип <xref:System.DateTime> определяется в mscorlib, самой основной библиотеке в .NET. <xref:System.DateTime>не разрешается приписывать атрибут, который исходит от другой сборки,<xref:System.ComponentModel.TypeConverterAttribute> которая вводит зависимость (из системы), поэтому обычный механизм обнаружения преобразователя типа путем приписывания не может быть поддержан. Вместо этого в средстве синтаксического анализа XAML имеется список типов, для которых необходима такая встроенная обработка; такие типы обрабатываются так же, как настоящие примитивы. (В случае <xref:System.DateTime> этого включает в <xref:System.DateTime.Parse%2A>себя вызов .)  
  
<a name="Implementing_a_Type_Converter"></a>
## <a name="implementing-a-type-converter"></a>Реализация преобразователя типов  
  
### <a name="typeconverter"></a>TypeConverter  
 В <xref:System.Windows.Point> приведенном ранее примере был упомянут класс. <xref:System.Windows.PointConverter> Для реализации XAML .NET все преобразователи типа, используемые для целей <xref:System.ComponentModel.TypeConverter>XAML, являются классами, которые вытекают из базового класса. Класс <xref:System.ComponentModel.TypeConverter> существовал в версиях .NET Framework, которые предшествуют существованию XAML; одним из его первоначальных обычаев было обеспечить преобразование строки для диалога свойств в визуальных дизайнеров. Для XAML роль <xref:System.ComponentModel.TypeConverter> расширена, включив в него базовый класс для конверсий строки и из строки, которые позволяют анализировать значение атрибута строки и, возможно, обрабатывать значение затрат ы времени конкретного свойства объекта обратно в строку для сериализации в качестве атрибута.  
  
 <xref:System.ComponentModel.TypeConverter>определяет четыре участника, которые имеют отношение к преобразованию в и из строк для целей обработки XAML:  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>  
  
 Из них, наиболее <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>важным методом является . Этот метод преобразует входную строку к требуемому типу объекта. Строго говоря, <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> метод может быть реализован для преобразования гораздо более широкого диапазона типов в тип назначения преобразователя и, таким образом, служить целям, которые выходят за рамки XAML, такие как поддержка конверсий времени выполнения, но для целей XAML это только путь кода, который может обрабатывать <xref:System.String> входные данные, которые имеют значение.  
  
 Следующим наиболее <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>важным методом является . Если приложение преобразуется в представление разметки (например, если оно сохранено в XAML как файл), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> отвечает за создание представления разметки. В этом случае, путь кода, который имеет значение `destinationType` для <xref:System.String> XAML, когда вы проходите из .  
  
 <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> и <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> — это вспомогательные методы, используемые, когда служба запрашивает возможности реализации <xref:System.ComponentModel.TypeConverter> . Вам необходимо реализовать эти методы для возврата `true` для определенных типов. Они аналогичны методам преобразования для поддержки вашего преобразователя. В целях XAML обычно это означает тип <xref:System.String> .  
  
### <a name="culture-information-and-type-converters-for-xaml"></a>Сведения о языке и преобразователи типов для XAML  

 Каждая <xref:System.ComponentModel.TypeConverter> реализация может иметь свою собственную интерпретацию того, что представляет собой действительную строку для преобразования, а также может использовать или игнорировать описание типа, передаваемые в качестве параметров. Важное замечание относительно языка и региональных параметров и преобразования типов XAML. Использование локализуемых строк в качестве значений атрибутов полностью поддерживается в XAML. Но использование локализуемых строк в качестве входных данных преобразователя типов с учетом индивидуальных требований для языка и региональных параметров не поддерживается, так как преобразователи типов значений атрибутов XAML по необходимости выполняют анализ с фиксированным языком, используя язык и региональные параметры `en-US`. Для получения дополнительной информации о причинах этого ограничения необходимо ознакомиться со спецификацией языка XAML[\[(MS-XAML.\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf)  
  
 Пример того, что учет языка и региональных параметров может быть важен: некоторые языки и региональные параметры используют запятую в качестве десятичного разделителя. Это входит в противоречие с поведением многих преобразователей типов WPF XAML, которые используют запятую в качестве разделителя (исторически в обычной форме X,Y или в списках, разделенных запятыми). Даже передача языка и региональных параметров в окружающий XAML (установка параметра `Language` или `xml:lang` в значение `sl-SI`, как пример языка и региональных параметров, использующих запятую в качестве десятичного разделителя) не решает проблемы.  
  
### <a name="implementing-convertfrom"></a>Реализация ConvertFrom  
 Для использования в качестве реализации <xref:System.ComponentModel.TypeConverter> , поддерживающей XAML, метод <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> данного преобразователя должен принимать строку как параметр `value` . Если строка была в действительном формате <xref:System.ComponentModel.TypeConverter> и может быть преобразована реализацией, то возвращенный объект должен поддерживать отливку к типу, ожидаемому свойством. В противном случае реализация <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> должна возвращать `null`.  
  
 Каждая <xref:System.ComponentModel.TypeConverter> реализация может иметь свое собственное толкование того, что представляет собой действительную строку для преобразования, а также может использовать или игнорировать описание типа или контексты культуры, передаваемые в качестве параметров. Тем не менее обработка WPF XAML может не передать значения в контекст описания типа во всех случаях, а также может не передать язык и региональные параметры на основе `xml:lang`.  
  
> [!NOTE]
> Не используйте фигурные скобки, особенно {, как возможный элемент формата строки. Эти символы зарезервированы как вход и выход для последовательности расширения разметки.  
  
### <a name="implementing-convertto"></a>Реализация ConvertTo  
 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> может использоваться для поддержки сериализации. Поддержка сериализации с помощью <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> для пользовательского типа и его преобразователя типов не обязательна. Тем не менее, при реализации элемента управления или использовании сериализации как часть функций или класса, необходимо реализовать <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.  
  
 Чтобы быть пригодным <xref:System.ComponentModel.TypeConverter> для реализации в <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> качестве реализации, поддерживающей XAML, метод для этого преобразователя должен принять экземпляр типа (или значение), поддерживаемый в `value` качестве параметра. Когда `destinationType` параметр типа, <xref:System.String>то возвращенный объект должен быть <xref:System.String>в состоянии быть отлиты как. Возвращаемая строка должна представлять сериализованное значение `value`. В идеале формат сериализации, который вы выбираете, должен быть способен <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> генерировать такое же значение, если эта строка была передана в реализацию того же конвертера без значительной потери информации.  
  
 Если значение не может быть сериализовано или преобразователь не поддерживает сериализацию, <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> реализация должна вернуться, `null`и в этом случае разрешается выбросить исключение. Но если вы делаете исключения, вы должны сообщить о невозможности использования этого преобразования как части реализации, <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> так что наилучшая практика проверки с <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> первую, чтобы избежать исключений поддерживается.  
  
 Если `destinationType` параметр не <xref:System.String>имеет типа, вы можете выбрать свой собственный конвертер обработки. Как правило, вы возвращаетесь к базовой <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> обработке реализации, которая в базовом случае вызывает конкретное исключение.  
  
### <a name="implementing-canconvertto"></a>Реализация CanConvertTo  
 Ваша реализация <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> должна возвращать `true` для `destinationType` типа <xref:System.String>, а в противном случае обращаться к базовой реализации.  
  
### <a name="implementing-canconvertfrom"></a>Реализация CanConvertFrom  
 Ваша реализация <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> должна возвращать `true` для `sourceType` типа <xref:System.String>, а в противном случае обращаться к базовой реализации.  
  
<a name="Applying_the_TypeConverterAttribute"></a>
## <a name="applying-the-typeconverterattribute"></a>Применение TypeConverterAttribute  
 Для того, чтобы конвертер пользовательского типа использовался в качестве преобразователя типа действия <xref:System.ComponentModel.TypeConverterAttribute> для пользовательского класса процессором XAML, необходимо применить его к определению класса. Имя <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> , указываемое в атрибуте, должно быть именем типа пользовательского преобразователя типов. Если этот атрибут применен, то в случае, когда обработчик XAML обрабатывает значения, в которых тип свойства использует тип пользовательского класса, обработчик может ввести строки и вернуть экземпляры объекта.  
  
 Вы также можете предоставить преобразователь типов для отдельных свойств. Вместо того, <xref:System.ComponentModel.TypeConverterAttribute> чтобы применять определение класса, примените его к определению свойства (основное определение, а не `get` / `set` реализации в нем). Тип свойства должен соответствовать типу, который обрабатывается пользовательским преобразователем типов. Если этот атрибут применяется, обработчик XAML может обработать входные строки и вернуть экземпляры объекта при работе со значениями этого свойства. Метод конвертера типа в свойстве особенно полезен, если вы решите использовать тип свойств из Microsoft .NET Framework <xref:System.ComponentModel.TypeConverterAttribute> или из какой-либо другой библиотеки, где вы не можете контролировать определение класса и не можете применить его.  
  
## <a name="see-also"></a>См. также раздел

- <xref:System.ComponentModel.TypeConverter>
- [Обзор XAML (WPF)](../../../desktop-wpf/fundamentals/xaml.md)
- [Расширения разметки и XAML WPF](markup-extensions-and-wpf-xaml.md)
- [Подробное описание синтаксиса XAML](xaml-syntax-in-detail.md)
