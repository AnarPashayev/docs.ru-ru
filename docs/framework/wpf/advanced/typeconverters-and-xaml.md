---
title: TypeConverters и XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [WPF], TypeConverter class
ms.assetid: f6313e4d-e89d-497d-ac87-b43511a1ae4b
ms.openlocfilehash: 6b8b58228e94ed12557e97406e55cc4165753076
ms.sourcegitcommit: 011314e0c8eb4cf4a11d92078f58176c8c3efd2d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/09/2020
ms.locfileid: "77095090"
---
# <a name="typeconverters-and-xaml"></a><span data-ttu-id="a4628-102">TypeConverters и XAML</span><span class="sxs-lookup"><span data-stu-id="a4628-102">TypeConverters and XAML</span></span>
<span data-ttu-id="a4628-103">Этот раздел посвящен цели преобразования типов из строк — одной из основных функций языка XAML.</span><span class="sxs-lookup"><span data-stu-id="a4628-103">This topic introduces the purpose of type conversion from string as a general XAML language feature.</span></span> <span data-ttu-id="a4628-104">В .NET Framework класс <xref:System.ComponentModel.TypeConverter> служит в качестве части реализации управляемого пользовательского класса, который можно использовать в качестве значения свойства в использовании атрибута XAML.</span><span class="sxs-lookup"><span data-stu-id="a4628-104">In the .NET Framework, the <xref:System.ComponentModel.TypeConverter> class serves a particular purpose as part of the implementation for a managed custom class that can be used as a property value in XAML attribute usage.</span></span> <span data-ttu-id="a4628-105">При написании пользовательского класса и необходимости использовать экземпляры класса в качестве значений атрибутов, устанавливаемых в XAML, может потребоваться применить к классу <xref:System.ComponentModel.TypeConverterAttribute>, написать пользовательский класс <xref:System.ComponentModel.TypeConverter> или и то, и другое.</span><span class="sxs-lookup"><span data-stu-id="a4628-105">If you write a custom class, and you want instances of your class to be usable as XAML settable attribute values, you might need to apply a <xref:System.ComponentModel.TypeConverterAttribute> to your class, write a custom <xref:System.ComponentModel.TypeConverter> class, or both.</span></span>  

## <a name="type-conversion-concepts"></a><span data-ttu-id="a4628-106">Понятия преобразования типов</span><span class="sxs-lookup"><span data-stu-id="a4628-106">Type Conversion Concepts</span></span>  
  
### <a name="xaml-and-string-values"></a><span data-ttu-id="a4628-107">XAML и строковые значения</span><span class="sxs-lookup"><span data-stu-id="a4628-107">XAML and String Values</span></span>  
 <span data-ttu-id="a4628-108">Когда задается значение атрибута в файле XAML, начальный тип этого значения — строка чистого текста.</span><span class="sxs-lookup"><span data-stu-id="a4628-108">When you set an attribute value in a XAML file, the initial type of that value is a string in pure text.</span></span> <span data-ttu-id="a4628-109">Даже другие примитивы, такие как <xref:System.Double>, являются исходными текстовыми строками для обработчика XAML.</span><span class="sxs-lookup"><span data-stu-id="a4628-109">Even other primitives such as <xref:System.Double> are initially text strings to a XAML processor.</span></span>  
  
 <span data-ttu-id="a4628-110">XAML-обработчику требуется два сообщения для того, чтобы обработать значение атрибута.</span><span class="sxs-lookup"><span data-stu-id="a4628-110">A XAML processor needs two pieces of information in order to process an attribute value.</span></span> <span data-ttu-id="a4628-111">Первый из них — это тип значения свойства, которое должно быть задано.</span><span class="sxs-lookup"><span data-stu-id="a4628-111">The first piece of information is the value type of the property that is being set.</span></span> <span data-ttu-id="a4628-112">Любую строку, которая определяет значение атрибута и обрабатывается в XAML, в конечном счете необходимо преобразовать или разрешить в значение этого типа.</span><span class="sxs-lookup"><span data-stu-id="a4628-112">Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.</span></span> <span data-ttu-id="a4628-113">Если значение — примитивный тип, понятный средству синтаксического анализа XAML (например, числовое значение), выполняется попытка прямого преобразования строки.</span><span class="sxs-lookup"><span data-stu-id="a4628-113">If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.</span></span> <span data-ttu-id="a4628-114">Если значение является перечислением, то строка используется для проверки совпадения имени в этом перечислении с именем константы.</span><span class="sxs-lookup"><span data-stu-id="a4628-114">If the value is an enumeration, the string is used to check for a name match to a named constant in that enumeration.</span></span> <span data-ttu-id="a4628-115">Если значение не является ни примитивом, понятным средству синтаксического анализа, ни перечислением, то этот тип должен обладать возможностью предоставления экземпляра типа или значения, основанного на преобразованной строке.</span><span class="sxs-lookup"><span data-stu-id="a4628-115">If the value is neither a parser-understood primitive nor an enumeration, then the type in question must be able to provide an instance of the type, or a value, based on a converted string.</span></span> <span data-ttu-id="a4628-116">Это делается указанием класса преобразователя типов.</span><span class="sxs-lookup"><span data-stu-id="a4628-116">This is done by indicating a type converter class.</span></span> <span data-ttu-id="a4628-117">Преобразователь типов — это фактически вспомогательный класс, предоставляющий значения другого класса как сценариям XAML, так и потенциально вызовам из кода .NET.</span><span class="sxs-lookup"><span data-stu-id="a4628-117">The type converter is effectively a helper class for providing values of another class, both for the XAML scenario and also potentially for code calls in .NET code.</span></span>  
  
### <a name="using-existing-type-conversion-behavior-in-xaml"></a><span data-ttu-id="a4628-118">Использование поведения преобразования существующего типа в XAML</span><span class="sxs-lookup"><span data-stu-id="a4628-118">Using Existing Type Conversion Behavior in XAML</span></span>  
 <span data-ttu-id="a4628-119">В зависимости от уровня понимания концепций XAML, вы, возможно, уже используете преобразование типа в простом приложении XAML, не реализуя его.</span><span class="sxs-lookup"><span data-stu-id="a4628-119">Depending on your familiarity with the underlying XAML concepts, you may already be using type conversion behavior in basic application XAML without realizing it.</span></span> <span data-ttu-id="a4628-120">Например, WPF определяет буквально сотни свойств, которые принимают значение типа <xref:System.Windows.Point>.</span><span class="sxs-lookup"><span data-stu-id="a4628-120">For instance, WPF defines literally hundreds of properties that take a value of type <xref:System.Windows.Point>.</span></span> <span data-ttu-id="a4628-121"><xref:System.Windows.Point> — это значение, описывающее координату в двухмерном пространстве координат и имеющее только два важных свойства: <xref:System.Windows.Point.X%2A> и <xref:System.Windows.Point.Y%2A>.</span><span class="sxs-lookup"><span data-stu-id="a4628-121">A <xref:System.Windows.Point> is a value that describes a coordinate in a two-dimensional coordinate space, and it really just has two important properties: <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A>.</span></span> <span data-ttu-id="a4628-122">При указании точки в XAML она указывается в виде строки с разделителем (обычно запятой) между <xref:System.Windows.Point.X%2A> и <xref:System.Windows.Point.Y%2A> указанными значениями.</span><span class="sxs-lookup"><span data-stu-id="a4628-122">When you specify a point in XAML, you specify it as a string with a delimiter (typically a comma) between the <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A> values you provide.</span></span> <span data-ttu-id="a4628-123">Например: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`.</span><span class="sxs-lookup"><span data-stu-id="a4628-123">For example: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`.</span></span>  
  
 <span data-ttu-id="a4628-124">Даже этот простой тип <xref:System.Windows.Point> и его простое использование в XAML — это преобразователь типов.</span><span class="sxs-lookup"><span data-stu-id="a4628-124">Even this simple type of <xref:System.Windows.Point> and its simple usage in XAML involve a type converter.</span></span> <span data-ttu-id="a4628-125">В этом случае это класс <xref:System.Windows.PointConverter>.</span><span class="sxs-lookup"><span data-stu-id="a4628-125">In this case that is the class <xref:System.Windows.PointConverter>.</span></span>  
  
 <span data-ttu-id="a4628-126">Преобразователь типов для <xref:System.Windows.Point>, определенный на уровне класса, упрощает использование разметки всех свойств, которые принимают <xref:System.Windows.Point>.</span><span class="sxs-lookup"><span data-stu-id="a4628-126">The type converter for <xref:System.Windows.Point> defined at the class level streamlines the markup usages of all properties that take <xref:System.Windows.Point>.</span></span> <span data-ttu-id="a4628-127">Без преобразователя типов для создания примера, показанного выше, требуется гораздо больше разметки.</span><span class="sxs-lookup"><span data-stu-id="a4628-127">Without a type converter here, you would need the following much more verbose markup for the same example shown previously:</span></span>  

```xaml
<LinearGradientBrush>
  <LinearGradientBrush.StartPoint>
    <Point X="0" Y="0"/>
  </LinearGradientBrush.StartPoint>
  <LinearGradientBrush.EndPoint>
    <Point X="1" Y="1"/>
  </LinearGradientBrush.EndPoint>
</LinearGradientBrush>
 ```
  
 <span data-ttu-id="a4628-128">Использовать преобразование типа строки или более многословный синтаксис — этот выбор диктуется только стилем написания кода.</span><span class="sxs-lookup"><span data-stu-id="a4628-128">Whether to use the type conversion string or a more verbose equivalent syntax is generally a coding style choice.</span></span> <span data-ttu-id="a4628-129">Инструментарий рабочего процесса XAML также может оказывать влияние на то, как задаются значения.</span><span class="sxs-lookup"><span data-stu-id="a4628-129">Your XAML tooling workflow might also influence how values are set.</span></span> <span data-ttu-id="a4628-130">Некоторые инструменты XAML склонны создавать очень подробную разметку, так как это облегчает переключение между представлениями конструктора и собственным механизмом сериализации.</span><span class="sxs-lookup"><span data-stu-id="a4628-130">Some XAML tools tend to emit the most verbose form of the markup because it is easier to round-trip to designer views or its own serialization mechanism.</span></span>  
  
 <span data-ttu-id="a4628-131">Существующие преобразователи типов обычно можно обнаружить на типах WPF и .NET Framework, проверив класс (или свойство) на наличие примененной <xref:System.ComponentModel.TypeConverterAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a4628-131">Existing type converters can generally be discovered on WPF and .NET Framework types by checking a class (or property) for the presence of an applied <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="a4628-132">Этот атрибут содержит имя класса, поддерживающего преобразование для данного типа, как для XAML, так потенциально и для других целей.</span><span class="sxs-lookup"><span data-stu-id="a4628-132">This attribute will name the class that is the supporting type converter for values of that type, for XAML purposes as well as potentially other purposes.</span></span>  
  
### <a name="type-converters-and-markup-extensions"></a><span data-ttu-id="a4628-133">Преобразователи типов и расширения разметки</span><span class="sxs-lookup"><span data-stu-id="a4628-133">Type Converters and Markup Extensions</span></span>  
 <span data-ttu-id="a4628-134">Расширения разметки и преобразователи типов играют ортогональные роли в терминах поведения обработчика XAML и сценариев, к которым они применяются.</span><span class="sxs-lookup"><span data-stu-id="a4628-134">Markup extensions and type converters fill orthogonal roles in terms of XAML processor behavior and the scenarios that they are applied to.</span></span> <span data-ttu-id="a4628-135">Хотя для расширения разметки контекст доступен, поведение преобразования типов свойств, когда расширение разметки предоставляет значение, обычно не включается в реализацию расширения разметки.</span><span class="sxs-lookup"><span data-stu-id="a4628-135">Although context is available for markup extension usages, type conversion behavior of properties where a markup extension provides a value is generally is not checked in the markup extension implementations.</span></span> <span data-ttu-id="a4628-136">Другими словами, даже если расширение разметки возвращает текстовую строку в качестве выходных данных `ProvideValue`, преобразование типа для этой строки относительно конкретного свойства или типа значения свойства не применяется. Обычно целью расширения разметки является обработка строки и возврат объекта без использования какого бы то ни было преобразователя типов.</span><span class="sxs-lookup"><span data-stu-id="a4628-136">In other words, even if a markup extension returns a text string as its `ProvideValue` output, type conversion behavior on that string as applied to a specific property or property value type is not invoked, Generally, the purpose of a markup extension is to process a string and return an object without any type converter involved.</span></span>  
  
 <span data-ttu-id="a4628-137">Одна общая ситуация, где необходимо расширение разметки, а не преобразователь типов, заключается в создании ссылки на объект, который уже существует.</span><span class="sxs-lookup"><span data-stu-id="a4628-137">One common situation where a markup extension is necessary rather than a type converter is to make a reference to an object that already exists.</span></span> <span data-ttu-id="a4628-138">В лучшем случае преобразователь типов с неопределенным состоянием может только создать новый экземпляр, что может быть нежелательно.</span><span class="sxs-lookup"><span data-stu-id="a4628-138">At best, a stateless type converter could only generate a new instance, which might not be desirable.</span></span> <span data-ttu-id="a4628-139">Дополнительные сведения о расширениях разметки см. в разделе [Расширения разметки и XAML WPF](markup-extensions-and-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="a4628-139">For more information on markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span>  
  
### <a name="native-type-converters"></a><span data-ttu-id="a4628-140">Собственные преобразователи типа</span><span class="sxs-lookup"><span data-stu-id="a4628-140">Native Type Converters</span></span>  
 <span data-ttu-id="a4628-141">В реализации средства синтаксического анализа XAML в WPF и платформе .NET Framework существуют несколько типов, поддерживающих собственную обработку преобразования типа, но нет типов, которые можно рассматривать как примитивы.</span><span class="sxs-lookup"><span data-stu-id="a4628-141">In the WPF and .NET Framework implementation of the XAML parser, there are certain types that have native type conversion handling, yet are not types that might conventionally be thought of as primitives.</span></span> <span data-ttu-id="a4628-142">Пример такого типа — <xref:System.DateTime>.</span><span class="sxs-lookup"><span data-stu-id="a4628-142">An example of such a type is <xref:System.DateTime>.</span></span> <span data-ttu-id="a4628-143">Причина этого зависит от того, как работает архитектура .NET Framework: тип <xref:System.DateTime> определен в mscorlib, самой простой библиотеке в .NET.</span><span class="sxs-lookup"><span data-stu-id="a4628-143">The reason for this is based on how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET.</span></span> <span data-ttu-id="a4628-144"><xref:System.DateTime> не разрешено использовать атрибут, поступающий из другой сборки, которая вводит зависимость (<xref:System.ComponentModel.TypeConverterAttribute> из системы), поэтому стандартный механизм обнаружения преобразователя типов с помощью атрибутов не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="a4628-144"><xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System) so the usual type converter discovery mechanism by attributing cannot be supported.</span></span> <span data-ttu-id="a4628-145">Вместо этого в средстве синтаксического анализа XAML имеется список типов, для которых необходима такая встроенная обработка; такие типы обрабатываются так же, как настоящие примитивы.</span><span class="sxs-lookup"><span data-stu-id="a4628-145">Instead, the XAML parser has a list of types that need such native processing and processes these similarly to how the true primitives are processed.</span></span> <span data-ttu-id="a4628-146">(В случае <xref:System.DateTime> это включает вызов <xref:System.DateTime.Parse%2A>.)</span><span class="sxs-lookup"><span data-stu-id="a4628-146">(In the case of <xref:System.DateTime> this involves a call to <xref:System.DateTime.Parse%2A>.)</span></span>  
  
<a name="Implementing_a_Type_Converter"></a>   
## <a name="implementing-a-type-converter"></a><span data-ttu-id="a4628-147">Реализация преобразователя типов</span><span class="sxs-lookup"><span data-stu-id="a4628-147">Implementing a Type Converter</span></span>  
  
### <a name="typeconverter"></a><span data-ttu-id="a4628-148">TypeConverter</span><span class="sxs-lookup"><span data-stu-id="a4628-148">TypeConverter</span></span>  
 <span data-ttu-id="a4628-149">В <xref:System.Windows.Point> примере, приведенном ранее, был упомянут класс <xref:System.Windows.PointConverter>.</span><span class="sxs-lookup"><span data-stu-id="a4628-149">In the <xref:System.Windows.Point> example given previously, the class <xref:System.Windows.PointConverter> was mentioned.</span></span> <span data-ttu-id="a4628-150">Для реализаций XAML в .NET все преобразователи типов, используемые для целей XAML, являются классами, производными от базового класса <xref:System.ComponentModel.TypeConverter>.</span><span class="sxs-lookup"><span data-stu-id="a4628-150">For .NET implementations of XAML, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="a4628-151">Класс <xref:System.ComponentModel.TypeConverter> существовал в версиях .NET Framework, предшествующих существованию XAML; одним из его первоначальных применений было преобразование строк для диалоговых окон свойств в визуальных конструкторах.</span><span class="sxs-lookup"><span data-stu-id="a4628-151">The <xref:System.ComponentModel.TypeConverter> class existed in versions of .NET Framework that precede the existence of XAML; one of its original usages was to provide string conversion for property dialogs in visual designers.</span></span> <span data-ttu-id="a4628-152">Для XAML роль <xref:System.ComponentModel.TypeConverter> расширяется, чтобы включать в себя базовый класс для преобразований в строковые и из строк, которые позволяют анализировать значение атрибута String, и, возможно, обработку значения времени выполнения определенного свойства объекта обратно в строку для сериализации в качестве атрибута.</span><span class="sxs-lookup"><span data-stu-id="a4628-152">For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded to include being the base class for to-string and from-string conversions that enable parsing a string attribute value, and possibly processing a run-time value of a particular object property back into a string for serialization as an attribute.</span></span>  
  
 <span data-ttu-id="a4628-153"><xref:System.ComponentModel.TypeConverter> определяет четыре элемента, которые относятся к преобразованию в строки и из строк для целей обработки XAML:</span><span class="sxs-lookup"><span data-stu-id="a4628-153"><xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to and from strings for XAML processing purposes:</span></span>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>  
  
 <span data-ttu-id="a4628-154">Наиболее важным методом является <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="a4628-154">Of these, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span></span> <span data-ttu-id="a4628-155">Этот метод преобразует входную строку к требуемому типу объекта.</span><span class="sxs-lookup"><span data-stu-id="a4628-155">This method converts the input string to the required object type.</span></span> <span data-ttu-id="a4628-156">Строго говоря, метод <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> может быть реализован для преобразования более широкого диапазона типов в предполагаемый целевой тип преобразователя. Таким образом, он обеспечивает более широкие возможности, чем XAML, такие как поддержка преобразований во время выполнения, но для XAML это только путь кода, который может обрабатывать <xref:System.String> входные данные.</span><span class="sxs-lookup"><span data-stu-id="a4628-156">Strictly speaking, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method could be implemented to convert a much wider range of types into the converter's intended destination type, and thus serve purposes that extend beyond XAML such as supporting run-time conversions, but for XAML purposes it is only the code path that can process a <xref:System.String> input that matters.</span></span>  
  
 <span data-ttu-id="a4628-157">Следующий самый важный метод — <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="a4628-157">The next most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span> <span data-ttu-id="a4628-158">Если приложение преобразуется в представление разметки (например, если оно сохраняется в XAML как файл), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> отвечает за создание представления разметки.</span><span class="sxs-lookup"><span data-stu-id="a4628-158">If an application is converted to a markup representation (for instance, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is responsible for producing a markup representation.</span></span> <span data-ttu-id="a4628-159">В этом случае путь кода, который важен для XAML, — при передаче `destinationType` <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="a4628-159">In this case, the code path that matters for XAML is when you pass a `destinationType` of <xref:System.String> .</span></span>  
  
 <span data-ttu-id="a4628-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> и <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> — это вспомогательные методы, используемые, когда служба запрашивает возможности реализации <xref:System.ComponentModel.TypeConverter> .</span><span class="sxs-lookup"><span data-stu-id="a4628-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation.</span></span> <span data-ttu-id="a4628-161">Вам необходимо реализовать эти методы для возврата `true` для определенных типов. Они аналогичны методам преобразования для поддержки вашего преобразователя.</span><span class="sxs-lookup"><span data-stu-id="a4628-161">You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support.</span></span> <span data-ttu-id="a4628-162">В целях XAML обычно это означает тип <xref:System.String> .</span><span class="sxs-lookup"><span data-stu-id="a4628-162">For XAML purposes, this generally means the <xref:System.String> type.</span></span>  
  
### <a name="culture-information-and-type-converters-for-xaml"></a><span data-ttu-id="a4628-163">Сведения о языке и преобразователи типов для XAML</span><span class="sxs-lookup"><span data-stu-id="a4628-163">Culture Information and Type Converters for XAML</span></span>  

 <span data-ttu-id="a4628-164">Каждая реализация <xref:System.ComponentModel.TypeConverter> может иметь собственную интерпретацию того, что составляет допустимую строку для преобразования, а также может использовать или игнорировать описание типа, передаваемое в качестве параметров.</span><span class="sxs-lookup"><span data-stu-id="a4628-164">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description passed as parameters.</span></span> <span data-ttu-id="a4628-165">Важное замечание относительно языка и региональных параметров и преобразования типов XAML.</span><span class="sxs-lookup"><span data-stu-id="a4628-165">There is an important consideration with regard to culture and XAML type conversion.</span></span> <span data-ttu-id="a4628-166">Использование локализуемых строк в качестве значений атрибутов полностью поддерживается в XAML.</span><span class="sxs-lookup"><span data-stu-id="a4628-166">Using localizable strings as attribute values is entirely supported by XAML.</span></span> <span data-ttu-id="a4628-167">Но использование локализуемых строк в качестве входных данных преобразователя типов с учетом индивидуальных требований для языка и региональных параметров не поддерживается, так как преобразователи типов значений атрибутов XAML по необходимости выполняют анализ с фиксированным языком, используя язык и региональные параметры `en-US`.</span><span class="sxs-lookup"><span data-stu-id="a4628-167">But using that localizable string as type converter input with specific culture requirements is not supported, because type converters for XAML attribute values involve a necessarily fixed-language parsing behavior, using `en-US` culture.</span></span> <span data-ttu-id="a4628-168">Дополнительные сведения о причинах этого ограничения см. в спецификации языка XAML ([\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf).</span><span class="sxs-lookup"><span data-stu-id="a4628-168">For more information on the design reasons for this restriction, you should consult the XAML language specification ([\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf).</span></span>  
  
 <span data-ttu-id="a4628-169">Пример того, что учет языка и региональных параметров может быть важен: некоторые языки и региональные параметры используют запятую в качестве десятичного разделителя.</span><span class="sxs-lookup"><span data-stu-id="a4628-169">As an example where culture can be an issue, some cultures use a comma as their decimal point delimiter for numbers.</span></span> <span data-ttu-id="a4628-170">Это входит в противоречие с поведением многих преобразователей типов WPF XAML, которые используют запятую в качестве разделителя (исторически в обычной форме X,Y или в списках, разделенных запятыми).</span><span class="sxs-lookup"><span data-stu-id="a4628-170">This will collide with the behavior that many of the WPF XAML type converters have, which is to use a comma as a delimiter (based on historical precedents such as the common X,Y form, or comma delimited lists).</span></span> <span data-ttu-id="a4628-171">Даже передача языка и региональных параметров в окружающий XAML (установка параметра `Language` или `xml:lang` в значение `sl-SI`, как пример языка и региональных параметров, использующих запятую в качестве десятичного разделителя) не решает проблемы.</span><span class="sxs-lookup"><span data-stu-id="a4628-171">Even passing a culture in the surrounding XAML (setting `Language` or `xml:lang` to the `sl-SI` culture, an example of a culture that uses a comma for decimal in this way) does not solve the issue.</span></span>  
  
### <a name="implementing-convertfrom"></a><span data-ttu-id="a4628-172">Реализация ConvertFrom</span><span class="sxs-lookup"><span data-stu-id="a4628-172">Implementing ConvertFrom</span></span>  
 <span data-ttu-id="a4628-173">Для использования в качестве реализации <xref:System.ComponentModel.TypeConverter> , поддерживающей XAML, метод <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> данного преобразователя должен принимать строку как параметр `value` .</span><span class="sxs-lookup"><span data-stu-id="a4628-173">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter.</span></span> <span data-ttu-id="a4628-174">Если строка находилась в допустимом формате и может быть преобразована реализацией <xref:System.ComponentModel.TypeConverter>, возвращаемый объект должен поддерживать приведение к типу, ожидаемому свойством.</span><span class="sxs-lookup"><span data-stu-id="a4628-174">If the string was in valid format, and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, then the returned object must support a cast to the type expected by the property.</span></span> <span data-ttu-id="a4628-175">В противном случае реализация <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> должна возвращать `null`.</span><span class="sxs-lookup"><span data-stu-id="a4628-175">Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.</span></span>  
  
 <span data-ttu-id="a4628-176">Каждая реализация <xref:System.ComponentModel.TypeConverter> может иметь собственную интерпретацию того, что составляет допустимую строку для преобразования, а также может использовать или игнорировать описание типа или контекстов языка и региональных параметров, переданных в качестве параметров.</span><span class="sxs-lookup"><span data-stu-id="a4628-176">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description or culture contexts passed as parameters.</span></span> <span data-ttu-id="a4628-177">Тем не менее обработка WPF XAML может не передать значения в контекст описания типа во всех случаях, а также может не передать язык и региональные параметры на основе `xml:lang`.</span><span class="sxs-lookup"><span data-stu-id="a4628-177">However, the WPF XAML processing might not pass values to the type description context in all cases, and also might not pass culture based on `xml:lang`.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="a4628-178">Не используйте фигурные скобки, особенно {, как возможный элемент формата строки.</span><span class="sxs-lookup"><span data-stu-id="a4628-178">Do not use the curly brace characters, particularly {, as a possible element of your string format.</span></span> <span data-ttu-id="a4628-179">Эти символы зарезервированы как вход и выход для последовательности расширения разметки.</span><span class="sxs-lookup"><span data-stu-id="a4628-179">These characters are reserved as the entry and exit for a markup extension sequence.</span></span>  
  
### <a name="implementing-convertto"></a><span data-ttu-id="a4628-180">Реализация ConvertTo</span><span class="sxs-lookup"><span data-stu-id="a4628-180">Implementing ConvertTo</span></span>  
 <span data-ttu-id="a4628-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> может использоваться для поддержки сериализации.</span><span class="sxs-lookup"><span data-stu-id="a4628-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support.</span></span> <span data-ttu-id="a4628-182">Поддержка сериализации с помощью <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> для пользовательского типа и его преобразователя типов не обязательна.</span><span class="sxs-lookup"><span data-stu-id="a4628-182">Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement.</span></span> <span data-ttu-id="a4628-183">Тем не менее, при реализации элемента управления или использовании сериализации как часть функций или класса, необходимо реализовать <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="a4628-183">However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span>  
  
 <span data-ttu-id="a4628-184">Для использования в качестве <xref:System.ComponentModel.TypeConverter>ной реализации, поддерживающей XAML, метод <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> для этого преобразователя должен принимать экземпляр типа (или значения), поддерживаемый в качестве параметра `value`.</span><span class="sxs-lookup"><span data-stu-id="a4628-184">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) being supported as the `value` parameter.</span></span> <span data-ttu-id="a4628-185">Если параметр `destinationType` имеет тип <xref:System.String>, возвращаемый объект должен иметь возможность приведения <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="a4628-185">When the `destinationType` parameter is the type <xref:System.String>, then the returned object must be able to be cast as <xref:System.String>.</span></span> <span data-ttu-id="a4628-186">Возвращаемая строка должна представлять сериализованное значение `value`.</span><span class="sxs-lookup"><span data-stu-id="a4628-186">The returned string must represent a serialized value of `value`.</span></span> <span data-ttu-id="a4628-187">В идеале выбранный формат сериализации должен иметь возможность создания того же значения, если эта строка была передана <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>ной реализации того же преобразователя без значительной потери информации.</span><span class="sxs-lookup"><span data-stu-id="a4628-187">Ideally, the serialization format you choose should be capable of generating the same value if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.</span></span>  
  
 <span data-ttu-id="a4628-188">Если значение не может быть сериализовано или преобразователь не поддерживает сериализацию, <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> реализация должна возвращать `null`и в данном случае может вызываться исключение.</span><span class="sxs-lookup"><span data-stu-id="a4628-188">If the value cannot be serialized, or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null`, and is permitted to throw an exception in this case.</span></span> <span data-ttu-id="a4628-189">Но если вы выдаете исключения, следует сообщить о невозможности использовать это преобразование как часть реализации <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>, чтобы лучше проверяться с <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> во избежание исключений.</span><span class="sxs-lookup"><span data-stu-id="a4628-189">But if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.</span></span>  
  
 <span data-ttu-id="a4628-190">Если параметр `destinationType` не имеет тип <xref:System.String>, можно выбрать собственную обработку преобразователя.</span><span class="sxs-lookup"><span data-stu-id="a4628-190">If `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling.</span></span> <span data-ttu-id="a4628-191">Как правило, возвращается к базовой обработке реализации, которая в <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> басемост создает определенное исключение.</span><span class="sxs-lookup"><span data-stu-id="a4628-191">Typically, you would revert to base implementation handling, which in the basemost <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.</span></span>  
  
### <a name="implementing-canconvertto"></a><span data-ttu-id="a4628-192">Реализация CanConvertTo</span><span class="sxs-lookup"><span data-stu-id="a4628-192">Implementing CanConvertTo</span></span>  
 <span data-ttu-id="a4628-193">Ваша реализация <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> должна возвращать `true` для `destinationType` типа <xref:System.String>, а в противном случае обращаться к базовой реализации.</span><span class="sxs-lookup"><span data-stu-id="a4628-193">Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
### <a name="implementing-canconvertfrom"></a><span data-ttu-id="a4628-194">Реализация CanConvertFrom</span><span class="sxs-lookup"><span data-stu-id="a4628-194">Implementing CanConvertFrom</span></span>  
 <span data-ttu-id="a4628-195">Ваша реализация <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> должна возвращать `true` для `sourceType` типа <xref:System.String>, а в противном случае обращаться к базовой реализации.</span><span class="sxs-lookup"><span data-stu-id="a4628-195">Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
<a name="Applying_the_TypeConverterAttribute"></a>   
## <a name="applying-the-typeconverterattribute"></a><span data-ttu-id="a4628-196">Применение TypeConverterAttribute</span><span class="sxs-lookup"><span data-stu-id="a4628-196">Applying the TypeConverterAttribute</span></span>  
 <span data-ttu-id="a4628-197">Чтобы пользовательский преобразователь типов мог использоваться в качестве преобразователя для действующего типа для пользовательского класса обработчиком XAML, необходимо применить <xref:System.ComponentModel.TypeConverterAttribute> к определению класса.</span><span class="sxs-lookup"><span data-stu-id="a4628-197">In order for your custom type converter to be used as the acting type converter for a custom class by a XAML processor, you must apply the <xref:System.ComponentModel.TypeConverterAttribute> to your class definition.</span></span> <span data-ttu-id="a4628-198">Имя <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> , указываемое в атрибуте, должно быть именем типа пользовательского преобразователя типов.</span><span class="sxs-lookup"><span data-stu-id="a4628-198">The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter.</span></span> <span data-ttu-id="a4628-199">Если этот атрибут применен, то в случае, когда обработчик XAML обрабатывает значения, в которых тип свойства использует тип пользовательского класса, обработчик может ввести строки и вернуть экземпляры объекта.</span><span class="sxs-lookup"><span data-stu-id="a4628-199">With this attribute applied, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.</span></span>  
  
 <span data-ttu-id="a4628-200">Вы также можете предоставить преобразователь типов для отдельных свойств.</span><span class="sxs-lookup"><span data-stu-id="a4628-200">You can also provide a type converter on a per-property basis.</span></span> <span data-ttu-id="a4628-201">Вместо применения <xref:System.ComponentModel.TypeConverterAttribute> к определению класса примените его к определению свойства (основное определение, а не `get`/`set` реализации внутри него).</span><span class="sxs-lookup"><span data-stu-id="a4628-201">Instead of applying a <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it).</span></span> <span data-ttu-id="a4628-202">Тип свойства должен соответствовать типу, который обрабатывается пользовательским преобразователем типов.</span><span class="sxs-lookup"><span data-stu-id="a4628-202">The type of the property must match the type that is processed by your custom type converter.</span></span> <span data-ttu-id="a4628-203">Если этот атрибут применяется, обработчик XAML может обработать входные строки и вернуть экземпляры объекта при работе со значениями этого свойства.</span><span class="sxs-lookup"><span data-stu-id="a4628-203">With this attribute applied, when a XAML processor handles values of that property, it can process input strings and return object instances.</span></span> <span data-ttu-id="a4628-204">Использование преобразователя типов для каждого свойства особенно полезно, если вы решили использовать тип свойства из Microsoft .NET Framework или из другой библиотеки, где нельзя управлять определением класса и не применять <xref:System.ComponentModel.TypeConverterAttribute> там.</span><span class="sxs-lookup"><span data-stu-id="a4628-204">The per-property type converter technique is particularly useful if you choose to use a property type from Microsoft .NET Framework or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a4628-205">См. также раздел</span><span class="sxs-lookup"><span data-stu-id="a4628-205">See also</span></span>

- <xref:System.ComponentModel.TypeConverter>
- [<span data-ttu-id="a4628-206">Обзор XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="a4628-206">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="a4628-207">Расширения разметки и XAML WPF</span><span class="sxs-lookup"><span data-stu-id="a4628-207">Markup Extensions and WPF XAML</span></span>](markup-extensions-and-wpf-xaml.md)
- [<span data-ttu-id="a4628-208">Подробное описание синтаксиса XAML</span><span class="sxs-lookup"><span data-stu-id="a4628-208">XAML Syntax In Detail</span></span>](xaml-syntax-in-detail.md)
