---
title: События изменения свойств
ms.date: 03/30/2017
helpviewer_keywords:
- dependency properties [WPF], change events
- property value changes [WPF]
- change events [WPF], property
- events [WPF], change in property values
- creating property triggers [WPF]
- property change events [WPF], types of
- property change events [WPF]
- property triggers [WPF]
- identifying changed property events [WPF]
- property triggers [WPF], definition of
ms.assetid: 0a7989df-9674-4cc1-bc50-5d8ef5d9c055
ms.openlocfilehash: 68be4c6bf7cce8a3aeb928e1f0b0e8131263320c
ms.sourcegitcommit: 944ddc52b7f2632f30c668815f92b378efd38eea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/03/2019
ms.locfileid: "73459346"
---
# <a name="property-change-events"></a>События изменения свойств
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] определяет несколько событий, которые возникают в ответ на изменение значения свойства. Часто этим свойством является свойство зависимостей. Само событие иногда является перенаправленным событием и иногда является стандартным событием среды CLR. Определение события зависит от сценария, так как некоторые изменения свойств лучше перенаправлять через дерево элементов, тогда как другие в основном влияют только на объект, в котором это свойство изменено.  
  
## <a name="identifying-a-property-change-event"></a>Определение события изменения свойства  
 Не все события, сообщающие об изменении свойства, явным образом определяются как событие изменения свойства на основании шаблона сигнатуры или именования. Как правило, описание события в документации по пакету SDK указывает, привязано ли событие непосредственно к изменению значения свойства и предоставляет перекрестные ссылки между свойством и событием.  
  
### <a name="routedpropertychanged-events"></a>События RoutedPropertyChanged  
 Некоторые события используют тип данных события и делегат, которые явно используются для событий изменения свойств. Тип данных события — <xref:System.Windows.RoutedPropertyChangedEventArgs%601>, а делегат — <xref:System.Windows.RoutedPropertyChangedEventHandler%601>. Данные события и делегат имеют параметр универсального типа, который используется для указания фактического типа изменяющегося свойства при определении обработчика. Данные события содержат два свойства: <xref:System.Windows.RoutedPropertyChangedEventArgs%601.OldValue%2A> и <xref:System.Windows.RoutedPropertyChangedEventArgs%601.NewValue%2A>, которые затем передаются как аргумент типа в данных события.  
  
 "Перенаправляемая" часть имени указывает, что событие изменения свойства зарегистрировано как перенаправляемое событие. Преимуществом перенаправления события изменения свойства является то, что верхний уровень элемента управления может получать события изменения свойств, если свойства дочерних элементов (составные части элемента управления) изменяют значения. Например, можно создать элемент управления, включающий в себя <xref:System.Windows.Controls.Primitives.RangeBase>ный элемент управления, например <xref:System.Windows.Controls.Slider>. Если значение свойства <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> меняется в части ползунка, может потребоваться обработать это изменение в родительском элементе управления, а не в части.  
  
 Поскольку имеется старое и новое значение, то может казаться заманчивым использовать этот обработчик событий в качестве проверяющего элемента управления для значения свойства. Однако большинство событий изменения свойств создается не для этого. Как правило, предоставляются значения, на основе которых можно действовать в других логических областях кода, но на самом деле изменение значений из обработчика событий не рекомендуется и может привести к непреднамеренной рекурсии в зависимости от реализации обработчика.  
  
 Если свойство является пользовательским свойством зависимости или если вы работаете с производным классом, в котором определен код создания экземпляра, существует гораздо более эффективный механизм отслеживания изменений свойств, встроенных в систему свойств [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]: свойство Системные обратные вызовы <xref:System.Windows.CoerceValueCallback> и <xref:System.Windows.PropertyChangedCallback>. Дополнительные сведения об использовании системы свойств [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] для проверки и приведения см. в разделах [Проверка и обратные вызовы свойства зависимостей](dependency-property-callbacks-and-validation.md) и [Пользовательские свойства зависимостей](custom-dependency-properties.md).  
  
### <a name="dependencypropertychanged-events"></a>События DependencyPropertyChanged  
 Другой парой типов, которые являются частью сценария события изменения свойства, является <xref:System.Windows.DependencyPropertyChangedEventArgs> и <xref:System.Windows.DependencyPropertyChangedEventHandler>. События для этих изменений свойств не маршрутизируются. Это стандартные события CLR. <xref:System.Windows.DependencyPropertyChangedEventArgs> — это необычный тип отчетов с данными о событиях, так как он не является производным от <xref:System.EventArgs>; <xref:System.Windows.DependencyPropertyChangedEventArgs> является структурой, а не классом.  
  
 События, использующие <xref:System.Windows.DependencyPropertyChangedEventArgs> и <xref:System.Windows.DependencyPropertyChangedEventHandler>, являются несколько более распространенными, чем события `RoutedPropertyChanged`. Примером события, использующего эти типы, является <xref:System.Windows.UIElement.IsMouseCapturedChanged>.  
  
 Как и <xref:System.Windows.RoutedPropertyChangedEventArgs%601>, <xref:System.Windows.DependencyPropertyChangedEventArgs> также сообщает старое и новое значение для свойства. Аналогично это относится и к тому, что вы можете делать со значениями. Обычно не рекомендуется пытаться снова изменить значения в отправителе в ответ на это событие.  
  
## <a name="property-triggers"></a>Триггеры свойств  
 С событием изменения свойств тесно связана другая концепция — триггер свойств. Триггер свойств создается внутри стиля или шаблона и позволяет создавать условное поведение на основе значения свойства, которому назначается триггер.  
  
 У триггера свойств должно быть свойство зависимостей. Оно может быть (и часто является) свойством зависимостей только для чтения. Хорошим указанием на то, что свойство зависимостей, предоставляемое элементом управления, хотя бы частично разработано как триггер свойства, является Is в начале имени свойства. Свойства с таким именованием часто являются логическим свойством зависимостей только для чтения, а основной сценарий для свойства — предоставление состояния элемента управления, которое может иметь последствия для пользовательского интерфейса реального времени и, следовательно, является кандидатом на роль триггера свойств.  
  
 Некоторые из этих свойств также имеют специальное событие изменения свойства. Например, свойство <xref:System.Windows.UIElement.IsMouseCaptured%2A> содержит событие изменения свойства <xref:System.Windows.UIElement.IsMouseCapturedChanged>. Само свойство доступно только для чтения, его значение корректируется входной системой, а система ввода <xref:System.Windows.UIElement.IsMouseCapturedChanged> для каждого изменения в режиме реального времени.  
  
 По сравнению с истинным событием изменения свойства, использование триггера свойств для реагирования на изменение свойства имеет некоторые ограничения.  
  
 Триггеры свойств работают через логику точного соответствия. Укажите свойство и значение, указывающее конкретное значение, для которого будет действовать триггер. Например: `<Setter Property="IsMouseCaptured" Value="true"> ... </Setter>`. Из-за этого ограничения большая часть триггеров свойств будет использоваться для логических свойств или свойств, которые принимают определенное значение перечисления, когда возможный диапазон значений достаточно управляем, чтобы определить триггер для каждого случая. Триггеры свойств могут существовать только для специальных значений, например когда количество элементов достигает нуля, а также нет триггера, который учитывает случаи, когда значение свойства изменяется от нуля (вместо триггеров для всех случаев вам может понадобиться обработчик события кода или поведение по умолчанию, которое снова возвращается из состояния триггера, когда значение отлично от нуля).  
  
 Синтаксис триггера свойств аналогичен оператору if в программировании. Если условие триггера истинно, тогда "тело" триггера свойств "выполняется". "Тело" триггера свойств является не кодом, а разметкой. Эта разметка ограничена использованием одного или нескольких элементов <xref:System.Windows.Setter> для задания других свойств объекта, к которому применяется стиль или шаблон.  
  
 Для смещения условия "If" триггера свойства, имеющего множество возможных значений, обычно рекомендуется установить это же значение свойства в качестве значения по умолчанию с помощью <xref:System.Windows.Setter>. Таким образом, <xref:System.Windows.Trigger> содержащий метод задания будет иметь приоритет, если условие триггера истинно, а <xref:System.Windows.Setter>, находящиеся вне <xref:System.Windows.Trigger>, будут иметь приоритет при условии, что условие триггера имеет значение false.  
  
 Триггеры свойств, как правило, подходят для сценариев, в которых одно или несколько свойств Appearance должны изменяться в зависимости от состояния другого свойства в том же элементе.  
  
 Дополнительные сведения о триггерах свойств см. в разделе [Использование стилей и шаблонов](../../../desktop-wpf/fundamentals/styles-templates-overview.md).  
  
## <a name="see-also"></a>См. также

- [Общие сведения о перенаправленных событиях](routed-events-overview.md)
- [Общие сведения о свойствах зависимости](dependency-properties-overview.md)
