---
title: Маркировка перенаправленных событий как обработанных и обработка классов
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 55ed91a848ce69fa6ce3e69a654a56d7875912b5
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401043"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a>Маркировка перенаправленных событий как обработанных и обработка классов
Обработчики для перенаправленных событий могут помечать событие как обработанное в данных этого события. Обработка событий эффективно сокращает маршрут. Обработка класса — это концепция программирования, поддерживаемая перенаправленными событиями. Обработчик класса может обрабатывать отдельное перенаправленное событие на уровне класса с помощью обработчика, который вызывается перед любым обработчиком экземпляра в любом экземпляре класса.  

<a name="prerequisites"></a>
## <a name="prerequisites"></a>Предварительные требования  
 В этом разделе описываются основные понятия, представленные в разделе [Общие сведения о перенаправленных событиях](routed-events-overview.md).  
  
<a name="When_to_Mark_Events_as_Handled"></a>
## <a name="when-to-mark-events-as-handled"></a>Когда следует помечать события как обработанные  
 При установлении значения <xref:System.Windows.RoutedEventArgs.Handled%2A> свойства `true` в данных события для маршрутизаторного события это называется "маркировка обрабатываемого события". Нет абсолютного правила, кто должен помечать перенаправленные события как обработанные — разработчик приложения или разработчик элемента управления, который реагирует на существующие или реализует новые перенаправленные события. По большей части, понятие "обработано" в случае, если они выполняются в данных события маршрутного события, должно использоваться [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] в качестве ограниченного протокола для ответов вашего собственного приложения на различные маршрутистые события, разоблоченные в AI, а также для любых пользовательских маршрутных событий. С другой стороны, главным образом следует помечать перенаправленное событие как обработанное, если код отвечал на перенаправленное событие значительным и относительно законченным образом. Как правило, не должно быть более одного значительного ответа, которому требуется реализация отдельных обработчиков для каждого отдельного перенаправленного события. Если требуются дополнительные ответы, необходимый код должен быть реализован посредством логики приложения, связанной с простым обработчиком, а не с помощью системы перенаправленных событий для переадресации. Понятие того, что является «значительным», также субъективно и зависит от приложения или кода. В качестве общих рекомендаций можно привести следующие примеры «значительного ответа»: установка фокуса, изменение общедоступного состояния, установка свойств, влияющих на визуальное представление, и создание других новых событий. Примеры незначительных ответов: изменение закрытого состояния (без визуального воздействия или программного представления), ведение журнала событий, просмотр аргументов события и выбор не отвечать на него.  
  
 Поведение маршрутизаторной системы событий усиливает эту модель «значительного ответа» для использования обработанного состояния маршрутного события, поскольку добавленные обработчики [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] или общая подпись не <xref:System.Windows.UIElement.AddHandler%2A> вызываются в ответ на маршрутное событие, в котором данные события уже помечены. Необходимо приложить дополнительные усилия по добавлению обработчика с `handledEventsToo` параметром версии ()<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>для обработки маршрутных событий, отмеченных более ранними участниками маршрута события.  
  
 В некоторых случаях элементы управления сами помечают некоторые перенаправленные события как обработанные. Обработанное перенаправленное событие представляет решение разработчиков элемента управления [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], что действия этого элемента управления в ответ на перенаправленное событие являются значительными или завершенными в рамках реализации элемента управления, и событие не требует дальнейшей обработки. Обычно это делается путем добавления обработчика класса для события или путем переопределения одного из виртуальных методов обработчика класса, который существует в базовом классе. При необходимости вы по-прежнему можете обойти обработку этого события; см. раздел [Обход подавления событий элементами управления](#WorkingAroundEventSuppressionByControls) далее в этой статье.  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a>"Предварительный просмотр" (туннелирование) События против событий, восходящих, и обработка событий  
 Перенаправленные события предварительного просмотра — это события нисходящей маршрутизации через дерево элементов. Выражение «Предварительный просмотр» в соглашении об именовании указывает на общий принцип для событий ввода, согласно которому перенаправленные события предварительного просмотра (нисходящей маршрутизации) вызываются до эквивалентных перенаправленных событий восходящей маршрутизации. Кроме того, перенаправленные события, имеющие пару нисходящей и восходящей маршрутизации, имеют другую логику обработки. Если перенаправленное событие нисходящей маршрутизации (событие предварительного просмотра) помечается прослушивателем событий как обработанное, то перенаправленное событие восходящей маршрутизации будет помечено как обработанное даже до того, как это событие будет получено каким-либо прослушивателем событий восходящей маршрутизации. Перенаправленные события нисходящей и восходящей маршрутизации технически являются отдельными событиями, но они специально совместно используют один и тот же экземпляр данных события, чтобы такое поведение стало возможным.  
  
 Связь между перенаправленными событиями нисходящей и восходящей маршрутизации обеспечивается внутренней реализацией того, как любой конкретный класс [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] вызывает свои собственные объявленные перенаправленные события, и это справедливо для пары перенаправленных событий ввода. Но если данная реализация на уровне класса отсутствует, то между перенаправленными событиями нисходящей и восходящей маршрутизации, совместно использующими эту схему именования, нет связи: без такой реализации это будут два абсолютно раздельных перенаправленных события, которые не будут вызываться в последовательности и не будут совместно использовать данные события.  
  
 Дополнительные сведения о реализации пары перенаправленных событий нисходящей и восходящей маршрутизации в пользовательском классе см. в разделе [Создание пользовательских перенаправленных событий](how-to-create-a-custom-routed-event.md).  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>
## <a name="class-handlers-and-instance-handlers"></a>Обработчики классов и обработчики экземпляров  
 Перенаправленные события поддерживают два разных типа прослушивателей события: прослушиватели классов и прослушиватели экземпляров. Слушатели классов существуют, <xref:System.Windows.EventManager> потому<xref:System.Windows.EventManager.RegisterClassHandler%2A>что типы вызвали определенный API, в их статическом конструкторе, или переопределили виртуальный метод обработчика класса из базового класса элемента. Слушатели экземпляров — это отдельные экземпляры/элементы класса, где один или <xref:System.Windows.UIElement.AddHandler%2A>несколько обработчиков были прикреплены к этому маршрутизированному событию вызовом. [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Существующие маршрутные события <xref:System.Windows.UIElement.AddHandler%2A> делают вызовы как часть обертки события{} общего{} языка (CLR) добавить и [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] удалить реализации события, который также, как простой механизм присоединения обработчиков событий с помощью атрибута синтаксисвключен. Поэтому даже [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] простое использование в <xref:System.Windows.UIElement.AddHandler%2A> конечном счете приравнивается к вызову.  
  
 Элементы в пределах визуального дерева проверяются на наличие реализаций зарегистрированных обработчиков. Обработчики потенциально вызываются на всем маршруте в порядке, соответствующем типу стратегии маршрутизации для этого перенаправленного события. Например, перенаправленные события восходящей маршрутизации сначала будут вызывать обработчики, присоединенные к элементу, который вызвал это перенаправленное событие. Затем перенаправленное событие «поднимается» к следующему родительскому элементу и так далее, пока не будет достигнут корневой элемент приложения.  
  
 С точки зрения корневого элемента в восходящем маршруте, если обработка класса или любой элемент, ближайший к источнику перенаправленного события, вызывает обработчики, которые помечают аргументы события как обработанные, то обработчики в корневых элементах не вызываются и маршрут события эффективно укорачивается до достижения этого корневого элемента. Однако маршрут не полностью останавливается, так как обработчики могут быть добавлены с использованием специального условия, что они должны по-прежнему вызываться, даже если обработчик класса или обработчик экземпляра пометил перенаправленное событие как обработанное. Это объясняется в разделе [Добавление обработчиков экземпляра, которые вызываются, даже когда события помечены как обработанные](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled) далее в этой статье.  
  
 На более глубоком уровне, чем маршрут события, также потенциально имеется несколько обработчиков класса, действующих в любом экземпляре класса. Это связано с тем, что модель обработки класса для перенаправленных событий позволяет каждому из возможных классов в иерархии классов зарегистрировать свой собственный обработчик класса для каждого перенаправленного события. Каждый обработчик класса добавляется во внутреннее хранилище, и, когда формируется маршрут события для приложения, все обработчики классов добавляются в этот маршрут события. Обработчики классов добавляются в маршрут таким образом, что сначала вызывается обработчик класса, находящегося на самом низком уровне иерархии, а затем вызываются обработчики классов из каждого последующего базового класса. Как правило, обработчики классов не регистрируются, так что они также отвечают на перенаправленные события, которые уже были помечены как обработанные. Таким образом, этот механизм обработки класса позволяет выбрать один из двух следующих вариантов.  
  
- Производные классы могут дополнять обработку класса, наследуемую от базового класса, путем добавления обработчика, который не помечает перенаправленное событие как обработанное, поскольку обработчик базового класса будет иногда вызываться после обработчика производного класса.  
  
- Производные классы могут заменять обработку класса из базового класса путем добавления обработчика класса, который помечает перенаправленное событие как обработанное. Следует соблюдать осторожность при таком подходе, потому что в результате возможно изменение планируемой конструкции базового элемента управления в таких областях, как внешний вид, логика состояний, обработки ввода и обработка команд.  
  
<a name="Class_Handling_of_Routed_Events"></a>
## <a name="class-handling-of-routed-events-by-control-base-classes"></a>Обработка перенаправленных событий базовыми классами элементов управления  
 В каждом узле элементов в маршруте события прослушиватели классов имеют возможность ответить на перенаправленное событие прежде, чем это сможет сделать любой прослушиватель экземпляра в элементе. По этой причине обработчики классов иногда используются для подавления перенаправленных событий, которые определенная реализация класса элементов управления не желает распространять дальше, или для предоставления специальной обработки этого перенаправленного события, являющейся функцией класса. Например, класс может вызывать собственное событие класса, содержащее дополнительные сведения о том, что означает некоторое пользовательское условие ввода в контексте данного класса. Затем эта реализация класса может пометить более общее перенаправленное событие как обработанное. Обработчики классов обычно добавляются таким образом, что они не вызываются для маршрутных событий, где <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> общие данные событий уже были помечены обрабатываемыми, но в нетипичных случаях есть также подпись, которую регистрируют обработчики классов, чтобы вызвать даже при пометке маршрутированных событий.  
  
### <a name="class-handler-virtuals"></a>Виртуальные функции обработчиков классов  
 Некоторые элементы, в частности базовые элементы, такие <xref:System.Windows.UIElement>как\*, выставляют пустые виртуальные методы «On'Event» и «OnPreview Event», которые соответствуют их списку общедоступных маршрутизированных событий. Эти виртуальные методы можно переопределить, чтобы реализовать обработчик класса для перенаправленного события. Классы базовых элементов регистрируют эти виртуальные методы <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> в качестве обработчика классов для каждого такого маршрутного события, используя описанные ранее. Виртуальные методы On\*Event существенно упрощают реализацию обработки класса для соответствующих перенаправленных события, не требуя специальной инициализации в статических конструкторах для каждого типа. Например, можно добавить обработку класса для <xref:System.Windows.UIElement.DragEnter> события в любом <xref:System.Windows.UIElement> производном классе, переопределив виртуальный <xref:System.Windows.UIElement.OnDragEnter%2A> метод. В переопределении можно обрабатывать перенаправленное событие, вызывать другие события, инициировать логику данного класса, которая может изменять свойства элементов в экземплярах или задавать любое сочетание этих действий. Обычно в таких переопределениях следует вызывать базовую реализацию, даже если событие помечается как обработанное. Вызов базовой реализации настоятельно рекомендуется, так как виртуальный метод находится в базовом классе. Стандартный защищенный виртуальный шаблон вызова базовых реализаций из каждого виртуального метода в сущности заменяет и дублирует аналогичный механизм, встроенный в обработку класса перенаправленных событий, в котором обработчики классов для всех классов в иерархии вызываются в любом указанном экземпляре, начиная с обработчика класса, самого дальнего в иерархии, и заканчивая обработчиком базового класса. Вам достаточно лишь опустить вызов базовой реализации, если класс обоснованно требует изменить логику обработки базового класса. Вызов базовой реализации до или после переопределения кода будет зависеть от природы реализации.  
  
#### <a name="input-event-class-handling"></a>Обработка классов событий ввода  
 Все виртуальные методы обработчика класса регистрируются таким образом, что они вызываются только в случаях, когда общие данные события еще не помечены как обработанные. Кроме того, исключительно для событий ввода, нисходящая и восходящая версии маршрутизации обычно вызываются последовательно и совместно используют данные события. Это влечет за собой то, что для конкретной пары обработчиков класса событий ввода, где один является версией для нисходящей маршрутизации, а другой — для восходящей, вы можете не захотеть немедленно пометить событие как обработанное. Если вы реализуете виртуальный метод обработки класса событий нисходящей маршрутизации для пометки события как обработанного, это препятствует вызову обработчика класса событий восходящей маршрутизации (а также препятствует вызову любых обычно зарегистрированных обработчиков экземпляров для событий как нисходящей, так и восходящей маршрутизации).  
  
 После завершения обработки класса в узле рассматриваются прослушиватели экземпляров.  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a>Добавление обработчиков экземпляра, которые вызываются, даже когда события помечены как обработанные  
 Метод <xref:System.Windows.UIElement.AddHandler%2A> обеспечивает определенную перегрузку, которая позволяет добавлять обработчики, которые будут вызываться системой событий всякий раз, когда событие достигает элемента обработки в маршруте, даже если какой-либо другой обработчик уже скорректировал данные о событии, чтобы отметить это событие как обработанное. Обычно это не делается. Как правило, обработчики могут быть написаны для корректировки всех областей кода приложения, на которые может влиять событие, независимо от того, где оно было обработано в дереве элементов, даже если требуется несколько конечных результатов. Кроме того, обычно существует только один элемент, который должен отвечать на это событие, и соответствующая прикладная логика уже была применена. Однако перегрузка `handledEventsToo` доступна в исключительных случаях, когда некоторые элементы в дереве элементов или в составных элементах управления уже пометили событие как обработанное, но другие элементы, находящиеся выше или ниже в дереве элементов (в зависимости от маршрута), по-прежнему требуют вызов своих собственных обработчиков.  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a>Когда следует помечать обработанные события как необработанные  
 Как правило, маршрутные события, которые помечены обрабатываются<xref:System.Windows.RoutedEventArgs.Handled%2A> не `false`должны быть отмечены без `handledEventsToo`ручки (установлен обратно) даже обработчики, которые действуют на . Однако некоторые события ввода имеют представления событий высокого и низкого уровня, которые могут перекрываться, когда событие высокого уровня отображается в одной позиции в дереве, а событие низкого уровня — в другой позиции. Например, рассмотрим случай, когда элемент ребенка слушает ключевое <xref:System.Windows.UIElement.TextInput> событие высокого уровня, например, в <xref:System.Windows.UIElement.KeyDown>то время как родительский элемент слушает событие низкого уровня, например. Если родительский элемент обрабатывает событие нижнего уровня, событие верхнего уровня может подавляться даже в дочернем элементе, который интуитивно должен иметь возможность первым обработать это событие.  
  
 В таких ситуациях может потребоваться добавить обработчики события нижнего уровня и в родительский, и в дочерний элемент. Реализация обработчика дочернего элемента может пометить событие нижнего уровня как обработанное, но реализация обработчика родительского элемента будет снова устанавливать его как необработанное, чтобы последующие элементы в дереве (а также события высокого уровня) имели возможность ответить. Это достаточно редкая ситуация.  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a>Намеренное подавление событий ввода для составных элементов управления  
 Основной сценарий, в котором используется обработка класса перенаправленных событий, предназначен для событий ввода и составных элементов управления. Составной элемент управления по определению состоит из нескольких фактических элементов управления или базовых классов элементов управления. Часто разработчик элемента управления хочет объединить все возможные события ввода, которые могут вызываться каждым из компонентов, чтобы полный элемент управления был единственным источником событий. В некоторых случаях разработчик элемента управления может захотеть полностью подавить события от компонентов или заменить на определяемое компонентом событие, которое содержит дополнительные сведения или подразумевает более конкретное поведение. Канонический пример, который сразу же виден любому [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> автору компонента, заключается в том, как обрабатывает <xref:System.Windows.Controls.Primitives.ButtonBase.Click> любое событие мыши, которое в конечном итоге разрешит интуитивное событие, которое есть у всех кнопок: событие.  
  
 Базовый <xref:System.Windows.Controls.Button> класс<xref:System.Windows.Controls.Primitives.ButtonBase>() <xref:System.Windows.Controls.Control> вытекает из которого, в свою очередь, вытекает из <xref:System.Windows.FrameworkElement> и, <xref:System.Windows.UIElement> <xref:System.Windows.UIElement> и большая часть инфраструктуры событий, необходимых для обработки ввода управления доступна на уровне. В частности, <xref:System.Windows.Input.Mouse> обрабатывает общие события, <xref:System.Windows.UIElement> обрабатывающие тестирование хита для курсора мыши в пределах <xref:System.Windows.UIElement.MouseLeftButtonDown>своих границ, и предоставляет различные события для наиболее распространенных действий кнопки, таких как . <xref:System.Windows.UIElement>также предоставляет пустой виртуальный <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> как <xref:System.Windows.UIElement.MouseLeftButtonDown>предварительно <xref:System.Windows.Controls.Primitives.ButtonBase> зарегистрированный обработчик класса для, и переопределяет его. Аналогичным <xref:System.Windows.Controls.Primitives.ButtonBase> образом, использует <xref:System.Windows.UIElement.MouseLeftButtonUp>обработчики классов для . В переопределениях, которые передаются данные события, <xref:System.Windows.RoutedEventArgs> реализации отмечают <xref:System.Windows.RoutedEventArgs.Handled%2A> этот `true`экземпляр как обрабатываемый путем настройки, и те же данные события — это то, что продолжается по оставшейся части маршрута другим обработчикам класса, а также обработчикам или сеттерам событий. Кроме того, <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> переопределение будет <xref:System.Windows.Controls.Primitives.ButtonBase.Click> следующий поднять событие. Конечным результатом для большинства <xref:System.Windows.UIElement.MouseLeftButtonDown> слушателей будет то, что <xref:System.Windows.UIElement.MouseLeftButtonUp> <xref:System.Windows.Controls.Primitives.ButtonBase.Click>и события "исчезают" и заменяются вместо этого, событие, которое имеет больше смысла, потому что известно, что это событие возникла из истинной кнопки, а не какой-то составной кусок кнопки или от некоторых других элементов полностью.  
  
<a name="WorkingAroundEventSuppressionByControls"></a>
### <a name="working-around-event-suppression-by-controls"></a>Обход скрытия события элементами управления  
 Иногда это поведение скрытия события внутри отдельных элементов управления может конфликтовать с некоторыми более общими целями логики обработки событий в приложении. Например, если по какой-либо <xref:System.Windows.UIElement.MouseLeftButtonDown> причине в приложении был обработчик для расположения в корневом элементе приложения, вы заметите, что любое нажатие мыши на кнопку не будет вызывать <xref:System.Windows.UIElement.MouseLeftButtonDown> или <xref:System.Windows.UIElement.MouseLeftButtonUp> обработчиков на корневом уровне. Само событие действительно передается вверх (еще раз, маршруты событий на самом деле не завершены, но система перенаправления событий изменяет поведение вызова их обработчика после пометки их как обработанных). Когда маршрутное событие достигло <xref:System.Windows.Controls.Primitives.ButtonBase> кнопки, <xref:System.Windows.UIElement.MouseLeftButtonDown> обработка класса пометила обработанную, потому что она хотела заменить <xref:System.Windows.Controls.Primitives.ButtonBase.Click> событие большим значением. Таким образом, <xref:System.Windows.UIElement.MouseLeftButtonDown> любой стандартный обработчик дальше по маршруту не будет вызываться. Существует два способа гарантировать, что в таких обстоятельствах ваши обработчики будут вызываться.  
  
 Первый метод заключается в том, `handledEventsToo` чтобы <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>намеренно добавить обработчик с помощью подписи . Этот подход ограничен тем, что такой способ присоединения обработчика событий возможен только из кода, но не из разметки. Простой синтаксис указания имени обработчика событий в качестве значения атрибута события посредством [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] не позволяет такое поведение.  
  
 Второй способ работает только для событий ввода, где версии нисходящей и восходящей маршрутизации перенаправленного события объединены в пару. Для этих перенаправленных событий можно добавлять обработчики в версию перенаправленного события нисходящей маршрутизации. Это перенаправленное событие будет спускаться по маршруту, начиная от корня, поэтому код обработки класса кнопки не будет его перехватывать, при условии что вы присоединили обработчик предварительного просмотра на уровне предшествующего элемента в дереве элементов приложения. При использовании этого подхода будьте внимательны при пометке любого события предварительного просмотра как обработанного. В примере, <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> приведенном при обработке в корневом <xref:System.Windows.RoutedEventArgs.Handled%2A> элементе, если вы отметили <xref:System.Windows.Controls.Primitives.ButtonBase.Click> событие как в реализации обработчика, вы фактически подавите событие. Обычно это нежелательное поведение.  
  
## <a name="see-also"></a>См. также раздел

- <xref:System.Windows.EventManager>
- [События предварительного просмотра](preview-events.md)
- [Создание пользовательских перенаправленных событий](how-to-create-a-custom-routed-event.md)
- [Общие сведения о перенаправленных событиях](routed-events-overview.md)
