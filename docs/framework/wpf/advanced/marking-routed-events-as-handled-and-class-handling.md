---
title: Маркировка перенаправленных событий как обработанных и обработка классов
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 6e3f314de07948e53ffed13ddc1289c1de115edd
ms.sourcegitcommit: 24a4a8eb6d8cfe7b8549fb6d823076d7c697e0c6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/23/2019
ms.locfileid: "68401642"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a>Маркировка перенаправленных событий как обработанных и обработка классов
Обработчики для перенаправленных событий могут помечать событие как обработанное в данных этого события. Обработка событий эффективно сокращает маршрут. Обработка класса — это концепция программирования, поддерживаемая перенаправленными событиями. Обработчик класса может обрабатывать отдельное перенаправленное событие на уровне класса с помощью обработчика, который вызывается перед любым обработчиком экземпляра в любом экземпляре класса.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Предварительные требования  
 В этом разделе описываются основные понятия, представленные в разделе [Общие сведения о перенаправленных событиях](routed-events-overview.md).  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a>Когда следует помечать события как обработанные  
 Если для <xref:System.Windows.RoutedEventArgs.Handled%2A> `true` свойства задано значение в данных события для перенаправленного события, это называется пометкой обработанного события. Нет абсолютного правила, кто должен помечать перенаправленные события как обработанные — разработчик приложения или разработчик элемента управления, который реагирует на существующие или реализует новые перенаправленные события. В большинстве случаев понятие «обработанного», переданное в данные события перенаправленного события, должно использоваться как ограниченный протокол для ответов вашего приложения на различные перенаправленные события, предоставляемые в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] интерфейсах API, а также для любых пользовательских перенаправленных событий. С другой стороны, главным образом следует помечать перенаправленное событие как обработанное, если код отвечал на перенаправленное событие значительным и относительно законченным образом. Как правило, не должно быть более одного значительного ответа, которому требуется реализация отдельных обработчиков для каждого отдельного перенаправленного события. Если требуются дополнительные ответы, необходимый код должен быть реализован посредством логики приложения, связанной с простым обработчиком, а не с помощью системы перенаправленных событий для переадресации. Понятие того, что является «значительным», также субъективно и зависит от приложения или кода. В качестве общих рекомендаций можно привести следующие примеры «значительного ответа»: установка фокуса, изменение общедоступного состояния, установка свойств, влияющих на визуальное представление, и создание других новых событий. Примеры незначительных ответов: изменение закрытого состояния (без визуального воздействия или программного представления), ведение журнала событий, просмотр аргументов события и выбор не отвечать на него.  
  
 Поведение системы перенаправленных событий усиливает эту модель "значительный ответ" для использования обработанного состояния перенаправленного события, так как обработчики, [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] добавленные в или в <xref:System.Windows.UIElement.AddHandler%2A> общую сигнатуру, не вызываются в ответ на перенаправленное событие, где событие данные уже помечены как обработанные. Необходимо выполнить дополнительные усилия по добавлению обработчика с `handledEventsToo` параметром version (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) для обработки перенаправленных событий, которые помечены как обработанные предыдущими участниками в маршруте события.  
  
 В некоторых случаях элементы управления сами помечают некоторые перенаправленные события как обработанные. Обработанное перенаправленное событие представляет решение разработчиков элемента управления [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], что действия этого элемента управления в ответ на перенаправленное событие являются значительными или завершенными в рамках реализации элемента управления, и событие не требует дальнейшей обработки. Обычно это делается путем добавления обработчика класса для события или путем переопределения одного из виртуальных методов обработчика класса, который существует в базовом классе. При необходимости вы по-прежнему можете обойти обработку этого события; см. раздел [Обход подавления событий элементами управления](#WorkingAroundEventSuppressionByControls) далее в этой статье.  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a>События предварительного просмотра по сравнению с событиями восходящей маршрутизации и обработка событий  
 Перенаправленные события предварительного просмотра — это события нисходящей маршрутизации через дерево элементов. Выражение «Предварительный просмотр» в соглашении об именовании указывает на общий принцип для событий ввода, согласно которому перенаправленные события предварительного просмотра (нисходящей маршрутизации) вызываются до эквивалентных перенаправленных событий восходящей маршрутизации. Кроме того, перенаправленные события, имеющие пару нисходящей и восходящей маршрутизации, имеют другую логику обработки. Если перенаправленное событие нисходящей маршрутизации (событие предварительного просмотра) помечается прослушивателем событий как обработанное, то перенаправленное событие восходящей маршрутизации будет помечено как обработанное даже до того, как это событие будет получено каким-либо прослушивателем событий восходящей маршрутизации. Перенаправленные события нисходящей и восходящей маршрутизации технически являются отдельными событиями, но они специально совместно используют один и тот же экземпляр данных события, чтобы такое поведение стало возможным.  
  
 Связь между перенаправленными событиями нисходящей и восходящей маршрутизации обеспечивается внутренней реализацией того, как любой конкретный класс [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] вызывает свои собственные объявленные перенаправленные события, и это справедливо для пары перенаправленных событий ввода. Но если данная реализация на уровне класса отсутствует, то между перенаправленными событиями нисходящей и восходящей маршрутизации, совместно использующими эту схему именования, нет связи: без такой реализации это будут два абсолютно раздельных перенаправленных события, которые не будут вызываться в последовательности и не будут совместно использовать данные события.  
  
 Дополнительные сведения о реализации пары перенаправленных событий нисходящей и восходящей маршрутизации в пользовательском классе см. в разделе [Создание пользовательских перенаправленных событий](how-to-create-a-custom-routed-event.md).  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a>Обработчики классов и обработчики экземпляров  
 Перенаправленные события поддерживают два разных типа прослушивателей события: прослушиватели классов и прослушиватели экземпляров. Прослушиватели классов существуют, так как типы вызвали <xref:System.Windows.EventManager> определенный<xref:System.Windows.EventManager.RegisterClassHandler%2A>API,, в статическом конструкторе или переопределили виртуальный метод обработчика класса из базового класса элемента. Прослушиватели экземпляров — это конкретные экземпляры или элементы класса, в которых один или несколько обработчиков были присоединены к перенаправленному <xref:System.Windows.UIElement.AddHandler%2A>событию посредством вызова. Существующие [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] перенаправленные события выполняют вызовы <xref:System.Windows.UIElement.AddHandler%2A> в рамках оболочки событий среды CLR для добавления{} и удаления{} реализаций события, что также является простым [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] механизмом разрешено присоединение обработчиков событий с помощью синтаксиса атрибутов. Поэтому даже простое [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] использование в конечном итоге равнозначно <xref:System.Windows.UIElement.AddHandler%2A> вызову.  
  
 Элементы в пределах визуального дерева проверяются на наличие реализаций зарегистрированных обработчиков. Обработчики потенциально вызываются на всем маршруте в порядке, соответствующем типу стратегии маршрутизации для этого перенаправленного события. Например, перенаправленные события восходящей маршрутизации сначала будут вызывать обработчики, присоединенные к элементу, который вызвал это перенаправленное событие. Затем перенаправленное событие «поднимается» к следующему родительскому элементу и так далее, пока не будет достигнут корневой элемент приложения.  
  
 С точки зрения корневого элемента в восходящем маршруте, если обработка класса или любой элемент, ближайший к источнику перенаправленного события, вызывает обработчики, которые помечают аргументы события как обработанные, то обработчики в корневых элементах не вызываются и маршрут события эффективно укорачивается до достижения этого корневого элемента. Однако маршрут не полностью останавливается, так как обработчики могут быть добавлены с использованием специального условия, что они должны по-прежнему вызываться, даже если обработчик класса или обработчик экземпляра пометил перенаправленное событие как обработанное. Это объясняется в разделе [Добавление обработчиков экземпляра, которые вызываются, даже когда события помечены как обработанные](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled) далее в этой статье.  
  
 На более глубоком уровне, чем маршрут события, также потенциально имеется несколько обработчиков класса, действующих в любом экземпляре класса. Это связано с тем, что модель обработки класса для перенаправленных событий позволяет каждому из возможных классов в иерархии классов зарегистрировать свой собственный обработчик класса для каждого перенаправленного события. Каждый обработчик класса добавляется во внутреннее хранилище, и, когда формируется маршрут события для приложения, все обработчики классов добавляются в этот маршрут события. Обработчики классов добавляются в маршрут таким образом, что сначала вызывается обработчик класса, находящегося на самом низком уровне иерархии, а затем вызываются обработчики классов из каждого последующего базового класса. Как правило, обработчики классов не регистрируются, так что они также отвечают на перенаправленные события, которые уже были помечены как обработанные. Таким образом, этот механизм обработки класса позволяет выбрать один из двух следующих вариантов.  
  
- Производные классы могут дополнять обработку класса, наследуемую от базового класса, путем добавления обработчика, который не помечает перенаправленное событие как обработанное, поскольку обработчик базового класса будет иногда вызываться после обработчика производного класса.  
  
- Производные классы могут заменять обработку класса из базового класса путем добавления обработчика класса, который помечает перенаправленное событие как обработанное. Следует соблюдать осторожность при таком подходе, потому что в результате возможно изменение планируемой конструкции базового элемента управления в таких областях, как внешний вид, логика состояний, обработки ввода и обработка команд.  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a>Обработка перенаправленных событий базовыми классами элементов управления  
 В каждом узле элементов в маршруте события прослушиватели классов имеют возможность ответить на перенаправленное событие прежде, чем это сможет сделать любой прослушиватель экземпляра в элементе. По этой причине обработчики классов иногда используются для подавления перенаправленных событий, которые определенная реализация класса элементов управления не желает распространять дальше, или для предоставления специальной обработки этого перенаправленного события, являющейся функцией класса. Например, класс может вызывать собственное событие класса, содержащее дополнительные сведения о том, что означает некоторое пользовательское условие ввода в контексте данного класса. Затем эта реализация класса может пометить более общее перенаправленное событие как обработанное. Обработчики классов обычно добавляются таким, что они не вызываются для перенаправленных событий, когда общие данные событий уже помечены как обработанные, но в нетипичных случаях также <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> существует сигнатура, которая регистрирует обработчики класса для вызова, даже если перенаправленные события помечено как обработанное.  
  
### <a name="class-handler-virtuals"></a>Виртуальные функции обработчиков классов  
 Некоторые элементы, в частности базовые элементы, такие <xref:System.Windows.UIElement>как, предоставляют пустые виртуальные методы "On * Event" и\*"OnPreview Event", соответствующие их списку общих перенаправленных событий. Эти виртуальные методы можно переопределить, чтобы реализовать обработчик класса для перенаправленного события. Классы базовых элементов регистрируют эти виртуальные методы в качестве обработчика класса для каждого такого перенаправленного события <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> , используя, как описано выше. Виртуальные методы On\*Event существенно упрощают реализацию обработки класса для соответствующих перенаправленных события, не требуя специальной инициализации в статических конструкторах для каждого типа. Например, можно добавить обработку класса для <xref:System.Windows.UIElement.DragEnter> события в любом <xref:System.Windows.UIElement> производном <xref:System.Windows.UIElement.OnDragEnter%2A> классе, переопределив виртуальный метод. В переопределении можно обрабатывать перенаправленное событие, вызывать другие события, инициировать логику данного класса, которая может изменять свойства элементов в экземплярах или задавать любое сочетание этих действий. Обычно в таких переопределениях следует вызывать базовую реализацию, даже если событие помечается как обработанное. Вызов базовой реализации настоятельно рекомендуется, так как виртуальный метод находится в базовом классе. Стандартный защищенный виртуальный шаблон вызова базовых реализаций из каждого виртуального метода в сущности заменяет и дублирует аналогичный механизм, встроенный в обработку класса перенаправленных событий, в котором обработчики классов для всех классов в иерархии вызываются в любом указанном экземпляре, начиная с обработчика класса, самого дальнего в иерархии, и заканчивая обработчиком базового класса. Вам достаточно лишь опустить вызов базовой реализации, если класс обоснованно требует изменить логику обработки базового класса. Вызов базовой реализации до или после переопределения кода будет зависеть от природы реализации.  
  
#### <a name="input-event-class-handling"></a>Обработка классов событий ввода  
 Все виртуальные методы обработчика класса регистрируются таким образом, что они вызываются только в случаях, когда общие данные события еще не помечены как обработанные. Кроме того, исключительно для событий ввода, нисходящая и восходящая версии маршрутизации обычно вызываются последовательно и совместно используют данные события. Это влечет за собой то, что для конкретной пары обработчиков класса событий ввода, где один является версией для нисходящей маршрутизации, а другой — для восходящей, вы можете не захотеть немедленно пометить событие как обработанное. Если вы реализуете виртуальный метод обработки класса событий нисходящей маршрутизации для пометки события как обработанного, это препятствует вызову обработчика класса событий восходящей маршрутизации (а также препятствует вызову любых обычно зарегистрированных обработчиков экземпляров для событий как нисходящей, так и восходящей маршрутизации).  
  
 После завершения обработки класса в узле рассматриваются прослушиватели экземпляров.  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a>Добавление обработчиков экземпляра, которые вызываются, даже когда события помечены как обработанные  
 <xref:System.Windows.UIElement.AddHandler%2A> Метод предоставляет определенную перегрузку, которая позволяет добавлять обработчики, которые будут вызываться системой событий каждый раз, когда событие достигнет обрабатывающего элемента в маршруте, даже если какие-либо другие обработчики уже настроили данные события для пометки событие как обработанное. Обычно это не делается. Как правило, обработчики могут быть написаны для корректировки всех областей кода приложения, на которые может влиять событие, независимо от того, где оно было обработано в дереве элементов, даже если требуется несколько конечных результатов. Кроме того, обычно существует только один элемент, который должен отвечать на это событие, и соответствующая прикладная логика уже была применена. Однако перегрузка `handledEventsToo` доступна в исключительных случаях, когда некоторые элементы в дереве элементов или в составных элементах управления уже пометили событие как обработанное, но другие элементы, находящиеся выше или ниже в дереве элементов (в зависимости от маршрута), по-прежнему требуют вызов своих собственных обработчиков.  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a>Когда следует помечать обработанные события как необработанные  
 Как правило, перенаправленные события, помеченные как обработанные, не должны помечаться как `false`необработанные (<xref:System.Windows.RoutedEventArgs.Handled%2A> устанавливаются обратно `handledEventsToo`) даже обработчиками, которые действуют. Однако некоторые события ввода имеют представления событий высокого и низкого уровня, которые могут перекрываться, когда событие высокого уровня отображается в одной позиции в дереве, а событие низкого уровня — в другой позиции. Например, рассмотрим случай, когда дочерний элемент прослушивает событие ключа высокого уровня, например <xref:System.Windows.UIElement.TextInput> , в то время как родительский элемент ожидает события низкого уровня, такого как. <xref:System.Windows.UIElement.KeyDown> Если родительский элемент обрабатывает событие нижнего уровня, событие верхнего уровня может подавляться даже в дочернем элементе, который интуитивно должен иметь возможность первым обработать это событие.  
  
 В таких ситуациях может потребоваться добавить обработчики события нижнего уровня и в родительский, и в дочерний элемент. Реализация обработчика дочернего элемента может пометить событие нижнего уровня как обработанное, но реализация обработчика родительского элемента будет снова устанавливать его как необработанное, чтобы последующие элементы в дереве (а также события высокого уровня) имели возможность ответить. Это достаточно редкая ситуация.  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a>Намеренное подавление событий ввода для составных элементов управления  
 Основной сценарий, в котором используется обработка класса перенаправленных событий, предназначен для событий ввода и составных элементов управления. Составной элемент управления по определению состоит из нескольких фактических элементов управления или базовых классов элементов управления. Часто разработчик элемента управления хочет объединить все возможные события ввода, которые могут вызываться каждым из компонентов, чтобы полный элемент управления был единственным источником событий. В некоторых случаях разработчик элемента управления может захотеть полностью подавить события от компонентов или заменить на определяемое компонентом событие, которое содержит дополнительные сведения или подразумевает более конкретное поведение. Канонический пример, непосредственно видимый для любого автора компонента, заключается в [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> том, как обработчик обрабатывает любое событие мыши, которое в конечном итоге будет разрешать интуитивно понятному событию, что <xref:System.Windows.Controls.Primitives.ButtonBase.Click> все кнопки имеют: событие.  
  
 <xref:System.Windows.Controls.Primitives.ButtonBase> <xref:System.Windows.Controls.Control> <xref:System.Windows.UIElement> <xref:System.Windows.UIElement> <xref:System.Windows.FrameworkElement> Базовый класс () является производным от, который, в свою очередь, является производным от и, и большая часть инфраструктуры событий, необходимая для обработки входных данных управления, доступна на уровне. <xref:System.Windows.Controls.Button> В частности, <xref:System.Windows.UIElement> обрабатывает общие <xref:System.Windows.Input.Mouse> события, которые обрабатывают проверку попадания курсора мыши в пределах границ, и предоставляет отдельные события для наиболее распространенных действий кнопок, таких как <xref:System.Windows.UIElement.MouseLeftButtonDown>. <xref:System.Windows.UIElement>также предоставляет пустой виртуальный <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> в качестве предварительно зарегистрированного обработчика класса для <xref:System.Windows.UIElement.MouseLeftButtonDown>и <xref:System.Windows.Controls.Primitives.ButtonBase> переопределяет его. Аналогичным образом <xref:System.Windows.UIElement.MouseLeftButtonUp> используетобработчики<xref:System.Windows.Controls.Primitives.ButtonBase> классов для. В переопределениях, которые передают данные события, реализации отмечают этот <xref:System.Windows.RoutedEventArgs> экземпляр как обработанный, `true`присвоив параметру <xref:System.Windows.RoutedEventArgs.Handled%2A> значение, и эти данные события будут продолжаться в оставшейся части маршрута к другим обработчикам класса и также к обработчикам экземпляров или методам задания событий. Кроме того, <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> переопределение приводит к <xref:System.Windows.Controls.Primitives.ButtonBase.Click> последующему вызову события. Конечным результатом для большинства прослушивателей является то, <xref:System.Windows.UIElement.MouseLeftButtonDown> что <xref:System.Windows.UIElement.MouseLeftButtonUp> события и исчезают, а вместо них <xref:System.Windows.Controls.Primitives.ButtonBase.Click>заменяются на событие, которое содержит больше смысла, поскольку известно, что это событие поступило от кнопки «истина», а не для некоторых составной элемент кнопки или из другого элемента полностью.  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a>Обход скрытия события элементами управления  
 Иногда это поведение скрытия события внутри отдельных элементов управления может конфликтовать с некоторыми более общими целями логики обработки событий в приложении. Например, если по какой-то причине в приложении имелся обработчик <xref:System.Windows.UIElement.MouseLeftButtonDown> для размещается в корневом элементе приложения, можно заметить, что любой щелчок кнопки мыши не <xref:System.Windows.UIElement.MouseLeftButtonUp> вызовет <xref:System.Windows.UIElement.MouseLeftButtonDown> обработчиков на корневом уровне. Само событие действительно передается вверх (еще раз, маршруты событий на самом деле не завершены, но система перенаправления событий изменяет поведение вызова их обработчика после пометки их как обработанных). Когда перенаправленное событие достигает кнопки, обработка <xref:System.Windows.Controls.Primitives.ButtonBase> класса <xref:System.Windows.UIElement.MouseLeftButtonDown> помечается как обработанная, так как <xref:System.Windows.Controls.Primitives.ButtonBase.Click> она замещает событие более значимым значением. Таким образом, любой <xref:System.Windows.UIElement.MouseLeftButtonDown> стандартный обработчик, расположенный дальше по маршруту, не будет вызываться. Существует два способа гарантировать, что в таких обстоятельствах ваши обработчики будут вызываться.  
  
 Первый способ — намеренно добавить обработчик, используя `handledEventsToo` <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>сигнатуру. Этот подход ограничен тем, что такой способ присоединения обработчика событий возможен только из кода, но не из разметки. Простой синтаксис указания имени обработчика событий в качестве значения атрибута события посредством [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] не позволяет такое поведение.  
  
 Второй способ работает только для событий ввода, где версии нисходящей и восходящей маршрутизации перенаправленного события объединены в пару. Для этих перенаправленных событий можно добавлять обработчики в версию перенаправленного события нисходящей маршрутизации. Это перенаправленное событие будет спускаться по маршруту, начиная от корня, поэтому код обработки класса кнопки не будет его перехватывать, при условии что вы присоединили обработчик предварительного просмотра на уровне предшествующего элемента в дереве элементов приложения. При использовании этого подхода будьте внимательны при пометке любого события предварительного просмотра как обработанного. В примере <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> , который обрабатывается в корневом элементе, если событие помечено как <xref:System.Windows.RoutedEventArgs.Handled%2A> в реализации обработчика, это <xref:System.Windows.Controls.Primitives.ButtonBase.Click> событие будет подавлено. Обычно это нежелательное поведение.  
  
## <a name="see-also"></a>См. также

- <xref:System.Windows.EventManager>
- [События предварительного просмотра](preview-events.md)
- [Создание пользовательских перенаправленных событий](how-to-create-a-custom-routed-event.md)
- [Общие сведения о перенаправленных событиях](routed-events-overview.md)
