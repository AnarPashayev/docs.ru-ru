---
title: Маркировка перенаправленных событий как обработанных и обработка классов
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 8a21b5e69e8fb3f9781d862bd62b0db92073b1dc
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62053877"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a><span data-ttu-id="61e05-102">Маркировка перенаправленных событий как обработанных и обработка классов</span><span class="sxs-lookup"><span data-stu-id="61e05-102">Marking Routed Events as Handled, and Class Handling</span></span>
<span data-ttu-id="61e05-103">Обработчики для перенаправленных событий могут помечать событие как обработанное в данных этого события.</span><span class="sxs-lookup"><span data-stu-id="61e05-103">Handlers for a routed event can mark the event handled within the event data.</span></span> <span data-ttu-id="61e05-104">Обработка событий эффективно сокращает маршрут.</span><span class="sxs-lookup"><span data-stu-id="61e05-104">Handling the event will effectively shorten the route.</span></span> <span data-ttu-id="61e05-105">Обработка класса — это концепция программирования, поддерживаемая перенаправленными событиями.</span><span class="sxs-lookup"><span data-stu-id="61e05-105">Class handling is a programming concept that is supported by routed events.</span></span> <span data-ttu-id="61e05-106">Обработчик класса может обрабатывать отдельное перенаправленное событие на уровне класса с помощью обработчика, который вызывается перед любым обработчиком экземпляра в любом экземпляре класса.</span><span class="sxs-lookup"><span data-stu-id="61e05-106">A class handler has the opportunity to handle a particular routed event at a class level with a handler that is invoked before any instance handler on any instance of the class.</span></span>  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="61e05-107">Предварительные требования</span><span class="sxs-lookup"><span data-stu-id="61e05-107">Prerequisites</span></span>  
 <span data-ttu-id="61e05-108">В этом разделе описываются основные понятия, представленные в разделе [Общие сведения о перенаправленных событиях](routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="61e05-108">This topic elaborates on concepts introduced in the [Routed Events Overview](routed-events-overview.md).</span></span>  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a><span data-ttu-id="61e05-109">Когда следует помечать события как обработанные</span><span class="sxs-lookup"><span data-stu-id="61e05-109">When to Mark Events as Handled</span></span>  
 <span data-ttu-id="61e05-110">Если задано значение <xref:System.Windows.RoutedEventArgs.Handled%2A> свойства `true` событий данные для перенаправленного события, это называется «маркировка события как обработанного».</span><span class="sxs-lookup"><span data-stu-id="61e05-110">When you set the value of the <xref:System.Windows.RoutedEventArgs.Handled%2A> property to `true` in the event data for a routed event, this is referred to as "marking the event handled".</span></span> <span data-ttu-id="61e05-111">Нет абсолютного правила, кто должен помечать перенаправленные события как обработанные — разработчик приложения или разработчик элемента управления, который реагирует на существующие или реализует новые перенаправленные события.</span><span class="sxs-lookup"><span data-stu-id="61e05-111">There is no absolute rule for when you should mark routed events as handled, either as an application author, or as a control author who responds to existing routed events or implements new routed events.</span></span> <span data-ttu-id="61e05-112">По большей части концепция «обработанный», вносимая в данные перенаправленного события, должна использоваться в качестве ограниченного протокола для ответов собственного приложения на различные перенаправленные события, предоставленные в [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], а также на любые пользовательские перенаправленные события.</span><span class="sxs-lookup"><span data-stu-id="61e05-112">For the most part, the concept of "handled" as carried in the routed event's event data should be used as a limited protocol for your own application's responses to the various routed events exposed in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] as well as for any custom routed events.</span></span> <span data-ttu-id="61e05-113">С другой стороны, главным образом следует помечать перенаправленное событие как обработанное, если код отвечал на перенаправленное событие значительным и относительно законченным образом.</span><span class="sxs-lookup"><span data-stu-id="61e05-113">Another way to consider the "handled" issue is that you should generally mark a routed event handled if your code responded to the routed event in a significant and relatively complete way.</span></span> <span data-ttu-id="61e05-114">Как правило, не должно быть более одного значительного ответа, которому требуется реализация отдельных обработчиков для каждого отдельного перенаправленного события.</span><span class="sxs-lookup"><span data-stu-id="61e05-114">Typically, there should not be more than one significant response that requires separate handler implementations for any single routed event occurrence.</span></span> <span data-ttu-id="61e05-115">Если требуются дополнительные ответы, необходимый код должен быть реализован посредством логики приложения, связанной с простым обработчиком, а не с помощью системы перенаправленных событий для переадресации.</span><span class="sxs-lookup"><span data-stu-id="61e05-115">If more responses are needed, then the necessary code should be implemented through application logic that is chained within a single handler rather than by using the routed event system for forwarding.</span></span> <span data-ttu-id="61e05-116">Понятие того, что является «значительным», также субъективно и зависит от приложения или кода.</span><span class="sxs-lookup"><span data-stu-id="61e05-116">The concept of what is "significant" is also subjective, and depends on your application or code.</span></span> <span data-ttu-id="61e05-117">В качестве общих рекомендаций можно привести следующие примеры «значительного ответа»: установка фокуса, изменение общедоступного состояния, установка свойств, влияющих на визуальное представление, и создание других новых событий.</span><span class="sxs-lookup"><span data-stu-id="61e05-117">As general guidance, some "significant response" examples include: setting focus, modifying public state, setting properties that affect the visual representation, and raising other new events.</span></span> <span data-ttu-id="61e05-118">Примеры незначительных ответов: изменение закрытого состояния (без визуального воздействия или программного представления), ведение журнала событий, просмотр аргументов события и выбор не отвечать на него.</span><span class="sxs-lookup"><span data-stu-id="61e05-118">Examples of nonsignificant responses include: modifying private state (with no visual impact, or programmatic representation), logging of events, or looking at arguments of an event and choosing not to respond to it.</span></span>  
  
 <span data-ttu-id="61e05-119">Поведение системы перенаправленных событий усиливает эту модель «значительного ответа» для использования обработанного состояния перенаправленного события, поскольку обработчики, добавленные в [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] или в общую подпись <xref:System.Windows.UIElement.AddHandler%2A> не вызываются в ответ на перенаправленное событие где события данные уже помечено как обработанное.</span><span class="sxs-lookup"><span data-stu-id="61e05-119">The routed event system behavior reinforces this "significant response" model for using handled state of a routed event, because handlers added in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or the common signature of <xref:System.Windows.UIElement.AddHandler%2A> are not invoked in response to a routed event where the event data is already marked handled.</span></span> <span data-ttu-id="61e05-120">Вы должны проходить через дополнительные усилия, добавить обработчик с `handledEventsToo` версией параметра (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) для обработки перенаправленных событий, которые помечены как обработанные, более ранними участниками маршрута события.</span><span class="sxs-lookup"><span data-stu-id="61e05-120">You must go through the extra effort of adding a handler with the `handledEventsToo` parameter version (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) in order to handle routed events that are marked handled by earlier participants in the event route.</span></span>  
  
 <span data-ttu-id="61e05-121">В некоторых случаях элементы управления сами помечают некоторые перенаправленные события как обработанные.</span><span class="sxs-lookup"><span data-stu-id="61e05-121">In some circumstances, controls themselves mark certain routed events as handled.</span></span> <span data-ttu-id="61e05-122">Обработанное перенаправленное событие представляет решение разработчиков элемента управления [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], что действия этого элемента управления в ответ на перенаправленное событие являются значительными или завершенными в рамках реализации элемента управления, и событие не требует дальнейшей обработки.</span><span class="sxs-lookup"><span data-stu-id="61e05-122">A handled routed event represents a decision by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control authors that the control's actions in response to the routed event are significant or complete as part of the control implementation, and the event needs no further handling.</span></span> <span data-ttu-id="61e05-123">Обычно это делается путем добавления обработчика класса для события или путем переопределения одного из виртуальных методов обработчика класса, который существует в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="61e05-123">Usually this is done by adding a class handler for an event, or by overriding one of the class handler virtuals that exist on a base class.</span></span> <span data-ttu-id="61e05-124">При необходимости вы по-прежнему можете обойти обработку этого события; см. раздел [Обход подавления событий элементами управления](#WorkingAroundEventSuppressionByControls) далее в этой статье.</span><span class="sxs-lookup"><span data-stu-id="61e05-124">You can still work around this event handling if necessary; see [Working Around Event Suppression by Controls](#WorkingAroundEventSuppressionByControls) later in this topic.</span></span>  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a><span data-ttu-id="61e05-125">События предварительного просмотра по сравнению с событиями восходящей маршрутизации и обработка событий</span><span class="sxs-lookup"><span data-stu-id="61e05-125">"Preview" (Tunneling) Events vs. Bubbling Events, and Event Handling</span></span>  
 <span data-ttu-id="61e05-126">Перенаправленные события предварительного просмотра — это события нисходящей маршрутизации через дерево элементов.</span><span class="sxs-lookup"><span data-stu-id="61e05-126">Preview routed events are events that follow a tunneling route through the element tree.</span></span> <span data-ttu-id="61e05-127">Выражение «Предварительный просмотр» в соглашении об именовании указывает на общий принцип для событий ввода, согласно которому перенаправленные события предварительного просмотра (нисходящей маршрутизации) вызываются до эквивалентных перенаправленных событий восходящей маршрутизации.</span><span class="sxs-lookup"><span data-stu-id="61e05-127">The "Preview" expressed in the naming convention is indicative of the general principle for input events that preview (tunneling) routed events are raised prior to the equivalent bubbling routed event.</span></span> <span data-ttu-id="61e05-128">Кроме того, перенаправленные события, имеющие пару нисходящей и восходящей маршрутизации, имеют другую логику обработки.</span><span class="sxs-lookup"><span data-stu-id="61e05-128">Also, input routed events that have a tunneling and bubbling pair have a distinct handling logic.</span></span> <span data-ttu-id="61e05-129">Если перенаправленное событие нисходящей маршрутизации (событие предварительного просмотра) помечается прослушивателем событий как обработанное, то перенаправленное событие восходящей маршрутизации будет помечено как обработанное даже до того, как это событие будет получено каким-либо прослушивателем событий восходящей маршрутизации.</span><span class="sxs-lookup"><span data-stu-id="61e05-129">If the tunneling/preview routed event is marked as handled by an event listener, then the bubbling routed event will be marked handled even before any listeners of the bubbling routed event receive it.</span></span> <span data-ttu-id="61e05-130">Перенаправленные события нисходящей и восходящей маршрутизации технически являются отдельными событиями, но они специально совместно используют один и тот же экземпляр данных события, чтобы такое поведение стало возможным.</span><span class="sxs-lookup"><span data-stu-id="61e05-130">The tunneling and bubbling routed events are technically separate events, but they deliberately share the same instance of event data to enable this behavior.</span></span>  
  
 <span data-ttu-id="61e05-131">Связь между перенаправленными событиями нисходящей и восходящей маршрутизации обеспечивается внутренней реализацией того, как любой конкретный класс [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] вызывает свои собственные объявленные перенаправленные события, и это справедливо для пары перенаправленных событий ввода.</span><span class="sxs-lookup"><span data-stu-id="61e05-131">The connection between the tunneling and bubbling routed events is accomplished by the internal implementation of how any given [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] class raises its own declared routed events, and this is true of the paired input routed events.</span></span> <span data-ttu-id="61e05-132">Но если данная реализация на уровне класса отсутствует, то между перенаправленными событиями нисходящей и восходящей маршрутизации, совместно использующими эту схему именования, нет связи: без такой реализации это будут два абсолютно раздельных перенаправленных события, которые не будут вызываться в последовательности и не будут совместно использовать данные события.</span><span class="sxs-lookup"><span data-stu-id="61e05-132">But unless this class-level implementation exists, there is no connection between a tunneling routed event and a bubbling routed event that share the naming scheme: without such implementation they would be two entirely separate routed events and would not be raised in sequence or share event data.</span></span>  
  
 <span data-ttu-id="61e05-133">Дополнительные сведения о реализации пары перенаправленных событий нисходящей и восходящей маршрутизации в пользовательском классе см. в разделе [Создание пользовательских перенаправленных событий](how-to-create-a-custom-routed-event.md).</span><span class="sxs-lookup"><span data-stu-id="61e05-133">For more information about how to implement tunnel/bubble input routed event pairs in a custom class, see [Create a Custom Routed Event](how-to-create-a-custom-routed-event.md).</span></span>  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a><span data-ttu-id="61e05-134">Обработчики классов и обработчики экземпляров</span><span class="sxs-lookup"><span data-stu-id="61e05-134">Class Handlers and Instance Handlers</span></span>  
 <span data-ttu-id="61e05-135">Перенаправленные события поддерживают два разных типа прослушивателей события: прослушиватели классов и прослушиватели экземпляров.</span><span class="sxs-lookup"><span data-stu-id="61e05-135">Routed events consider two different types of listeners to the event: class listeners and instance listeners.</span></span> <span data-ttu-id="61e05-136">Прослушиватели классов существуют, так как типы определенный <xref:System.Windows.EventManager> [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, в своем статическом конструкторе, или переопределяют виртуальный метод обработчика класса из элемента базового класса.</span><span class="sxs-lookup"><span data-stu-id="61e05-136">Class listeners exist because types have called a particular <xref:System.Windows.EventManager> [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, in their static constructor, or have overridden a class handler virtual method from an element base class.</span></span> <span data-ttu-id="61e05-137">Прослушиватели экземпляров — экземпляры определенного класса или элементы, где один или несколько привязаны обработчики для этого перенаправленного события путем вызова <xref:System.Windows.UIElement.AddHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="61e05-137">Instance listeners are particular class instances/elements where one or more handlers have been attached for that routed event by a call to <xref:System.Windows.UIElement.AddHandler%2A>.</span></span> <span data-ttu-id="61e05-138">Существующие [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] вызывают перенаправленные события <xref:System.Windows.UIElement.AddHandler%2A> как часть [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] Добавление программы-оболочки событий{} и удалить{} реализации событий, который также является как простой [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] механизм присоединения обработчики событий через синтаксис атрибутов включен.</span><span class="sxs-lookup"><span data-stu-id="61e05-138">Existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] routed events make calls to <xref:System.Windows.UIElement.AddHandler%2A> as part of the [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] event wrapper add{} and remove{} implementations of the event, which is also how the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mechanism of attaching event handlers via an attribute syntax is enabled.</span></span> <span data-ttu-id="61e05-139">Таким образом, даже простое [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] использования конечном счете приравнивается к <xref:System.Windows.UIElement.AddHandler%2A> вызова.</span><span class="sxs-lookup"><span data-stu-id="61e05-139">Therefore even the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] usage ultimately equates to an <xref:System.Windows.UIElement.AddHandler%2A> call.</span></span>  
  
 <span data-ttu-id="61e05-140">Элементы в пределах визуального дерева проверяются на наличие реализаций зарегистрированных обработчиков.</span><span class="sxs-lookup"><span data-stu-id="61e05-140">Elements within the visual tree are checked for registered handler implementations.</span></span> <span data-ttu-id="61e05-141">Обработчики потенциально вызываются на всем маршруте в порядке, соответствующем типу стратегии маршрутизации для этого перенаправленного события.</span><span class="sxs-lookup"><span data-stu-id="61e05-141">Handlers are potentially invoked throughout the route, in the order that is inherent in the type of the routing strategy for that routed event.</span></span> <span data-ttu-id="61e05-142">Например, перенаправленные события восходящей маршрутизации сначала будут вызывать обработчики, присоединенные к элементу, который вызвал это перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="61e05-142">For instance, bubbling routed events will first invoke those handlers that are attached to the same element that raised the routed event.</span></span> <span data-ttu-id="61e05-143">Затем перенаправленное событие «поднимается» к следующему родительскому элементу и так далее, пока не будет достигнут корневой элемент приложения.</span><span class="sxs-lookup"><span data-stu-id="61e05-143">Then the routed event "bubbles" to the next parent element and so on until the application root element is reached.</span></span>  
  
 <span data-ttu-id="61e05-144">С точки зрения корневого элемента в восходящем маршруте, если обработка класса или любой элемент, ближайший к источнику перенаправленного события, вызывает обработчики, которые помечают аргументы события как обработанные, то обработчики в корневых элементах не вызываются и маршрут события эффективно укорачивается до достижения этого корневого элемента.</span><span class="sxs-lookup"><span data-stu-id="61e05-144">From the perspective of the root element in a bubbling route, if class handling or any element closer to the source of the routed event invoke handlers that mark the event arguments as being handled, then handlers on the root elements are not invoked, and the event route is effectively shortened before reaching that root element.</span></span> <span data-ttu-id="61e05-145">Однако маршрут не полностью останавливается, так как обработчики могут быть добавлены с использованием специального условия, что они должны по-прежнему вызываться, даже если обработчик класса или обработчик экземпляра пометил перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="61e05-145">However, the route is not completely halted, because handlers can be added using a special conditional that they should still be invoked, even if a class handler or instance handler has marked the routed event as handled.</span></span> <span data-ttu-id="61e05-146">Это объясняется в разделе [Добавление обработчиков экземпляра, которые вызываются, даже когда события помечены как обработанные](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled) далее в этой статье.</span><span class="sxs-lookup"><span data-stu-id="61e05-146">This is explained in [Adding Instance Handlers That Are Raised Even When Events Are Marked Handled](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), later in this topic.</span></span>  
  
 <span data-ttu-id="61e05-147">На более глубоком уровне, чем маршрут события, также потенциально имеется несколько обработчиков класса, действующих в любом экземпляре класса.</span><span class="sxs-lookup"><span data-stu-id="61e05-147">At a deeper level than the event route, there are also potentially multiple class handlers acting on any given instance of a class.</span></span> <span data-ttu-id="61e05-148">Это связано с тем, что модель обработки класса для перенаправленных событий позволяет каждому из возможных классов в иерархии классов зарегистрировать свой собственный обработчик класса для каждого перенаправленного события.</span><span class="sxs-lookup"><span data-stu-id="61e05-148">This is because the class handling model for routed events enables all possible classes in a class hierarchy to each register its own class handler for each routed event.</span></span> <span data-ttu-id="61e05-149">Каждый обработчик класса добавляется во внутреннее хранилище, и, когда формируется маршрут события для приложения, все обработчики классов добавляются в этот маршрут события.</span><span class="sxs-lookup"><span data-stu-id="61e05-149">Each class handler is added to an internal store, and when the event route for an application is constructed, the class handlers are all added to the event route.</span></span> <span data-ttu-id="61e05-150">Обработчики классов добавляются в маршрут таким образом, что сначала вызывается обработчик класса, находящегося на самом низком уровне иерархии, а затем вызываются обработчики классов из каждого последующего базового класса.</span><span class="sxs-lookup"><span data-stu-id="61e05-150">Class handlers are added to the route such that the most-derived class handler is invoked first, and class handlers from each successive base class are invoked next.</span></span> <span data-ttu-id="61e05-151">Как правило, обработчики классов не регистрируются, так что они также отвечают на перенаправленные события, которые уже были помечены как обработанные.</span><span class="sxs-lookup"><span data-stu-id="61e05-151">Generally, class handlers are not registered such that they also respond to routed events that were already marked handled.</span></span> <span data-ttu-id="61e05-152">Таким образом, этот механизм обработки класса позволяет выбрать один из двух следующих вариантов.</span><span class="sxs-lookup"><span data-stu-id="61e05-152">Therefore, this class handling mechanism enables one of two choices:</span></span>  
  
- <span data-ttu-id="61e05-153">Производные классы могут дополнять обработку класса, наследуемую от базового класса, путем добавления обработчика, который не помечает перенаправленное событие как обработанное, поскольку обработчик базового класса будет иногда вызываться после обработчика производного класса.</span><span class="sxs-lookup"><span data-stu-id="61e05-153">Derived classes can supplement the class handling that is inherited from the base class by adding a handler that does not mark the routed event handled, because the base class handler will be invoked sometime after the derived class handler.</span></span>  
  
- <span data-ttu-id="61e05-154">Производные классы могут заменять обработку класса из базового класса путем добавления обработчика класса, который помечает перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="61e05-154">Derived classes can replace the class handling from the base class by adding a class handler that marks the routed event handled.</span></span> <span data-ttu-id="61e05-155">Следует соблюдать осторожность при таком подходе, потому что в результате возможно изменение планируемой конструкции базового элемента управления в таких областях, как внешний вид, логика состояний, обработки ввода и обработка команд.</span><span class="sxs-lookup"><span data-stu-id="61e05-155">You should be cautious with this approach, because it will potentially change the intended base control design in areas such as visual appearance, state logic, input handling, and command handling.</span></span>  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a><span data-ttu-id="61e05-156">Обработка перенаправленных событий базовыми классами элементов управления</span><span class="sxs-lookup"><span data-stu-id="61e05-156">Class Handling of Routed Events by Control Base Classes</span></span>  
 <span data-ttu-id="61e05-157">В каждом узле элементов в маршруте события прослушиватели классов имеют возможность ответить на перенаправленное событие прежде, чем это сможет сделать любой прослушиватель экземпляра в элементе.</span><span class="sxs-lookup"><span data-stu-id="61e05-157">On each given element node in an event route, class listeners have the opportunity to respond to the routed event before any instance listener on the element can.</span></span> <span data-ttu-id="61e05-158">По этой причине обработчики классов иногда используются для подавления перенаправленных событий, которые определенная реализация класса элементов управления не желает распространять дальше, или для предоставления специальной обработки этого перенаправленного события, являющейся функцией класса.</span><span class="sxs-lookup"><span data-stu-id="61e05-158">For this reason, class handlers are sometimes used to suppress routed events that a particular control class implementation does not wish to propagate further, or to provide special handling of that routed event that is a feature of the class.</span></span> <span data-ttu-id="61e05-159">Например, класс может вызывать собственное событие класса, содержащее дополнительные сведения о том, что означает некоторое пользовательское условие ввода в контексте данного класса.</span><span class="sxs-lookup"><span data-stu-id="61e05-159">For instance, a class might raise its own class-specific event that contains more specifics about what some user input condition means in the context of that particular class.</span></span> <span data-ttu-id="61e05-160">Затем эта реализация класса может пометить более общее перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="61e05-160">The class implementation might then mark the more general routed event as handled.</span></span> <span data-ttu-id="61e05-161">Обработчики класса обычно добавляются таким образом, чтобы они не вызываются для перенаправленных событий, где общие данные события уже помечены как обработанные, однако для нетипичных случаев имеется также <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> подпись, которая регистрирует обработчики классов для вызова, даже если перенаправленные события имеют помечено как обработанное.</span><span class="sxs-lookup"><span data-stu-id="61e05-161">Class handlers are typically added such that they are not invoked for routed events where shared event data was already marked handled, but for atypical cases there is also a <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature that registers class handlers to invoke even when routed events are marked handled.</span></span>  
  
### <a name="class-handler-virtuals"></a><span data-ttu-id="61e05-162">Виртуальные функции обработчиков классов</span><span class="sxs-lookup"><span data-stu-id="61e05-162">Class Handler Virtuals</span></span>  
 <span data-ttu-id="61e05-163">Некоторые элементы, в частности базовые элементы, такие как <xref:System.Windows.UIElement>, предоставляют пустые «на \* событий» и «OnPreview\*событий» виртуальные методы, которые соответствуют списку общих перенаправленных событий.</span><span class="sxs-lookup"><span data-stu-id="61e05-163">Some elements, particularly the base elements such as <xref:System.Windows.UIElement>, expose empty "On\*Event" and "OnPreview\*Event" virtual methods that correspond to their list of public routed events.</span></span> <span data-ttu-id="61e05-164">Эти виртуальные методы можно переопределить, чтобы реализовать обработчик класса для перенаправленного события.</span><span class="sxs-lookup"><span data-stu-id="61e05-164">These virtual methods can be overridden to implement a class handler for that routed event.</span></span> <span data-ttu-id="61e05-165">Классы базовых элементов регистрируют эти виртуальные методы как свои обработчики классов для каждого такого перенаправленного события с помощью <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> как было описано ранее.</span><span class="sxs-lookup"><span data-stu-id="61e05-165">The base element classes register these virtual methods as their class handler for each such routed event using <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> as described earlier.</span></span> <span data-ttu-id="61e05-166">Виртуальные методы On\*Event существенно упрощают реализацию обработки класса для соответствующих перенаправленных события, не требуя специальной инициализации в статических конструкторах для каждого типа.</span><span class="sxs-lookup"><span data-stu-id="61e05-166">The On\*Event virtual methods make it much simpler to implement class handling for the relevant routed events, without requiring special initialization in static constructors for each type.</span></span> <span data-ttu-id="61e05-167">Например, можно добавить обработку класса для <xref:System.Windows.UIElement.DragEnter> событий в любом <xref:System.Windows.UIElement> производный класс, переопределив <xref:System.Windows.UIElement.OnDragEnter%2A> виртуального метода.</span><span class="sxs-lookup"><span data-stu-id="61e05-167">For instance, you can add class handling for the <xref:System.Windows.UIElement.DragEnter> event in any <xref:System.Windows.UIElement> derived class by overriding the <xref:System.Windows.UIElement.OnDragEnter%2A> virtual method.</span></span> <span data-ttu-id="61e05-168">В переопределении можно обрабатывать перенаправленное событие, вызывать другие события, инициировать логику данного класса, которая может изменять свойства элементов в экземплярах или задавать любое сочетание этих действий.</span><span class="sxs-lookup"><span data-stu-id="61e05-168">Within the override, you could handle the routed event, raise other events, initiate class-specific logic that might change element properties on instances, or any combination of those actions.</span></span> <span data-ttu-id="61e05-169">Обычно в таких переопределениях следует вызывать базовую реализацию, даже если событие помечается как обработанное.</span><span class="sxs-lookup"><span data-stu-id="61e05-169">You should generally call the base implementation in such overrides even if you mark the event handled.</span></span> <span data-ttu-id="61e05-170">Вызов базовой реализации настоятельно рекомендуется, так как виртуальный метод находится в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="61e05-170">Calling the base implementation is strongly recommended because the virtual method is on the base class.</span></span> <span data-ttu-id="61e05-171">Стандартный защищенный виртуальный шаблон вызова базовых реализаций из каждого виртуального метода в сущности заменяет и дублирует аналогичный механизм, встроенный в обработку класса перенаправленных событий, в котором обработчики классов для всех классов в иерархии вызываются в любом указанном экземпляре, начиная с обработчика класса, самого дальнего в иерархии, и заканчивая обработчиком базового класса.</span><span class="sxs-lookup"><span data-stu-id="61e05-171">The standard protected virtual pattern of calling the base implementations from each virtual essentially replaces and parallels a similar mechanism that is native to routed event class handling, whereby class handlers for all classes in a class hierarchy are called on any given instance, starting with the most-derived class' handler and continuing to the base class handler.</span></span> <span data-ttu-id="61e05-172">Вам достаточно лишь опустить вызов базовой реализации, если класс обоснованно требует изменить логику обработки базового класса.</span><span class="sxs-lookup"><span data-stu-id="61e05-172">You should only omit the base implementation call if your class has a deliberate requirement to change the base class handling logic.</span></span> <span data-ttu-id="61e05-173">Вызов базовой реализации до или после переопределения кода будет зависеть от природы реализации.</span><span class="sxs-lookup"><span data-stu-id="61e05-173">Whether you call the base implementation before or after your overriding code will depend on the nature of your implementation.</span></span>  
  
#### <a name="input-event-class-handling"></a><span data-ttu-id="61e05-174">Обработка классов событий ввода</span><span class="sxs-lookup"><span data-stu-id="61e05-174">Input Event Class Handling</span></span>  
 <span data-ttu-id="61e05-175">Все виртуальные методы обработчика класса регистрируются таким образом, что они вызываются только в случаях, когда общие данные события еще не помечены как обработанные.</span><span class="sxs-lookup"><span data-stu-id="61e05-175">The class handler virtual methods are all registered such that they are only invoked in cases where any shared event data are not already marked handled.</span></span> <span data-ttu-id="61e05-176">Кроме того, исключительно для событий ввода, нисходящая и восходящая версии маршрутизации обычно вызываются последовательно и совместно используют данные события.</span><span class="sxs-lookup"><span data-stu-id="61e05-176">Also, for the input events uniquely, the tunneling and bubbling versions typically are raised in sequence and share event data.</span></span> <span data-ttu-id="61e05-177">Это влечет за собой то, что для конкретной пары обработчиков класса событий ввода, где один является версией для нисходящей маршрутизации, а другой — для восходящей, вы можете не захотеть немедленно пометить событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="61e05-177">This entails that for a given pair of class handlers of input events where one is the tunneling version and the other is the bubbling version, you may not want to mark the event handled immediately.</span></span> <span data-ttu-id="61e05-178">Если вы реализуете виртуальный метод обработки класса событий нисходящей маршрутизации для пометки события как обработанного, это препятствует вызову обработчика класса событий восходящей маршрутизации (а также препятствует вызову любых обычно зарегистрированных обработчиков экземпляров для событий как нисходящей, так и восходящей маршрутизации).</span><span class="sxs-lookup"><span data-stu-id="61e05-178">If you implement the tunneling class handling virtual method to mark the event handled, that will prevent the bubbling class handler from being invoked (as well as preventing any normally registered instance handlers for either the tunneling or bubbling event from being invoked).</span></span>  
  
 <span data-ttu-id="61e05-179">После завершения обработки класса в узле рассматриваются прослушиватели экземпляров.</span><span class="sxs-lookup"><span data-stu-id="61e05-179">Once class handling on a node is complete, the instance listeners are considered.</span></span>  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a><span data-ttu-id="61e05-180">Добавление обработчиков экземпляра, которые вызываются, даже когда события помечены как обработанные</span><span class="sxs-lookup"><span data-stu-id="61e05-180">Adding Instance Handlers That Are Raised Even When Events Are Marked Handled</span></span>  
 <span data-ttu-id="61e05-181"><xref:System.Windows.UIElement.AddHandler%2A> Метод предоставляет конкретную перегрузку, которая дает возможность добавлять обработчики, которые будут вызываться системой событий всякий раз, когда событие достигает обрабатываемый элемент в маршруте, даже если некоторые другие обработчики уже отметили данные события для пометки, событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="61e05-181">The <xref:System.Windows.UIElement.AddHandler%2A> method supplies a particular overload that allows you to add handlers that will be invoked by the event system whenever an event reaches the handling element in the route, even if some other handler has already adjusted the event data to mark that event as handled.</span></span> <span data-ttu-id="61e05-182">Обычно это не делается.</span><span class="sxs-lookup"><span data-stu-id="61e05-182">This is not typically done.</span></span> <span data-ttu-id="61e05-183">Как правило, обработчики могут быть написаны для корректировки всех областей кода приложения, на которые может влиять событие, независимо от того, где оно было обработано в дереве элементов, даже если требуется несколько конечных результатов.</span><span class="sxs-lookup"><span data-stu-id="61e05-183">Generally, handlers can be written to adjust all areas of application code that might be influenced by an event, regardless of where it was handled in an element tree, even if multiple end results are desired.</span></span> <span data-ttu-id="61e05-184">Кроме того, обычно существует только один элемент, который должен отвечать на это событие, и соответствующая прикладная логика уже была применена.</span><span class="sxs-lookup"><span data-stu-id="61e05-184">Also, typically there is really only one element that needs to respond to that event, and the appropriate application logic had already happened.</span></span> <span data-ttu-id="61e05-185">Однако перегрузка `handledEventsToo` доступна в исключительных случаях, когда некоторые элементы в дереве элементов или в составных элементах управления уже пометили событие как обработанное, но другие элементы, находящиеся выше или ниже в дереве элементов (в зависимости от маршрута), по-прежнему требуют вызов своих собственных обработчиков.</span><span class="sxs-lookup"><span data-stu-id="61e05-185">But the `handledEventsToo` overload is available for the exceptional cases where some other element in an element tree or control compositing has already marked an event as handled, but other elements either higher or lower in the element tree (depending on route) still wish to have their own handlers invoked.</span></span>  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a><span data-ttu-id="61e05-186">Когда следует помечать обработанные события как необработанные</span><span class="sxs-lookup"><span data-stu-id="61e05-186">When to Mark Handled Events as Unhandled</span></span>  
 <span data-ttu-id="61e05-187">Как правило, перенаправленные события, которые помечены как обработанные следует не должны помечаться как необработанные (<xref:System.Windows.RoutedEventArgs.Handled%2A> снова установить значение `false`) даже обработчиками, которые действуют на `handledEventsToo`.</span><span class="sxs-lookup"><span data-stu-id="61e05-187">Generally, routed events that are marked handled should not be marked unhandled (<xref:System.Windows.RoutedEventArgs.Handled%2A> set back to `false`) even by handlers that act on `handledEventsToo`.</span></span> <span data-ttu-id="61e05-188">Однако некоторые события ввода имеют представления событий высокого и низкого уровня, которые могут перекрываться, когда событие высокого уровня отображается в одной позиции в дереве, а событие низкого уровня — в другой позиции.</span><span class="sxs-lookup"><span data-stu-id="61e05-188">However, some input events have high-level and lower-level event representations that can overlap when the high-level event is seen at one position in the tree and the low-level event at another position.</span></span> <span data-ttu-id="61e05-189">Например, рассмотрим случай, где дочерний элемент прослушивает ключевое событие высокого например <xref:System.Windows.UIElement.TextInput> хотя родительский элемент прослушивает событие нижнего уровня, такие как <xref:System.Windows.UIElement.KeyDown>.</span><span class="sxs-lookup"><span data-stu-id="61e05-189">For instance, consider the case where a child element listens to a high-level key event such as <xref:System.Windows.UIElement.TextInput> while a parent element listens to a low-level event such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="61e05-190">Если родительский элемент обрабатывает событие нижнего уровня, событие верхнего уровня может подавляться даже в дочернем элементе, который интуитивно должен иметь возможность первым обработать это событие.</span><span class="sxs-lookup"><span data-stu-id="61e05-190">If the parent element handles the low-level event, the higher-level event can be suppressed even in the child element that intuitively should have first opportunity to handle the event.</span></span>  
  
 <span data-ttu-id="61e05-191">В таких ситуациях может потребоваться добавить обработчики события нижнего уровня и в родительский, и в дочерний элемент.</span><span class="sxs-lookup"><span data-stu-id="61e05-191">In these situations it may be necessary to add handlers to both parent elements and child elements for the low-level event.</span></span> <span data-ttu-id="61e05-192">Реализация обработчика дочернего элемента может пометить событие нижнего уровня как обработанное, но реализация обработчика родительского элемента будет снова устанавливать его как необработанное, чтобы последующие элементы в дереве (а также события высокого уровня) имели возможность ответить.</span><span class="sxs-lookup"><span data-stu-id="61e05-192">The child element handler implementation can mark the low-level event as handled, but the parent element handler implementation would set it unhandled again so that further elements up the tree (as well as the high-level event) can have the opportunity to respond.</span></span> <span data-ttu-id="61e05-193">Это достаточно редкая ситуация.</span><span class="sxs-lookup"><span data-stu-id="61e05-193">This situation is should be fairly rare.</span></span>  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a><span data-ttu-id="61e05-194">Намеренное подавление событий ввода для составных элементов управления</span><span class="sxs-lookup"><span data-stu-id="61e05-194">Deliberately Suppressing Input Events for Control Compositing</span></span>  
 <span data-ttu-id="61e05-195">Основной сценарий, в котором используется обработка класса перенаправленных событий, предназначен для событий ввода и составных элементов управления.</span><span class="sxs-lookup"><span data-stu-id="61e05-195">The main scenario where class handling of routed events is used is for input events and composited controls.</span></span> <span data-ttu-id="61e05-196">Составной элемент управления по определению состоит из нескольких фактических элементов управления или базовых классов элементов управления.</span><span class="sxs-lookup"><span data-stu-id="61e05-196">A composited control is by definition composed of multiple practical controls or control base classes.</span></span> <span data-ttu-id="61e05-197">Часто разработчик элемента управления хочет объединить все возможные события ввода, которые могут вызываться каждым из компонентов, чтобы полный элемент управления был единственным источником событий.</span><span class="sxs-lookup"><span data-stu-id="61e05-197">Often the author of the control wishes to amalgamate all of the possible input events that each of the subcomponents might raise, in order to report the entire control as the singular event source.</span></span> <span data-ttu-id="61e05-198">В некоторых случаях разработчик элемента управления может захотеть полностью подавить события от компонентов или заменить на определяемое компонентом событие, которое содержит дополнительные сведения или подразумевает более конкретное поведение.</span><span class="sxs-lookup"><span data-stu-id="61e05-198">In some cases the control author might wish to suppress the events from components entirely, or substitute a component-defined event that carries more information or implies a more specific behavior.</span></span> <span data-ttu-id="61e05-199">Типичный пример, который сразу виден любому разработчику компонента — как [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> обрабатывает любые события мыши, в конечном итоге будет разрешено в интуитивно понятное событие всех кнопках: <xref:System.Windows.Controls.Primitives.ButtonBase.Click> событий.</span><span class="sxs-lookup"><span data-stu-id="61e05-199">The canonical example that is immediately visible to any component author is how a [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> handles any mouse event that will eventually resolve to the intuitive event that all buttons have: a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 <span data-ttu-id="61e05-200"><xref:System.Windows.Controls.Button> Базового класса (<xref:System.Windows.Controls.Primitives.ButtonBase>) является производным от <xref:System.Windows.Controls.Control> который, в свою очередь, наследуется от <xref:System.Windows.FrameworkElement> и <xref:System.Windows.UIElement>и большая часть инфраструктуры событий, необходимой для обработки ввода элемента управления доступны в <xref:System.Windows.UIElement> уровень.</span><span class="sxs-lookup"><span data-stu-id="61e05-200">The <xref:System.Windows.Controls.Button> base class (<xref:System.Windows.Controls.Primitives.ButtonBase>) derives from <xref:System.Windows.Controls.Control> which in turn derives from <xref:System.Windows.FrameworkElement> and <xref:System.Windows.UIElement>, and much of the event infrastructure needed for control input processing is available at the <xref:System.Windows.UIElement> level.</span></span> <span data-ttu-id="61e05-201">В частности <xref:System.Windows.UIElement> обрабатывает Общие <xref:System.Windows.Input.Mouse> события, которые обрабатывают проверку попадания курсора мыши в пределах его границ и предоставляет различные события для наиболее часто используемых действий кнопок, такие как <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="61e05-201">In particular, <xref:System.Windows.UIElement> processes general <xref:System.Windows.Input.Mouse> events that handle hit testing for the mouse cursor within its bounds, and provides distinct events for the most common button actions, such as <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="61e05-202"><xref:System.Windows.UIElement> также предоставляет пустой виртуальный <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> качестве предварительно зарегистрированного обработчика класса для <xref:System.Windows.UIElement.MouseLeftButtonDown>, и <xref:System.Windows.Controls.Primitives.ButtonBase> ее переопределяет.</span><span class="sxs-lookup"><span data-stu-id="61e05-202"><xref:System.Windows.UIElement> also provides an empty virtual <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> as the preregistered class handler for <xref:System.Windows.UIElement.MouseLeftButtonDown>, and <xref:System.Windows.Controls.Primitives.ButtonBase> overrides it.</span></span> <span data-ttu-id="61e05-203">Аналогичным образом <xref:System.Windows.Controls.Primitives.ButtonBase> использует класс обработчики для <xref:System.Windows.UIElement.MouseLeftButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="61e05-203">Similarly, <xref:System.Windows.Controls.Primitives.ButtonBase> uses class handlers for <xref:System.Windows.UIElement.MouseLeftButtonUp>.</span></span> <span data-ttu-id="61e05-204">В переопределениях, которые передают данные событий, реализации помечают, <xref:System.Windows.RoutedEventArgs> экземпляр как обработанного путем присвоения <xref:System.Windows.RoutedEventArgs.Handled%2A> для `true`, и что же событий данные остаются на всей оставшейся части маршрута к другим обработчикам классов и также к обработчикам экземпляров или методы задания событий.</span><span class="sxs-lookup"><span data-stu-id="61e05-204">In the overrides, which are passed the event data, the implementations mark that <xref:System.Windows.RoutedEventArgs> instance as handled by setting <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`, and that same event data is what continues along the remainder of the route to other class handlers and also to instance handlers or event setters.</span></span> <span data-ttu-id="61e05-205">Кроме того <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> переопределение будет вызывать <xref:System.Windows.Controls.Primitives.ButtonBase.Click> событий.</span><span class="sxs-lookup"><span data-stu-id="61e05-205">Also, the <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> override will next raise the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="61e05-206">Конечным результатом для большинства прослушивателей будут, <xref:System.Windows.UIElement.MouseLeftButtonDown> и <xref:System.Windows.UIElement.MouseLeftButtonUp> «исчезновение» событий и замена их <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, событие, которое имеет больше смысла, так как известно, поступившее от настоящей кнопки, а не некоторые составной фигуру полностью кнопки или из другой элемент.</span><span class="sxs-lookup"><span data-stu-id="61e05-206">The end result for most listeners will be that the <xref:System.Windows.UIElement.MouseLeftButtonDown> and <xref:System.Windows.UIElement.MouseLeftButtonUp> events "disappear" and are replaced instead by <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, an event that holds more meaning because it is known that this event originated from a true button and not some composite piece of the button or from some other element entirely.</span></span>  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a><span data-ttu-id="61e05-207">Обход скрытия события элементами управления</span><span class="sxs-lookup"><span data-stu-id="61e05-207">Working Around Event Suppression by Controls</span></span>  
 <span data-ttu-id="61e05-208">Иногда это поведение скрытия события внутри отдельных элементов управления может конфликтовать с некоторыми более общими целями логики обработки событий в приложении.</span><span class="sxs-lookup"><span data-stu-id="61e05-208">Sometimes this event suppression behavior within individual controls can interfere with some more general intentions of event handling logic for your application.</span></span> <span data-ttu-id="61e05-209">Например если для какой-либо причине приложение имеет обработчик для <xref:System.Windows.UIElement.MouseLeftButtonDown> находится в корневом элементе приложения, то можно заметить, что любой щелчок мышью по кнопке не вызывает <xref:System.Windows.UIElement.MouseLeftButtonDown> или <xref:System.Windows.UIElement.MouseLeftButtonUp> обработчики на корневом уровне.</span><span class="sxs-lookup"><span data-stu-id="61e05-209">For instance, if for some reason your application had a handler for <xref:System.Windows.UIElement.MouseLeftButtonDown> located at the application root element, you would notice that any mouse click on a button would not invoke <xref:System.Windows.UIElement.MouseLeftButtonDown> or <xref:System.Windows.UIElement.MouseLeftButtonUp> handlers at the root level.</span></span> <span data-ttu-id="61e05-210">Само событие действительно передается вверх (еще раз, маршруты событий на самом деле не завершены, но система перенаправления событий изменяет поведение вызова их обработчика после пометки их как обработанных).</span><span class="sxs-lookup"><span data-stu-id="61e05-210">The event itself actually did bubble up (again, event routes are not truly ended, but the routed event system changes their handler invocation behavior after being marked handled).</span></span> <span data-ttu-id="61e05-211">Когда перенаправленное событие достигает кнопки, <xref:System.Windows.Controls.Primitives.ButtonBase> обработку класса помечен <xref:System.Windows.UIElement.MouseLeftButtonDown> как обработанное, поскольку пытается заменить <xref:System.Windows.Controls.Primitives.ButtonBase.Click> событием с большим смыслом.</span><span class="sxs-lookup"><span data-stu-id="61e05-211">When the routed event reached the button, the <xref:System.Windows.Controls.Primitives.ButtonBase> class handling marked the <xref:System.Windows.UIElement.MouseLeftButtonDown> handled because it wished to substitute the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event with more meaning.</span></span> <span data-ttu-id="61e05-212">Таким образом, любой стандарт <xref:System.Windows.UIElement.MouseLeftButtonDown> обработчик далее по маршруту вызываться не будет.</span><span class="sxs-lookup"><span data-stu-id="61e05-212">Therefore, any standard <xref:System.Windows.UIElement.MouseLeftButtonDown> handler further up the route would not be invoked.</span></span> <span data-ttu-id="61e05-213">Существует два способа гарантировать, что в таких обстоятельствах ваши обработчики будут вызываться.</span><span class="sxs-lookup"><span data-stu-id="61e05-213">There are two techniques you can use to ensure that your handlers would be invoked in this circumstance.</span></span>  
  
 <span data-ttu-id="61e05-214">Первый способ состоит в том, чтобы намеренно добавить обработчик с помощью `handledEventsToo` подпись <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>.</span><span class="sxs-lookup"><span data-stu-id="61e05-214">The first technique is to deliberately add the handler using the `handledEventsToo` signature of <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>.</span></span> <span data-ttu-id="61e05-215">Этот подход ограничен тем, что такой способ присоединения обработчика событий возможен только из кода, но не из разметки.</span><span class="sxs-lookup"><span data-stu-id="61e05-215">A limitation of this approach is that this technique for attaching an event handler is only possible from code, not from markup.</span></span> <span data-ttu-id="61e05-216">Простой синтаксис указания имени обработчика событий в качестве значения атрибута события посредством [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] не позволяет такое поведение.</span><span class="sxs-lookup"><span data-stu-id="61e05-216">The simple syntax of specifying the event handler name as an event attribute value via [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] does not enable that behavior.</span></span>  
  
 <span data-ttu-id="61e05-217">Второй способ работает только для событий ввода, где версии нисходящей и восходящей маршрутизации перенаправленного события объединены в пару.</span><span class="sxs-lookup"><span data-stu-id="61e05-217">The second technique works only for input events, where the tunneling and bubbling versions of the routed event are paired.</span></span> <span data-ttu-id="61e05-218">Для этих перенаправленных событий можно добавлять обработчики в версию перенаправленного события нисходящей маршрутизации.</span><span class="sxs-lookup"><span data-stu-id="61e05-218">For these routed events, you can add handlers to the preview/tunneling equivalent routed event instead.</span></span> <span data-ttu-id="61e05-219">Это перенаправленное событие будет спускаться по маршруту, начиная от корня, поэтому код обработки класса кнопки не будет его перехватывать, при условии что вы присоединили обработчик предварительного просмотра на уровне предшествующего элемента в дереве элементов приложения.</span><span class="sxs-lookup"><span data-stu-id="61e05-219">That routed event will tunnel through the route starting from the root, so the button class handling code would not intercept it, presuming that you attached the Preview handler at some ancestor element level in the application's element tree.</span></span> <span data-ttu-id="61e05-220">При использовании этого подхода будьте внимательны при пометке любого события предварительного просмотра как обработанного.</span><span class="sxs-lookup"><span data-stu-id="61e05-220">If you use this approach, be cautious about marking any Preview event handled.</span></span> <span data-ttu-id="61e05-221">В примере с <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> обрабатывается в корневом элементе, если вы пометили событие как <xref:System.Windows.RoutedEventArgs.Handled%2A> в реализации обработчика, фактически будет подавлено <xref:System.Windows.Controls.Primitives.ButtonBase.Click> событий.</span><span class="sxs-lookup"><span data-stu-id="61e05-221">For the example given with <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> being handled at the root element, if you marked the event as <xref:System.Windows.RoutedEventArgs.Handled%2A> in the handler implementation, you would actually suppress the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="61e05-222">Обычно это нежелательное поведение.</span><span class="sxs-lookup"><span data-stu-id="61e05-222">That is typically not desirable behavior.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="61e05-223">См. также</span><span class="sxs-lookup"><span data-stu-id="61e05-223">See also</span></span>

- <xref:System.Windows.EventManager>
- [<span data-ttu-id="61e05-224">События предварительного просмотра</span><span class="sxs-lookup"><span data-stu-id="61e05-224">Preview Events</span></span>](preview-events.md)
- [<span data-ttu-id="61e05-225">Создание пользовательских перенаправленных событий</span><span class="sxs-lookup"><span data-stu-id="61e05-225">Create a Custom Routed Event</span></span>](how-to-create-a-custom-routed-event.md)
- [<span data-ttu-id="61e05-226">Общие сведения о перенаправленных событиях</span><span class="sxs-lookup"><span data-stu-id="61e05-226">Routed Events Overview</span></span>](routed-events-overview.md)
