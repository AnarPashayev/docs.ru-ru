---
title: XAML и пользовательские классы
ms.date: 03/30/2017
helpviewer_keywords:
- custom classes in XAML [WPF]
- XAML [WPF], custom classes
- classes [WPF], custom classes in XAML
ms.assetid: e7313137-581e-4a64-8453-d44e15a6164a
ms.openlocfilehash: 8dab7310826357d7fbe434002298032b8722e5b5
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2020
ms.locfileid: "76744423"
---
# <a name="xaml-and-custom-classes-for-wpf"></a>Код XAML и пользовательские классы для WPF
XAML, реализованный в средах CLR, поддерживает возможность определения пользовательского класса или структуры на любом языке среды CLR, а затем доступ к этому классу с помощью разметки XAML. В одном файле разметки можно использовать сочетание определенных в [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] типов и пользовательских типов, обычно сопоставляя пользовательские типы с префиксом пространства имен XAML. В этом разделе обсуждаются требования, которым должен соответствовать пользовательский класс, чтобы его можно было использовать в качестве элемента XAML.  

<a name="Custom_Classes_in_Applications_vs__in_Assemblies"></a>   
## <a name="custom-classes-in-applications-or-assemblies"></a>Пользовательские классы в приложениях или сборках  
 Пользовательские классы, используемые в XAML, можно определить двумя способами: в коде программной части или другом коде, который создает основное приложение [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], или как класс в отдельной сборке, например как исполняемый файл или библиотеку DLL, используемые в качестве библиотеки классов. Каждый из этих подходов имеет определенные преимущества и недостатки.  
  
- Преимуществом создания библиотеки классов является то, что все подобные пользовательские классы могут совместно использоваться несколькими различными приложениями. Отдельная библиотека также облегчает управление версиями приложений и упрощает создание класса, который предполагается использовать в качестве корневого элемента на странице XAML.  
  
- Преимущество определения пользовательских классов в приложении состоит в том, что этот способ является относительно простым и сводит к минимуму проблемы развертывания и тестирования, возникающие при введении отдельных сборок за пределами главного исполняемого файла приложения.  
  
- Независимо от того, определены ли пользовательские классы в одной или разных сборках, они должны быть распределены между пространством имен CLR и пространством имен XML, чтобы их можно было использовать в XAML в качестве элементов. См. раздел [Пространства имен XAML и сопоставление пространств имен для WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).  
  
<a name="Requirements_for_a_Custom_Class_as_a_XAML_Element"></a>   
## <a name="requirements-for-a-custom-class-as-a-xaml-element"></a>Требования к пользовательскому классу как элементу XAML  
 Чтобы можно было создавать экземпляр класса в качестве объектного элемента, класс должен удовлетворять указанным ниже требованиям.  
  
- Пользовательский класс должен быть открытым и должен поддерживать открытый конструктор по умолчанию (без параметров). (Примечания о структурах см. в следующем разделе.)  
  
- Пользовательский класс не должен быть вложенным. Вложенные классы и "точка" в их общем синтаксисе использования в среде CLR конфликтуют с другими функциями [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] и XAML, такими как присоединенные свойства.  
  
 В дополнение к разрешению синтаксиса объектных элементов определение объекта также разрешает синтаксис элемента свойства для всех других открытых свойств, которые принимают объект в качестве типа значения. Это происходит потому, что экземпляр объекта теперь может быть создан в качестве объектного элемента и может заполнить значение элемента свойства.  
  
### <a name="structures"></a>Структуры  
 Структуры, определяемые в качестве пользовательских типов, всегда могут быть созданы на языке XAML в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. Это обусловлено тем, что компиляторы CLR неявно создают конструктор без параметров для структуры, которая инициализирует все значения свойств значениями по умолчанию. В некоторых случаях поведение конструктора по умолчанию или использование объектных элементов для структуры является нежелательным. Это возможно в тех случаях, когда структура используется для заполнения значений и функционирует в качестве объединения, в котором хранятся взаимоисключающие значения, и поэтому ни одному из свойств нельзя присвоить значение. [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] пример такой структуры <xref:System.Windows.GridLength>. Как правило, в таких структурах необходимо реализовать преобразователь типов, чтобы значения можно было представить в виде атрибутов, используя преобразования строк для создания различных интерпретаций или режимов значений структуры. Структура должна также предоставлять аналогичное поведение для построения кода с помощью конструктора без параметров.  
  
<a name="Requirements_for_Properties_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-properties-of-a-custom-class-as-xaml-attributes"></a>Требования к свойствам пользовательского класса как атрибутам XAML  
 Свойства должны ссылаться на тип по значению (например, на примитив) или использовать класс для типа, имеющего либо конструктор без параметров, либо специальный преобразователь типов, к которому может получить доступ обработчик XAML. В реализации CLR XAML обработчики XAML либо находят такие конвертеры с помощью встроенной поддержки примитивов языка, либо путем применения <xref:System.ComponentModel.TypeConverterAttribute> к типу или члену в определениях резервных типов.  
  
 Помимо этого, свойство может ссылаться на абстрактный тип класса или интерфейс. Для абстрактных классов или интерфейсов ожидаемый результат синтаксического анализа XAML заключается в том, что значение свойства должно быть заполнено практическими экземплярами класса, которые реализуют интерфейс, или экземплярами типов, которые являются производными от абстрактного класса.  
  
 Свойства могут объявляться в абстрактном классе, но могут быть заданы только в практических классах, производных от абстрактных классов. Это связано с тем, что для создания объектного элемента для класса вообще требуется открытый конструктор без параметров для класса.  
  
### <a name="typeconverter-enabled-attribute-syntax"></a>Синтаксис атрибута с поддержкой TypeConverter  
 Если поддерживается выделенный преобразователь типов атрибутов на уровне класса, то применяемый тип преобразования включает синтаксис атрибута для любого свойства, для которого необходимо создать экземпляр этого типа. Преобразователь типов не включает использование объектного элемента типа; только наличие конструктора без параметров для этого типа активирует использование объектного элемента. Таким образом, свойства, разрешенные преобразователем типов, обычно не используются в синтаксисе свойств, если только сам тип не поддерживает синтаксис объектных элементов. Исключением из этого является указание синтаксиса элемента свойства при наличии элемента свойства, содержащего строку. Это использование на самом деле эквивалентно использованию синтаксиса атрибутов, и такое использование не является распространенным, если нет необходимости в более надежной обработке пробелов в значении атрибута. Например, ниже показано использование элемента свойства, который принимает строку, а использование атрибута эквивалентно.  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe)]  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE2](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe2)]  
  
 Примеры свойств, в которых разрешен синтаксис атрибутов, но синтаксис элемента свойства, содержащего элемент объекта, запрещен посредством XAML — различные свойства, принимающие тип <xref:System.Windows.Input.Cursor>. Класс <xref:System.Windows.Input.Cursor> имеет выделенный преобразователь типов <xref:System.Windows.Input.CursorConverter>, но не предоставляет конструктор без параметров, поэтому свойство <xref:System.Windows.FrameworkElement.Cursor%2A> может быть задано только с помощью синтаксиса атрибутов, даже если фактический тип <xref:System.Windows.Input.Cursor> является ссылочным типом.  
  
### <a name="per-property-type-converters"></a>Преобразователь типа каждого свойства  
 В качестве альтернативы само свойство может объявлять преобразователь типов на уровне свойств. Это позволяет «мини-язык», который создает экземпляры объектов типа встроенного свойства путем обработки входящих строковых значений атрибута в качестве входных данных для <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> операции на основе соответствующего типа. Обычно это делается для предоставления удобного метода доступа, а не как единственное средство для задания свойства в XAML. Однако можно также использовать преобразователи типов для атрибутов, где необходимо использовать существующие типы CLR, которые не предоставляют конструктор без параметров или преобразователь типов с атрибутами. Примерами из API [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] являются определенные свойства, которые принимают тип <xref:System.Globalization.CultureInfo>. В этом случае [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] использовал существующий тип Microsoft .NET Framework <xref:System.Globalization.CultureInfo>, чтобы улучшить совместимость и сценарии миграции, которые использовались в более ранних версиях платформ, но тип <xref:System.Globalization.CultureInfo> не поддерживал необходимые конструкторы или преобразование типов на уровне типа для использования в качестве значения свойства XAML напрямую.  
  
 При каждом предоставлении свойства, использующего XAML (особенно в том случае, если вы являетесь автором элемента управления), настоятельно рекомендуем резервировать это свойство с помощью свойства зависимости. Это особенно справедливо при использовании существующей реализации [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] обработчика XAML, так как можно повысить производительность с помощью <xref:System.Windows.DependencyProperty> резервного копирования. Свойство зависимости предоставит возможности системы свойств для данного свойства, которые пользователи ожидают от доступного в XAML свойства. В число этих возможностей входят анимация, привязка данных и поддержка стилей. Дополнительные сведения см. в разделах [Пользовательские свойства зависимостей](custom-dependency-properties.md) и [Загрузка кода XAML и свойства зависимостей](xaml-loading-and-dependency-properties.md).  
  
### <a name="writing-and-attributing-a-type-converter"></a>Написание и установка атрибутов преобразователя типов  
 Иногда потребуется написать пользовательский <xref:System.ComponentModel.TypeConverter> производный класс, чтобы обеспечить преобразование типов для типа свойства. Инструкции по наследованию от и созданию преобразователя типов, поддерживающего использование XAML, а также о применении <xref:System.ComponentModel.TypeConverterAttribute>см. в разделе [TypeConverters and XAML](typeconverters-and-xaml.md).  
  
<a name="Requirements_for_Events_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-xaml-event-handler-attribute-syntax-on-events-of-a-custom-class"></a>Требования к синтаксису атрибутов обработчиков событий XAML пользовательского класса  
 Для использования в качестве события CLR событие должно быть предоставлено как открытое событие в классе, поддерживающем конструктор без параметров, или на абстрактном классе, где событие может быть получено в производных классах. Для удобства использования в качестве перенаправленного события ваше событие CLR должно реализовывать явные `add` и `remove` методы, которые добавляют и удаляют обработчики для сигнатуры событий CLR и передают эти обработчики методам <xref:System.Windows.UIElement.AddHandler%2A> и <xref:System.Windows.UIElement.RemoveHandler%2A>. Эти методы добавляют или удаляют обработчики из хранилища обработчиков перенаправленных событий экземпляра, к которому присоединено событие.  
  
> [!NOTE]
> Обработчики можно регистрировать непосредственно для перенаправленных событий с помощью <xref:System.Windows.UIElement.AddHandler%2A>и намеренно не определять событие CLR, которое предоставляет перенаправленное событие. Обычно это не рекомендуется, так как событие не включит синтаксис атрибута XAML для подключения обработчиков и результирующий класс предложит менее прозрачное представление XAML возможностей этого типа.  
  
<a name="Collection_Properties"></a>   
## <a name="writing-collection-properties"></a>Написание свойств коллекции  
 Свойства, принимающие тип коллекции, имеют синтаксис XAML, который позволяет определять объекты, добавляемые в коллекцию. Этот синтаксис имеет две важные функции.  
  
- Объект, являющийся объектом коллекции, необязательно определять в синтаксисе объектного элемента. Присутствие этого типа коллекции подразумевается всякий раз, когда в XAML указывается свойство, принимающее тип коллекции.  
  
- Дочерние элементы свойства коллекции в разметке обрабатываются для того, чтобы они стали элементами коллекции. Обычно доступ кода к элементам коллекции осуществляется через методы списка или словаря, такие как `Add`, или через индексатор. Но синтаксис XAML не поддерживает методы или индексаторы. (Исключением является версия XAML 2009, которая поддерживает методы, но ее применение ограничивает возможные способы использования WPF. См. раздел [Возможности языка XAML 2009](../../../desktop-wpf/xaml-services/xaml-2009-language-features.md).) Коллекции, очевидно, являются очень общим требованием для построения дерева элементов, и требуется какой-нибудь способ заполнения этих коллекций в декларативном XAML. Таким образом, дочерние элементы свойства коллекции обрабатываются путем добавления их в коллекцию, которая является значением типа свойства коллекции.  
  
 Реализация служб XAML в .NET Framework и, следовательно, процессор XAML WPF используют указанное ниже определение того, что составляет свойство коллекции. Тип свойства должен реализовывать один из следующих интерфейсов:  
  
- Реализует <xref:System.Collections.IList>.  
  
- Реализует <xref:System.Collections.IDictionary> или универсальный эквивалент (<xref:System.Collections.Generic.IDictionary%602>).  
  
- Является производным от <xref:System.Array> (Дополнительные сведения о массивах в XAML см. в разделе [расширение разметки x:Array](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)  
  
- Реализует <xref:System.Windows.Markup.IAddChild> (интерфейс, определенный [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).  
  
 Каждый из этих типов в среде CLR имеет метод `Add`, который используется процессором XAML для добавления элементов в базовую коллекцию при создании графа объекта.  
  
> [!NOTE]
> Универсальные интерфейсы `List` и `Dictionary` (<xref:System.Collections.Generic.IList%601> и <xref:System.Collections.Generic.IDictionary%602>) не поддерживают обнаружение коллекций с помощью обработчика XAML [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. Однако класс <xref:System.Collections.Generic.List%601> можно использовать в качестве базового класса, поскольку он реализует <xref:System.Collections.IList> напрямую или <xref:System.Collections.Generic.Dictionary%602> как базовый класс, так как он реализует <xref:System.Collections.IDictionary> напрямую.  
  
 При объявлении свойства, принимающего коллекцию, будьте осторожны при инициализации значения свойства в новых экземплярах типа. Если свойство не реализуется как свойство зависимости, то со свойством достаточно использовать резервное поле, вызывающее конструктор типа коллекции. Если свойство является свойством зависимости, то может потребоваться инициализация свойства коллекции как части конструктора типа по умолчанию. Это обусловлено тем, что свойство зависимости принимает значение по умолчанию из метаданных и обычно нежелательно, чтобы начальное значение свойства коллекции было статической общей коллекцией. Экземпляр коллекции должен иметься для каждого экземпляра содержащего типа. Дополнительные сведения см. в разделе [Пользовательские свойства зависимостей](custom-dependency-properties.md).  
  
 Вы можете реализовать пользовательский тип коллекции для свойства коллекции. Из-за неявной обработки свойства коллекции пользовательскому типу коллекции не нужно предоставлять конструктор без параметров, чтобы его можно было использовать в XAML неявно. Однако при необходимости можно предоставить конструктор без параметров для типа коллекции. Это может оказаться целесообразным. Если не предоставить конструктор без параметров, вы не сможете явно объявить коллекцию как объектный элемент. Некоторые разработчики разметки могут предпочесть просмотр явной коллекции в качестве стиля разметки. Кроме того, конструктор без параметров может упростить требования к инициализации при создании новых объектов, использующих тип коллекции в качестве значения свойства.  
  
<a name="XAMLCONtent"></a>   
## <a name="declaring-xaml-content-properties"></a>Объявление свойств содержимого XAML  
 Язык XAML определяет концепцию свойства содержимого [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]. Каждый класс, используемый в синтаксисе объекта, может иметь только одно свойство содержимого XAML. Чтобы объявить свойство в качестве свойства содержимого XAML для класса, примените <xref:System.Windows.Markup.ContentPropertyAttribute> как часть определения класса. Укажите имя предполагаемого свойства содержимого XAML в качестве <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> в атрибуте. Свойство указывается как строка по имени, а не как конструкция отражения, например <xref:System.Reflection.PropertyInfo>.  
  
 Можно определить свойство коллекции как свойство содержимого XAML. Это отражается на использовании этого свойства, так как объектный элемент может иметь один или несколько дочерних элементов без промежуточных объектных элементов коллекции или тегов элементов свойства. Эти элементы затем рассматриваются как значение для свойства содержимого XAML и добавляются к резервному экземпляру коллекции.  
  
 Некоторые существующие свойства содержимого XAML используют тип свойства `Object`. Это позволяет использовать свойство содержимого XAML, которое может принимать примитивные значения, такие как <xref:System.String>, а также принимает одно значение ссылочного объекта. Если следовать этой модели, то тип будет отвечать как за определение типа, так и за обработку возможных типов. Типичная причина для типа содержимого <xref:System.Object> заключается в поддержке как простых средств добавления содержимого объекта в виде строки (которая получает обработку представления по умолчанию), так и расширенных средств для добавления содержимого объекта, указывающего представление не по умолчанию или дополнительные данные.  
  
<a name="Serializing"></a>   
## <a name="serializing-xaml"></a>Сериализация XAML  
 В некоторых сценариях (например, если вы являетесь автором элемента управления) следует убедиться в том, что любое представление объекта, которое может быть создано в XAML, также может быть сериализовано обратно в эквивалентную разметку XAML. Требования к сериализации не описываются в этом разделе. См. разделы [Общие сведения о разработке элементов управления](../controls/control-authoring-overview.md) и [Дерево элементов и сериализация](element-tree-and-serialization.md).  
  
## <a name="see-also"></a>См. также:

- [Общие сведения о языке XAML (WPF)](../../../desktop-wpf/fundamentals/xaml.md)
- [Пользовательские свойства зависимостей](custom-dependency-properties.md)
- [Общие сведения о разработке элементов управления](../controls/control-authoring-overview.md)
- [Общие сведения о базовых элементах](base-elements-overview.md)
- [Загрузка кода XAML и свойства зависимостей](xaml-loading-and-dependency-properties.md)
