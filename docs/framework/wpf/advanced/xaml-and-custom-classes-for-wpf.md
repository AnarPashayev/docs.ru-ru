---
title: Код XAML и пользовательские классы для WPF
ms.date: 03/30/2017
helpviewer_keywords:
- custom classes in XAML [WPF]
- XAML [WPF], custom classes
- classes [WPF], custom classes in XAML
ms.assetid: e7313137-581e-4a64-8453-d44e15a6164a
ms.openlocfilehash: 8b47c43e897004a6c7eb3d2f8b2a2b9bb625e158
ms.sourcegitcommit: 24a4a8eb6d8cfe7b8549fb6d823076d7c697e0c6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/23/2019
ms.locfileid: "68400836"
---
# <a name="xaml-and-custom-classes-for-wpf"></a><span data-ttu-id="d4710-102">Код XAML и пользовательские классы для WPF</span><span class="sxs-lookup"><span data-stu-id="d4710-102">XAML and Custom Classes for WPF</span></span>
<span data-ttu-id="d4710-103">XAML, реализованный в средах CLR, поддерживает возможность определения пользовательского класса или структуры на любом языке среды CLR, а затем доступ к этому классу с помощью разметки XAML.</span><span class="sxs-lookup"><span data-stu-id="d4710-103">XAML as implemented in common language runtime (CLR) frameworks supports the ability to define a custom class or structure in any common language runtime (CLR) language, and then access that class using XAML markup.</span></span> <span data-ttu-id="d4710-104">В одном файле разметки можно использовать сочетание определенных в [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] типов и пользовательских типов, обычно сопоставляя пользовательские типы с префиксом пространства имен XAML.</span><span class="sxs-lookup"><span data-stu-id="d4710-104">You can use a mixture of [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-defined types and your custom types within the same markup file, typically by mapping the custom types to a XAML namespace prefix.</span></span> <span data-ttu-id="d4710-105">В этом разделе обсуждаются требования, которым должен соответствовать пользовательский класс, чтобы его можно было использовать в качестве элемента XAML.</span><span class="sxs-lookup"><span data-stu-id="d4710-105">This topic discusses the requirements that a custom class must satisfy to be usable as a XAML element.</span></span>  

<a name="Custom_Classes_in_Applications_vs__in_Assemblies"></a>   
## <a name="custom-classes-in-applications-or-assemblies"></a><span data-ttu-id="d4710-106">Пользовательские классы в приложениях или сборках</span><span class="sxs-lookup"><span data-stu-id="d4710-106">Custom Classes in Applications or Assemblies</span></span>  
 <span data-ttu-id="d4710-107">Пользовательские классы, используемые в XAML, можно определить двумя способами: в коде программной части или другом коде, который создает основное приложение [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], или как класс в отдельной сборке, например как исполняемый файл или библиотеку DLL, используемые в качестве библиотеки классов.</span><span class="sxs-lookup"><span data-stu-id="d4710-107">Custom classes that are used in XAML can be defined in two distinct ways: within the code-behind or other code that produces the primary [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application, or as a class in a separate assembly, such as an executable or DLL used as a class library.</span></span> <span data-ttu-id="d4710-108">Каждый из этих подходов имеет определенные преимущества и недостатки.</span><span class="sxs-lookup"><span data-stu-id="d4710-108">Each of these approaches has particular advantages and disadvantages.</span></span>  
  
- <span data-ttu-id="d4710-109">Преимуществом создания библиотеки классов является то, что все подобные пользовательские классы могут совместно использоваться несколькими различными приложениями.</span><span class="sxs-lookup"><span data-stu-id="d4710-109">The advantage of creating a class library is that any such custom classes can be shared across many different possible applications.</span></span> <span data-ttu-id="d4710-110">Отдельная библиотека также облегчает управление версиями приложений и упрощает создание класса, который предполагается использовать в качестве корневого элемента на странице XAML.</span><span class="sxs-lookup"><span data-stu-id="d4710-110">A separate library also makes versioning issues of applications easier to control, and simplifies creating a class where the intended class usage is as a root element on a XAML page.</span></span>  
  
- <span data-ttu-id="d4710-111">Преимущество определения пользовательских классов в приложении состоит в том, что этот способ является относительно простым и сводит к минимуму проблемы развертывания и тестирования, возникающие при введении отдельных сборок за пределами главного исполняемого файла приложения.</span><span class="sxs-lookup"><span data-stu-id="d4710-111">The advantage of defining the custom classes in the application is that this technique is relatively lightweight and minimizes the deployment and testing issues encountered when you introduce separate assemblies beyond the main application executable.</span></span>  
  
- <span data-ttu-id="d4710-112">Независимо от того, определены ли пользовательские классы в одной или разных сборках, они должны быть распределены между пространством имен CLR и пространством имен XML, чтобы их можно было использовать в XAML в качестве элементов.</span><span class="sxs-lookup"><span data-stu-id="d4710-112">Whether defined in the same or different assembly, custom classes need to be mapped between CLR  namespace and XML  namespace in order to be used in XAML as elements.</span></span> <span data-ttu-id="d4710-113">См. раздел [Пространства имен XAML и сопоставление пространств имен для WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="d4710-113">See [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="Requirements_for_a_Custom_Class_as_a_XAML_Element"></a>   
## <a name="requirements-for-a-custom-class-as-a-xaml-element"></a><span data-ttu-id="d4710-114">Требования к пользовательскому классу как элементу XAML</span><span class="sxs-lookup"><span data-stu-id="d4710-114">Requirements for a Custom Class as a XAML Element</span></span>  
 <span data-ttu-id="d4710-115">Чтобы можно было создавать экземпляр класса в качестве объектного элемента, класс должен удовлетворять указанным ниже требованиям.</span><span class="sxs-lookup"><span data-stu-id="d4710-115">In order to be able to be instantiated as an object element, your class must meet the following requirements:</span></span>  
  
- <span data-ttu-id="d4710-116">Пользовательский класс должен быть открытым и должен поддерживать открытый конструктор по умолчанию (без параметров).</span><span class="sxs-lookup"><span data-stu-id="d4710-116">Your custom class must be public and support a default (parameterless) public constructor.</span></span> <span data-ttu-id="d4710-117">(Примечания о структурах см. в следующем разделе.)</span><span class="sxs-lookup"><span data-stu-id="d4710-117">(See following section for notes regarding structures.)</span></span>  
  
- <span data-ttu-id="d4710-118">Пользовательский класс не должен быть вложенным.</span><span class="sxs-lookup"><span data-stu-id="d4710-118">Your custom class must not be a nested class.</span></span> <span data-ttu-id="d4710-119">Вложенные классы и "точка" в их общем синтаксисе использования в среде CLR конфликтуют с другими функциями [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] и XAML, такими как присоединенные свойства.</span><span class="sxs-lookup"><span data-stu-id="d4710-119">Nested classes and the "dot" in their general CLR usage syntax interfere with other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and/or XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="d4710-120">В дополнение к разрешению синтаксиса объектных элементов определение объекта также разрешает синтаксис элемента свойства для всех других открытых свойств, которые принимают объект в качестве типа значения.</span><span class="sxs-lookup"><span data-stu-id="d4710-120">In addition to enabling object element syntax, your object definition also enables property element syntax for any other public properties that take that object as the value type.</span></span> <span data-ttu-id="d4710-121">Это происходит потому, что экземпляр объекта теперь может быть создан в качестве объектного элемента и может заполнить значение элемента свойства.</span><span class="sxs-lookup"><span data-stu-id="d4710-121">This is because the object can now be instantiated as an object element and can fill the property element value of such a property.</span></span>  
  
### <a name="structures"></a><span data-ttu-id="d4710-122">Структуры</span><span class="sxs-lookup"><span data-stu-id="d4710-122">Structures</span></span>  
 <span data-ttu-id="d4710-123">Структуры, определяемые в качестве пользовательских типов, всегда могут быть созданы в XAML в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] . Это обусловлено тем, что компиляторы CLR неявно создают конструктор без параметров для структуры, которая инициализирует все значения свойств значениями по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="d4710-123">Structures that you define as custom types are always able to be constructed in XAML  in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] .This is because the CLR compilers implicitly create a parameterless constructor for a structure that initializes all property values to their defaults.</span></span> <span data-ttu-id="d4710-124">В некоторых случаях поведение конструктора по умолчанию или использование объектных элементов для структуры является нежелательным.</span><span class="sxs-lookup"><span data-stu-id="d4710-124">In some cases, the default construction behavior and/or object element usage for a structure is not desirable.</span></span> <span data-ttu-id="d4710-125">Это возможно в тех случаях, когда структура используется для заполнения значений и функционирует в качестве объединения, в котором хранятся взаимоисключающие значения, и поэтому ни одному из свойств нельзя присвоить значение.</span><span class="sxs-lookup"><span data-stu-id="d4710-125">This might be because the structure is intended to fill values and function conceptually as a union, where the values contained might have mutually exclusive interpretations and thus none of its properties are settable.</span></span> <span data-ttu-id="d4710-126">Примером такой структуры является <xref:System.Windows.GridLength>. [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</span><span class="sxs-lookup"><span data-stu-id="d4710-126">A [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] example of such a structure is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="d4710-127">Как правило, в таких структурах необходимо реализовать преобразователь типов, чтобы значения можно было представить в виде атрибутов, используя преобразования строк для создания различных интерпретаций или режимов значений структуры.</span><span class="sxs-lookup"><span data-stu-id="d4710-127">Generally, such structures should implement a type converter such that the values can be expressed in attribute form, using string conventions that create the different interpretations or modes of the structure's values.</span></span> <span data-ttu-id="d4710-128">Структура должна также предоставлять аналогичное поведение для построения кода с помощью конструктора без параметров.</span><span class="sxs-lookup"><span data-stu-id="d4710-128">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>  
  
<a name="Requirements_for_Properties_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-properties-of-a-custom-class-as-xaml-attributes"></a><span data-ttu-id="d4710-129">Требования к свойствам пользовательского класса как атрибутам XAML</span><span class="sxs-lookup"><span data-stu-id="d4710-129">Requirements for Properties of a Custom Class as XAML Attributes</span></span>  
 <span data-ttu-id="d4710-130">Свойства должны ссылаться на тип по значению (например, на примитив) или использовать класс для типа, имеющего либо конструктор без параметров, либо специальный преобразователь типов, к которому может получить доступ обработчик XAML.</span><span class="sxs-lookup"><span data-stu-id="d4710-130">Properties must reference a by-value type (such as a primitive), or use a class for type that has either a parameterless constructor or a dedicated type converter that a XAML processor can access.</span></span> <span data-ttu-id="d4710-131">В реализации CLR XAML обработчики XAML либо находят такие конвертеры с помощью встроенной поддержки примитивов языка, либо посредством <xref:System.ComponentModel.TypeConverterAttribute> применения к типу или члену в определениях резервных типов.</span><span class="sxs-lookup"><span data-stu-id="d4710-131">In the CLR XAML implementation, XAML processors either find such converters through native support for language primitives, or through application of <xref:System.ComponentModel.TypeConverterAttribute> to a type or member in backing type definitions</span></span>  
  
 <span data-ttu-id="d4710-132">Помимо этого, свойство может ссылаться на абстрактный тип класса или интерфейс.</span><span class="sxs-lookup"><span data-stu-id="d4710-132">Alternatively, the property may reference an abstract class type, or an interface.</span></span> <span data-ttu-id="d4710-133">Для абстрактных классов или интерфейсов ожидаемый результат синтаксического анализа XAML заключается в том, что значение свойства должно быть заполнено практическими экземплярами класса, которые реализуют интерфейс, или экземплярами типов, которые являются производными от абстрактного класса.</span><span class="sxs-lookup"><span data-stu-id="d4710-133">For abstract classes or interfaces, the expectation for XAML parsing is that the property value must be filled with practical class instances that implement the interface, or instances of types that derive from the abstract class.</span></span>  
  
 <span data-ttu-id="d4710-134">Свойства могут объявляться в абстрактном классе, но могут быть заданы только в практических классах, производных от абстрактных классов.</span><span class="sxs-lookup"><span data-stu-id="d4710-134">Properties can be declared on an abstract class, but can only be set on practical classes that derive from the abstract class.</span></span> <span data-ttu-id="d4710-135">Это связано с тем, что для создания объектного элемента для класса вообще требуется открытый конструктор без параметров для класса.</span><span class="sxs-lookup"><span data-stu-id="d4710-135">This is because creating the object element for the class at all requires a public parameterless constructor on the class.</span></span>  
  
### <a name="typeconverter-enabled-attribute-syntax"></a><span data-ttu-id="d4710-136">Синтаксис атрибута с поддержкой TypeConverter</span><span class="sxs-lookup"><span data-stu-id="d4710-136">TypeConverter Enabled Attribute Syntax</span></span>  
 <span data-ttu-id="d4710-137">Если поддерживается выделенный преобразователь типов атрибутов на уровне класса, то применяемый тип преобразования включает синтаксис атрибута для любого свойства, для которого необходимо создать экземпляр этого типа.</span><span class="sxs-lookup"><span data-stu-id="d4710-137">If you provide a dedicated, attributed type converter at the class level, the applied type conversion enables attribute syntax for any property that needs to instantiate that type.</span></span> <span data-ttu-id="d4710-138">Преобразователь типов не включает использование объектного элемента типа; только наличие конструктора без параметров для этого типа активирует использование объектного элемента.</span><span class="sxs-lookup"><span data-stu-id="d4710-138">A type converter does not enable object element usage of the type; only the presence of a parameterless constructor for that type enables object element usage.</span></span> <span data-ttu-id="d4710-139">Таким образом, свойства, разрешенные преобразователем типов, обычно не используются в синтаксисе свойств, если только сам тип не поддерживает синтаксис объектных элементов.</span><span class="sxs-lookup"><span data-stu-id="d4710-139">Therefore, properties that are type-converter enabled are generally speaking not usable in property syntax, unless the type itself also supports object element syntax.</span></span> <span data-ttu-id="d4710-140">Исключением из этого является указание синтаксиса элемента свойства при наличии элемента свойства, содержащего строку.</span><span class="sxs-lookup"><span data-stu-id="d4710-140">The exception to this is that you can specify a property element syntax, but have the property element contain a string.</span></span> <span data-ttu-id="d4710-141">Это использование на самом деле эквивалентно использованию синтаксиса атрибутов, и такое использование не является распространенным, если нет необходимости в более надежной обработке пробелов в значении атрибута.</span><span class="sxs-lookup"><span data-stu-id="d4710-141">That usage is really essentially equivalent to an attribute syntax usage, and such a usage is not common unless there is a need for more robust white-space handling of the attribute value.</span></span> <span data-ttu-id="d4710-142">Например, ниже показано использование элемента свойства, который принимает строку, а использование атрибута эквивалентно.</span><span class="sxs-lookup"><span data-stu-id="d4710-142">For example, the following is a property element usage that takes a string, and the attribute usage equivalent:</span></span>  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe)]  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE2](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe2)]  
  
 <span data-ttu-id="d4710-143">Примеры свойств, в которых разрешен синтаксис атрибутов, но синтаксис элемента свойства, содержащего объектный элемент, запрещен посредством XAML — различные свойства, которые принимают <xref:System.Windows.Input.Cursor> тип.</span><span class="sxs-lookup"><span data-stu-id="d4710-143">Examples of properties where attribute syntax is allowed but property element syntax that contains an object element is disallowed through XAML are various properties that take the <xref:System.Windows.Input.Cursor> type.</span></span> <span data-ttu-id="d4710-144">Класс имеет выделенный преобразователь <xref:System.Windows.Input.CursorConverter>типов, но не предоставляет конструктор без параметров, поэтому <xref:System.Windows.FrameworkElement.Cursor%2A> свойство можно задать только с помощью синтаксиса атрибутов, даже если фактический <xref:System.Windows.Input.Cursor> тип является ссылочным типом. <xref:System.Windows.Input.Cursor></span><span class="sxs-lookup"><span data-stu-id="d4710-144">The <xref:System.Windows.Input.Cursor> class has a dedicated type converter <xref:System.Windows.Input.CursorConverter>, but does not expose a parameterless constructor, so the <xref:System.Windows.FrameworkElement.Cursor%2A> property can only be set through attribute syntax even though the actual <xref:System.Windows.Input.Cursor> type is a reference type.</span></span>  
  
### <a name="per-property-type-converters"></a><span data-ttu-id="d4710-145">Преобразователь типа каждого свойства</span><span class="sxs-lookup"><span data-stu-id="d4710-145">Per-Property Type Converters</span></span>  
 <span data-ttu-id="d4710-146">В качестве альтернативы само свойство может объявлять преобразователь типов на уровне свойств.</span><span class="sxs-lookup"><span data-stu-id="d4710-146">Alternatively, the property itself may declare a type converter at the property level.</span></span> <span data-ttu-id="d4710-147">Это позволяет «мини-язык», который создает экземпляры объектов типа встроенного свойства путем обработки входящих строковых значений атрибута в качестве входных данных для <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> операции на основе соответствующего типа.</span><span class="sxs-lookup"><span data-stu-id="d4710-147">This enables a "mini language" that instantiates objects of the type of the property inline, by processing incoming string values of the attribute as input for a <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> operation based on the appropriate type.</span></span> <span data-ttu-id="d4710-148">Обычно это делается для предоставления удобного метода доступа, а не как единственное средство для задания свойства в XAML.</span><span class="sxs-lookup"><span data-stu-id="d4710-148">Typically this is done to provide a convenience accessor, and not as the sole means to enable setting a property in XAML.</span></span> <span data-ttu-id="d4710-149">Однако можно также использовать преобразователи типов для атрибутов, где необходимо использовать существующие типы CLR, которые не предоставляют конструктор без параметров или преобразователь типов с атрибутами.</span><span class="sxs-lookup"><span data-stu-id="d4710-149">However, it is also possible to use type converters for attributes where you want to use existing CLR types that do not supply either a parameterless constructor or an attributed type converter.</span></span> <span data-ttu-id="d4710-150">Примерами из [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API являются определенные свойства, которые <xref:System.Globalization.CultureInfo> принимают тип.</span><span class="sxs-lookup"><span data-stu-id="d4710-150">Examples from the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API are certain properties that take the <xref:System.Globalization.CultureInfo> type.</span></span> <span data-ttu-id="d4710-151">В этом случае [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] использовал существующий тип платформы <xref:System.Globalization.CultureInfo> Microsoft .NET для улучшения совместимости и сценариев миграции, которые использовались в более ранних версиях <xref:System.Globalization.CultureInfo> платформ, но тип не поддерживал необходимую конструкторы или преобразование типа на уровне типа для использования в качестве значения свойства XAML напрямую.</span><span class="sxs-lookup"><span data-stu-id="d4710-151">In this case, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] used the existing Microsoft .NET Framework <xref:System.Globalization.CultureInfo> type to better address compatibility and migration scenarios that were used in earlier versions of frameworks, but the <xref:System.Globalization.CultureInfo> type did not support the necessary constructors or type-level type conversion to be usable as a XAML property value directly.</span></span>  
  
 <span data-ttu-id="d4710-152">При каждом предоставлении свойства, использующего XAML (особенно в том случае, если вы являетесь автором элемента управления), настоятельно рекомендуем резервировать это свойство с помощью свойства зависимости.</span><span class="sxs-lookup"><span data-stu-id="d4710-152">Whenever you expose a property that has a XAML usage, particularly if you are a control author, you should strongly consider backing that property with a dependency property.</span></span> <span data-ttu-id="d4710-153">Это особенно справедливо при использовании существующей [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] реализации обработчика XAML, так как вы можете повысить производительность с помощью <xref:System.Windows.DependencyProperty> резервного копирования.</span><span class="sxs-lookup"><span data-stu-id="d4710-153">This is particularly true if you use the existing [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] implementation of the XAML processor, because you can improve performance by using <xref:System.Windows.DependencyProperty> backing.</span></span> <span data-ttu-id="d4710-154">Свойство зависимости предоставит возможности системы свойств для данного свойства, которые пользователи ожидают от доступного в XAML свойства.</span><span class="sxs-lookup"><span data-stu-id="d4710-154">A dependency property will expose property system features for your property that users will come to expect for a XAML accessible property.</span></span> <span data-ttu-id="d4710-155">В число этих возможностей входят анимация, привязка данных и поддержка стилей.</span><span class="sxs-lookup"><span data-stu-id="d4710-155">This includes features such as animation, data binding, and style support.</span></span> <span data-ttu-id="d4710-156">Дополнительные сведения см. в разделах [Пользовательские свойства зависимостей](custom-dependency-properties.md) и [Загрузка кода XAML и свойства зависимостей](xaml-loading-and-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="d4710-156">For more information, see [Custom Dependency Properties](custom-dependency-properties.md) and [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>  
  
### <a name="writing-and-attributing-a-type-converter"></a><span data-ttu-id="d4710-157">Написание и установка атрибутов преобразователя типов</span><span class="sxs-lookup"><span data-stu-id="d4710-157">Writing and Attributing a Type Converter</span></span>  
 <span data-ttu-id="d4710-158">Иногда потребуется написать пользовательский <xref:System.ComponentModel.TypeConverter> производный класс, чтобы обеспечить преобразование типов для типа свойства.</span><span class="sxs-lookup"><span data-stu-id="d4710-158">You occasionally will need to write a custom <xref:System.ComponentModel.TypeConverter> derived class to provide type conversion for your property type.</span></span> <span data-ttu-id="d4710-159">Инструкции по наследованию от и созданию преобразователя типов, поддерживающего использование XAML, а также о применении <xref:System.ComponentModel.TypeConverterAttribute>, см. в разделе TypeConverters [and XAML](typeconverters-and-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="d4710-159">For instructions on how to derive from and create a type converter that can support XAML usages, and how to apply the <xref:System.ComponentModel.TypeConverterAttribute>, see [TypeConverters and XAML](typeconverters-and-xaml.md).</span></span>  
  
<a name="Requirements_for_Events_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-xaml-event-handler-attribute-syntax-on-events-of-a-custom-class"></a><span data-ttu-id="d4710-160">Требования к синтаксису атрибутов обработчиков событий XAML пользовательского класса</span><span class="sxs-lookup"><span data-stu-id="d4710-160">Requirements for XAML Event Handler Attribute Syntax on Events of a Custom Class</span></span>  
 <span data-ttu-id="d4710-161">Для использования в качестве события CLR событие должно быть предоставлено как открытое событие в классе, поддерживающем конструктор без параметров, или на абстрактном классе, где событие может быть получено в производных классах.</span><span class="sxs-lookup"><span data-stu-id="d4710-161">To be usable as a CLR event, the event must be exposed as a public event on a class that supports a parameterless constructor, or on an abstract class where the event can be accessed on derived classes.</span></span> <span data-ttu-id="d4710-162">Для удобного использования в качестве перенаправленного события в событии CLR должны быть реализованы `add` явные `remove` методы и, которые добавляют и удаляют обработчики для сигнатуры событий CLR и <xref:System.Windows.UIElement.AddHandler%2A> передают <xref:System.Windows.UIElement.RemoveHandler%2A> эти обработчики в и метод.</span><span class="sxs-lookup"><span data-stu-id="d4710-162">In order to be used conveniently as a routed event, your CLR event should implement explicit `add` and `remove` methods, which add and remove handlers for the CLR event signature and forward those handlers to the <xref:System.Windows.UIElement.AddHandler%2A> and <xref:System.Windows.UIElement.RemoveHandler%2A> methods.</span></span> <span data-ttu-id="d4710-163">Эти методы добавляют или удаляют обработчики из хранилища обработчиков перенаправленных событий экземпляра, к которому присоединено событие.</span><span class="sxs-lookup"><span data-stu-id="d4710-163">These methods add or remove the handlers to the routed event handler store on the instance that the event is attached to.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d4710-164">Можно регистрировать обработчики напрямую для перенаправленных событий с помощью <xref:System.Windows.UIElement.AddHandler%2A>, а также намеренно не определять событие CLR, которое предоставляет перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="d4710-164">It is possible to register handlers directly for routed events using <xref:System.Windows.UIElement.AddHandler%2A>, and to deliberately not define a CLR event that exposes the routed event.</span></span> <span data-ttu-id="d4710-165">Обычно это не рекомендуется, так как событие не включит синтаксис атрибута XAML для подключения обработчиков и результирующий класс предложит менее прозрачное представление XAML возможностей этого типа.</span><span class="sxs-lookup"><span data-stu-id="d4710-165">This is not generally recommended because the event will not enable XAML attribute syntax for attaching handlers, and your resulting class will offer a less transparent XAML view of that type's capabilities.</span></span>  
  
<a name="Collection_Properties"></a>   
## <a name="writing-collection-properties"></a><span data-ttu-id="d4710-166">Написание свойств коллекции</span><span class="sxs-lookup"><span data-stu-id="d4710-166">Writing Collection Properties</span></span>  
 <span data-ttu-id="d4710-167">Свойства, принимающие тип коллекции, имеют синтаксис XAML, который позволяет определять объекты, добавляемые в коллекцию.</span><span class="sxs-lookup"><span data-stu-id="d4710-167">Properties that take a collection type have a XAML syntax that enables you to specify objects that are added to the collection.</span></span> <span data-ttu-id="d4710-168">Этот синтаксис имеет две важные функции.</span><span class="sxs-lookup"><span data-stu-id="d4710-168">This syntax has two notable features.</span></span>  
  
- <span data-ttu-id="d4710-169">Объект, являющийся объектом коллекции, необязательно определять в синтаксисе объектного элемента.</span><span class="sxs-lookup"><span data-stu-id="d4710-169">The object that is the collection object does not need to be specified in object element syntax.</span></span> <span data-ttu-id="d4710-170">Присутствие этого типа коллекции подразумевается всякий раз, когда в XAML указывается свойство, принимающее тип коллекции.</span><span class="sxs-lookup"><span data-stu-id="d4710-170">The presence of that collection type is implicit whenever you specify a property in XAML that takes a collection type.</span></span>  
  
- <span data-ttu-id="d4710-171">Дочерние элементы свойства коллекции в разметке обрабатываются для того, чтобы они стали элементами коллекции.</span><span class="sxs-lookup"><span data-stu-id="d4710-171">Child elements of the collection property in markup are processed to become members of the collection.</span></span> <span data-ttu-id="d4710-172">Обычно доступ кода к элементам коллекции осуществляется через методы списка или словаря, такие как `Add`, или через индексатор.</span><span class="sxs-lookup"><span data-stu-id="d4710-172">Ordinarily, the code access to the members of a collection is performed through list/dictionary methods such as `Add`, or through an indexer.</span></span> <span data-ttu-id="d4710-173">Но синтаксис XAML не поддерживает методы или индексаторы (исключение: XAML 2009 может поддерживать методы, но использование XAML 2009 позволяет ограничивать возможные варианты использования WPF. см. раздел [возможности языка XAML 2009](../../xaml-services/xaml-2009-language-features.md).</span><span class="sxs-lookup"><span data-stu-id="d4710-173">But XAML syntax does not support methods or indexers (exception: XAML 2009 can support methods, but using XAML 2009 restricts the possible WPF usages; see [XAML 2009 Language Features](../../xaml-services/xaml-2009-language-features.md)).</span></span> <span data-ttu-id="d4710-174">Коллекции, очевидно, являются очень общим требованием для построения дерева элементов, и требуется какой-нибудь способ заполнения этих коллекций в декларативном XAML.</span><span class="sxs-lookup"><span data-stu-id="d4710-174">Collections are obviously a very common requirement for building a tree of elements, and you need some way to populate these collections in declarative XAML.</span></span> <span data-ttu-id="d4710-175">Таким образом, дочерние элементы свойства коллекции обрабатываются путем добавления их в коллекцию, которая является значением типа свойства коллекции.</span><span class="sxs-lookup"><span data-stu-id="d4710-175">Therefore, child elements of a collection property are processed by adding them to the collection that is the collection property type value.</span></span>  
  
 <span data-ttu-id="d4710-176">Реализация служб XAML в .NET Framework и, следовательно, процессор XAML WPF используют указанное ниже определение того, что составляет свойство коллекции.</span><span class="sxs-lookup"><span data-stu-id="d4710-176">The .NET Framework XAML Services implementation and thus the WPF XAML processor uses the following definition for what constitutes a collection property.</span></span> <span data-ttu-id="d4710-177">Тип свойства должен реализовывать один из следующих интерфейсов:</span><span class="sxs-lookup"><span data-stu-id="d4710-177">The property type of the property must implement one of the following:</span></span>  
  
- <span data-ttu-id="d4710-178">Реализует <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="d4710-178">Implements <xref:System.Collections.IList>.</span></span>  
  
- <span data-ttu-id="d4710-179">Реализует <xref:System.Collections.IDictionary> или универсальный эквивалент (<xref:System.Collections.Generic.IDictionary%602>).</span><span class="sxs-lookup"><span data-stu-id="d4710-179">Implements <xref:System.Collections.IDictionary> or the generic equivalent (<xref:System.Collections.Generic.IDictionary%602>).</span></span>  
  
- <span data-ttu-id="d4710-180">Является производным <xref:System.Array> от (Дополнительные сведения о массивах в XAML см. в разделе [расширение разметки x:Array](../../xaml-services/x-array-markup-extension.md).)</span><span class="sxs-lookup"><span data-stu-id="d4710-180">Derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../xaml-services/x-array-markup-extension.md).)</span></span>  
  
- <span data-ttu-id="d4710-181">Реализует <xref:System.Windows.Markup.IAddChild> (интерфейс, определенный параметром [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span><span class="sxs-lookup"><span data-stu-id="d4710-181">Implements <xref:System.Windows.Markup.IAddChild> (an interface defined by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span></span>  
  
 <span data-ttu-id="d4710-182">Каждый из этих типов в среде CLR имеет метод `Add`, который используется процессором XAML для добавления элементов в базовую коллекцию при создании графа объекта.</span><span class="sxs-lookup"><span data-stu-id="d4710-182">Each of these types in CLR has an `Add` method, which is used by the XAML processor to add items to the underlying collection when creating the object graph.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d4710-183">Универсальный `List` интерфейс и `Dictionary` интерфейсы (<xref:System.Collections.Generic.IList%601> и <xref:System.Collections.Generic.IDictionary%602>) не поддерживаются для обнаружения [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] коллекции обработчиком XAML.</span><span class="sxs-lookup"><span data-stu-id="d4710-183">The generic `List` and `Dictionary` interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processor.</span></span> <span data-ttu-id="d4710-184">Однако <xref:System.Collections.Generic.List%601> класс можно использовать в качестве базового класса, поскольку он реализуется <xref:System.Collections.IList> напрямую или <xref:System.Collections.Generic.Dictionary%602> как базовый класс, поскольку он реализуется <xref:System.Collections.IDictionary> напрямую.</span><span class="sxs-lookup"><span data-stu-id="d4710-184">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="d4710-185">При объявлении свойства, принимающего коллекцию, будьте осторожны при инициализации значения свойства в новых экземплярах типа.</span><span class="sxs-lookup"><span data-stu-id="d4710-185">When you declare a property that takes a collection, be cautious about how that property value is initialized in new instances of the type.</span></span> <span data-ttu-id="d4710-186">Если свойство не реализуется как свойство зависимости, то со свойством достаточно использовать резервное поле, вызывающее конструктор типа коллекции.</span><span class="sxs-lookup"><span data-stu-id="d4710-186">If you are not implementing the property as a dependency property, then having the property use a backing field that calls the collection type constructor is adequate.</span></span> <span data-ttu-id="d4710-187">Если свойство является свойством зависимости, то может потребоваться инициализация свойства коллекции как части конструктора типа по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="d4710-187">If your property is a dependency property, then you may need to initialize the collection property as part of the default type constructor.</span></span> <span data-ttu-id="d4710-188">Это обусловлено тем, что свойство зависимости принимает значение по умолчанию из метаданных и обычно нежелательно, чтобы начальное значение свойства коллекции было статической общей коллекцией.</span><span class="sxs-lookup"><span data-stu-id="d4710-188">This is because a dependency property takes its default value from metadata, and you typically do not want the initial value of a collection property to be a static, shared collection.</span></span> <span data-ttu-id="d4710-189">Экземпляр коллекции должен иметься для каждого экземпляра содержащего типа.</span><span class="sxs-lookup"><span data-stu-id="d4710-189">There should be a collection instance per each containing type instance.</span></span> <span data-ttu-id="d4710-190">Дополнительные сведения см. в разделе [Пользовательские свойства зависимостей](custom-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="d4710-190">For more information, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="d4710-191">Вы можете реализовать пользовательский тип коллекции для свойства коллекции.</span><span class="sxs-lookup"><span data-stu-id="d4710-191">You can implement a custom collection type for your collection property.</span></span> <span data-ttu-id="d4710-192">Из-за неявной обработки свойства коллекции пользовательскому типу коллекции не нужно предоставлять конструктор без параметров, чтобы его можно было использовать в XAML неявно.</span><span class="sxs-lookup"><span data-stu-id="d4710-192">Because of implicit collection property treatment, the custom collection type does not need to provide a parameterless constructor in order to be used in XAML implicitly.</span></span> <span data-ttu-id="d4710-193">Однако при необходимости можно предоставить конструктор без параметров для типа коллекции.</span><span class="sxs-lookup"><span data-stu-id="d4710-193">However, you can optionally provide a parameterless constructor for the collection type.</span></span> <span data-ttu-id="d4710-194">Это может оказаться целесообразным.</span><span class="sxs-lookup"><span data-stu-id="d4710-194">This can be a worthwhile practice.</span></span> <span data-ttu-id="d4710-195">Если не предоставить конструктор без параметров, вы не сможете явно объявить коллекцию как объектный элемент.</span><span class="sxs-lookup"><span data-stu-id="d4710-195">Unless you do provide a parameterless constructor, you cannot explicitly declare the collection as an object element.</span></span> <span data-ttu-id="d4710-196">Некоторые разработчики разметки могут предпочесть просмотр явной коллекции в качестве стиля разметки.</span><span class="sxs-lookup"><span data-stu-id="d4710-196">Some markup authors might prefer to see the explicit collection as a matter of markup style.</span></span> <span data-ttu-id="d4710-197">Кроме того, конструктор без параметров может упростить требования к инициализации при создании новых объектов, использующих тип коллекции в качестве значения свойства.</span><span class="sxs-lookup"><span data-stu-id="d4710-197">Also, a parameterless constructor can simplify the initialization requirements when you create new objects that use your collection type as a property value.</span></span>  
  
<a name="XAMLCONtent"></a>   
## <a name="declaring-xaml-content-properties"></a><span data-ttu-id="d4710-198">Объявление свойств содержимого XAML</span><span class="sxs-lookup"><span data-stu-id="d4710-198">Declaring XAML Content Properties</span></span>  
 <span data-ttu-id="d4710-199">Язык XAML определяет концепцию свойства содержимого [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="d4710-199">The XAML language defines the concept of a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] content property.</span></span> <span data-ttu-id="d4710-200">Каждый класс, используемый в синтаксисе объекта, может иметь только одно свойство содержимого XAML.</span><span class="sxs-lookup"><span data-stu-id="d4710-200">Each class that is usable in object syntax can have exactly one XAML content property.</span></span> <span data-ttu-id="d4710-201">Чтобы объявить свойство в качестве свойства содержимого XAML для класса, примените в <xref:System.Windows.Markup.ContentPropertyAttribute> определении класса.</span><span class="sxs-lookup"><span data-stu-id="d4710-201">To declare a property to be the XAML content property for your class, apply the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of the class definition.</span></span> <span data-ttu-id="d4710-202">Укажите имя предполагаемого свойства <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> содержимого XAML в атрибуте.</span><span class="sxs-lookup"><span data-stu-id="d4710-202">Specify the name of the intended XAML content property as the <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> in the attribute.</span></span> <span data-ttu-id="d4710-203">Свойство указывается как строка по имени, а не как конструкция отражения, например <xref:System.Reflection.PropertyInfo>.</span><span class="sxs-lookup"><span data-stu-id="d4710-203">The property is specified as a string by name, not as a reflection construct such as <xref:System.Reflection.PropertyInfo>.</span></span>  
  
 <span data-ttu-id="d4710-204">Можно определить свойство коллекции как свойство содержимого XAML.</span><span class="sxs-lookup"><span data-stu-id="d4710-204">You can specify a collection property to be the XAML content property.</span></span> <span data-ttu-id="d4710-205">Это отражается на использовании этого свойства, так как объектный элемент может иметь один или несколько дочерних элементов без промежуточных объектных элементов коллекции или тегов элементов свойства.</span><span class="sxs-lookup"><span data-stu-id="d4710-205">This results in a usage for that property whereby the object element can have one or more child elements, without any intervening collection object elements or property element tags.</span></span> <span data-ttu-id="d4710-206">Эти элементы затем рассматриваются как значение для свойства содержимого XAML и добавляются к резервному экземпляру коллекции.</span><span class="sxs-lookup"><span data-stu-id="d4710-206">These elements are then treated as the value for the XAML content property and added to the backing collection instance.</span></span>  
  
 <span data-ttu-id="d4710-207">Некоторые существующие свойства содержимого XAML используют тип свойства `Object`.</span><span class="sxs-lookup"><span data-stu-id="d4710-207">Some existing XAML content properties use the property type of `Object`.</span></span> <span data-ttu-id="d4710-208">Это включает свойство содержимого XAML, которое может принимать примитивные значения, такие <xref:System.String> как, а также принимает одно значение ссылочного объекта.</span><span class="sxs-lookup"><span data-stu-id="d4710-208">This enables a XAML content property that can take primitive values such as a <xref:System.String> as well as taking a single reference object value.</span></span> <span data-ttu-id="d4710-209">Если следовать этой модели, то тип будет отвечать как за определение типа, так и за обработку возможных типов.</span><span class="sxs-lookup"><span data-stu-id="d4710-209">If you follow this model, your type is responsible for type determination as well as the handling of possible types.</span></span> <span data-ttu-id="d4710-210">Типичная причина для <xref:System.Object> типа содержимого — поддержка простого способа добавления содержимого объекта в виде строки (которая получает обработку представления по умолчанию) или расширенного способа добавления содержимого объекта, которое указывает представление, отличное от представления по умолчанию или Дополнительные данные.</span><span class="sxs-lookup"><span data-stu-id="d4710-210">The typical reason for an <xref:System.Object> content type is to support both a simple means of adding object content as a string (which receives a default presentation treatment), or an advanced means of adding object content that specifies a non-default presentation or additional data.</span></span>  
  
<a name="Serializing"></a>   
## <a name="serializing-xaml"></a><span data-ttu-id="d4710-211">Сериализация XAML</span><span class="sxs-lookup"><span data-stu-id="d4710-211">Serializing XAML</span></span>  
 <span data-ttu-id="d4710-212">В некоторых сценариях (например, если вы являетесь автором элемента управления) следует убедиться в том, что любое представление объекта, которое может быть создано в XAML, также может быть сериализовано обратно в эквивалентную разметку XAML.</span><span class="sxs-lookup"><span data-stu-id="d4710-212">For certain scenarios, such as if you are a control author, you may also want to assure that any object representation that can be instantiated in XAML can also be serialized back to equivalent XAML markup.</span></span> <span data-ttu-id="d4710-213">Требования к сериализации не описываются в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="d4710-213">Serialization requirements are not described in this topic.</span></span> <span data-ttu-id="d4710-214">См. разделы [Общие сведения о разработке элементов управления](../controls/control-authoring-overview.md) и [Дерево элементов и сериализация](element-tree-and-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="d4710-214">See [Control Authoring Overview](../controls/control-authoring-overview.md) and [Element Tree and Serialization](element-tree-and-serialization.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d4710-215">См. также</span><span class="sxs-lookup"><span data-stu-id="d4710-215">See also</span></span>

- [<span data-ttu-id="d4710-216">Общие сведения о языке XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="d4710-216">XAML Overview (WPF)</span></span>](xaml-overview-wpf.md)
- [<span data-ttu-id="d4710-217">Пользовательские свойства зависимостей</span><span class="sxs-lookup"><span data-stu-id="d4710-217">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="d4710-218">Общие сведения о разработке элементов управления</span><span class="sxs-lookup"><span data-stu-id="d4710-218">Control Authoring Overview</span></span>](../controls/control-authoring-overview.md)
- [<span data-ttu-id="d4710-219">Общие сведения о базовых элементах</span><span class="sxs-lookup"><span data-stu-id="d4710-219">Base Elements Overview</span></span>](base-elements-overview.md)
- [<span data-ttu-id="d4710-220">Загрузка кода XAML и свойства зависимостей</span><span class="sxs-lookup"><span data-stu-id="d4710-220">XAML Loading and Dependency Properties</span></span>](xaml-loading-and-dependency-properties.md)
