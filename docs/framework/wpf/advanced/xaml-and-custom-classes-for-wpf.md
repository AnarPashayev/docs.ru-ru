---
title: XAML и пользовательские классы
ms.date: 03/30/2017
helpviewer_keywords:
- custom classes in XAML [WPF]
- XAML [WPF], custom classes
- classes [WPF], custom classes in XAML
ms.assetid: e7313137-581e-4a64-8453-d44e15a6164a
ms.openlocfilehash: 4cd0ba7fa03d2578f4477c3ccf53188fbbea2dbd
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79186262"
---
# <a name="xaml-and-custom-classes-for-wpf"></a>Код XAML и пользовательские классы для WPF
XAML как реализованный в общих языковых системах времени выполнения (CLR) поддерживает возможность определения пользовательского класса или структуры на любом общем языке выполнения языка (CLR), а затем получить доступ к этому классу с помощью разметки XAML. В одном файле разметки можно использовать сочетание определенных в [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] типов и пользовательских типов, обычно сопоставляя пользовательские типы с префиксом пространства имен XAML. В этом разделе обсуждаются требования, которым должен соответствовать пользовательский класс, чтобы его можно было использовать в качестве элемента XAML.  

<a name="Custom_Classes_in_Applications_vs__in_Assemblies"></a>
## <a name="custom-classes-in-applications-or-assemblies"></a>Пользовательские классы в приложениях или сборках  
 Пользовательские классы, используемые в XAML, можно определить двумя способами: в коде программной части или другом коде, который создает основное приложение [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], или как класс в отдельной сборке, например как исполняемый файл или библиотеку DLL, используемые в качестве библиотеки классов. Каждый из этих подходов имеет определенные преимущества и недостатки.  
  
- Преимуществом создания библиотеки классов является то, что все подобные пользовательские классы могут совместно использоваться несколькими различными приложениями. Отдельная библиотека также облегчает управление версиями приложений и упрощает создание класса, который предполагается использовать в качестве корневого элемента на странице XAML.  
  
- Преимущество определения пользовательских классов в приложении состоит в том, что этот способ является относительно простым и сводит к минимуму проблемы развертывания и тестирования, возникающие при введении отдельных сборок за пределами главного исполняемого файла приложения.  
  
- Независимо от того, определены ли пользовательские классы в одной или разных сборках, они должны быть распределены между пространством имен CLR и пространством имен XML, чтобы их можно было использовать в XAML в качестве элементов. См. раздел [Пространства имен XAML и сопоставление пространств имен для WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).  
  
<a name="Requirements_for_a_Custom_Class_as_a_XAML_Element"></a>
## <a name="requirements-for-a-custom-class-as-a-xaml-element"></a>Требования к пользовательскому классу как элементу XAML  
 Чтобы можно было создавать экземпляр класса в качестве объектного элемента, класс должен удовлетворять указанным ниже требованиям.  
  
- Пользовательский класс должен быть открытым и должен поддерживать открытый конструктор по умолчанию (без параметров). (Примечания о структурах см. в следующем разделе.)  
  
- Пользовательский класс не должен быть вложенным. Вложенные классы и "точка" в их общем синтаксисе использования в среде CLR конфликтуют с другими функциями [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] и XAML, такими как присоединенные свойства.  
  
 В дополнение к разрешению синтаксиса объектных элементов определение объекта также разрешает синтаксис элемента свойства для всех других открытых свойств, которые принимают объект в качестве типа значения. Это происходит потому, что экземпляр объекта теперь может быть создан в качестве объектного элемента и может заполнить значение элемента свойства.  
  
### <a name="structures"></a>Структуры  
 Структуры, которые вы определяете как пользовательские типы, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] всегда могут быть построены в XAML в . Это происходит потому, что компиляторы CLR неявно создают беспараметрыный конструктор для структуры, которая инициализирует все значения свойств для своих по умолчанию. В некоторых случаях поведение конструктора по умолчанию или использование объектных элементов для структуры является нежелательным. Это возможно в тех случаях, когда структура используется для заполнения значений и функционирует в качестве объединения, в котором хранятся взаимоисключающие значения, и поэтому ни одному из свойств нельзя присвоить значение. Примером [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] такой структуры <xref:System.Windows.GridLength>является . Как правило, в таких структурах необходимо реализовать преобразователь типов, чтобы значения можно было представить в виде атрибутов, используя преобразования строк для создания различных интерпретаций или режимов значений структуры. Структура должна также подвергать аналогичное поведение для построения кода через непараметрбезный конструктор.  
  
<a name="Requirements_for_Properties_of_a_Custom_Class_as_XAML"></a>
## <a name="requirements-for-properties-of-a-custom-class-as-xaml-attributes"></a>Требования к свойствам пользовательского класса как атрибутам XAML  
 Свойства должны ссылаться на повысь-тип (например, примитивный), или использовать класс для типа, который имеет либо безпаралистов конструктора или специальный преобразователь типа, к которым может получить доступ процессор XAML. В реализации CLR XAML процессоры XAML либо находят такие преобразователи <xref:System.ComponentModel.TypeConverterAttribute> через родную поддержку примитивов языка, либо применяя к типу или участнику в определениях резервного типа  
  
 Помимо этого, свойство может ссылаться на абстрактный тип класса или интерфейс. Для абстрактных классов или интерфейсов ожидаемый результат синтаксического анализа XAML заключается в том, что значение свойства должно быть заполнено практическими экземплярами класса, которые реализуют интерфейс, или экземплярами типов, которые являются производными от абстрактного класса.  
  
 Свойства могут объявляться в абстрактном классе, но могут быть заданы только в практических классах, производных от абстрактных классов. Это связано с тем, что для создания элемента объекта для класса вообще требуется непосильным для нее конструктор в классе.  
  
### <a name="typeconverter-enabled-attribute-syntax"></a>Синтаксис атрибута с поддержкой TypeConverter  
 Если поддерживается выделенный преобразователь типов атрибутов на уровне класса, то применяемый тип преобразования включает синтаксис атрибута для любого свойства, для которого необходимо создать экземпляр этого типа. Преобразователь типа не позволяет использовать элемент объекта типа; только наличие беспараметрыного конструктора для этого типа позволяет использовать элемент объекта. Таким образом, свойства, разрешенные преобразователем типов, обычно не используются в синтаксисе свойств, если только сам тип не поддерживает синтаксис объектных элементов. Исключением из этого является указание синтаксиса элемента свойства при наличии элемента свойства, содержащего строку. Это использование действительно существенно эквивалентно использованию синтаксиса атрибутов, и такое использование не является обычным явлением, если нет необходимости в более надежной обработке значения атрибута с белым пространством. Например, ниже показано использование элемента свойства, который принимает строку, а использование атрибута эквивалентно.  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe)]  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE2](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe2)]  
  
 Примеры свойств, где синтаксис атрибута разрешен, но синтаксис элемента свойства, содержащего <xref:System.Windows.Input.Cursor> элемент объекта, запрещен через XAML, представляют собой различные свойства, которые принимают тип. Класс <xref:System.Windows.Input.Cursor> имеет специальный преобразователь <xref:System.Windows.Input.CursorConverter>типа, но не предоставляет <xref:System.Windows.FrameworkElement.Cursor%2A> беспараметрыный конструктор, поэтому свойство <xref:System.Windows.Input.Cursor> может быть установлено только через синтаксис атрибута, даже если фактический тип является эталонным типом.  
  
### <a name="per-property-type-converters"></a>Преобразователь типа каждого свойства  
 В качестве альтернативы само свойство может объявлять преобразователь типов на уровне свойств. Это позволяет "мини-язык", который мгновенно объекты типа свойства входящие, путем обработки входящих значений <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> строки атрибута в качестве ввода для операции на основе соответствующего типа. Обычно это делается для предоставления удобного метода доступа, а не как единственное средство для задания свойства в XAML. Тем не менее, можно также использовать преобразователи типа для атрибутов, где вы хотите использовать существующие типы CLR, которые не поставляют ни без параметра конструктора, ни приписываемого преобразователя типа. Примерами [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API являются определенные <xref:System.Globalization.CultureInfo> свойства, которые принимают тип. В этом [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] случае использовалсуществующий тип <xref:System.Globalization.CultureInfo> рамочного microsoft .NET для более эффективного решения сценариев <xref:System.Globalization.CultureInfo> совместимости и миграции, которые использовались в более ранних версиях фректов, но тип не поддерживал необходимые конструкторы или конверсию типа типа, чтобы быть пригодным для использования в качестве значения свойства XAML напрямую.  
  
 При каждом предоставлении свойства, использующего XAML (особенно в том случае, если вы являетесь автором элемента управления), настоятельно рекомендуем резервировать это свойство с помощью свойства зависимости. Это особенно верно, если [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] вы используете существующую реализацию процессора XAML, потому что вы можете улучшить производительность с помощью <xref:System.Windows.DependencyProperty> поддержки. Свойство зависимости предоставит возможности системы свойств для данного свойства, которые пользователи ожидают от доступного в XAML свойства. В число этих возможностей входят анимация, привязка данных и поддержка стилей. Дополнительные сведения см. в разделах [Пользовательские свойства зависимостей](custom-dependency-properties.md) и [Загрузка кода XAML и свойства зависимостей](xaml-loading-and-dependency-properties.md).  
  
### <a name="writing-and-attributing-a-type-converter"></a>Написание и установка атрибутов преобразователя типов  
 Иногда вам нужно будет <xref:System.ComponentModel.TypeConverter> написать пользовательский класс, чтобы обеспечить преобразование типа для вашего типа свойства. Для получения инструкций о том, как получить и создать преобразователь типа, <xref:System.ComponentModel.TypeConverterAttribute>который может поддерживать xAML обычаи, и как применять , см. [TypeConverters и XAML](typeconverters-and-xaml.md).  
  
<a name="Requirements_for_Events_of_a_Custom_Class_as_XAML"></a>
## <a name="requirements-for-xaml-event-handler-attribute-syntax-on-events-of-a-custom-class"></a>Требования к синтаксису атрибутов обработчиков событий XAML пользовательского класса  
 Чтобы быть пригодным для работы в качестве события CLR, событие должно быть выставлено как публичное событие на классе, который поддерживает беспараметрыный конструктор, или на абстрактном классе, где событие может быть доступно на производных классах. Для удобного использования в качестве маршрутного события событие CLR `add` `remove` должно реализовать явные и методы, которые добавляют и удаляют обработчики для подписи события CLR и направляют эти обработчики в <xref:System.Windows.UIElement.AddHandler%2A> методы. <xref:System.Windows.UIElement.RemoveHandler%2A> Эти методы добавляют или удаляют обработчики из хранилища обработчиков перенаправленных событий экземпляра, к которому присоединено событие.  
  
> [!NOTE]
> Можно регистрировать обработчиков непосредственно для <xref:System.Windows.UIElement.AddHandler%2A>маршрутных событий с помощью, и намеренно не определить событие CLR, которое разоблачает маршрутизируемое событие. Обычно это не рекомендуется, так как событие не включит синтаксис атрибута XAML для подключения обработчиков и результирующий класс предложит менее прозрачное представление XAML возможностей этого типа.  
  
<a name="Collection_Properties"></a>
## <a name="writing-collection-properties"></a>Написание свойств коллекции  
 Свойства, принимающие тип коллекции, имеют синтаксис XAML, который позволяет определять объекты, добавляемые в коллекцию. Этот синтаксис имеет две важные функции.  
  
- Объект, являющийся объектом коллекции, необязательно определять в синтаксисе объектного элемента. Присутствие этого типа коллекции подразумевается всякий раз, когда в XAML указывается свойство, принимающее тип коллекции.  
  
- Дочерние элементы свойства коллекции в разметке обрабатываются для того, чтобы они стали элементами коллекции. Обычно доступ кода к элементам коллекции осуществляется через методы списка или словаря, такие как `Add`, или через индексатор. Но синтаксис XAML не поддерживает методы или индексаторы. (Исключением является версия XAML 2009, которая поддерживает методы, но ее применение ограничивает возможные способы использования WPF. См. раздел [Возможности языка XAML 2009](../../../desktop-wpf/xaml-services/xaml-2009-language-features.md).) Коллекции, очевидно, являются очень общим требованием для построения дерева элементов, и требуется какой-нибудь способ заполнения этих коллекций в декларативном XAML. Таким образом, дочерние элементы свойства коллекции обрабатываются путем добавления их в коллекцию, которая является значением типа свойства коллекции.  
  
 Реализация служб XAML в .NET Framework и, следовательно, процессор XAML WPF используют указанное ниже определение того, что составляет свойство коллекции. Тип свойства должен реализовывать один из следующих интерфейсов:  
  
- Реализовывать объект <xref:System.Collections.IList>.  
  
- Реализации <xref:System.Collections.IDictionary> или общий<xref:System.Collections.Generic.IDictionary%602>эквивалент ( ).  
  
- Полученные <xref:System.Array> данные (для получения дополнительной информации о массивах в XAML, см. [x:Array Markup Extension.)](../../../desktop-wpf/xaml-services/xarray-markup-extension.md)  
  
- Реализует <xref:System.Windows.Markup.IAddChild> (интерфейс, определяемый). [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]  
  
 Каждый из этих типов в среде CLR имеет метод `Add`, который используется процессором XAML для добавления элементов в базовую коллекцию при создании графа объекта.  
  
> [!NOTE]
> Общие `List` и `Dictionary` интерфейсы<xref:System.Collections.Generic.IList%601> <xref:System.Collections.Generic.IDictionary%602>(и ) не поддерживаются [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] для обнаружения сбора процессором XAML. Тем не менее, <xref:System.Collections.Generic.List%601> вы можете использовать класс в <xref:System.Collections.IList> качестве <xref:System.Collections.Generic.Dictionary%602> базового класса, потому <xref:System.Collections.IDictionary> что он реализует сятворный напрямую или в качестве базового класса, потому что он реализуется напрямую.  
  
 При объявлении свойства, принимающего коллекцию, будьте осторожны при инициализации значения свойства в новых экземплярах типа. Если свойство не реализуется как свойство зависимости, то со свойством достаточно использовать резервное поле, вызывающее конструктор типа коллекции. Если свойство является свойством зависимости, то может потребоваться инициализация свойства коллекции как части конструктора типа по умолчанию. Это обусловлено тем, что свойство зависимости принимает значение по умолчанию из метаданных и обычно нежелательно, чтобы начальное значение свойства коллекции было статической общей коллекцией. Экземпляр коллекции должен иметься для каждого экземпляра содержащего типа. Дополнительные сведения см. в разделе [Пользовательские свойства зависимостей](custom-dependency-properties.md).  
  
 Вы можете реализовать пользовательский тип коллекции для свойства коллекции. Из-за неявной обработки свойств коллекции тип пользовательского сбора не должен предоставлять конструктор без параметров для того, чтобы использоваться в XAML неявно. Тем не менее, можно дополнительно предоставить безпараметр конструктор для типа коллекции. Это может оказаться целесообразным. Если вы не предоставите конструктор без параметров, вы не можете прямо объявить коллекцию элементом объекта. Некоторые разработчики разметки могут предпочесть просмотр явной коллекции в качестве стиля разметки. Кроме того, без параметров конструктор может упростить требования к инициализации при создании новых объектов, которые используют тип коллекции в качестве значения свойства.  
  
<a name="XAMLCONtent"></a>
## <a name="declaring-xaml-content-properties"></a>Объявление свойств содержимого XAML  
 Язык XAML определяет концепцию свойства содержимого [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]. Каждый класс, используемый в синтаксисе объекта, может иметь только одно свойство содержимого XAML. Чтобы объявить свойство свойством содержания XAML <xref:System.Windows.Markup.ContentPropertyAttribute> для вашего класса, примените его как часть определения класса. Укажите в атрибуте имя предполагаемого <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> свойства содержимого XAML. Свойство указывается как строка по имени, а <xref:System.Reflection.PropertyInfo>не как конструкция отражения, такие как .  
  
 Можно определить свойство коллекции как свойство содержимого XAML. Это отражается на использовании этого свойства, так как объектный элемент может иметь один или несколько дочерних элементов без промежуточных объектных элементов коллекции или тегов элементов свойства. Эти элементы затем рассматриваются как значение для свойства содержимого XAML и добавляются к резервному экземпляру коллекции.  
  
 Некоторые существующие свойства содержимого XAML используют тип свойства `Object`. Это позволяет свойство содержимого XAML, которое <xref:System.String> может принимать примитивные значения, такие как, а также с одним значением эталонного объекта. Если следовать этой модели, то тип будет отвечать как за определение типа, так и за обработку возможных типов. Типичная причина <xref:System.Object> для типа содержимого заключается в поддержке как простого средства добавления содержимого объекта в строку (которая получает обработку презентации по умолчанию), так и передовые средства добавления содержимого объекта, которое определяет непо умолчанию презентацию, так и дополнительные данные.  
  
<a name="Serializing"></a>
## <a name="serializing-xaml"></a>Сериализация XAML  
 В некоторых сценариях (например, если вы являетесь автором элемента управления) следует убедиться в том, что любое представление объекта, которое может быть создано в XAML, также может быть сериализовано обратно в эквивалентную разметку XAML. Требования к сериализации не описываются в этом разделе. См. разделы [Общие сведения о разработке элементов управления](../controls/control-authoring-overview.md) и [Дерево элементов и сериализация](element-tree-and-serialization.md).  
  
## <a name="see-also"></a>См. также раздел

- [Обзор XAML (WPF)](../../../desktop-wpf/fundamentals/xaml.md)
- [Пользовательские свойства зависимостей](custom-dependency-properties.md)
- [Общие сведения о разработке элементов управления](../controls/control-authoring-overview.md)
- [Общие сведения о базовых элементах](base-elements-overview.md)
- [Загрузка кода XAML и свойства зависимостей](xaml-loading-and-dependency-properties.md)
