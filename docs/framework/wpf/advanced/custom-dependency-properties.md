---
title: Пользовательские свойства зависимостей
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- implementing [WPF], wrappers
- registering properties [WPF]
- properties [WPF], metadata
- metadata [WPF], for properties
- custom dependency properties [WPF]
- properties [WPF], registering
- wrappers [WPF], implementing
- dependency properties [WPF], custom
ms.assetid: e6bfcfac-b10d-4f58-9f77-a864c2a2938f
ms.openlocfilehash: e4117d7add2a34d6d989d9222e7688361cf6b379
ms.sourcegitcommit: 62285ec11fa8e8424bab00511a90760c60e63c95
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/20/2020
ms.locfileid: "81646355"
---
# <a name="custom-dependency-properties"></a>Пользовательские свойства зависимостей

В этом разделе описываются основания для создания настраиваемых свойств зависимостей для приложений [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], а также этапы и некоторые варианты реализации, которые могут повысить производительность, удобство использования и универсальность свойств.

<a name="prerequisites"></a>

## <a name="prerequisites"></a>Предварительные требования

Предполагается, что вы имеете представление о свойствах зависимостей с точки зрения потребителя существующих свойств зависимостей в классах [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] и ознакомились с разделом [Общие сведения о свойствах зависимостей](dependency-properties-overview.md). Чтобы выполнить примеры в этом разделе, следует также иметь представление о [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] и написании простых приложений [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].

<a name="whatis"></a>

## <a name="what-is-a-dependency-property"></a>Что такое свойство зависимостей?

Вы можете включить свойство общего времени выполнения языка (CLR) для поддержки укладки, связывания данных, наследования, анимации и значений по умолчанию, реализуя его в качестве свойства зависимости. Свойства зависимости — это свойства, зарегистрированные [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.DependencyProperty.Register%2A> в системе <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>свойств, вызывая <xref:System.Windows.DependencyProperty> метод (или), и которые поддерживаются полем идентификатора. Свойства зависимости могут использоваться <xref:System.Windows.DependencyObject> только <xref:System.Windows.DependencyObject> по типам, но достаточно высоки в иерархии [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] классов, поэтому большинство классов, доступных в, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] могут поддерживать свойства зависимости. Для получения дополнительной информации о свойствах зависимости и некоторых терминологиях и конвенциях, используемых для их описания в этом SDK, [см.](dependency-properties-overview.md)

<a name="example_dp"></a>

## <a name="examples-of-dependency-properties"></a>Примеры свойств зависимостей

Примеры свойств зависимости, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] которые реализуются на классах, включают <xref:System.Windows.Controls.Control.Background%2A> свойство, <xref:System.Windows.FrameworkElement.Width%2A> свойство и <xref:System.Windows.Controls.TextBox.Text%2A> свойство, среди многих других. Каждое свойство зависимости, подвергаемое классу, имеет соответствующее общестатическое поле типа, <xref:System.Windows.DependencyProperty> выставленное на том же классе. Это идентификатор для свойства зависимостей. Идентификатор именуется по следующему соглашению: имя свойства зависимостей, за которым следует строка `Property`. Например, соответствующее <xref:System.Windows.DependencyProperty> поле идентификатора для <xref:System.Windows.Controls.Control.Background%2A> свойства . <xref:System.Windows.Controls.Control.BackgroundProperty> Идентификатор хранит информацию об свойстве зависимости в том виде, в каком оно было зарегистрировано, а идентификатор затем используется для других операций, связанных с свойством зависимости, таких как вызов. <xref:System.Windows.DependencyObject.SetValue%2A>

Как указано в [обзоре свойств зависимостей,](dependency-properties-overview.md)все свойства зависимости в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] (за исключением большинства прилагаемых свойств) также являются свойствами CLR из-за реализации "обертки". Таким образом, из кода можно получить или установить свойства зависимостей, позвонив в accessors CLR, которые определяют обертки таким же образом, как вы будете использовать другие свойства CLR. Как потребитель установленных свойств зависимости, вы <xref:System.Windows.DependencyObject> обычно <xref:System.Windows.DependencyObject.GetValue%2A> <xref:System.Windows.DependencyObject.SetValue%2A>не используете методы и, которые являются точкой соединения с базовой системой свойств. Скорее, существующая реализация свойств CLR <xref:System.Windows.DependencyObject.GetValue%2A> уже <xref:System.Windows.DependencyObject.SetValue%2A> вызвала `get` `set` и в рамках и обертки реализации свойства, используя поле идентификатора надлежащим образом. При собственной реализации настраиваемого свойства зависимостей вы будете определять оболочку аналогичным образом.

<a name="backing_with_dp"></a>

## <a name="when-should-you-implement-a-dependency-property"></a>Почему требуется реализовывать свойство зависимостей?

При реализации свойства в классе, до тех пор, как ваш класс происходит <xref:System.Windows.DependencyObject>от <xref:System.Windows.DependencyProperty> , у вас есть возможность поддержать свойство с идентификатором и, таким образом, чтобы сделать его свойством зависимости. Назначение свойства свойством зависимостей не всегда требуется и не всегда уместно и зависит от конкретной ситуации. В некоторых случаях достаточно просто снабдить свойство закрытым полем. Тем не менее реализовать свойство как свойство зависимостей потребуется, если свойство должно поддерживать одну или несколько из следующих возможностей [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].

- Требуется, чтобы свойство было задаваемым в стиле. Более подробную информацию см. в разделе [Стилизация и использование шаблонов](../../../desktop-wpf/fundamentals/styles-templates-overview.md).

- Требуется, чтобы свойство поддерживало привязку данных. Дополнительные сведения о свойствах зависимостей привязки данных см. в разделе [Привязка свойств двух элементов управления](../data/how-to-bind-the-properties-of-two-controls.md).

- Требуется, чтобы свойство было задаваемым с помощью динамической ссылки ресурса. Дополнительные сведения см. в разделе [Ресурсы XAML](../../../desktop-wpf/fundamentals/xaml-resources-define.md).

- Требуется настроить автоматическое наследование значения свойства из родительского элемента в дереве элементов. В этом случае зарегистрируйтесь в методе, <xref:System.Windows.DependencyProperty.RegisterAttached%2A> даже если вы также создаете обертку свойств для доступа CLR. Дополнительные сведения см. в разделе [Наследование значения свойства](property-value-inheritance.md).

- Требуется, чтобы свойство поддерживало анимацию. Для получения дополнительной информации [см.](../graphics-multimedia/animation-overview.md)

- Требуется, чтобы система свойств сообщала об изменении предыдущего значения свойства действиями, выполняемыми системой свойств, окружением или пользователем, или путем чтения и использования стилей. Используя метаданные свойства, свойство может указывать метод обратного вызова, который будет вызываться каждый раз, когда система свойств определит, что значение свойства было однозначно изменено. Связанным понятием является приведение значения свойства. Дополнительные сведения см. в разделе [Проверка и обратные вызовы свойства зависимостей](dependency-property-callbacks-and-validation.md).

- Требуется использовать установленные соглашения о метаданных, которые также используются процессами [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], такими как передача сведений о том, нужно ли системе макета перестраивать визуальные компоненты элемента при изменении значения свойства. Или требуется возможность использовать переопределения метаданных таким образом, чтобы производные классы могли изменять основанные на метаданных характеристики, такие как значение по умолчанию.

- Вы хотите, чтобы свойства пользовательского элемента управления получали поддержку Visual Studio WPF Designer, такие как редактирование окон **Properties.** Дополнительные сведения см. в разделе [Общие сведения о разработке элементов управления](../controls/control-authoring-overview.md).

Рекомендуется рассмотреть возможность реализации сценариев путем переопределения метаданных существующего свойства зависимостей, вместо реализации совершенно нового свойства. Практическая польза переопределения метаданных зависит от сценария и того, насколько этот сценарий схож с реализацией существующих свойств зависимостей и классов [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. Дополнительные сведения о переопределении метаданных для существующих свойств см. в разделе [Метаданные свойств зависимостей](dependency-property-metadata.md).

<a name="checklist"></a>

## <a name="checklist-for-defining-a-dependency-property"></a>Контрольный список определения свойства зависимостей

Определение свойства зависимостей состоит из четырех различных понятий. Эти понятия не обязательно являются строгими этапами процедуры, так как некоторые из них в итоге объединяются в одну строку кода в реализации.

- (Необязательно.) Создайте метаданные для свойства зависимостей.

- Зарегистрируйте имя свойства в системе свойств, указав тип владельца и тип значения свойства. Также укажите метаданные свойства, если они используются.

- Определите <xref:System.Windows.DependencyProperty> идентификатор в `public` `static` `readonly` виде поля по типу владельца.

- Определите свойство "обертка" CLR, название которого совпадает с именем свойства зависимости. Реализация свойств CLR "обертки" `get` и `set` аксессуаров для подключения с свойством зависимости, которое поддерживает его.

<a name="registering"></a>

### <a name="registering-the-property-with-the-property-system"></a>Регистрация свойства в системе свойств

Чтобы назначить свойство свойством зависимостей, необходимо зарегистрировать это свойство в таблице, обслуживаемой системой свойств, и предоставить ему уникальный идентификатор, используемый в качестве квалификатора для последующих операций системы свойств. Эти операции могут быть внутренними операциями или собственным кодом, вызывая AA. Чтобы зарегистрировать свойство, <xref:System.Windows.DependencyProperty.Register%2A> вы называете метод в теле вашего класса (внутри класса, но вне каких-либо определений участника). Поле идентификатора <xref:System.Windows.DependencyProperty.Register%2A> также обеспечивается вызовом метода, как значение возврата. Причина, по <xref:System.Windows.DependencyProperty.Register%2A> которой вызов выполняется вне других определений членов, заключается `public` `static` `readonly` в том, что вы используете это значение возврата для присвоения и создания поля типа <xref:System.Windows.DependencyProperty> в рамках вашего класса. Это поле становится идентификатором для вашего свойства зависимостей.

[!code-csharp[WPFAquariumSln#RegisterAG](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerag)]
[!code-vb[WPFAquariumSln#RegisterAG](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerag)]

<a name="nameconventions"></a>

### <a name="dependency-property-name-conventions"></a>Соглашения об именовании свойств зависимостей

Существуют установленные соглашения об именовании, касающиеся свойств зависимостей, которым необходимо следовать, если ситуация не является исключительной.

Свойство зависимости само будет иметь базовое название, "АквариумГрафический", как в <xref:System.Windows.DependencyProperty.Register%2A>этом примере, который дается в качестве первого параметра . Это имя должно быть уникальным в пределах каждого регистрирующего типа. Считается, что свойства зависимостей, наследуемые через базовые типы, уже являются частью регистрирующего типа: имена наследуемых свойств нельзя зарегистрировать повторно. Однако существует способ добавления класса как владельца свойства зависимостей даже в том случае, если это свойство зависимостей не наследуется. Дополнительные сведения см. в разделе [Метаданные свойств зависимостей](dependency-property-metadata.md).

При создании поля идентификатора назовите это поле по зарегистрированному имени свойства, добавив суффикс `Property`. Это поле является вашим идентификатором для свойства зависимости, и <xref:System.Windows.DependencyObject.SetValue%2A> <xref:System.Windows.DependencyObject.GetValue%2A> оно будет использоваться позже в качестве ввода и вызовов, которые вы сделаете в обертках, любым другим [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] кодом доступа к свойству по вашему собственному коду, любым внешним кодом, который вы разрешаете, системой свойств и, возможно, процессорами.

> [!NOTE]
> Определение свойства зависимостей в теле класса является обычной реализацией, однако его также можно определить в статическом конструкторе класса. Этот подход может оказаться целесообразным, если для инициализации свойства зависимостей требуется несколько строк кода.

<a name="wrapper1"></a>

### <a name="implementing-the-wrapper"></a>Реализация "оболочки"

Реализация обертки <xref:System.Windows.DependencyObject.GetValue%2A> должна `get` быть <xref:System.Windows.DependencyObject.SetValue%2A> выполнена `set` в реализации и в реализации (оригинальный регистрационный вызов и поле показаны здесь также для ясности).

Во всех, кроме исключительных обстоятельств, ваши <xref:System.Windows.DependencyObject.GetValue%2A> реализации обертки должны выполнять только и <xref:System.Windows.DependencyObject.SetValue%2A> действия, соответственно. Причина этого обсуждается в разделе [Загрузка кода XAML и свойства зависимостей](xaml-loading-and-dependency-properties.md).

Все существующие открытые свойства зависимостей, предоставляемые для классов [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], используют эту простую модель реализации оболочки. Основные сложности обработки свойств зависимостей определяются наследуемым поведением системы свойств или реализацией через другие понятия, такие как приведение или обратные вызовы изменения свойства через метаданные свойства.

[!code-csharp[WPFAquariumSln#AGWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#agwithwrapper)]
[!code-vb[WPFAquariumSln#AGWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#agwithwrapper)]

Опять же, по конвенции, название свойства обертки должно быть таким <xref:System.Windows.DependencyProperty.Register%2A> же, как имя выбрано и дано в качестве первого параметра вызова, который зарегистрировал свойство. Если свойство не следует соглашению, это не обязательно ведет к его неработоспособности, однако будет наблюдаться несколько серьезных проблем.

- Не будут работать определенные аспекты стилей и шаблонов.

- Большинство инструментов и конструкторов полагается на соглашения об именовании для правильной сериализации [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], а также для предоставления помощи разработчику на уровне свойств.

- Текущая реализация [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] погрузчика полностью обходит обертки и опирается на конвенцию именования при обработке значений атрибутов. Дополнительные сведения см. в разделе [Загрузка кода XAML и свойства зависимостей](xaml-loading-and-dependency-properties.md).

<a name="metadata"></a>

### <a name="property-metadata-for-a-new-dependency-property"></a>Метаданные свойства для нового свойства зависимостей

При регистрации свойства зависимостей через систему свойств создается объект метаданных, который хранит характеристики свойства. Многие из этих характеристик имеют значения по умолчанию, если <xref:System.Windows.DependencyProperty.Register%2A>свойство зарегистрировано простыми подписями. Другие <xref:System.Windows.DependencyProperty.Register%2A> подписи позволяют указать метаданные, которые вы хотите при регистрации свойства. Как правило, метаданные, задаваемые для свойства зависимостей, предполагают предоставление значений по умолчанию, применяемых для новых экземпляров, которые используют свойство.

При создании свойства зависимости, которое существует на <xref:System.Windows.FrameworkElement>производном классе, можно <xref:System.Windows.FrameworkPropertyMetadata> использовать более <xref:System.Windows.PropertyMetadata> специализированный класс метаданных, а не базовый класс. Конструктор <xref:System.Windows.FrameworkPropertyMetadata> для класса имеет несколько подписей, где можно указать различные характеристики метаданных в комбинации. Если вы хотите указать только значение по умолчанию, используйте подпись, которая занимает один параметр типа. <xref:System.Object> Передайте этот параметр объекта в качестве значения по умолчанию для свойств, конкретного по умолчанию (при условии значение по умолчанию должно быть типом, который вы предоставили в `propertyType` качестве параметра в вызове). <xref:System.Windows.DependencyProperty.Register%2A>

Для <xref:System.Windows.FrameworkPropertyMetadata>этого можно также указать флаги параметра метаданных для вашего имущества. Эти флаги преобразуются в дискретные свойства в метаданных свойства после регистрации и используются для передачи определенных условных объектов в другие процессы, например в обработчик макетов.

#### <a name="setting-appropriate-metadata-flags"></a>Задание соответствующих флагов метаданных

- Если ваше свойство (или изменения в [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]его значении) влияет на , и, в частности, влияет на то, как <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure> <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange>система <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender>макета должна размер или сделать ваш элемент на странице, установите один или несколько из следующих флагов: , .

  - <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure>указывает на то, что изменение [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] этого свойства требует изменения рендеринга, в котором содержащемуся объекту может потребоваться более или менее место в родительском объекте. Например, этот флаг следует задать для свойства "Ширина".

  - <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange>указывает на то, что изменение [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] этого свойства требует изменения рендеринга, которое обычно не требует изменения выделенного пространства, но указывает на изменение положения в пространстве. Например, этот флаг следует задать для свойства "Выравнивание".

  - <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender>указывает на то, что произошло другое изменение, которое не повлияет на макет и измерение, но требует другого рендера. Примером будет свойство, изменяющее цвет существующего элемента, например "Фон".

  - Эти флаги часто используются в качестве протокола в метаданных для собственных реализаций переопределения системы свойств или обратных вызовов макета. Например, у вас <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> может быть <xref:System.Windows.UIElement.InvalidateArrange%2A> обратный вызов, который вызовет, если <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> `true` какое-либо свойство экземпляра сообщает о изменении значения и имеет как в его метаданных.

- Некоторые свойства могут влиять на характеристики отрисовки содержащего их родительского элемента указанными выше способами и помимо изменений в обязательном размере, упомянутых выше. Примером может <xref:System.Windows.Documents.Paragraph.MinOrphanLines%2A> быть свойство, используемое в модели документа потока, где изменения в этом свойстве могут изменить общую визуализацию документа потока, содержащего абзац. <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentArrange> Используйте <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentMeasure> или выявляйте подобные случаи в ваших собственных свойствах.

- По умолчанию свойства зависимостей поддерживают привязку данных. Вы можете специально отключить привязку данных для случаев, когда отсутствует практический смысл в привязке данных или когда быстродействие в привязке данных для больших объектов становится проблемой.

- По умолчанию <xref:System.Windows.Data.Binding.Mode%2A> привязка данных <xref:System.Windows.Data.BindingMode.OneWay>для свойств зависимости по умолчанию. Вы всегда можете изменить <xref:System.Windows.Data.BindingMode.TwoWay> привязку, чтобы быть в связывающем экземпляре; для получения подробной информации [см.](../data/how-to-specify-the-direction-of-the-binding.md) Но как автор свойств зависимости, вы можете <xref:System.Windows.Data.BindingMode.TwoWay> сделать режим связывания свойств по умолчанию. Примером существующего свойства зависимости является; <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A?displayProperty=nameWithType> сценарий для этого свойства <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> заключается в том, <xref:System.Windows.Controls.MenuItem> что логика настройки и композиция взаимодействия со стилем темы по умолчанию. Логика <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> свойства использует связывание данных на родине для поддержания состояния свойства в соответствии с другими государственными свойствами и вызовами метода. Другой пример свойства, <xref:System.Windows.Data.BindingMode.TwoWay> который <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=nameWithType>связывает по умолчанию.

- Вы также можете включить наследование свойств <xref:System.Windows.FrameworkPropertyMetadataOptions.Inherits> в пользовательском свойстве зависимости, установив флаг. Наследование свойств удобно для ситуации, когда родительские и дочерние элементы имеют общее свойство и для дочерних элементов имеет смысл задать то же значение свойства, что и в родительском элементе. Примером наследуемого <xref:System.Windows.FrameworkElement.DataContext%2A>свойства является , который используется для связывания операций, чтобы включить важный сценарий мастер-детали для представления данных. Делая <xref:System.Windows.FrameworkElement.DataContext%2A> наследуемые, любые элементы ребенка также наследуют этот контекст данных. Благодаря наследованию значения свойства вы можете указать контекст данных в корне приложения или страницы и вам не потребуется уточнять его для привязок во всех возможных дочерних элементах. <xref:System.Windows.FrameworkElement.DataContext%2A>является также хорошим примером для иллюстрации того, что наследование переопределяет значение по умолчанию, но оно всегда может быть установлено локально на любом конкретном элементе ребенка; для получения [подробной](../data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md)информации см. Наследование значения свойства может влиять на производительность, и таким образом, его следует использовать с осторожностью. Дополнительные сведения см. в разделе [Наследование значения свойства](property-value-inheritance.md).

- Установите <xref:System.Windows.FrameworkPropertyMetadataOptions.Journal> флаг, чтобы указать, следует ли обнаружить свойство зависимости или использоваться службами навигационного журналирования. Примером может <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> быть свойство; любой элемент, выбранный в контрольном элементе отбора, должен сохраняться при навигации по истории журналов.

<a name="RODP"></a>

## <a name="read-only-dependency-properties"></a>Свойства зависимости "только для чтения"

Можно определить свойство зависимости, которое доступно только для чтения. Однако ситуации для такого использования немного отличаются, как и процедура регистрации свойства в системе свойств и предоставление идентификатора. Дополнительные сведения см. в разделе [Свойства зависимостей "только для чтения"](read-only-dependency-properties.md).

<a name="CTDP"></a>

## <a name="collection-type-dependency-properties"></a>Свойства зависимостей типа коллекция

Свойства зависимостей типа коллекции имеют некоторые дополнительные проблемы при реализации, которые необходимо учитывать. Подробности см. в разделе [Свойства зависимостей типа коллекции](collection-type-dependency-properties.md).

<a name="SecurityC"></a>

## <a name="dependency-property-security-considerations"></a>Замечания по безопасности свойств зависимостей

Свойства зависимостей должны объявляться как открытые свойства. Поля идентификаторов свойств зависимостей должны объявляться как открытые статические поля. Даже если вы попытаетесь объявить другие уровни доступа (например, защищенные), свойство зависимости всегда может быть доступно через идентификатор в сочетании с AIS системы свойств. Даже защищенное поле идентификатора потенциально доступно из-за отчетности метаданных или <xref:System.Windows.LocalValueEnumerator>AIS определения значений, которые являются частью системы свойств, таких как . Дополнительные сведения см. в разделе [Безопасность свойств зависимостей](dependency-property-security.md).

<a name="DPCtor"></a>

## <a name="dependency-properties-and-class-constructors"></a>Свойства зависимостей и конструкторы класса

Есть общий принцип в программировании управляемого кода (он часто принудительно применяется средствами анализа кода, такими как FxCop), подразумевающий, что конструкторы класса не должны вызывать виртуальные методы. Этот принцип обусловлен тем, что конструкторы могут быть вызваны в качестве базовой инициализации конструктора производного класса, а ввод виртуального метода через конструктор может произойти в состоянии неполной инициализации конструируемого экземпляра объекта. Когда вы вытекаете из любого класса, который уже вытекает из, <xref:System.Windows.DependencyObject>вы должны знать, что система свойств сама вызывает и предоставляет виртуальные методы внутри страны. Эти виртуальные методы являются частью служб системы свойств [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. Переопределение методов позволяет производным классам участвовать в определении значения. Чтобы избежать потенциальных проблем при инициализации среды выполнения, не задавайте значения свойств зависимостей в конструкторах классов (если только вы не следуете конкретному шаблону конструктора). Подробнее см. в разделе [Шаблоны безопасного конструктора для DependencyObjects](safe-constructor-patterns-for-dependencyobjects.md).

## <a name="see-also"></a>См. также раздел

- [Общие сведения о свойствах зависимости](dependency-properties-overview.md)
- [Метаданные свойства зависимости](dependency-property-metadata.md)
- [Общие сведения о разработке элементов управления](../controls/control-authoring-overview.md)
- [Свойства зависимостей типа коллекция](collection-type-dependency-properties.md)
- [Безопасность свойства зависимости](dependency-property-security.md)
- [Загрузка кода XAML и свойства зависимостей](xaml-loading-and-dependency-properties.md)
- [Шаблоны безопасного конструктора для DependencyObjects](safe-constructor-patterns-for-dependencyobjects.md)
