---
title: Деревья
ms.date: 03/30/2017
helpviewer_keywords:
- logical tree [WPF]
- element tree [WPF]
- visual tree [WPF]
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
ms.openlocfilehash: d4b17c34fb33f73ca1c173bebc8f94ddac5b1942
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2020
ms.locfileid: "76746575"
---
# <a name="trees-in-wpf"></a>Деревья в WPF
Во многих технологиях элементы и компоненты организованы в форме древовидной структуры, и разработчики могут напрямую управлять узлами объекта в дереве, чтобы повлиять на визуализацию или поведение приложения. В [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] часто используется несколько метафор древовидных структур, чтобы определить отношения между программными элементами. Для большей части WPF разработчики могут создать приложение в коде или определить части приложения в XAML и при этом концептуально думать о метафоре дерева объектов, но для этого им потребуется вызвать определенный интерфейс API или использовать конкретную разметку, а не интерфейс API управления деревом некоторых общих объектов, какой можно использовать в XML DOM. WPF предоставляет два вспомогательных класса, которые предоставляют представление метафор дерева <xref:System.Windows.LogicalTreeHelper> и <xref:System.Windows.Media.VisualTreeHelper>. Термины "логическое дерево" и "визуальное дерево" также используются в документации WPF, поскольку эти же деревья помогают понять поведение определенных ключевых функций WPF. В этом разделе определяются представления визуального дерева и логического дерева, обсуждаются отношения этих деревьев к общей концепции дерева объектов, а также представлены <xref:System.Windows.LogicalTreeHelper> и <xref:System.Windows.Media.VisualTreeHelper>s.  

<a name="element_tree"></a>   
## <a name="trees-in-wpf"></a>Деревья в WPF  
 Самой полной древовидной структурой в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] является дерево объектов. При определении страницы приложения в [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] и последующей загрузке [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] древовидная структура создается на основе отношений вложенности элементов в разметке. При определении приложения или части приложения в коде древовидная структура создается в зависимости от того, как присваиваются значения свойствам, которые реализуют модель содержимого для данного объекта. В [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] существует два способа концептуализации и передачи в открытый интерфейс API полного дерева объектов: в виде логического дерева и в виде визуального дерева. Различия между логическими деревьями и визуальными деревьями не всегда важны, но иногда они могут вызвать проблемы с некоторыми подсистемами [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] и повлиять на изменения, внесенные в разметку или код.  
  
 Несмотря на то, что управление логическим деревом или визуальным деревом не всегда происходит напрямую, понимание концепций взаимодействия деревьев позволяет понять WPF как технологию. Рассмотрение WPF как некоторой метафоры дерева также важно для понимания того, как в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] осуществляется наследование свойств и маршрутизация событий.  
  
> [!NOTE]
> Поскольку дерево объектов — это более широкое понятие, чем фактический интерфейс API, еще одним способом представить себе концепцию является граф объекта. На практике отношения между объектами можно наблюдать во время выполнения, когда метафора дерева разделяется. Тем не менее, особенно в пользовательском интерфейсе, определенном XAML, метафора дерева достаточно релевантна, и в большей части документации WPF используется термин "дерево объекта" при ссылке на это общее понятие.  
  
<a name="logical_tree"></a>   
## <a name="the-logical-tree"></a>Логическое дерево  
 В [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] содержимое добавляется в элементы пользовательского интерфейса путем задания свойств объектов, которые поддерживают эти элементы. Например, можно добавить элементы в элемент управления <xref:System.Windows.Controls.ListBox>, управляя его свойством <xref:System.Windows.Controls.ItemsControl.Items%2A>. При этом элементы помещаются в <xref:System.Windows.Controls.ItemCollection>, который является значением свойства <xref:System.Windows.Controls.ItemsControl.Items%2A>. Аналогичным образом, чтобы добавить объекты в <xref:System.Windows.Controls.DockPanel>, вы управляете его значением свойства <xref:System.Windows.Controls.Panel.Children%2A>. Здесь вы добавляете объекты в <xref:System.Windows.Controls.UIElementCollection>. Пример кода см. в разделе [как добавить элемент динамически](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100)).  
  
 В [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]при помещении элементов списка в <xref:System.Windows.Controls.ListBox> или элементы управления или другие элементы пользовательского интерфейса в <xref:System.Windows.Controls.DockPanel>также используются свойства <xref:System.Windows.Controls.ItemsControl.Items%2A> и <xref:System.Windows.Controls.Panel.Children%2A> явно или неявно, как показано в следующем примере.  
  
 [!code-xaml[TreeOvwsSupport#AllCode](~/samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 Если бы этот XAML обрабатывался как XML в объектной модели документов, и если бы были включены теги, закомментированные как неявные (были бы допустимы), полученное дерево XML DOM включало бы элементы для `<ListBox.Items>` и другие неявные элементы. Но XAML не выполняет такую обработку при чтении разметки и записи в объекты, полученный граф объекта не включает `ListBox.Items` в буквальном смысле. Однако у него есть свойство <xref:System.Windows.Controls.ListBox> с именем `Items`, содержащее <xref:System.Windows.Controls.ItemCollection>, которое <xref:System.Windows.Controls.ItemCollection> инициализировано, но является пустым при обработке <xref:System.Windows.Controls.ListBox> XAML. Затем каждый дочерний элемент объекта, существующий как содержимое для <xref:System.Windows.Controls.ListBox>, добавляется в <xref:System.Windows.Controls.ItemCollection> вызовами синтаксического анализатора в `ItemCollection.Add`. Этот пример обработки XAML в дереве объектов на первый взгляд похож на пример, в котором созданное дерево объектов, по сути, является логическим деревом.  
  
 Однако логическое дерево не является всей диаграммой объектов, которая существует для пользовательского интерфейса приложения во время выполнения, даже при использовании неявных элементов синтаксиса XAML. Основная причина этого — визуальные элементы и шаблоны. Например, рассмотрим <xref:System.Windows.Controls.Button>. Логическое дерево сообщает об объекте <xref:System.Windows.Controls.Button>, а также его строке `Content`. Но в дереве объектов времени выполнения имеется больше сведений об этой кнопке. В частности, кнопка отображается на экране только в том виде, в котором был применен определенный шаблон элемента управления <xref:System.Windows.Controls.Button>. Визуальные элементы, поступающие из примененного шаблона (например, определенные шаблоном <xref:System.Windows.Controls.Border> темно-серого вокруг визуальной кнопки), не передаются в логическое дерево, даже если во время выполнения отображается логическое дерево (например, обработка события ввода из видимого пользовательского интерфейса и последующее чтение логического дерева). Чтобы найти визуальные элементы шаблона, необходимо проверить визуальное дерево.  
  
 Дополнительные сведения о сопоставлении синтаксиса [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] с созданным графом объекта и неявным синтаксисом в XAML см. в разделе [Подробное описание синтаксиса XAML](xaml-syntax-in-detail.md) или [Общие сведения о языке XAML (WPF)](xaml-overview-wpf.md).  
  
<a name="tree_property_inheritance_event_routing"></a>   
### <a name="the-purpose-of-the-logical-tree"></a>Назначение логического дерева  
 Логическое дерево существует для того, чтобы модели содержимого имели возможность пройти по своим доступным дочерним объектам, а также для их расширяемости. Кроме того, логическое дерево предоставляет оболочку для некоторых уведомлений, например при загрузке всех объектов логического дерева. По существу, логическое дерево является подобием графа объекта времени выполнения на уровне оболочки, исключающего визуальные элементы, но подходит для большинства операций запросов для собственной композиции приложения времени выполнения.  
  
 Кроме того, как статические, так и динамические ссылки на ресурсы разрешаются путем поиска по логическому дереву <xref:System.Windows.FrameworkElement.Resources%2A> коллекций в первоначальном запрашивающем объекте, а затем продолжается логическое дерево и выполняется проверка каждого <xref:System.Windows.FrameworkElement> (или <xref:System.Windows.FrameworkContentElement>) для другого `Resources`ного значения, содержащего <xref:System.Windows.ResourceDictionary>, возможно, с помощью этого ключа. Логическое дерево используется для просмотра ресурсов при наличии логического дерева и визуального дерева. Дополнительные сведения о словарях ресурсов и поиске см. в разделе [Общие сведения о ресурсах](../../../desktop-wpf/fundamentals/xaml-resources-define.md).  
  
<a name="composition"></a>   
### <a name="composition-of-the-logical-tree"></a>Композиция логического дерева  
 Логическое дерево определяется на уровне платформы WPF. Это означает, что базовый элемент WPF, который наиболее важен для операций логического дерева, либо <xref:System.Windows.FrameworkElement>, либо <xref:System.Windows.FrameworkContentElement>. Однако, как можно увидеть, если фактически используется API <xref:System.Windows.LogicalTreeHelper>, логическое дерево иногда содержит узлы, которые не <xref:System.Windows.FrameworkElement> или <xref:System.Windows.FrameworkContentElement>. Например, логическое дерево сообщает значение <xref:System.Windows.Controls.TextBlock.Text%2A> <xref:System.Windows.Controls.TextBlock>, которое является строкой.  
  
<a name="override_logical_tree"></a>   
### <a name="overriding-the-logical-tree"></a>Переопределение логического дерева  
 Авторы расширенного элемента управления могут переопределить логическое дерево путем переопределения нескольких интерфейсов API, определяющих, как общий объект или модель содержимого добавляют или удаляют объекты в логическом дереве. Пример переопределения логического дерева содержится в разделе [Переопределение логического дерева](how-to-override-the-logical-tree.md).  
  
<a name="pvi"></a>   
### <a name="property-value-inheritance"></a>Наследование значения свойства  
 Наследование значения свойств действует через гибридное дерево. Фактические метаданные, содержащие свойство <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>, которое позволяет наследование свойств, — это класс <xref:System.Windows.FrameworkPropertyMetadata> уровня среды WPF. Таким образом, как родитель, содержащий исходное значение, так и дочерний объект, который наследует это значение, должны быть <xref:System.Windows.FrameworkElement> или <xref:System.Windows.FrameworkContentElement>, и они должны быть частью некоторого логического дерева. Однако для существующих свойств WPF, поддерживающих наследование свойств, наследование значений свойств способно принять промежуточный объект, которого нет в логическом дереве. Как правило, это распространяется на элементы шаблона, использующие все унаследованные значения свойств, заданные как в экземпляре, который является шаблоном, так и на более высоких уровнях композиции уровня страницы и, следовательно, выше в логическом дереве. Чтобы наследование значений свойств осуществлялось согласованно в таких пределах, наследуемое свойство должно быть зарегистрировано как вложенное свойство, кроме того, необходимо следовать этому шаблону, если требуется определить пользовательское свойство зависимостей с поведением наследования свойств. Точное дерево, используемое для наследования свойств, не может быть полностью предсказано вспомогательным служебным методом класса даже во время выполнения. Дополнительные сведения см. в разделе [Наследование значения свойства](property-value-inheritance.md).  
  
<a name="two_trees"></a>   
## <a name="the-visual-tree"></a>Визуальное дерево  
 В дополнение к концепции логического дерева в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] также существует концепция визуального дерева. Визуальное дерево описывает структуру визуальных объектов, представленных базовым классом <xref:System.Windows.Media.Visual>. При написании шаблона для элемента управления следует определить или переопределить визуальное дерево, применяемое для данного элемента управления. Визуальное дерево также представляет интерес для разработчиков, заинтересованных в контроле рисования на нижнем уровне по соображениям производительности и оптимизации. Слабым местом визуального дерева как части программирования стандартных приложений [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] является то, что маршруты событий для перенаправленного события в большинстве случаев проходят по визуальному дереву, а не по логическому. Эта тонкость поведения перенаправленного события может быть не очевидна, если вы не являетесь автором элемента управления. Маршрутизация событий по визуальному дереву позволяет элементам управления, которые реализуют композицию на визуальном уровне, обрабатывать события или создавать установщики событий.  
  
<a name="trees_content"></a>   
## <a name="trees-content-elements-and-content-hosts"></a>Деревья, элементы содержимого и узлы содержимого  
 Элементы содержимого (классы, производные от <xref:System.Windows.ContentElement>) не являются частью визуального дерева; они не наследуют от <xref:System.Windows.Media.Visual> и не имеют визуального представления. Для отображения в пользовательском интерфейсе <xref:System.Windows.ContentElement> должны размещаться на узле содержимого, который является и <xref:System.Windows.Media.Visual>, и участником логического дерева. Обычно такой объект является <xref:System.Windows.FrameworkElement>ом. Можно представить сайт содержимого в качестве "обозревателя" содержимого, который выбирает способ отображения содержимого в пределах области экрана, управляемой сайтом. При размещении содержимого оно может стать участником некоторых процессов дерева, которые обычно связаны с визуальным деревом. Как правило, класс узла <xref:System.Windows.FrameworkElement> включает код реализации, который добавляет любые размещенные <xref:System.Windows.ContentElement> в маршрут событий через подузлы логического дерева содержимого, даже если размещенное содержимое не является частью истинного визуального дерева. Это необходимо для того, чтобы в <xref:System.Windows.ContentElement> можно было разослать перенаправленное событие, которое будет маршрутизироваться к любому элементу, отличному от самого себя.  
  
<a name="tree_traversal"></a>   
## <a name="tree-traversal"></a>Прохождение по дереву  
 Класс <xref:System.Windows.LogicalTreeHelper> предоставляет методы <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>, <xref:System.Windows.LogicalTreeHelper.GetParent%2A>и <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> для обхода логического дерева. В большинстве случаев не следует проходить по логическому дереву существующих элементов управления, так как эти элементы управления почти всегда предоставляют свои логические дочерние элементы в качестве выделенного свойства коллекции, которое поддерживает доступ к коллекции, например `Add`, индексатор и т. д. Обход дерева в основном является сценарием, используемым авторами элементов управления, которые не являются производными от предполагаемых шаблонов элементов управления, таких как <xref:System.Windows.Controls.ItemsControl> или <xref:System.Windows.Controls.Panel>, где свойства коллекции уже определены, и кто планирует предоставить собственную поддержку свойств коллекции.  
  
 Визуальное дерево также поддерживает вспомогательный класс для обхода визуального дерева, <xref:System.Windows.Media.VisualTreeHelper>. Визуальное дерево недоступно для свойств, зависящих от элемента управления, поэтому класс <xref:System.Windows.Media.VisualTreeHelper> является рекомендуемым способом обхода визуального дерева, если это необходимо для сценария программирования. Дополнительные сведения см. в разделе [Общие сведения об отрисовке графики в WPF](../graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
> [!NOTE]
> Иногда необходимо проверять визуальное дерево применяемого шаблона. Необходимо соблюдать осторожность при использовании этого метода. Даже если вы просматриваете визуальное дерево для элемента управления, в котором вы определили шаблон, потребители элемента управления всегда могут изменить шаблон, установив свойство <xref:System.Windows.Controls.Control.Template%2A> для экземпляров, и даже конечный пользователь может повлиять на примененный шаблон, изменив тему системы.  
  
<a name="routes"></a>   
## <a name="routes-for-routed-events-as-a-tree"></a>Маршруты для маршрутизируемых событий как "дерево"  
 Как уже отмечалось ранее, маршрут любого заданного перенаправленного события проходит по одному предопределенному пути дерева, представляющего собой гибрид представлений визуального и логического деревьев. Маршрут события может проходить как по восходящей, так и по нисходящий в пределах дерева в зависимости от того, имеет ли перенаправленное событие нисходящую или восходящую маршрутизацию. Концепция маршрута события не имеет непосредственного вспомогательного класса, который может быть использован для "прохода" маршрута события независимо от вызова фактически перенаправленного события. Существует класс, представляющий маршрут, <xref:System.Windows.EventRoute>, но методы этого класса обычно предназначены только для внутреннего использования.  
  
<a name="resourcesandtrees"></a>   
## <a name="resource-dictionaries-and-trees"></a>Словари и деревья ресурсов  
 Поиск по словарю ресурсов для всех `Resources`, определенных на странице, обычно проходит по логическому дереву. Объекты, которые не входят в логическое дерево, могут ссылаться на ресурсы с ключом, но последовательность поиска ресурса начинается с той точки, где объект подключен к логическому дереву. В WPF только логические узлы дерева могут иметь свойство `Resources`, которое содержит <xref:System.Windows.ResourceDictionary>, поэтому нет смысла перемещаться по визуальному дереву при поиске ключевых ресурсов из <xref:System.Windows.ResourceDictionary>.  
  
 В то же время поиск ресурсов также можно расширить за пределы логического дерева. Для разметки приложения поиск ресурсов можно затем продолжить в словарях ресурсов на уровне приложений, поддержке тем и значениях системы, на которые ссылаются как на статические свойства или ключи. Сами темы также могут ссылаться на системные значения вне логического дерева тем, если ссылки на ресурсы являются динамическими. Дополнительные сведения о словарях ресурсов и логике поиска см. в разделе [Ресурсы XAML](../../../desktop-wpf/fundamentals/xaml-resources-define.md).  
  
## <a name="see-also"></a>См. также раздел

- [Общие сведения о входных данных](input-overview.md)
- [Общие сведения об отрисовке графики в WPF](../graphics-multimedia/wpf-graphics-rendering-overview.md)
- [Общие сведения о перенаправленных событиях](routed-events-overview.md)
- [Инициализация для объектных элементов, которые не находятся в дереве объектов](initialization-for-object-elements-not-in-an-object-tree.md)
- [Архитектура WPF](wpf-architecture.md)
