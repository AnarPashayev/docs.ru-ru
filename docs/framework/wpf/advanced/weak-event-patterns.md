---
title: Шаблоны слабых событий
ms.date: 03/30/2017
helpviewer_keywords:
- weak event pattern implementation [WPF]
- event handlers [WPF], weak event pattern
- IWeakEventListener interface [WPF]
ms.assetid: e7c62920-4812-4811-94d8-050a65c856f6
ms.openlocfilehash: f4cbb22a3cdd7b966c36f6c8246b13b5c58e056d
ms.sourcegitcommit: 005980b14629dfc193ff6cdc040800bc75e0a5a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/14/2019
ms.locfileid: "70991791"
---
# <a name="weak-event-patterns"></a>Шаблоны слабых событий
В приложениях возможно, что обработчики, присоединенные к источникам событий, не будут уничтожены в координации с объектом прослушивателя, который присоединил обработчик к источнику. Такая ситуация может привести к утечке памяти. [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]представляет шаблон проектирования, который можно использовать для решения этой проблемы, предоставляя выделенный класс Manager для конкретных событий и реализуя интерфейс для прослушивателей этого события. Этот шаблон разработки известен как *шаблон слабых событий*.  
  
## <a name="why-implement-the-weak-event-pattern"></a>Зачем реализовывать шаблон слабых событий?  
 Прослушивание событий может привести к утечке памяти. Типичным приемом для прослушивания события является использование синтаксиса, зависящего от языка, который прикрепляет обработчик к событию в источнике. Например, в C#используется следующий синтаксис: `source.SomeEvent += new SomeEventHandler(MyEventHandler)`.  
  
 Этот метод создает строгую ссылку из источника событий в прослушиватель событий. Обычно присоединение обработчика событий для прослушивателя приводит к тому, что прослушиватель имеет время существования объекта, на которое влияет время существования объекта источника (если только обработчик событий не удаляется явным образом). Но в некоторых случаях может потребоваться, чтобы время существования объекта прослушивателя управлялось другими факторами, например, если он принадлежит визуальному дереву приложения, а не времени существования источника. Каждый раз, когда время существования исходного объекта выходит за пределы времени существования объекта прослушивателя, шаблон обычного события приводит к утечке памяти: прослушиватель поддерживается дольше, чем планировалось.  
  
 Шаблон слабых событий предназначен для решения этой проблемы утечки памяти. Шаблон слабых событий можно использовать всякий раз, когда прослушивателю необходимо зарегистрироваться для события, но прослушиватель не знает, когда следует отменять регистрацию. Шаблон слабых событий также можно использовать всякий раз, когда время существования объекта источника превышает полезное время существования объекта прослушивателя. (В этом случае *полезно* определить.) Шаблон слабых событий позволяет прослушивателю регистрироваться и принимать события, не влияя на характеристики времени существования объекта прослушивателя любым способом. Фактически неявная ссылка из источника не определяет, подходит ли прослушиватель для сборки мусора. Ссылка является слабой ссылкой, то есть наименованием шаблона слабых событий и связанных с ним API. Прослушиватель может быть собран или удален сборщиком мусора, и источник можно продолжить без удержания ссылок на Несобираемые обработчики на уже уничтоженный объект.  
  
## <a name="who-should-implement-the-weak-event-pattern"></a>Кто должен реализовывать шаблон слабых событий?  
 Реализация шаблона слабых событий является наиболее интересной в основном для авторов элементов управления. Как автор элемента управления, вы в основном отвечаете за поведение и включение элемента управления и влияние его на приложения, в которых он вставлен. Это включает в себя поведение времени существования управляющего объекта, в частности, обработку описанной проблемы утечки памяти.  
  
 Некоторые сценарии изначально предоставляются для применения шаблона слабых событий. Одним из таких сценариев является привязка данных. В привязке данных обычно исходный объект полностью независим от объекта listener, который является целевым объектом привязки. Многие аспекты [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] привязки данных уже имеют шаблон слабых событий, применяемый в способе реализации событий.  
  
## <a name="how-to-implement-the-weak-event-pattern"></a>Реализация шаблона слабых событий  
 Существует три способа реализации шаблона слабых событий. В следующей таблице перечислены три подхода и приведены некоторые рекомендации по их использованию.  
  
|Подход|Когда следует реализовывать|  
|--------------|-----------------------|  
|Использование существующего класса диспетчера слабых событий|Если событие, на которое нужно подписываться, имеет <xref:System.Windows.WeakEventManager>соответствующее значение, используйте существующий диспетчер слабых событий. Список слабых диспетчеров событий, входящих в состав WPF, см. в разделе Иерархия наследования в <xref:System.Windows.WeakEventManager> классе. Поскольку входящие диспетчеры событий ограничены, вам, вероятно, потребуется выбрать один из других подходов.|  
|Использование универсального класса диспетчера слабых событий|Использовать универсальный <xref:System.Windows.WeakEventManager%602> , если существующий <xref:System.Windows.WeakEventManager> объект недоступен, вы хотите легко реализовать и не беспокоиться об эффективности. Универсальный <xref:System.Windows.WeakEventManager%602> объект менее эффективен, чем существующий или пользовательский диспетчер слабых событий. Например, универсальный класс делает больше отражения для обнаружения события в заданном имени события. Кроме того, код для регистрации события с помощью универсального <xref:System.Windows.WeakEventManager%602> типа является более подробным, чем использование существующего или пользовательского. <xref:System.Windows.WeakEventManager>|  
|Создание пользовательского класса диспетчера слабых событий|Создание настраиваемого <xref:System.Windows.WeakEventManager> объекта, если <xref:System.Windows.WeakEventManager> существующий объект недоступен и требуется лучшая эффективность. Использование настраиваемого <xref:System.Windows.WeakEventManager> объекта для подписки на событие будет более эффективным, однако стоимость написания кода в начале не взимается.|  
|Использование стороннего диспетчера слабых событий|NuGet имеет [несколько диспетчеров слабых событий](https://www.nuget.org/packages?q=weak+event+manager&prerel=false) , а многие платформы WPF также поддерживают шаблон (например, см. [документацию по Prism по слабо связанной подписке на события](https://github.com/PrismLibrary/Prism-Documentation/blob/master/docs/wpf/Communication.md#subscribing-to-events)).|

 В следующих разделах описывается реализация шаблона слабых событий.  В рамках этого обсуждения событие, для которого подписывается, имеет следующие характеристики.  
  
- Имя события — `SomeEvent`.  
  
- Событие вызывается `EventSource` классом.  
  
- Обработчик событий имеет тип: `SomeEventEventHandler` (или `EventHandler<SomeEventEventArgs>`).  
  
- Событие передает параметр типа `SomeEventEventArgs` в обработчики событий.  
  
### <a name="using-an-existing-weak-event-manager-class"></a>Использование существующего класса диспетчера слабых событий  
  
1. Найдите существующий диспетчер слабых событий.  
  
     Список слабых диспетчеров событий, входящих в состав WPF, см. в разделе Иерархия наследования в <xref:System.Windows.WeakEventManager> классе.  
  
2. Используйте новый диспетчер слабых событий вместо обычного подключения к событию.  
  
     Например, если в коде для подписки на событие используется следующий шаблон:  
  
    ```csharp  
    source.SomeEvent += new SomeEventEventHandler(OnSomeEvent);  
    ```  
  
     Измените его на следующий шаблон:  
  
    ```csharp  
    SomeEventWeakEventManager.AddHandler(source, OnSomeEvent);  
    ```  
  
     Аналогично, если в коде используется следующий шаблон для отмены подписки на событие:  
  
    ```csharp  
    source.SomeEvent -= new SomeEventEventHandler(OnSomeEvent);  
    ```  
  
     Измените его на следующий шаблон:  
  
    ```csharp  
    SomeEventWeakEventManager.RemoveHandler(source, OnSomeEvent);  
    ```  
  
### <a name="using-the-generic-weak-event-manager-class"></a>Использование универсального класса диспетчера слабых событий  
  
1. Используйте универсальный <xref:System.Windows.WeakEventManager%602> класс вместо обычной подписки на событие.  
  
     При использовании <xref:System.Windows.WeakEventManager%602> для регистрации прослушивателей событий необходимо указать источник события и <xref:System.EventArgs> тип в качестве параметров типа для класса и вызвать <xref:System.Windows.WeakEventManager%602.AddHandler%2A> , как показано в следующем коде:  
  
    ```csharp  
    WeakEventManager<EventSource, SomeEventEventArgs>.AddHandler(source, "SomeEvent", source_SomeEvent);  
    ```  
  
### <a name="creating-a-custom-weak-event-manager-class"></a>Создание пользовательского класса диспетчера слабых событий  
  
1. Скопируйте следующий шаблон класса в проект.  
  
     Этот класс наследуется от <xref:System.Windows.WeakEventManager> класса.  
  
     [!code-csharp[WeakEvents#WeakEventManagerTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/WeakEvents/CSharp/WeakEventManagerTemplate.cs#weakeventmanagertemplate)]  
  
2. `SomeEventWeakEventManager` Замените имя своим именем.  
  
3. Замените три имени, описанные выше, соответствующими именами для события. (`SomeEvent`, `EventSource`и )`SomeEventEventArgs`  
  
4. Задайте для свойства Visibility (открытый/внутренний/частный) класс диспетчера событий ту же видимость, что и управляемое им событие.  
  
5. Используйте новый диспетчер слабых событий вместо обычного подключения к событию.  
  
     Например, если в коде для подписки на событие используется следующий шаблон:  
  
    ```csharp  
    source.SomeEvent += new SomeEventEventHandler(OnSomeEvent);  
    ```  
  
     Измените его на следующий шаблон:  
  
    ```csharp  
    SomeEventWeakEventManager.AddHandler(source, OnSomeEvent);  
    ```  
  
     Аналогично, если в коде используется следующий шаблон для отмены подписки на событие:  
  
    ```csharp  
    source.SomeEvent -= new SomeEventEventHandler(OnSome);  
    ```  
  
     Измените его на следующий шаблон:  
  
    ```csharp  
    SomeEventWeakEventManager.RemoveHandler(source, OnSomeEvent);  
    ```  
  
## <a name="see-also"></a>См. также

- <xref:System.Windows.WeakEventManager>
- <xref:System.Windows.IWeakEventListener>
- [Общие сведения о перенаправленных событиях](routed-events-overview.md)
- [Общие сведения о привязке данных](../data/data-binding-overview.md)
