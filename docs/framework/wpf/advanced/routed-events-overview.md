---
title: Общие сведения о перенаправленных событиях
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- attached events [WPF]
- grouped button set [WPF]
- routed events [WPF]
- events [WPF], routed
- tunneling [WPF]
- events [WPF], attached
- routing strategies for events [WPF]
- button set [WPF], grouped
- bubbling [WPF]
ms.assetid: 1a2189ae-13b4-45b0-b12c-8de2e49c29d2
ms.openlocfilehash: 24fa283ec0c1fef2023845df0a05c3f1ebf5df06
ms.sourcegitcommit: 24a4a8eb6d8cfe7b8549fb6d823076d7c697e0c6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/23/2019
ms.locfileid: "68400750"
---
# <a name="routed-events-overview"></a>Общие сведения о перенаправленных событиях

В этом разделе описывается понятие перенаправленных событий в [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]. Здесь определяется терминология перенаправленных событий, описывается, как перенаправленные события маршрутизируются через дерево элементов, кратко описываются способы обработки перенаправленных событий, а также способы создания пользовательских перенаправленных событий.

<a name="prerequisites"></a>

## <a name="prerequisites"></a>Предварительные требования

В этом разделе предполагается, что у вас есть базовые знания о среде CLR и объектно-ориентированном программировании, а также понятие о том, как отношения [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] между элементами можно представить в виде дерева. Чтобы выполнить примеры в этом разделе, следует также понимать [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] и знать, как писать простые приложения или страницы [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. Дополнительные сведения см. в разделе [Пошаговое руководство: Мое первое классическое приложение](../getting-started/walkthrough-my-first-wpf-desktop-application.md) WPF и [Общие сведения о XAML (WPF)](xaml-overview-wpf.md).

<a name="routing"></a>

## <a name="what-is-a-routed-event"></a>Что такое перенаправленное событие?

Перенаправленные события можно рассматривать с точки зрения функциональности или реализации. Здесь приводятся оба определения, чтобы пользователи могли выбрать наиболее подходящее для себя.

Функциональное определение: Перенаправленное событие — это тип события, которое может вызывать обработчики для нескольких прослушивателей в дереве элементов, а не только для объекта, вызвавшего событие.

Определение реализации: Перенаправленное событие — это событие CLR, которое поддерживается экземпляром <xref:System.Windows.RoutedEvent> класса и обрабатывается [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] системой событий.

Обычно в приложении [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] содержится много элементов. В зависимости от того, созданы элементы в коде или объявлены в [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], они связаны в дереве элементов друг с другом. Маршрут события может проходить в одном из двух направлений в зависимости от определения события, но обычно маршрут проходит от исходного элемента и затем "всплывает" вверх по дереву элементов до тех пор, пока не достигнет корневого элемента дерева (как правило, страница или окно). Концепция всплывания может быть знакома, если имеется опыт работы с моделью DHTML-объектов.

Рассмотрим следующее простое дерево элементов.

[!code-xaml[EventOvwSupport#GroupButton](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#groupbutton)]

Это дерево элементов выглядит примерно следующим образом.

![Кнопки "Да", "Нет" и "Отмена"](./media/routedevent-ovw-1.gif "RoutedEvent_ovw_1")

В этом упрощенном дереве элементов источником <xref:System.Windows.Controls.Primitives.ButtonBase.Click> события является один <xref:System.Windows.Controls.Button> из элементов, а в зависимости от того, <xref:System.Windows.Controls.Button> какой элемент был нажат, первым элементом, который имеет возможность справиться с событием. Но если к событию не прикрепляется <xref:System.Windows.Controls.Button> обработчик, то событие будет перенаправлено вверх <xref:System.Windows.Controls.Button> к родительскому элементу в <xref:System.Windows.Controls.StackPanel>дереве элементов, то есть. Потенциально событие переносится в <xref:System.Windows.Controls.Border>, а затем выходит в корень страницы дерева элементов (не показано).

Иными словами, маршрут события для этого <xref:System.Windows.Controls.Primitives.ButtonBase.Click> события:

Button-->StackPanel-->Border-->...

### <a name="top-level-scenarios-for-routed-events"></a>Сценарии верхнего уровня для перенаправленных событий

Ниже приведен краткий обзор сценариев, которые послужили концепцией перенаправленных событий, и почему стандартное событие CLR не было достаточным для этих сценариев:

**Композиция элементов управления и инкапсуляция:** Различные элементы управления [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] в имеют обширную модель содержимого. Например, можно поместить изображение в <xref:System.Windows.Controls.Button>, которое эффективно расширяет визуальное дерево кнопки. Однако добавленное изображение не должно прерывать проверку попадания, которая вызывает реакцию <xref:System.Windows.Controls.Primitives.ButtonBase.Click> кнопки на ее содержимое, даже если пользователь щелкает Пиксели, которые технически являются частью изображения.

**Точки вложенности единственного обработчика:** В [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)]для обработки событий, которые могут быть вызваны из нескольких элементов, необходимо несколько раз присоединить один и тот же обработчик. Перенаправленные события позволяют присоединить обработчик только один раз, как было показано в предыдущем примере, и при необходимости использовать логику обработки для определения места возникновения события. Например, это может быть обработчиком для ранее показанного [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].

[!code-csharp[EventOvwSupport#GroupButtonCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#groupbuttoncodebehind)]
[!code-vb[EventOvwSupport#GroupButtonCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#groupbuttoncodebehind)]

**Обработка класса:** Перенаправленные события разрешает статический обработчик, определяемый классом. Этот обработчик классов может обрабатывать событие раньше любого вложенного обработчика экземпляров.

**Ссылка на событие без отражения:** Для определенных методов кода и разметки требуется способ обнаружения определенного события. Перенаправленное событие создает <xref:System.Windows.RoutedEvent> поле в виде идентификатора, которое предоставляет надежный метод идентификации событий, не требующий статического отражения или отражение во время выполнения.

### <a name="how-routed-events-are-implemented"></a>Реализация перенаправленных событий

Перенаправленное событие — это событие CLR, которое поддерживается экземпляром <xref:System.Windows.RoutedEvent> класса и регистрируется [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] в системе событий. Экземпляр, полученный из регистрации, обычно `static` сохраняется `readonly` `public` как элемент поля класса, который регистрирует и, таким образом, "владеет" перенаправленным событием. <xref:System.Windows.RoutedEvent> Соединение с событием CLR с одинаковым именем (которое иногда называется "оболочкой") достигается путем переопределения `add` реализаций и `remove` для события CLR. Как правило, `add` и `remove` остаются неявными по умолчанию и используют соответствующий синтаксис события определенного языка для добавления и удаления обработчиков события. Механизм резервного копирования и подключения перенаправленных событий концептуально похож на то, как свойство зависимостей является свойством CLR, которое поддерживается <xref:System.Windows.DependencyProperty> классом и регистрируется [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] в системе свойств.

В следующем примере показано объявление пользовательского `Tap` перенаправленного события, включая регистрацию и раскрытие <xref:System.Windows.RoutedEvent> поля `remove` идентификатора, а также `add` реализаций для `Tap` события CLR.

[!code-csharp[RoutedEventCustom#AddRemoveHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#addremovehandler)]
[!code-vb[RoutedEventCustom#AddRemoveHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#addremovehandler)]

### <a name="routed-event-handlers-and-xaml"></a>Обработчики перенаправленных событий и XAML

Чтобы добавить обработчик для события с помощью [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], следует объявить имя события как атрибут для элемента, который является прослушивателем событий. Значением атрибута является имя метода реализуемого обработчика, который должен существовать в разделяемом классе файла кода программной части.

[!code-xaml[EventOvwSupport#SimplestSyntax](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#simplestsyntax)]

[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] Синтаксис для добавления стандартных обработчиков событий среды CLR аналогичен для добавления обработчиков перенаправленных событий, так как вы действительно добавляете обработчики в оболочку событий CLR, которая имеет реализацию перенаправленного события. Дополнительные сведения о добавлении обработчиков событий в [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] см. в разделе [Общие сведения о языке XAML (WPF)](xaml-overview-wpf.md).

<a name="routing_strategies"></a>

## <a name="routing-strategies"></a>Стратегии маршрутизации

Перенаправленные события используют одну из трех стратегий маршрутизации.

- **Восходящей маршрутизации** Вызываются обработчики событий в источнике события. Перенаправленное событие затем следует к родительским элементам до достижения корневого элемента дерева. Большинство перенаправленных событий используют стратегию восходящей маршрутизации. События восходящей маршрутизации обычно используются для получения отчета об изменении входных данных или состояния от различных элементов управления или других элементов пользовательского интерфейса.

- **Направлений** Только сам исходный элемент получает возможность вызывать обработчики в ответе. Это является аналогом "маршрутизации", которая используется [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] для события. Однако, в отличие от стандартного события CLR, прямые перенаправленные события поддерживают обработку классов (обработка классов объясняется в следующем разделе) и может использоваться <xref:System.Windows.EventSetter> и. <xref:System.Windows.EventTrigger>

- **Туннелирование** Изначально вызываются обработчики событий в корне дерева элементов. Перенаправленное событие затем передается по маршруту через последовательные дочерние элементы к узловому элементу, который является источником перенаправленного события (элементом, вызвавшим перенаправленное событие). Нисходящая маршрутизация событий часто используется или обрабатывается как часть композиции для элемента управления таким образом, что события из составных частей композиции могут намеренно подавляться или заменяться событиями, которые определены для полного контроля. Входные события, которые содержатся в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], часто реализуются в виде пары нисходящей и восходящей маршрутизации. События нисходящей маршрутизации также иногда называют событиями предварительного просмотра по причине используемого для пар соглашения об именах.

<a name="why_use"></a>

## <a name="why-use-routed-events"></a>Зачем использовать перенаправленные события?

Разработчикам приложений не всегда необходимо знать, реализуется ли обрабатываемое событие как перенаправленное. Перенаправленные события имеют особое поведение, но такое событие остается невидимым, если обрабатывается в элементе, где оно возникает.

Перенаправленные события являются мощным инструментом при использовании их в одном из предлагаемых сценариев: при определении общих обработчиков для общего корня, при композиции собственного элемента управления или при определении собственного класса пользовательского элемента управления.

Прослушиватели перенаправленных событий и источники перенаправленных событий не требуются для совместного использования общего события в их иерархии. Any <xref:System.Windows.UIElement> или<xref:System.Windows.ContentElement> может быть прослушивателем событий для любого перенаправленного события. Таким образом, можно использовать полный набор перенаправленных событий, доступных во всем рабочем наборе API в качестве концептуального "интерфейса", благодаря которому разнородные элементы в приложении могут обмениваться данными о событиях. Эта концепция "интерфейса" для перенаправленных событий особенно применима для событий ввода.

Перенаправленные события могут также использоваться для связи элементов дерева, так как данные событий сохраняются для каждого элемента в маршруте. Один элемент может изменить что-либо в данных события, и это изменение будет доступно для следующего элемента в маршруте.

В отличие от маршрутизации, существует еще две причины, по которым любое заданное [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] событие может быть реализовано в виде перенаправленного события вместо стандартного события CLR. При реализации собственных событий рекомендуется учитывать приведенные далее принципы.

- Некоторые [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] функции стилизации и создания шаблонов <xref:System.Windows.EventSetter> , <xref:System.Windows.EventTrigger> такие как и, занимают событие, на которое указывает ссылка, как перенаправленное событие. Это сценарий идентификатора события, упомянутого выше.

- Перенаправленные события поддерживают механизм обработки классов, в силу чего класс может указывать статические методы, имеющие возможность обрабатывать перенаправленные события до того, как любой зарегистрированный обработчик экземпляров сможет получить к ним доступ. Это очень полезно при разработке элемента управления, поскольку класс может управляться с помощью событий, что не может быть случайно подавлено обработкой события в экземпляре.

Каждое из описанных выше рассуждений рассматривается в отдельной части этого раздела.

<a name="event_handing"></a>

## <a name="adding-and-implementing-an-event-handler-for-a-routed-event"></a>Добавление и реализация обработчика событий для перенаправленного события

Чтобы добавить обработчик событий в [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], просто добавьте имя события в элемент как атрибут и установите значение атрибута в качестве имени обработчика событий, который реализует соответствующий делегат, как показано в следующем примере.

[!code-xaml[EventOvwSupport#SimplestSyntax](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#simplestsyntax)]

`b1SetColor`имя реализованного обработчика, содержащего код, обрабатывающий <xref:System.Windows.Controls.Primitives.ButtonBase.Click> событие. `b1SetColor`должен иметь такую же сигнатуру, <xref:System.Windows.RoutedEventHandler> что и делегат, который является делегатом обработчика <xref:System.Windows.Controls.Primitives.ButtonBase.Click> событий для события. Первый параметр всех делегатов обработчиков перенаправленных событий указывает элемент, к которому добавляется обработчик событий, а второй параметр указывает данные для события.

[!code-csharp[EventOvwSupport#SimpleHandlerA](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#simplehandlera)]
[!code-vb[EventOvwSupport#SimpleHandlerA](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#simplehandlera)]

<xref:System.Windows.RoutedEventHandler>является базовым делегатом обработчика перенаправленных событий. Для перенаправленных событий, которые являются специализированными для определенных элементов управления или скриптов, делегаты, которые используются для обработчиков перенаправленных событий, также могут быть более специализированными, чтобы они могли передавать определенные данные события. Например, в общем сценарии ввода может быть обработано <xref:System.Windows.UIElement.DragEnter> перенаправленное событие. Обработчик должен реализовать <xref:System.Windows.DragEventHandler> делегат. Используя наиболее конкретный делегат, можно обработать <xref:System.Windows.DragEventArgs> в обработчике и <xref:System.Windows.DragEventArgs.Data%2A> прочитать свойство, которое содержит полезные данные буфера обмена операции перетаскивания.

Полный пример добавления обработчика событий к элементу с помощью [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] см. в разделе [Обработка перенаправленных событий](how-to-handle-a-routed-event.md).

Добавить обработчик для перенаправленного события в приложении, созданном в коде, достаточно просто. Обработчики перенаправленных событий всегда можно добавлять с помощью вспомогательного метода <xref:System.Windows.UIElement.AddHandler%2A> (который является тем же методом, для `add`которого существуют резервные вызовы.) Однако существующие перенаправленные события  [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] обычно имеют резервную реализацию `add` и логику `remove`, позволяющую добавлять обработчики перенаправленных событий с помощью синтаксиса событий для определенного языка, являющегося более понятным, чем вспомогательный метод. Ниже приведен пример использования вспомогательного метода.

[!code-csharp[EventOvwSupport#AddHandlerCode](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#addhandlercode)]
[!code-vb[EventOvwSupport#AddHandlerCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#addhandlercode)]

В следующем примере показан синтаксис C# оператора (Visual Basic несколько отличается синтаксисом оператора из-за его обработки разыменованием):

[!code-csharp[EventOvwSupport#AddHandlerPlusEquals](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#addhandlerplusequals)]
[!code-vb[EventOvwSupport#AddHandlerPlusEquals](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#addhandlerplusequals)]

Пример добавления обработчика событий в коде см. в разделе [Добавление обработчика событий с помощью кода](how-to-add-an-event-handler-using-code.md).

Если вы используете Visual Basic, можно также использовать `Handles` ключевое слово для добавления обработчиков в составе объявлений обработчика. Дополнительные сведения см. в разделе [Обработка событий в Visual Basic и WPF](visual-basic-and-wpf-event-handling.md).

<a name="concept_handled"></a>

### <a name="the-concept-of-handled"></a>Концепция обработанных событий

Все перенаправленные события совместно используют общий базовый класс данных событий <xref:System.Windows.RoutedEventArgs>,. <xref:System.Windows.RoutedEventArgs><xref:System.Windows.RoutedEventArgs.Handled%2A> определяет свойство, принимающее логическое значение. Свойство предназначено для включения любого обработчика событий на маршруте, чтобы пометить перенаправленное событие как *обработанное*, <xref:System.Windows.RoutedEventArgs.Handled%2A> задав для `true`параметра значение. <xref:System.Windows.RoutedEventArgs.Handled%2A> После обработки обработчиком в одном элементе в маршруте совместно используемые данные события снова предоставляются каждому прослушивателю в маршруте.

Значение <xref:System.Windows.RoutedEventArgs.Handled%2A> влияет на то, как перенаправленное событие сообщается или обрабатывается, когда оно перемещается дальше вдоль маршрута. Если <xref:System.Windows.RoutedEventArgs.Handled%2A> параметр `true` находится в данных события для перенаправленного события, то обработчики, которые прослушивают перенаправленное событие для других элементов, обычно больше не вызываются для этого конкретного экземпляра события. Это справедливо как для обработчиков, присоединенных к [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], так и для обработчиков, добавленных с помощью синтаксиса присоединения обработчика событий конкретного языка, например `+=` или `Handles`. Для наиболее распространенных сценариев обработчика Пометка события как обработанного путем <xref:System.Windows.RoutedEventArgs.Handled%2A> установки `true` параметра в значение будет "прекращать" маршрутизацию для маршрута туннелирования или для восходящей маршрутизации, а также для любого события, которое обрабатывается в точке в маршруте обработчиком класса.

Однако существует механизм "handledEventsToo", при котором прослушиватели по-прежнему могут запускать обработчики в ответ на перенаправляемые события, где <xref:System.Windows.RoutedEventArgs.Handled%2A> находится `true` в данных события. Другими словами, маршрут события в действительности не останавливается при пометке события в данных события как обработанного. Механизм handledEventsToo можно использовать только в коде или в <xref:System.Windows.EventSetter>:

- В коде вместо использования синтаксиса событий, зависящего от языка, который работает для общих событий CLR, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] вызовите <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> метод, чтобы добавить обработчик. Задайте для `handledEventsToo` значение `true`.

- В присвойте атрибуту `true`значение. <xref:System.Windows.EventSetter.HandledEventsToo%2A> <xref:System.Windows.EventSetter>

В дополнение к поведению, <xref:System.Windows.RoutedEventArgs.Handled%2A> которое получается в перенаправленных событиях, <xref:System.Windows.RoutedEventArgs.Handled%2A> концепция имеет влияние на то, как следует проектировать приложение и написать код обработчика событий. Можно концептуализировать <xref:System.Windows.RoutedEventArgs.Handled%2A> как простой протокол, предоставляемый перенаправленными событиями. Именно вы используете этот протокол, но концептуальное проектирование того, как предполагается использовать значение <xref:System.Windows.RoutedEventArgs.Handled%2A> , выглядит следующим образом:

- Если перенаправленное событие помечено как обработанное, то затем его не требуется снова обрабатывать другими элементами в маршруте.

- Если перенаправленное событие не помечено как обработанное, то другие прослушиватели, ранее находились в маршруте, отказались от регистрации обработчика, или обработчики, которые были зарегистрированы, отказались `true`от обработки данных события и присвоить параметру значение <xref:System.Windows.RoutedEventArgs.Handled%2A> . (Или, возможно, текущий прослушиватель является первой точкой в маршруте.) Обработчики на текущем прослушивателе имеют три возможных варианта действий.

  - Не выполнять никаких действий. Событие остается необработанным и переходит к следующему прослушивателю.

  - Выполнить код в ответ на событие, при этом убедиться, что выполненное действие не было достаточно существенным, чтобы пометить событие как обработанное. Событие перенаправляется к следующему прослушивателю.

  - Выполнить кода в ответ на событие. Пометить событие как обработанное в данных события, передаваемых обработчику, потому что предпринятое действие считается достаточно существенным, чтобы пометить событие как обработанное. Событие все еще перенаправляется к следующему прослушивателю, <xref:System.Windows.RoutedEventArgs.Handled%2A> но с = `true` его данными событий, поэтому `handledEventsToo` только прослушиватели имеют возможность вызывать дополнительные обработчики.

Этот концептуальный проект усиливается описанным выше поведением маршрутизации: более сложная (хотя и возможно в коде или стилях) присоединение обработчиков для перенаправленных событий, которые вызываются, даже если предыдущий обработчик маршрута уже задан <xref:System.Windows.RoutedEventArgs.Handled%2A>. в`true`.

Дополнительные сведения об <xref:System.Windows.RoutedEventArgs.Handled%2A>обработке классов перенаправленных событий и рекомендации о том, когда нужно пометить перенаправленное событие как <xref:System.Windows.RoutedEventArgs.Handled%2A>, см. в разделе Маркировка перенаправленных [событий как обработанных и обработка классов](marking-routed-events-as-handled-and-class-handling.md).

В приложениях весьма распространена обработка только перенаправляемого по восходящей события в объекте, который вызывал его, независимо от характеристик маршрутизации события. Однако все же рекомендуется помечать перенаправленное событие как обработанное в данных события, чтобы избежать непредвиденных побочных эффектов на случай, если элемент, который далее следует в дереве элементов, имеет вложенный обработчик для этого же перенаправленного события.

<a name="class_handlers"></a>

## <a name="class-handlers"></a>Обработчики классов

При определении класса, который является каким-то образом производным от <xref:System.Windows.DependencyObject>, можно также определить и присоединить обработчик класса для перенаправленного события, которое является объявленным или унаследованным членом события класса. Обработчики классов вызываются ранее любого обработчика прослушивателей экземпляров, присоединенного к экземпляру этого класса, всякий раз, когда перенаправленное событие встречает экземпляр элемента в своем маршруте.

Некоторые элементы управления [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] имеют внутреннюю обработку классов для некоторых перенаправленных событий. Может показаться, что перенаправленное событие не возникает никогда, но на самом деле оно обрабатывается классом и перенаправленное событие по-прежнему может потенциально обрабатываться с помощью обработчиков экземпляров при использовании определенных методов. Кроме того, многие базовые классы и элементы управления предоставляют виртуальные методы, которые могут быть использованы для переопределения поведения при обработке классов. Дополнительные сведения о том, как обрабатывать нежелательные классы и как определить обработку собственного класса в пользовательском классе, см. в разделе [Маркировка перенаправленных событий как обработанных и обработка классов](marking-routed-events-as-handled-and-class-handling.md).

<a name="attached_events"></a>

## <a name="attached-events-in-wpf"></a>Вложенные события в WPF

[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] также определяет специальный тип события, называемого *вложенным событием*. Вложенное событие позволяет добавлять обработчик для конкретного события в произвольный элемент. Элементу, обрабатывающему событие, не требуется определять или наследовать вложенное событие, и ни объект, который потенциально может вызвать событие, ни экземпляр обработки места назначения не должны определять или каким-либо иным способом владеть этим событием в качестве элемента класса.

Система ввода [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] широко использует вложенные события. Однако практически все эти вложенные события перенаправляются через базовые элементы. События ввода затем отображаются как эквивалент невложенных перенаправленных событий, которые являются членами класса базового элемента. Например, базовое присоединенное событие <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> может быть проще обработано в любом <xref:System.Windows.UIElement> заданном <xref:System.Windows.UIElement.MouseDown> с помощью <xref:System.Windows.UIElement> , вместо того чтобы обрабатываться с помощью синтаксиса вложенных событий в [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] коде или.

Дополнительные сведения о вложенных событиях в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] см. в разделе [Общие сведения о вложенных событиях](attached-events-overview.md).

<a name="Qualifying_Event_Names_in_XAML_for_Anticipated_Routing"></a>

## <a name="qualified-event-names-in-xaml"></a>Полные имена событий в XAML

Другой синтаксис напоминает синаксис *typename*. *EventName* вложенного события, но он не является синтаксисом вложенного события при присоединении обработчиков для перенаправленных событий, вызываемых дочерними элементами. Обработчики присоединяются в общем родительском элементе, чтобы воспользоваться преимуществами маршрутизации событий, несмотря на то что общий родительский элемент может не иметь соответствующего перенаправленного события в качестве члена. Рассмотрим этот пример еще раз.

[!code-xaml[EventOvwSupport#GroupButton](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#groupbutton)]

Здесь прослушиватель родительского элемента, в который добавляется обработчик, — <xref:System.Windows.Controls.StackPanel>это. Однако он добавляет обработчик для перенаправленного события, которое было объявлено и будет вызываться <xref:System.Windows.Controls.Button> классом (<xref:System.Windows.Controls.Primitives.ButtonBase> <xref:System.Windows.Controls.Button> фактически, но доступно через наследование). <xref:System.Windows.Controls.Button>"владеет" событием, но система перенаправленных событий позволяет обработчикам любого перенаправленного события прикрепляться к <xref:System.Windows.UIElement> любому <xref:System.Windows.ContentElement> прослушивателю экземпляра, который в противном случае может присоединить прослушиватели для события среды CLR. Пространством имен xmlns по умолчанию для этих полных имен атрибутов событий обычно является пространство имен xmlns [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] по умолчанию, но можно также указать префиксные пространства имен для пользовательских перенаправленных событий. Дополнительные сведения о xmlns см. в разделе [Пространства имен XAML и сопоставление пространств имен для WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).

<a name="how_event_processing_works"></a>

## <a name="wpf-input-events"></a>События ввода WPF

Перенаправленные события в платформе [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] часто применяются для событий ввода. В [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] имена перенаправляемых по нисходящей событий по соглашению указываются с префиксом Preview. События ввода часто возникают попарно, одно маршрутизируется по восходящей, другое — по нисходящей. Например, <xref:System.Windows.ContentElement.KeyDown> событие <xref:System.Windows.ContentElement.PreviewKeyDown> и событие имеют одинаковую сигнатуру, первый из которых является восходящей событием ввода, а второй — событием ввода с нисходящей маршрутизацией. Иногда события ввода имеют только восходящую или, возможно, только прямую маршрутизацию. В документации в разделах, посвященных перенаправленным событиям, содержатся перекрестные ссылки на аналогичные перенаправленные события с альтернативной стратегией маршрутизации, если такие перенаправленные события существуют, и ссылки на разделы документации для уточнения стратегии маршрутизации каждого перенаправленного события.

События ввода [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], возникающие попарно, реализуются таким образом, что одно действие пользователя из входных данных, такое как нажатие кнопки мыши, последовательно вызовет оба перенаправленные события пары. Сначала вызывается событие, которое маршрутизируется по нисходящей. Затем вызывается событие, которое маршрутизируется по восходящей. Эти два события буквально используют один и тот же экземпляр данных события, <xref:System.Windows.UIElement.RaiseEvent%2A> так как вызов метода в реализующем классе, вызывающем событие восходящей маршрутизации, прослушивает данные события из события туннелирования и повторно использует их в новом вызванном событии. Прослушиватели с обработчиками для события, маршрутизирующегося по нисходящей, могут первыми пометить перенаправленное событие как обработанное (сначала обработчики классов, затем обработчики экземпляров). Если элемент при нисходящей маршрутизации отметил перенаправленное событие как обработанное, уже обработанные данные события отправляются для события, маршрутизирующегося по восходящей, и типичные обработчики, вложенные для эквивалентных маршрутизируемых по восходящей событий, не будут вызываться. Внешне это будет выглядеть так, как будто обработанное маршрутизируемое по восходящей событие и не вызывалось. Поведение при обработке полезно использовать при композиции элементов управления, где требуется, чтобы конечный элемент управления (а не его составные части) создавал отчеты о событиях проверки нажатия при вводе или событиях ввода на основе фокуса. Конечный элемент управления находится ближе к корневому элементу в композиции и поэтому имеет возможность обработать событие, передаваемое по нисходящей, первым и, возможно, "заменить" это перенаправленное событие более подходящим для данного элемента управления как часть кода, которая резервирует класс элемента управления.

В качестве иллюстрации того, как обрабатываются события ввода, рассмотрим следующий пример. На следующем рисунке `leaf element #2` дерева является источником `PreviewMouseDown` `MouseDown` события а, а затем —.

![Схема маршрутизации события](./media/routed-events-overview/input-event-routing.png)

Порядок обработки событий выглядит следующим образом.

1. `PreviewMouseDown` (нисходящее) на корневом элементе.

2. `PreviewMouseDown` (нисходящее) на промежуточном элементе № 1.

3. `PreviewMouseDown` (нисходящее) на исходном элементе № 2.

4. `MouseDown` (всплывающее) на исходном элементе № 2.

5. `MouseDown` (всплывающее) на промежуточном элементе № 1.

6. `MouseDown` (всплывающее) на корневом элементе.

Делегат обработчика перенаправленных событий содержит ссылки на два объекта: объект, который вызвал событие, и объект, в котором был вызван обработчик. Объект, в котором был вызван обработчик, указывается с помощью параметра `sender`. Объект, в котором событие было впервые вызвано <xref:System.Windows.RoutedEventArgs.Source%2A> свойством в данных события. Перенаправленное событие по-прежнему может создаваться и обрабатываться одним и тем же объектом `sender` . <xref:System.Windows.RoutedEventArgs.Source%2A> в этом случае и идентичны (это происходит в шагах 3 и 4 в списке "пример обработки событий").

В <xref:System.Windows.RoutedEventArgs.Source%2A> связи с туннелированием и восходящей маршрутизацией родительские элементы получают входные события, где является одним из их дочерних элементов. Когда важно знать, что представляет собой исходный элемент, можно определить исходный элемент, обратившись к <xref:System.Windows.RoutedEventArgs.Source%2A> свойству.

Как правило, после пометки <xref:System.Windows.RoutedEventArgs.Handled%2A>события ввода дополнительные обработчики не вызываются. Обычно события ввода помечаются как обработанные сразу же после вызова обработчика, который при обработке события ввода опирается на логику приложения.

Исключением из этой общей инструкции о <xref:System.Windows.RoutedEventArgs.Handled%2A> состоянии является то, что обработчики событий ввода, зарегистрированные для намеренного пропуска <xref:System.Windows.RoutedEventArgs.Handled%2A> состояния данных события, будут по-прежнему вызываться по маршруту. Дополнительные сведения см. в разделах [События предварительного просмотра](preview-events.md) или [Маркировка перенаправленных событий как обработанных и обработка классов](marking-routed-events-as-handled-and-class-handling.md).

Модель общего использования данных события при нисходящей и восходящей маршрутизации и последовательный вызов сначала нисходящих, а потом всплывающих событий не обязательно выполняются для всех перенаправленных событий. Такое поведение реализуется в зависимости от того, как устройства ввода [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] вызывают или соединяют пары событий ввода. Дополнительным сценарием является реализация собственных событий ввода, но эту модель также можно реализовывать для собственных событий ввода.

В определенных классах обработка классов используется для определенных событий ввода, как правило, с целью переопределения значения событий ввода, вызываемых пользователем, и вызова новых событий. Дополнительные сведения см. в разделе [Маркировка перенаправленных событий как обработанных и обработка классов](marking-routed-events-as-handled-and-class-handling.md).

Дополнительные сведения о вводе данных и о том, как ввод данных и события взаимодействуют в обычных сценариях приложения, см. в разделе [Общие сведения о входных данных](input-overview.md).

<a name="events_styles"></a>

## <a name="eventsetters-and-eventtriggers"></a>EventSetters и EventTriggers

В стилях можно включить некоторые предварительно объявленные [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] синтаксисы обработки событий в разметку <xref:System.Windows.EventSetter>с помощью. При применении стиля указанный обработчик добавляется в экземпляр стиля. Можно объявить <xref:System.Windows.EventSetter> только для перенаправленного события. Пример. Обратите внимание, что указанный метод `b1SetColor` находится в файле кода программной части.

[!code-xaml[EventOvwSupport#XAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml#xaml2)]

Преимущество этого подхода состоит в том, что стиль, скорее всего, будет содержать значительную часть других сведений, которые могут <xref:System.Windows.EventSetter> быть применены к любой кнопке в приложении, и наличие части этого стиля способствует повторному использованию кода даже на уровне разметки. Кроме того, <xref:System.Windows.EventSetter> абстрактные имена методов для обработчиков поочередно изменяются от общего разметки приложения и страницы.

Другим специализированным синтаксисом, объединяющим функции [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] перенаправленного события и анимации, <xref:System.Windows.EventTrigger>является. Как и <xref:System.Windows.EventSetter>в случае, <xref:System.Windows.EventTrigger>для можно использовать только перенаправленные события. Как правило, <xref:System.Windows.EventTrigger> выражение объявляется как часть стиля, <xref:System.Windows.EventTrigger> но также может быть объявлено в <xref:System.Windows.FrameworkElement.Triggers%2A> элементах уровня страницы как часть коллекции или в <xref:System.Windows.Controls.ControlTemplate>. Позволяет указать, который запускается каждый раз, когда перенаправленное событие достигает элемента в его <xref:System.Windows.EventTrigger> маршруте, который объявляет для этого события. <xref:System.Windows.Media.Animation.Storyboard> <xref:System.Windows.EventTrigger> Преимущество <xref:System.Windows.EventTrigger> обработки события и его запуск существующей раскадровки заключается в <xref:System.Windows.EventTrigger> том, что обеспечивает лучший контроль над раскадровкой и ее поведение во время выполнения. Дополнительные сведения см. в разделе [Использование триггеров событий для управления раскадровкой после ее запуска](../graphics-multimedia/how-to-use-event-triggers-to-control-a-storyboard-after-it-starts.md).

<a name="more_about"></a>

## <a name="more-about-routed-events"></a>Дополнительные сведения о перенаправленных событиях

В этом разделе перенаправленные события рассматриваются, главным образом, с точки зрения описания основных понятий. Также приводится руководство по тому, как и когда следует отвечать на перенаправляемые события, которые уже существуют в различных базовых элементах и элементах управления. Однако можно создать собственное перенаправленное событие на пользовательском классе вместе со всей необходимой поддержкой, такой как особые для этого события классы данных и делегаты. Владельцем перенаправленного события может быть любой класс, но перенаправленные события должны быть вызваны и обработаны <xref:System.Windows.UIElement> <xref:System.Windows.ContentElement> производными классами, чтобы быть полезными. Дополнительные сведения о пользовательских событиях см. в разделе [Создание пользовательских событий маршрутизации](how-to-create-a-custom-routed-event.md).

## <a name="see-also"></a>См. также

- <xref:System.Windows.EventManager>
- <xref:System.Windows.RoutedEvent>
- <xref:System.Windows.RoutedEventArgs>
- [Маркировка перенаправленных событий как обработанных и обработка классов](marking-routed-events-as-handled-and-class-handling.md)
- [Общие сведения о входных данных](input-overview.md)
- [Общие сведения о системе команд](commanding-overview.md)
- [Пользовательские свойства зависимостей](custom-dependency-properties.md)
- [Деревья в WPF](trees-in-wpf.md)
- [Шаблоны слабых событий](weak-event-patterns.md)
