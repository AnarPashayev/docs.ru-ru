---
title: Проверка и обратные вызовы свойства зависимостей
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- dependency properties [WPF], validation
- coerce value callbacks [WPF]
- callbacks [WPF], validation
- dependency properties [WPF], callbacks
- validation of dependency properties [WPF]
ms.assetid: 48db5fb2-da7f-49a6-8e81-3540e7b25825
ms.openlocfilehash: 7f00961ba100700c68936cc33facfdc758c77d3f
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/22/2019
ms.locfileid: "69940827"
---
# <a name="dependency-property-callbacks-and-validation"></a>Проверка и обратные вызовы свойства зависимостей
В этом разделе описывается создание свойства зависимостей с помощью альтернативных пользовательских реализаций функций, связанных со свойствами, таких как определение проверки, обратные вызовы, которые совершаются при каждом изменении эффективного значения свойства, и переопределение возможных внешних влияний на определение значения. В этом разделе также рассматриваются сценарии, в которых подходит расширение стандартных правил для системы свойств с помощью этих методов.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Предварительные требования  
 В этом разделе предполагается, что вы понимаете основные сценарии реализации свойства зависимостей и способы применения метаданных к настраиваемому свойству зависимостей. Дополнительные сведения см. в разделах [Пользовательские свойства зависимостей](custom-dependency-properties.md) и [Метаданные свойства зависимостей](dependency-property-metadata.md).  
  
<a name="Validation_Callbacks"></a>   
## <a name="validation-callbacks"></a>Обратные вызовы проверки  
 Обратные вызовы проверки можно назначить свойству зависимостей при первой регистрации. Обратный вызов проверки не является частью метаданных свойства. Это прямой ввод <xref:System.Windows.DependencyProperty.Register%2A> метода. Поэтому после того, как будет создан обратный вызов проверки для свойства зависимостей, он уже не может быть переопределен новой реализацией.  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 Обратные вызовы реализуются так, что они получают значение объекта. Они возвращают `true`, если полученное значение является допустимым для свойства. В противном случае — возвращают `false`. Предполагается, что свойство принадлежит допустимому типу (зарегистрированному в системе свойств), поэтому проверка типов в обратных вызовах обычно не выполняется. Обратные вызовы используются системой свойств в различных операциях. Сюда входит начальная инициализация типа по умолчанию, программное изменение путем <xref:System.Windows.DependencyObject.SetValue%2A>вызова или попытка переопределить метаданные новым значением по умолчанию. Если обратный вызов проверки совершается любой из этих операций и возвращает `false`, вызывается исключение. Программисты должны быть готовы обрабатывать эти исключения. Обычно обратные вызовы проверки используются для проверки значений перечислений или для ограничения значений целых чисел, когда это свойство задает измерения, которые должны быть больше или равны нулю.  
  
 Обратные вызовы проверки специально предназначены для проверки классов, а не экземпляров классов. Параметры обратного вызова не обмениваются данными <xref:System.Windows.DependencyObject> , для которых заданы свойства для проверки. Поэтому обратные вызовы проверки не используются для принудительного применения возможных "зависимостей", способных повлиять на значение свойства, где значение свойства для этого экземпляра зависит от таких факторов, как значения других свойств этого экземпляра или состояния во время выполнения.  
  
 Ниже приведен пример кода для очень простого сценария обратного вызова проверки: Проверка того, что свойство, типизированное как <xref:System.Double> примитив, не <xref:System.Double.PositiveInfinity> имеет <xref:System.Double.NegativeInfinity>значение или.  
  
 [!code-csharp[DPCallbackOverride#ValidateValueCallback](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#validatevaluecallback)]
 [!code-vb[DPCallbackOverride#ValidateValueCallback](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#validatevaluecallback)]  
  
<a name="Coerce_Value_Callbacks_and_Property_Changed_Events"></a>   
## <a name="coerce-value-callbacks-and-property-changed-events"></a>Обратные вызовы с привязкой к значению и события изменения свойств  
 Обратные вызовы приводимых значений передают <xref:System.Windows.DependencyObject> конкретный экземпляр свойству, <xref:System.Windows.PropertyChangedCallback> как и реализации, которые вызываются системой свойств при каждом изменении значения свойства зависимостей. Используя сочетание этих обратных вызовов, можно создать ряд свойств элементов, где изменения значения одного свойства будут вызывать принудительное изменение или пересчет значения другого свойства.  
  
 Вот типичный сценарий использования связки свойств зависимостей. Имеется свойство, управляемое пользовательским интерфейсом. Элемент содержит по одному свойству для минимального и максимального значений и третье свойство для фактического или текущего значения. Если максимальное значение будет изменено так, что текущее значение станет превышать это новое максимальное значение, следует изменить текущее значение, сделав его не более максимального. Аналогичная связь нужна и для минимального значения.  
  
 Ниже приведен пример очень краткого кода для одного из трех свойств зависимостей, иллюстрирующий эту связь. В примере показано, как регистрируется свойство `CurrentReading` для набора связанных свойств (максимальное, минимальное, текущее) объекта *Reading. Он использует проверку, как это показано в предыдущем разделе.  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 Обратный вызов при изменении свойства текущего объекта используется для пересылки изменений в другие зависимые свойства путем явного выполнения обратных вызовов с привязкой к значению, зарегистрированных для этих свойств.  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 При выполнении обратных вызовов с привязкой к значению проверяются значения свойств, от которых потенциально зависит текущее свойство, и принудительно изменяется его значение при необходимости.  
  
 [!code-csharp[DPCallbackOverride#CoerceCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#coercecurrent)]
 [!code-vb[DPCallbackOverride#CoerceCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#coercecurrent)]  
  
> [!NOTE]
> Значения свойств по умолчанию не изменяются. Значение свойства, равное значению по умолчанию, может возникать, если значение свойства по-прежнему имеет начальное значение по <xref:System.Windows.DependencyObject.ClearValue%2A>умолчанию или с помощью очистки других значений с.  
  
 Обратные вызовы с привязкой к значению и обратные вызовы при изменении свойств являются частью метаданных свойства. Вы можете изменить обратные вызовы для конкретного свойства зависимостей, так как оно задается типом, производным от типа, которому принадлежит свойство зависимостей, путем переопределения метаданных для этого свойства в типе.  
  
<a name="Advanced"></a>   
## <a name="advanced-coercion-and-callback-scenarios"></a>Сценарии расширенного приведения и обратного вызова  
  
### <a name="constraints-and-desired-values"></a>Ограничения и требуемые значения  
 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> Функции обратного вызова будут использоваться системой свойств для приведения значения в соответствии с объявляемой логикой, но приведенное значение локально заданного свойства будет по-прежнему содержать "требуемое значение" внутренне. Если ограничения зависят от других значений свойств, которые могут изменяться динамически во время работы приложения, приведенные ограничения будут также изменяться динамически, а ограниченное свойство может изменить свое значение, чтобы максимально приблизиться к требуемому значению с учетом новых ограничений. Значение станет равно требуемому значению, если все ограничения будут сняты. При необходимости можно создать достаточно сложные сценарии зависимостей, если имеется, например, несколько свойств, которые циклически зависят друг от друга. В сценарии, где имеется минимальное, максимальное и текущее значения, можно, например, сделать минимальное и максимальное значения определяемыми пользователем. В этом случае может потребоваться правило приведения, определяющее, что максимальное значение должно быть всегда больше минимального или наоборот. Но если приведение включено и максимальное значение приводится к минимальному, текущее значение остается в неопределенном состоянии, так как оно зависит от них обоих и ограничено диапазоном между ними, который равен нулю. С другой стороны, если максимальное или минимальное значение настраивается, текущее значение будет стремиться "отслеживать" одно из них. Это происходит из-за того, что для текущего значения сохраняется его требуемая величина и оно пытается достичь этой величины при ослаблении ограничений.  
  
 С технической реализацией сложных зависимостей нет проблем, но они могут ухудшить производительность, если для их осуществления потребуется выполнять большой объем вычислений. Кроме того, они могут вызвать недоумение у пользователей, если будут непосредственно влиять на пользовательский интерфейс. Будьте внимательны при использовании обратных вызовов с привязкой к значению и обратных вызовов при изменении свойств и следите за тем, чтобы попытки приведения могли выполняться максимально однозначно, не вызывая "сверхограничений".  
  
### <a name="using-coercevalue-to-cancel-value-changes"></a>Использование CoerceValue для отмены изменений значения  
 Система свойств будет обрабатывать любые <xref:System.Windows.CoerceValueCallback> , возвращающие значение <xref:System.Windows.DependencyProperty.UnsetValue> , как особый случай. Этот особый случай означает, что изменение свойства, которое привело к <xref:System.Windows.CoerceValueCallback> вызываемому методу, должно быть отклонено системой свойств, а система свойств должна сообщить о любом предыдущем значении свойства. Этот механизм можно использовать для того, чтобы убедиться, что изменения свойства, инициированные асинхронно, все еще действительны для текущего состояния объекта, и, если это не так, запретить эти изменения. Другой возможный сценарий. Вы можете выборочно запретить значения в зависимости от того, какой компонент определения значения свойства отвечает за переданное значение. Для этого можно использовать <xref:System.Windows.DependencyProperty> переданный метод обратного вызова и идентификатор свойства в качестве входных данных для <xref:System.Windows.DependencyPropertyHelper.GetValueSource%2A> <xref:System.Windows.ValueSource>, а затем обработать.  
  
## <a name="see-also"></a>См. также

- [Общие сведения о свойствах зависимости](dependency-properties-overview.md)
- [Метаданные свойства зависимостей](dependency-property-metadata.md)
- [Пользовательские свойства зависимостей](custom-dependency-properties.md)
