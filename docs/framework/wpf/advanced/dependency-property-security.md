---
title: Безопасность свойства зависимости
ms.date: 03/30/2017
helpviewer_keywords:
- wrappers [WPF], access
- wrappers [WPF], security
- dependency properties [WPF], security
- security [WPF], wrappers
- validation [WPF], dependency properties
- dependency properties [WPF], access
- security [WPF], dependency properties
ms.assetid: d10150ec-90c5-4571-8d35-84bafa2429a4
ms.openlocfilehash: f5640b348ccd68819052f58756489489371862d0
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79186395"
---
# <a name="dependency-property-security"></a>Безопасность свойства зависимости
Свойства зависимости, как правило, считаются открытыми. Суть системы свойств [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] такова, что дать гарантии безопасности о значении свойства зависимости невозможно.  

<a name="AccessSecurity"></a>
## <a name="access-and-security-of-wrappers-and-dependency-properties"></a>Доступ к программам-оболочкам и свойствам зависимости и их безопасность  
 Как правило, свойства зависимости реализуются вместе с свойствами общего языка (CLR), которые упрощают получение или настройку свойства из экземпляра. Но обертки на самом деле просто удобные методы, которые реализуют основные <xref:System.Windows.DependencyObject.GetValue%2A> и <xref:System.Windows.DependencyObject.SetValue%2A> статические вызовы, которые используются при взаимодействии с свойствами зависимости. Думая об этом по-другому, свойства разоблачаются как общие свойства времени выполнения языка (CLR), которые, случается, опираются на свойство зависимости, а не частное поле. Механизмы безопасности, применяемые к программам-оболочкам, не поддерживают параллели между поведением системы свойств и доступом базового свойства зависимости. Размещение требования безопасности на обертке только предотвратит использование метода удобства, но не предотвратит вызовы <xref:System.Windows.DependencyObject.GetValue%2A> или <xref:System.Windows.DependencyObject.SetValue%2A>. Аналогично: размещение защищенного или закрытого уровня доступа в программе-разработчике не обеспечивает эффективную защиту.  
  
 Если вы пишете свои собственные свойства зависимости, вы <xref:System.Windows.DependencyProperty> должны объявить обертки и поле идентификатора в качестве публичных членов, так что абоненты не получают вводящую в заблуждение информацию об истинном уровне доступа этого свойства (из-за его хранения реализуется как свойство зависимости).  
  
 Для пользовательского свойства зависимости вы можете зарегистрировать свою собственность в качестве свойства зависимости только для чтения, и это обеспечивает эффективное <xref:System.Windows.DependencyPropertyKey> средство предотвращения собственности, устанавливаемых кем-либо, кто не содержит ссылки на это свойство. Дополнительные сведения см. в разделе [Свойства зависимостей "только для чтения"](read-only-dependency-properties.md).  
  
> [!NOTE]
> Объявление <xref:System.Windows.DependencyProperty> поля идентификатора частным не запрещено, и оно может быть использовано, чтобы помочь уменьшить немедленно открытые пространства имен пользовательского класса, но такое свойство не должно считаться "частным" в том же смысле, что и определения языка общего языка (CLR) определяют этот уровень доступа по причинам, описанным в следующем разделе.  
  
<a name="PropertySystemExposure"></a>
## <a name="property-system-exposure-of-dependency-properties"></a>Предоставление системы свойств свойствам зависимости  
 Это, как правило, не полезно, и это <xref:System.Windows.DependencyProperty> потенциально вводит в заблуждение, объявить, как любой уровень доступа, кроме общественности. Такая настройка уровня доступа просто лишит возможности получить ссылку на экземпляр из объявляющего класса. Но есть несколько аспектов системы <xref:System.Windows.DependencyProperty> свойств, которые вернут сярприз в качестве средства идентификации конкретного свойства в том виде, в <xref:System.Windows.DependencyObject.SetValue%2A> каком оно существует на экземпляре класса или производного экземпляра класса, и этот идентификатор по-прежнему может быть пригоден к удочку, даже если исходный статический идентификатор объявлен непубличным. Кроме <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> того, виртуальные методы получают информацию о любом существующем свойстве зависимости, которое изменило значение. Кроме того, <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> метод возвращает идентификаторы для любого свойства на экземплярах с локально установленным значением.  
  
### <a name="validation-and-security"></a>Проверка и безопасность  
 Применение требования к <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> запросу и ожидание сбоя проверки при отказе требования предотвратить установку объекта не является адекватным механизмом обеспечения безопасности. Недействительное установленное значение <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> также может быть подавлено вредоносными абонентами, если эти абоненты работают в домене приложения.  
  
## <a name="see-also"></a>См. также раздел

- [Пользовательские свойства зависимостей](custom-dependency-properties.md)
