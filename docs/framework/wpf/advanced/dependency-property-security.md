---
title: Безопасность свойства зависимости
ms.date: 03/30/2017
helpviewer_keywords:
- wrappers [WPF], access
- wrappers [WPF], security
- dependency properties [WPF], security
- security [WPF], wrappers
- validation [WPF], dependency properties
- dependency properties [WPF], access
- security [WPF], dependency properties
ms.assetid: d10150ec-90c5-4571-8d35-84bafa2429a4
ms.openlocfilehash: 85806ee9fb01cd2ca07697230c46a8847fdf8c6a
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/08/2019
ms.locfileid: "59077476"
---
# <a name="dependency-property-security"></a><span data-ttu-id="7e453-102">Безопасность свойства зависимости</span><span class="sxs-lookup"><span data-stu-id="7e453-102">Dependency Property Security</span></span>
<span data-ttu-id="7e453-103">Свойства зависимости, как правило, считаются открытыми.</span><span class="sxs-lookup"><span data-stu-id="7e453-103">Dependency properties should generally be considered to be public properties.</span></span> <span data-ttu-id="7e453-104">Суть системы свойств [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] такова, что дать гарантии безопасности о значении свойства зависимости невозможно.</span><span class="sxs-lookup"><span data-stu-id="7e453-104">The nature of the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] property system prevents the ability to make security guarantees about a dependency property value.</span></span>  

<a name="AccessSecurity"></a>   
## <a name="access-and-security-of-wrappers-and-dependency-properties"></a><span data-ttu-id="7e453-105">Доступ к программам-оболочкам и свойствам зависимости и их безопасность</span><span class="sxs-lookup"><span data-stu-id="7e453-105">Access and Security of Wrappers and Dependency Properties</span></span>  
 <span data-ttu-id="7e453-106">Как правило, свойства зависимости реализуются вместе со свойствами [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] программы-оболочки, которые упрощают получение или настройку свойства от экземпляра.</span><span class="sxs-lookup"><span data-stu-id="7e453-106">Typically, dependency properties are implemented along with "wrapper" [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] properties that simplify getting or setting the property from an instance.</span></span> <span data-ttu-id="7e453-107">Но программы-оболочки — на самом деле, лишь удобные способы реализации базового <xref:System.Windows.DependencyObject.GetValue%2A> и <xref:System.Windows.DependencyObject.SetValue%2A> статические вызовы, которые используются при взаимодействии со свойствами зависимости.</span><span class="sxs-lookup"><span data-stu-id="7e453-107">But the wrappers are really just convenience methods that implement the underlying <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> static calls that are used when interacting with dependency properties.</span></span> <span data-ttu-id="7e453-108">Другими словами, свойства предоставляются как свойства [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)], поддерживаемые свойством зависимости, а не закрытым полем.</span><span class="sxs-lookup"><span data-stu-id="7e453-108">Thinking of it in another way, the properties are exposed as [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] properties that happen to be backed by a dependency property rather than by a private field.</span></span> <span data-ttu-id="7e453-109">Механизмы безопасности, применяемые к программам-оболочкам, не поддерживают параллели между поведением системы свойств и доступом базового свойства зависимости.</span><span class="sxs-lookup"><span data-stu-id="7e453-109">Security mechanisms applied to the wrappers do not parallel the property system behavior and access of the underlying dependency property.</span></span> <span data-ttu-id="7e453-110">Помещение требования безопасности на оболочку помешает только использованию удобного метода, но не блокирует вызовы <xref:System.Windows.DependencyObject.GetValue%2A> или <xref:System.Windows.DependencyObject.SetValue%2A>.</span><span class="sxs-lookup"><span data-stu-id="7e453-110">Placing a security demand on the wrapper will only prevent the usage of the convenience method but will not prevent calls to <xref:System.Windows.DependencyObject.GetValue%2A> or <xref:System.Windows.DependencyObject.SetValue%2A>.</span></span> <span data-ttu-id="7e453-111">Аналогично: размещение защищенного или закрытого уровня доступа в программе-разработчике не обеспечивает эффективную защиту.</span><span class="sxs-lookup"><span data-stu-id="7e453-111">Similarly, placing protected or private access level on the wrappers does not provide any effective security.</span></span>  
  
 <span data-ttu-id="7e453-112">При написании собственных свойств зависимости необходимо объявить программы-оболочки и <xref:System.Windows.DependencyProperty> поле идентификатора как открытые элементы, чтобы вызывающие объекты не получали противоречивую информацию об истинном уровне доступа этого свойства (из-за его хранилища, реализовано как свойство зависимостей).</span><span class="sxs-lookup"><span data-stu-id="7e453-112">If you are writing your own dependency properties, you should declare the wrappers and the <xref:System.Windows.DependencyProperty> identifier field as public members, so that callers do not get misleading information about the true access level of that property (because of its store being implemented as a dependency property).</span></span>  
  
 <span data-ttu-id="7e453-113">Для настраиваемого свойства зависимости, можно зарегистрировать свойство как свойство зависимостей только для чтения, и это обеспечивают эффективные способы предотвратить устанавливаемое любым пользователем, не содержит ссылку на свойство <xref:System.Windows.DependencyPropertyKey> для этого свойства.</span><span class="sxs-lookup"><span data-stu-id="7e453-113">For a custom dependency property, you can register your property as a read-only dependency property, and this does provide an effective means of preventing a property being set by anyone that does not hold a reference to the <xref:System.Windows.DependencyPropertyKey> for that property.</span></span> <span data-ttu-id="7e453-114">Дополнительные сведения см. в разделе [Свойства зависимостей "только для чтения"](read-only-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="7e453-114">For more information, see [Read-Only Dependency Properties](read-only-dependency-properties.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7e453-115">Объявление <xref:System.Windows.DependencyProperty> закрытого поля идентификатора не запрещено и он может быть использован для уменьшения немедленно предоставляемого пространства имен пользовательского класса, но такое свойство не считается «private», в том же смысле, как [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] язык определения определяют этот уровень доступа, по причинам, описанным в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="7e453-115">Declaring a <xref:System.Windows.DependencyProperty> identifier field private is not forbidden, and it can conceivably be used to help reduce the immediately exposed namespace of a custom class, but such a property should not be considered "private" in the same sense as the [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] language definitions define that access level, for reasons described in the next section.</span></span>  
  
<a name="PropertySystemExposure"></a>   
## <a name="property-system-exposure-of-dependency-properties"></a><span data-ttu-id="7e453-116">Предоставление системы свойств свойствам зависимости</span><span class="sxs-lookup"><span data-stu-id="7e453-116">Property System Exposure of Dependency Properties</span></span>  
 <span data-ttu-id="7e453-117">Он обычно не имеет смысла, и это ложная для объявления <xref:System.Windows.DependencyProperty> как любого уровня доступа, отличный от открытого.</span><span class="sxs-lookup"><span data-stu-id="7e453-117">It is not generally useful, and it is potentially misleading, to declare a <xref:System.Windows.DependencyProperty> as any access level other than public.</span></span> <span data-ttu-id="7e453-118">Такая настройка уровня доступа просто лишит возможности получить ссылку на экземпляр из объявляющего класса.</span><span class="sxs-lookup"><span data-stu-id="7e453-118">That access level setting only prevents someone from being able to get a reference to the instance from the declaring class.</span></span> <span data-ttu-id="7e453-119">Но существует несколько аспектов системы свойств, который будет возвращать <xref:System.Windows.DependencyProperty> как средства для идентификации конкретного свойства, как он существует на экземпляре класса или экземпляре производного класса, и этот идентификатор является по-прежнему можно использовать в <xref:System.Windows.DependencyObject.SetValue%2A> даже вызвать Если исходный статический идентификатор объявляется неоткрытым.</span><span class="sxs-lookup"><span data-stu-id="7e453-119">But there are several aspects of the property system that will return a <xref:System.Windows.DependencyProperty> as the means of identifying a particular property as it exists on an instance of a class or a derived class instance, and this identifier is still usable in a <xref:System.Windows.DependencyObject.SetValue%2A> call even if the original static identifier is declared as nonpublic.</span></span> <span data-ttu-id="7e453-120">Кроме того <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> виртуальные методы получают сведения о любом существующем свойстве зависимости, которое изменило значение.</span><span class="sxs-lookup"><span data-stu-id="7e453-120">Also, <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> virtual methods receive information of any existing dependency property that changed value.</span></span> <span data-ttu-id="7e453-121">Кроме того <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> метод возвращает идентификаторы для любого свойства в экземплярах с локально заданное значение.</span><span class="sxs-lookup"><span data-stu-id="7e453-121">In addition, the <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> method returns identifiers for any property on instances with a locally set value.</span></span>  
  
### <a name="validation-and-security"></a><span data-ttu-id="7e453-122">Проверка и безопасность</span><span class="sxs-lookup"><span data-stu-id="7e453-122">Validation and Security</span></span>  
 <span data-ttu-id="7e453-123">Применение требований <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> и ожидается сбой проверки при сбое требования для предотвращения задаваемое свойство не является достаточно безопасным механизмом.</span><span class="sxs-lookup"><span data-stu-id="7e453-123">Applying a demand to a <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> and expecting the validation failure on a demand failure to prevent a property from being set is not an adequate security mechanism.</span></span> <span data-ttu-id="7e453-124">Реализацию недействительности заданного значения регламентирует <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> может подавляться вредоносные вызывающие объекты, если эти вызывающие объекты работают внутри домена приложения.</span><span class="sxs-lookup"><span data-stu-id="7e453-124">Set-value invalidation enforced through <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> could also be suppressed by malicious callers, if those callers are operating within the application domain.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="7e453-125">См. также</span><span class="sxs-lookup"><span data-stu-id="7e453-125">See also</span></span>

- [<span data-ttu-id="7e453-126">Пользовательские свойства зависимостей</span><span class="sxs-lookup"><span data-stu-id="7e453-126">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
