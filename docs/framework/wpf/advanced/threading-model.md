---
title: Модель потоков
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- text on buttons [WPF], updating
- message processing [WPF], nested
- blocking operations [WPF]
- Common Language Runtime (CLR), locking mechanism
- locking mechanism of Common Language Runtime (CLR)
- threading model [WPF]
- Word [WPF], spelling checking
- button text [WPF], updating
- spelling checking in Word [WPF]
- asynchronous behavior [WPF], exposing
- nested message processing [WPF]
- reentrancy [WPF]
ms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b
ms.openlocfilehash: 550ba74c7ceba16c2040932918364ae2a59ea665
ms.sourcegitcommit: 13e79efdbd589cad6b1de634f5d6b1262b12ab01
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/28/2020
ms.locfileid: "76794274"
---
# <a name="threading-model"></a><span data-ttu-id="1ec42-102">Модель потоков</span><span class="sxs-lookup"><span data-stu-id="1ec42-102">Threading Model</span></span>
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <span data-ttu-id="1ec42-103">призвана помочь разработчикам избежать трудностей при разработке потоков.</span><span class="sxs-lookup"><span data-stu-id="1ec42-103">is designed to save developers from the difficulties of threading.</span></span> <span data-ttu-id="1ec42-104">В результате большинству [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] разработчикам не придется писать интерфейс, использующий более одного потока.</span><span class="sxs-lookup"><span data-stu-id="1ec42-104">As a result, the majority of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread.</span></span> <span data-ttu-id="1ec42-105">Поскольку многопотоковые программы являются сложными и трудно отлаживаемыми, их следует избегать, если существуют однопоточные решения.</span><span class="sxs-lookup"><span data-stu-id="1ec42-105">Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.</span></span>

 <span data-ttu-id="1ec42-106">Однако независимо от того, насколько хорошо архитектура, [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] Framework не сможет предоставить однопотоковое решение для каждой проблемы.</span><span class="sxs-lookup"><span data-stu-id="1ec42-106">No matter how well architected, however, no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="1ec42-107">близко, но существуют ситуации, когда несколько потоков улучшают [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] скорость реагирования или производительность приложения.</span><span class="sxs-lookup"><span data-stu-id="1ec42-107">comes close, but there are still situations where multiple threads improve [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance.</span></span> <span data-ttu-id="1ec42-108">После рассмотрения некоторых основных материалов в данном документе рассматриваются подобные ситуации и в завершение обсуждаются некоторые более подробные сведения.</span><span class="sxs-lookup"><span data-stu-id="1ec42-108">After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.</span></span>

> [!NOTE]
> <span data-ttu-id="1ec42-109">В этом разделе обсуждается работа с потоками с помощью метода <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> для асинхронных вызовов.</span><span class="sxs-lookup"><span data-stu-id="1ec42-109">This topic discusses threading by using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls.</span></span> <span data-ttu-id="1ec42-110">Асинхронные вызовы также можно выполнять, вызывая метод <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A>, принимающий <xref:System.Action> или <xref:System.Func%601> в качестве параметра.</span><span class="sxs-lookup"><span data-stu-id="1ec42-110">You can also make asynchronous calls by calling the <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="1ec42-111">Метод <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> возвращает <xref:System.Windows.Threading.DispatcherOperation> или <xref:System.Windows.Threading.DispatcherOperation%601>, который имеет свойство <xref:System.Windows.Threading.DispatcherOperation.Task%2A>.</span><span class="sxs-lookup"><span data-stu-id="1ec42-111">The <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, which has a <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property.</span></span> <span data-ttu-id="1ec42-112">Можно использовать ключевое слово `await` с <xref:System.Windows.Threading.DispatcherOperation> или связанным <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="1ec42-112">You can use the `await` keyword with either the <xref:System.Windows.Threading.DispatcherOperation> or the associated <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="1ec42-113">Если необходимо выполнить синхронное ожидание <xref:System.Threading.Tasks.Task>, возвращаемого <xref:System.Windows.Threading.DispatcherOperation> или <xref:System.Windows.Threading.DispatcherOperation%601>, вызовите метод расширения <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="1ec42-113">If you need to wait synchronously for the <xref:System.Threading.Tasks.Task> that is returned by a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, call the <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.</span></span>  <span data-ttu-id="1ec42-114">Вызов <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> приведет к взаимоблокировке.</span><span class="sxs-lookup"><span data-stu-id="1ec42-114">Calling <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> will result in a deadlock.</span></span> <span data-ttu-id="1ec42-115">Дополнительные сведения об использовании <xref:System.Threading.Tasks.Task> для выполнения асинхронных операций см. в разделе Параллелизм задач.</span><span class="sxs-lookup"><span data-stu-id="1ec42-115">For more information about using a <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.</span></span>  <span data-ttu-id="1ec42-116">Метод <xref:System.Windows.Threading.Dispatcher.Invoke%2A> также имеет перегрузки, принимающие <xref:System.Action> или <xref:System.Func%601> в качестве параметра.</span><span class="sxs-lookup"><span data-stu-id="1ec42-116">The <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="1ec42-117">Метод <xref:System.Windows.Threading.Dispatcher.Invoke%2A> можно использовать для выполнения синхронных вызовов путем передачи делегата, <xref:System.Action> или <xref:System.Func%601>.</span><span class="sxs-lookup"><span data-stu-id="1ec42-117">You can use the <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate, <xref:System.Action> or <xref:System.Func%601>.</span></span>

<a name="threading_overview"></a>
## <a name="overview-and-the-dispatcher"></a><span data-ttu-id="1ec42-118">Общие сведения и Dispatcher</span><span class="sxs-lookup"><span data-stu-id="1ec42-118">Overview and the Dispatcher</span></span>
 <span data-ttu-id="1ec42-119">Как правило, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] приложения начинаются с двух потоков: один для обработки отрисовки, а другой для управления [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1ec42-119">Typically, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="1ec42-120">Поток отрисовки фактически запускается в фоновом режиме, пока поток [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] получает входные данные, обрабатывает события, закрашивает экран и выполняет код приложения.</span><span class="sxs-lookup"><span data-stu-id="1ec42-120">The rendering thread effectively runs hidden in the background while the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code.</span></span> <span data-ttu-id="1ec42-121">Большинство приложений используют один поток [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], хотя в некоторых случаях лучше использовать несколько.</span><span class="sxs-lookup"><span data-stu-id="1ec42-121">Most applications use a single [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several.</span></span> <span data-ttu-id="1ec42-122">Позже это будет рассмотрено на примере.</span><span class="sxs-lookup"><span data-stu-id="1ec42-122">We’ll discuss this with an example later.</span></span>

 <span data-ttu-id="1ec42-123">Поток [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] помещает рабочие элементы в объект, называемый <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="1ec42-123">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="1ec42-124">Объект <xref:System.Windows.Threading.Dispatcher> выбирает рабочие элементы на основе приоритетов и выполняет каждый из них до завершения.</span><span class="sxs-lookup"><span data-stu-id="1ec42-124">The <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion.</span></span>  <span data-ttu-id="1ec42-125">Каждый поток [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] должен иметь по крайней мере один <xref:System.Windows.Threading.Dispatcher>, и каждый <xref:System.Windows.Threading.Dispatcher> может выполнять рабочие элементы только в одном потоке.</span><span class="sxs-lookup"><span data-stu-id="1ec42-125">Every [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread must have at least one <xref:System.Windows.Threading.Dispatcher>, and each <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread.</span></span>

 <span data-ttu-id="1ec42-126">Хитрость в создании ориентированных на пользователя приложений заключается в том, чтобы максимально увеличить пропускную способность <xref:System.Windows.Threading.Dispatcher>, сохранив рабочие элементы небольшими.</span><span class="sxs-lookup"><span data-stu-id="1ec42-126">The trick to building responsive, user-friendly applications is to maximize the <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small.</span></span> <span data-ttu-id="1ec42-127">Таким образом, элементы никогда не устаревают в очереди <xref:System.Windows.Threading.Dispatcher>, ожидающей обработки.</span><span class="sxs-lookup"><span data-stu-id="1ec42-127">This way items never get stale sitting in the <xref:System.Windows.Threading.Dispatcher> queue waiting for processing.</span></span> <span data-ttu-id="1ec42-128">Любая задержка между входными данными и ответами может разочаровать пользователя.</span><span class="sxs-lookup"><span data-stu-id="1ec42-128">Any perceivable delay between input and response can frustrate a user.</span></span>

 <span data-ttu-id="1ec42-129">Как же [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] приложения должны справляться с большими операциями?</span><span class="sxs-lookup"><span data-stu-id="1ec42-129">How then are [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations?</span></span> <span data-ttu-id="1ec42-130">Что если код включает большие вычисления или требуется запрос к базе данных на удаленном сервере?</span><span class="sxs-lookup"><span data-stu-id="1ec42-130">What if your code involves a large calculation or needs to query a database on some remote server?</span></span> <span data-ttu-id="1ec42-131">Как правило, ответ заключается в обработке большой операции в отдельном потоке, в результате чего [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]ный поток остается недоступным для элементов в очереди <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="1ec42-131">Usually, the answer is to handle the big operation in a separate thread, leaving the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="1ec42-132">После завершения большой операции она может сообщить результат обратно в поток [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] для вывода.</span><span class="sxs-lookup"><span data-stu-id="1ec42-132">When the big operation is complete, it can report its result back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread for display.</span></span>

 <span data-ttu-id="1ec42-133">Исторически Windows позволяет получить доступ к [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] элементам только создавшим их потоком.</span><span class="sxs-lookup"><span data-stu-id="1ec42-133">Historically, Windows allows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them.</span></span> <span data-ttu-id="1ec42-134">Это означает, что фоновый поток, отвечающий за некоторую длительную задачу, не может обновить текстовое поле при своем завершении.</span><span class="sxs-lookup"><span data-stu-id="1ec42-134">This means that a background thread in charge of some long-running task cannot update a text box when it is finished.</span></span> <span data-ttu-id="1ec42-135">Windows делает это для обеспечения целостности компонентов [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1ec42-135">Windows does this to ensure the integrity of [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] components.</span></span> <span data-ttu-id="1ec42-136">Список может выглядеть странно, если его содержимое обновляется фоновым потоком в процессе отображения.</span><span class="sxs-lookup"><span data-stu-id="1ec42-136">A list box could look strange if its contents were updated by a background thread during painting.</span></span>

 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="1ec42-137">имеет встроенный механизм взаимного исключения, который осуществляет эту координацию.</span><span class="sxs-lookup"><span data-stu-id="1ec42-137">has a built-in mutual exclusion mechanism that enforces this coordination.</span></span> <span data-ttu-id="1ec42-138">Большинство классов в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] являются производными от <xref:System.Windows.Threading.DispatcherObject>.</span><span class="sxs-lookup"><span data-stu-id="1ec42-138">Most classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>.</span></span> <span data-ttu-id="1ec42-139">Во время создания <xref:System.Windows.Threading.DispatcherObject> сохраняет ссылку на <xref:System.Windows.Threading.Dispatcher>, связанную с текущим выполняющимся потоком.</span><span class="sxs-lookup"><span data-stu-id="1ec42-139">At construction, a <xref:System.Windows.Threading.DispatcherObject> stores a reference to the <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread.</span></span> <span data-ttu-id="1ec42-140">Фактически <xref:System.Windows.Threading.DispatcherObject> связывается с потоком, который его создает.</span><span class="sxs-lookup"><span data-stu-id="1ec42-140">In effect, the <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it.</span></span> <span data-ttu-id="1ec42-141">Во время выполнения программы <xref:System.Windows.Threading.DispatcherObject> может вызвать его открытый метод <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>.</span><span class="sxs-lookup"><span data-stu-id="1ec42-141">During program execution, a <xref:System.Windows.Threading.DispatcherObject> can call its public <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method.</span></span> <span data-ttu-id="1ec42-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> проверяет <xref:System.Windows.Threading.Dispatcher>, связанных с текущим потоком, и сравнивает его с <xref:System.Windows.Threading.Dispatcher> ссылкой, хранящейся во время создания.</span><span class="sxs-lookup"><span data-stu-id="1ec42-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examines the <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the <xref:System.Windows.Threading.Dispatcher> reference stored during construction.</span></span> <span data-ttu-id="1ec42-143">Если они не совпадают, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> создает исключение.</span><span class="sxs-lookup"><span data-stu-id="1ec42-143">If they don’t match, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception.</span></span> <span data-ttu-id="1ec42-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> предназначено для вызова в начале каждого метода, принадлежащего <xref:System.Windows.Threading.DispatcherObject>.</span><span class="sxs-lookup"><span data-stu-id="1ec42-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> is intended to be called at the beginning of every method belonging to a <xref:System.Windows.Threading.DispatcherObject>.</span></span>

 <span data-ttu-id="1ec42-145">Если только один поток может изменить [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], как фоновые потоки взаимодействуют с пользователем?</span><span class="sxs-lookup"><span data-stu-id="1ec42-145">If only one thread can modify the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user?</span></span> <span data-ttu-id="1ec42-146">Фоновый поток может попросить [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]ного потока выполнить операцию от его имени.</span><span class="sxs-lookup"><span data-stu-id="1ec42-146">A background thread can ask the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf.</span></span> <span data-ttu-id="1ec42-147">Это достигается путем регистрации рабочего элемента с <xref:System.Windows.Threading.Dispatcher> потока [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1ec42-147">It does this by registering a work item with the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1ec42-148">Класс <xref:System.Windows.Threading.Dispatcher> предоставляет два метода для регистрации рабочих элементов: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> и <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span><span class="sxs-lookup"><span data-stu-id="1ec42-148">The <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span></span> <span data-ttu-id="1ec42-149">Оба метода назначают делегат для выполнения.</span><span class="sxs-lookup"><span data-stu-id="1ec42-149">Both methods schedule a delegate for execution.</span></span> <span data-ttu-id="1ec42-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> является синхронным вызовом, то есть он не возвращает значение, пока поток [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] не завершит выполнение делегата.</span><span class="sxs-lookup"><span data-stu-id="1ec42-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> is a synchronous call – that is, it doesn’t return until the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate.</span></span> <span data-ttu-id="1ec42-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> является асинхронным и возвращается немедленно.</span><span class="sxs-lookup"><span data-stu-id="1ec42-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is asynchronous and returns immediately.</span></span>

 <span data-ttu-id="1ec42-152"><xref:System.Windows.Threading.Dispatcher> упорядочивает элементы в своей очереди по приоритету.</span><span class="sxs-lookup"><span data-stu-id="1ec42-152">The <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority.</span></span> <span data-ttu-id="1ec42-153">При добавлении элемента в очередь <xref:System.Windows.Threading.Dispatcher> можно указать десять уровней.</span><span class="sxs-lookup"><span data-stu-id="1ec42-153">There are ten levels that may be specified when adding an element to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="1ec42-154">Эти приоритеты поддерживаются в перечислении <xref:System.Windows.Threading.DispatcherPriority>.</span><span class="sxs-lookup"><span data-stu-id="1ec42-154">These priorities are maintained in the <xref:System.Windows.Threading.DispatcherPriority> enumeration.</span></span> <span data-ttu-id="1ec42-155">Подробные сведения о <xref:System.Windows.Threading.DispatcherPriority> уровнях можно найти в документации по Windows SDK.</span><span class="sxs-lookup"><span data-stu-id="1ec42-155">Detailed information about <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the Windows SDK documentation.</span></span>

<a name="samples"></a>
## <a name="threads-in-action-the-samples"></a><span data-ttu-id="1ec42-156">Потоки в действии: примеры</span><span class="sxs-lookup"><span data-stu-id="1ec42-156">Threads in Action: The Samples</span></span>

<a name="prime_number"></a>
### <a name="a-single-threaded-application-with-a-long-running-calculation"></a><span data-ttu-id="1ec42-157">Пример однопоточного приложения с длительным выполнением вычислений</span><span class="sxs-lookup"><span data-stu-id="1ec42-157">A Single-Threaded Application with a Long-Running Calculation</span></span>
 <span data-ttu-id="1ec42-158">Большинство графических интерфейсов пользователя (GUI) тратят большую часть времени простоя, когда ожидают события, создаваемые в ответ на взаимодействие с пользователем.</span><span class="sxs-lookup"><span data-stu-id="1ec42-158">Most graphical user interfaces (GUIs) spend a large portion of their time idle while waiting for events that are generated in response to user interactions.</span></span> <span data-ttu-id="1ec42-159">При тщательном программировании это время простоя можно использовать в конструкторе, не влияя на скорость реагирования [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1ec42-159">With careful programming this idle time can be used constructively, without affecting the responsiveness of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="1ec42-160">Потоковая модель [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] не позволяет входным данным прерывать операции, происходящие в потоке [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1ec42-160">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1ec42-161">Это означает, что необходимо периодически возвращаться к <xref:System.Windows.Threading.Dispatcher> для обработки ожидающих входных событий, прежде чем они станут устаревшими.</span><span class="sxs-lookup"><span data-stu-id="1ec42-161">This means you must be sure to return to the <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale.</span></span>

 <span data-ttu-id="1ec42-162">Рассмотрим следующий пример.</span><span class="sxs-lookup"><span data-stu-id="1ec42-162">Consider the following example:</span></span>

 ![Снимок экрана, показывающий поток простых чисел.](./media/threading-model/threading-prime-numbers.png)

 <span data-ttu-id="1ec42-164">Это простое приложение ищет простые числа, начиная от трех и далее.</span><span class="sxs-lookup"><span data-stu-id="1ec42-164">This simple application counts upwards from three, searching for prime numbers.</span></span> <span data-ttu-id="1ec42-165">Когда пользователь нажимает кнопку **Start** , начинается поиск.</span><span class="sxs-lookup"><span data-stu-id="1ec42-165">When the user clicks the **Start** button, the search begins.</span></span> <span data-ttu-id="1ec42-166">Когда программа находит простое число, она обновляет пользовательский интерфейс.</span><span class="sxs-lookup"><span data-stu-id="1ec42-166">When the program finds a prime, it updates the user interface with its discovery.</span></span> <span data-ttu-id="1ec42-167">В любой момент пользователь может остановить поиск.</span><span class="sxs-lookup"><span data-stu-id="1ec42-167">At any point, the user can stop the search.</span></span>

 <span data-ttu-id="1ec42-168">При всей простоте операции поиск простых чисел может происходить бесконечно, что представляет некоторые трудности.</span><span class="sxs-lookup"><span data-stu-id="1ec42-168">Although simple enough, the prime number search could go on forever, which presents some difficulties.</span></span>  <span data-ttu-id="1ec42-169">Если бы мы обработали весь Поиск внутри обработчика событий нажатия кнопки, мы бы никогда не придать потоку [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] возможность обрабатывать другие события.</span><span class="sxs-lookup"><span data-stu-id="1ec42-169">If we handled the entire search inside of the click event handler of the button, we would never give the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events.</span></span> <span data-ttu-id="1ec42-170">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] не сможет ответить на ввод или обработку сообщений.</span><span class="sxs-lookup"><span data-stu-id="1ec42-170">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages.</span></span> <span data-ttu-id="1ec42-171">Он бы никогда не обновил отображение и не ответил бы на нажатие кнопки.</span><span class="sxs-lookup"><span data-stu-id="1ec42-171">It would never repaint and never respond to button clicks.</span></span>

 <span data-ttu-id="1ec42-172">Можно провести поиск простого числа в отдельном потоке, но тогда пришлось бы иметь дело с проблемами синхронизации.</span><span class="sxs-lookup"><span data-stu-id="1ec42-172">We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues.</span></span> <span data-ttu-id="1ec42-173">С помощью однопотокового подхода можно непосредственно обновить подпись, в которой перечислено наибольшее простое число.</span><span class="sxs-lookup"><span data-stu-id="1ec42-173">With a single-threaded approach, we can directly update the label that lists the largest prime found.</span></span>

 <span data-ttu-id="1ec42-174">Если разделить задачу вычисления на управляемые фрагменты, можно периодически возвращаться в <xref:System.Windows.Threading.Dispatcher> и обрабатывать события.</span><span class="sxs-lookup"><span data-stu-id="1ec42-174">If we break up the task of calculation into manageable chunks, we can periodically return to the <xref:System.Windows.Threading.Dispatcher> and process events.</span></span> <span data-ttu-id="1ec42-175">Можно предоставить [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] возможность перерисовки и обработки входных данных.</span><span class="sxs-lookup"><span data-stu-id="1ec42-175">We can give [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input.</span></span>

 <span data-ttu-id="1ec42-176">Лучший способ разделить время обработки между вычислениями и обработкой событий — Управление вычислениями из <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="1ec42-176">The best way to split processing time between calculation and event handling is to manage calculation from the <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="1ec42-177">Используя метод <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>, можно запланировать проверки простых чисел в той же очереди, из которой [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] события.</span><span class="sxs-lookup"><span data-stu-id="1ec42-177">By using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events are drawn from.</span></span> <span data-ttu-id="1ec42-178">В приведенном примере запланирована проверка только одного простого числа в каждый момент времени.</span><span class="sxs-lookup"><span data-stu-id="1ec42-178">In our example, we schedule only a single prime number check at a time.</span></span> <span data-ttu-id="1ec42-179">После завершения проверки простого числа немедленно планируется следующая проверка.</span><span class="sxs-lookup"><span data-stu-id="1ec42-179">After the prime number check is complete, we schedule the next check immediately.</span></span> <span data-ttu-id="1ec42-180">Эта проверка продолжается только после обработки ожидающих [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] событий.</span><span class="sxs-lookup"><span data-stu-id="1ec42-180">This check proceeds only after pending [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events have been handled.</span></span>

 ![Снимок экрана, на котором показана очередь диспетчера.](./media/threading-model/threading-dispatcher-queue.png)

 <span data-ttu-id="1ec42-182">Microsoft Word выполняет проверку орфографии с помощью этого механизма.</span><span class="sxs-lookup"><span data-stu-id="1ec42-182">Microsoft Word accomplishes spell checking using this mechanism.</span></span> <span data-ttu-id="1ec42-183">Проверка орфографии выполняется в фоновом режиме с использованием времени простоя потока [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1ec42-183">Spell checking is done in the background using the idle time of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1ec42-184">Давайте посмотрим на код.</span><span class="sxs-lookup"><span data-stu-id="1ec42-184">Let's take a look at the code.</span></span>

 <span data-ttu-id="1ec42-185">В следующем примере показан код XAML, который создает пользовательский интерфейс.</span><span class="sxs-lookup"><span data-stu-id="1ec42-185">The following example shows the XAML that creates the user interface.</span></span>

 [!code-xaml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]

 <span data-ttu-id="1ec42-186">В следующем примере показан код программной части.</span><span class="sxs-lookup"><span data-stu-id="1ec42-186">The following example shows the code-behind.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]

 <span data-ttu-id="1ec42-187">В следующем примере показан обработчик событий для <xref:System.Windows.Controls.Button>.</span><span class="sxs-lookup"><span data-stu-id="1ec42-187">The following example shows the event handler for the <xref:System.Windows.Controls.Button>.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]

 <span data-ttu-id="1ec42-188">Помимо обновления текста в <xref:System.Windows.Controls.Button>, этот обработчик отвечает за планирование первой проверки простого числа путем добавления делегата в очередь <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="1ec42-188">Besides updating the text on the <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="1ec42-189">После завершения работы этого обработчика событий <xref:System.Windows.Threading.Dispatcher> выберет этот делегат для выполнения.</span><span class="sxs-lookup"><span data-stu-id="1ec42-189">Sometime after this event handler has completed its work, the <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution.</span></span>

 <span data-ttu-id="1ec42-190">Как упоминалось ранее, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> является элементом <xref:System.Windows.Threading.Dispatcher>, используемым для планирования выполнения делегата.</span><span class="sxs-lookup"><span data-stu-id="1ec42-190">As we mentioned earlier, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution.</span></span> <span data-ttu-id="1ec42-191">В этом случае мы выбираем приоритет <xref:System.Windows.Threading.DispatcherPriority.SystemIdle>.</span><span class="sxs-lookup"><span data-stu-id="1ec42-191">In this case, we choose the <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priority.</span></span> <span data-ttu-id="1ec42-192"><xref:System.Windows.Threading.Dispatcher> будет выполнять этот делегат только в том случае, если нет важных событий для обработки.</span><span class="sxs-lookup"><span data-stu-id="1ec42-192">The <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process.</span></span> <span data-ttu-id="1ec42-193">Быстродействие [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] представляет большую важность, чем проверка числа.</span><span class="sxs-lookup"><span data-stu-id="1ec42-193">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] responsiveness is more important than number checking.</span></span> <span data-ttu-id="1ec42-194">Также передается новый делегат, представляющий подпрограмму проверки числа.</span><span class="sxs-lookup"><span data-stu-id="1ec42-194">We also pass a new delegate representing the number-checking routine.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]

 <span data-ttu-id="1ec42-195">Этот метод проверяет, является ли следующее нечетное число простым.</span><span class="sxs-lookup"><span data-stu-id="1ec42-195">This method checks if the next odd number is prime.</span></span> <span data-ttu-id="1ec42-196">Если это просто, метод непосредственно обновляет `bigPrime`<xref:System.Windows.Controls.TextBlock>, чтобы отразить его обнаружение.</span><span class="sxs-lookup"><span data-stu-id="1ec42-196">If it is prime, the method directly updates the `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery.</span></span> <span data-ttu-id="1ec42-197">Мы можем сделать так потому, что вычисление происходит в том же потоке, который был использован для создания компонента.</span><span class="sxs-lookup"><span data-stu-id="1ec42-197">We can do this because the calculation is occurring in the same thread that was used to create the component.</span></span> <span data-ttu-id="1ec42-198">Если бы мы решили использовать отдельный поток для вычисления, нам пришлось бы использовать более сложный механизм синхронизации и выполнять обновление в потоке [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1ec42-198">Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1ec42-199">Эта ситуация будет продемонстрирована далее.</span><span class="sxs-lookup"><span data-stu-id="1ec42-199">We’ll demonstrate this situation next.</span></span>

 <span data-ttu-id="1ec42-200">Полный исходный код для этого примера см. в разделе [Пример однопотокового приложения с длительным выполнением вычислений](https://go.microsoft.com/fwlink/?LinkID=160038) .</span><span class="sxs-lookup"><span data-stu-id="1ec42-200">For the complete source code for this sample, see the [Single-Threaded Application with Long-Running Calculation Sample](https://go.microsoft.com/fwlink/?LinkID=160038)</span></span>

<a name="weather_sim"></a>
### <a name="handling-a-blocking-operation-with-a-background-thread"></a><span data-ttu-id="1ec42-201">Обработка блокирующей операции с фоновым потоком</span><span class="sxs-lookup"><span data-stu-id="1ec42-201">Handling a Blocking Operation with a Background Thread</span></span>
 <span data-ttu-id="1ec42-202">Обработка блокировки операций в графическом приложении может оказаться трудной задачей.</span><span class="sxs-lookup"><span data-stu-id="1ec42-202">Handling blocking operations in a graphical application can be difficult.</span></span> <span data-ttu-id="1ec42-203">Мы не будем вызывать методы блокировки из обработчиков событий, так как приложение будет остановлено.</span><span class="sxs-lookup"><span data-stu-id="1ec42-203">We don’t want to call blocking methods from event handlers because the application will appear to freeze up.</span></span> <span data-ttu-id="1ec42-204">Для обработки этих операций можно использовать отдельный поток, но после этого нам нужно выполнить синхронизацию с [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] потоком, так как мы не можем напрямую изменить пользовательский интерфейс из рабочего потока.</span><span class="sxs-lookup"><span data-stu-id="1ec42-204">We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the GUI from our worker thread.</span></span> <span data-ttu-id="1ec42-205">Для вставки делегатов в <xref:System.Windows.Threading.Dispatcher> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] потока можно использовать <xref:System.Windows.Threading.Dispatcher.Invoke%2A> или <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span><span class="sxs-lookup"><span data-stu-id="1ec42-205">We can use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1ec42-206">Со временем эти делегаты будут выполняться с разрешением на изменение элементов [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1ec42-206">Eventually, these delegates will be executed with permission to modify [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements.</span></span>

 <span data-ttu-id="1ec42-207">В этом примере мы имитируем вызов удаленной процедуры, который получает прогноз погоды.</span><span class="sxs-lookup"><span data-stu-id="1ec42-207">In this example, we mimic a remote procedure call that retrieves a weather forecast.</span></span> <span data-ttu-id="1ec42-208">Мы используем отдельный рабочий поток для выполнения этого вызова, и мы планируем метод обновления в <xref:System.Windows.Threading.Dispatcher> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] потока по завершении.</span><span class="sxs-lookup"><span data-stu-id="1ec42-208">We use a separate worker thread to execute this call, and we schedule an update method in the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished.</span></span>

 ![Снимок экрана, на котором показан пользовательский интерфейс погоды.](./media/threading-model/threading-weather-ui.png)

 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]

 <span data-ttu-id="1ec42-210">Ниже приведены некоторые подробности, на которые следует обратить внимание.</span><span class="sxs-lookup"><span data-stu-id="1ec42-210">The following are some of the details to be noted.</span></span>

- <span data-ttu-id="1ec42-211">Создание обработчика кнопки</span><span class="sxs-lookup"><span data-stu-id="1ec42-211">Creating the Button Handler</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]

 <span data-ttu-id="1ec42-212">При нажатии кнопки мы отображаем рисунок часов и запускаем анимацию.</span><span class="sxs-lookup"><span data-stu-id="1ec42-212">When the button is clicked, we display the clock drawing and start animating it.</span></span> <span data-ttu-id="1ec42-213">Мы отключаем кнопку.</span><span class="sxs-lookup"><span data-stu-id="1ec42-213">We disable the button.</span></span> <span data-ttu-id="1ec42-214">Метод `FetchWeatherFromServer` вызывается в новом потоке, а затем возвращается, что позволяет <xref:System.Windows.Threading.Dispatcher> обрабатывать события, пока не будет собран прогноз погоды.</span><span class="sxs-lookup"><span data-stu-id="1ec42-214">We invoke the `FetchWeatherFromServer` method in a new thread, and then we return, allowing the <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast.</span></span>

- <span data-ttu-id="1ec42-215">Выборка погоды</span><span class="sxs-lookup"><span data-stu-id="1ec42-215">Fetching the Weather</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]

 <span data-ttu-id="1ec42-216">Для простоты мы фактически не используем никакого сетевого кода в данном примере.</span><span class="sxs-lookup"><span data-stu-id="1ec42-216">To keep things simple, we don’t actually have any networking code in this example.</span></span> <span data-ttu-id="1ec42-217">Вместо этого мы моделируем задержку доступа к сети, задав для нашего нового потока спящий режим в течение четырех секунд.</span><span class="sxs-lookup"><span data-stu-id="1ec42-217">Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds.</span></span> <span data-ttu-id="1ec42-218">В этот раз исходный поток [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] все еще выполняется и отвечает на события.</span><span class="sxs-lookup"><span data-stu-id="1ec42-218">In this time, the original [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events.</span></span> <span data-ttu-id="1ec42-219">Чтобы показать это, была оставлена запущенная анимация, и кнопки свертывания и развертывания также продолжают работать.</span><span class="sxs-lookup"><span data-stu-id="1ec42-219">To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.</span></span>

 <span data-ttu-id="1ec42-220">После завершения задержки и случайного выбора нашего прогноза погоды пора вернуться к потоку [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1ec42-220">When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1ec42-221">Для этого нужно распланировать вызов `UpdateUserInterface` в потоке [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], используя <xref:System.Windows.Threading.Dispatcher>этого потока.</span><span class="sxs-lookup"><span data-stu-id="1ec42-221">We do this by scheduling a call to `UpdateUserInterface` in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="1ec42-222">В запланированный вызов этого метода передается строка, описывающая погоду.</span><span class="sxs-lookup"><span data-stu-id="1ec42-222">We pass a string describing the weather to this scheduled method call.</span></span>

- <span data-ttu-id="1ec42-223">Обновление [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span><span class="sxs-lookup"><span data-stu-id="1ec42-223">Updating the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]

 <span data-ttu-id="1ec42-224">Когда <xref:System.Windows.Threading.Dispatcher> в потоке [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] имеет время, он выполняет запланированный вызов `UpdateUserInterface`.</span><span class="sxs-lookup"><span data-stu-id="1ec42-224">When the <xref:System.Windows.Threading.Dispatcher> in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to `UpdateUserInterface`.</span></span> <span data-ttu-id="1ec42-225">Этот метод останавливает анимацию часов и выбирает изображение для описания погоды.</span><span class="sxs-lookup"><span data-stu-id="1ec42-225">This method stops the clock animation and chooses an image to describe the weather.</span></span> <span data-ttu-id="1ec42-226">Он отображает это изображение и восстанавливает кнопку "Получить прогноз погоды".</span><span class="sxs-lookup"><span data-stu-id="1ec42-226">It displays this image and restores the "fetch forecast" button.</span></span>

<a name="multi_browser"></a>
### <a name="multiple-windows-multiple-threads"></a><span data-ttu-id="1ec42-227">Несколько окон, несколько потоков</span><span class="sxs-lookup"><span data-stu-id="1ec42-227">Multiple Windows, Multiple Threads</span></span>
 <span data-ttu-id="1ec42-228">Для некоторых [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] приложений требуется несколько окон верхнего уровня.</span><span class="sxs-lookup"><span data-stu-id="1ec42-228">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows.</span></span> <span data-ttu-id="1ec42-229">Это вполне допустимо для одного сочетания потоков и<xref:System.Windows.Threading.Dispatcher> для управления несколькими окнами, но иногда несколько потоков выполняют более качественную работу.</span><span class="sxs-lookup"><span data-stu-id="1ec42-229">It is perfectly acceptable for one Thread/<xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job.</span></span> <span data-ttu-id="1ec42-230">Это особенно верно, когда существует возможность, что одно из окон будет монополизировать поток.</span><span class="sxs-lookup"><span data-stu-id="1ec42-230">This is especially true if there is any chance that one of the windows will monopolize the thread.</span></span>

 <span data-ttu-id="1ec42-231">Проводник Windows работает таким образом.</span><span class="sxs-lookup"><span data-stu-id="1ec42-231">Windows Explorer works in this fashion.</span></span> <span data-ttu-id="1ec42-232">Каждое новое окно проводника принадлежит исходному процессу, однако оно создается под управлением независимого потока.</span><span class="sxs-lookup"><span data-stu-id="1ec42-232">Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.</span></span>

 <span data-ttu-id="1ec42-233">С помощью элемента управления <xref:System.Windows.Controls.Frame> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]можно отображать веб-страницы.</span><span class="sxs-lookup"><span data-stu-id="1ec42-233">By using a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages.</span></span> <span data-ttu-id="1ec42-234">Можно легко создать простое подстановку Internet Explorer.</span><span class="sxs-lookup"><span data-stu-id="1ec42-234">We can easily create a simple Internet Explorer substitute.</span></span> <span data-ttu-id="1ec42-235">Начнем с важной функции: возможности открыть новое окно браузера.</span><span class="sxs-lookup"><span data-stu-id="1ec42-235">We start with an important feature: the ability to open a new explorer window.</span></span> <span data-ttu-id="1ec42-236">Когда пользователь нажимает кнопку "Новое окно", запускается копия окна в отдельном потоке.</span><span class="sxs-lookup"><span data-stu-id="1ec42-236">When the user clicks the "new window" button, we launch a copy of our window in a separate thread.</span></span> <span data-ttu-id="1ec42-237">Таким образом, долго выполняющиеся или блокирующие операции в одном из окон не блокируют все остальные окна.</span><span class="sxs-lookup"><span data-stu-id="1ec42-237">This way, long-running or blocking operations in one of the windows won’t lock all the other windows.</span></span>

 <span data-ttu-id="1ec42-238">На самом деле у браузера имеется своя собственная сложная поточная модель.</span><span class="sxs-lookup"><span data-stu-id="1ec42-238">In reality, the Web browser model has its own complicated threading model.</span></span> <span data-ttu-id="1ec42-239">Мы выбрали его, поскольку он знаком большинству читателей.</span><span class="sxs-lookup"><span data-stu-id="1ec42-239">We’ve chosen it because it should be familiar to most readers.</span></span>

 <span data-ttu-id="1ec42-240">В следующем примере показан код.</span><span class="sxs-lookup"><span data-stu-id="1ec42-240">The following example shows the code.</span></span>

 [!code-xaml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]

 <span data-ttu-id="1ec42-241">В данном контексте наиболее интересными являются следующие сегменты потоков этого кода:</span><span class="sxs-lookup"><span data-stu-id="1ec42-241">The following threading segments of this code are the most interesting to us in this context:</span></span>

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]

 <span data-ttu-id="1ec42-242">Этот метод вызывается при нажатии кнопки "Новое окно".</span><span class="sxs-lookup"><span data-stu-id="1ec42-242">This method is called when the "new window" button is clicked.</span></span> <span data-ttu-id="1ec42-243">Она создает новый поток и запускает его в асинхронном режиме.</span><span class="sxs-lookup"><span data-stu-id="1ec42-243">It creates a new thread and starts it asynchronously.</span></span>

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]

 <span data-ttu-id="1ec42-244">Этот метод является начальной точкой для нового потока.</span><span class="sxs-lookup"><span data-stu-id="1ec42-244">This method is the starting point for the new thread.</span></span> <span data-ttu-id="1ec42-245">Мы создаем новое окно под элементом управления этого потока.</span><span class="sxs-lookup"><span data-stu-id="1ec42-245">We create a new window under the control of this thread.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="1ec42-246">автоматически создает новую <xref:System.Windows.Threading.Dispatcher> для управления новым потоком.</span><span class="sxs-lookup"><span data-stu-id="1ec42-246">automatically creates a new <xref:System.Windows.Threading.Dispatcher> to manage the new thread.</span></span> <span data-ttu-id="1ec42-247">Все, что нужно сделать, чтобы сделать окно функциональным, — запустить <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="1ec42-247">All we have to do to make the window functional is to start the <xref:System.Windows.Threading.Dispatcher>.</span></span>

<a name="stumbling_points"></a>
## <a name="technical-details-and-stumbling-points"></a><span data-ttu-id="1ec42-248">Технические подробности и важные моменты</span><span class="sxs-lookup"><span data-stu-id="1ec42-248">Technical Details and Stumbling Points</span></span>

### <a name="writing-components-using-threading"></a><span data-ttu-id="1ec42-249">Написание компонентов, использующих поток</span><span class="sxs-lookup"><span data-stu-id="1ec42-249">Writing Components Using Threading</span></span>
 <span data-ttu-id="1ec42-250">Руководство разработчика платформы Microsoft .NET Framework описывает шаблон того, как компонент может предоставлять асинхронное поведение своим клиентам (см. раздел [Общие сведения об асинхронной модели на основе событий](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span><span class="sxs-lookup"><span data-stu-id="1ec42-250">The Microsoft .NET Framework Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see [Event-based Asynchronous Pattern Overview](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span></span> <span data-ttu-id="1ec42-251">Например, предположим, что мы хотели упаковать метод `FetchWeatherFromServer` в неграфический компонент многократного использования.</span><span class="sxs-lookup"><span data-stu-id="1ec42-251">For instance, suppose we wanted to package the `FetchWeatherFromServer` method into a reusable, nongraphical component.</span></span> <span data-ttu-id="1ec42-252">После стандартного шаблона Microsoft .NET Framework это будет выглядеть примерно следующим образом.</span><span class="sxs-lookup"><span data-stu-id="1ec42-252">Following the standard Microsoft .NET Framework pattern, this would look something like the following.</span></span>

 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]

 <span data-ttu-id="1ec42-253">`GetWeatherAsync` использовал бы один из методов, описанных выше, таких как создание фонового потока, для работы в асинхронном режиме, не блокируя вызов потока.</span><span class="sxs-lookup"><span data-stu-id="1ec42-253">`GetWeatherAsync` would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.</span></span>

 <span data-ttu-id="1ec42-254">Одна из важнейших частей этого шаблона — вызов метода *имя_метода*`Completed` в том же потоке, который вызывал метод *имя_метода*`Async`, чтобы начать с.</span><span class="sxs-lookup"><span data-stu-id="1ec42-254">One of the most important parts of this pattern is calling the *MethodName*`Completed` method on the same thread that called the *MethodName*`Async` method to begin with.</span></span> <span data-ttu-id="1ec42-255">Это можно сделать с помощью [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] довольно просто, сохранив <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>, но затем неграфический компонент можно было бы использовать только в приложениях [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], а не в программах Windows Forms и ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="1ec42-255">You could do this using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, not in Windows Forms or ASP.NET programs.</span></span>

 <span data-ttu-id="1ec42-256">Класс <xref:System.Windows.Threading.DispatcherSynchronizationContext> решает эту потребность — представьте ее как упрощенную версию <xref:System.Windows.Threading.Dispatcher>, которая работает также с другими [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]ными платформами.</span><span class="sxs-lookup"><span data-stu-id="1ec42-256">The <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of <xref:System.Windows.Threading.Dispatcher> that works with other [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks as well.</span></span>

 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]

### <a name="nested-pumping"></a><span data-ttu-id="1ec42-257">Вложенная накачка</span><span class="sxs-lookup"><span data-stu-id="1ec42-257">Nested Pumping</span></span>
 <span data-ttu-id="1ec42-258">Иногда нецелесообразно полностью заблокировать [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] поток.</span><span class="sxs-lookup"><span data-stu-id="1ec42-258">Sometimes it is not feasible to completely lock up the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1ec42-259">Давайте рассмотрим метод <xref:System.Windows.MessageBox.Show%2A> класса <xref:System.Windows.MessageBox>.</span><span class="sxs-lookup"><span data-stu-id="1ec42-259">Let’s consider the <xref:System.Windows.MessageBox.Show%2A> method of the <xref:System.Windows.MessageBox> class.</span></span> <span data-ttu-id="1ec42-260"><xref:System.Windows.MessageBox.Show%2A> не возвращается, пока пользователь не нажмет кнопку ОК.</span><span class="sxs-lookup"><span data-stu-id="1ec42-260"><xref:System.Windows.MessageBox.Show%2A> doesn’t return until the user clicks the OK button.</span></span> <span data-ttu-id="1ec42-261">Однако он создает окно, которое должно иметь цикл обработки сообщений, чтобы быть интерактивным.</span><span class="sxs-lookup"><span data-stu-id="1ec42-261">It does, however, create a window that must have a message loop in order to be interactive.</span></span> <span data-ttu-id="1ec42-262">Ожидая, когда пользователь нажмет кнопку "ОК", исходное окно приложения не отвечает на ввод данных пользователем.</span><span class="sxs-lookup"><span data-stu-id="1ec42-262">While we are waiting for the user to click OK, the original application window does not respond to user input.</span></span> <span data-ttu-id="1ec42-263">Тем не менее оно продолжает обрабатывать сообщения отображения.</span><span class="sxs-lookup"><span data-stu-id="1ec42-263">It does, however, continue to process paint messages.</span></span> <span data-ttu-id="1ec42-264">Исходное окно перерисовывается при его перекрытии и выведении.</span><span class="sxs-lookup"><span data-stu-id="1ec42-264">The original window redraws itself when covered and revealed.</span></span>

 ![Снимок экрана, показывающий MessageBox с кнопкой "ОК"](./media/threading-model/threading-message-loop.png)

 <span data-ttu-id="1ec42-266">Данное окно сообщения должно подчиняться какому-либо потоку.</span><span class="sxs-lookup"><span data-stu-id="1ec42-266">Some thread must be in charge of the message box window.</span></span> <span data-ttu-id="1ec42-267">Приложение [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] могло бы создать новый поток специально для данного окна сообщения, но этот поток не смог бы отображать отключенные элементы в исходном окне (вспомните предыдущее обсуждение взаимного исключения).</span><span class="sxs-lookup"><span data-stu-id="1ec42-267">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion).</span></span> <span data-ttu-id="1ec42-268">Вместо этого [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] использует систему обработки вложенных сообщений.</span><span class="sxs-lookup"><span data-stu-id="1ec42-268">Instead, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system.</span></span> <span data-ttu-id="1ec42-269">Класс <xref:System.Windows.Threading.Dispatcher> содержит специальный метод с именем <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, который сохраняет текущую точку выполнения приложения, а затем начинает новый цикл обработки сообщений.</span><span class="sxs-lookup"><span data-stu-id="1ec42-269">The <xref:System.Windows.Threading.Dispatcher> class includes a special method called <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop.</span></span> <span data-ttu-id="1ec42-270">После завершения цикла вложенных сообщений выполнение возобновляется после исходного вызова <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>.</span><span class="sxs-lookup"><span data-stu-id="1ec42-270">When the nested message loop finishes, execution resumes after the original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call.</span></span>

 <span data-ttu-id="1ec42-271">В этом случае <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> поддерживает контекст программы при вызове <xref:System.Windows.MessageBox.Show%2A?displayProperty=nameWithType>и запускает новый цикл обработки сообщений для перерисовки фонового окна и обработки входных данных в окне окна сообщения.</span><span class="sxs-lookup"><span data-stu-id="1ec42-271">In this case, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to <xref:System.Windows.MessageBox.Show%2A?displayProperty=nameWithType>, and it starts a new message loop to repaint the background window and handle input to the message box window.</span></span> <span data-ttu-id="1ec42-272">Когда пользователь нажимает кнопку ОК и очищает всплывающее окно, вложенный цикл завершает работу и управление возобновляется после вызова <xref:System.Windows.MessageBox.Show%2A>.</span><span class="sxs-lookup"><span data-stu-id="1ec42-272">When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to <xref:System.Windows.MessageBox.Show%2A>.</span></span>

### <a name="stale-routed-events"></a><span data-ttu-id="1ec42-273">Устаревшие перенаправленные события</span><span class="sxs-lookup"><span data-stu-id="1ec42-273">Stale Routed Events</span></span>
 <span data-ttu-id="1ec42-274">Система перенаправленных событий в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] уведомляет все деревья при возникновении событий.</span><span class="sxs-lookup"><span data-stu-id="1ec42-274">The routed event system in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised.</span></span>

 [!code-xaml[InputOvw#ThreadingArticleStaticRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]

 <span data-ttu-id="1ec42-275">При нажатии левой кнопки мыши над эллипсом `handler2` выполняется.</span><span class="sxs-lookup"><span data-stu-id="1ec42-275">When the left mouse button is pressed over the ellipse, `handler2` is executed.</span></span> <span data-ttu-id="1ec42-276">По завершении `handler2` событие передается в объект <xref:System.Windows.Controls.Canvas>, который использует `handler1` для обработки.</span><span class="sxs-lookup"><span data-stu-id="1ec42-276">After `handler2` finishes, the event is passed along to the <xref:System.Windows.Controls.Canvas> object, which uses `handler1` to process it.</span></span> <span data-ttu-id="1ec42-277">Это происходит только в том случае, если `handler2` явно не помечает объект события как обработанный.</span><span class="sxs-lookup"><span data-stu-id="1ec42-277">This happens only if `handler2` does not explicitly mark the event object as handled.</span></span>

 <span data-ttu-id="1ec42-278">Возможно, `handler2` потребует много времени на обработку этого события.</span><span class="sxs-lookup"><span data-stu-id="1ec42-278">It’s possible that `handler2` will take a great deal of time processing this event.</span></span> <span data-ttu-id="1ec42-279">`handler2` может использовать <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, чтобы начать вложенный цикл обработки сообщений, который не возвращается в течение часов.</span><span class="sxs-lookup"><span data-stu-id="1ec42-279">`handler2` might use <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours.</span></span> <span data-ttu-id="1ec42-280">Если `handler2` не помечает событие как обработанное при завершении цикла обработки сообщений, событие передается вверх по дереву, несмотря на то, что оно очень старое.</span><span class="sxs-lookup"><span data-stu-id="1ec42-280">If `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.</span></span>

### <a name="reentrancy-and-locking"></a><span data-ttu-id="1ec42-281">Повторный вход и блокировка</span><span class="sxs-lookup"><span data-stu-id="1ec42-281">Reentrancy and Locking</span></span>
 <span data-ttu-id="1ec42-282">Механизм блокировки среды CLR не работает в точности так, как это возможно. один из них может ожидать, что поток полностью прекратит операцию при запросе блокировки.</span><span class="sxs-lookup"><span data-stu-id="1ec42-282">The locking mechanism of the common language runtime (CLR) doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock.</span></span> <span data-ttu-id="1ec42-283">В действительности поток продолжает получать и обрабатывать сообщения с высоким приоритетом.</span><span class="sxs-lookup"><span data-stu-id="1ec42-283">In actuality, the thread continues to receive and process high-priority messages.</span></span> <span data-ttu-id="1ec42-284">Это помогает избежать взаимоблокировок и максимально повышает скорость отклика интерфейсов, но может приводить к незначительным ошибкам.</span><span class="sxs-lookup"><span data-stu-id="1ec42-284">This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.</span></span>  <span data-ttu-id="1ec42-285">Подавляющее большинство раз не нужно ничего знать об этом, но в редких обстоятельствах (обычно при использовании сообщений окна Win32 или компонентов COM STA) это может быть необходимо знать.</span><span class="sxs-lookup"><span data-stu-id="1ec42-285">The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving Win32 window messages or COM STA components) this can be worth knowing.</span></span>

 <span data-ttu-id="1ec42-286">Большинство интерфейсов не создаются с учетом потокобезопасности, поскольку разработчики работают с предположением о том, что доступ к [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] никогда не осуществляется более чем одним потоком.</span><span class="sxs-lookup"><span data-stu-id="1ec42-286">Most interfaces are not built with thread safety in mind because developers work under the assumption that a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread.</span></span> <span data-ttu-id="1ec42-287">В этом случае один поток может вносить изменения в окружающую среду в непредвиденное время, что приводит к некорректному эффекту решения <xref:System.Windows.Threading.DispatcherObject> механизмом взаимного исключения.</span><span class="sxs-lookup"><span data-stu-id="1ec42-287">In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve.</span></span> <span data-ttu-id="1ec42-288">Рассмотрим следующий псевдокод:</span><span class="sxs-lookup"><span data-stu-id="1ec42-288">Consider the following pseudocode:</span></span>

 <span data-ttu-id="1ec42-289">![Схема, показывающая повторный вход в поток.](./media/threading-model/threading-reentrancy.png "среадингринтранци")</span><span class="sxs-lookup"><span data-stu-id="1ec42-289">![Diagram that shows threading reentrancy.](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span></span>

 <span data-ttu-id="1ec42-290">В большинстве случаев это верно, но бывают случаи, в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], в которых такой непредвиденный повторный вход может привести к проблемам.</span><span class="sxs-lookup"><span data-stu-id="1ec42-290">Most of the time that’s the right thing, but there are times in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems.</span></span> <span data-ttu-id="1ec42-291">Таким образом, в определенный момент времени [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] вызывает <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, который изменяет инструкцию блокировки для этого потока на использование блокировки повторного входа в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], а не обычной блокировки CLR.</span><span class="sxs-lookup"><span data-stu-id="1ec42-291">So, at certain key times, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] calls <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual CLR lock.</span></span>

 <span data-ttu-id="1ec42-292">Итак, почему группа разработчиков CLR выбрала такое поведение?</span><span class="sxs-lookup"><span data-stu-id="1ec42-292">So why did the CLR team choose this behavior?</span></span> <span data-ttu-id="1ec42-293">Это было связано с объектами COM STA и завершением потока.</span><span class="sxs-lookup"><span data-stu-id="1ec42-293">It had to do with COM STA objects and the finalization thread.</span></span> <span data-ttu-id="1ec42-294">Когда объект уничтожается сборщиком мусора, его `Finalize`ный метод выполняется в выделенном потоке метода завершения, а не в [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]ном потоке.</span><span class="sxs-lookup"><span data-stu-id="1ec42-294">When an object is garbage collected, its `Finalize` method is run on the dedicated finalizer thread, not the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1ec42-295">И в этом заключается проблема, поскольку объект COM STA, созданный в [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] потоке, может быть удален только в потоке [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1ec42-295">And therein lies the problem, because a COM STA object that was created on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1ec42-296">Среда CLR эквивалентна <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (в данном случае — с помощью Win32's `SendMessage`).</span><span class="sxs-lookup"><span data-stu-id="1ec42-296">The CLR does the equivalent of a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s `SendMessage`).</span></span> <span data-ttu-id="1ec42-297">Но если поток [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] занят, поток завершения останавливается и объект COM STA не может быть удален, что создает серьезную утечку памяти.</span><span class="sxs-lookup"><span data-stu-id="1ec42-297">But if the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak.</span></span> <span data-ttu-id="1ec42-298">Так что группа разработчиков CLR сделала трудный вызов, чтобы блокировки работали так, как они делают.</span><span class="sxs-lookup"><span data-stu-id="1ec42-298">So the CLR team made the tough call to make locks work the way they do.</span></span>

 <span data-ttu-id="1ec42-299">Задача для [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] заключается в предотвращении непредвиденного повторного входа без повторного введения утечек памяти, поэтому мы не блокируем повторного входа везде.</span><span class="sxs-lookup"><span data-stu-id="1ec42-299">The task for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.</span></span>

## <a name="see-also"></a><span data-ttu-id="1ec42-300">См. также:</span><span class="sxs-lookup"><span data-stu-id="1ec42-300">See also</span></span>

- [<span data-ttu-id="1ec42-301">Пример однопоточного приложения с длительным выполнением вычислений</span><span class="sxs-lookup"><span data-stu-id="1ec42-301">Single-Threaded Application with Long-Running Calculation Sample</span></span>](https://go.microsoft.com/fwlink/?LinkID=160038)
