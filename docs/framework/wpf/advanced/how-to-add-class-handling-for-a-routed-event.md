---
title: Практическое руководство. Добавление обработки классов для перенаправленных событий
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- routed events [WPF], class handlers
- task_core_add_class_handling_routed_properties [WPF]
- class handlers [WPF], routed events
ms.assetid: 15b7b06c-9112-4ee5-b30a-65d10c5c5df6
ms.openlocfilehash: 7b897954cbdab461dc0305c6290e67c1af5282c3
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/08/2019
ms.locfileid: "59224277"
---
# <a name="how-to-add-class-handling-for-a-routed-event"></a><span data-ttu-id="5f921-102">Практическое руководство. Добавление обработки классов для перенаправленных событий</span><span class="sxs-lookup"><span data-stu-id="5f921-102">How to: Add Class Handling for a Routed Event</span></span>
<span data-ttu-id="5f921-103">Перенаправленные события могут быть обработаны с помощью обработчики классов или экземпляров на заданного узла в маршруте.</span><span class="sxs-lookup"><span data-stu-id="5f921-103">Routed events can be handled either by class handlers or instance handlers on any given node in the route.</span></span> <span data-ttu-id="5f921-104">Обработчики классов вызываются первыми, а также может использоваться реализациями класса для подавления событий обработчиков экземпляров или введения вариантов поведения других событий для события, которые принадлежат базовых классов.</span><span class="sxs-lookup"><span data-stu-id="5f921-104">Class handlers are invoked first, and can be used by class implementations to suppress events from instance handling or introduce other event specific behaviors on events that are owned by base classes.</span></span> <span data-ttu-id="5f921-105">В этом примере показаны два тесно связанные методы для реализации обработчиков класса.</span><span class="sxs-lookup"><span data-stu-id="5f921-105">This example illustrates two closely related techniques for implementing class handlers.</span></span>  
  
## <a name="example"></a><span data-ttu-id="5f921-106">Пример</span><span class="sxs-lookup"><span data-stu-id="5f921-106">Example</span></span>  
 <span data-ttu-id="5f921-107">В этом примере пользовательский класс, основанный на <xref:System.Windows.Controls.Canvas> панели.</span><span class="sxs-lookup"><span data-stu-id="5f921-107">This example uses a custom class based on the <xref:System.Windows.Controls.Canvas> panel.</span></span> <span data-ttu-id="5f921-108">Основной замысел приложения является то, что пользовательский класс представляет поведение его дочерних элементов, включая перехват, нажатии любой кнопки мыши и маркировки, их обработки, прежде чем будет вызван дочернего элемента класса или любого обработчика экземпляров на нем.</span><span class="sxs-lookup"><span data-stu-id="5f921-108">The basic premise of the application is that the custom class introduces behaviors on its child elements, including intercepting any left mouse button clicks and marking them handled, before the child element class or any instance handlers on it will be invoked.</span></span>  
  
 <span data-ttu-id="5f921-109"><xref:System.Windows.UIElement> Класс предоставляет виртуальный метод, позволяющий обработки класса в <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> событие, просто переопределив метод события.</span><span class="sxs-lookup"><span data-stu-id="5f921-109">The <xref:System.Windows.UIElement> class exposes a virtual method that enables class handling on the <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> event, by simply overriding the event.</span></span> <span data-ttu-id="5f921-110">Это самый простой способ реализовать обработку класса, если виртуальный метод доступен где-то в иерархии класса.</span><span class="sxs-lookup"><span data-stu-id="5f921-110">This is the simplest way to implement class handling if such a virtual method is available somewhere in your class' hierarchy.</span></span> <span data-ttu-id="5f921-111">В следующем коде показан <xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A> реализацию в «MyEditContainer», который является производным от <xref:System.Windows.Controls.Canvas>.</span><span class="sxs-lookup"><span data-stu-id="5f921-111">The following code shows the <xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A> implementation in the "MyEditContainer" that is derived from <xref:System.Windows.Controls.Canvas>.</span></span> <span data-ttu-id="5f921-112">Реализация помечает событие как обработанное в аргументах, а затем добавляет часть кода для предоставления основное видимое изменение исходного элемента.</span><span class="sxs-lookup"><span data-stu-id="5f921-112">The implementation marks the event as handled in the arguments, and then adds some code to give the source element a basic visible change.</span></span>  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 <span data-ttu-id="5f921-113">Если нет виртуальных базовых классов или для этого конкретного метода, обработка класса можно добавить непосредственно с помощью служебной программы метод <xref:System.Windows.EventManager> класса <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="5f921-113">If no virtual is available on base classes or for that particular method, class handling can be added directly using a utility method of the <xref:System.Windows.EventManager> class, <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span> <span data-ttu-id="5f921-114">Этот метод должен вызываться только внутри статической инициализации классов, которые используют обработку классов.</span><span class="sxs-lookup"><span data-stu-id="5f921-114">This method should only be called within the static initialization of classes that are adding class handling.</span></span> <span data-ttu-id="5f921-115">В этом примере добавляется еще один обработчик для <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> , и в этом случае зарегистрированный класс является пользовательским классом.</span><span class="sxs-lookup"><span data-stu-id="5f921-115">This example adds another handler for <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> , and in this case the registered class is the custom class.</span></span> <span data-ttu-id="5f921-116">Напротив, при использовании виртуальных методов, зарегистрированный класс является <xref:System.Windows.UIElement> базового класса.</span><span class="sxs-lookup"><span data-stu-id="5f921-116">In contrast, when using the virtuals, the registered class is really the <xref:System.Windows.UIElement> base class.</span></span> <span data-ttu-id="5f921-117">В случаях, где базовых классов и подклассов зарегистрировать обработку класса обработчики подклассов вызываются первыми.</span><span class="sxs-lookup"><span data-stu-id="5f921-117">In cases where base classes and subclass each register class handling, the subclass handlers are invoked first.</span></span> <span data-ttu-id="5f921-118">Поведение в приложении бы, что сначала этот обработчик отобразит окно сообщения, а затем будет показано визуальное изменение в обработчике виртуального метода.</span><span class="sxs-lookup"><span data-stu-id="5f921-118">The behavior in an application would be that first this handler would show its message box and then the visual change in the virtual method's handler would be shown.</span></span>  
  
 [!code-csharp[ClassHandling#StaticAndRegisterClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#staticandregisterclasshandler)]
 [!code-vb[ClassHandling#StaticAndRegisterClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#staticandregisterclasshandler)]  
  
## <a name="see-also"></a><span data-ttu-id="5f921-119">См. также</span><span class="sxs-lookup"><span data-stu-id="5f921-119">See also</span></span>

- <xref:System.Windows.EventManager>
- [<span data-ttu-id="5f921-120">Маркировка перенаправленных событий как обработанных и обработка классов</span><span class="sxs-lookup"><span data-stu-id="5f921-120">Marking Routed Events as Handled, and Class Handling</span></span>](marking-routed-events-as-handled-and-class-handling.md)
- [<span data-ttu-id="5f921-121">Обработка перенаправленных событий</span><span class="sxs-lookup"><span data-stu-id="5f921-121">Handle a Routed Event</span></span>](how-to-handle-a-routed-event.md)
- [<span data-ttu-id="5f921-122">Общие сведения о перенаправленных событиях</span><span class="sxs-lookup"><span data-stu-id="5f921-122">Routed Events Overview</span></span>](routed-events-overview.md)
