---
title: Общие сведения о вложенных свойствах зависимостей
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- attached properties [WPF Designer]
ms.assetid: 75928354-dc01-47e8-a018-8409aec1f32d
ms.openlocfilehash: 2eacb0ff49b868f144bf35af4bb64b7d049b30cb
ms.sourcegitcommit: 24a4a8eb6d8cfe7b8549fb6d823076d7c697e0c6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/23/2019
ms.locfileid: "68401392"
---
# <a name="attached-properties-overview"></a><span data-ttu-id="13919-102">Общие сведения о вложенных свойствах зависимостей</span><span class="sxs-lookup"><span data-stu-id="13919-102">Attached Properties Overview</span></span>

<span data-ttu-id="13919-103">Присоединенное свойство — это понятие, определяемое языком XAML.</span><span class="sxs-lookup"><span data-stu-id="13919-103">An attached property is a concept defined by XAML.</span></span> <span data-ttu-id="13919-104">Присоединенное свойство предназначено для использования в качестве типа глобального свойства, которое может быть задано для любого объекта.</span><span class="sxs-lookup"><span data-stu-id="13919-104">An attached property is intended to be used as a type of global property that is settable on any object.</span></span> <span data-ttu-id="13919-105">В [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] присоединенные свойства обычно определяются как особая форма свойства зависимости, не имеющего обычной "оболочки" свойства.</span><span class="sxs-lookup"><span data-stu-id="13919-105">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], attached properties are typically defined as a specialized form of dependency property that does not have the conventional property "wrapper".</span></span>

## <span data-ttu-id="13919-106">Требований<a name="prerequisites"></a></span><span class="sxs-lookup"><span data-stu-id="13919-106">Prerequisites <a name="prerequisites"></a></span></span>

<span data-ttu-id="13919-107">Предполагается, что вы имеете представление о свойствах зависимостей с точки зрения потребителя существующих свойств зависимостей в классах [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] и ознакомились с разделом [Общие сведения о свойствах зависимостей](dependency-properties-overview.md).</span><span class="sxs-lookup"><span data-stu-id="13919-107">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md).</span></span> <span data-ttu-id="13919-108">Чтобы выполнить примеры в этом разделе, необходимо также понимать XAML и знать, как писать приложения WPF.</span><span class="sxs-lookup"><span data-stu-id="13919-108">To follow the examples in this topic, you should also understand XAML and know how to write WPF applications.</span></span>

## <span data-ttu-id="13919-109">Зачем использовать присоединенные свойства<a name="attached_properties_usage"></a></span><span class="sxs-lookup"><span data-stu-id="13919-109">Why Use Attached Properties <a name="attached_properties_usage"></a></span></span>

<span data-ttu-id="13919-110">Среди прочего, присоединенные свойства позволяют разным дочерним элементам задавать уникальные значения для свойства, которое фактически определено в родительском элементе.</span><span class="sxs-lookup"><span data-stu-id="13919-110">One purpose of an attached property is to allow different child elements to specify unique values for a property that is actually defined in a parent element.</span></span> <span data-ttu-id="13919-111">Конкретным примером этого сценария является уведомление дочерними элементами родительского элемента о порядке их представления в [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="13919-111">A specific application of this scenario is having child elements inform the parent element of how they are to be presented in the [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="13919-112">Одним из примеров является <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> свойство.</span><span class="sxs-lookup"><span data-stu-id="13919-112">One example is the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="13919-113">Свойство создается как присоединенное свойство, так как оно предназначено для установки в элементах, содержащихся <xref:System.Windows.Controls.DockPanel>в, а не на <xref:System.Windows.Controls.DockPanel> самом себе. <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="13919-113">The <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property is created as an attached property because it is designed to be set on elements that are contained within a <xref:System.Windows.Controls.DockPanel>, rather than on <xref:System.Windows.Controls.DockPanel> itself.</span></span> <span data-ttu-id="13919-114"><xref:System.Windows.DependencyProperty> <xref:System.Windows.Controls.DockPanel.DockProperty> <xref:System.Windows.Controls.DockPanel.GetDock%2A> Класс определяет статическое поле с именем, а затем предоставляет методы и <xref:System.Windows.Controls.DockPanel.SetDock%2A> в качестве открытых методов доступа для присоединенного свойства. <xref:System.Windows.Controls.DockPanel></span><span class="sxs-lookup"><span data-stu-id="13919-114">The <xref:System.Windows.Controls.DockPanel> class defines the static <xref:System.Windows.DependencyProperty> field named <xref:System.Windows.Controls.DockPanel.DockProperty>, and then provides the <xref:System.Windows.Controls.DockPanel.GetDock%2A> and <xref:System.Windows.Controls.DockPanel.SetDock%2A> methods as public accessors for the attached property.</span></span>

## <span data-ttu-id="13919-115">Вложенные свойства в XAML<a name="attached_properties_xaml"></a></span><span class="sxs-lookup"><span data-stu-id="13919-115">Attached Properties in XAML <a name="attached_properties_xaml"></a></span></span>

<span data-ttu-id="13919-116">В XAML присоединенные свойства задаются с помощью синтаксиса *ПоставщикПрисоединенногоСвойства*.*ИмяСвойства*.</span><span class="sxs-lookup"><span data-stu-id="13919-116">In XAML, you set attached properties by using the syntax *AttachedPropertyProvider*.*PropertyName*</span></span>

<span data-ttu-id="13919-117">Ниже приведен пример того, как можно задать <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> в XAML:</span><span class="sxs-lookup"><span data-stu-id="13919-117">The following is an example of how you can set <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> in XAML:</span></span>

[!code-xaml[PropertiesOvwSupport#APBasicUsage](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#apbasicusage)]

<span data-ttu-id="13919-118">Обратите внимание, что использование в некоторой степени похоже на статическое свойство. всегда следует ссылаться на тип <xref:System.Windows.Controls.DockPanel> , который владеет и регистрирует присоединенное свойство, а не ссылаться на любой экземпляр, указанный по имени.</span><span class="sxs-lookup"><span data-stu-id="13919-118">Note that the usage is somewhat similar to a static property; you always reference the type <xref:System.Windows.Controls.DockPanel> that owns and registers the attached property, rather than referring to any instance specified by name.</span></span>

<span data-ttu-id="13919-119">Кроме того, поскольку присоединенное свойство в XAML является атрибутом, который устанавливается в разметке, операция задания является значимой.</span><span class="sxs-lookup"><span data-stu-id="13919-119">Also, because an attached property in XAML is an attribute that you set in markup, only the set operation has any relevance.</span></span> <span data-ttu-id="13919-120">Нельзя напрямую получить свойство в XAML, хотя существуют некоторые косвенные механизмы для сравнения значений, такие как триггеры в стилях (подробнее см. в разделе [Стилизация и использование шаблонов](../controls/styling-and-templating.md)).</span><span class="sxs-lookup"><span data-stu-id="13919-120">You cannot directly get a property in XAML, although there are some indirect mechanisms for comparing values, such as triggers in styles (for details, see [Styling and Templating](../controls/styling-and-templating.md)).</span></span>

### <a name="attached-property-implementation-in-wpf"></a><span data-ttu-id="13919-121">Реализация присоединенного свойства в WPF</span><span class="sxs-lookup"><span data-stu-id="13919-121">Attached Property Implementation in WPF</span></span>

<span data-ttu-id="13919-122">В [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]большинство присоединенных свойств, которые существуют в типах WPF, связанных с представлением пользовательского интерфейса, реализуются как свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="13919-122">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], most of the attached properties that exist on WPF types that are related to UI presentation are implemented as dependency properties.</span></span> <span data-ttu-id="13919-123">Присоединенные свойства являются концепцией XAML, тогда как свойства зависимостей являются понятием WPF.</span><span class="sxs-lookup"><span data-stu-id="13919-123">Attached properties are a XAML concept, whereas dependency properties are a WPF concept.</span></span> <span data-ttu-id="13919-124">Поскольку вложенные свойства WPF являются свойствами зависимостей, они поддерживают понятия свойств зависимостей, такие как метаданные свойств, и значения по умолчанию из метаданных этого свойства.</span><span class="sxs-lookup"><span data-stu-id="13919-124">Because WPF attached properties are dependency properties, they support dependency property concepts such as property metadata, and default values from that property metadata.</span></span>

## <span data-ttu-id="13919-125">Как присоединенные свойства используются типом-владельцем<a name="howused"></a></span><span class="sxs-lookup"><span data-stu-id="13919-125">How Attached Properties Are Used by the Owning Type <a name="howused"></a></span></span>

<span data-ttu-id="13919-126">Хотя присоединенные свойства могут устанавливаться для любого объекта, это не означает, что задание свойства будет создавать осязаемый результат или что значение будет когда-либо использоваться другим объектом.</span><span class="sxs-lookup"><span data-stu-id="13919-126">Although attached properties are settable on any object, that does not automatically mean that setting the property will produce a tangible result, or that the value will ever be used by another object.</span></span> <span data-ttu-id="13919-127">Как правило, использование присоединенных свойств подразумевает, что объекты, поступающие из разнообразных иерархий классов или логических связей, могут передавать общую информацию в тип, который определяет присоединенное свойство.</span><span class="sxs-lookup"><span data-stu-id="13919-127">Generally, attached properties are intended so that objects coming from a wide variety of possible class hierarchies or logical relationships can each report common information to the type that defines the attached property.</span></span> <span data-ttu-id="13919-128">Тип, который определяет присоединенное свойство, обычно соответствует одной из следующих моделей.</span><span class="sxs-lookup"><span data-stu-id="13919-128">The type that defines the attached property typically follows one of these models:</span></span>

- <span data-ttu-id="13919-129">Тип, который определяет присоединенное свойство, может являться родительским элементом для элементов, которые будут задавать значения для присоединенного свойства.</span><span class="sxs-lookup"><span data-stu-id="13919-129">The type that defines the attached property is designed so that it can be the parent element of the elements that will set values for the attached property.</span></span> <span data-ttu-id="13919-130">Тип, который затем выполняет итерацию его дочерних объектов согласно внутренней логике относительно некоторой структуры дерева объектов, получает значения и выполняет с этими значениями какие-либо действия.</span><span class="sxs-lookup"><span data-stu-id="13919-130">The type then iterates its child objects through internal logic against some object tree structure, obtains the values, and acts on those values in some manner.</span></span>

- <span data-ttu-id="13919-131">Тип, который определяет присоединенное свойство, будет использоваться в качестве дочернего элемента для разнообразных возможных родительских элементов и моделей содержимого.</span><span class="sxs-lookup"><span data-stu-id="13919-131">The type that defines the attached property will be used as the child element for a variety of possible parent elements and content models.</span></span>

- <span data-ttu-id="13919-132">Тип, который определяет присоединенное свойство, представляет службу.</span><span class="sxs-lookup"><span data-stu-id="13919-132">The type that defines the attached property represents a service.</span></span> <span data-ttu-id="13919-133">Другие типы устанавливают значения для присоединенного свойства.</span><span class="sxs-lookup"><span data-stu-id="13919-133">Other types set values for the attached property.</span></span> <span data-ttu-id="13919-134">Затем, когда элемент, задающий свойство, вычисляется в контексте службы, значения присоединенного свойства получаются через внутреннюю логику класса службы.</span><span class="sxs-lookup"><span data-stu-id="13919-134">Then, when the element that set the property is evaluated in the context of the service, the attached property values are obtained through internal logic of the service class.</span></span>

### <a name="an-example-of-a-parent-defined-attached-property"></a><span data-ttu-id="13919-135">Пример присоединенного свойства, определенного родительским элементом</span><span class="sxs-lookup"><span data-stu-id="13919-135">An Example of a Parent-Defined Attached Property</span></span>

<span data-ttu-id="13919-136">Наиболее типичный сценарий, в котором WPF определяет присоединенное свойство, — когда родительский элемент поддерживает коллекцию дочерних элементов, а также реализует поведение, при котором особенности поведения передаются по отдельности для каждого дочернего элемента.</span><span class="sxs-lookup"><span data-stu-id="13919-136">The most typical scenario where WPF defines an attached property is when a parent element supports a child element collection, and also implements a behavior where the specifics of the behavior are reported individually for each child element.</span></span>

<span data-ttu-id="13919-137"><xref:System.Windows.Controls.DockPanel>Определяет присоединенное свойство и <xref:System.Windows.Controls.DockPanel> содержит код уровня класса как часть его логики отрисовки (в частности, <xref:System.Windows.Controls.DockPanel.MeasureOverride%2A> и <xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>). <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="13919-137"><xref:System.Windows.Controls.DockPanel> defines the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property, and <xref:System.Windows.Controls.DockPanel> has class-level code as part of its rendering logic (specifically, <xref:System.Windows.Controls.DockPanel.MeasureOverride%2A> and <xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>).</span></span> <span data-ttu-id="13919-138">Экземпляр всегда проверяет, установил ли какой-либо из его непосредственных дочерних элементов значение для <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>. <xref:System.Windows.Controls.DockPanel></span><span class="sxs-lookup"><span data-stu-id="13919-138">A <xref:System.Windows.Controls.DockPanel> instance will always check to see whether any of its immediate child elements have set a value for <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="13919-139">В таком случае эти значения становятся входными данными для логики отображения, применяемой к соответствующему дочернему элементу.</span><span class="sxs-lookup"><span data-stu-id="13919-139">If so, those values become input for the rendering logic applied to that particular child element.</span></span> <span data-ttu-id="13919-140">Каждый <xref:System.Windows.Controls.DockPanel> вложенный экземпляр обрабатывает собственные непосредственные коллекции дочерних элементов, но это поведение зависит от реализации того <xref:System.Windows.Controls.DockPanel> , <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> как обрабатываются значения.</span><span class="sxs-lookup"><span data-stu-id="13919-140">Nested <xref:System.Windows.Controls.DockPanel> instances each treat their own immediate child element collections, but that behavior is implementation-specific to how <xref:System.Windows.Controls.DockPanel> processes <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> values.</span></span> <span data-ttu-id="13919-141">Теоретически возможно наличие присоединенных свойств, оказывающих влияние на элементы за пределами непосредственного родителя.</span><span class="sxs-lookup"><span data-stu-id="13919-141">It is theoretically possible to have attached properties that influence elements beyond the immediate parent.</span></span> <span data-ttu-id="13919-142">Если присоединенное свойство задано для элемента, который не <xref:System.Windows.Controls.DockPanel> имеет родительского элемента, который будет работать с ним, то ошибка или исключение не возникает. <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="13919-142">If the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property is set on an element that has no <xref:System.Windows.Controls.DockPanel> parent element to act upon it, no error or exception is raised.</span></span> <span data-ttu-id="13919-143">Это просто означает, что задано глобальное значение свойства, но у него нет текущего <xref:System.Windows.Controls.DockPanel> родителя, который мог бы использовать эту информацию.</span><span class="sxs-lookup"><span data-stu-id="13919-143">This simply means that a global property value was set, but it has no current <xref:System.Windows.Controls.DockPanel> parent that could consume the information.</span></span>

## <span data-ttu-id="13919-144">Присоединенные свойства в коде<a name="attached_properties_code"></a></span><span class="sxs-lookup"><span data-stu-id="13919-144">Attached Properties in Code <a name="attached_properties_code"></a></span></span>

<span data-ttu-id="13919-145">Присоединенные свойства в WPF не имеют типовых методов оболочки CLR для простого доступа get/set.</span><span class="sxs-lookup"><span data-stu-id="13919-145">Attached properties in WPF do not have the typical CLR "wrapper" methods for easy get/set access.</span></span> <span data-ttu-id="13919-146">Это связано с тем, что присоединенное свойство не обязательно является частью пространства имен CLR для экземпляров, в которых задано свойство.</span><span class="sxs-lookup"><span data-stu-id="13919-146">This is because the attached property is not necessarily part of the CLR namespace for instances where the property is set.</span></span> <span data-ttu-id="13919-147">Тем не менее обработчик XAML должен иметь возможность задавать эти значения при анализе XAML.</span><span class="sxs-lookup"><span data-stu-id="13919-147">However, a XAML processor must be able to set those values when XAML is parsed.</span></span> <span data-ttu-id="13919-148">Для поддержки эффективного использования присоединенного свойства тип владельца присоединенного свойства должен реализовывать выделенные методы доступа в форме **Get_PropertyName_** и **Set_PropertyName_** .</span><span class="sxs-lookup"><span data-stu-id="13919-148">To support an effective attached property usage, the owner type of the attached property must implement dedicated accessor methods in the form **Get_PropertyName_** and **Set_PropertyName_**.</span></span> <span data-ttu-id="13919-149">Такие специальные методы доступа также удобны для получения или задания присоединенного свойства в коде.</span><span class="sxs-lookup"><span data-stu-id="13919-149">These dedicated accessor methods are also useful to get or set the attached property in code.</span></span> <span data-ttu-id="13919-150">С точки зрения кода присоединенное свойство аналогично резервному полю с методами доступа к методам вместо методов доступа к свойствам. Такое резервное поле может существовать для любого объекта и не требует специального определения.</span><span class="sxs-lookup"><span data-stu-id="13919-150">From a code perspective, an attached property is similar to a backing field that has method accessors instead of property accessors, and that backing field can exist on any object rather than needing to be specifically defined.</span></span>

<span data-ttu-id="13919-151">В следующем примере кода показано задание присоединенного свойства в коде.</span><span class="sxs-lookup"><span data-stu-id="13919-151">The following example shows how you can set an attached property in code.</span></span> <span data-ttu-id="13919-152">В этом примере `myCheckBox` — это экземпляр <xref:System.Windows.Controls.CheckBox> класса.</span><span class="sxs-lookup"><span data-stu-id="13919-152">In this example, `myCheckBox` is an instance of the <xref:System.Windows.Controls.CheckBox> class.</span></span>

[!code-csharp[PropertiesOvwSupport#APCode](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml.cs#apcode)]
[!code-vb[PropertiesOvwSupport#APCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page4.xaml.vb#apcode)]

<span data-ttu-id="13919-153">Как и в случае с примером XAML `myCheckBox` , если он еще не был добавлен в качестве дочернего `myDockPanel` элемента третьей строкой кода, то в четвертой строке кода не будет вызываться исключение, но значение свойства не <xref:System.Windows.Controls.DockPanel> будет взаимодействовать с родительским объектом и, таким образом, ничего не делает.</span><span class="sxs-lookup"><span data-stu-id="13919-153">Similar to the XAML case, if `myCheckBox` had not already been added as a child element of `myDockPanel` by the third line of code, the fourth line of code would not raise an exception, but the property value would not interact with a <xref:System.Windows.Controls.DockPanel> parent and thus would do nothing.</span></span> <span data-ttu-id="13919-154">Только значение, установленное в дочернем элементе вместе с присутствием <xref:System.Windows.Controls.DockPanel> родительского элемента, приведет к эффективному поведению в приложении, готовом для просмотра. <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="13919-154">Only a <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> value set on a child element combined with the presence of a <xref:System.Windows.Controls.DockPanel> parent element will cause an effective behavior in the rendered application.</span></span> <span data-ttu-id="13919-155">(В этом случае вы может задать присоединенное свойство, а затем подключиться к дереву.</span><span class="sxs-lookup"><span data-stu-id="13919-155">(In this case, you could set the attached property, then attach to the tree.</span></span> <span data-ttu-id="13919-156">Аналогично, можно подключиться к дереву, а затем задать присоединенное свойство.</span><span class="sxs-lookup"><span data-stu-id="13919-156">Or you could attach to the tree then set the attached property.</span></span> <span data-ttu-id="13919-157">Любая последовательность действий дает тот же результат.)</span><span class="sxs-lookup"><span data-stu-id="13919-157">Either action order provides the same result.)</span></span>

## <span data-ttu-id="13919-158">Метаданные присоединенного свойства<a name="attached_properties_metadata"></a></span><span class="sxs-lookup"><span data-stu-id="13919-158">Attached Property Metadata <a name="attached_properties_metadata"></a></span></span>

<span data-ttu-id="13919-159">При регистрации свойства <xref:System.Windows.FrameworkPropertyMetadata> задается для указания характеристик свойства, например, влияет ли свойство на отрисовку, измерение и т. д.</span><span class="sxs-lookup"><span data-stu-id="13919-159">When registering the property, <xref:System.Windows.FrameworkPropertyMetadata> is set to specify characteristics of the property, such as whether the property affects rendering, measurement, and so on.</span></span> <span data-ttu-id="13919-160">Метаданные для присоединенного свойства, как правило, не отличаются от задаваемых для свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="13919-160">Metadata for an attached property is generally no different than on a dependency property.</span></span> <span data-ttu-id="13919-161">Если задать значение по умолчанию в переопределении для метаданных присоединенного свойства, это значение становится значением по умолчанию неявного присоединенного свойства для экземпляров переопределяющего класса.</span><span class="sxs-lookup"><span data-stu-id="13919-161">If you specify a default value in an override to attached property metadata, that value becomes the default value of the implicit attached property on instances of the overriding class.</span></span> <span data-ttu-id="13919-162">В частности, значение по умолчанию передается, если некоторый процесс запрашивает значение присоединенного свойства с помощью метода доступа `Get` для этого свойства, указывая экземпляр класса, в котором заданы метаданные, и значение для этого присоединенного свойства не задано иным образом.</span><span class="sxs-lookup"><span data-stu-id="13919-162">Specifically, your default value is reported if some process queries for the value of an attached property through the `Get` method accessor for that property, specifying an instance of the class where you specified the metadata, and the value for that attached property was otherwise not set.</span></span>

<span data-ttu-id="13919-163">Если вы хотите разрешить наследование значений свойства, следует использовать присоединенные свойства, вместо неприсоединенных свойств зависимостей.</span><span class="sxs-lookup"><span data-stu-id="13919-163">If you want to enable property value inheritance on a property, you should use attached properties rather than non-attached dependency properties.</span></span> <span data-ttu-id="13919-164">Подробнее см. в разделе [Наследование значения свойства](property-value-inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="13919-164">For details, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

## <span data-ttu-id="13919-165">Пользовательские присоединенные свойства<a name="custom"></a></span><span class="sxs-lookup"><span data-stu-id="13919-165">Custom Attached Properties <a name="custom"></a></span></span>

### <span data-ttu-id="13919-166">Когда следует создавать присоединенное свойство<a name="create_attached_properties"></a></span><span class="sxs-lookup"><span data-stu-id="13919-166">When to Create an Attached Property <a name="create_attached_properties"></a></span></span>

<span data-ttu-id="13919-167">Присоединенное свойство можно создать, если требуется механизм задания свойств для классов, не являющихся определяющим классом.</span><span class="sxs-lookup"><span data-stu-id="13919-167">You might create an attached property when there is a reason to have a property setting mechanism available for classes other than the defining class.</span></span> <span data-ttu-id="13919-168">Наиболее распространенным сценарием является макет.</span><span class="sxs-lookup"><span data-stu-id="13919-168">The most common scenario for this is layout.</span></span> <span data-ttu-id="13919-169">Примерами существующих свойств макета являются <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>, <xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>и <xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="13919-169">Examples of existing layout properties are <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>, <xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>, and <xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="13919-170">В этом сценарии элементы, которые существуют как дочерние элементы для элементов, управляющих макетом, могут индивидуально выражать требования макета для своих родительских элементов, задавая значение свойства, определяемого родительским элементом как присоединенное свойство.</span><span class="sxs-lookup"><span data-stu-id="13919-170">The scenario enabled here is that elements that exist as child elements to layout-controlling elements are able to express layout requirements to their layout parent elements individually, each setting a property value that the parent defined as an attached property.</span></span>

<span data-ttu-id="13919-171">Другой сценарий использования присоединенного свойства — когда класс представляет службу и требуется реализовать более прозрачную интеграцию службы классами.</span><span class="sxs-lookup"><span data-stu-id="13919-171">Another scenario for using an attached property is when your class represents a service, and you want classes to be able to integrate the service more transparently.</span></span>

<span data-ttu-id="13919-172">Еще один сценарий — получение поддержки конструктора WPF Visual Studio, например изменение окна **свойств** .</span><span class="sxs-lookup"><span data-stu-id="13919-172">Yet another scenario is to receive Visual Studio WPF Designer support, such as **Properties** window editing.</span></span> <span data-ttu-id="13919-173">Дополнительные сведения см. в разделе [Общие сведения о разработке элементов управления](../controls/control-authoring-overview.md).</span><span class="sxs-lookup"><span data-stu-id="13919-173">For more information, see [Control Authoring Overview](../controls/control-authoring-overview.md).</span></span>

<span data-ttu-id="13919-174">Как упоминалось ранее, свойство следует регистрировать как присоединенное, если требуется использовать наследование значения свойства.</span><span class="sxs-lookup"><span data-stu-id="13919-174">As mentioned before, you should register as an attached property if you want to use property value inheritance.</span></span>

### <span data-ttu-id="13919-175">Создание присоединенного свойства<a name="how_do_i_create_attached_properties"></a></span><span class="sxs-lookup"><span data-stu-id="13919-175">How to Create an Attached Property <a name="how_do_i_create_attached_properties"></a></span></span>

<span data-ttu-id="13919-176">Если класс определяет присоединенное свойство исключительно для использования в других типах, класс не обязательно должен быть производным от <xref:System.Windows.DependencyObject>.</span><span class="sxs-lookup"><span data-stu-id="13919-176">If your class is defining the attached property strictly for use on other types, then the class does not have to derive from <xref:System.Windows.DependencyObject>.</span></span> <span data-ttu-id="13919-177">Но вам нужно создать производную от <xref:System.Windows.DependencyObject> , если вы подберете общую модель WPF, в которой присоединенное свойство также является свойством зависимостей.</span><span class="sxs-lookup"><span data-stu-id="13919-177">But you do need to derive from <xref:System.Windows.DependencyObject> if you follow the overall WPF model of having your attached property also be a dependency property.</span></span>

<span data-ttu-id="13919-178">Определите присоединенное свойство как свойство зависимостей, объявляя `public static readonly` поле типа. <xref:System.Windows.DependencyProperty></span><span class="sxs-lookup"><span data-stu-id="13919-178">Define your attached property as a dependency property by declaring a `public static readonly` field of type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="13919-179">Это поле определяется с помощью возвращаемого значения <xref:System.Windows.DependencyProperty.RegisterAttached%2A> метода.</span><span class="sxs-lookup"><span data-stu-id="13919-179">You define this field by using the return value of the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method.</span></span> <span data-ttu-id="13919-180">Имя поля должно совпадать с именем присоединенного свойства, добавленного со строкой `Property`, чтобы соответствовать установленному шаблону WPF именования идентифицирующих полей относительно свойств, которые они представляют.</span><span class="sxs-lookup"><span data-stu-id="13919-180">The field name must match the attached property name, appended with the string `Property`, to follow the established WPF pattern of naming the identifying fields versus the properties that they represent.</span></span> <span data-ttu-id="13919-181">Поставщик присоединенного свойства также должен предоставлять статические методы **Get_PropertyName_** и **Set_PropertyName_** в качестве методов доступа к присоединенному свойству. Если этого не сделать, система свойств не сможет использовать присоединенное свойство.</span><span class="sxs-lookup"><span data-stu-id="13919-181">The attached property provider must also provide static **Get_PropertyName_** and **Set_PropertyName_** methods as accessors for the attached property; failing to do this will result in the property system being unable to use your attached property.</span></span>

> [!NOTE]
> <span data-ttu-id="13919-182">Если опустить метод доступа Get присоединенного свойства, привязка данных к свойству не будет работать в средствах разработки, таких как Visual Studio и Expression Blend.</span><span class="sxs-lookup"><span data-stu-id="13919-182">If you omit the attached property's get accessor, data binding on the property will not work in design tools, such as Visual Studio and Expression Blend.</span></span>

#### <a name="the-get-accessor"></a><span data-ttu-id="13919-183">Метод доступа get</span><span class="sxs-lookup"><span data-stu-id="13919-183">The Get Accessor</span></span>

<span data-ttu-id="13919-184">Сигнатура для метода доступа **Get_PropertyName_** должна быть:</span><span class="sxs-lookup"><span data-stu-id="13919-184">The signature for the **Get_PropertyName_** accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="13919-185">Объект `target` можно указать как более конкретный тип в реализации.</span><span class="sxs-lookup"><span data-stu-id="13919-185">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="13919-186">Например, <xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType> метод присваивает <xref:System.Windows.UIElement>параметру значение, поскольку присоединенное свойство <xref:System.Windows.UIElement> предназначено только для экземпляров.</span><span class="sxs-lookup"><span data-stu-id="13919-186">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType> method types the parameter as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>

- <span data-ttu-id="13919-187">Возвращаемое значение можно указать как более конкретный тип в реализации.</span><span class="sxs-lookup"><span data-stu-id="13919-187">The return value can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="13919-188">Например <xref:System.Windows.Controls.DockPanel.GetDock%2A> , метод вводит тип <xref:System.Windows.Controls.Dock>, так как значение может быть задано только для этого перечисления.</span><span class="sxs-lookup"><span data-stu-id="13919-188">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span>

#### <a name="the-set-accessor"></a><span data-ttu-id="13919-189">Метод доступа set</span><span class="sxs-lookup"><span data-stu-id="13919-189">The Set Accessor</span></span>

<span data-ttu-id="13919-190">Сигнатура для метода доступа **Set_PropertyName_** должна быть:</span><span class="sxs-lookup"><span data-stu-id="13919-190">The signature for the **Set_PropertyName_** accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="13919-191">Объект `target` можно указать как более конкретный тип в реализации.</span><span class="sxs-lookup"><span data-stu-id="13919-191">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="13919-192">Например, <xref:System.Windows.Controls.DockPanel.SetDock%2A> метод вводит <xref:System.Windows.UIElement>значение, поскольку присоединенное свойство <xref:System.Windows.UIElement> предназначено только для экземпляров.</span><span class="sxs-lookup"><span data-stu-id="13919-192">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>

- <span data-ttu-id="13919-193">Объект `value` можно указать как более конкретный тип в реализации.</span><span class="sxs-lookup"><span data-stu-id="13919-193">The `value` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="13919-194">Например <xref:System.Windows.Controls.DockPanel.SetDock%2A> , метод вводит тип <xref:System.Windows.Controls.Dock>, так как значение может быть задано только для этого перечисления.</span><span class="sxs-lookup"><span data-stu-id="13919-194">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span> <span data-ttu-id="13919-195">Помните, что значением этого метода являются входные данные, поступающие от загрузчика XAML, когда он встречает присоединенное свойство в использовании присоединенного свойства в макете.</span><span class="sxs-lookup"><span data-stu-id="13919-195">Remember that the value for this method is the input coming from the XAML loader when it encounters your attached property in an attached property usage in markup.</span></span> <span data-ttu-id="13919-196">Эти входные данные являются значением, указанным как значение атрибута XAML в разметке.</span><span class="sxs-lookup"><span data-stu-id="13919-196">That input is the value specified as a XAML attribute value in markup.</span></span> <span data-ttu-id="13919-197">Таким образом, необходимо обеспечить поддержку преобразования типов, сериализатора значений или расширений разметки для используемого типа так, чтобы соответствующий тип можно было создать из значения атрибута (которое, в конечном счете, является просто строкой).</span><span class="sxs-lookup"><span data-stu-id="13919-197">Therefore there must be type conversion, value serializer, or markup extension support for the type you use, such that the appropriate type can be created from the attribute value (which is ultimately just a string).</span></span>

<span data-ttu-id="13919-198">В следующем примере показана регистрация свойства зависимостей (с помощью <xref:System.Windows.DependencyProperty.RegisterAttached%2A> метода), а также методы доступа **Get_PropertyName_** и **Set_PropertyName_** .</span><span class="sxs-lookup"><span data-stu-id="13919-198">The following example shows the dependency property registration (using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method), as well as the **Get_PropertyName_** and **Set_PropertyName_** accessors.</span></span> <span data-ttu-id="13919-199">В этом примере именем присоединенного свойства является `IsBubbleSource`.</span><span class="sxs-lookup"><span data-stu-id="13919-199">In the example, the attached property name is `IsBubbleSource`.</span></span> <span data-ttu-id="13919-200">Таким образом, методы доступа должны называться `GetIsBubbleSource` и `SetIsBubbleSource`.</span><span class="sxs-lookup"><span data-stu-id="13919-200">Therefore, the accessors must be named `GetIsBubbleSource` and `SetIsBubbleSource`.</span></span>

[!code-csharp[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler)]
[!code-vb[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler)]

#### <a name="attached-property-attributes"></a><span data-ttu-id="13919-201">Атрибуты присоединенного свойства</span><span class="sxs-lookup"><span data-stu-id="13919-201">Attached Property Attributes</span></span>

<span data-ttu-id="13919-202">WPF определяет несколько [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] , которые предназначены для предоставления сведений о вложенных свойствах процессам отражения, а также обычным пользователям отражения и информации о свойствах, таких как конструкторы.</span><span class="sxs-lookup"><span data-stu-id="13919-202">WPF defines several [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] that are intended to provide information about attached properties to reflection processes, and to typical users of reflection and property information such as designers.</span></span> <span data-ttu-id="13919-203">Поскольку присоединенные свойства имеют тип неограниченной области, разработчикам необходим способ, который позволит избежать представления пользователям глобального списка всех присоединенных свойств, которые определены в конкретной реализации технологии, использующей XAML.</span><span class="sxs-lookup"><span data-stu-id="13919-203">Because attached properties have a type of unlimited scope, designers need a way to avoid overwhelming users with a global list of all the attached properties that are defined in a particular technology implementation that uses XAML.</span></span> <span data-ttu-id="13919-204">Объект [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] , определяемый в WPF для присоединенных свойств, может использоваться для определения области ситуаций, в которых заданное присоединенное свойство должно отображаться в окне свойств.</span><span class="sxs-lookup"><span data-stu-id="13919-204">The [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] that WPF defines for attached properties can be used to scope the situations where a given attached property should be shown in a properties window.</span></span> <span data-ttu-id="13919-205">Эти атрибуты можно также применить для собственных присоединенных свойств.</span><span class="sxs-lookup"><span data-stu-id="13919-205">You might consider applying these attributes for your own custom attached properties also.</span></span> <span data-ttu-id="13919-206">Назначение и синтаксис [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] описаны в соответствующих разделах справочника.</span><span class="sxs-lookup"><span data-stu-id="13919-206">The purpose and syntax of the [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] is described on the appropriate reference pages:</span></span>

- <xref:System.Windows.AttachedPropertyBrowsableAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForChildrenAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForTypeAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableWhenAttributePresentAttribute>

## <span data-ttu-id="13919-207">Дополнительные сведения о вложенных свойствах<a name="more"></a></span><span class="sxs-lookup"><span data-stu-id="13919-207">Learning More About Attached Properties <a name="more"></a></span></span>

- <span data-ttu-id="13919-208">Дополнительные сведения о создании присоединенного свойства см. в разделе [Регистрация присоединенного свойства](how-to-register-an-attached-property.md).</span><span class="sxs-lookup"><span data-stu-id="13919-208">For more information on creating an attached property, see [Register an Attached Property](how-to-register-an-attached-property.md).</span></span>

- <span data-ttu-id="13919-209">Более сложные сценарии использования свойств зависимостей и присоединенных свойств см. в разделе [Пользовательские свойства зависимостей](custom-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="13919-209">For more advanced usage scenarios for dependency properties and attached properties, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>

- <span data-ttu-id="13919-210">Свойство можно также зарегистрировать как присоединенное свойство и как свойство зависимостей, но тем не менее предоставить реализации "оболочки".</span><span class="sxs-lookup"><span data-stu-id="13919-210">You can also register a property as an attached property, and as a dependency property, but then still expose "wrapper" implementations.</span></span> <span data-ttu-id="13919-211">В этом случае свойство можно задать как для данного элемента, так и для любого элемента с помощью синтаксиса подключенных свойств XAML.</span><span class="sxs-lookup"><span data-stu-id="13919-211">In this case, the property can be set either on that element, or on any element through the XAML attached property syntax.</span></span> <span data-ttu-id="13919-212">Примером свойства с соответствующим сценарием для стандартных и присоединенных случаев использования является <xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="13919-212">An example of a property with an appropriate scenario for both standard and attached usages is <xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>.</span></span>

## <a name="see-also"></a><span data-ttu-id="13919-213">См. также</span><span class="sxs-lookup"><span data-stu-id="13919-213">See also</span></span>

- <xref:System.Windows.DependencyProperty>
- [<span data-ttu-id="13919-214">Общие сведения о свойствах зависимости</span><span class="sxs-lookup"><span data-stu-id="13919-214">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="13919-215">Пользовательские свойства зависимостей</span><span class="sxs-lookup"><span data-stu-id="13919-215">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="13919-216">Общие сведения о языке XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="13919-216">XAML Overview (WPF)</span></span>](xaml-overview-wpf.md)
- [<span data-ttu-id="13919-217">Регистрация присоединенного свойства</span><span class="sxs-lookup"><span data-stu-id="13919-217">Register an Attached Property</span></span>](how-to-register-an-attached-property.md)
