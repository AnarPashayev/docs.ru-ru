---
title: Общие сведения о вложенных свойствах зависимостей
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- attached properties [WPF Designer]
ms.assetid: 75928354-dc01-47e8-a018-8409aec1f32d
ms.openlocfilehash: 2eacb0ff49b868f144bf35af4bb64b7d049b30cb
ms.sourcegitcommit: 24a4a8eb6d8cfe7b8549fb6d823076d7c697e0c6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/23/2019
ms.locfileid: "68401392"
---
# <a name="attached-properties-overview"></a>Общие сведения о вложенных свойствах зависимостей

Присоединенное свойство — это понятие, определяемое языком XAML. Присоединенное свойство предназначено для использования в качестве типа глобального свойства, которое может быть задано для любого объекта. В [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] присоединенные свойства обычно определяются как особая форма свойства зависимости, не имеющего обычной "оболочки" свойства.

## Требований<a name="prerequisites"></a>

Предполагается, что вы имеете представление о свойствах зависимостей с точки зрения потребителя существующих свойств зависимостей в классах [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] и ознакомились с разделом [Общие сведения о свойствах зависимостей](dependency-properties-overview.md). Чтобы выполнить примеры в этом разделе, необходимо также понимать XAML и знать, как писать приложения WPF.

## Зачем использовать присоединенные свойства<a name="attached_properties_usage"></a>

Среди прочего, присоединенные свойства позволяют разным дочерним элементам задавать уникальные значения для свойства, которое фактически определено в родительском элементе. Конкретным примером этого сценария является уведомление дочерними элементами родительского элемента о порядке их представления в [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]. Одним из примеров является <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> свойство. Свойство создается как присоединенное свойство, так как оно предназначено для установки в элементах, содержащихся <xref:System.Windows.Controls.DockPanel>в, а не на <xref:System.Windows.Controls.DockPanel> самом себе. <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> <xref:System.Windows.DependencyProperty> <xref:System.Windows.Controls.DockPanel.DockProperty> <xref:System.Windows.Controls.DockPanel.GetDock%2A> Класс определяет статическое поле с именем, а затем предоставляет методы и <xref:System.Windows.Controls.DockPanel.SetDock%2A> в качестве открытых методов доступа для присоединенного свойства. <xref:System.Windows.Controls.DockPanel>

## Вложенные свойства в XAML<a name="attached_properties_xaml"></a>

В XAML присоединенные свойства задаются с помощью синтаксиса *ПоставщикПрисоединенногоСвойства*.*ИмяСвойства*.

Ниже приведен пример того, как можно задать <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> в XAML:

[!code-xaml[PropertiesOvwSupport#APBasicUsage](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#apbasicusage)]

Обратите внимание, что использование в некоторой степени похоже на статическое свойство. всегда следует ссылаться на тип <xref:System.Windows.Controls.DockPanel> , который владеет и регистрирует присоединенное свойство, а не ссылаться на любой экземпляр, указанный по имени.

Кроме того, поскольку присоединенное свойство в XAML является атрибутом, который устанавливается в разметке, операция задания является значимой. Нельзя напрямую получить свойство в XAML, хотя существуют некоторые косвенные механизмы для сравнения значений, такие как триггеры в стилях (подробнее см. в разделе [Стилизация и использование шаблонов](../controls/styling-and-templating.md)).

### <a name="attached-property-implementation-in-wpf"></a>Реализация присоединенного свойства в WPF

В [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]большинство присоединенных свойств, которые существуют в типах WPF, связанных с представлением пользовательского интерфейса, реализуются как свойства зависимостей. Присоединенные свойства являются концепцией XAML, тогда как свойства зависимостей являются понятием WPF. Поскольку вложенные свойства WPF являются свойствами зависимостей, они поддерживают понятия свойств зависимостей, такие как метаданные свойств, и значения по умолчанию из метаданных этого свойства.

## Как присоединенные свойства используются типом-владельцем<a name="howused"></a>

Хотя присоединенные свойства могут устанавливаться для любого объекта, это не означает, что задание свойства будет создавать осязаемый результат или что значение будет когда-либо использоваться другим объектом. Как правило, использование присоединенных свойств подразумевает, что объекты, поступающие из разнообразных иерархий классов или логических связей, могут передавать общую информацию в тип, который определяет присоединенное свойство. Тип, который определяет присоединенное свойство, обычно соответствует одной из следующих моделей.

- Тип, который определяет присоединенное свойство, может являться родительским элементом для элементов, которые будут задавать значения для присоединенного свойства. Тип, который затем выполняет итерацию его дочерних объектов согласно внутренней логике относительно некоторой структуры дерева объектов, получает значения и выполняет с этими значениями какие-либо действия.

- Тип, который определяет присоединенное свойство, будет использоваться в качестве дочернего элемента для разнообразных возможных родительских элементов и моделей содержимого.

- Тип, который определяет присоединенное свойство, представляет службу. Другие типы устанавливают значения для присоединенного свойства. Затем, когда элемент, задающий свойство, вычисляется в контексте службы, значения присоединенного свойства получаются через внутреннюю логику класса службы.

### <a name="an-example-of-a-parent-defined-attached-property"></a>Пример присоединенного свойства, определенного родительским элементом

Наиболее типичный сценарий, в котором WPF определяет присоединенное свойство, — когда родительский элемент поддерживает коллекцию дочерних элементов, а также реализует поведение, при котором особенности поведения передаются по отдельности для каждого дочернего элемента.

<xref:System.Windows.Controls.DockPanel>Определяет присоединенное свойство и <xref:System.Windows.Controls.DockPanel> содержит код уровня класса как часть его логики отрисовки (в частности, <xref:System.Windows.Controls.DockPanel.MeasureOverride%2A> и <xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>). <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> Экземпляр всегда проверяет, установил ли какой-либо из его непосредственных дочерних элементов значение для <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>. <xref:System.Windows.Controls.DockPanel> В таком случае эти значения становятся входными данными для логики отображения, применяемой к соответствующему дочернему элементу. Каждый <xref:System.Windows.Controls.DockPanel> вложенный экземпляр обрабатывает собственные непосредственные коллекции дочерних элементов, но это поведение зависит от реализации того <xref:System.Windows.Controls.DockPanel> , <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> как обрабатываются значения. Теоретически возможно наличие присоединенных свойств, оказывающих влияние на элементы за пределами непосредственного родителя. Если присоединенное свойство задано для элемента, который не <xref:System.Windows.Controls.DockPanel> имеет родительского элемента, который будет работать с ним, то ошибка или исключение не возникает. <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> Это просто означает, что задано глобальное значение свойства, но у него нет текущего <xref:System.Windows.Controls.DockPanel> родителя, который мог бы использовать эту информацию.

## Присоединенные свойства в коде<a name="attached_properties_code"></a>

Присоединенные свойства в WPF не имеют типовых методов оболочки CLR для простого доступа get/set. Это связано с тем, что присоединенное свойство не обязательно является частью пространства имен CLR для экземпляров, в которых задано свойство. Тем не менее обработчик XAML должен иметь возможность задавать эти значения при анализе XAML. Для поддержки эффективного использования присоединенного свойства тип владельца присоединенного свойства должен реализовывать выделенные методы доступа в форме **Get_PropertyName_** и **Set_PropertyName_** . Такие специальные методы доступа также удобны для получения или задания присоединенного свойства в коде. С точки зрения кода присоединенное свойство аналогично резервному полю с методами доступа к методам вместо методов доступа к свойствам. Такое резервное поле может существовать для любого объекта и не требует специального определения.

В следующем примере кода показано задание присоединенного свойства в коде. В этом примере `myCheckBox` — это экземпляр <xref:System.Windows.Controls.CheckBox> класса.

[!code-csharp[PropertiesOvwSupport#APCode](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml.cs#apcode)]
[!code-vb[PropertiesOvwSupport#APCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page4.xaml.vb#apcode)]

Как и в случае с примером XAML `myCheckBox` , если он еще не был добавлен в качестве дочернего `myDockPanel` элемента третьей строкой кода, то в четвертой строке кода не будет вызываться исключение, но значение свойства не <xref:System.Windows.Controls.DockPanel> будет взаимодействовать с родительским объектом и, таким образом, ничего не делает. Только значение, установленное в дочернем элементе вместе с присутствием <xref:System.Windows.Controls.DockPanel> родительского элемента, приведет к эффективному поведению в приложении, готовом для просмотра. <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> (В этом случае вы может задать присоединенное свойство, а затем подключиться к дереву. Аналогично, можно подключиться к дереву, а затем задать присоединенное свойство. Любая последовательность действий дает тот же результат.)

## Метаданные присоединенного свойства<a name="attached_properties_metadata"></a>

При регистрации свойства <xref:System.Windows.FrameworkPropertyMetadata> задается для указания характеристик свойства, например, влияет ли свойство на отрисовку, измерение и т. д. Метаданные для присоединенного свойства, как правило, не отличаются от задаваемых для свойства зависимостей. Если задать значение по умолчанию в переопределении для метаданных присоединенного свойства, это значение становится значением по умолчанию неявного присоединенного свойства для экземпляров переопределяющего класса. В частности, значение по умолчанию передается, если некоторый процесс запрашивает значение присоединенного свойства с помощью метода доступа `Get` для этого свойства, указывая экземпляр класса, в котором заданы метаданные, и значение для этого присоединенного свойства не задано иным образом.

Если вы хотите разрешить наследование значений свойства, следует использовать присоединенные свойства, вместо неприсоединенных свойств зависимостей. Подробнее см. в разделе [Наследование значения свойства](property-value-inheritance.md).

## Пользовательские присоединенные свойства<a name="custom"></a>

### Когда следует создавать присоединенное свойство<a name="create_attached_properties"></a>

Присоединенное свойство можно создать, если требуется механизм задания свойств для классов, не являющихся определяющим классом. Наиболее распространенным сценарием является макет. Примерами существующих свойств макета являются <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>, <xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>и <xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType>. В этом сценарии элементы, которые существуют как дочерние элементы для элементов, управляющих макетом, могут индивидуально выражать требования макета для своих родительских элементов, задавая значение свойства, определяемого родительским элементом как присоединенное свойство.

Другой сценарий использования присоединенного свойства — когда класс представляет службу и требуется реализовать более прозрачную интеграцию службы классами.

Еще один сценарий — получение поддержки конструктора WPF Visual Studio, например изменение окна **свойств** . Дополнительные сведения см. в разделе [Общие сведения о разработке элементов управления](../controls/control-authoring-overview.md).

Как упоминалось ранее, свойство следует регистрировать как присоединенное, если требуется использовать наследование значения свойства.

### Создание присоединенного свойства<a name="how_do_i_create_attached_properties"></a>

Если класс определяет присоединенное свойство исключительно для использования в других типах, класс не обязательно должен быть производным от <xref:System.Windows.DependencyObject>. Но вам нужно создать производную от <xref:System.Windows.DependencyObject> , если вы подберете общую модель WPF, в которой присоединенное свойство также является свойством зависимостей.

Определите присоединенное свойство как свойство зависимостей, объявляя `public static readonly` поле типа. <xref:System.Windows.DependencyProperty> Это поле определяется с помощью возвращаемого значения <xref:System.Windows.DependencyProperty.RegisterAttached%2A> метода. Имя поля должно совпадать с именем присоединенного свойства, добавленного со строкой `Property`, чтобы соответствовать установленному шаблону WPF именования идентифицирующих полей относительно свойств, которые они представляют. Поставщик присоединенного свойства также должен предоставлять статические методы **Get_PropertyName_** и **Set_PropertyName_** в качестве методов доступа к присоединенному свойству. Если этого не сделать, система свойств не сможет использовать присоединенное свойство.

> [!NOTE]
> Если опустить метод доступа Get присоединенного свойства, привязка данных к свойству не будет работать в средствах разработки, таких как Visual Studio и Expression Blend.

#### <a name="the-get-accessor"></a>Метод доступа get

Сигнатура для метода доступа **Get_PropertyName_** должна быть:

`public static object GetPropertyName(object target)`

- Объект `target` можно указать как более конкретный тип в реализации. Например, <xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType> метод присваивает <xref:System.Windows.UIElement>параметру значение, поскольку присоединенное свойство <xref:System.Windows.UIElement> предназначено только для экземпляров.

- Возвращаемое значение можно указать как более конкретный тип в реализации. Например <xref:System.Windows.Controls.DockPanel.GetDock%2A> , метод вводит тип <xref:System.Windows.Controls.Dock>, так как значение может быть задано только для этого перечисления.

#### <a name="the-set-accessor"></a>Метод доступа set

Сигнатура для метода доступа **Set_PropertyName_** должна быть:

`public static void SetPropertyName(object target, object value)`

- Объект `target` можно указать как более конкретный тип в реализации. Например, <xref:System.Windows.Controls.DockPanel.SetDock%2A> метод вводит <xref:System.Windows.UIElement>значение, поскольку присоединенное свойство <xref:System.Windows.UIElement> предназначено только для экземпляров.

- Объект `value` можно указать как более конкретный тип в реализации. Например <xref:System.Windows.Controls.DockPanel.SetDock%2A> , метод вводит тип <xref:System.Windows.Controls.Dock>, так как значение может быть задано только для этого перечисления. Помните, что значением этого метода являются входные данные, поступающие от загрузчика XAML, когда он встречает присоединенное свойство в использовании присоединенного свойства в макете. Эти входные данные являются значением, указанным как значение атрибута XAML в разметке. Таким образом, необходимо обеспечить поддержку преобразования типов, сериализатора значений или расширений разметки для используемого типа так, чтобы соответствующий тип можно было создать из значения атрибута (которое, в конечном счете, является просто строкой).

В следующем примере показана регистрация свойства зависимостей (с помощью <xref:System.Windows.DependencyProperty.RegisterAttached%2A> метода), а также методы доступа **Get_PropertyName_** и **Set_PropertyName_** . В этом примере именем присоединенного свойства является `IsBubbleSource`. Таким образом, методы доступа должны называться `GetIsBubbleSource` и `SetIsBubbleSource`.

[!code-csharp[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler)]
[!code-vb[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler)]

#### <a name="attached-property-attributes"></a>Атрибуты присоединенного свойства

WPF определяет несколько [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] , которые предназначены для предоставления сведений о вложенных свойствах процессам отражения, а также обычным пользователям отражения и информации о свойствах, таких как конструкторы. Поскольку присоединенные свойства имеют тип неограниченной области, разработчикам необходим способ, который позволит избежать представления пользователям глобального списка всех присоединенных свойств, которые определены в конкретной реализации технологии, использующей XAML. Объект [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] , определяемый в WPF для присоединенных свойств, может использоваться для определения области ситуаций, в которых заданное присоединенное свойство должно отображаться в окне свойств. Эти атрибуты можно также применить для собственных присоединенных свойств. Назначение и синтаксис [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] описаны в соответствующих разделах справочника.

- <xref:System.Windows.AttachedPropertyBrowsableAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForChildrenAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForTypeAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableWhenAttributePresentAttribute>

## Дополнительные сведения о вложенных свойствах<a name="more"></a>

- Дополнительные сведения о создании присоединенного свойства см. в разделе [Регистрация присоединенного свойства](how-to-register-an-attached-property.md).

- Более сложные сценарии использования свойств зависимостей и присоединенных свойств см. в разделе [Пользовательские свойства зависимостей](custom-dependency-properties.md).

- Свойство можно также зарегистрировать как присоединенное свойство и как свойство зависимостей, но тем не менее предоставить реализации "оболочки". В этом случае свойство можно задать как для данного элемента, так и для любого элемента с помощью синтаксиса подключенных свойств XAML. Примером свойства с соответствующим сценарием для стандартных и присоединенных случаев использования является <xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>.

## <a name="see-also"></a>См. также

- <xref:System.Windows.DependencyProperty>
- [Общие сведения о свойствах зависимости](dependency-properties-overview.md)
- [Пользовательские свойства зависимостей](custom-dependency-properties.md)
- [Общие сведения о языке XAML (WPF)](xaml-overview-wpf.md)
- [Регистрация присоединенного свойства](how-to-register-an-attached-property.md)
