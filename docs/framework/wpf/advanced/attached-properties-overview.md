---
title: Общие сведения о вложенных свойствах зависимостей
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- attached properties [WPF Designer]
ms.assetid: 75928354-dc01-47e8-a018-8409aec1f32d
ms.openlocfilehash: b207db459776c9f8fa7ea247d01071eeb8c995cf
ms.sourcegitcommit: 465547886a1224a5435c3ac349c805e39ce77706
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/21/2020
ms.locfileid: "81739299"
---
# <a name="attached-properties-overview"></a>Общие сведения о вложенных свойствах зависимостей

Присоединенное свойство — это понятие, определяемое языком XAML. Присоединенное свойство предназначено для использования в качестве типа глобального свойства, которое может быть задано для любого объекта. В [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] присоединенные свойства обычно определяются как особая форма свойства зависимости, не имеющего обычной "оболочки" свойства.

## <a name="prerequisites"></a>Необходимые условия<a name="prerequisites"></a>

В этой статье предполагается, что вы понимаете свойства зависимости [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] с точки зрения потребителя существующих свойств зависимости по классам, и читаете [обзор свойств зависимости](dependency-properties-overview.md). Чтобы следовать примерам этой статьи, вы также должны понимать XAML и знать, как писать приложения WPF.

## <a name="why-use-attached-properties"></a>Зачем использовать прилагаемые свойства<a name="attached_properties_usage"></a>

Одной из целей прилагаемого свойства является возможность указания различных элементов ребенка для определения уникальных значений для свойства, определяемого в родительском элементе. Конкретным примером этого сценария является уведомление дочерними элементами родительского элемента о порядке их представления в [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]. Одним из <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> примеров является свойство. Свойство <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> создается как прилагаемое свойство, поскольку оно предназначено для установки на элементы, содержащиеся в <xref:System.Windows.Controls.DockPanel> не самом <xref:System.Windows.Controls.DockPanel> себе. Класс <xref:System.Windows.Controls.DockPanel> определяет статическое <xref:System.Windows.DependencyProperty> поле, названное, <xref:System.Windows.Controls.DockPanel.DockProperty>а затем предоставляет <xref:System.Windows.Controls.DockPanel.GetDock%2A> и методы в <xref:System.Windows.Controls.DockPanel.SetDock%2A> качестве публичных аксессуаров для прилагаемого свойства.

## <a name="attached-properties-in-xaml"></a>Присоединенные свойства в XAML<a name="attached_properties_xaml"></a>

В XAML присоединенные свойства задаются с помощью синтаксиса *ПоставщикПрисоединенногоСвойства*.*ИмяСвойства*.

Ниже приводится пример того, <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> как вы можете установить в XAML:

[!code-xaml[PropertiesOvwSupport#APBasicUsage](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#apbasicusage)]

Использование чем-то похоже на статическое свойство; вы всегда ссылаетесь на тип, <xref:System.Windows.Controls.DockPanel> который владеет и регистрирует прилагаемое свойство, вместо того, чтобы ссылаться на любой экземпляр, указанный по имени.

Кроме того, поскольку присоединенное свойство в XAML является атрибутом, который устанавливается в разметке, операция задания является значимой. Нельзя напрямую получить свойство в XAML, хотя существуют некоторые косвенные механизмы для сравнения значений, такие как триггеры в стилях (подробнее см. в разделе [Стилизация и использование шаблонов](../../../desktop-wpf/fundamentals/styles-templates-overview.md)).

### <a name="attached-property-implementation-in-wpf"></a>Реализация присоединенного свойства в WPF

В [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], большинство связанных с uI прилагаемые свойства на типах WPF реализуются как свойства зависимости. Прилагаемые свойства являются концепцией XAML, в то время как свойства зависимости являются концепцией WPF. Поскольку прилагаемые WPF свойства являются свойствами зависимостей, они поддерживают концепции свойств зависимостей, такие как метаданные свойств и значения по умолчанию из метаданных свойств.

## <a name="how-attached-properties-are-used-by-the-owning-type"></a>Как прилагаемые свойства используются типом владения<a name="howused"></a>

Хотя присоединенные свойства могут устанавливаться для любого объекта, это не означает, что задание свойства будет создавать осязаемый результат или что значение будет когда-либо использоваться другим объектом. Как правило, использование присоединенных свойств подразумевает, что объекты, поступающие из разнообразных иерархий классов или логических связей, могут передавать общую информацию в тип, который определяет присоединенное свойство. Тип, который определяет присоединенное свойство, обычно соответствует одной из следующих моделей.

- Тип, который определяет присоединенное свойство, может являться родительским элементом для элементов, которые будут задавать значения для присоединенного свойства. Тип, который затем выполняет итерацию его дочерних объектов согласно внутренней логике относительно некоторой структуры дерева объектов, получает значения и выполняет с этими значениями какие-либо действия.

- Тип, который определяет присоединенное свойство, будет использоваться в качестве дочернего элемента для разнообразных возможных родительских элементов и моделей содержимого.

- Тип, который определяет присоединенное свойство, представляет службу. Другие типы устанавливают значения для присоединенного свойства. Затем, когда элемент, задающий свойство, вычисляется в контексте службы, значения присоединенного свойства получаются через внутреннюю логику класса службы.

### <a name="an-example-of-a-parent-defined-attached-property"></a>Пример присоединенного свойства, определенного родительским элементом

Наиболее типичным сценарием, в котором WPF определяет прилагаемое свойство, является то, когда родительский элемент поддерживает сбор элементов ребенка, а также реализует поведение, в котором специфика поведения регистрируется индивидуально для каждого элемента ребенка.

<xref:System.Windows.Controls.DockPanel>определяет <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> прилагаемое свойство и <xref:System.Windows.Controls.DockPanel> имеет код уровня класса как часть <xref:System.Windows.Controls.DockPanel.MeasureOverride%2A> <xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>его логики рендеринга (в частности, и). Экземпляр <xref:System.Windows.Controls.DockPanel> всегда проверяет, есть ли у кого-либо из <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>его непосредственных элементов ребенка значение. В таком случае эти значения становятся входными данными для логики отображения, применяемой к соответствующему дочернему элементу. Вложенные <xref:System.Windows.Controls.DockPanel> экземпляры обрабатывают свои собственные непосредственные коллекции элементов ребенка, но это поведение специфично для того, как <xref:System.Windows.Controls.DockPanel> значения процессов— <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> это связано с реализацией. Теоретически возможно наличие присоединенных свойств, оказывающих влияние на элементы за пределами непосредственного родителя. Если <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> прилагаемое свойство устанавливается <xref:System.Windows.Controls.DockPanel> на элемент, который не имеет родительского элемента, чтобы действовать на него, не возникает ошибка или исключение. Это просто означает, что глобальная стоимость свойства <xref:System.Windows.Controls.DockPanel> была установлена, но она не имеет текущего родительского, который мог бы потреблять информацию.

## <a name="attached-properties-in-code"></a>Прилагаемые свойства в коде<a name="attached_properties_code"></a>

Прилагаемые свойства в WPF не имеют типичных методов "обертки" CLR для легкого доступа к набору. Это объясняется тем, что прилагаемое свойство не обязательно является частью пространства имен CLR для случаев, когда свойство установлено. Тем не менее обработчик XAML должен иметь возможность задавать эти значения при анализе XAML. Для поддержки эффективного присоединенного использования свойств тип прилагаемого свойства должен реализовать специальные методы доступа в форме **Get_PropertyName_** и **Set_PropertyName_.** Такие специальные методы доступа также удобны для получения или задания присоединенного свойства в коде. С точки зрения кода присоединенное свойство аналогично резервному полю с методами доступа к методам вместо методов доступа к свойствам. Такое резервное поле может существовать для любого объекта и не требует специального определения.

В следующем примере кода показано задание присоединенного свойства в коде. В этом `myCheckBox` примере <xref:System.Windows.Controls.CheckBox> пример класса.

[!code-csharp[PropertiesOvwSupport#APCode](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml.cs#apcode)]
[!code-vb[PropertiesOvwSupport#APCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page4.xaml.vb#apcode)]

Как и в случае XAML, если `myCheckBox` бы еще `myDockPanel` не был добавлен в качестве элемента ребенка четвертой строки кода, пятая <xref:System.Windows.Controls.DockPanel> строка кода не породила бы исключение, но значение свойства не взаимодействовало бы с родителем и, таким образом, ничего не делало бы. Только <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> значение, установленное на элементе <xref:System.Windows.Controls.DockPanel> ребенка в сочетании с наличием родительского элемента, приведет к эффективному поведению в отрисованной приложении. (В этом случае вы может задать присоединенное свойство, а затем подключиться к дереву. Аналогично, можно подключиться к дереву, а затем задать присоединенное свойство. Любая последовательность действий дает тот же результат.)

## <a name="attached-property-metadata"></a>Прилагаемые метаданные свойств<a name="attached_properties_metadata"></a>

При регистрации свойства <xref:System.Windows.FrameworkPropertyMetadata> устанавливается указание характеристик свойство, например, влияет ли свойство на визуализацию, измерение и так далее. Метаданные для присоединенного свойства, как правило, не отличаются от задаваемых для свойства зависимостей. Если задать значение по умолчанию в переопределении для метаданных присоединенного свойства, это значение становится значением по умолчанию неявного присоединенного свойства для экземпляров переопределяющего класса. В частности, значение по умолчанию передается, если некоторый процесс запрашивает значение присоединенного свойства с помощью метода доступа `Get` для этого свойства, указывая экземпляр класса, в котором заданы метаданные, и значение для этого присоединенного свойства не задано иным образом.

Если вы хотите разрешить наследование значений свойства, следует использовать присоединенные свойства, вместо неприсоединенных свойств зависимостей. Для получения подробной информации [см.](property-value-inheritance.md)

## <a name="custom-attached-properties"></a>Пользовательские прилагаемые свойства<a name="custom"></a>

### <a name="when-to-create-an-attached-property"></a>Когда создавать присоединенное свойство<a name="create_attached_properties"></a>

Присоединенное свойство можно создать, если требуется механизм задания свойств для классов, не являющихся определяющим классом. Наиболее распространенным сценарием является макет. Примеры существующих свойств <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> <xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>макета, <xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType>и . В этом сценарии элементы, которые существуют как дочерние элементы для элементов, управляющих макетом, могут индивидуально выражать требования макета для своих родительских элементов, задавая значение свойства, определяемого родительским элементом как присоединенное свойство.

Другой сценарий использования присоединенного свойства — когда класс представляет службу и требуется реализовать более прозрачную интеграцию службы классами.

Еще один сценарий заключается в том, чтобы получить поддержку Visual Studio WPF Designer, такую как редактирование окон **Properties.** Дополнительные сведения см. в разделе [Общие сведения о разработке элементов управления](../controls/control-authoring-overview.md).

Как упоминалось ранее, свойство следует регистрировать как присоединенное, если требуется использовать наследование значения свойства.

### <a name="how-to-create-an-attached-property"></a>Как создать присоединенное свойство<a name="how_do_i_create_attached_properties"></a>

Если ваш класс определяет прилагаемое свойство строго для использования на других <xref:System.Windows.DependencyObject>типах, то класс не должен вытекать из . Но вы должны извлечь <xref:System.Windows.DependencyObject> из, если вы будете следовать общей модели WPF, имеющих прилагаемое свойство также быть свойством зависимости.

Определите прилагаемое свойство как `public static readonly` свойство <xref:System.Windows.DependencyProperty>зависимости, объявив поле типа. Это поле определяется с помощью <xref:System.Windows.DependencyProperty.RegisterAttached%2A> значения возврата метода. Имя поля должно соответствовать прилагаемому названию свойства, прилагаемому `Property`строкой, чтобы следовать установленному шаблону WPF, назначающим идентифицирующие поля по сравнению с свойствами, которые они представляют. Поставщик прилагаемых свойств должен также предоставлять статическое **Get_PropertyName_** и **Set_PropertyName_** методы в качестве аксессуаров для прилагаемого свойства; невыполнение этого результата приводит к тому, что система свойств не сможет использовать прилагаемое свойство.

> [!NOTE]
> Если вы не опустите прилагаемый доступ к свойству, привязка данных к свойству не будет работать в инструментах проектирования, таких как Visual Studio и Blend for Visual Studio.

#### <a name="the-get-accessor"></a>Метод доступа get

Подпись для **Get_PropertyName_** аксессуардолжен должен быть:

`public static object GetPropertyName(object target)`

- Объект `target` можно указать как более конкретный тип в реализации. Например, <xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType> метод набирает параметр как, <xref:System.Windows.UIElement>потому что прикрепленное <xref:System.Windows.UIElement> свойство предназначено только для установки на экземплярах.

- Возвращаемое значение можно указать как более конкретный тип в реализации. Например, <xref:System.Windows.Controls.DockPanel.GetDock%2A> метод вводит <xref:System.Windows.Controls.Dock>его как , потому что значение может быть установлено только для этого перечисления.

#### <a name="the-set-accessor"></a>Метод доступа set

Подпись для **Set_PropertyName_** аксессуара должна быть:

`public static void SetPropertyName(object target, object value)`

- Объект `target` можно указать как более конкретный тип в реализации. Например, <xref:System.Windows.Controls.DockPanel.SetDock%2A> метод вводит <xref:System.Windows.UIElement>его как, потому что прикрепленное <xref:System.Windows.UIElement> свойство предназначено только для установки на экземплярах.

- Объект `value` можно указать как более конкретный тип в реализации. Например, <xref:System.Windows.Controls.DockPanel.SetDock%2A> метод вводит <xref:System.Windows.Controls.Dock>его как , потому что значение может быть установлено только для этого перечисления. Помните, что значением этого метода являются входные данные, поступающие от загрузчика XAML, когда он встречает присоединенное свойство в использовании присоединенного свойства в макете. Эти входные данные являются значением, указанным как значение атрибута XAML в разметке. Таким образом, необходимо обеспечить поддержку преобразования типов, сериализатора значений или расширений разметки для используемого типа так, чтобы соответствующий тип можно было создать из значения атрибута (которое, в конечном счете, является просто строкой).

Ниже приводится регистрация собственности зависимости (с использованием метода), <xref:System.Windows.DependencyProperty.RegisterAttached%2A> а также **Get_PropertyName_** и **Set_PropertyName_** доступу. В этом примере именем присоединенного свойства является `IsBubbleSource`. Таким образом, методы доступа должны называться `GetIsBubbleSource` и `SetIsBubbleSource`.

[!code-csharp[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler)]
[!code-vb[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler)]

#### <a name="attached-property-attributes"></a>Атрибуты присоединенного свойства

WPF определяет несколько атрибутов .NET, которые предназначены для предоставления информации о прилагаемых свойствах для процессов отражения, а также для типичных пользователей отражения и информации о свойствах, таких как дизайнеры. Поскольку присоединенные свойства имеют тип неограниченной области, разработчикам необходим способ, который позволит избежать представления пользователям глобального списка всех присоединенных свойств, которые определены в конкретной реализации технологии, использующей XAML. Атрибуты .NET, которые определяет WPF для прилагаемых свойств, могут использоваться для охвата ситуаций, когда данное прилагаемое свойство должно отображаться в окне свойств. Эти атрибуты можно также применить для собственных присоединенных свойств. Цель и синтаксис атрибутов .NET описаны на соответствующих справочных страницах:

- <xref:System.Windows.AttachedPropertyBrowsableAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForChildrenAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForTypeAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableWhenAttributePresentAttribute>

## <a name="learning-more-about-attached-properties"></a>Узнать больше о прилагаемых свойствах<a name="more"></a>

- Дополнительные сведения о создании присоединенного свойства см. в разделе [Регистрация присоединенного свойства](how-to-register-an-attached-property.md).

- Более сложные сценарии использования свойств зависимостей и присоединенных свойств см. в разделе [Пользовательские свойства зависимостей](custom-dependency-properties.md).

- Свойство можно также зарегистрировать как присоединенное свойство и как свойство зависимостей, но тем не менее предоставить реализации "оболочки". В этом случае свойство можно задать как для данного элемента, так и для любого элемента с помощью синтаксиса подключенных свойств XAML. Примером свойства с соответствующим сценарием как для стандартных, так и для прикрепленных обычаев является. <xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>

## <a name="see-also"></a>См. также

- <xref:System.Windows.DependencyProperty>
- [Общие сведения о свойствах зависимости](dependency-properties-overview.md)
- [Пользовательские свойства зависимостей](custom-dependency-properties.md)
- [Обзор XAML (WPF)](../../../desktop-wpf/fundamentals/xaml.md)
- [Регистрация присоединенного свойства](how-to-register-an-attached-property.md)
