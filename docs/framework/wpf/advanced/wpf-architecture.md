---
title: Архитектура WPF
ms.date: 03/30/2017
helpviewer_keywords:
- properties [WPF], attached
- attached properties [WPF]
- architecture [WPF]
- unmanaged components [WPF]
- affinity thread [WPF]
- Storyboards [WPF]
- milcore [WPF]
- components [WPF], unmanaged
- painter's algorithm
- interfaces [WPF], INotifyPropertyChange
- CommandBindings [WPF]
- data templates [WPF]
- thread [WPF], affinity
ms.assetid: 8579c10b-76ab-4c52-9691-195ce02333c8
ms.openlocfilehash: 04e6c6fb5dd903e0f52a29bb2c0739d899ce2bb1
ms.sourcegitcommit: 7bc6887ab658550baa78f1520ea735838249345e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/03/2020
ms.locfileid: "75636358"
---
# <a name="wpf-architecture"></a>Архитектура WPF
В этом разделе представлен обзор иерархии классов Windows Presentation Foundation (WPF). Он охватывает большинство основных подсистем WPF и описывает их взаимодействие. В нем также подробно описаны некоторые варианты, сделанные архитекторами WPF.  

<a name="System_Object"></a>   
## <a name="systemobject"></a>System.Object  
 Основная модель программирования WPF предоставляется через управляемый код. На ранних стадиях разработки WPF существовало несколько споров о том, где должна отображаться линия между управляемыми компонентами системы и неуправляемыми элементами. Среда CLR предоставляет ряд функций, повышающих производительность и надежность разработки (включая управление памятью, обработку ошибок, систему общих типов и т. д.), но они поставляются по цене.  
  
 Основные компоненты WPF показаны на рисунке ниже. Красные разделы схемы (PresentationFramework, PresentationCore и milcore) являются основными частями кода WPF. Только один из этих компонентов является неуправляемым — milcore. Milcore написан на неуправляемом коде, чтобы обеспечить тесную интеграцию с DirectX. Все дисплеи в WPF выполняются с помощью механизма DirectX, что обеспечивает эффективную визуализацию оборудования и программного обеспечения. WPF также требует четкого управления памятью и выполнением. Механизм композиции в milcore чрезвычайно чувствителен к производительности, и для повышения производительности требуется предоставить множество преимуществ среды CLR.  
  
 ![Расположение WPF в .NET Framework.](./media/wpf-architect1.PNG "wpf_architect1")  
  
 Связь между управляемыми и неуправляемыми частями WPF обсуждается далее в этом разделе. Остальная часть управляемой модели программирования описана ниже.  
  
<a name="System_Threading_DispatcherObject"></a>   
## <a name="systemthreadingdispatcherobject"></a>System.Threading.DispatcherObject  
 Большинство объектов в WPF являются производными от <xref:System.Windows.Threading.DispatcherObject>, которые предоставляют базовые конструкции для работы с параллелизмом и многопоточностью. WPF основан на системе обмена сообщениями, реализованной диспетчером. Это работает во многом подобно привычному [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)]ному конвейеру сообщений; фактически диспетчер WPF использует сообщения User32 для выполнения вызовов между потоками.  
  
 Существует два основных понятия, которые следует учитывать при обсуждении параллелизма в WPF — механизме диспетчеризации и сходства потоков.  
  
 На этапе проектирования WPF задача была перемещена в один поток выполнения, а не в потоковую модель "привязаны". Сходство потоков случается, когда компонент использует идентификатор выполняемого потока для сохранения некоторых типов состояния. Наиболее распространенной формой этого является использование локальной памяти потока (TLS) для сохранения состояния. Сходство потоков требует, чтобы каждый логический поток выполнения принадлежал только одному физическому потоку в операционной системе, что создает большую нагрузку на память. В итоге потоковая модель WPF осталась согласованной с существующей потоковой моделью User32 однопотокового выполнения со сходством потоков. Основной причиной этого было взаимодействие — такие системы, как OLE 2,0, буфер обмена и Internet Explorer, нуждаются в выполнении однопотокового сходства (STA).  
  
 При наличии объектов с организацией потоковой обработки STA необходим способ связи между потоками и проверки нахождения в правильном потоке. В этом заключается роль диспетчера. Диспетчер — это основная система управления сообщениями, включающая несколько очередей с назначенными приоритетами. Примеры сообщений включают необработанные входящие уведомления (перемещение мыши), функции платформы (макет) или пользовательские команды (выполнение этого метода). Производя от <xref:System.Windows.Threading.DispatcherObject>, вы создаете объект CLR, имеющий поведение STA, и ему присваивается указатель на Dispatcher во время создания.  
  
<a name="System_Windows_DependencyObject"></a>   
## <a name="systemwindowsdependencyobject"></a>System.Windows.DependencyObject  
 Одним из основных архитектурных концепций, используемых при построении WPF, является предпочтение свойств методам или событиям. Свойства являются декларативными, и с их помощью проще указать цель, а не действие. Поддерживается также система для отображения содержимого пользовательского интерфейса на основе моделей (или данных). Такой подход обусловил создание дополнительных свойств, к которым можно осуществить привязку в целях лучшего управления поведением приложения.  
  
 Для обеспечения большей части системы, управляемой свойствами, более обширная система свойств, чем нужна среда CLR. Простым примером такой полноты являются уведомления об изменении. Для двусторонней привязки необходимо, чтобы обе стороны привязки поддерживали уведомления об изменениях. Чтобы поведение зависело от значений свойств, необходимо получать уведомление в случае изменения значения свойства. Платформа Microsoft .NET имеет интерфейс **INotifyPropertyChange**, позволяющий объекту публиковать уведомления об изменениях, однако это необязательно.  
  
 WPF предоставляет более обширную систему свойств, производную от типа <xref:System.Windows.DependencyObject>. Система свойств действительно является системой свойств "зависимостей" в том смысле, что она отслеживает зависимости между выражениями свойств и автоматически проверяет значение свойства при изменении зависимости. Например, если имеется свойство, наследуемое (например, <xref:System.Windows.Controls.Control.FontSize%2A>), система автоматически обновляется, если свойство изменяется в родительском элементе элемента, который наследует значение.  
  
 Основой системы свойств WPF является понятие выражения свойства. В первом выпуске WPF система выражений свойств закрыта, а все выражения предоставляются как часть платформы. Выражения объясняют, почему система свойств не поддерживает привязку к данным, создание стилей или жестко заданное наследование, но вместо этого представлена слоями более поздних версий в платформе.  
  
 Система свойств также предоставляет способ разреженного хранения значений свойств. Так как объекты могут иметь десятки (если не сотни) свойств и большинство значений находится в состоянии по умолчанию (унаследованы, задаются стилем и т. д.), не каждый экземпляр объекта должен иметь все определенные в нем свойства в полном объеме.  
  
 Наконец, последняя новая особенность системы свойств — это понятие присоединенных свойств. Элементы WPF создаются на основе принципа повторного использования композиции и компонентов. Часто бывает так, что некоторым содержащим элементом (например, элементу макета <xref:System.Windows.Controls.Grid>) требуются дополнительные данные дочерних элементов, чтобы управлять его поведением (например, сведениями о строках и столбцах). Вместо того чтобы сопоставлять все эти свойства с каждым элементом, любой объект может предоставить определения свойств для любого другого объекта. Это похоже на возможности expando в JavaScript.  
  
<a name="System_Windows_Media_Visual"></a>   
## <a name="systemwindowsmediavisual"></a>System.Windows.Media.Visual  
 После определения системы следующим шагом является рисование пикселей на экране. Класс <xref:System.Windows.Media.Visual> предоставляет для создания дерева визуальных объектов, каждый из которых при необходимости содержит инструкции по рисованию и метаданные о том, как визуализировать эти инструкции (обрезка, преобразование и т. д.). <xref:System.Windows.Media.Visual> является чрезвычайно упрощенной и гибкой, поэтому большинство функций не имеют открытых интерфейсов API и сильно зависят от защищенных функций обратного вызова.  
  
 <xref:System.Windows.Media.Visual> на самом деле является точкой входа в систему композиции WPF. <xref:System.Windows.Media.Visual> является точкой подключения между этими двумя подсистемами, управляемым API и неуправляемым milcore.  
  
 WPF отображает данные путем обхода неуправляемых структур данных, управляемых milcore. Эти структуры, называемые узлами композиции, представляют собой иерархическое дерево отображения с инструкциями по отрисовке в каждом узле. Это дерево, показанное в правой части расположенного ниже рисунка, доступно только через протокол обмена сообщениями.  
  
 При программировании WPF создаются <xref:System.Windows.Media.Visual> элементы и производные типы, которые внутренне взаимодействуют с деревом композиции через этот протокол обмена сообщениями. Каждый <xref:System.Windows.Media.Visual> в WPF может создать один или несколько узлов композиции.  
  
 ![Визуальное дерево Windows Presentation Foundation.](./media/wpf-architecture2.PNG "wpf_architecture2")  
  
 Здесь имеется один очень важный архитектурный момент — все дерево визуальных объектов и инструкций по рисованию кэшируется. В графических терминах WPF использует готовую систему отрисовки. Это позволяет системе осуществлять перерисовку с высокой частотой без блокирования системы композиции при обратных вызовах, обращенных к коду пользователя. Это помогает предотвратить признаки неотвечающего приложения.  
  
 Другим важным моментом, который не заметен на схеме, является то, как система в действительности выполняет композицию.  
  
 В user32 и GDI система работает в режиме немедленной обрезки системы. Когда требуется визуализация компонента, система устанавливает границы обрезки, вне которых компонент не может изменять пиксели, а затем компонент запрашивает рисование пикселей в этой области. Эта система работает очень хорошо в системах с ограниченной памятью, так как в случае каких-либо изменений приходится иметь дело только с измененным компонентом — два компонента никогда не воздействуют на цвет одного пикселя.  
  
 WPF использует модель рисования "алгоритм по образцу". Это означает, что вместо обрезки каждого компонента каждый компонент запрашивается для отрисовки, начиная с заднего плана и до переднего плана отображения. Это позволяет рисовать каждый компонент поверх отображения предыдущего компонента. Преимуществом этой модели является то, что можно создавать сложные полупрозрачные фигуры. Благодаря современной современного графического оборудования эта модель относительно быстра (что не так, когда создавалась user32 или GDI).  
  
 Как упоминалось ранее, основная философия WPF — переход к более декларативной модели программирования, ориентированной на свойства. В визуальной системе это проявляется в паре любопытных моментов.  
  
 Во-первых, если говорить о сохраненном режиме графической системы, он действительно отражает переход от императивной модели DrawLine/DrawLine к модели, ориентированной на данные, — new Line()/new Line(). Этот переход к управляемой данными отрисовке позволяет выполнять сложные операции в инструкциях по рисованию, выражаемых с помощью свойств. Типы, производные от <xref:System.Windows.Media.Drawing>, фактически являются объектной моделью для подготовки к просмотру.  
  
 Во-вторых, оценивая систему анимации, можно увидеть, что она является практически полностью декларативной. Вместо обязательного вычисления разработчиком следующего положения или цвета можно выразить анимации как набор свойств для объекта анимации. Эти анимации могут выражать замыслы разработчика или проектировщика (переместить эту кнопку отсюда туда в течение 5 секунд), и система может определить наиболее эффективный способ для их выполнения.  
  
<a name="System_Windows_UIElement"></a>   
## <a name="systemwindowsuielement"></a>System.Windows.UIElement  
 <xref:System.Windows.UIElement> определяет основные подсистемы, включая макет, ввод и события.  
  
 Макет — это основная концепция в WPF. Во многих системах либо присутствует фиксированный набор моделей для макетов (HTML поддерживает три модели для макетов: поток, абсолютное значение и таблицы), либо вообще нет модели для макета (User32 в действительности поддерживает только абсолютное размещение). Платформа WPF была запущена с предположением, что разработчикам и дизайнерам требовалось гибкая расширяемая модель макета, которая может управляться значениями свойств, а не императивной логикой. На уровне <xref:System.Windows.UIElement> доступен базовый контракт для макета — модель из двух этапов с <xref:System.Windows.UIElement.Measure%2A> и <xref:System.Windows.UIElement.Arrange%2A>.  
  
 <xref:System.Windows.UIElement.Measure%2A> позволяет компоненту определить размер, который должен быть занят. Это отдельный этап от <xref:System.Windows.UIElement.Arrange%2A>, так как существует множество ситуаций, когда родительский элемент запрашивает у дочернего элемента несколько раз, чтобы определить его оптимальное расположение и размер. Тот факт, что родительские элементы запрашивают меру дочерних элементов, демонстрирует другую ключевую философию WPF — размер содержимого. Все элементы управления в WPF поддерживают возможность изменения размера в соответствии с естественным размером содержимого. Это значительно упрощает локализацию и позволяет осуществлять динамическую компоновку элементов в соответствии с изменением размеров. Этап <xref:System.Windows.UIElement.Arrange%2A> позволяет родительскому элементу позиционировать и определять конечный размер каждого дочернего элемента.  
  
 Часто приходится говорить о части выходных данных WPF — <xref:System.Windows.Media.Visual> и связанных объектов. Однако существует также множество новшеств со стороны ввода данных. Возможно, наиболее фундаментальным изменением входной модели WPF является последовательная модель, с помощью которой события ввода направляются через систему.  
  
 Ввод возникает как сигнал драйверу устройства режима ядра и направляется в нужный процесс и поток через сложный процесс, в котором участвуют ядро Windows и User32. После того как сообщение User32, соответствующее входным данным, направляется в WPF, оно преобразуется в необработанное входное сообщение WPF и отправляется диспетчеру. WPF позволяет преобразовывать необработанные входные события в несколько реальных событий, что позволяет реализовать такие функции, как "MouseEnter", на низком уровне системы с гарантированной доставкой.  
  
 Каждое событие ввода преобразуется по крайней мере в два события: событие предварительное и событие фактическое. Все события в WPF имеют понятие маршрутизации через дерево элементов. События говорят «пузырьковой», если они переходят от конечной папки к корневому элементу, и говорят о «туннеле», если они начинаются с корня и проходят до целевого объекта. Предварительные события ввода перемещаются по нисходящей, причем любые элементы в дереве могут фильтровать или обрабатывать событие. Обычные события (не предварительные) перемещаются по восходящей от конечной точки вверх к корню.  
  
 Это разделение между нисходящим и восходящими этапами делает возможным согласованную реализацию таких возможностей, как сочетания клавиш. В User32 сочетания клавиш реализуются посредством одной глобальной таблицы, содержащей все необходимые сочетания клавиш (CTRL+N сопоставляется с командой "Создать"). В диспетчере приложения вызывается метод **TranslateAccelerator**, который будет анализировать сообщения ввода в User32 и определять их соответствие зарегистрированному сочетанию клавиш. В WPF это не будет работать, так как система полностью "поддерживает композицию" — любой элемент может работать с любыми сочетаниями клавиш и использовать их. Наличие такой двухэтапной модели для ввода позволяет компонентам реализовать собственные методы TranslateAccelerator.  
  
 Чтобы выполнить этот шаг дальше, <xref:System.Windows.UIElement> также познакомится с понятием CommandBindings. Система команд WPF позволяет разработчикам определять функциональные возможности в терминах конечной точки команды — что-то, которое реализует <xref:System.Windows.Input.ICommand>. Привязки команд позволяют элементу определять соответствие между действием ввода (CTRL+N) и командой ("Создать"). И действия ввода, и определения команд являются расширяемыми и могут быть связаны вместе во время использования. Это делается, например, для того чтобы конечный пользователь мог легко настраивать привязки клавиш, которые ему необходимо использовать в приложении.  
  
 К этому моменту в разделе «Основные» функции WPF — функции, реализованные в сборке PresentationCore, были сосредоточены в фокусе. При создании WPF необходимо четкое разделение между базовыми частями (например, контрактом для макета с **мерами** и структурой **) и**элементами платформы (например, реализация определенного макета, например <xref:System.Windows.Controls.Grid>), была желаемым результатом. Целью являлось предоставление точки расширяемости внизу стека, что позволило бы внешним разработчикам при необходимости создавать свои собственные платформы.  
  
<a name="System_Windows_FrameworkElement"></a>   
## <a name="systemwindowsframeworkelement"></a>System.Windows.FrameworkElement  
 <xref:System.Windows.FrameworkElement> можно рассматривать двумя разными способами. В нем представлен набор политик и настроек для подсистем, представленных на более низких уровнях WPF. В нем также вводится набор новых подсистем.  
  
 Основная политика, появившаяся <xref:System.Windows.FrameworkElement>, связана с макетом приложения. <xref:System.Windows.FrameworkElement> основан на базовом контракте макета, представленном <xref:System.Windows.UIElement>, и добавляет понятие "слот" макета, что упрощает авторам макетов единообразный набор семантик макетов, управляемых свойствами. Такие свойства, как <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>, <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>и <xref:System.Windows.FrameworkElement.Margin%2A> (несколько имен), предоставляют всем компонентам, производным от <xref:System.Windows.FrameworkElement>, единообразное поведение в контейнерах макета.  
  
 <xref:System.Windows.FrameworkElement> также предоставляет более простой интерфейс API для многих функций, имеющихся на основных уровнях WPF. Например, <xref:System.Windows.FrameworkElement> предоставляет прямой доступ к анимации с помощью метода <xref:System.Windows.FrameworkElement.BeginStoryboard%2A>. <xref:System.Windows.Media.Animation.Storyboard> предоставляет способ создания скрипта для нескольких анимаций по набору свойств.  
  
 Две наиболее важные вещи, которые <xref:System.Windows.FrameworkElement> представляют, являются привязкой и стилями данных.  
  
 Подсистема привязки данных в WPF должна быть относительно знакома всем, кто использовал [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] или ASP.NET для создания приложения [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]. В каждой из этих систем есть простой способ выразить, что одно или несколько свойств данного элемента необходимо привязать к элементу данных. WPF обеспечивает полную поддержку привязки свойств, преобразования и привязки списка.  
  
 Одной из наиболее интересных функций привязки данных в WPF является введение шаблонов данных. Шаблоны данных позволяют декларативно указывать способ визуализации фрагмента данных. Вместо создания настраиваемого пользовательского интерфейса, который может быть привязан к данным, можно обойти проблему и позволить данным определять способ отображения.  
  
 Создание стилей — это облегченная форма привязки данных. Посредством создания стилей можно привязать набор свойств из общего определения к одному или нескольким экземплярам элемента. Стили применяются к элементу посредством явной ссылки (путем установки свойства <xref:System.Windows.FrameworkElement.Style%2A>) или неявно путем связывания стиля с типом CLR элемента.  
  
<a name="System_Windows_Controls_Control"></a>   
## <a name="systemwindowscontrolscontrol"></a>System.Windows.Controls.Control  
 Наиболее значимая возможность для элемента управления — это использование шаблонов. Если представлять себе систему композиции WPF как систему отрисовки сохраненного режима, то шаблоны позволяют элементу управления описывать свою отрисовку в параметризированной, декларативной форме. <xref:System.Windows.Controls.ControlTemplate>, на самом деле, является лишь сценарием создания набора дочерних элементов с привязками к свойствам, предлагаемым элементом управления.  
  
 <xref:System.Windows.Controls.Control> предоставляет набор стандартных свойств, <xref:System.Windows.Controls.Control.Foreground%2A>, <xref:System.Windows.Controls.Control.Background%2A>, <xref:System.Windows.Controls.Control.Padding%2A>, для названия нескольких, которые авторы шаблонов могут использовать для настройки представления элемента управления. Реализация элемента управления обеспечивает модель данных и модель взаимодействия. Модель взаимодействия определяет набор команд (таких как "Закрыть" для окна) и привязки к действиям ввода (таким как нажатие красного символа X в верхнем углу окна). Модель данных предоставляет набор свойств либо для настройки модели взаимодействия, либо для настройки отображения (определяется шаблоном).  
  
 Это разделение между моделью данных (свойства), моделью взаимодействия (команды и события) и моделью отображения (шаблоны) позволяет полностью настроить внешний вид и поведение элемента управления.  
  
 Типичным аспектом модели данных элементов управления является модель содержимого. Если взглянуть на элемент управления, например <xref:System.Windows.Controls.Button>, вы увидите, что у него есть свойство с именем "Content" типа <xref:System.Object>. В [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] и ASP.NET это свойство обычно является строкой, но ограничивает тип содержимого, которое можно добавить в кнопку. Содержимое для кнопки может представлять собой простую строку, сложный объект данных или все дерево элементов. В случае объекта данных используется шаблон данных для создания отображения.  
  
<a name="Summary"></a>   
## <a name="summary"></a>Сводка  
 Платформа WPF предназначена для создания динамических, управляемых данными систем представления данных. Каждая часть системы предназначена для создания объектов с помощью наборов свойств, которые определяют их поведение. Привязка данных является основополагающей частью системы и интегрирована на каждом уровне.  
  
 Традиционные приложения создают отображение, а затем привязывают его к некоторым данным. В WPF все элементы управления, каждый аспект экрана, создаются с помощью какого-либо типа привязки данных. Текст внутри кнопки отображается путем создания составного элемента управления внутри кнопки и привязки его отображения к свойству содержимого кнопки.  
  
 Когда вы начинаете разрабатывать приложения на основе WPF, оно должно быть знакомо. Можно задать свойства, использовать объекты и привязывать данные во многом так же, как можно использовать [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] или ASP.NET. Благодаря более глубокому исследованию архитектуры WPF вы обнаружите, что существует возможность создания более сложных приложений, которые фундаментально обрабатывают данные в качестве основного драйвера приложения.  
  
## <a name="see-also"></a>См. также:

- <xref:System.Windows.Media.Visual>
- <xref:System.Windows.UIElement>
- <xref:System.Windows.Input.ICommand>
- <xref:System.Windows.FrameworkElement>
- <xref:System.Windows.Threading.DispatcherObject>
- <xref:System.Windows.Input.CommandBinding>
- <xref:System.Windows.Controls.Control>
- [Общие сведения о привязке данных](../../../desktop-wpf/data/data-binding-overview.md)
- [Макет](layout.md)
- [Общие сведения об анимации](../graphics-multimedia/animation-overview.md)
