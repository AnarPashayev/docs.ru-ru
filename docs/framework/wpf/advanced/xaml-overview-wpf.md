---
title: Общие сведения о XAML (WPF)
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- user interfaces [XAML]
- classes [XAML]
- root element [XAML]
- XAML [WPF], about XAML
- base classes [XAML]
- routed events [WPF]
- code-behind files [WPF], XAML
- collection properties [XAML]
- events [XAML]
- property element [XAML]
- content models [XAML]
- Extensible Application Markup Language (see XAML)
- attribute syntax [XAML]
ms.assetid: a80db4cd-dd0f-479f-a45f-3740017c22e4
ms.openlocfilehash: 7aa695ae3402c4a834e5f83c40f341c5448ab524
ms.sourcegitcommit: 30a83efb57c468da74e9e218de26cf88d3254597
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/20/2019
ms.locfileid: "68364130"
---
# <a name="xaml-overview-wpf"></a>Общие сведения о XAML (WPF)
В этом разделе описаны возможности языка XAML и показано, как использовать язык XAML для написания приложений [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]. В частности, в этом разделе описывается реализация XAML в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. Сам язык XAML — это более широкое понятие языка, чем [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  

<a name="what_is_xaml"></a>   
## <a name="what-is-xaml"></a>Что это такое язык XAML?  
 XAML — это декларативный язык разметки. Код XAML, применяемый к .NET Framework модели программирования, упрощает создание [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] для .NET Framework приложения. Можно создать видимые элементы [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] в декларативной XAML-разметке, а затем отделить определение [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] от логики времени выполнения, используя файлы кода программной части, присоединенные к разметке с помощью определений разделяемых классов. Язык XAML напрямую представляет создание экземпляров объектов в конкретном наборе резервных типов, определенных в сборках. В этом заключается его отличие от большинства других языков разметки, которые, как правило, представляют собой интерпретируемые языки без прямой связи с системой резервных типов. Язык XAML обеспечивает рабочий процесс, позволяющий нескольким участникам разрабатывать [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] и логику приложения, используя потенциально различные средства.  
  
 При представлении в виде текста файлы XAML являются XML-файлами, которые обычно имеют расширение `.xaml`. Файлы можно сохранять в любой кодировке, поддерживаемой XML, но обычно используется кодировка UTF-8.  
  
 В следующем примере показано, как можно создать кнопку как часть [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]. Этот пример дает лишь общее представление о том, как в языке XAML представлены распространенные метафоры программирования для такого объекта как [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] (это неполный пример).  
  
 [!code-xaml[XAMLOvwSupport#DirtSimple](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page2.xaml#dirtsimple)]  
  
<a name="xaml_syntax_in_brief"></a>   
## <a name="xaml-syntax-in-brief"></a>Краткий синтаксис XAML  
 Далее приводятся описание основных форм синтаксиса XAML и короткий пример разметки. В этих разделах не приводится полная информация о каждой форме синтаксиса (например, представление в системе резервных типов). Дополнительные сведения об особенностях синтаксиса XAML для каждой формы синтаксиса, представленной в этом разделе см. в разделе [Подробное описание синтаксиса XAML](xaml-syntax-in-detail.md).  
  
 Значительная часть материалов в следующих нескольких разделах будет уже знакома тем, кто имеет опыт работы с языком XML. Это обусловлено базовыми принципами разработки языка XAML.  Язык XAML определяет собственные понятия, но эти понятия работают в XML-языке и форме разметки.  
  
### <a name="xaml-object-elements"></a>Элементы объекта XAML  
 Объектный элемент обычно объявляет экземпляр типа. Этот тип определен в сборках, предоставляющих резервные типы для технологии, в которой XAML используется как язык.  
  
 Синтаксис объектного элемента всегда начинается с открывающей угловой скобки (\<). За ней следует имя типа, для которого требуется создать экземпляр. (Имя может содержать префикс. Описание этого понятия будет приведено далее.) После этого при необходимости можно объявить атрибуты объектного элемента. Для завершения тега объектного элемента введите закрывающую угловую скобку (>). Вместо этого можно использовать самозакрывающуюся форму, в которой отсутствует содержимое, установив в конце тега косую черту и закрывающую угловую скобку (/>). Например, снова рассмотрим предыдущий фрагмент разметки.  
  
 [!code-xaml[XAMLOvwSupport#DirtSimple](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page2.xaml#dirtsimple)]  
  
 В нем указано два объектных элемента: `<StackPanel>` (с содержимым и последующим закрывающим тегом) и `<Button .../>` (самозакрывающаяся форма с несколькими атрибутами). Объектные элементы `StackPanel` и `Button` сопоставлены с именем класса, определенным [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] и являющимся частью сборок [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. При задании тега объектного элемента создается инструкция обработки XAML для создания нового экземпляра. Каждый экземпляр создается путем вызова конструктора без параметров базового типа при синтаксическом анализе и загрузке XAML.  
  
### <a name="attribute-syntax-properties"></a>Синтаксис атрибутов (свойства)  
 Свойства объекта часто можно выразить в виде атрибутов объектного элемента. Синтаксис атрибутов именует свойство, задаваемое в синтаксисе атрибутов, за которым следует оператор присваивания (=). Значение атрибута всегда задается как строка, заключенная в кавычки.  
  
 Синтаксис атрибутов — это наиболее простой синтаксис задания свойств, интуитивно понятный разработчикам, которые раньше использовали языки разметки. Например, следующая разметка создает кнопку с красным текстом и синим фоном и отображает текст, заданный как `Content`.  
  
 [!code-xaml[XAMLOvwSupport#BlueRedButton](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#blueredbutton)]  
  
### <a name="property-element-syntax"></a>Синтаксис элемента свойства  
 Для некоторых свойств объектного элемента невозможен синтаксис атрибутов, так как объект или сведения, необходимые для задания значения свойства, не могут быть адекватно представлены в строке, указываемой в кавычках, с соблюдением ограничений синтаксиса атрибутов. В этих случаях может использоваться другой синтаксис — синтаксис элементов свойств.  
  
 Для открывающего тега элемента свойства используется следующий синтаксис: `<`*имя_типа*`.`*имя_свойства*`>`. Как правило, содержимое этого тега является элементом объекта типа, который принимается в качестве значения свойства. После указания содержимого необходимо закрыть элемент свойства с закрывающим тегом. Для закрывающего тега используется синтаксис `</`*имя_типа*`.`*имя_свойства*`>`.  
  
 Если синтаксис атрибутов допустим, его использование, как правило, более удобно и приводит к созданию более компактной разметки, но часто выбор связан только со стилем, а не с техническими ограничениями. В следующем примере те же свойства задаются так же, как в предыдущем примере синтаксиса атрибутов, но на этот раз с помощью синтаксиса элементов свойств для всех свойств `Button`.  
  
 [!code-xaml[XAMLOvwSupport#BlueRedButtonPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#blueredbuttonpe)]  
  
### <a name="collection-syntax"></a>Синтаксис коллекции  
 Язык XAML включает некоторые оптимизации, делающие разметку более удобной для чтения. Одна из оптимизаций заключается в том, что, если определенное свойство принимает тип коллекции, элементы, объявленные в разметке как дочерние в пределах значения этого свойства, становятся частью коллекции. В этом случае коллекция дочерних объектных элементов является значением, которое задается для свойства коллекции.  
  
 В следующем примере показан синтаксис коллекции для установки значений <xref:System.Windows.Media.GradientBrush.GradientStops%2A> свойства:  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <!-- no explicit new GradientStopCollection, parser knows how to find or create -->  
    <GradientStop Offset="0.0" Color="Red" />  
    <GradientStop Offset="1.0" Color="Blue" />  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
### <a name="xaml-content-properties"></a>Свойства содержимого XAML  
 XAML указывает функцию языка, за счет чего класс может назначить только одно из своих свойств как свойство содержимого XAML. Дочерние элементы данного объектного элемента используются для задания значения этого свойства содержимого. Другими словами, для свойства содержимого (и только для него) можно опустить элемент свойства, указав это свойство в XAML-разметке, и тем самым создать более наглядную метафору родительского/дочернего элементов в разметке.  
  
 Например, <xref:System.Windows.Controls.Border> указывает свойство содержимого объекта <xref:System.Windows.Controls.Decorator.Child%2A>. Следующие два <xref:System.Windows.Controls.Border> элемента обрабатываются одинаково. Первый элемент использует преимущества синтаксиса свойства содержимого и опускает элемент свойства `Border.Child`. Второй пример явно показывает `Border.Child`.  
  
```xaml  
<Border>  
  <TextBox Width="300"/>  
</Border>  
<!--explicit equivalent-->  
<Border>  
  <Border.Child>  
    <TextBox Width="300"/>  
  </Border.Child>  
</Border>  
```  
  
 Для языка XAML действует следующее правило: значение свойства содержимого XAML должно быть задано полностью либо до, либо после любых других элементов свойств данного объектного элемента. Например, следующая разметка не компилируется.  
  
```  
<Button>I am a   
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 Дополнительные сведения об этом ограничении свойств содержимого XAML см. в подразделе "Свойства содержимого XAML" раздела [Подробное описание синтаксиса XAML](xaml-syntax-in-detail.md).  
  
### <a name="text-content"></a>Текстовое содержимое  
 Небольшое количество элементов XAML могут непосредственно обрабатывать текст как содержимое. Это происходит в одной из следующих ситуаций.  
  
- Класс должен объявлять свойство содержимого, и это свойство содержимого должно иметь тип, присваиваемый строке (тип может быть <xref:System.Object>). <xref:System.Windows.Controls.ContentControl> Например, любое использование <xref:System.Windows.Controls.ContentControl.Content%2A> в качестве свойства содержимого и имеет тип <xref:System.Object>, и это позволяет использовать <xref:System.Windows.Controls.Button>следующие возможности на практике <xref:System.Windows.Controls.ContentControl> , например: `<Button>Hello</Button>`.  
  
- Тип должен объявлять преобразователь типов, при этом текстовое содержимое используется как текст инициализации для данного преобразователя типов. Например, `<Brush>Blue</Brush>`. Этот случай менее распространен.  
  
- Тип должен быть известным типом-примитивом языка XAML.  
  
### <a name="content-properties-and-collection-syntax-combined"></a>Объединение свойств содержимого и синтаксиса коллекции  
 Рассмотрим следующий пример.  
  
```xaml  
<StackPanel>  
  <Button>First Button</Button>  
  <Button>Second Button</Button>  
</StackPanel>  
```  
  
 Здесь каждый <xref:System.Windows.Controls.Button> является дочерним <xref:System.Windows.Controls.StackPanel>элементом. Это рациональная и интуитивно понятная разметка, в которой опущены два тега по двум разным причинам.  
  
- **Пропущен элемент свойства StackPanel. Children:** является производным <xref:System.Windows.Controls.Panel>от. <xref:System.Windows.Controls.StackPanel> <xref:System.Windows.Controls.Panel>Определяет <xref:System.Windows.Controls.Panel.Children%2A?displayProperty=nameWithType> как свойство содержимого XAML.  
  
- **Пропущен элемент объекта UIElementCollection:** Свойство принимает тип <xref:System.Windows.Controls.UIElementCollection>, который реализует <xref:System.Collections.IList>. <xref:System.Windows.Controls.Panel.Children%2A?displayProperty=nameWithType> Тег элемента коллекции можно опустить на основе правил XAML для обработки коллекций, таких как <xref:System.Collections.IList>. (В данном случае <xref:System.Windows.Controls.UIElementCollection> создать экземпляр на самом деле невозможно, так как он не предоставляет конструктор без параметров, и именно поэтому элемент Object отображается с <xref:System.Windows.Controls.UIElementCollection> комментарием).  
  
```xaml  
<StackPanel>  
  <StackPanel.Children>  
    <!--<UIElementCollection>-->  
    <Button>First Button</Button>  
    <Button>Second Button</Button>  
    <!--</UIElementCollection>-->  
  </StackPanel.Children>  
</StackPanel>  
```  
  
### <a name="attribute-syntax-events"></a>Синтаксис атрибутов (события)  
 Синтаксис атрибутов также можно использовать для элементов, которые являются событиями, а не свойствами. В этом случае имя атрибута является именем события. События для языка XAML реализованы в WPF таким образом, что значение атрибута является именем обработчика, реализующего делегат этого события. Например, в следующей разметке обработчик <xref:System.Windows.Controls.Primitives.ButtonBase.Click> события <xref:System.Windows.Controls.Button> назначается созданной в разметке:  
  
 [!code-xaml[XAMLOvwSupport#ButtonWithCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page3.xaml#buttonwithcodebehind)]  
  
 Помимо этого примера синтаксиса атрибутов, имеется больше информации по событиям и XAML в WPF. Например, может возникнуть вопрос, что представляет и как определяется указанный здесь атрибут `ClickHandler`. Ответ можно найти в следующем подразделе [События и код программной части XAML](xaml-overview-wpf.md#events_and_xaml_codebehind) этого раздела.  
  
<a name="case_and_white space_in_xaml"></a>   
## <a name="case-and-white-space-in-xaml"></a>Регистр и пробелы в XAML  
 Вообще говоря, в языке XAML учитывается регистр символов. При разрешении резервных типов в WPF XAML регистр учитывается по тем же правилам, что и для CLR. Объектные элементы, элементы свойств и имена атрибутов должны быть указаны с учетом регистра символов при сравнении по имени с базовым типом в сборке или с элементом типа. В ключевых словах и примитивах в языке XAML также учитывается регистр. В значениях регистр учитывается не всегда. Учет регистра для значений будет зависеть от поведения преобразователя типов, связанного со свойством, которое принимает значение, или с соответствующим типом значения свойства. Например, свойства, принимающие <xref:System.Boolean> тип, могут `true` принимать или `True` эквивалентные значения, но только так как преобразование типа средства синтаксического анализа <xref:System.Boolean> XAML WPF для строки уже разрешает их как эквиваленты.  
  
 Обработчики WPF XAML и сериализаторы пропускают и удаляют все незначащие пробелы и будут нормализовать все значащие пробелы. Это согласуется с рекомендациями по использованию пробела по умолчанию в спецификации XAML. Данное поведение типично только при задании строки в свойствах содержимого XAML. Проще говоря, XAML преобразует пробелы, символы табуляции и перевода строки в пробелы, а затем сохраняет один пробел, если таковой найден с любого конца непрерывной строки. Полное объяснение обработки пробелов в XAML не рассматривается в этом разделе. Дополнительные сведения см. [в разделе Обработка пробелов в XAML](../../xaml-services/whitespace-processing-in-xaml.md).  
  
<a name="markup_extensions"></a>   
## <a name="markup-extensions"></a>Расширения разметки  
 Расширения разметки являются понятием языка XAML. При использовании для предоставления значения синтаксиса атрибутов фигурные скобки (`{` и `}`) указывают на использование расширения разметки. При обработке XAML расширения разметки обрабатываются иначе, чем значения атрибутов, обычно рассматриваемые как литеральная строка или как значение, которое может быть преобразовано в строку.  
  
 Наиболее распространенными расширениями разметки, используемыми при программирования приложений [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], являются [Binding](binding-markup-extension.md), используемое для выражений привязки данных, и ссылки на ресурсы [StaticResource](staticresource-markup-extension.md) и [DynamicResource](dynamicresource-markup-extension.md). Используя расширения разметки, можно использовать синтаксис атрибутов для указания значений свойств, которые в целом не поддерживают синтаксис атрибутов. В расширениях разметки часто используются промежуточные типы выражений для включения функций, которые присутствуют только во время выполнения, например откладывание значений или ссылка на другие объекты.  
  
 Например, следующая разметка задает значение <xref:System.Windows.FrameworkElement.Style%2A> свойства с помощью синтаксиса атрибута. Свойство принимает экземпляр <xref:System.Windows.Style> класса, который по умолчанию не может быть создан с помощью строки синтаксиса атрибута. <xref:System.Windows.FrameworkElement.Style%2A> Но в этом случае атрибут ссылается на определенное расширение разметки [StaticResource](staticresource-markup-extension.md). Когда это расширение разметки обрабатывается, оно возвращает ссылку на стиль, экземпляр которого был ранее создан в качестве ключевого ресурса в словаре ресурсов.  
  
 [!code-xaml[FEResourceSH_snip#XAMLOvwShortResources](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResourceSH_snip/CS/page1.xaml#xamlovwshortresources)]  
[!code-xaml[FEResourceSH_snip#XAMLOvwShortResources2](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResourceSH_snip/CS/page1.xaml#xamlovwshortresources2)]  
[!code-xaml[FEResourceSH_snip#XAMLOvwShortResources3](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResourceSH_snip/CS/page1.xaml#xamlovwshortresources3)]  
  
 Список всех расширений разметки для XAML, реализованных в WPF, см. в разделе [Расширения XAML WPF](wpf-xaml-extensions.md). Список расширений разметки, которые определены в System. XAML и более широко доступны для .NET Framework реализаций XAML, см. в разделе [пространство имен XAML (x:). Функции](../../xaml-services/xaml-namespace-x-language-features.md)языка. Дополнительные сведения о понятиях расширений разметки см. в разделе [Расширения разметки и XAML WPF](markup-extensions-and-wpf-xaml.md).  
  
<a name="type_converters"></a>   
## <a name="type-converters"></a>Преобразователи типов  
 В разделе [Краткое описание синтаксиса XAML](xaml-overview-wpf.md#xaml_syntax_in_brief) было отмечено, что необходимо обеспечить возможность задать значение атрибута строкой. Основная собственная обработка преобразования строк в другие типы объектов или примитивные значения основана на <xref:System.String> самом типе, а также в собственной обработке для определенных типов, таких как <xref:System.DateTime> или <xref:System.Uri>. Но многие типы [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] или члены этих типов расширяют основное поведение обработки атрибутов строк таким образом, что экземпляры более сложных типов объектов могут быть заданы как строки и атрибуты.  
  
 <xref:System.Windows.Thickness> Структура является примером типа с включенным преобразованием типов для использования XAML. <xref:System.Windows.Thickness>Указывает измерения внутри вложенного прямоугольника и используется в качестве значения для таких свойств, <xref:System.Windows.FrameworkElement.Margin%2A>как. Поместив преобразователь типов в <xref:System.Windows.Thickness>, все свойства, использующие объект <xref:System.Windows.Thickness> , проще указывать в XAML, поскольку они могут быть указаны как атрибуты. В следующем примере используется преобразование типа и синтаксис атрибутов для предоставления значения для <xref:System.Windows.FrameworkElement.Margin%2A>:  
  
 [!code-xaml[XAMLOvwSupport#MarginTCE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page7.xaml#margintce)]  
  
 Предыдущий пример синтаксиса атрибутов эквивалентен следующему подробному примеру синтаксиса, где <xref:System.Windows.FrameworkElement.Margin%2A> вместо этого задается синтаксис элемента свойства, <xref:System.Windows.Thickness> содержащий элемент Object. Четыре ключевых свойства класса <xref:System.Windows.Thickness> задаются в качестве атрибутов в новом экземпляре:  
  
 [!code-xaml[XAMLOvwSupport#MarginVerbose](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page7.xaml#marginverbose)]  
  
> [!NOTE]
>  Существует также ограниченное количество объектов, в которых преобразование типа является единственным открытым способом установки свойства для этого типа без использования подкласса, так как сам тип не содержит конструктора без параметров. Пример: <xref:System.Windows.Input.Cursor>.  
  
 Дополнительные сведения о поддержке преобразователя типов для синтаксиса атрибутов см. в разделе [TypeConverters и XAML](typeconverters-and-xaml.md).  
  
<a name="xaml_root_elements_and_xaml_namespaces"></a>   
## <a name="xaml-root-elements-and-xaml-namespaces"></a>Корневые элементы XAML и пространства имен XAML  
 Файл XAML должен иметь только один корневой элемент, чтобы одновременно быть файлом [!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)] с правильным форматом и допустимым файлом XAML. Для типичных сценариев WPF используется корневой элемент, который имеет заметное значение в модели <xref:System.Windows.Window> приложения WPF (например, или <xref:System.Windows.Controls.Page> для страницы, <xref:System.Windows.ResourceDictionary> для внешнего словаря или <xref:System.Windows.Application> для определения приложения). В следующем примере показан корневой элемент типичного XAML [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] -файла для страницы с корневым <xref:System.Windows.Controls.Page>элементом.  
  
 [!code-xaml[XAMLOvwSupport#RootOnly](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page2.xaml#rootonly)]  
[!code-xaml[XAMLOvwSupport#RootOnly2](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page2.xaml#rootonly2)]  
  
 Корневой элемент также содержит атрибуты `xmlns` и `xmlns:x`. Эти атрибуты указывают обработчику XAML, какие пространства имен XAML содержат определения типов для резервных типов, на которые будет ссылаться разметка в качестве элементов. Атрибут `xmlns` специально указывает пространство имен XAML по умолчанию. В пределах пространства имен XAML по умолчанию объектные элементы в разметке можно указывать без префикса. Для большинства сценариев приложения [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] и практически для всех примеров, приведенных в разделах [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)], пространство имен XAML по умолчанию сопоставлено с пространством имен [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA#tla_wpfxmlnsv1](../../../../includes/tlasharptla-wpfxmlnsv1-md.md)]. Атрибут `xmlns:x` указывает дополнительное пространство имен XAML, которое сопоставлено пространству имен языка [!INCLUDE[TLA#tla_xamlxmlnsv1](../../../../includes/tlasharptla-xamlxmlnsv1-md.md)].  
  
 Это использование атрибутов `xmlns` для определения области использования и сопоставления области видимости имен согласовано со спецификацией XML 1.0. Области видимости имен XAML отличаются от областей видимости имен XML только тем, что область видимости имен XAML также подразумевает некоторую информацию о резервном копировании элементов области видимости имен по типам в случае разрешения типов и анализа XAML.  
  
 Обратите внимание, что атрибуты `xmlns` строго необходимы только для корневого элемента каждого XAML-файла. Определения `xmlns` будут применяться ко всем элементам-потомкам корневого элемента (такое поведение также соответствует спецификации XML 1.0 для `xmlns`.). Атрибуты `xmlns` также разрешены для других элементов ниже корня и будут применены ко всем элементам-потомкам определяющего элемента. Впрочем, частое определение или повторное определение пространств имен XAML может сделать стиль разметки XAML трудным для человеческого восприятия.  
  
 В [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] реализация обработчика XAML включает инфраструктуру, содержащую информацию о ключевых сборках WPF. Ключевые сборки [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] содержат типы, поддерживающие сопоставления [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] с пространством имен XAML по умолчанию. Это осуществляется за счет конфигурации, являющейся частью файла построения проекта, построения WPF и систем проекта. Таким образом, объявление пространства имен XAML как `xmlns` по умолчанию — это все, что нужно, чтобы ссылаться на элементы XAML, полученные из сборок [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
### <a name="the-x-prefix"></a>Префикс x:  
 В предыдущем примере корневого элемента префикс `x:` использовался для сопоставления пространства имен XAML [!INCLUDE[TLA#tla_xamlxmlnsv1](../../../../includes/tlasharptla-xamlxmlnsv1-md.md)], которое является выделенным пространством имен XAML, поддерживающим конструкции языка XAML. Префикс `x:` используется для сопоставления данного пространства имен XAML в шаблонах для проектов, в примерах и в документации по всему этому [!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)]. Пространство имен XAML для языка XAML содержит несколько конструкций программирования, которые будут использоваться очень часто в XAML. Ниже приведен список наиболее распространенных конструкций программирования с префиксом `x:`, которые могут вам потребоваться.  
  
- [x:Key](../../xaml-services/x-key-directive.md): Задает уникальный ключ для каждого ресурса в <xref:System.Windows.ResourceDictionary> (или подобных понятиях словаря в других платформах). `x:Key` применяется примерно в 90 % случаев использования сопоставления `x:` в разметке типичных приложений WPF.  
  
- [x:Class](../../xaml-services/x-class-directive.md): [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] Указывает пространство имен и имя класса для класса, который предоставляет код программной части для страницы XAML. Согласно модели программирования WPF, такой класс должен присутствовать для поддержки кода программной части, поэтому сопоставление `x:` присутствует почти всегда, даже если ресурсы отсутствуют.  
  
- [x:Name](../../xaml-services/x-name-directive.md): Задает имя объекта времени выполнения для экземпляра, который существует в коде во время выполнения после обработки элемента объекта. Как правило, на практике часто используется свойство, определенное в WPF, эквивалентное [x:Name](../../xaml-services/x-name-directive.md). Такие свойства сопоставляются непосредственно с резервным свойством CLR, а потому более удобны для программирования приложений, где код времени выполнения часто используется для поиска именованных элементов из инициализированного XAML-кода. Наиболее распространенное такое свойство — <xref:System.Windows.FrameworkElement.Name%2A?displayProperty=nameWithType>. Можно по-прежнему использовать [x:Name](../../xaml-services/x-name-directive.md) , если эквивалентное свойство уровня <xref:System.Windows.FrameworkElement.Name%2A> среды WPF не поддерживается в определенном типе. Это происходит в некоторых сценариях анимации.  
  
- [x:Static](../../xaml-services/x-static-markup-extension.md): Включает ссылку, возвращающую статическое значение, которое в противном случае не является свойством, совместимым с XAML.  
  
- [x:Type](../../xaml-services/x-type-markup-extension.md): <xref:System.Type> Конструирует ссылку на основе имени типа. Он используется для указания атрибутов, которые принимают <xref:System.Type>, <xref:System.Windows.Style.TargetType%2A?displayProperty=nameWithType>например, хотя часто свойство имеет<xref:System.Type> собственную строку для преобразования, таким образом, что использование расширения разметки [x:Type](../../xaml-services/x-type-markup-extension.md) является необязательным.  
  
 Существуют дополнительные конструкции программирования в пространстве имен XAML/с префиксом `x:`, которые применяются не так часто. Дополнительные сведения см. [в разделе пространство имен XAML (x:). Функции](../../xaml-services/xaml-namespace-x-language-features.md)языка.  
  
<a name="custom_prefixes_and_custom_types_in_xaml"></a>   
## <a name="custom-prefixes-and-custom-types-in-xaml"></a>Пользовательские префиксы и пользовательские типы в XAML  
 При использовании собственных пользовательских сборок или сборок PresentationCore, PresentationFramework и WindowsBase за пределами ядра WPF можно указать сборку как часть пользовательского сопоставления `xmlns`. Затем можно указывать в пользовательском XAML-коде ссылки на типы из этой сборки, если в типе правильно реализована поддержка требуемых средств XAML.  
  
 Ниже приведен очень общий пример работы пользовательских префиксов в разметке XAML. Префикс `custom` определен в теге корневого элемента и сопоставляется с конкретной сборкой, упакованной и доступной в приложении. Эта сборка содержит тип `NumericUpDown`, который реализуется для поддержки общего использования XAML, а также использования наследования класса, которое можно вставить в данную конкретную точку модели содержимого XAML WPF. Экземпляр этого элемента управления `NumericUpDown` объявлен как объектный элемент, префикс обеспечивает, что анализатор XAML "знает", какое пространство имен XAML содержит тип и, следовательно, где находится резервная сборка, содержащая определение типа.  
  
```  
<Page  
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"   
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"   
    xmlns:custom="clr-namespace:NumericUpDownCustomControl;assembly=CustomLibrary"  
    >  
  <StackPanel Name="LayoutRoot">  
    <custom:NumericUpDown Name="numericCtrl1" Width="100" Height="60"/>  
...  
  </StackPanel>  
</Page>  
```  
  
 Дополнительные сведения о пользовательских типах в языке XAML см. в разделе [Код XAML и пользовательские классы для WPF](xaml-and-custom-classes-for-wpf.md).  
  
 Дополнительные сведения об отношении пространств имен XML и пространств имен кода программной части в сборках см. в разделе [Пространства имен XAML и сопоставление пространств имен для WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).  
  
<a name="events_and_xaml_codebehind"></a>   
## <a name="events-and-xaml-code-behind"></a>События и код программной части XAML  
 В большинстве приложений [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] содержатся как разметка XAML, так и код программной части. В рамках проекта XAML записывается в виде `.xaml` файла, [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] а также такого языка, как Microsoft Visual Basic или C# используется для записи файла кода программной части. При компиляции разметки в файле XAML (в составе модели приложений и программирования WPF) расположение файла кода программной части для файла XAML определяется путем указания пространства имен и класса как атрибута `x:Class` корневого элемента XAML-кода.  
  
 В приведенных примерах было использовано несколько кнопок, но ни с одной из этих кнопок не было ассоциировано логическое поведение. Первичным механизмом добавления поведения для объектного элемента на уровне приложения является использование существующего события элементного класса и написание специального обработчика для этого события, которое вызывается при возникновении этого события во время выполнения. Имя события и имя обработчика для использования указываются в разметке, тогда как код, который реализует обработчик, определен в коде программной части.  
  
 [!code-xaml[XAMLOvwSupport#ButtonWithCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page3.xaml#buttonwithcodebehind)]  
  
 [!code-csharp[XAMLOvwSupport#ButtonWithCodeBehindHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page3.xaml.cs#buttonwithcodebehindhandler)]
 [!code-vb[XAMLOvwSupport#ButtonWithCodeBehindHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XAMLOvwSupport/VisualBasic/Page1.xaml.vb#buttonwithcodebehindhandler)]  
  
 Обратите внимание, что файл кода программной части использует пространство имен CLR `ExampleNamespace` и объявляет `ExamplePage` как разделяемый класс в этом пространстве имен. Это аналогично значению атрибута `x:Class` `ExampleNamespace`.`ExamplePage`, предоставленному в корне разметки. Компилятор разметки WPF создает разделяемый класс для любого скомпилированного файла XAML путем создания класса, производного от типа корневого элемента. При предоставлении кода программной части, который также определяет тот же разделяемый класс, результирующий код объединяется внутри того же пространства имен и класса скомпилированного приложения.  
  
 Дополнительные сведения о требованиях к созданию кода программной части в WPF см. в подразделе "Код программной части, обработчик событий и требования частичного класса" раздела [Код программной части и XAML в WPF](code-behind-and-xaml-in-wpf.md).  
  
 Если создание отдельного файла кода программной части нежелательно, то можно также встроить код в файл XAML. Однако встроенный код является менее гибким методом, имеющим значительные ограничения. Дополнительные сведения см. в разделе [Код программной части и XAML в WPF](code-behind-and-xaml-in-wpf.md).  
  
### <a name="routed-events"></a>Перенаправленные события  
 Одна из наиболее важных возможностей в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] — перенаправленное событие. Перенаправленные события позволяют элементу обрабатывать событие, которое было вызвано другим элементом, пока они связаны через отношение дерева. При задании обработки события атрибутом XAML перенаправленное событие может отслеживаться и обрабатываться любым элементом, включая те, для которых это событие не указано в таблице членов класса. Это достигается путем уточнения атрибута имени события именем класса владельца. Например `StackPanel` , родитель в текущем `StackPanel` `Button` `Button.Click` примереможет`StackPanel` зарегистрировать обработчик для событиякнопкидочернегоэлемента,указаватрибутвэлементе<xref:System.Windows.Controls.Primitives.ButtonBase.Click>  /  объектный элемент с именем обработчика в качестве значения атрибута. Дополнительные сведения о принципах работы перенаправленных событий см. в разделе [Общие сведения о перенаправленных событиях](routed-events-overview.md).  
  
<a name="x_name_and_xaml_named_elements"></a>   
## <a name="xaml-named-elements"></a>Именованные элементы XAML  
 По умолчанию экземпляр объекта, созданный в графе объекта путем обработки объектного элемента XAML, не имеет уникального идентификатора или ссылки на объект. Напротив, если конструктор вызывается в коде, результат конструктора почти всегда используется для указания созданного экземпляра в качестве значения переменной, чтобы на него можно было ссылаться в дальнейшем коде. Для предоставления стандартизованного доступа к объектам, созданным с помощью определения разметки, в языке XAML определяется [атрибут x:Name](../../xaml-services/x-name-directive.md). Можно задать значение атрибута `x:Name` для любого объектного элемента. В коде программной части выбранный идентификатор эквивалентен переменной экземпляра, которая ссылается на созданный экземпляр. Именованные элементы во всех отношениях действуют так, как если бы они были экземплярами объекта (имя только ссылается на этот экземпляр), и в приложении код программной части может ссылаться на именованные элементы для обработки взаимодействий времени выполнения. Это соединение между экземплярами и переменными осуществляется компилятором разметки XAML WPF, а в частности <xref:System.Windows.Markup.IComponentConnector.InitializeComponent%2A> , в нем используются функции и шаблоны, которые не рассматриваются в этом разделе подробно.  
  
 Элементы XAML уровня среды WPF наследуют <xref:System.Windows.FrameworkElement.Name%2A> свойство, которое эквивалентно определенному `x:Name` атрибуту XAML. Некоторые другие классы также предоставляют эквиваленты уровня свойств для `x:Name`, который также обычно определяется как свойство `Name`. Вообще говоря, если не удается найти свойство `Name` в таблице членов для выбранного элемента или типа, вместо него следует использовать атрибут `x:Name`. Значения будут предоставлять идентификатор для элемента XAML, который может использоваться во время выполнения, конкретными подсистемами или вспомогательными методами, такими как <xref:System.Windows.FrameworkElement.FindName%2A>. `x:Name`  
  
 В следующем примере <xref:System.Windows.FrameworkElement.Name%2A> задается <xref:System.Windows.Controls.StackPanel> для элемента. Затем обработчик на <xref:System.Windows.Controls.Button> внутри, <xref:System.Windows.FrameworkElement.Name%2A>который <xref:System.Windows.Controls.StackPanel> ссылается на ссылку `buttonContainer` на <xref:System.Windows.Controls.StackPanel> экземпляр, как задано в.  
  
 [!code-xaml[XAMLOvwSupport#NamedE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page7.xaml#namede)]  
[!code-xaml[XAMLOvwSupport#NamedE2](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page7.xaml#namede2)]  
  
 [!code-csharp[XAMLOvwSupport#NameCode](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page7.xaml.cs#namecode)]
 [!code-vb[XAMLOvwSupport#NameCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XAMLOvwSupport/VisualBasic/Page1.xaml.vb#namecode)]  
  
 Как и в случае с переменными, имена экземпляров классов XAML регулируются понятием области, так что обеспечивается уникальность имен в пределах определенной области с известными границами. Основная разметка, определяющая страницу, обозначает одну уникальную область видимости имен XAML с корневым элементом страницы в качестве границы. Однако другие источники разметки могут взаимодействовать со страницей во время выполнения, например стили или шаблоны в стилях, и такие источники разметки часто имеют свои собственные области видимости имен XAML, не обязательно связанные с областью видимости имен XAML страницы. Дополнительные сведения о и `x:Name` областях имен XAML см. в <xref:System.Windows.FrameworkElement.Name%2A>разделе, [Директива x:Name](../../xaml-services/x-name-directive.md)или [области видимости имен XAML WPF](wpf-xaml-namescopes.md).  
  
<a name="attached_properties_and_attached_events"></a>   
## <a name="attached-properties-and-attached-events"></a>Вложенные свойства и вложенные события  
 Одна из возможностей языка XAML позволяет задавать для любого элемента определенные свойства или события, независимо от того, существует ли свойство или событие в таблице определений типа для этого элемента. Версия свойств этой возможности называется вложенным свойством, версия событий называется вложенным событием. Концептуально можно представить вложенные свойства и события как глобальные члены, которые могут быть заданы для любого элемента/экземпляра объекта XAML. Впрочем, этот элемент/класс (или более крупная инфраструктура) должен поддерживать резервное хранилище свойств для вложенных значений.  
  
 Вложенные свойства в языке XAML обычно используются через синтаксис атрибутов. В синтаксисе атрибутов можно указать вложенное свойство в виде *тип_владельца*.*имя_свойства*.  
  
 Внешне это напоминает использование элементов свойств, но в данном случае задаваемый тип *ownerType* всегда отличается от типа объектного элемента, для которого задается вложенное свойство. *ownerType* является типом, предоставляющим методы доступа, необходимые обработчику XAML для получения или установки значения вложенного свойства.  
  
 Наиболее распространенным сценарием для вложенных свойств является разрешение дочерним элементам предоставления значения свойства их родительскому элементу.  
  
 В следующем примере показано <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> присоединенное свойство. Класс определяет методы доступа для <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> и, следовательно, владеет присоединенным свойством. <xref:System.Windows.Controls.DockPanel> Класс также включает логику, которая выполняет итерацию дочерних элементов и в частности проверяет каждый элемент на заданное <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>значение. <xref:System.Windows.Controls.DockPanel> Если значение обнаруживается, это значение используется в процессе разметки для расположения дочерних элементов. Использование присоединенного свойства и этой возможности позиционирования на самом деле является сценарием мотивации <xref:System.Windows.Controls.DockPanel> для класса. <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>  
  
 [!code-xaml[XAMLOvwSupport#DockAP](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#dockap)]  
  
 В [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] большинство вложенных свойств (или все такие свойства) также реализуются как свойства зависимости. Дополнительные сведения см. в разделе [Общие сведения о вложенных свойствах зависимостей](attached-properties-overview.md).  
  
 Вложенные события используют аналогичную форму *тип_владельца*.*имя_события* синтаксиса атрибутов. Подобно невложенным событиям, значение атрибута для вложенного события в XAML задает имя метода обработчика, который вызывается, когда событие обрабатывается для элемента. Использование вложенного события в XAML WPF менее распространено. Дополнительные сведения см. в разделе [Общие сведения о вложенных событиях](attached-events-overview.md).  
  
<a name="base_classes_and_xaml"></a>   
## <a name="base-types-and-xaml"></a>Базовые типы и XAML  
 Базовая платформа XAML WPF и его пространство имен XAML представляют собой коллекцию типов, которые соответствуют объектам [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)], а также элементы разметки для XAML. Однако не все классы могут сопоставляться с элементами. Абстрактные классы, такие <xref:System.Windows.Controls.Primitives.ButtonBase>как и определенные неабстрактные базовые классы, используются для наследования [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] в модели объектов. Базовые классы, включая абстрактные, по-прежнему важны для разработки XAML, так как каждый из элементов XAML наследует члены некоторого базового класса в своей иерархии. Часто эти члены включают в себя свойства, которые можно задать в качестве атрибутов в элементе или событий, которые могут быть обработаны. <xref:System.Windows.FrameworkElement>является конкретным базовым [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] классом на уровне платформы WPF. При проектировании [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]будут использоваться различные классы форм, панелей, декораторов или элементов управления, которые являются производными от <xref:System.Windows.FrameworkElement>. Связанный базовый класс <xref:System.Windows.FrameworkContentElement>, поддерживает элементы, ориентированные на документ, которые хорошо подходят для представления в режиме потока, используя интерфейсы API, которые преднамеренно зеркально отражают <xref:System.Windows.FrameworkElement>интерфейсы API в. Сочетание атрибутов на уровне элементов и объектной модели [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] обеспечивает набор общих свойств, которые можно задать для большинства конкретных элементов XAML, независимо от типа элемента XAML и его базового типа.  
  
<a name="xaml_security"></a>   
## <a name="xaml-security"></a>Безопасность XAML  
 XAML — это язык разметки, непосредственно представляющий создание и выполнение объекта. Таким образом, элементы, созданные в XAML, имеют такие же возможности взаимодействия с системными ресурсами (например, сетевой доступ и операции ввода-вывода файловой системы), как и эквивалентный созданный код.  
  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]поддерживает .NET Framework 4. Управление доступом для кода платформы безопасности (CAS). Это означает, что содержимое [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], работающее в зоне Интернет, сократило разрешения исполнения. "Свободный XAML" (страницы некомпилированного XAML, интерпретируемые во время загрузки средства просмотра XAML) и [!INCLUDE[TLA#tla_xbap](../../../../includes/tlasharptla-xbap-md.md)] обычно выполняются в этой Интернет-зоне и используют один набор разрешений.  Однако XAML, загруженный в полностью доверенное приложение, имеет такой же доступ к системным ресурсам, как ведущее приложение. Дополнительные сведения см. в разделе [Безопасность частичного доверия в WPF](../wpf-partial-trust-security.md).  
  
<a name="loading_xaml_from_code"></a>   
## <a name="loading-xaml-from-code"></a>Загрузка XAML из кода  
 XAML можно использовать для определения всего пользовательского интерфейса, но иногда также уместно определение в XAML только его части. Эта возможность может использоваться для включения частичной настройки, локального хранения данных, использования XAML для предоставления бизнес-объекта или различных возможных сценариев. Ключом к этим сценариям является <xref:System.Windows.Markup.XamlReader> класс и его <xref:System.Windows.Markup.XamlReader.Load%2A> метод. Входные данные являются файлом XAML, а выходные данные — объектом, представляющим дерево объектов времени выполнения, созданных по разметке. Затем можно вставить объект, который будет свойством другого объекта, уже существующего в приложении. Пока свойство является допустимым свойством в модели содержимого, которая имеет возможности отображения и которая уведомляет ядро выполнения о добавлении в приложение нового содержимого, можно достаточно легко изменить содержимое работающего приложения путем загрузки XAML. Обратите внимание, что эта возможность доступна только в приложениях с уровнем полного доверия из-за очевидных с точки зрения безопасности последствий загрузки файлов в работающие приложения.  
  
<a name="whats_next"></a>   
## <a name="whats-next"></a>Дальнейшие действия  
 Этот раздел содержит основные сведения о терминологии и понятиях синтаксиса XAML применительно к WPF. Дополнительные сведения об используемых здесь терминах см. в разделе [Подробное описание синтаксиса XAML](xaml-syntax-in-detail.md).  
  
 Если вы еще не сделали этого, воспользуйтесь упражнениями в разделе [пошаговое руководство. Мое первое приложение](../getting-started/walkthrough-my-first-wpf-desktop-application.md)WPF для настольных систем. При создании приложения, ориентированного на разметку и описанного в руководстве, упражнения помогут лучше осознать многие понятия, описанные в этом разделе.  
  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]использует конкретную модель приложения, основанную на <xref:System.Windows.Application> классе. Дополнительные сведения см. в разделе [Общие сведения об управлении приложением](../app-development/application-management-overview.md).  
  
 В разделе [Построение приложения WPF](../app-development/building-a-wpf-application-wpf.md) представлены дополнительные сведения о том, как построить включающие XAML приложения из командной строки и в [!INCLUDE[TLA#tla_visualstu](../../../../includes/tlasharptla-visualstu-md.md)].  
  
 В разделе [Общие сведения о свойствах зависимостей](dependency-properties-overview.md) представлены дополнительные сведения о разнообразии свойств [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] и описано понятие свойств зависимостей.  
  
## <a name="see-also"></a>См. также

- [Подробное описание синтаксиса XAML](xaml-syntax-in-detail.md)
- [Код XAML и пользовательские классы для WPF](xaml-and-custom-classes-for-wpf.md)
- [Пространство имен XAML (x:) Языковые возможности](../../xaml-services/xaml-namespace-x-language-features.md)
- [Расширения XAML WPF](wpf-xaml-extensions.md)
- [Общие сведения о базовых элементах](base-elements-overview.md)
- [Деревья в WPF](trees-in-wpf.md)
