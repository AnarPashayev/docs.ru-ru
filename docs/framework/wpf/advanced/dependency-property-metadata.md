---
title: Метаданные свойства зависимости
ms.date: 03/30/2017
helpviewer_keywords:
- APIs [WPF], metadata
- dependency properties [WPF], metadata
- metadata [WPF], for dependency properties
- overriding metadata [WPF]
ms.assetid: d01ed009-b722-41bf-b82f-fe1a8cdc50dd
ms.openlocfilehash: 3d84510fce69e81929cbe9b6088e12aaf3409769
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79186370"
---
# <a name="dependency-property-metadata"></a>Метаданные свойства зависимости
Система [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] свойств включает в себя систему отчетности о метаданных, которая выходит за рамки того, что может быть сообщено о собственности через отражение или общие общие характеристики времени выполнения языка (CLR). Метаданные для свойства зависимости также можно уникально назначить для отдельного класса, который определяет свойство зависимости, можно изменить, когда свойство зависимости добавляется в другой класс, и можно переопределить, в частности, всеми производными классами, наследующими свойство зависимости от определяющего базового класса.  

<a name="prerequisites"></a>
## <a name="prerequisites"></a>Предварительные требования  
 Предполагается, что вы имеете представление о свойствах зависимостей с точки зрения потребителя существующих свойств зависимостей в классах [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] и ознакомились с разделом [Общие сведения о свойствах зависимостей](dependency-properties-overview.md). Чтобы выполнить примеры в этом разделе, следует также иметь представление о [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] и написании простых приложений [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
<a name="dp_metadata_contents"></a>
## <a name="how-dependency-property-metadata-is-used"></a>Как используются метаданные свойства зависимости  
 Метаданные свойств зависимости существуют в виде объекта, которому можно направлять запросы, чтобы проанализировать свойство зависимости. Система свойств также часто осуществляет доступ к этим метаданным, обрабатывая то или иное свойство зависимости. Объект метаданных для свойства зависимости может содержать следующие сведения.  
  
- Значение по умолчанию для свойства зависимости, если никакое другое значение не может быть определено для свойства зависимости по локальной стоимости, стилю, наследованию и т.д. Для тщательного обсуждения того, как значения по умолчанию участвуют в приоритете, используемом [Dependency Property Value Precedence](dependency-property-value-precedence.md)системой свойств при назначении значений для свойств зависимости, см.  
  
- Ссылки на реализации обратных вызовов, которые влияют на поведение приведения или уведомления об изменении для каждого типа владельца. Обратите внимание, что эти обратные вызовы часто определяются закрытым уровнем доступа, поэтому получить реальные ссылки из метаданных, как правило, невозможно, если только эти ссылки не находятся внутри области, к которой у вас имеется доступ. Дополнительные сведения об обратных вызовах свойств зависимости см. в разделе [Обратные вызовы свойств зависимости и проверка](dependency-property-callbacks-and-validation.md).  
  
- Если рассматриваемое свойство зависимости является свойством уровня среды WPF, метаданные могут содержать характеристики свойства зависимости уровня среды WPF, сообщающие информацию о службах и их состоянии, например модуле макетов уровня среды WPF и логику наследования свойств. Дополнительные сведения об этом аспекте метаданных свойства зависимости см. в разделе [Метаданные свойств среды](framework-property-metadata.md).  
  
<a name="APIs"></a>
## <a name="metadata-apis"></a>Интерфейсы API метаданных  
 Тип, который сообщает большую часть информации о метаданных, используемой системой свойств, является классом. <xref:System.Windows.PropertyMetadata> Экземпляры метаданных указываются при необходимости, когда свойства зависимости регистрируются в системе свойств; их можно повторно указать для дополнительных типов, добавляющихся в качестве владельцев или переопределяющих метаданные, которые они наследуют от определения свойства зависимости базового класса. (В случаях, когда регистрация недвижимости не указывает <xref:System.Windows.PropertyMetadata> метаданные, создается значение значения по умолчанию для этого класса.) Зарегистрированные метаданные возвращаются <xref:System.Windows.PropertyMetadata> при вызове различных <xref:System.Windows.DependencyProperty.GetMetadata%2A> перегрузок, которые получают метаданные из свойства зависимости на экземпляре. <xref:System.Windows.DependencyObject>  
  
 Затем <xref:System.Windows.PropertyMetadata> класс выводится из более конкретных метаданных для архитектурных подразделений, таких как классы уровня рамочного уровня WPF. <xref:System.Windows.UIPropertyMetadata>добавляет отчетность о <xref:System.Windows.FrameworkPropertyMetadata> анимации и предоставляет свойства уровня платформы WPF, упомянутые в предыдущем разделе. Когда свойства зависимости зарегистрированы, они <xref:System.Windows.PropertyMetadata> могут быть зарегистрированы в этих классах, полученных. При изучении метаданных базовый <xref:System.Windows.PropertyMetadata> тип потенциально может быть отлит в производные классы, чтобы можно было изучить более конкретные свойства.  
  
> [!NOTE]
> Характеристики свойств, которые <xref:System.Windows.FrameworkPropertyMetadata> могут быть указаны в, иногда называются в настоящей документации как "флаги". При создании новых экземпляров метаданных для использования в регистрации свойств зависимости или переопределения метаданных вы <xref:System.Windows.FrameworkPropertyMetadataOptions> указываете эти значения с помощью перечисления флагом, <xref:System.Windows.FrameworkPropertyMetadata> а затем поставляются возможно совмещенные значения перечисления конструктору. Однако, после построения, эти <xref:System.Windows.FrameworkPropertyMetadata> характеристики опции подвергаются в пределах серии свойств Boolean, а не построения значения перечисления. Логические свойства позволяют проверить каждое условие, а не требуют применения маски к значению флагового перечисления для получения интересующей вас информации. Конструктор использует concatenated <xref:System.Windows.FrameworkPropertyMetadataOptions> для того чтобы держать длину подписи конструктора разумно, тогда как фактически ежектые построенные метаданные подвергают дискретные свойства для того чтобы сделать запрос метаданные более интуитивным.  
  
<a name="override_or_subclass"></a>
## <a name="when-to-override-metadata-when-to-derive-a-class"></a>Когда следует переопределять метаданные, а когда — создавать производный класс  
 В системном свойстве [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] имеются установленные возможности для изменения некоторых характеристик свойств зависимости без повторного создания с нуля. Это достигается путем создания другого экземпляра метаданных свойства для свойства зависимости в том виде, в котором оно существует в определенном типе. Обратите внимание, что большинство существующих свойств зависимости не являются виртуальными свойствами, поэтому строго говоря, их повторное создание в унаследованных классах возможно только путем затемнения существующего члена.  
  
 Если невозможно реализовать нужный вам сценарий для свойства зависимости в типе путем изменения характеристик существующих свойств зависимости, возможно, потребуется создать производный класс, а затем объявить в нем пользовательское свойство зависимости. Пользовательское свойство зависимости ведет себя одинаково свойствам [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] зависимости, определенным AIS. Дополнительные сведения о пользовательских свойствах зависимости см. в разделе [Пользовательские свойства зависимости](custom-dependency-properties.md).  
  
 Единственной важной характеристикой свойства зависимости, которую невозможно переопределить, является его тип значения. Если вы наследуете свойство зависимости, которое имеет примерное поведение, нужное вам, но вам нужен другой тип свойства, потребуется создать пользовательское свойство зависимости и, возможно, связать два свойства друг с другом через преобразование типов или другую реализацию пользовательского класса. Кроме того, вы <xref:System.Windows.ValidateValueCallback>не можете заменить существующий, потому что этот обратный вызов существует в самом поле регистрации, а не в его метаданных.  
  
<a name="scenarios"></a>
## <a name="scenarios-for-changing-existing-metadata"></a>Сценарии для изменения существующих метаданных  
 При работе с метаданными существующего свойства зависимости одним из распространенных сценариев для изменения метаданных свойства зависимости является изменение значения по умолчанию. Изменение или добавление обратных вызовов системы свойств является более сложным сценарием. Это целесообразно, если в вашей реализации производного класса существуют различные взаимосвязи между свойствами зависимостей. Одно из условий наличия модели программирования, которая поддерживает и код, и декларативное использование, заключается в том, что свойства должны обеспечить возможность настройки их значений в любом порядке. Следовательно, все зависимые свойства необходимо настраивать в режиме JIT без контекста; при этом невозможно использовать какую-либо информацию о порядке настройки (которую можно найти, например, в конструкторе). Дополнительные сведения об этом аспекте системы свойств см. в разделе [Проверка и обратные вызовы свойства зависимостей](dependency-property-callbacks-and-validation.md). Обратите внимание, что обратные вызовы проверки не являются частью метаданных; они являются частью идентификатора свойства зависимости. Следовательно, обратные вызовы проверки невозможно изменить путем переопределения метаданных.  
  
 В некоторых случаях целесообразно изменить параметры метаданных свойств уровня среды WPF для существующих свойств зависимости. Эти параметры связывают некоторые известные условия свойств уровня среды WPF с другими процессами среды WPF, такими как система макетов.  Настройка опций обычно выполняется только при регистрации нового свойства зависимости, но также можно изменить метаданные <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> <xref:System.Windows.DependencyProperty.AddOwner%2A> свойства уровня WPF как часть вызова или вызова. Дополнительные сведения и рекомендации по использованию конкретных значений см. в разделе [Метаданные свойств среды](framework-property-metadata.md). Дополнительные сведения о том, как следует настраивать эти свойства для только что зарегистрированного свойства зависимости, см. в разделе [Пользовательские свойства зависимости](custom-dependency-properties.md).  
  
<a name="dp_override_metadata"></a>
### <a name="overriding-metadata"></a>Переопределение метаданных  
 Основной целью переопределения метаданных является то, что у вас есть возможность изменить различные производные от метаданных характеристики, которые применяются к свойству зависимости в том виде, в котором оно существует в вашем типе. Причины этого рассматриваются более подробно в разделе [Метаданные](#dp_metadata_contents). Дополнительные сведения, включая примеры кода, см. в разделе [Переопределение метаданных для свойства зависимости](how-to-override-metadata-for-a-dependency-property.md).  
  
 Метаданные свойств могут быть предоставлены для собственности<xref:System.Windows.DependencyProperty.Register%2A>зависимости во время регистрационного звонка (). Но во многих случаях целесообразно предоставить метаданные определенного типа для вашего класса, когда он наследует соответствующее свойство зависимости. Вы можете сделать <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> это, позвонив в метод.  Например, из [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.FrameworkElement> AI, класс — это тип, <xref:System.Windows.UIElement.Focusable%2A> который сначала регистрирует свойство зависимости. Но <xref:System.Windows.Controls.Control> класс переопределяет метаданные для свойства зависимости, чтобы обеспечить `false` свое `true`собственное начальное значение <xref:System.Windows.UIElement.Focusable%2A> по умолчанию, изменяя его с к , и в противном случае повторно использует исходную реализацию.  
  
 При переопределении метаданных различные характеристики метаданных объединяются или заменяют друг друга.  
  
- <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>сливается. Если вы добавите новый, <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>то обратный вызов хранится в метаданных. Если вы не <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> указали в переопределении, значение повышается как ссылка от ближайшего <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> предка, который указал его в метаданных.  
  
- Фактическое поведение системы свойств для <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> того, чтобы реализации для всех владельцев метаданных в иерархии сохранялись и добавлялись в таблицу, при этом порядок выполнения системой свойств в том, что наиболее полученные группы вызовов вызываются в первую очередь.  
  
- <xref:System.Windows.PropertyMetadata.DefaultValue%2A>заменяется. Если вы не <xref:System.Windows.PropertyMetadata.DefaultValue%2A> укажете в переопределении, значение исходит от ближайшего <xref:System.Windows.PropertyMetadata.DefaultValue%2A> предка, который указал его в метаданных.  
  
- <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>реализации заменяются. Если вы добавите новый, <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>то обратный вызов хранится в метаданных. Если вы не <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> указали в переопределении, значение повышается как ссылка от ближайшего <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> предка, который указал его в метаданных.  
  
- Поведение системы свойств заключается в том, что вызывается только <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> в непосредственных метаданных. Ссылки на <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> другие реализации в иерархии не сохраняются.  
  
 Это поведение <xref:System.Windows.PropertyMetadata.Merge%2A>реализуется, и может быть переопределено на производных классах метаданных.  
  
#### <a name="overriding-attached-property-metadata"></a>Переопределение метаданных присоединенного свойства  
 В [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] вложенные свойства реализованы как свойства зависимости. Это означает, что они также имеют метаданные свойств, которые могут быть переопределены отдельными классами. Рассмотрение для прикрепленного свойства, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] как правило, что <xref:System.Windows.DependencyObject> любой может иметь прикрепленное свойство, установленное на них. Таким образом, любой <xref:System.Windows.DependencyObject> полученный класс может переопределить метаданные для любого прилагаемого свойства, так как они могут быть установлены на экземпляре класса. Можно переопределить значения по умолчанию, обратные вызовы или свойства отчетности о характеристиках уровня среды WPF. Если вложенное свойство задано в экземпляре класса, действуют характеристики переопределенных метаданных свойства. Например, можно переопределить значение по умолчанию, чтобы переопределенное значение передавалось как значение вложенного свойства в экземплярах класса всякий раз, когда свойство не задано никаким другим способом.  
  
> [!NOTE]
> Свойство <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> не имеет значения для прилагаемых свойств.  
  
<a name="dp_add_owner"></a>
### <a name="adding-a-class-as-an-owner-of-an-existing-dependency-property"></a>Добавление класса в качестве владельца существующего свойства зависимости  
 Класс может добавить себя в качестве владельца свойства зависимости, которое уже зарегистрировано, с помощью метода. <xref:System.Windows.DependencyProperty.AddOwner%2A> Это позволяет классу использовать свойство зависимости, первоначально зарегистрированное для другого типа. Добавляемый класс, как правило, не является производным классом типа, который первым зарегистрировал это свойство зависимости в качестве владельца. Фактически это позволяет классу и его производным классам "наследовать" реализацию свойства зависимости, даже если исходный класс-владелец и добавляемый класс не находятся в одной действительной иерархии классов. Кроме того, добавляемый класс (и все его наследуемые классы) могут затем предоставить метаданные определенного типа для исходного свойства зависимости.  
  
 Помимо добавления себя в качестве владельца с использованием служебных методов системы свойств, добавляемый класс должен объявить в себе дополнительные открытые элементы, чтобы сделать свойство зависимости полноценным участником в системе свойств, которое доступно и коду, и разметке. Класс, который добавляет существующее свойство зависимости, имеет те же обязанности по предоставлению объектной модели для свойства зависимости, что и класс, определяющий новое пользовательское свойство зависимости. Первый такой предоставляемый элемент — поле идентификатора свойства зависимости. Это поле должно `public static readonly` быть <xref:System.Windows.DependencyProperty>полем типа, которое присваивается значению возврата <xref:System.Windows.DependencyProperty.AddOwner%2A> вызова. Вторым участником, определяющим, является свойство "обертки" общего языка (CLR). Обертка делает его гораздо более удобным для манипулирования вашей <xref:System.Windows.DependencyObject.SetValue%2A> зависимости собственности в коде (вы избежать звонков каждый раз, и может сделать этот звонок только один раз в обертке себя). Оболочка реализуется так же, как если бы регистрировалось пользовательское свойство зависимости. Дополнительные сведения о реализации свойства зависимости см. в разделе [Пользовательские свойства взаимозависимости](custom-dependency-properties.md) и [Добавление типа владельца для свойства зависимостей](how-to-add-an-owner-type-for-a-dependency-property.md).  
  
#### <a name="addowner-and-attached-properties"></a>AddOwner и вложенные свойства  
 Можно вызвать <xref:System.Windows.DependencyProperty.AddOwner%2A> свойство зависимости, которое определяется как прилагаемое свойство классом владельца. Обычно так делают, чтобы предоставить ранее вложенное свойство в качестве невложенного свойства зависимости. Затем вы обнажаете значение <xref:System.Windows.DependencyProperty.AddOwner%2A> возврата в качестве `public static readonly` поля для использования в качестве идентификатора свойств зависимости и определите соответствующие свойства "обертки", чтобы свойство отослало в таблице членов и поддерживало неприлагаемое использование свойств в вашем классе.  
  
## <a name="see-also"></a>См. также раздел

- <xref:System.Windows.PropertyMetadata>
- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- <xref:System.Windows.DependencyProperty.GetMetadata%2A>
- [Общие сведения о свойствах зависимости](dependency-properties-overview.md)
- [Метаданные свойств среды](framework-property-metadata.md)
