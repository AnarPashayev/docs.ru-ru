---
title: Метаданные свойства зависимости
ms.date: 03/30/2017
helpviewer_keywords:
- APIs [WPF], metadata
- dependency properties [WPF], metadata
- metadata [WPF], for dependency properties
- overriding metadata [WPF]
ms.assetid: d01ed009-b722-41bf-b82f-fe1a8cdc50dd
ms.openlocfilehash: 154a2543c62de545e8b2df711d6ad51989d0689d
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/22/2019
ms.locfileid: "69964853"
---
# <a name="dependency-property-metadata"></a>Метаданные свойства зависимости
Система [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] свойств включает систему создания отчетов по метаданным, которая выходит за рамки того, что может быть сообщено о свойстве через отражение или общие характеристики среды CLR. Метаданные для свойства зависимости также можно уникально назначить для отдельного класса, который определяет свойство зависимости, можно изменить, когда свойство зависимости добавляется в другой класс, и можно переопределить, в частности, всеми производными классами, наследующими свойство зависимости от определяющего базового класса.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Предварительные требования  
 Предполагается, что вы имеете представление о свойствах зависимостей с точки зрения потребителя существующих свойств зависимостей в классах [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] и ознакомились с разделом [Общие сведения о свойствах зависимостей](dependency-properties-overview.md). Чтобы выполнить примеры в этом разделе, следует также иметь представление о [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] и написании приложений [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
<a name="dp_metadata_contents"></a>   
## <a name="how-dependency-property-metadata-is-used"></a>Как используются метаданные свойства зависимости  
 Метаданные свойств зависимости существуют в виде объекта, которому можно направлять запросы, чтобы проанализировать свойство зависимости. Система свойств также часто осуществляет доступ к этим метаданным, обрабатывая то или иное свойство зависимости. Объект метаданных для свойства зависимости может содержать следующие сведения.  
  
- Значение по умолчанию для свойства зависимости, если никакое другое значение для свойства зависимости не может быть определено локальным значением, стилем, наследованием и т. д. Подробное описание того, как значения по умолчанию применяются системой свойств при определении приоритета присвоения значений для свойств зависимостей, см. в разделе [Приоритет значения свойства зависимости](dependency-property-value-precedence.md).  
  
- Ссылки на реализации обратных вызовов, которые влияют на поведение приведения или уведомления об изменении для каждого типа владельца. Обратите внимание, что эти обратные вызовы часто определяются закрытым уровнем доступа, поэтому получить реальные ссылки из метаданных, как правило, невозможно, если только эти ссылки не находятся внутри области, к которой у вас имеется доступ. Дополнительные сведения об обратных вызовах свойств зависимости см. в разделе [Обратные вызовы свойств зависимости и проверка](dependency-property-callbacks-and-validation.md).  
  
- Если рассматриваемое свойство зависимости является свойством уровня среды WPF, метаданные могут содержать характеристики свойства зависимости уровня среды WPF, сообщающие информацию о службах и их состоянии, например модуле макетов уровня среды WPF и логику наследования свойств. Дополнительные сведения об этом аспекте метаданных свойства зависимости см. в разделе [Метаданные свойств среды](framework-property-metadata.md).  
  
<a name="APIs"></a>   
## <a name="metadata-apis"></a>Интерфейсы API метаданных  
 Тип, который сообщает большую часть сведений о метаданных, используемых системой свойств, — <xref:System.Windows.PropertyMetadata> это класс. Экземпляры метаданных указываются при необходимости, когда свойства зависимости регистрируются в системе свойств; их можно повторно указать для дополнительных типов, добавляющихся в качестве владельцев или переопределяющих метаданные, которые они наследуют от определения свойства зависимости базового класса. (В случаях, когда регистрация свойства не указывает метаданные, для этого класса <xref:System.Windows.PropertyMetadata> создается значение по умолчанию со значениями по умолчанию.) Зарегистрированные метаданные возвращаются, как <xref:System.Windows.PropertyMetadata> при вызове различных <xref:System.Windows.DependencyProperty.GetMetadata%2A> перегрузок, которые получают метаданные из свойства зависимостей в <xref:System.Windows.DependencyObject> экземпляре.  
  
 Затем <xref:System.Windows.PropertyMetadata> класс является производным от класса, чтобы предоставить более конкретные метаданные для структурных подразделений, таких как классы уровня среды WPF. <xref:System.Windows.UIPropertyMetadata>добавляет отчеты о анимации и <xref:System.Windows.FrameworkPropertyMetadata> предоставляет свойства уровня среды WPF, упомянутые в предыдущем разделе. При регистрации свойств зависимости они могут быть зарегистрированы в этих <xref:System.Windows.PropertyMetadata> производных классах. При проверке метаданных базовый <xref:System.Windows.PropertyMetadata> тип может быть приведен к производному классу, чтобы можно было изучить более конкретные свойства.  
  
> [!NOTE]
> Характеристики свойств, которые могут быть заданы <xref:System.Windows.FrameworkPropertyMetadata> в, иногда называются в этой документации как "Flags". При создании новых экземпляров метаданных для использования в регистрации свойств зависимостей или переопределениях метаданных эти значения указываются с помощью перечисления <xref:System.Windows.FrameworkPropertyMetadataOptions> флагового, а затем указываются возможные сцепленные значения перечисления в <xref:System.Windows.FrameworkPropertyMetadata> конструктор. Однако после создания эти характеристики параметров предоставляются в <xref:System.Windows.FrameworkPropertyMetadata> виде последовательности логических свойств, а не значения перечисления. Логические свойства позволяют проверить каждое условие, а не требуют применения маски к значению флагового перечисления для получения интересующей вас информации. Конструктор использует объединенный <xref:System.Windows.FrameworkPropertyMetadataOptions> объект, чтобы обеспечить разумную длину сигнатуры конструктора, в то время как фактически создаваемые метаданные предоставляют дискретные свойства, чтобы сделать запрос к метаданным более интуитивным.  
  
<a name="override_or_subclass"></a>   
## <a name="when-to-override-metadata-when-to-derive-a-class"></a>Когда следует переопределять метаданные, а когда — создавать производный класс  
 В системном свойстве [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] имеются установленные возможности для изменения некоторых характеристик свойств зависимости без повторного создания с нуля. Это достигается путем создания другого экземпляра метаданных свойства для свойства зависимости в том виде, в котором оно существует в определенном типе. Обратите внимание, что большинство существующих свойств зависимости не являются виртуальными свойствами, поэтому строго говоря, их повторное создание в унаследованных классах возможно только путем затемнения существующего члена.  
  
 Если невозможно реализовать нужный вам сценарий для свойства зависимости в типе путем изменения характеристик существующих свойств зависимости, возможно, потребуется создать производный класс, а затем объявить в нем пользовательское свойство зависимости. Пользовательское свойство зависимости ведет себя идентично свойствам зависимостей, определенным в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] интерфейсах API. Дополнительные сведения о пользовательских свойствах зависимости см. в разделе [Пользовательские свойства зависимости](custom-dependency-properties.md).  
  
 Единственной важной характеристикой свойства зависимости, которую невозможно переопределить, является его тип значения. Если вы наследуете свойство зависимости, которое имеет примерное поведение, нужное вам, но вам нужен другой тип свойства, потребуется создать пользовательское свойство зависимости и, возможно, связать два свойства друг с другом через преобразование типов или другую реализацию пользовательского класса. Кроме того, нельзя заменить существующий <xref:System.Windows.ValidateValueCallback>, так как этот обратный вызов существует в поле регистрации, а не в его метаданных.  
  
<a name="scenarios"></a>   
## <a name="scenarios-for-changing-existing-metadata"></a>Сценарии для изменения существующих метаданных  
 При работе с метаданными существующего свойства зависимости одним из распространенных сценариев для изменения метаданных свойства зависимости является изменение значения по умолчанию. Изменение или добавление обратных вызовов системы свойств является более сложным сценарием. Это целесообразно, если в вашей реализации производного класса существуют различные взаимосвязи между свойствами зависимостей. Одно из условий наличия модели программирования, которая поддерживает и код, и декларативное использование, заключается в том, что свойства должны обеспечить возможность настройки их значений в любом порядке. Следовательно, все зависимые свойства необходимо настраивать в режиме JIT без контекста; при этом невозможно использовать какую-либо информацию о порядке настройки (которую можно найти, например, в конструкторе). Дополнительные сведения об этом аспекте системы свойств см. в разделе [Проверка и обратные вызовы свойства зависимостей](dependency-property-callbacks-and-validation.md). Обратите внимание, что обратные вызовы проверки не являются частью метаданных; они являются частью идентификатора свойства зависимости. Следовательно, обратные вызовы проверки невозможно изменить путем переопределения метаданных.  
  
 В некоторых случаях целесообразно изменить параметры метаданных свойств уровня среды WPF для существующих свойств зависимости. Эти параметры связывают некоторые известные условия свойств уровня среды WPF с другими процессами среды WPF, такими как система макетов.  Установка параметров обычно выполняется только при регистрации нового свойства зависимости, но можно также изменить метаданные свойства уровня среды WPF как часть <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> вызова или. <xref:System.Windows.DependencyProperty.AddOwner%2A> Дополнительные сведения и рекомендации по использованию конкретных значений см. в разделе [Метаданные свойств среды](framework-property-metadata.md). Дополнительные сведения о том, как следует настраивать эти свойства для только что зарегистрированного свойства зависимости, см. в разделе [Пользовательские свойства зависимости](custom-dependency-properties.md).  
  
<a name="dp_override_metadata"></a>   
### <a name="overriding-metadata"></a>Переопределение метаданных  
 Основной целью переопределения метаданных является то, что у вас есть возможность изменить различные производные от метаданных характеристики, которые применяются к свойству зависимости в том виде, в котором оно существует в вашем типе. Причины этого рассматриваются более подробно в разделе [Метаданные](#dp_metadata_contents). Дополнительные сведения, включая примеры кода, см. в разделе [Переопределение метаданных для свойства зависимости](how-to-override-metadata-for-a-dependency-property.md).  
  
 Метаданные свойства могут быть заданы для свойства зависимостей во время вызова регистрации (<xref:System.Windows.DependencyProperty.Register%2A>). Но во многих случаях целесообразно предоставить метаданные определенного типа для вашего класса, когда он наследует соответствующее свойство зависимости. Это можно сделать, вызвав <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> метод.  Для примера из [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API-интерфейсов <xref:System.Windows.FrameworkElement> класс является <xref:System.Windows.UIElement.Focusable%2A> типом, который сначала регистрирует свойство зависимостей. Однако класс переопределяет метаданные для свойства зависимостей, чтобы предоставить собственное начальное значение по умолчанию, изменив `true`его с `false` на и иным образом повторно используя <xref:System.Windows.UIElement.Focusable%2A> исходную реализацию. <xref:System.Windows.Controls.Control>  
  
 При переопределении метаданных различные характеристики метаданных объединяются или заменяют друг друга.  
  
- <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>объединяется. При добавлении нового <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>ответный вызов сохраняется в метаданных. Если не указать <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> в переопределении, <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> значение будет выдвинуто как ссылка из ближайшего предка, указанного в метаданных.  
  
- Фактическое поведение системы свойств для <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> заключается в том, что реализации для всех владельцев метаданных в иерархии сохраняются и добавляются в таблицу с порядком выполнения системой свойств, которая вызывается первыми при вызове обратного вызова производного класса.  
  
- <xref:System.Windows.PropertyMetadata.DefaultValue%2A>заменяется. Если не указать <xref:System.Windows.PropertyMetadata.DefaultValue%2A> в переопределении, <xref:System.Windows.PropertyMetadata.DefaultValue%2A> значение берется из ближайшего предка, указанного в метаданных.  
  
- <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>реализации заменяются. При добавлении нового <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>ответный вызов сохраняется в метаданных. Если не указать <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> в переопределении, <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> значение будет выдвинуто как ссылка из ближайшего предка, указанного в метаданных.  
  
- Поведение системы свойств заключается в том, что <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> вызывается только в немедленных метаданных. Ссылки на другие <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> реализации в иерархии не сохраняются.  
  
 Это поведение реализуется <xref:System.Windows.PropertyMetadata.Merge%2A>и может быть переопределено в производных классах метаданных.  
  
#### <a name="overriding-attached-property-metadata"></a>Переопределение метаданных присоединенного свойства  
 В [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] вложенные свойства реализованы как свойства зависимости. Это означает, что они также имеют метаданные свойств, которые могут быть переопределены отдельными классами. Рекомендации по области для присоединенного свойства в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] обычно <xref:System.Windows.DependencyObject> могут иметь для них присоединенное свойство. Таким образом, <xref:System.Windows.DependencyObject> любой производный класс может переопределить метаданные для любого присоединенного свойства, как это может быть задано в экземпляре класса. Можно переопределить значения по умолчанию, обратные вызовы или свойства отчетности о характеристиках уровня среды WPF. Если вложенное свойство задано в экземпляре класса, действуют характеристики переопределенных метаданных свойства. Например, можно переопределить значение по умолчанию, чтобы переопределенное значение передавалось как значение вложенного свойства в экземплярах класса всякий раз, когда свойство не задано никаким другим способом.  
  
> [!NOTE]
> <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> Свойство не относится к присоединенным свойствам.  
  
<a name="dp_add_owner"></a>   
### <a name="adding-a-class-as-an-owner-of-an-existing-dependency-property"></a>Добавление класса в качестве владельца существующего свойства зависимости  
 Класс может добавить себя в качестве владельца свойства зависимостей, которое уже было зарегистрировано с помощью <xref:System.Windows.DependencyProperty.AddOwner%2A> метода. Это позволяет классу использовать свойство зависимости, первоначально зарегистрированное для другого типа. Добавляемый класс, как правило, не является производным классом типа, который первым зарегистрировал это свойство зависимости в качестве владельца. Фактически это позволяет классу и его производным классам "наследовать" реализацию свойства зависимости, даже если исходный класс-владелец и добавляемый класс не находятся в одной действительной иерархии классов. Кроме того, добавляемый класс (и все его наследуемые классы) могут затем предоставить метаданные определенного типа для исходного свойства зависимости.  
  
 Помимо добавления себя в качестве владельца с использованием служебных методов системы свойств, добавляемый класс должен объявить в себе дополнительные открытые элементы, чтобы сделать свойство зависимости полноценным участником в системе свойств, которое доступно и коду, и разметке. Класс, который добавляет существующее свойство зависимости, имеет те же обязанности по предоставлению объектной модели для свойства зависимости, что и класс, определяющий новое пользовательское свойство зависимости. Первый такой предоставляемый элемент — поле идентификатора свойства зависимости. Это поле должно быть `public static readonly` полем типа <xref:System.Windows.DependencyProperty>, которое присваивается возвращаемому значению <xref:System.Windows.DependencyProperty.AddOwner%2A> вызова. Вторым определяемым элементом является свойство "оболочки" среды CLR. Программа-оболочка намного удобнее в управлении свойством зависимостей в коде (это позволяет избежать вызовов <xref:System.Windows.DependencyObject.SetValue%2A> каждый раз и выполнять этот вызов только один раз в самой оболочке). Оболочка реализуется так же, как если бы регистрировалось пользовательское свойство зависимости. Дополнительные сведения о реализации свойства зависимости см. в разделе [Пользовательские свойства взаимозависимости](custom-dependency-properties.md) и [Добавление типа владельца для свойства зависимостей](how-to-add-an-owner-type-for-a-dependency-property.md).  
  
#### <a name="addowner-and-attached-properties"></a>AddOwner и вложенные свойства  
 Можно вызвать <xref:System.Windows.DependencyProperty.AddOwner%2A> для свойства зависимости, которое определено как присоединенное свойство классом Owner. Обычно так делают, чтобы предоставить ранее вложенное свойство в качестве невложенного свойства зависимости. Затем вы получите <xref:System.Windows.DependencyProperty.AddOwner%2A> возвращаемое значение в `public static readonly` качестве поля для использования в качестве идентификатора свойства зависимости и определит соответствующие свойства "оболочки", чтобы свойство появлялось в таблице Members и поддерживало неприсоединенное свойство. использование в классе.  
  
## <a name="see-also"></a>См. также

- <xref:System.Windows.PropertyMetadata>
- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- <xref:System.Windows.DependencyProperty.GetMetadata%2A>
- [Общие сведения о свойствах зависимости](dependency-properties-overview.md)
- [Метаданные свойств среды](framework-property-metadata.md)
