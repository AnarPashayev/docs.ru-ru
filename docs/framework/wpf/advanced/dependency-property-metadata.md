---
title: Метаданные свойства зависимости
ms.date: 03/30/2017
helpviewer_keywords:
- APIs [WPF], metadata
- dependency properties [WPF], metadata
- metadata [WPF], for dependency properties
- overriding metadata [WPF]
ms.assetid: d01ed009-b722-41bf-b82f-fe1a8cdc50dd
ms.openlocfilehash: 3d84510fce69e81929cbe9b6088e12aaf3409769
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79186370"
---
# <a name="dependency-property-metadata"></a><span data-ttu-id="6071b-102">Метаданные свойства зависимости</span><span class="sxs-lookup"><span data-stu-id="6071b-102">Dependency Property Metadata</span></span>
<span data-ttu-id="6071b-103">Система [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] свойств включает в себя систему отчетности о метаданных, которая выходит за рамки того, что может быть сообщено о собственности через отражение или общие общие характеристики времени выполнения языка (CLR).</span><span class="sxs-lookup"><span data-stu-id="6071b-103">The [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] property system includes a metadata reporting system that goes beyond what can be reported about a property through reflection or general common language runtime (CLR) characteristics.</span></span> <span data-ttu-id="6071b-104">Метаданные для свойства зависимости также можно уникально назначить для отдельного класса, который определяет свойство зависимости, можно изменить, когда свойство зависимости добавляется в другой класс, и можно переопределить, в частности, всеми производными классами, наследующими свойство зависимости от определяющего базового класса.</span><span class="sxs-lookup"><span data-stu-id="6071b-104">Metadata for a dependency property can also be assigned uniquely by the class that defines a dependency property, can be changed when the dependency property is added to a different class, and can be specifically overridden by all derived classes that inherit the dependency property from the defining base class.</span></span>  

<a name="prerequisites"></a>
## <a name="prerequisites"></a><span data-ttu-id="6071b-105">Предварительные требования</span><span class="sxs-lookup"><span data-stu-id="6071b-105">Prerequisites</span></span>  
 <span data-ttu-id="6071b-106">Предполагается, что вы имеете представление о свойствах зависимостей с точки зрения потребителя существующих свойств зависимостей в классах [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] и ознакомились с разделом [Общие сведения о свойствах зависимостей](dependency-properties-overview.md).</span><span class="sxs-lookup"><span data-stu-id="6071b-106">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md).</span></span> <span data-ttu-id="6071b-107">Чтобы выполнить примеры в этом разделе, следует также иметь представление о [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] и написании простых приложений [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span><span class="sxs-lookup"><span data-stu-id="6071b-107">In order to follow the examples in this topic, you should also understand [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] and know how to write [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications.</span></span>  
  
<a name="dp_metadata_contents"></a>
## <a name="how-dependency-property-metadata-is-used"></a><span data-ttu-id="6071b-108">Как используются метаданные свойства зависимости</span><span class="sxs-lookup"><span data-stu-id="6071b-108">How Dependency Property Metadata is Used</span></span>  
 <span data-ttu-id="6071b-109">Метаданные свойств зависимости существуют в виде объекта, которому можно направлять запросы, чтобы проанализировать свойство зависимости.</span><span class="sxs-lookup"><span data-stu-id="6071b-109">Dependency property metadata exists as an object that can be queried to examine the characteristics of a dependency property.</span></span> <span data-ttu-id="6071b-110">Система свойств также часто осуществляет доступ к этим метаданным, обрабатывая то или иное свойство зависимости.</span><span class="sxs-lookup"><span data-stu-id="6071b-110">This metadata is also accessed frequently by the property system as it processes any given dependency property.</span></span> <span data-ttu-id="6071b-111">Объект метаданных для свойства зависимости может содержать следующие сведения.</span><span class="sxs-lookup"><span data-stu-id="6071b-111">The metadata object for a dependency property can contain the following types of information:</span></span>  
  
- <span data-ttu-id="6071b-112">Значение по умолчанию для свойства зависимости, если никакое другое значение не может быть определено для свойства зависимости по локальной стоимости, стилю, наследованию и т.д. Для тщательного обсуждения того, как значения по умолчанию участвуют в приоритете, используемом [Dependency Property Value Precedence](dependency-property-value-precedence.md)системой свойств при назначении значений для свойств зависимости, см.</span><span class="sxs-lookup"><span data-stu-id="6071b-112">Default value for the dependency property, if no other value can be determined for the dependency property by local value, style, inheritance, etc. For a thorough discussion of how default values participate in the precedence used by the property system when assigning values for dependency properties, see [Dependency Property Value Precedence](dependency-property-value-precedence.md).</span></span>  
  
- <span data-ttu-id="6071b-113">Ссылки на реализации обратных вызовов, которые влияют на поведение приведения или уведомления об изменении для каждого типа владельца.</span><span class="sxs-lookup"><span data-stu-id="6071b-113">References to callback implementations that affect coercion or change-notification behaviors on a per-owner-type basis.</span></span> <span data-ttu-id="6071b-114">Обратите внимание, что эти обратные вызовы часто определяются закрытым уровнем доступа, поэтому получить реальные ссылки из метаданных, как правило, невозможно, если только эти ссылки не находятся внутри области, к которой у вас имеется доступ.</span><span class="sxs-lookup"><span data-stu-id="6071b-114">Note that these callbacks are often defined with a nonpublic access level, so obtaining the actual references from metadata is generally not possible unless the references are within your permitted access scope.</span></span> <span data-ttu-id="6071b-115">Дополнительные сведения об обратных вызовах свойств зависимости см. в разделе [Обратные вызовы свойств зависимости и проверка](dependency-property-callbacks-and-validation.md).</span><span class="sxs-lookup"><span data-stu-id="6071b-115">For more information on dependency property callbacks, see [Dependency Property Callbacks and Validation](dependency-property-callbacks-and-validation.md).</span></span>  
  
- <span data-ttu-id="6071b-116">Если рассматриваемое свойство зависимости является свойством уровня среды WPF, метаданные могут содержать характеристики свойства зависимости уровня среды WPF, сообщающие информацию о службах и их состоянии, например модуле макетов уровня среды WPF и логику наследования свойств.</span><span class="sxs-lookup"><span data-stu-id="6071b-116">If the dependency property in question is considered to be a WPF framework-level property, the metadata might contain WPF framework-level dependency property characteristics, which report information and state for services such as the WPF framework-level layout engine and property inheritance logic.</span></span> <span data-ttu-id="6071b-117">Дополнительные сведения об этом аспекте метаданных свойства зависимости см. в разделе [Метаданные свойств среды](framework-property-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="6071b-117">For more information on this aspect of dependency property metadata, see [Framework Property Metadata](framework-property-metadata.md).</span></span>  
  
<a name="APIs"></a>
## <a name="metadata-apis"></a><span data-ttu-id="6071b-118">Интерфейсы API метаданных</span><span class="sxs-lookup"><span data-stu-id="6071b-118">Metadata APIs</span></span>  
 <span data-ttu-id="6071b-119">Тип, который сообщает большую часть информации о метаданных, используемой системой свойств, является классом. <xref:System.Windows.PropertyMetadata></span><span class="sxs-lookup"><span data-stu-id="6071b-119">The type that reports most of the metadata information used by the property system is the <xref:System.Windows.PropertyMetadata> class.</span></span> <span data-ttu-id="6071b-120">Экземпляры метаданных указываются при необходимости, когда свойства зависимости регистрируются в системе свойств; их можно повторно указать для дополнительных типов, добавляющихся в качестве владельцев или переопределяющих метаданные, которые они наследуют от определения свойства зависимости базового класса.</span><span class="sxs-lookup"><span data-stu-id="6071b-120">Metadata instances are optionally specified when dependency properties are registered with the property system, and can be specified again for additional types that either add themselves as owners or override metadata they inherit from the base class dependency property definition.</span></span> <span data-ttu-id="6071b-121">(В случаях, когда регистрация недвижимости не указывает <xref:System.Windows.PropertyMetadata> метаданные, создается значение значения по умолчанию для этого класса.) Зарегистрированные метаданные возвращаются <xref:System.Windows.PropertyMetadata> при вызове различных <xref:System.Windows.DependencyProperty.GetMetadata%2A> перегрузок, которые получают метаданные из свойства зависимости на экземпляре. <xref:System.Windows.DependencyObject></span><span class="sxs-lookup"><span data-stu-id="6071b-121">(For cases where a property registration does not specify metadata, a default <xref:System.Windows.PropertyMetadata> is created with default values for that class.)The registered metadata is returned as <xref:System.Windows.PropertyMetadata> when you call the various <xref:System.Windows.DependencyProperty.GetMetadata%2A> overloads that get metadata from a dependency property on a <xref:System.Windows.DependencyObject> instance.</span></span>  
  
 <span data-ttu-id="6071b-122">Затем <xref:System.Windows.PropertyMetadata> класс выводится из более конкретных метаданных для архитектурных подразделений, таких как классы уровня рамочного уровня WPF.</span><span class="sxs-lookup"><span data-stu-id="6071b-122">The <xref:System.Windows.PropertyMetadata> class is then derived from to provide more specific metadata for architectural divisions such as the WPF framework-level classes.</span></span> <span data-ttu-id="6071b-123"><xref:System.Windows.UIPropertyMetadata>добавляет отчетность о <xref:System.Windows.FrameworkPropertyMetadata> анимации и предоставляет свойства уровня платформы WPF, упомянутые в предыдущем разделе.</span><span class="sxs-lookup"><span data-stu-id="6071b-123"><xref:System.Windows.UIPropertyMetadata> adds animation reporting, and <xref:System.Windows.FrameworkPropertyMetadata> provides the WPF framework-level properties mentioned in the previous section.</span></span> <span data-ttu-id="6071b-124">Когда свойства зависимости зарегистрированы, они <xref:System.Windows.PropertyMetadata> могут быть зарегистрированы в этих классах, полученных.</span><span class="sxs-lookup"><span data-stu-id="6071b-124">When dependency properties are registered, they can be registered with these <xref:System.Windows.PropertyMetadata> derived classes.</span></span> <span data-ttu-id="6071b-125">При изучении метаданных базовый <xref:System.Windows.PropertyMetadata> тип потенциально может быть отлит в производные классы, чтобы можно было изучить более конкретные свойства.</span><span class="sxs-lookup"><span data-stu-id="6071b-125">When the metadata is examined, the base <xref:System.Windows.PropertyMetadata> type can potentially be cast to the derived classes so that you can examine the more specific properties.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="6071b-126">Характеристики свойств, которые <xref:System.Windows.FrameworkPropertyMetadata> могут быть указаны в, иногда называются в настоящей документации как "флаги".</span><span class="sxs-lookup"><span data-stu-id="6071b-126">The property characteristics that can be specified in <xref:System.Windows.FrameworkPropertyMetadata> are sometimes referred to in this documentation as "flags".</span></span> <span data-ttu-id="6071b-127">При создании новых экземпляров метаданных для использования в регистрации свойств зависимости или переопределения метаданных вы <xref:System.Windows.FrameworkPropertyMetadataOptions> указываете эти значения с помощью перечисления флагом, <xref:System.Windows.FrameworkPropertyMetadata> а затем поставляются возможно совмещенные значения перечисления конструктору.</span><span class="sxs-lookup"><span data-stu-id="6071b-127">When you create new metadata instances for use in dependency property registrations or metadata overrides, you specify these values using the flagwise enumeration <xref:System.Windows.FrameworkPropertyMetadataOptions> and then you supply possibly concatenated values of the enumeration to the <xref:System.Windows.FrameworkPropertyMetadata> constructor.</span></span> <span data-ttu-id="6071b-128">Однако, после построения, эти <xref:System.Windows.FrameworkPropertyMetadata> характеристики опции подвергаются в пределах серии свойств Boolean, а не построения значения перечисления.</span><span class="sxs-lookup"><span data-stu-id="6071b-128">However, once constructed, these option characteristics are exposed within a <xref:System.Windows.FrameworkPropertyMetadata> as a series of Boolean properties rather than the constructing enumeration value.</span></span> <span data-ttu-id="6071b-129">Логические свойства позволяют проверить каждое условие, а не требуют применения маски к значению флагового перечисления для получения интересующей вас информации.</span><span class="sxs-lookup"><span data-stu-id="6071b-129">The Boolean properties enable you to check each conditional, rather than requiring you to apply a mask to a flagwise enumeration value to get the information you are interested in.</span></span> <span data-ttu-id="6071b-130">Конструктор использует concatenated <xref:System.Windows.FrameworkPropertyMetadataOptions> для того чтобы держать длину подписи конструктора разумно, тогда как фактически ежектые построенные метаданные подвергают дискретные свойства для того чтобы сделать запрос метаданные более интуитивным.</span><span class="sxs-lookup"><span data-stu-id="6071b-130">The constructor uses the concatenated <xref:System.Windows.FrameworkPropertyMetadataOptions> in order to keep the length of the constructor signature reasonable, whereas the actual constructed metadata exposes the discrete properties to make querying the metadata more intuitive.</span></span>  
  
<a name="override_or_subclass"></a>
## <a name="when-to-override-metadata-when-to-derive-a-class"></a><span data-ttu-id="6071b-131">Когда следует переопределять метаданные, а когда — создавать производный класс</span><span class="sxs-lookup"><span data-stu-id="6071b-131">When to Override Metadata, When to Derive a Class</span></span>  
 <span data-ttu-id="6071b-132">В системном свойстве [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] имеются установленные возможности для изменения некоторых характеристик свойств зависимости без повторного создания с нуля.</span><span class="sxs-lookup"><span data-stu-id="6071b-132">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system has established capabilities for changing some characteristics of dependency properties without requiring them to be entirely re-implemented.</span></span> <span data-ttu-id="6071b-133">Это достигается путем создания другого экземпляра метаданных свойства для свойства зависимости в том виде, в котором оно существует в определенном типе.</span><span class="sxs-lookup"><span data-stu-id="6071b-133">This is accomplished by constructing a different instance of property metadata for the dependency property as it exists on a particular type.</span></span> <span data-ttu-id="6071b-134">Обратите внимание, что большинство существующих свойств зависимости не являются виртуальными свойствами, поэтому строго говоря, их повторное создание в унаследованных классах возможно только путем затемнения существующего члена.</span><span class="sxs-lookup"><span data-stu-id="6071b-134">Note that most existing dependency properties are not virtual properties, so strictly speaking "re-implementing" them on inherited classes could only be accomplished by shadowing the existing member.</span></span>  
  
 <span data-ttu-id="6071b-135">Если невозможно реализовать нужный вам сценарий для свойства зависимости в типе путем изменения характеристик существующих свойств зависимости, возможно, потребуется создать производный класс, а затем объявить в нем пользовательское свойство зависимости.</span><span class="sxs-lookup"><span data-stu-id="6071b-135">If the scenario you are trying to enable for a dependency property on a type cannot be accomplished by modifying characteristics of existing dependency properties, it might then be necessary to create a derived class, and then to declare a custom dependency property on your derived class.</span></span> <span data-ttu-id="6071b-136">Пользовательское свойство зависимости ведет себя одинаково свойствам [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] зависимости, определенным AIS.</span><span class="sxs-lookup"><span data-stu-id="6071b-136">A custom dependency property behaves identically to dependency properties defined by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] APIs.</span></span> <span data-ttu-id="6071b-137">Дополнительные сведения о пользовательских свойствах зависимости см. в разделе [Пользовательские свойства зависимости](custom-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="6071b-137">For more details about custom dependency properties, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="6071b-138">Единственной важной характеристикой свойства зависимости, которую невозможно переопределить, является его тип значения.</span><span class="sxs-lookup"><span data-stu-id="6071b-138">One notable characteristic of a dependency property that you cannot override is its value type.</span></span> <span data-ttu-id="6071b-139">Если вы наследуете свойство зависимости, которое имеет примерное поведение, нужное вам, но вам нужен другой тип свойства, потребуется создать пользовательское свойство зависимости и, возможно, связать два свойства друг с другом через преобразование типов или другую реализацию пользовательского класса.</span><span class="sxs-lookup"><span data-stu-id="6071b-139">If you are inheriting a dependency property that has the approximate behavior you require, but you require a different type for it, you will have to implement a custom dependency property and perhaps link the properties through type conversion or other implementation on your custom class.</span></span> <span data-ttu-id="6071b-140">Кроме того, вы <xref:System.Windows.ValidateValueCallback>не можете заменить существующий, потому что этот обратный вызов существует в самом поле регистрации, а не в его метаданных.</span><span class="sxs-lookup"><span data-stu-id="6071b-140">Also, you cannot replace an existing <xref:System.Windows.ValidateValueCallback>, because this callback exists in the registration field itself and not within its metadata.</span></span>  
  
<a name="scenarios"></a>
## <a name="scenarios-for-changing-existing-metadata"></a><span data-ttu-id="6071b-141">Сценарии для изменения существующих метаданных</span><span class="sxs-lookup"><span data-stu-id="6071b-141">Scenarios for Changing Existing Metadata</span></span>  
 <span data-ttu-id="6071b-142">При работе с метаданными существующего свойства зависимости одним из распространенных сценариев для изменения метаданных свойства зависимости является изменение значения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="6071b-142">If you are working with metadata of an existing dependency property, one common scenario for changing dependency property metadata is to change the default value.</span></span> <span data-ttu-id="6071b-143">Изменение или добавление обратных вызовов системы свойств является более сложным сценарием.</span><span class="sxs-lookup"><span data-stu-id="6071b-143">Changing or adding property system callbacks is a more advanced scenario.</span></span> <span data-ttu-id="6071b-144">Это целесообразно, если в вашей реализации производного класса существуют различные взаимосвязи между свойствами зависимостей.</span><span class="sxs-lookup"><span data-stu-id="6071b-144">You might want to do this if your implementation of a derived class has different interrelationships between dependency properties.</span></span> <span data-ttu-id="6071b-145">Одно из условий наличия модели программирования, которая поддерживает и код, и декларативное использование, заключается в том, что свойства должны обеспечить возможность настройки их значений в любом порядке.</span><span class="sxs-lookup"><span data-stu-id="6071b-145">One of the conditionals of having a programming model that supports both code and declarative usage is that properties must enable being set in any order.</span></span> <span data-ttu-id="6071b-146">Следовательно, все зависимые свойства необходимо настраивать в режиме JIT без контекста; при этом невозможно использовать какую-либо информацию о порядке настройки (которую можно найти, например, в конструкторе).</span><span class="sxs-lookup"><span data-stu-id="6071b-146">Thus any dependent properties need to be set just-in-time without context and cannot rely on knowing a setting order such as might be found in a constructor.</span></span> <span data-ttu-id="6071b-147">Дополнительные сведения об этом аспекте системы свойств см. в разделе [Проверка и обратные вызовы свойства зависимостей](dependency-property-callbacks-and-validation.md).</span><span class="sxs-lookup"><span data-stu-id="6071b-147">For more information on this aspect of the property system, see [Dependency Property Callbacks and Validation](dependency-property-callbacks-and-validation.md).</span></span> <span data-ttu-id="6071b-148">Обратите внимание, что обратные вызовы проверки не являются частью метаданных; они являются частью идентификатора свойства зависимости.</span><span class="sxs-lookup"><span data-stu-id="6071b-148">Note that validation callbacks are not part of the metadata; they are part of the dependency property identifier.</span></span> <span data-ttu-id="6071b-149">Следовательно, обратные вызовы проверки невозможно изменить путем переопределения метаданных.</span><span class="sxs-lookup"><span data-stu-id="6071b-149">Therefore, validation callbacks cannot be changed by overriding the metadata.</span></span>  
  
 <span data-ttu-id="6071b-150">В некоторых случаях целесообразно изменить параметры метаданных свойств уровня среды WPF для существующих свойств зависимости.</span><span class="sxs-lookup"><span data-stu-id="6071b-150">In some cases you might also want to alter the WPF framework-level property metadata options on existing dependency properties.</span></span> <span data-ttu-id="6071b-151">Эти параметры связывают некоторые известные условия свойств уровня среды WPF с другими процессами среды WPF, такими как система макетов.</span><span class="sxs-lookup"><span data-stu-id="6071b-151">These options communicate certain known conditionals about WPF framework-level properties to other WPF framework-level processes such as the layout system.</span></span>  <span data-ttu-id="6071b-152">Настройка опций обычно выполняется только при регистрации нового свойства зависимости, но также можно изменить метаданные <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> <xref:System.Windows.DependencyProperty.AddOwner%2A> свойства уровня WPF как часть вызова или вызова.</span><span class="sxs-lookup"><span data-stu-id="6071b-152">Setting the options is generally done only when registering a new dependency property, but it is also possible to change the WPF framework-level property metadata as part of a <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> or <xref:System.Windows.DependencyProperty.AddOwner%2A> call.</span></span> <span data-ttu-id="6071b-153">Дополнительные сведения и рекомендации по использованию конкретных значений см. в разделе [Метаданные свойств среды](framework-property-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="6071b-153">For the specific values to use and more information, see [Framework Property Metadata](framework-property-metadata.md).</span></span> <span data-ttu-id="6071b-154">Дополнительные сведения о том, как следует настраивать эти свойства для только что зарегистрированного свойства зависимости, см. в разделе [Пользовательские свойства зависимости](custom-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="6071b-154">For more information that is pertinent to how these options should be set for a newly registered dependency property, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
<a name="dp_override_metadata"></a>
### <a name="overriding-metadata"></a><span data-ttu-id="6071b-155">Переопределение метаданных</span><span class="sxs-lookup"><span data-stu-id="6071b-155">Overriding Metadata</span></span>  
 <span data-ttu-id="6071b-156">Основной целью переопределения метаданных является то, что у вас есть возможность изменить различные производные от метаданных характеристики, которые применяются к свойству зависимости в том виде, в котором оно существует в вашем типе.</span><span class="sxs-lookup"><span data-stu-id="6071b-156">The purpose of overriding metadata is primarily so that you have the opportunity to change the various metadata-derived behaviors that are applied to the dependency property as it exists on your type.</span></span> <span data-ttu-id="6071b-157">Причины этого рассматриваются более подробно в разделе [Метаданные](#dp_metadata_contents).</span><span class="sxs-lookup"><span data-stu-id="6071b-157">The reasons for this are explained in more detail in the [Metadata](#dp_metadata_contents) section.</span></span> <span data-ttu-id="6071b-158">Дополнительные сведения, включая примеры кода, см. в разделе [Переопределение метаданных для свойства зависимости](how-to-override-metadata-for-a-dependency-property.md).</span><span class="sxs-lookup"><span data-stu-id="6071b-158">For more information including some code examples, see [Override Metadata for a Dependency Property](how-to-override-metadata-for-a-dependency-property.md).</span></span>  
  
 <span data-ttu-id="6071b-159">Метаданные свойств могут быть предоставлены для собственности<xref:System.Windows.DependencyProperty.Register%2A>зависимости во время регистрационного звонка ().</span><span class="sxs-lookup"><span data-stu-id="6071b-159">Property metadata can be supplied for a dependency property during the registration call (<xref:System.Windows.DependencyProperty.Register%2A>).</span></span> <span data-ttu-id="6071b-160">Но во многих случаях целесообразно предоставить метаданные определенного типа для вашего класса, когда он наследует соответствующее свойство зависимости.</span><span class="sxs-lookup"><span data-stu-id="6071b-160">However, in many cases, you might want to provide type-specific metadata for your class when it inherits that dependency property.</span></span> <span data-ttu-id="6071b-161">Вы можете сделать <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> это, позвонив в метод.</span><span class="sxs-lookup"><span data-stu-id="6071b-161">You can do this by calling the <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method.</span></span>  <span data-ttu-id="6071b-162">Например, из [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.FrameworkElement> AI, класс — это тип, <xref:System.Windows.UIElement.Focusable%2A> который сначала регистрирует свойство зависимости.</span><span class="sxs-lookup"><span data-stu-id="6071b-162">For an example from the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] APIs, the <xref:System.Windows.FrameworkElement> class is the type that first registers the <xref:System.Windows.UIElement.Focusable%2A> dependency property.</span></span> <span data-ttu-id="6071b-163">Но <xref:System.Windows.Controls.Control> класс переопределяет метаданные для свойства зависимости, чтобы обеспечить `false` свое `true`собственное начальное значение <xref:System.Windows.UIElement.Focusable%2A> по умолчанию, изменяя его с к , и в противном случае повторно использует исходную реализацию.</span><span class="sxs-lookup"><span data-stu-id="6071b-163">But the <xref:System.Windows.Controls.Control> class overrides metadata for the dependency property to provide its own initial default value, changing it from `false` to `true`, and otherwise re-uses the original <xref:System.Windows.UIElement.Focusable%2A> implementation.</span></span>  
  
 <span data-ttu-id="6071b-164">При переопределении метаданных различные характеристики метаданных объединяются или заменяют друг друга.</span><span class="sxs-lookup"><span data-stu-id="6071b-164">When you override metadata, the different metadata characteristics are either merged or replaced.</span></span>  
  
- <span data-ttu-id="6071b-165"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>сливается.</span><span class="sxs-lookup"><span data-stu-id="6071b-165"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is merged.</span></span> <span data-ttu-id="6071b-166">Если вы добавите новый, <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>то обратный вызов хранится в метаданных.</span><span class="sxs-lookup"><span data-stu-id="6071b-166">If you add a new <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>, that callback is stored in the metadata.</span></span> <span data-ttu-id="6071b-167">Если вы не <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> указали в переопределении, значение повышается как ссылка от ближайшего <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> предка, который указал его в метаданных.</span><span class="sxs-lookup"><span data-stu-id="6071b-167">If you do not specify a <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is promoted as a reference from the nearest ancestor that specified it in metadata.</span></span>  
  
- <span data-ttu-id="6071b-168">Фактическое поведение системы свойств для <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> того, чтобы реализации для всех владельцев метаданных в иерархии сохранялись и добавлялись в таблицу, при этом порядок выполнения системой свойств в том, что наиболее полученные группы вызовов вызываются в первую очередь.</span><span class="sxs-lookup"><span data-stu-id="6071b-168">The actual property system behavior for <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is that implementations for all metadata owners in the hierarchy are retained and added to a table, with order of execution by the property system being that the most derived class's callbacks are invoked first.</span></span>  
  
- <span data-ttu-id="6071b-169"><xref:System.Windows.PropertyMetadata.DefaultValue%2A>заменяется.</span><span class="sxs-lookup"><span data-stu-id="6071b-169"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> is replaced.</span></span> <span data-ttu-id="6071b-170">Если вы не <xref:System.Windows.PropertyMetadata.DefaultValue%2A> укажете в переопределении, значение исходит от ближайшего <xref:System.Windows.PropertyMetadata.DefaultValue%2A> предка, который указал его в метаданных.</span><span class="sxs-lookup"><span data-stu-id="6071b-170">If you do not specify a <xref:System.Windows.PropertyMetadata.DefaultValue%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.DefaultValue%2A> comes from the nearest ancestor that specified it in metadata.</span></span>  
  
- <span data-ttu-id="6071b-171"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>реализации заменяются.</span><span class="sxs-lookup"><span data-stu-id="6071b-171"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implementations are replaced.</span></span> <span data-ttu-id="6071b-172">Если вы добавите новый, <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>то обратный вызов хранится в метаданных.</span><span class="sxs-lookup"><span data-stu-id="6071b-172">If you add a new <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>, that callback is stored in the metadata.</span></span> <span data-ttu-id="6071b-173">Если вы не <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> указали в переопределении, значение повышается как ссылка от ближайшего <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> предка, который указал его в метаданных.</span><span class="sxs-lookup"><span data-stu-id="6071b-173">If you do not specify a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is promoted as a reference from the nearest ancestor that specified it in metadata.</span></span>  
  
- <span data-ttu-id="6071b-174">Поведение системы свойств заключается в том, что вызывается только <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> в непосредственных метаданных.</span><span class="sxs-lookup"><span data-stu-id="6071b-174">The property system behavior is that only the <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> in the immediate metadata is invoked.</span></span> <span data-ttu-id="6071b-175">Ссылки на <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> другие реализации в иерархии не сохраняются.</span><span class="sxs-lookup"><span data-stu-id="6071b-175">No references to other <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implementations in the hierarchy are retained.</span></span>  
  
 <span data-ttu-id="6071b-176">Это поведение <xref:System.Windows.PropertyMetadata.Merge%2A>реализуется, и может быть переопределено на производных классах метаданных.</span><span class="sxs-lookup"><span data-stu-id="6071b-176">This behavior is implemented by <xref:System.Windows.PropertyMetadata.Merge%2A>, and can be overridden on derived metadata classes.</span></span>  
  
#### <a name="overriding-attached-property-metadata"></a><span data-ttu-id="6071b-177">Переопределение метаданных присоединенного свойства</span><span class="sxs-lookup"><span data-stu-id="6071b-177">Overriding Attached Property Metadata</span></span>  
 <span data-ttu-id="6071b-178">В [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] вложенные свойства реализованы как свойства зависимости.</span><span class="sxs-lookup"><span data-stu-id="6071b-178">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], attached properties are implemented as dependency properties.</span></span> <span data-ttu-id="6071b-179">Это означает, что они также имеют метаданные свойств, которые могут быть переопределены отдельными классами.</span><span class="sxs-lookup"><span data-stu-id="6071b-179">This means that they also have property metadata, which individual classes can override.</span></span> <span data-ttu-id="6071b-180">Рассмотрение для прикрепленного свойства, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] как правило, что <xref:System.Windows.DependencyObject> любой может иметь прикрепленное свойство, установленное на них.</span><span class="sxs-lookup"><span data-stu-id="6071b-180">The scoping considerations for an attached property in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] are generally that any <xref:System.Windows.DependencyObject> can have an attached property set on them.</span></span> <span data-ttu-id="6071b-181">Таким образом, любой <xref:System.Windows.DependencyObject> полученный класс может переопределить метаданные для любого прилагаемого свойства, так как они могут быть установлены на экземпляре класса.</span><span class="sxs-lookup"><span data-stu-id="6071b-181">Therefore, any <xref:System.Windows.DependencyObject> derived class can override the metadata for any attached property, as it might be set on an instance of the class.</span></span> <span data-ttu-id="6071b-182">Можно переопределить значения по умолчанию, обратные вызовы или свойства отчетности о характеристиках уровня среды WPF.</span><span class="sxs-lookup"><span data-stu-id="6071b-182">You can override default values, callbacks, or WPF framework-level characteristic-reporting properties.</span></span> <span data-ttu-id="6071b-183">Если вложенное свойство задано в экземпляре класса, действуют характеристики переопределенных метаданных свойства.</span><span class="sxs-lookup"><span data-stu-id="6071b-183">If the attached property is set on an instance of your class, those override property metadata characteristics apply.</span></span> <span data-ttu-id="6071b-184">Например, можно переопределить значение по умолчанию, чтобы переопределенное значение передавалось как значение вложенного свойства в экземплярах класса всякий раз, когда свойство не задано никаким другим способом.</span><span class="sxs-lookup"><span data-stu-id="6071b-184">For instance, you can override the default value, such that your override value is reported as the value of the attached property on instances of your class, whenever the property is not otherwise set.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="6071b-185">Свойство <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> не имеет значения для прилагаемых свойств.</span><span class="sxs-lookup"><span data-stu-id="6071b-185">The <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> property is not relevant for attached properties.</span></span>  
  
<a name="dp_add_owner"></a>
### <a name="adding-a-class-as-an-owner-of-an-existing-dependency-property"></a><span data-ttu-id="6071b-186">Добавление класса в качестве владельца существующего свойства зависимости</span><span class="sxs-lookup"><span data-stu-id="6071b-186">Adding a Class as an Owner of an Existing Dependency Property</span></span>  
 <span data-ttu-id="6071b-187">Класс может добавить себя в качестве владельца свойства зависимости, которое уже зарегистрировано, с помощью метода. <xref:System.Windows.DependencyProperty.AddOwner%2A></span><span class="sxs-lookup"><span data-stu-id="6071b-187">A class can add itself as an owner of a dependency property that has already been registered, by using the <xref:System.Windows.DependencyProperty.AddOwner%2A> method.</span></span> <span data-ttu-id="6071b-188">Это позволяет классу использовать свойство зависимости, первоначально зарегистрированное для другого типа.</span><span class="sxs-lookup"><span data-stu-id="6071b-188">This enables the class to use a dependency property that was originally registered for a different type.</span></span> <span data-ttu-id="6071b-189">Добавляемый класс, как правило, не является производным классом типа, который первым зарегистрировал это свойство зависимости в качестве владельца.</span><span class="sxs-lookup"><span data-stu-id="6071b-189">The adding class is typically not a derived class of the type that first registered that dependency property as owner.</span></span> <span data-ttu-id="6071b-190">Фактически это позволяет классу и его производным классам "наследовать" реализацию свойства зависимости, даже если исходный класс-владелец и добавляемый класс не находятся в одной действительной иерархии классов.</span><span class="sxs-lookup"><span data-stu-id="6071b-190">Effectively, this allows your class and its derived classes to "inherit" a dependency property implementation without the original owner class and the adding class being in the same true class hierarchy.</span></span> <span data-ttu-id="6071b-191">Кроме того, добавляемый класс (и все его наследуемые классы) могут затем предоставить метаданные определенного типа для исходного свойства зависимости.</span><span class="sxs-lookup"><span data-stu-id="6071b-191">In addition, the adding class (and all derived classes as well) can then provide type-specific metadata for the original dependency property.</span></span>  
  
 <span data-ttu-id="6071b-192">Помимо добавления себя в качестве владельца с использованием служебных методов системы свойств, добавляемый класс должен объявить в себе дополнительные открытые элементы, чтобы сделать свойство зависимости полноценным участником в системе свойств, которое доступно и коду, и разметке.</span><span class="sxs-lookup"><span data-stu-id="6071b-192">As well as adding itself as owner through the property system utility methods, the adding class should declare additional public members on itself in order to make the dependency property] a full participant in the property system with exposure to both code and markup.</span></span> <span data-ttu-id="6071b-193">Класс, который добавляет существующее свойство зависимости, имеет те же обязанности по предоставлению объектной модели для свойства зависимости, что и класс, определяющий новое пользовательское свойство зависимости.</span><span class="sxs-lookup"><span data-stu-id="6071b-193">A class that adds an existing dependency property has the same responsibilities as far as exposing the object model for that dependency property as does a class that defines a new custom dependency property.</span></span> <span data-ttu-id="6071b-194">Первый такой предоставляемый элемент — поле идентификатора свойства зависимости.</span><span class="sxs-lookup"><span data-stu-id="6071b-194">The first such member to expose is a dependency property identifier field.</span></span> <span data-ttu-id="6071b-195">Это поле должно `public static readonly` быть <xref:System.Windows.DependencyProperty>полем типа, которое присваивается значению возврата <xref:System.Windows.DependencyProperty.AddOwner%2A> вызова.</span><span class="sxs-lookup"><span data-stu-id="6071b-195">This field should be a `public static readonly` field of type <xref:System.Windows.DependencyProperty>, which is assigned to the return value of the <xref:System.Windows.DependencyProperty.AddOwner%2A> call.</span></span> <span data-ttu-id="6071b-196">Вторым участником, определяющим, является свойство "обертки" общего языка (CLR).</span><span class="sxs-lookup"><span data-stu-id="6071b-196">The second member to define is the common language runtime (CLR) "wrapper" property.</span></span> <span data-ttu-id="6071b-197">Обертка делает его гораздо более удобным для манипулирования вашей <xref:System.Windows.DependencyObject.SetValue%2A> зависимости собственности в коде (вы избежать звонков каждый раз, и может сделать этот звонок только один раз в обертке себя).</span><span class="sxs-lookup"><span data-stu-id="6071b-197">The wrapper makes it much more convenient to manipulate your dependency property in code (you avoid calls to <xref:System.Windows.DependencyObject.SetValue%2A> each time, and can make that call only once in the wrapper itself).</span></span> <span data-ttu-id="6071b-198">Оболочка реализуется так же, как если бы регистрировалось пользовательское свойство зависимости.</span><span class="sxs-lookup"><span data-stu-id="6071b-198">The wrapper is implemented identically to how it would be implemented if you were registering a custom dependency property.</span></span> <span data-ttu-id="6071b-199">Дополнительные сведения о реализации свойства зависимости см. в разделе [Пользовательские свойства взаимозависимости](custom-dependency-properties.md) и [Добавление типа владельца для свойства зависимостей](how-to-add-an-owner-type-for-a-dependency-property.md).</span><span class="sxs-lookup"><span data-stu-id="6071b-199">For more information about implementing a dependency property, see [Custom Dependency Properties](custom-dependency-properties.md) and [Add an Owner Type for a Dependency Property](how-to-add-an-owner-type-for-a-dependency-property.md).</span></span>  
  
#### <a name="addowner-and-attached-properties"></a><span data-ttu-id="6071b-200">AddOwner и вложенные свойства</span><span class="sxs-lookup"><span data-stu-id="6071b-200">AddOwner and Attached Properties</span></span>  
 <span data-ttu-id="6071b-201">Можно вызвать <xref:System.Windows.DependencyProperty.AddOwner%2A> свойство зависимости, которое определяется как прилагаемое свойство классом владельца.</span><span class="sxs-lookup"><span data-stu-id="6071b-201">You can call <xref:System.Windows.DependencyProperty.AddOwner%2A> for a dependency property that is defined as an attached property by the owner class.</span></span> <span data-ttu-id="6071b-202">Обычно так делают, чтобы предоставить ранее вложенное свойство в качестве невложенного свойства зависимости.</span><span class="sxs-lookup"><span data-stu-id="6071b-202">Generally the reason for doing this is to expose the previously attached property as a non-attached dependency property.</span></span> <span data-ttu-id="6071b-203">Затем вы обнажаете значение <xref:System.Windows.DependencyProperty.AddOwner%2A> возврата в качестве `public static readonly` поля для использования в качестве идентификатора свойств зависимости и определите соответствующие свойства "обертки", чтобы свойство отослало в таблице членов и поддерживало неприлагаемое использование свойств в вашем классе.</span><span class="sxs-lookup"><span data-stu-id="6071b-203">You then will expose the <xref:System.Windows.DependencyProperty.AddOwner%2A> return value as a `public static readonly` field for use as the dependency property identifier, and will define appropriate "wrapper" properties so that the property appears in the members table and supports a non-attached property usage in your class.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6071b-204">См. также раздел</span><span class="sxs-lookup"><span data-stu-id="6071b-204">See also</span></span>

- <xref:System.Windows.PropertyMetadata>
- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- <xref:System.Windows.DependencyProperty.GetMetadata%2A>
- [<span data-ttu-id="6071b-205">Общие сведения о свойствах зависимости</span><span class="sxs-lookup"><span data-stu-id="6071b-205">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="6071b-206">Метаданные свойств среды</span><span class="sxs-lookup"><span data-stu-id="6071b-206">Framework Property Metadata</span></span>](framework-property-metadata.md)
