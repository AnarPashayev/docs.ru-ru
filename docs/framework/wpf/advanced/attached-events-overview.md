---
title: Общие сведения о вложенных событиях
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- handling attached events [WPF]
- defining attached events as routed events [WPF]
- attached events [WPF], scenarios for
- attached events vs. routed events [WPF]
- backing attached events with routed events [WPF]
- attached events [WPF], definition
ms.assetid: 2c40eae3-80e4-4a45-ae09-df6c9ab4d91e
ms.openlocfilehash: 76ff60cfe26f9105d4504164802987115fc2a7e2
ms.sourcegitcommit: 944ddc52b7f2632f30c668815f92b378efd38eea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/03/2019
ms.locfileid: "73455472"
---
# <a name="attached-events-overview"></a>Общие сведения о вложенных событиях

XAML (XAML) определяет компонент языка и тип события, называемого *вложенным событием*. Концепция присоединенного события позволяет добавить обработчик для конкретного события в произвольный элемент, а не в элемент, который фактически определяет или наследует событие. В этом случае ни объект, потенциально вызывающий событие, ни конечный обрабатывающий экземпляр не определяет или иным образом не "владеет" событием.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Необходимые компоненты  
 Предполагается, что вы ознакомились с разделами [Общие сведения о перенаправленных событиях](routed-events-overview.md) и [Обзор XAML (WPF)](../../../desktop-wpf/fundamentals/xaml.md).  
  
<a name="Syntax"></a>   
## <a name="attached-event-syntax"></a>Синтаксис присоединенных событий  
 Вложенные события имеют синтаксис XAML и шаблон кодирования, который должен использоваться резервным кодом для поддержки использования вложенного события.  
  
 В синтаксисе XAML вложенное событие указывается не только именем события, но и типом его владельца и именем события, разделенными точкой (.). Так как имя события квалифицируется с помощью имени типа, которому оно принадлежит, синтаксис присоединенных событий позволяет подключить любое присоединенное событие к любому элементу, для которого может быть создан экземпляр.  
  
 Например, ниже приведен синтаксис XAML для присоединения обработчика для пользовательского `NeedsCleaning` присоединенного события:  
  
 [!code-xaml[WPFAquariumSln#AE](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquarium/Window1.xaml#ae)]  
  
 Обратите внимание на префикс `aqua:`. Префикс необходим в этом случае, поскольку присоединенное событие является пользовательским событием, которое поступает из пользовательского сопоставленного xmlns.  
  
<a name="WPFImplements"></a>   
## <a name="how-wpf-implements-attached-events"></a>Реализация присоединенных событий в WPF

В WPF вложенные события поддерживаются полем <xref:System.Windows.RoutedEvent> и направляются через дерево после их возникновения. Как правило, источником присоединенного события (объектом, вызывающим событие) является система или служба, и таким образом, объект, который выполняет код, порождающий это событие, не является непосредственной частью дерева элементов.  
  
<a name="Scenarios"></a>   
## <a name="scenarios-for-attached-events"></a>Сценарии для присоединенных событий  
 В WPF вложенные события присутствуют в определенных функциональных областях, где существует абстракция уровня службы, например для событий, включенных статическим классом <xref:System.Windows.Input.Mouse> или классом <xref:System.Windows.Controls.Validation>. Классы, которые взаимодействуют со службой или используют ее, могут использовать событие в синтаксисе присоединенных событий или предоставить присоединенное событие как перенаправленное событие, которое является частью процесса интеграции возможностей службы классом.  
  
 Хотя WPF определяет ряд вложенных событий, сценарии, в которых вы будете использовать или напрямую управлять присоединенным событием, очень ограничены. Как правило, присоединенное событие служит целью архитектуры, но затем перенаправляется в неприсоединенное (с помощью оболочки события CLR) перенаправленное событие.  
  
 Например, базовое присоединенное событие <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> может быть проще обработано на любом заданном <xref:System.Windows.UIElement> с помощью <xref:System.Windows.UIElement.MouseDown> на этом <xref:System.Windows.UIElement> вместо использования синтаксиса вложенных событий в XAML или коде. Присоединенное событие выполняет определенную роль в архитектуре, поскольку оно обеспечивает будущее расширение типов устройств ввода. Гипотетическому устройству пришлось бы порождать только <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> для имитации ввода с помощью мыши, и для этого не потребуется наследовать от <xref:System.Windows.Input.Mouse>. Однако этот сценарий включает обработку кода событий, и обработка XAML присоединенного события не относится к этому сценарию.  
  
<a name="Handling"></a>   
## <a name="handling-an-attached-event-in-wpf"></a>Обработка присоединенного события в WPF  
 Процесс для обработки присоединенного события и код обработчика, который вы будете писать, по сути аналогичны перенаправленному событию.  
  
 Как правило, вложенное событие WPF не сильно отличается от перенаправленного события WPF. Различия в том, как источник события и как он предоставляется классом в качестве члена (который также влияет на синтаксис обработчика XAML).  
  
 Однако, как отмечалось ранее, существующие подключенные события WPF не предназначены специально для обработки в WPF. Гораздо чаще целью событий является включение составного элемента для передачи состояния в родительский элемент при компоновке. В этом случае событие обычно вызывается в коде и зависит от обработки класса в соответствующем родительском классе. Например, элементы в <xref:System.Windows.Controls.Primitives.Selector> должны вызывать событие присоединенного <xref:System.Windows.Controls.Primitives.Selector.Selected>, которое затем обрабатывается классом <xref:System.Windows.Controls.Primitives.Selector>, а затем может быть преобразовано классом <xref:System.Windows.Controls.Primitives.Selector> в другое перенаправленное событие <xref:System.Windows.Controls.Primitives.Selector.SelectionChanged>. Дополнительные сведения о перенаправленных событиях и обработке классов см. в разделе [Маркировка перенаправленных событий как обработанных и обработка классов](marking-routed-events-as-handled-and-class-handling.md).  
  
<a name="Custom"></a>   
## <a name="defining-your-own-attached-events-as-routed-events"></a>Определение собственных присоединенных событий как перенаправленных событий  
 Если вы наследуете от общих базовых классов WPF, вы можете реализовать собственные вложенные события, включив определенные методы шаблона в класс и используя служебные методы, которые уже имеются в базовых классах.  
  
 Шаблон выглядит следующим образом.  
  
- Метод __добавляет обработчик*EventName*__ с двумя параметрами. Первый параметр — это экземпляр, в который добавляется обработчик событий. Второй параметр — это добавляемый обработчик событий. Метод должен быть `public` и `static`без возвращаемого значения.  
  
- Метод __удаляет обработчик*EventName*__ с двумя параметрами. Первый параметр — это экземпляр, из которого удаляется обработчик событий. Второй параметр — это обработчик событий, который необходимо удалить. Метод должен быть `public` и `static`без возвращаемого значения.  
  
 Метод доступа __Add*ИмяСобытия*Handler__ упрощает обработку XAML при объявлении атрибутов обработчика вложенных событий в элементе. Методы обработчика __Add*EventName*__ и __Remove*EventName*__ также обеспечивают доступ кода к хранилищу обработчиков событий для присоединенного события.  
  
 Этот общий шаблон еще не достаточен для практической реализации в платформе, так как любая заданная реализация средства чтения XAML может иметь различные схемы для идентификации базовых событий в поддерживающем языке и архитектуре. Это одна из причин, по которой в WPF реализуются вложенные события как перенаправляемые события; Идентификатор, используемый для события (<xref:System.Windows.RoutedEvent>), уже определен системой событий WPF. Кроме того, маршрутизация события является естественным расширением реализации в концепции уровня языка XAML присоединенного события.  
  
 Реализация __обработчика типа "Add*EventName*__ " для присоединенного события WPF состоит из вызова <xref:System.Windows.UIElement.AddHandler%2A> с перенаправленным событием и обработчиком в качестве аргументов.  
  
 Эта стратегия реализации и система перенаправленных событий в целом ограничивают обработку присоединенных событий как <xref:System.Windows.UIElement> производных классов, так и <xref:System.Windows.ContentElement> производных классов, так как только эти классы имеют <xref:System.Windows.UIElement.AddHandler%2A> реализации.  
  
 Например, следующий код определяет `NeedsCleaning` присоединенное событие для класса Owner `Aquarium`, используя стратегию вложенных событий WPF для объявления присоединенного события в виде перенаправленного события.  
  
 [!code-csharp[WPFAquariumSln#AECode](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#aecode)]
 [!code-vb[WPFAquariumSln#AECode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#aecode)]  
  
 Обратите внимание, что метод, используемый для определения поля идентификатора присоединенного события, <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>, фактически является тем же методом, который используется для регистрации неприсоединенного перенаправленного события. Все присоединенные события и перенаправленные события регистрируются в централизованном внутреннем хранилище. Эта реализация хранилища событий обеспечивает поддержку режима "события в качестве интерфейса", который рассматривается в разделе [Общие сведения о перенаправленных событиях](routed-events-overview.md).  
  
<a name="Raising"></a>   
## <a name="raising-a-wpf-attached-event"></a>Вызов присоединенного события WPF  
 Обычно не требуется вызывать существующие присоединенные события, определенные в WPF, из кода. Эти события следуют общей концептуальной модели службы, а классы служб, такие как <xref:System.Windows.Input.InputManager>, отвечают за создание событий.  
  
 Однако при определении пользовательского присоединенного события на основе модели WPF для создания присоединенных событий на <xref:System.Windows.RoutedEvent>можно использовать <xref:System.Windows.UIElement.RaiseEvent%2A> для вызова присоединенного события из любого <xref:System.Windows.UIElement> или <xref:System.Windows.ContentElement>. Для вызова перенаправленного события (присоединенного или нет) требуется объявить конкретный элемент в дереве элементов в качестве источника события. Этот источник выводится как <xref:System.Windows.UIElement.RaiseEvent%2A> вызывающий объект. За определение того, какой элемент передается как источник в дереве, отвечает служба.  
  
## <a name="see-also"></a>См. также

- [Общие сведения о перенаправленных событиях](routed-events-overview.md)
- [Подробное описание синтаксиса XAML](xaml-syntax-in-detail.md)
- [Код XAML и пользовательские классы для WPF](xaml-and-custom-classes-for-wpf.md)
