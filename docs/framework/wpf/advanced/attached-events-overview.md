---
title: Общие сведения о вложенных событиях
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- handling attached events [WPF]
- defining attached events as routed events [WPF]
- attached events [WPF], scenarios for
- attached events vs. routed events [WPF]
- backing attached events with routed events [WPF]
- attached events [WPF], definition
ms.assetid: 2c40eae3-80e4-4a45-ae09-df6c9ab4d91e
ms.openlocfilehash: 40e7bd34388bec06cd8a7c3610599d814aef101f
ms.sourcegitcommit: cf9515122fce716bcfb6618ba366e39b5a2eb81e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/15/2019
ms.locfileid: "69038159"
---
# <a name="attached-events-overview"></a>Общие сведения о вложенных событиях

XAML (XAML) определяет компонент языка и тип события, называемого *вложенным событием*. Концепция присоединенного события позволяет добавить обработчик для конкретного события в произвольный элемент, а не в элемент, который фактически определяет или наследует событие. В этом случае ни объект, потенциально вызывающий событие, ни конечный обрабатывающий экземпляр не определяет или иным образом не "владеет" событием.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Предварительные требования  
 Предполагается, что вы ознакомились с разделами [Общие сведения о перенаправленных событиях](routed-events-overview.md) и [Обзор XAML (WPF)](xaml-overview-wpf.md).  
  
<a name="Syntax"></a>   
## <a name="attached-event-syntax"></a>Синтаксис присоединенных событий  
 Вложенные события имеют синтаксис XAML и шаблон кодирования, который должен использоваться резервным кодом для поддержки использования вложенного события.  
  
 В синтаксисе XAML вложенное событие указывается не только именем события, но и типом его владельца и именем события, разделенными точкой (.). Так как имя события квалифицируется с помощью имени типа, которому оно принадлежит, синтаксис присоединенных событий позволяет подключить любое присоединенное событие к любому элементу, для которого может быть создан экземпляр.  
  
 Например, ниже приведен синтаксис XAML для присоединения обработчика для пользовательского `NeedsCleaning` присоединенного события:  
  
 [!code-xaml[WPFAquariumSln#AE](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquarium/Window1.xaml#ae)]  
  
 Обратите внимание на префикс `aqua:`. Префикс необходим в этом случае, поскольку присоединенное событие является пользовательским событием, которое поступает из пользовательского сопоставленного xmlns.  
  
<a name="WPFImplements"></a>   
## <a name="how-wpf-implements-attached-events"></a>Реализация присоединенных событий в WPF

В WPF вложенные события поддерживаются <xref:System.Windows.RoutedEvent> полем и направляются через дерево после их возникновения. Как правило, источником присоединенного события (объектом, вызывающим событие) является система или служба, и таким образом, объект, который выполняет код, порождающий это событие, не является непосредственной частью дерева элементов.  
  
<a name="Scenarios"></a>   
## <a name="scenarios-for-attached-events"></a>Сценарии для присоединенных событий  
 В WPF вложенные события присутствуют в определенных функциональных областях, где существует абстракция уровня службы, например для событий, включенных статическим <xref:System.Windows.Input.Mouse> классом <xref:System.Windows.Controls.Validation> или классом. Классы, которые взаимодействуют со службой или используют ее, могут использовать событие в синтаксисе присоединенных событий или предоставить присоединенное событие как перенаправленное событие, которое является частью процесса интеграции возможностей службы классом.  
  
 Хотя WPF определяет ряд вложенных событий, сценарии, в которых вы будете использовать или напрямую управлять присоединенным событием, очень ограничены. Как правило, присоединенное событие служит целью архитектуры, но затем перенаправляется в неприсоединенное (с помощью оболочки события CLR) перенаправленное событие.  
  
 Например, базовое присоединенное событие <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> может быть проще обработано в любой <xref:System.Windows.UIElement> заданном <xref:System.Windows.UIElement.MouseDown> с помощью <xref:System.Windows.UIElement> , вместо того чтобы обрабатываться с синтаксисом вложенных событий в XAML или коде. Присоединенное событие выполняет определенную роль в архитектуре, поскольку оно обеспечивает будущее расширение типов устройств ввода. Гипотетическому устройству пришлось бы вызывать <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> только для имитации ввода с <xref:System.Windows.Input.Mouse> помощью мыши, а не для этого. Однако этот сценарий включает обработку кода событий, и обработка XAML присоединенного события не относится к этому сценарию.  
  
<a name="Handling"></a>   
## <a name="handling-an-attached-event-in-wpf"></a>Обработка присоединенного события в WPF  
 Процесс для обработки присоединенного события и код обработчика, который вы будете писать, по сути аналогичны перенаправленному событию.  
  
 Как правило, вложенное событие WPF не сильно отличается от перенаправленного события WPF. Различия в том, как источник события и как он предоставляется классом в качестве члена (который также влияет на синтаксис обработчика XAML).  
  
 Однако, как отмечалось ранее, существующие подключенные события WPF не предназначены специально для обработки в WPF. Гораздо чаще целью событий является включение составного элемента для передачи состояния в родительский элемент при компоновке. В этом случае событие обычно вызывается в коде и зависит от обработки класса в соответствующем родительском классе. Например, элементы <xref:System.Windows.Controls.Primitives.Selector> внутри a должны вызывать вложенное <xref:System.Windows.Controls.Primitives.Selector.Selected> событие, которое <xref:System.Windows.Controls.Primitives.Selector> затем обрабатывается классом и может быть преобразовано <xref:System.Windows.Controls.Primitives.Selector> классом в другое перенаправленное событие <xref:System.Windows.Controls.Primitives.Selector.SelectionChanged> . . Дополнительные сведения о перенаправленных событиях и обработке классов см. в разделе [Маркировка перенаправленных событий как обработанных и обработка классов](marking-routed-events-as-handled-and-class-handling.md).  
  
<a name="Custom"></a>   
## <a name="defining-your-own-attached-events-as-routed-events"></a>Определение собственных присоединенных событий как перенаправленных событий  
 Если вы наследуете от общих базовых классов WPF, вы можете реализовать собственные вложенные события, включив определенные методы шаблона в класс и используя служебные методы, которые уже имеются в базовых классах.  
  
 Шаблон выглядит следующим образом.  
  
- Метод __добавляет обработчик*EventName*__ с двумя параметрами. Первый параметр — это экземпляр, в который добавляется обработчик событий. Второй параметр — это добавляемый обработчик событий. Метод должен иметь `public` значение и `static`, без возвращаемого значения.  
  
- Метод __удаляет обработчик*EventName*__ с двумя параметрами. Первый параметр — это экземпляр, из которого удаляется обработчик событий. Второй параметр — это обработчик событий, который необходимо удалить. Метод должен иметь `public` значение и `static`, без возвращаемого значения.  
  
 Метод доступа __Add*ИмяСобытия*Handler__ упрощает обработку XAML при объявлении атрибутов обработчика вложенных событий в элементе. Методы обработчика __Add*EventName*__ и Remove __*EventName*__ также обеспечивают доступ кода к хранилищу обработчиков событий для присоединенного события.  
  
 Этот общий шаблон еще не достаточен для практической реализации в платформе, так как любая заданная реализация средства чтения XAML может иметь различные схемы для идентификации базовых событий в поддерживающем языке и архитектуре. Это одна из причин, по которой в WPF реализуются вложенные события как перенаправляемые события; Идентификатор, используемый для события (<xref:System.Windows.RoutedEvent>), уже определен системой событий WPF. Кроме того, маршрутизация события является естественным расширением реализации в концепции уровня языка XAML присоединенного события.  
  
 Реализация __обработчика "Add*EventName*__ " для присоединенного события WPF состоит <xref:System.Windows.UIElement.AddHandler%2A> из вызова метода с перенаправленным событием и обработчиком в качестве аргументов.  
  
 Эта стратегия реализации и система перенаправленных событий в целом ограничивают обработку присоединенных событий <xref:System.Windows.UIElement> производными классами или <xref:System.Windows.ContentElement> производными классами, так как <xref:System.Windows.UIElement.AddHandler%2A> только эти классы имеют реализации.  
  
 Например, следующий код определяет `NeedsCleaning` присоединенное событие для класса `Aquarium`Owner, используя стратегию вложенных событий WPF объявления присоединенного события в виде перенаправленного события.  
  
 [!code-csharp[WPFAquariumSln#AECode](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#aecode)]
 [!code-vb[WPFAquariumSln#AECode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#aecode)]  
  
 Обратите внимание, что метод, используемый для установления поля идентификатора <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>присоединенного события, фактически является тем же методом, который используется для регистрации неприсоединенного перенаправленного события. Все присоединенные события и перенаправленные события регистрируются в централизованном внутреннем хранилище. Эта реализация хранилища событий обеспечивает поддержку режима "события в качестве интерфейса", который рассматривается в разделе [Общие сведения о перенаправленных событиях](routed-events-overview.md).  
  
<a name="Raising"></a>   
## <a name="raising-a-wpf-attached-event"></a>Вызов присоединенного события WPF  
 Обычно не требуется вызывать существующие присоединенные события, определенные в WPF, из кода. Эти события следуют общей концептуальной модели службы, а классы служб, такие как <xref:System.Windows.Input.InputManager> , отвечают за создание событий.  
  
 Однако при определении пользовательского присоединенного события, основанного на модели WPF для создания присоединенных событий <xref:System.Windows.RoutedEvent>на основе, можно использовать <xref:System.Windows.UIElement.RaiseEvent%2A> для вызова вложенного события из любого <xref:System.Windows.UIElement> или <xref:System.Windows.ContentElement>. Для вызова перенаправленного события (присоединенного или нет) требуется объявить конкретный элемент в дереве элементов в качестве источника события. Этот источник сообщается в <xref:System.Windows.UIElement.RaiseEvent%2A> качестве вызывающего. За определение того, какой элемент передается как источник в дереве, отвечает служба.  
  
## <a name="see-also"></a>См. также

- [Общие сведения о перенаправленных событиях](routed-events-overview.md)
- [Подробное описание синтаксиса XAML](xaml-syntax-in-detail.md)
- [Код XAML и пользовательские классы для WPF](xaml-and-custom-classes-for-wpf.md)
