---
title: Свойства зависимости "только для чтения"
ms.date: 03/30/2017
helpviewer_keywords:
- dependency properties [WPF], read-only
- read-only dependency properties [WPF]
ms.assetid: f23d6ec9-3780-4c09-a2ff-b2f0a2deddf1
ms.openlocfilehash: a849b835bab832a4ddb8d594d1788ab062f4284e
ms.sourcegitcommit: 944ddc52b7f2632f30c668815f92b378efd38eea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/03/2019
ms.locfileid: "73459003"
---
# <a name="read-only-dependency-properties"></a>Свойства зависимости "только для чтения"
В этом разделе описываются свойства зависимостей "только для чтения", включая существующие свойства зависимостей "только для чтения", а также сценарии и методы создания настраиваемого свойства зависимостей "только для чтения".  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Необходимые компоненты  
 В этом разделе предполагается, что вы понимаете основные сценарии реализации свойства зависимостей и способы применения метаданных к настраиваемому свойству зависимостей. Дополнительные сведения см. в разделах [Пользовательские свойства зависимостей](custom-dependency-properties.md) и [Метаданные свойства зависимостей](dependency-property-metadata.md).  
  
<a name="existing"></a>   
## <a name="existing-read-only-dependency-properties"></a>Существующие свойства зависимостей "только для чтения"  
 Некоторые свойства зависимостей, определенные в среде [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], доступны только для чтения. Типичной причиной для указания свойства зависимости "только для чтения" является то, что это свойства, которые должны использоваться для определения состояния там, где это состояние зависит от множества факторов, но простая настройка этого состояния для данного свойства нежелательна с точки зрения дизайна пользовательского интерфейса. Например, свойство <xref:System.Windows.UIElement.IsMouseOver%2A> действительно просто состояние отображая, как определено на основе ввода с помощью мыши. Любая попытка установить это значение программно путем обхода истинного ввода с помощью мыши будет непредсказуемой и вызовет несогласованность.  
  
 Поскольку свойства зависимостей "только для чтения" нельзя устанавливать, они не подходят для многих сценариев, для которых свойства зависимостей обычно предлагают решение (а именно: привязка данных с возможностью прямого использования стилей для значения, проверки, анимации, наследования). Несмотря на то что их нельзя устанавливать, свойства зависимостей "только для чтения" обладают некоторыми дополнительными возможностями, которые поддерживаются свойствами зависимостей в системе свойств. Наиболее важной оставшейся возможностью является то, что свойство зависимости "только для чтения" по-прежнему можно использовать как триггер свойств в стиле. Триггеры нельзя включить с обычным свойством среды CLR. оно должно быть свойством зависимостей. Упомянутое выше свойство <xref:System.Windows.UIElement.IsMouseOver%2A> является идеальным примером сценария, где может быть весьма полезно определить стиль для элемента управления, где некоторое видимое свойство, такое как фон, передний план или аналогичные свойства составных элементов в элементе управления, будет изменяются, когда пользователь наводит указатель мыши на определенную область элемента управления. Изменения в свойстве зависимостей "только для чтения" также могут обнаруживаться и сообщаться внутренними процессами определения недействительности в системе свойств. Фактически, это внутренняя поддержка функциональности триггера свойств.  
  
<a name="new"></a>   
## <a name="creating-custom-read-only-dependency-properties"></a>Создание пользовательских свойств зависимостей "только для чтения"  
 Обязательно ознакомьтесь с вышеприведенным разделом, описывающим, почему свойства зависимостей "только для чтения" не будут работать для многих типичных сценариев свойств зависимостей. Однако при наличии соответствующего сценария можно создать собственное свойство зависимостей "только для чтения".  
  
 Большая часть процесса создания свойства зависимостей "только для чтения" аналогична описанному в разделах [Пользовательские свойства зависимостей](custom-dependency-properties.md) и [Реализация свойства зависимостей](how-to-implement-a-dependency-property.md). Однако есть три важных отличия.  
  
- При регистрации свойства вызовите метод <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> вместо обычного метода <xref:System.Windows.DependencyProperty.Register%2A> для регистрации свойства.  
  
- При реализации свойства "оболочка CLR" убедитесь, что оболочка не имеет реализации набора, так что не существует несогласованности в состоянии только для чтения для предоставляемой общедоступной обертки.  
  
- Объект, возвращаемый регистрацией только для чтения, <xref:System.Windows.DependencyPropertyKey>, а не <xref:System.Windows.DependencyProperty>. Необходимо сохранить это поле в качестве члена, но обычно не нужно его делать общим членом для типа.  
  
 Любое частное поле или значение, заложенное в свойство зависимостей "только для чтения", может быть полностью записываемым с помощью любой выбранной логики. Однако самый простой способ установить свойство изначально или как часть логики среды выполнения — использовать API системы свойств вместо того, чтобы обойти систему свойств и задать частное резервное поле напрямую. В частности, существует сигнатура <xref:System.Windows.DependencyObject.SetValue%2A>, принимающая параметр типа <xref:System.Windows.DependencyPropertyKey>. Как и где вы задаете это значение программным способом в логике приложения, вы повлияете на то, как можно задать доступ на <xref:System.Windows.DependencyPropertyKey>, созданном при первой регистрации свойства зависимостей. Если обрабатывать эту логику внутри класса, то можно сделать ее частной. Если необходимо устанавливать ее из других частей сборки, можно сделать ее внутренней. Один из подходов заключается в вызове <xref:System.Windows.DependencyObject.SetValue%2A> в обработчике событий класса соответствующего события, которое информирует экземпляр класса о необходимости изменения значения хранимого свойства. Другой подход заключается в том, чтобы связать свойства зависимостей друг с другом, используя парные <xref:System.Windows.PropertyChangedCallback> и <xref:System.Windows.CoerceValueCallback> обратные вызовы в рамках метаданных этих свойств во время регистрации.  
  
 Поскольку <xref:System.Windows.DependencyPropertyKey> является частным и не распространяется системой свойств за пределы вашего кода, свойство зависимости только для чтения имеет лучшую безопасность, чем свойство зависимостей для чтения и записи. Для свойства зависимостей с возможностью чтения и записи идентифицирующее поле является явно или неявно общим, и таким образом, свойство является широко устанавливаемым. Дополнительные сведения см. в разделе [Безопасность свойства зависимостей](dependency-property-security.md).  
  
## <a name="see-also"></a>См. также

- [Общие сведения о свойствах зависимости](dependency-properties-overview.md)
- [Пользовательские свойства зависимостей](custom-dependency-properties.md)
- [Стилизация и использование шаблонов](../../../desktop-wpf/fundamentals/styles-templates-overview.md)
