---
title: Свойства зависимости "только для чтения"
ms.date: 03/30/2017
helpviewer_keywords:
- dependency properties [WPF], read-only
- read-only dependency properties [WPF]
ms.assetid: f23d6ec9-3780-4c09-a2ff-b2f0a2deddf1
ms.openlocfilehash: 8adc90182f0f42f52e6ace4e13c68acb3539516b
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79187183"
---
# <a name="read-only-dependency-properties"></a>Свойства зависимости "только для чтения"
В этом разделе описываются свойства зависимостей "только для чтения", включая существующие свойства зависимостей "только для чтения", а также сценарии и методы создания настраиваемого свойства зависимостей "только для чтения".  

<a name="prerequisites"></a>
## <a name="prerequisites"></a>Предварительные требования  
 В этом разделе предполагается, что вы понимаете основные сценарии реализации свойства зависимостей и способы применения метаданных к настраиваемому свойству зависимостей. Дополнительные сведения см. в разделах [Пользовательские свойства зависимостей](custom-dependency-properties.md) и [Метаданные свойства зависимостей](dependency-property-metadata.md).  
  
<a name="existing"></a>
## <a name="existing-read-only-dependency-properties"></a>Существующие свойства зависимостей "только для чтения"  
 Некоторые свойства зависимостей, определенные в среде [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], доступны только для чтения. Типичной причиной для указания свойства зависимости "только для чтения" является то, что это свойства, которые должны использоваться для определения состояния там, где это состояние зависит от множества факторов, но простая настройка этого состояния для данного свойства нежелательна с точки зрения дизайна пользовательского интерфейса. Например, свойство <xref:System.Windows.UIElement.IsMouseOver%2A> на самом деле просто состояние наплавки, как это определено из ввода мыши. Любая попытка установить это значение программно путем обхода истинного ввода с помощью мыши будет непредсказуемой и вызовет несогласованность.  
  
 Поскольку свойства зависимостей "только для чтения" нельзя устанавливать, они не подходят для многих сценариев, для которых свойства зависимостей обычно предлагают решение (а именно: привязка данных с возможностью прямого использования стилей для значения, проверки, анимации, наследования). Несмотря на то что их нельзя устанавливать, свойства зависимостей "только для чтения" обладают некоторыми дополнительными возможностями, которые поддерживаются свойствами зависимостей в системе свойств. Наиболее важной оставшейся возможностью является то, что свойство зависимости "только для чтения" по-прежнему можно использовать как триггер свойств в стиле. Вы не можете включить триггеры с обычным свойством общего языка времени выполнения (CLR); она должна быть свойством зависимости. Вышеупомянутое <xref:System.Windows.UIElement.IsMouseOver%2A> свойство является прекрасным примером сценария, в котором может быть весьма полезно определить стиль управления, где некоторые видимые свойства, такие как фон, передний план или аналогичные свойства композитных элементов в элементе управления, будут меняться, когда пользователь помещает мышь над определенной областью вашего управления. Изменения в свойстве зависимостей "только для чтения" также могут обнаруживаться и сообщаться внутренними процессами определения недействительности в системе свойств. Фактически, это внутренняя поддержка функциональности триггера свойств.  
  
<a name="new"></a>
## <a name="creating-custom-read-only-dependency-properties"></a>Создание пользовательских свойств зависимостей "только для чтения"  
 Обязательно ознакомьтесь с вышеприведенным разделом, описывающим, почему свойства зависимостей "только для чтения" не будут работать для многих типичных сценариев свойств зависимостей. Однако при наличии соответствующего сценария можно создать собственное свойство зависимостей "только для чтения".  
  
 Большая часть процесса создания свойства зависимостей "только для чтения" аналогична описанному в разделах [Пользовательские свойства зависимостей](custom-dependency-properties.md) и [Реализация свойства зависимостей](how-to-implement-a-dependency-property.md). Однако есть три важных отличия.  
  
- При регистрации недвижимости, <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> позвоните метод <xref:System.Windows.DependencyProperty.Register%2A> вместо обычного метода для регистрации собственности.  
  
- При реализации свойства "обертка" CLR убедитесь, что обертка тоже не имеет набора реализации, так что нет несоответствия в состоянии чтения только для публичной обертки вы подвергаете.  
  
- Объект, возвращенный только для <xref:System.Windows.DependencyPropertyKey> чтения <xref:System.Windows.DependencyProperty>регистрации, а не . Необходимо сохранить это поле в качестве члена, но обычно не нужно его делать общим членом для типа.  
  
 Любое частное поле или значение, заложенное в свойство зависимостей "только для чтения", может быть полностью записываемым с помощью любой выбранной логики. Однако самый простой способ установить свойство на начальном этапе или в рамках логики выполнения — использовать AAP системы свойств, а не обходить систему свойств и непосредственно устанавливать частное резервное поле. В частности, есть <xref:System.Windows.DependencyObject.SetValue%2A> подпись, которая принимает <xref:System.Windows.DependencyPropertyKey>параметр типа. Как и где вы запрограммировали это значение в логике приложения, повлияет на то, как вы можете установить доступ к <xref:System.Windows.DependencyPropertyKey> созданного при первой регистрации свойства зависимости. Если обрабатывать эту логику внутри класса, то можно сделать ее частной. Если необходимо устанавливать ее из других частей сборки, можно сделать ее внутренней. Один из подходов заключается в вызове <xref:System.Windows.DependencyObject.SetValue%2A> в обработчике событий класса соответствующего события, которое информирует экземпляр класса о необходимости изменения значения сохраненного свойства. Другой подход заключается в объединении <xref:System.Windows.PropertyChangedCallback> свойств <xref:System.Windows.CoerceValueCallback> зависимости с помощью парных и обратных вызовов как части метаданных этих свойств во время регистрации.  
  
 Поскольку <xref:System.Windows.DependencyPropertyKey> свойство свойств является закрытым и не распространяется системой свойств за пределами кода, свойство зависимости только для чтения имеет лучшую безопасность, чем свойство зависимости для чтения. Для свойства зависимостей с возможностью чтения и записи идентифицирующее поле является явно или неявно общим, и таким образом, свойство является широко устанавливаемым. Дополнительные сведения см. в разделе [Безопасность свойства зависимостей](dependency-property-security.md).  
  
## <a name="see-also"></a>См. также раздел

- [Общие сведения о свойствах зависимости](dependency-properties-overview.md)
- [Пользовательские свойства зависимостей](custom-dependency-properties.md)
- [Стилизация и использование шаблонов](../../../desktop-wpf/fundamentals/styles-templates-overview.md)
