---
title: Подробное описание синтаксиса XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XML [WPF], namespaces
- XAML [WPF], parsing of attributes
- parsing of attributes [WPF]
- XAML [WPF], markup extensions
- attached properties [WPF]
- tag syntax [XAML]
- markup extensions [WPF]
- XAML [WPF], object element syntax
- XAML [WPF], syntax terminology
- attached events [WPF]
- lookup semantics [WPF]
- XAML [WPF], attached events
- XAML [WPF], content syntax
- XAML [WPF], lookup semantics
- content syntax [WPF]
- object element syntax [WPF]
- syntax terminology [XAML]
- XAML [WPF], attached properties
- attributes [XAML], parsing
- XAML [WPF], tag syntax
- XAML [WPF], attribute syntax
- property element syntax [WPF]
- terminology [XAML]
- namespaces [WPF], XML
- attribute syntax [XAML]
- XAML [WPF], property element syntax
ms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479
ms.openlocfilehash: 3ac7d79660830601ca69951e56763fc923692b0e
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/22/2019
ms.locfileid: "69958790"
---
# <a name="xaml-syntax-in-detail"></a>Подробное описание синтаксиса XAML
В этом разделе определяются термины, используемые для описания элементов синтаксиса XAML. Эти термины часто используются в оставшейся части этой документации как для документации по WPF, так и для других платформ, использующих XAML, или базовых понятий XAML, включенных в поддержку языка XAML на уровне System. XAML. Этот раздел расширяет базовую терминологию, представленную в разделе [Общие сведения о XAML (WPF)](xaml-overview-wpf.md).  

<a name="the_xaml_language_specification"></a>   
## <a name="the-xaml-language-specification"></a>Спецификация языка XAML  
 Определенная здесь терминология синтаксиса XAML также определяется или указывается в спецификации языка XAML. XAML — это язык, основанный на XML, который следует за или расширяет согласно структурным правилам XML. Часть терминологии совместно используется или основана на терминологии, часто используемой при описании языка XML или объектной модели XML-документа.  
  
 Чтобы получить дополнительные сведения о спецификации языка XAML, скачайте [ \[MS-XAML\] ](https://go.microsoft.com/fwlink/?LinkId=114525) из центра загрузки Майкрософт.  
  
<a name="xaml_and_clr"></a>   
## <a name="xaml-and-clr"></a>XAML и CLR  
 XAML — это язык разметки. Среда CLR, как подразумевается ее имя, обеспечивает выполнение среды выполнения. XAML сам по себе не является одним из общих языков, которые напрямую используются средой CLR. Вместо этого XAML можно представить как поддерживающий собственную систему типов. Конкретная система анализа XAML, используемая WPF, основана на CLR и системе типов CLR. Типы XAML сопоставляются с типами CLR для создания экземпляра представления времени выполнения при синтаксическом анализе XAML для WPF. По этой причине в оставшейся части обсуждения синтаксиса в этом документе будут содержаться ссылки на систему типов CLR, несмотря на то, что аналогичные обсуждения синтаксиса в спецификации языка XAML не имеют. (На уровне спецификации языка XAML типы XAML могут быть сопоставлены с любой другой системой типов, которая не обязательно должна быть средой CLR, но для этого потребуется создание и использование другого средства синтаксического анализа XAML.)  
  
#### <a name="members-of-types-and-class-inheritance"></a>Члены типов и наследование классов  
 Свойства и события, отображаемые как члены [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML типа, часто наследуются от базовых типов. Например, рассмотрим следующий пример: `<Button Background="Blue" .../>`. Свойство не является немедленно объявленным свойством <xref:System.Windows.Controls.Button> класса, если бы вы искали определение класса, результаты отражения или документацию. <xref:System.Windows.Controls.Control.Background%2A> Вместо этого класс наследуется от <xref:System.Windows.Controls.Control> базового класса. <xref:System.Windows.Controls.Control.Background%2A>  
  
 Поведение наследования класса элементов [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML значительно отличается от интерпретации XML-разметки в соответствии с схемой. Наследование класса может стать сложным, особенно если промежуточные базовые классы являются абстрактными или используются интерфейсы. Это одна из причин того, что набор элементов XAML и их допустимых атрибутов трудно представить точно и полностью с помощью типов схем, которые обычно используются для [!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)] программирования, например DTD или XSD. Другая причина заключается в том, что функции расширяемости и сопоставления типов в самом языке XAML не позволяют гарантировать полноту какого-либо фиксированного представления допустимых типов и членов.  
  
<a name="object_element_syntax"></a>   
## <a name="object-element-syntax"></a>Синтаксис объектных элементов  
 *Синтаксис элемента объекта* — это синтаксис разметки XAML, создающий экземпляр класса или структуры среды CLR путем объявления элемента XML. Этот синтаксис напоминает синтаксис элементов других языков разметки, таких как HTML. Синтаксис объектного элемента начинается с левой угловой скобки\<(), за которым следует сразу же имя типа класса или структуры, для которой создается экземпляр. После имени типа может содержаться ноль или более пробелов. Кроме того, в элементе Object могут быть объявлены ноль или более атрибутов с одним или несколькими пробелами, разделяющими каждую пару "имя атрибута =" значение ". Наконец, должно выполняться одно из следующих условий:  
  
- Элемент и тег должны быть закрыты косой чертой (/), за которой следует правая угловая скобка (>).  
  
- Открывающий тег должен быть заполнен правой угловой скобкой (>). Другие элементы объекта, элементы свойств или внутренний текст могут следовать за открывающим тегом. Именно содержимое, которое может содержаться здесь, обычно ограничено объектной моделью элемента. Эквивалентный закрывающий тег для объектного элемента также должен существовать в правильном вложении и сбалансировать с другими открывающими и закрывающими парами тегов.  
  
 XAML, реализованный в .NET, имеет набор правил, которые сопоставляют элементы объекта с типами, атрибутами в свойствах или событиях, а также пространства имен XAML для пространств имен CLR и сборки. Для WPF и .NET Framework объектные элементы XAML сопоставляются с [!INCLUDE[TLA#tla_net](../../../../includes/tlasharptla-net-md.md)] типами, как определено в ссылочных сборках, и атрибуты сопоставляются с элементами этих типов. При ссылке на тип CLR в XAML у вас также есть доступ к унаследованным членам этого типа.  
  
 Например, следующий пример представляет собой синтаксис элемента объекта, который создает новый экземпляр <xref:System.Windows.Controls.Button> класса, а также <xref:System.Windows.FrameworkElement.Name%2A> задает атрибут и значение для этого атрибута:  
  
 [!code-xaml[XAMLOvwSupport#SyntaxOE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxoe)]  
  
 В следующем примере показан синтаксис элемента объекта, который также включает синтаксис свойства содержимого XAML. Внутренний текст, <xref:System.Windows.Controls.TextBox.Text%2A>содержащийся в, будет использоваться для задания <xref:System.Windows.Controls.TextBox> свойства содержимого XAML.  
  
 [!code-xaml[XAMLOvwSupport#ThisIsATextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#thisisatextbox)]  
  
### <a name="content-models"></a>Модели содержимого  
 Класс может поддерживать использование как объектного элемента XAML с точки зрения синтаксиса, но этот элемент будет работать правильно только в приложении или странице, когда он помещается в ожидаемую точку общей модели содержимого или дерева элементов. Например, элемент <xref:System.Windows.Controls.MenuItem> , как правило, должен быть размещен только как дочерний <xref:System.Windows.Controls.Primitives.MenuBase> объект производного <xref:System.Windows.Controls.Menu>класса, например. Модели содержимого для конкретных элементов задокументированы как часть примечаний на страницах класса для элементов управления и других [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] классов, которые могут использоваться в качестве элементов XAML.  
  
<a name="properties_of_object_elements"></a>   
## <a name="properties-of-object-elements"></a>Свойства элементов Object  
 Свойства в XAML задаются различными возможными синтаксисами. Синтаксис, который может использоваться для конкретного свойства, зависит от системных характеристик базового типа свойства, которое вы устанавливаете.  
  
 Устанавливая значения свойств, вы добавляете компоненты или характеристики в объекты, так как они существуют в графе объектов времени выполнения. Начальное состояние созданного объекта из объектного элемента основано на поведении конструктора без параметров. Как правило, приложение будет использовать нечто, отличное от полного экземпляра по умолчанию любого заданного объекта.  
  
<a name="attribute_syntax_properties"></a>   
## <a name="attribute-syntax-properties"></a>Синтаксис атрибутов (свойства)  
 Синтаксис атрибутов — это синтаксис разметки XAML, который задает значение для свойства путем объявления атрибута для существующего объектного элемента. Имя атрибута должно совпадать с именем члена CLR свойства класса, который создает соответствующий элемент объекта. За именем атрибута следует оператор присваивания (=). Значение атрибута должно быть строкой, заключенной в кавычки.  
  
> [!NOTE]
> С помощью альтернативных кавычек можно поместить литеральную кавычку в атрибут. Например, можно использовать одинарные кавычки в качестве средства для объявления строки, содержащей символ двойной кавычки в нем. Независимо от того, используются ли одинарные или двойные кавычки, следует использовать совпадающую пару для открытия и закрытия строки значения атрибута. Существуют также escape-последовательности или другие методы, доступные для обхода ограничений по символам, накладываемых любым конкретным синтаксисом XAML. См. раздел [сущности символов XML и XAML](../../xaml-services/xml-character-entities-and-xaml.md).  
  
 Для настройки с помощью синтаксиса атрибутов свойство должно быть открытым и должно быть доступно для записи. Значение свойства в системе резервных типов должно быть типом значения или ссылочным типом, который может быть создан или указан в обработчике XAML при доступе к соответствующему резервному типу.  
  
 Для событий WPF XAML событие, на которое ссылается имя атрибута, должно быть открытым и иметь открытый делегат.  
  
 Свойство или событие должно быть членом класса или структуры, экземпляры которых создаются содержащим его элементом Object.  
  
### <a name="processing-of-attribute-values"></a>Обработка значений атрибутов  
 Строковое значение, содержащееся в открывающих и закрывающих кавычках, обрабатывается обработчиком XAML. Для свойств поведение обработки по умолчанию определяется типом базового свойства CLR.  
  
 Значение атрибута заполняется одним из следующих значений с использованием этого порядка обработки:  
  
1. Если обработчик XAML встречает фигурную скобку или элемент объекта, производный от <xref:System.Windows.Markup.MarkupExtension>, то расширение разметки, на которое указывает ссылка, вычисляется первыми вместо обработки значения в виде строки, а объект, возвращаемый расширением разметки, используется в качестве значений. Во многих случаях объект, возвращаемый расширением разметки, будет ссылкой на существующий объект или выражение, которое откладывает вычисление до времени выполнения и не является новым экземпляром объекта.  
  
2. Если свойство объявлено с атрибутом <xref:System.ComponentModel.TypeConverter>или тип значения этого свойства объявлен с <xref:System.ComponentModel.TypeConverter>атрибутом, строковое значение атрибута передается в преобразователь типов в качестве входных данных преобразования, а преобразователь возвратит новый экземпляр объекта.  
  
3. Если нет <xref:System.ComponentModel.TypeConverter>, предпринимается попытка прямого преобразования в тип свойства. Этот последний уровень является прямым преобразованием в собственном значении синтаксического анализатора между типами примитивов языка XAML или проверки имен именованных констант в перечислении (средство синтаксического анализа обращается к соответствующим значениям).  
  
#### <a name="enumeration-attribute-values"></a>Значения атрибутов перечисления  
 Перечисления в XAML обрабатываются внутренне средствами синтаксического анализа XAML, а элементы перечисления должны быть указаны путем указания имени строки одной из именованных констант перечисления.  
  
 Для непомеченных значений перечисления поведение в собственном режиме заключается в обработке строки значения атрибута и ее разрешении в одно из значений перечисления. Перечисление не указывается в перечисленииFormat. *Значение*, как и в коде. Вместо этого указывается только *значение*, а перечисление выводится типом свойства, которое вы устанавливаете. При указании атрибута в перечислении. Форма *значения* , она будет разрешаться неправильно.  
  
 Для перечислений флагового поведение основано на <xref:System.Enum.Parse%2A?displayProperty=nameWithType> методе. Можно указать несколько значений для перечисления флагового, разделяя каждое значение запятой. Однако нельзя сочетать значения перечисления, которые не являются флагового. Например, нельзя использовать синтаксис с запятой для создания объекта <xref:System.Windows.Trigger> , который обрабатывает несколько условий перечисления, не являющегося флагом:  
  
```  
<!--This will not compile, because Visibility is not a flagwise enumeration.-->  
...  
<Trigger Property="Visibility" Value="Collapsed,Hidden">  
  <Setter ... />  
</Trigger>  
...  
```  
  
 Перечисления флагового, поддерживающие атрибуты, устанавливаемые в XAML, редко встречаются в WPF. Однако одно такое перечисление <xref:System.Windows.Media.StyleSimulations>—. Например, можно использовать синтаксис атрибута флагового с разделителями-запятыми для изменения примера, приведенного в комментариях <xref:System.Windows.Documents.Glyphs> к классу. `StyleSimulations = "BoldSimulation"` может стать `StyleSimulations = "BoldSimulation,ItalicSimulation"`. <xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType>еще одно свойство, в котором можно указать несколько значений перечисления. Однако это свойство является особым случаем, так как <xref:System.Windows.Input.ModifierKeys> перечисление поддерживает собственный преобразователь типов. Преобразователь типов для модификаторов использует знак плюс (+) в качестве разделителя, а не запятую (,). Это преобразование поддерживает более традиционный синтаксис для представления сочетаний клавиш в программировании Microsoft Windows, например "Ctrl + Alt".  
  
### <a name="properties-and-event-member-name-references"></a>Ссылки на свойства и имена членов событий  
 При указании атрибута можно ссылаться на любое свойство или событие, которое существует в качестве члена типа CLR, созданного для содержащего объектного элемента.  
  
 Или можно сослаться на присоединенное свойство или присоединенное событие независимо от содержащего его элемента Object. (Присоединенные свойства обсуждаются в следующем разделе.)  
  
 Можно также присвоить любое событие любому объекту, доступному через пространство имен по умолчанию, с помощью имени *типа*. частично определенное имя *события* ; Этот синтаксис поддерживает присоединение обработчиков для перенаправленных событий, когда обработчик предназначен для обработки маршрутизации событий из дочерних элементов, но родительский элемент также не имеет этого события в таблице Members. Этот синтаксис напоминает синтаксис присоединенного события, но событие здесь не является настоящим вложенным событием. Вместо этого вы ссылаетесь на событие с полным именем. Дополнительные сведения см. в разделе [Общие сведения о перенаправленных событиях](routed-events-overview.md).  
  
 В некоторых сценариях имена свойств иногда предоставляются как значение атрибута, а не имя атрибута. Это имя свойства также может включать квалификаторы, например свойство, указанное в формате *OwnerType*. *депенденципропертинаме*. Этот сценарий часто используется при написании стилей или шаблонов в XAML. Правила обработки имен свойств, указанных в качестве значений атрибутов, отличаются и определяются типом устанавливаемого свойства или поведением конкретных подсистем WPF. Дополнительные сведения см. в разделе [Стилизация и создание шаблонов](../controls/styling-and-templating.md).  
  
 Еще одним использованием имен свойств является то, что значение атрибута описывает связь свойств свойства. Эта функция используется для привязки данных и для целей раскадровки и включается <xref:System.Windows.PropertyPath> классом и преобразователем типов. Более полное описание семантики уточняющего запроса см. в разделе [синтаксис языка XAML PropertyPath](propertypath-xaml-syntax.md).  
  
<a name="property_element_syntax"></a>   
## <a name="property-element-syntax"></a>Синтаксис элемента свойства  
 *Синтаксис элемента свойства* — это синтаксис, который отличается от основных правил синтаксиса XML для элементов. В XML значением атрибута является строка де-факто с единственной возможной вариацией, в которой используется формат кодировки строк. В XAML можно назначить другие элементы объекта в качестве значения свойства. Эта возможность включается с помощью синтаксиса элемента свойства. Вместо свойства, указанного в качестве атрибута в теге элемента, свойство указывается с помощью открывающего тега элемента в *елементтипенаме*. *PropertyName* Form, значение свойства указывается в, а затем элемент свойства закрывается.  
  
 В частности, синтаксис начинается с левой угловой скобки (\<), за которым следует сразу же имя типа класса или структуры, в которой содержится синтаксис элемента свойства. За ним следует одиночная точка (.), затем по имени свойства, а затем по правой угловой скобке (>). Как и при использовании синтаксиса атрибутов, это свойство должно существовать в объявленных открытых членах указанного типа. Значение, присваиваемое свойству, содержится в элементе Property. Как правило, значение задается как один или несколько объектных элементов, так как указание объектов в качестве значений является сценарием, которому предназначен синтаксис элемента свойства. И, наконец, эквивалентный закрывающий тег, указывающий тот же *елементтипенаме*. необходимо указать сочетание *PropertyName* , правильно вложенное и сбалансировать с другими тегами элементов.  
  
 Например, ниже приведен синтаксис элемента свойства для <xref:System.Windows.FrameworkElement.ContextMenu%2A> свойства <xref:System.Windows.Controls.Button>объекта.  
  
 [!code-xaml[XAMLOvwSupport#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#contextmenu)]  
  
 Значение в элементе Property также может быть задано как внутренний текст, в случаях, когда указанный тип свойства является примитивным типом значения, например <xref:System.String>, или перечислением, в котором указано имя. Эти два варианта использования довольно редки, так как в каждом из этих случаев также может использоваться более простой синтаксис атрибутов. Один из сценариев заполнения элемента Property строкой предназначен для свойств, которые не являются свойством содержимого XAML, но по-прежнему используются для представления текста пользовательского интерфейса, а определенные элементы пробела, такие как символы перевода строки, должны отображаться в тексте пользовательского интерфейса. Синтаксис атрибутов не может сохранять символы перевода строки, но синтаксис элемента свойства может быть настолько длиннее, насколько активна незначительная сохранность пробелов (Дополнительные сведения см. [в разделе Обработка пробелов в XAML](../../xaml-services/whitespace-processing-in-xaml.md)). Другой сценарий заключается в том, что [директиву x:UID](../../xaml-services/x-uid-directive.md) можно применить к элементу Property и, таким образом, пометить значение в качестве значения, которое должно быть локализовано в выходных данных WPF BAML или другими методами.  
  
 Элемент свойства не представлен в логическом дереве WPF. Элемент Property — это просто определенный синтаксис для установки свойства, который не является элементом, имеющим резервный экземпляр или объект. (Дополнительные сведения о концепции логического дерева см. в разделе [деревья в WPF](trees-in-wpf.md).)  
  
 Для свойств, в которых поддерживаются и атрибут, и синтаксис элемента свойства, два синтаксиса обычно имеют одинаковый результат, хотя такие тонкости, как обработка пробелов, могут незначительно различаться в синтаксисе.  
  
<a name="collection_syntax"></a>   
## <a name="collection-syntax"></a>Синтаксис коллекции  
 Спецификация XAML требует реализации процессора XAML для определения свойств, в которых тип значения является коллекцией. Общая реализация процессора XAML в .NET основана на управляемом коде и среде CLR и определяет типы коллекций одним из следующих методов:  
  
- Реализует <xref:System.Collections.IList>тип.  
  
- Реализует <xref:System.Collections.IDictionary>тип.  
  
- Тип является производным <xref:System.Array> от (Дополнительные сведения о массивах в XAML см. в разделе [расширение разметки x:Array](../../xaml-services/x-array-markup-extension.md).)  
  
 Если тип свойства является коллекцией, то выводимый тип коллекции не обязательно указывать в разметке как элемент объекта. Вместо этого элементы, которые должны стать элементами коллекции, задаются как один или несколько дочерних элементов элемента Property. Каждый такой элемент вычисляется в объект во время загрузки и добавляется в коллекцию путем вызова `Add` метода неявной коллекции. Например, <xref:System.Windows.Style.Triggers%2A> <xref:System.Windows.TriggerCollection>свойство принимает специализированный тип коллекции, реализующий <xref:System.Collections.IList>. <xref:System.Windows.Style> Нет необходимости создавать экземпляр <xref:System.Windows.TriggerCollection> объектного элемента в разметке. Вместо этого вы указываете один или <xref:System.Windows.Trigger> несколько элементов `Style.Triggers` в качестве элементов в элементе Property, <xref:System.Windows.Trigger> где (или производный класс) является типом, ожидаемым типом элемента для строго типизированного и неявного <xref:System.Windows.TriggerCollection>.  
  
 [!code-xaml[XAMLOvwSupport#SyntaxPECollection](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxpecollection)]  
  
 Свойство может быть как типом коллекции, так и свойством содержимого XAML для этого типа и производных типов, о которых рассказывается в следующем разделе этой статьи.  
  
 Неявный элемент коллекции создает элемент в представлении логического дерева, даже если он не отображается в разметке как элемент. Обычно конструктор родительского типа выполняет создание экземпляра для коллекции, которая является одним из ее свойств, а начальная пустая коллекция становится частью дерева объектов.  
  
> [!NOTE]
> Для обнаружения коллекции не поддерживаются универсальные <xref:System.Collections.Generic.IDictionary%602>интерфейсы List и Dictionary (<xref:System.Collections.Generic.IList%601> и). Однако <xref:System.Collections.Generic.List%601> класс можно использовать в качестве базового класса, поскольку он реализуется <xref:System.Collections.IList> напрямую или <xref:System.Collections.Generic.Dictionary%602> как базовый класс, поскольку он реализуется <xref:System.Collections.IDictionary> напрямую.  
  
 На справочных страницах .NET для типов коллекций этот синтаксис с намеренным опущенным элементом объекта для коллекции иногда отмечается в разделах синтаксиса XAML как неявный синтаксис коллекции.  
  
 За исключением корневого элемента, каждый объектный элемент в файле XAML, вложенный в качестве дочернего элемента другого элемента, на самом деле является элементом, который является одним или обоими в следующих случаях: членом неявного свойства коллекции своего родительского элемента. или элемент, указывающий значение свойства содержимого XAML для родительского элемента (свойства содержимого XAML будут обсуждаться в следующем разделе). Иными словами, связь между родительскими и дочерними элементами на странице разметки на самом деле является одним объектом в корне, а каждый объектный элемент под корнем является либо единственным экземпляром, предоставляющим значение свойства родителя, либо одним из элементов в столбце. лектион, который также является значением свойства типа коллекции для родителя. Это понятие с одним корнем, которое обычно используется в XML и часто прикрепляется к поведению интерфейсов API, которые <xref:System.Windows.Markup.XamlReader.Load%2A>загружают XAML, например.  
  
 В следующем примере показан синтаксис с элементом Object для коллекции (<xref:System.Windows.Media.GradientStopCollection>), заданной явным образом.  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <GradientStopCollection>  
      <GradientStop Offset="0.0" Color="Red" />  
      <GradientStop Offset="1.0" Color="Blue" />  
    </GradientStopCollection>  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
 Обратите внимание, что не всегда можно явно объявлять коллекцию. Например, попытка явного объявления <xref:System.Windows.TriggerCollection> в приведенном <xref:System.Windows.Style.Triggers%2A> выше примере приведет к сбою. Для явного объявления коллекции необходимо, чтобы класс коллекции поддерживал конструктор без параметров и <xref:System.Windows.TriggerCollection> не имел конструктор без параметров.  
  
<a name="xaml_content_properties"></a>   
## <a name="xaml-content-properties"></a>Свойства содержимого XAML  
 Синтаксис содержимого XAML — это синтаксис, который включается только для классов, которые <xref:System.Windows.Markup.ContentPropertyAttribute> указывают в качестве части их объявления класса. <xref:System.Windows.Markup.ContentPropertyAttribute> Ссылается на имя свойства, которое является свойством содержимого для этого типа элемента (включая производные классы). При обработке обработчиком XAML все дочерние элементы или внутренний текст, найденный между открывающим и закрывающим тегами элемента Object, будут назначены в качестве значения свойства содержимого XAML для этого объекта. Вы имеете разрешение указывать явные элементы свойств для свойства содержимого, но это использование не показано в разделах синтаксиса XAML в справочнике по .NET. Метод Explicit/verbose имеет случайное значение для ясности разметки или для стиля разметки, но обычно целью свойства содержимого является упрощение разметки, чтобы элементы, интуитивно связанные как родители-потомки, могли быть вложены напрямую. Теги элементов свойств для других свойств элемента не присваиваются как "содержимое" в соответствии с определенным определением языка XAML; они обрабатываются ранее в порядке обработки средства синтаксического анализа XAML и не считаются "содержимым".  
  
### <a name="xaml-content-property-values-must-be-contiguous"></a>Значения свойств содержимого XAML должны быть непрерывными  
 Значение свойства содержимого XAML должно быть задано либо полностью до, либо полностью после любых других элементов свойств в этом элементе Object. Это справедливо, если значение свойства содержимого XAML указано как строка или как один или несколько объектов. Например, следующая разметка не выполняет синтаксический анализ:  
  
```  
<Button>I am a   
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 Это недопустимо, поскольку если этот синтаксис был сделан явным с помощью синтаксиса элемента свойства для свойства содержимого, свойство Content будет установлено дважды:  
  
```xml  
<Button>  
  <Button.Content>I am a </Button.Content>  
  <Button.Background>Blue</Button.Background>  
  <Button.Content> blue button</Button.Content>  
</Button>  
```  
  
 Аналогичным образом является недопустимый пример, если свойство Content является коллекцией, а дочерние элементы помещаются в элементы свойств:  
  
```xml  
<StackPanel>  
  <Button>This example</Button>  
  <StackPanel.Resources>  
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>  
  </StackPanel.Resources>  
  <Button>... is illegal XAML</Button>  
</StackPanel>  
```  
  
<a name="content_properties_and_collection_syntax_combined"></a>   
## <a name="content-properties-and-collection-syntax-combined"></a>Объединение свойства содержимого и синтаксиса коллекции  
 Чтобы принимать больше одного элемента объекта в качестве содержимого, тип свойства содержимого должен быть типом коллекции. Подобно синтаксису элементов свойств для типов коллекций, обработчик XAML должен указывать типы, которые являются типами коллекций. Если элемент имеет свойство содержимого XAML и тип свойства содержимого XAML является коллекцией, то неявный тип коллекции не обязательно указывать в разметке как элемент объекта, а свойство содержимого XAML не нужно указывать как свойство El. правления. Поэтому в качестве содержимого может быть назначено более одного дочернего элемента в разметке. Ниже приведен синтаксис содержимого для <xref:System.Windows.Controls.Panel> производного класса. Все <xref:System.Windows.Controls.Panel> производные классы устанавливают свойство содержимого XAML, которое <xref:System.Windows.Controls.Panel.Children%2A>должно иметь значение типа <xref:System.Windows.Controls.UIElementCollection>.  
  
 [!code-xaml[XAMLOvwSupport#SyntaxContent](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page5.xaml#syntaxcontent)]  
  
 Обратите внимание, что ни элемент <xref:System.Windows.Controls.Panel.Children%2A> свойства для, <xref:System.Windows.Controls.UIElementCollection> ни элемент для элемента не требуется в разметке. Это функция разработки XAML, позволяющая рекурсивно сопоставленные элементы, определяющие [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] , более интуитивно представленные в виде дерева вложенных элементов с непосредственными связями "родители-потомки", без промежуточных тегов элемента свойств или объекты коллекции. Фактически, <xref:System.Windows.Controls.UIElementCollection> не может быть явно задано в разметке как элемент объекта, по дизайну. Поскольку используется только в качестве неявной коллекции, <xref:System.Windows.Controls.UIElementCollection> не предоставляет общедоступный конструктор без параметров и, таким образом, не может быть создан как объектный элемент.  
  
### <a name="mixing-property-elements-and-object-elements-in-an-object-with-a-content-property"></a>Смешивание элементов свойств и объектных элементов в объекте со свойством содержимого  
 В спецификации XAML объявляется, что обработчик XAML может принудительно применять элементы объекта, используемые для заполнения свойства содержимого XAML в элементе Object, должен быть непрерывным и не должен быть смешанным. Это ограничение для смешивания элементов свойств и содержимого обеспечивается [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] обработчиками XAML.  
  
 В качестве первой немедленной разметки в элементе Object можно использовать дочерний элемент Object. Затем можно ввести элементы свойств. Или можно указать один или несколько элементов свойств, затем содержимое, а затем дополнительные элементы свойств. Но после того, как элемент свойства последует за содержимым, вы не можете добавить никакого содержимого, но можно добавлять только элементы свойств.  
  
 Это требование порядка элементов свойства и содержимого не применяется к внутреннему тексту, используемому в качестве содержимого. Тем не менее, он по-прежнему является хорошим стилем разметки для сохранения внутреннего текста непрерывно, поскольку значащий пробел будет трудно обнаружить визуально в разметке, если элементы свойств поделены внутренним текстом.  
  
<a name="xaml_namespaces"></a>   
## <a name="xaml-namespaces"></a>Пространства имен языка XAML  
 Ни один из предыдущих примеров синтаксиса не указал пространство имен XAML, отличное от пространства имен XAML по умолчанию. В типичных [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] приложениях пространство имен XAML по умолчанию задается [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] как пространство имен. Можно указать пространства имен XAML, отличные от пространства имен XAML по умолчанию, и по-прежнему использовать аналогичный синтаксис. Но в любом месте, где имя класса недоступно в пространстве имен XAML по умолчанию, этому имени класса должен предшествовать префикс пространства имен XAML, сопоставленный с соответствующим пространством имен CLR. Например, `<custom:Example/>` представляет собой синтаксис элемента объекта для создания экземпляра `Example` класса, в котором пространство имен CLR, содержащее этот класс (и, возможно, сведения о внешней сборке, содержащие резервные типы), было ранее сопоставлено с `custom` префикс.  
  
 Дополнительные сведения о пространствах имен XAML см. в разделе [пространства имен и сопоставление пространств имен XAML для WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).  
  
<a name="markup_extensions"></a>   
## <a name="markup-extensions"></a>Расширения разметки  
 XAML определяет сущность для программирования расширения разметки, которая обеспечивает escape-обработку от обычного обработчика XAML значений строковых атрибутов или элементов объектов, а также откладывает обработку на резервный класс. Символ, определяющий расширение разметки для обработчика XAML при использовании синтаксиса атрибутов, — это открывающая фигурная скобка ({), за которой следует любой символ, отличный от закрывающей фигурной скобки (}). Первая строка, следующая за открывающей фигурной скобкой, должна ссылаться на класс, предоставляющий конкретное поведение расширения, где ссылка может опускать подстроку "Extension", если эта подстрока является частью истинного имени класса. После этого может появиться одно пространство, а затем каждый последующий символ будет использоваться в качестве входных данных реализацией расширения до тех пор, пока не будет обнаружена закрывающая фигурная скобка.  
  
 Реализация XAML в .NET использует <xref:System.Windows.Markup.MarkupExtension> абстрактный класс как основу для всех расширений разметки, поддерживаемых, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] а также других платформ или технологий. Расширения разметки, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] которые особенно реализуются, часто предназначены для предоставления средств для ссылки на другие существующие объекты или для предоставления отложенных ссылок на объекты, которые будут вычисляться во время выполнения. Например, простая привязка данных WPF достигается путем указания `{Binding}` расширения разметки вместо значения, которое обычно принимает конкретное свойство. Многие расширения разметки WPF позволяют использовать синтаксис атрибутов для свойств, в которых использование синтаксиса атрибутов не было бы возможным. Например, <xref:System.Windows.Style> объект является относительно сложным типом, который содержит вложенный ряд объектов и свойств. Стили в WPF обычно определяются как ресурс в <xref:System.Windows.ResourceDictionary>, а затем указываются через одно из двух расширений разметки WPF, запрашивающих ресурс. Расширение разметки откладывает вычисление значения свойства на Уточняющий запрос ресурса и позволяет предоставить значение <xref:System.Windows.FrameworkElement.Style%2A> свойства, принимая во внимание тип <xref:System.Windows.Style>в синтаксисе атрибута, как показано в следующем примере:  
  
 `<Button Style="{StaticResource MyStyle}">My button</Button>`  
  
 `StaticResource` Здесь<xref:System.Windows.StaticResourceExtension> определяется класс, предоставляющий реализацию расширения разметки. Следующая строка `MyStyle` используется в качестве входных данных для конструктора, не являющегося <xref:System.Windows.StaticResourceExtension> конструктором по умолчанию, где параметр, взятый из строки расширения, <xref:System.Windows.ResourceKey>объявляет запрошенный. `MyStyle`должно быть значением <xref:System.Windows.Style> [x:Key](../../xaml-services/x-key-directive.md) , определенным как ресурс. Использование [расширения разметки StaticResource](staticresource-markup-extension.md) требует, чтобы ресурс использовался для предоставления <xref:System.Windows.Style> значения свойства через логику поиска статических ресурсов во время загрузки.  
  
 Подробнее о расширениях разметки см. в разделе [Расширения разметки и XAML WPF](markup-extensions-and-wpf-xaml.md). Ссылки на расширения разметки и другие функции программирования XAML, включенные в общей реализации .NET XAML, см [. в разделе пространство имен XAML (x:). Функции](../../xaml-services/xaml-namespace-x-language-features.md)языка. Сведения о расширениях разметки WPF см. в разделе [расширения XAML WPF](wpf-xaml-extensions.md).  
  
<a name="attached_properties"></a>   
## <a name="attached-properties"></a>Вложенные свойства  
 Присоединенные свойства — это концепция программирования, появившаяся в XAML, при которой свойства могут принадлежать определенному типу, но устанавливаться в качестве атрибутов или элементов свойств в любом элементе. Основной сценарий, в котором присоединенные свойства предназначены для, — включить дочерние элементы в структуре разметки для передачи информации родительскому элементу, не требуя совместного использования объектной модели для всех элементов. И наоборот, вложенные свойства могут использоваться родительскими элементами для передачи сведений дочерним элементам. Дополнительные сведения о назначении присоединенных свойств и о создании собственных присоединенных свойств см. в разделе [Общие сведения о вложенных](attached-properties-overview.md)свойствах.  
  
 Присоединенные свойства используют синтаксис, который внешне напоминает синтаксис элемента свойства, в котором также указывается *имя TypeName*. *PropertyName* . Однако имеется два важных отличия.  
  
- Можно использовать *имя TypeName*. *PropertyName* — даже при задании присоединенного свойства с помощью синтаксиса атрибутов. Присоединенные свойства — это единственный случай, когда уточнение имени свойства является обязательным в синтаксисе атрибута.  
  
- Для присоединенных свойств также можно использовать синтаксис элемента свойства. Однако для типичного синтаксиса элемента свойства указываемое *имя TypeName* является элементом объекта, содержащим элемент Property. Если вы ссылаетесь на присоединенное свойство, то *TypeName* является классом, который определяет присоединенное свойство, а не содержащий его элемент.  
  
<a name="attached_events"></a>   
## <a name="attached-events"></a>Вложенные события  
 Вложенные события — это еще одна концепция программирования, появившаяся в XAML, где события могут быть определены определенным типом, но обработчики могут быть присоединены к любому элементу Object. В реализации ВОФ тип, определяющий присоединенное событие, часто является статическим типом, определяющим службу, и иногда эти вложенные события предоставляются псевдонимом перенаправленных событий в типах, которые предоставляют службу. Обработчики для вложенных событий задаются с помощью синтаксиса атрибутов. Как и в случае с присоединенными событиями, синтаксис атрибута разворачивается для вложенных событий, чтобы разрешить *имя типа*. *EventName* использование, где *TypeName* — это класс, предоставляющий `Add` методы `Remove` доступа и обработчики событий для подключаемой инфраструктуры событий, а *EventName* — это имя события.  
  
<a name="anatomy_of_a_xaml_page_root_element"></a>   
## <a name="anatomy-of-a-xaml-root-element"></a>Анатомия корневого элемента XAML  
 В следующей таблице показан типичный корневой элемент XAML, в котором показаны определенные атрибуты корневого элемента:  
  
|||  
|-|-|  
|`<Page`|Открытие объектного элемента корневого элемента|  
|`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`|Пространство имен XAML[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]по умолчанию ()|  
|`xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`|Пространство имен XAML языка XAML|  
|`x:Class="ExampleNamespace.ExampleCode"`|Объявление разделяемого класса, которое соединяет разметку с кодом программной части, определенными для разделяемого класса|  
|`>`|Конец элемента Object для корня. Объект еще не закрыт, так как элемент содержит дочерние элементы|  
  
<a name="optional_and_nonrecommended_xaml_usages"></a>   
## <a name="optional-and-nonrecommended-xaml-usages"></a>Необязательные и нерекомендуемые использования XAML  
 В следующих разделах описываются случаи использования XAML, которые технически поддерживаются обработчиками XAML, но они создают подробные сведения или другие Aesthetic проблемы, которые мешают работе с файлами XAML, остающимися для чтения человеком при разработке приложений, содержащих источники XAML.  
  
### <a name="optional-property-element-usages"></a>Необязательные использование элементов свойств  
 Необязательные использования элементов свойств включают явное Написание свойств содержимого элементов, которые обработчик XAML считает неявным. Например, при <xref:System.Windows.Controls.Menu>объявлении содержимого объекта можно явно <xref:System.Windows.Controls.ItemsControl.Items%2A> объявить `<Menu.Items>` коллекцию в <xref:System.Windows.Controls.Menu> качестве тега элемента свойства и разместить каждый из `<Menu.Items>`них <xref:System.Windows.Controls.MenuItem> , а не по сравнению с использованием неявного поведения обработчика XAML все <xref:System.Windows.Controls.Menu> дочерние <xref:System.Windows.Controls.MenuItem> элементы должны быть <xref:System.Windows.Controls.ItemsControl.Items%2A> и помещены в коллекцию. Иногда необязательное использование может помочь визуально уточнить структуру объекта, представленную в разметке. Или иногда использование явного элемента свойства может не допустить технически функциональной разметки, такой как вложенные расширения разметки в значении атрибута.  
  
### <a name="full-typenamemembername-qualified-attributes"></a>Полные атрибуты typeName. memberName  
 *Имя типа*. Функция *MemberName* для атрибута в действительности работает более универсально, чем только вариант перенаправленного события. Но в других ситуациях этот формат является излишним, и его следует избегать, если только причина стиля разметки и удобства чтения. В следующем примере каждая из трех ссылок на <xref:System.Windows.Controls.Control.Background%2A> атрибут полностью эквивалентна:  
  
 [!code-xaml[XAMLOvwSupport#TypeNameProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenameprop)]  
  
 `Button.Background`работает, поскольку полный поиск этого свойства в <xref:System.Windows.Controls.Button> успешно завершен (<xref:System.Windows.Controls.Control.Background%2A> наследуется от Control) и <xref:System.Windows.Controls.Button> является классом элемента Object или базового класса. `Control.Background`работает, поскольку <xref:System.Windows.Controls.Control> класс фактически определяет <xref:System.Windows.Controls.Control.Background%2A> и <xref:System.Windows.Controls.Control> является <xref:System.Windows.Controls.Button> базовым классом.  
  
 Однако приведенное ниже *имя TypeName*. Пример *MemberName* Form не работает и поэтому отображается с комментариями:  
  
 [!code-xaml[XAMLOvwSupport#TypeNameBadProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenamebadprop)]  
  
 <xref:System.Windows.Controls.Label>является еще одним производным <xref:System.Windows.Controls.Control>классом, и если вы `Label.Background` указали <xref:System.Windows.Controls.Label> в элементе Object, это использование было бы работало. Однако, поскольку <xref:System.Windows.Controls.Label> не является классом или базовым <xref:System.Windows.Controls.Button>классом, заданное поведение обработчика XAML будет обрабатываться `Label.Background` как присоединенное свойство. `Label.Background`не является доступным присоединенным свойством, и это использование завершается неудачно.  
  
### <a name="basetypenamemembername-property-elements"></a>Элементы свойств Басетипенаме. memberName  
 Аналогичным образом, как имя *TypeName*. *MemberName* работает для синтаксиса атрибутов, *басетипенаме*. синтаксис *MemberName* работает для синтаксиса элемента свойства. Например, следующий синтаксис работает:  
  
 [!code-xaml[XAMLOvwSupport#GoofyPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofype)]  
  
 Здесь элемент свойства был задан так, как `Control.Background` будто элемент Property содержится в. `Button`  
  
 Но так же, как *TypeName*. *MemberName* Form для атрибутов, *басетипенаме*. *MemberName* является неудовлетворительным стилем в разметке, и его следует избегать.  
  
## <a name="see-also"></a>См. также

- [Общие сведения о языке XAML (WPF)](xaml-overview-wpf.md)
- [Пространство имен XAML (x:) Языковые возможности](../../xaml-services/xaml-namespace-x-language-features.md)
- [Расширения XAML WPF](wpf-xaml-extensions.md)
- [Общие сведения о свойствах зависимости](dependency-properties-overview.md)
- [TypeConverters и XAML](typeconverters-and-xaml.md)
- [Код XAML и пользовательские классы для WPF](xaml-and-custom-classes-for-wpf.md)
