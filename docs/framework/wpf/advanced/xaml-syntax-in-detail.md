---
title: Подробное описание синтаксиса XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XML [WPF], namespaces
- XAML [WPF], parsing of attributes
- parsing of attributes [WPF]
- XAML [WPF], markup extensions
- attached properties [WPF]
- tag syntax [XAML]
- markup extensions [WPF]
- XAML [WPF], object element syntax
- XAML [WPF], syntax terminology
- attached events [WPF]
- lookup semantics [WPF]
- XAML [WPF], attached events
- XAML [WPF], content syntax
- XAML [WPF], lookup semantics
- content syntax [WPF]
- object element syntax [WPF]
- syntax terminology [XAML]
- XAML [WPF], attached properties
- attributes [XAML], parsing
- XAML [WPF], tag syntax
- XAML [WPF], attribute syntax
- property element syntax [WPF]
- terminology [XAML]
- namespaces [WPF], XML
- attribute syntax [XAML]
- XAML [WPF], property element syntax
ms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479
ms.openlocfilehash: dbff4bed59c8d1e861555676578b52528e2aebbe
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79186189"
---
# <a name="xaml-syntax-in-detail"></a>Подробное описание синтаксиса XAML
Эта тема определяет термины, которые используются для описания элементов синтаксиса XAML. Эти термины часто используются на протяжении оставшейся части настоящей документации, как для документации WPF, так и для других фреймворков, которые используют XAML или основные концепции XAML, включенные в поддержку языка XAML на уровне System.Xaml. Эта тема распространяется на основную терминологию, представленную в теме [XAML Обзор (WPF)](../../../desktop-wpf/fundamentals/xaml.md).  

<a name="the_xaml_language_specification"></a>
## <a name="the-xaml-language-specification"></a>Спецификация языка XAML  
 Терминология синтаксиса XAML, определенная здесь, также определена или ссылки в спецификации языка XAML. XAML является языком, основанным на XML и следует или расширяется на XML структурных правил. Часть терминологии используется или основана на терминологии, обычно используемой при описании языка XML или модели объекта документа XML.  
  
 Для получения дополнительной информации о спецификации языка XAML загрузите [ \[MS-XAML\] ](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf) из Центра загрузки Майкрософт.  
  
<a name="xaml_and_clr"></a>
## <a name="xaml-and-clr"></a>XAML и CLR  
 XAML является языком разметки. Общее время выполнения языка (CLR), как подразумевается под его названием, позволяет выполнять время выполнения. XAML сам по себе не является одним из распространенных языков, которые непосредственно потребляются временем выполнения CLR. Вместо этого, вы можете думать о XAML как о поддержке своей собственной системы типа. Конкретная система разбора XAML, используемая WPF, построена на системе CLR и типа CLR. Типы XAML отображаются в типах CLR, чтобы мгновенно восполнить время выполнения при разборе XAML для WPF. По этой причине оставшаяся часть обсуждения синтаксиса в этом документе будет включать ссылки на систему типа CLR, даже если эквивалентные обсуждения синтаксиса в спецификации языка XAML не содержат. (На уровне спецификации языка XAML типы XAML могут быть отображены в любой другой тип системы, которая не должна быть CLR, но это потребует создания и использования другого parser XAML.)  
  
#### <a name="members-of-types-and-class-inheritance"></a>Члены Типов и Наследования класса  
 Свойства и события, как они появляются [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] как XAML членов типа часто наследуются от базовых типов. Например, рассмотрим `<Button Background="Blue" .../>`этот пример: . Свойство <xref:System.Windows.Controls.Control.Background%2A> не является сразу задекларированным свойством в <xref:System.Windows.Controls.Button> классе, если вы должны были посмотреть на определение класса, результаты отражения или документацию. Вместо <xref:System.Windows.Controls.Control.Background%2A> этого, наследуется <xref:System.Windows.Controls.Control> от базового класса.  
  
 Поведение классового [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] наследования элементов XAML является значительным отходом от интерпретации разметки XML, принудительной схемой. Наследования классов могут стать сложными, особенно когда промежуточные базовые классы являются абстрактными, или когда интерфейсы участвуют. Это одна из причин того, что набор элементов XAML и их допустимые атрибуты трудно представить точно и полностью с помощью типов схем, которые обычно используются для программирования XML, таких как dTD или XSD формат. Другая причина заключается в том, что особенности размножения и отображения типов самого языка XAML исключают полноту любого фиксированного представления допустимых типов и членов.  
  
<a name="object_element_syntax"></a>
## <a name="object-element-syntax"></a>Синтаксис объектных элементов  
 *Синтаксис элемента объекта* — это синтаксис разметки XAML, который мгновенно сопровождает класс или структуру CLR, объявляя элемент XML. Этот синтаксис напоминает синтаксис элементов других языков разметки, таких как HTML. Синтаксис элемента объекта начинается\<с левой кронштейна угла (), а затем сразу же имя типа класса или структуры мгновенно. Ноль или больше пробелов могут следовать имени типа, а на элементе объекта также могут быть объявлены нулевые или более атрибуты, при этом одно или несколько пространств разделяют каждую пару атрибутов имени. Наконец, один из следующих должно быть правдой:  
  
- Элемент и тег должны быть закрыты передним слэшом (/) с последующим прямым углом кронштейна (>).  
  
- Тег открытия должен быть завершен прямым углом кронштейна (>). Другие элементы объекта, элементы свойств или внутренний текст могут следовать тегу открытия. То, что содержание может содержаться здесь, обычно ограничено типовой моделью элемента. Эквивалентный тег закрытия для элемента объекта также должен существовать при правильном вложении и балансе с другими парами тегов открытия и закрытия.  
  
 XAML, реализованный .NET, имеет набор правил, которые отображают элементы объектов по типам, атрибуты в свойства или события, а xAML пространства имен — в области имен CLR плюс сборку. Для WPF и .NET элементы объектов XAML отображают на типах .NET, как это определено в референтных собраниях, и карту атрибутов для членов этих типов. Когда вы ссылаетесь на тип CLR в XAML, у вас есть доступ к унаследованных членов этого типа, а также.  
  
 Например, следующий пример — синтаксис элемента объекта, <xref:System.Windows.Controls.Button> который мгновенно приводит к новому <xref:System.Windows.FrameworkElement.Name%2A> экземпляру класса, а также определяет атрибут и значение для этого атрибута:  
  
 [!code-xaml[XAMLOvwSupport#SyntaxOE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxoe)]  
  
 Следующим примером является синтаксис элемента объекта, который также включает в себя синтаксис свойства содержимого XAML. Внутренний текст, содержащийся внутри, <xref:System.Windows.Controls.TextBox> будет использоваться <xref:System.Windows.Controls.TextBox.Text%2A>для установки свойства содержимого XAML.  
  
 [!code-xaml[XAMLOvwSupport#ThisIsATextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#thisisatextbox)]  
  
### <a name="content-models"></a>Модели контента  
 Класс может поддерживать использование в качестве элемента объекта XAML с точки зрения синтаксиса, но этот элемент будет функционировать только в приложении или на странице, когда он находится в ожидаемом положении общей модели содержимого или дерева элементов. Например, <xref:System.Windows.Controls.MenuItem> a, как правило, следует <xref:System.Windows.Controls.Primitives.MenuBase> размещать только в <xref:System.Windows.Controls.Menu>качестве ребенка производного класса, такого как . Модели содержимого для определенных элементов документируются как часть [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] замечаний на страницах классов для элементов управления и других классов, которые могут быть использованы в качестве элементов XAML.  
  
<a name="properties_of_object_elements"></a>
## <a name="properties-of-object-elements"></a>Свойства элементов объекта  
 Свойства в XAML устанавливаются различными возможными синтами. Какой синтаксис может быть использован для конкретного свойства будет варьироваться, в зависимости от базовых характеристик системы типа свойства, которое вы устанавливаете.  
  
 Устанавливая значения свойств, вы добавляете объекты функций или характеристик по мере их существования в графике объекта времени выполнения. Начальное состояние созданного объекта из элемента объекта основано на поведении беспараметрыного конструктора. Как правило, приложение использует нечто иное, чем полностью экземпляр по умолчанию любого конкретного объекта.  
  
<a name="attribute_syntax_properties"></a>
## <a name="attribute-syntax-properties"></a>Синтаксис атрибутов (свойства)  
 Синтаксис атрибутов — это синтаксис разметки XAML, который устанавливает значение для свойства, объявляя атрибут на существующем элементе объекта. Имя атрибута должно совпадать с именем члена CLR свойства класса, которое поддерживает соответствующий элемент объекта. За именем атрибута следует оператор назначения (кв.). Значение атрибута должно быть строкой, заключенной в кавычки.  
  
> [!NOTE]
> Переменные котировки можно использовать для размещения буквального кавычки в атрибуте. Например, вы можете использовать одиночные кавычки в качестве средства для объявления строки, содержащей в ней символ двойной цитаты. Используете ли вы одну или двойную кавычки, следует использовать соответствующую пару для открытия и закрытия строки значения атрибута. Есть также побег последовательности или другие методы, доступные для работы вокруг символов ограничения, введенные какой-либо конкретной синтаксиса XAML. Смотрите [XML символов и XAML](../../../desktop-wpf/xaml-services/xml-character-entities.md).  
  
 Для того, чтобы быть установленным через синтаксис атрибута, свойство должно быть общедоступным и должно быть записываемым. Значение свойства в системе резервного типа должно быть типом значения или должен быть типом ссылки, который может быть мгновенно или ссылки процессора XAML при доступе к соответствующему типу поддержки.  
  
 Для событий WPF XAML событие, на которое ссылаются как имя атрибута, должно быть общедоступным и иметь публичного делегата.  
  
 Свойство или событие должно быть членом класса или структуры, мгновенно содержащего элемент объекта.  
  
### <a name="processing-of-attribute-values"></a>Обработка значений атрибутов  
 Значение строки, содержащееся в знаках кавычек открытия и закрытия, обрабатывается процессором XAML. Для свойств поведение обработки по умолчанию определяется типом базового свойства CLR.  
  
 Значение атрибута заполняется одним из следующих, используя этот порядок обработки:  
  
1. Если процессор XAML сталкивается с фигурной скобкой или <xref:System.Windows.Markup.MarkupExtension>элементом объекта, который вытекает из этого, то ссылка на расширение разметки оценивается сначала, а не обрабатывает значение как строку, и объект, возвращенный расширением разметки, используется в качестве значения. Во многих случаях объект, возвращенный расширением разметки, будет ссылкой на существующий объект или выражением, которое откладывает оценку до времени выполнения, и не является новым мгновенным объектом.  
  
2. Если свойство задекларировано с приписываемым, <xref:System.ComponentModel.TypeConverter>или тип <xref:System.ComponentModel.TypeConverter>значения этого свойства задекларирован с приписываемым, значение строки атрибута представлено преобразователю типа в качестве ввода преобразования, и преобразователь вернет новый экземпляр объекта.  
  
3. Если <xref:System.ComponentModel.TypeConverter>нет, попытка прямого преобразования в тип свойства. Этот окончательный уровень представляет собой прямое преобразование на парсер-родное значение между примитивными типами языка XAML или проверку имен названных констант в перечислении (парсер затем получает доступ к соответствующим значениям).  
  
#### <a name="enumeration-attribute-values"></a>Enumeration Attribute Values  
 Перечисления в XAML обрабатываются внутренне parsers XAML, и члены перечисления должны быть указаны путем указания строки имени одной из названных констант перечисления.  
  
 Для значений нефлагового перечисления родное поведение заключается в обработке строки значения атрибута и ее разослании с одним из значений перечисления. Вы не указываете перечисление в формате *Enumeration*. *Значение,* как вы делаете в коде. Вместо этого вы указываете только *значение,* и *значение* выводится по типу объекта, который вы устанавливаете. Если указать атрибут в *перечислении*. *Значение* формы, она не будет решать правильно.  
  
 Для зачисляемых флагов поведение основано на методе. <xref:System.Enum.Parse%2A?displayProperty=nameWithType> Можно указать несколько значений для перечисления флагом, разделив каждое значение с запятой. Тем не менее, нельзя комбинировать значения перечисления, которые не являются flagwise. Например, нельзя использовать синтаксис запятой <xref:System.Windows.Trigger> для создания, который действует на нескольких условиях перечисления нефлага:  
  
```xaml  
<!--This will not compile, because Visibility is not a flagwise enumeration.-->  
...  
<Trigger Property="Visibility" Value="Collapsed,Hidden">  
  <Setter ... />  
</Trigger>  
...  
```  
  
 Пометные перечисления, поддерживающие атрибуты, установленные в XAML, редки в WPF. Тем не менее, одним <xref:System.Windows.Media.StyleSimulations>из таких перечислений является . Можно, например, использовать синтаксис атрибута флага, делящемуся запятой, чтобы изменить пример, приведенный в Замечаниях для <xref:System.Windows.Documents.Glyphs> класса; `StyleSimulations = "BoldSimulation"` может `StyleSimulations = "BoldSimulation,ItalicSimulation"`стать . <xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType>это другое свойство, в котором может быть указано более одного значения перечисления. Однако это свойство является особым случаем, поскольку <xref:System.Windows.Input.ModifierKeys> перечисление поддерживает свой собственный преобразователь типа. Преобразователь типа для модификаторов использует знак плюс (кв) в качестве делимитеда, а не запятой (,). Это преобразование поддерживает более традиционный синтаксис для представления ключевых комбинаций в программировании Microsoft Windows, таких как "Ctrl-Alt".  
  
### <a name="properties-and-event-member-name-references"></a>Свойства и Ссылки на имена участников событий  
 При указании атрибута можно ссылаться на любое свойство или событие, которое существует в качестве типа CLR, которое вы мгновенный для элемента, содержащего объект.  
  
 Или можно ссылаться на прикрепленное свойство или прилагаемое событие, независимо от элемента, содержащего объект. (Присоединенные свойства обсуждаются в предстоящем разделе.)  
  
 Вы также можете назвать любое событие из любого объекта, доступного через пространство имен по умолчанию, используя *nameName typeName.* *событие* частично квалифицированное название; этот синтаксис поддерживает присоединение обработчиков для маршрутных событий, где обработчик предназначен для обработки маршрутизаний событий из элементов ребенка, но родительский элемент также не имеет этого события в таблице его членов. Этот синтаксис напоминает прилагаемый синтаксис события, но событие здесь не является истинным прикрепленным событием. Вместо этого вы ссылаетесь на событие с квалифицированным именем. Для получения дополнительной информации [см.](routed-events-overview.md)  
  
 Для некоторых сценариев имена свойств иногда предоставляются как значение атрибута, а не имени атрибута. Это имя свойства может также включать квалификаторы, такие как свойство, указанное в форме *ownerType*. *зависимостьPropertyName*. Этот сценарий является общим при написании стилей или шаблонов в XAML. Правила обработки имен свойств, представленные в качестве значения атрибута, различны и регулируются типом объекта, устанавливаемого, или поведением определенных подсистем WPF. Для получения подробной информации, [см Стиль и Templating](../controls/styling-and-templating.md).  
  
 Другое использование имен свойств — это когда значение атрибута описывает отношения свойство и свойств. Эта функция используется для связывания данных и для <xref:System.Windows.PropertyPath> целей раскадровки, и включена классом и его типовым преобразователем. Для более полного описания семантики [PropertyPath XAML Syntax](propertypath-xaml-syntax.md)поиска см.  
  
<a name="property_element_syntax"></a>
## <a name="property-element-syntax"></a>Синтаксис элемента свойства  
 *Синтаксис элементов свойства* — это синтаксис, который несколько отличается от основных правил синтаксиса XML для элементов. В XML значение атрибута является де-факто строкой, с единственным возможным вариантом, который используется формат кодирования строк. В XAML можно присвоить другие элементы объекта, которые будут значением свойства. Эта возможность включена синтаксисом элемента свойства. Вместо того, чтобы свойство, указанное в качестве атрибута в теге элемента, свойство указывается с помощью тега элемента открытия в *elementTypeName*. *propertyName* форма, стоимость имущества указана внутри, а затем элемент свойства закрывается.  
  
 В частности, синтаксис начинается\<с левой кронштейна угла ( ), а затем сразу же имя типа класса или структуры, что синтаксис элемента свойства содержится внутри. За этим следует сразу одна точка (.), затем по названию свойства, затем под прямым углом кронштейн (>). Как и в отношении синтаксиса атрибутов, это свойство должно существовать в пределах заявленных публичных членов указанного типа. Значение, назначенное свойству, содержится в элементе свойства. Как правило, значение приводится в качестве одного или нескольких элементов объекта, поскольку указание объектов в качестве значений — это сценарий, для решения которого предназначен синтаксис элемента свойства. Наконец, эквивалентный тег закрытия, указывающий тот же *элементTypeName.* *PropertyName* комбинация должна быть предоставлена, в надлежащем вложения и баланс с другими тегами элемента.  
  
 Например, ниже приводится синтаксис <xref:System.Windows.FrameworkElement.ContextMenu%2A> элемента <xref:System.Windows.Controls.Button>свойства для свойства .  
  
 [!code-xaml[XAMLOvwSupport#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#contextmenu)]  
  
 Значение элемента свойства также может быть приведено в виде внутреннего текста, в тех случаях, когда указанный тип свойства является примитивным типом значения, <xref:System.String>например, или перечислением, в котором указывается имя. Эти два обычая несколько редки, потому что каждый из этих случаев может также использовать более простой синтаксис атрибута. Один из сценариев заполнения элемента свойства строкой предназначен для свойств, которые не являются свойством содержимого XAML, но все еще используются для представления текста uI, и определенные элементы белого пространства, такие как линейные каналы, должны отображаться в этом тексте uI. Синтаксис атрибутов не может сохранять линейные каналы, но синтаксис элемента свойства может, до тех пор, пока активна значительная сохранность белого пространства (для деталей см. [Обработку белого пространства в XAML).](../../../desktop-wpf/xaml-services/white-space-processing.md) Другой сценарий заключается в том, что [директива x:Uid](../../../desktop-wpf/xaml-services/xuid-directive.md) может быть применена к элементу свойства и, таким образом, отметивать значение внутри как значение, которое должно быть локализовано в выходе WPF BAML или другими методами.  
  
 Элемент свойства не представлен в логическом дереве WPF. Элемент свойства — это всего лишь определенный синтаксис для настройки свойства и не является элементом, поддерживающим экземпляр или объект. (Для получения подробной информации о логической концепции дерева, [см. Деревья в WPF](trees-in-wpf.md).)  
  
 Для свойств, где синтаксис атрибута и элемента свойства поддерживается, два синтаксиса обычно имеют одинаковый результат, хотя такие тонкости, как обработка белого пространства, могут незначительно отличаться между синтаксисами.  
  
<a name="collection_syntax"></a>
## <a name="collection-syntax"></a>Синтаксис коллекции  
 Спецификация XAML требует реализации процессора XAML для определения свойств, в которых тип значения является коллекцией. Общая реализация процессора XAML в .NET основана на управляемом коде и CLR, и она определяет типы коллекций через один из следующих:  
  
- Тип орудий <xref:System.Collections.IList>.  
  
- Тип орудий <xref:System.Collections.IDictionary>.  
  
- Тип происходит <xref:System.Array> от (для получения дополнительной информации о массивах в XAML, см. [x: Array Markup Extension.)](../../../desktop-wpf/xaml-services/xarray-markup-extension.md)  
  
 Если тип свойства является коллекцией, то выведенный тип сбора не должен быть указан в разметке как элемент объекта. Вместо этого элементы, которые должны стать элементами в коллекции, указаны как один или несколько элементов детского элемента элемента свойства. Каждый такой элемент оценивается на объект во время `Add` загрузки и добавляется в коллекцию, называя метод подразумеваемой коллекции. Например, <xref:System.Windows.Style.Triggers%2A> свойство <xref:System.Windows.Style> принимает специализированный <xref:System.Windows.TriggerCollection>тип сбора, который <xref:System.Collections.IList>реализует. Нет необходимости мгновенно гонять <xref:System.Windows.TriggerCollection> элемент объекта в разметке. Вместо этого вы указываете один <xref:System.Windows.Trigger> или `Style.Triggers` несколько <xref:System.Windows.Trigger> элементов в качестве элементов в элементе свойства, где (или <xref:System.Windows.TriggerCollection>производный класс) является типом, ожидаемым как тип элемента для сильно набранного и неявного .  
  
 [!code-xaml[XAMLOvwSupport#SyntaxPECollection](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxpecollection)]  
  
 Свойство может быть как типом коллекции, так и свойством содержимого XAML для этого типа и производных типов, что обсуждается в следующем разделе этой темы.  
  
 Неявный элемент сбора создает элемент в логическом представлении дерева, даже если он не отображается в разметке как элемент. Обычно конструктор родительского типа выполняет моментацию для коллекции, которая является одним из ее свойств, и изначально пустая коллекция становится частью дерева объекта.  
  
> [!NOTE]
> Общие интерфейсы списка и<xref:System.Collections.Generic.IList%601> словаря (и <xref:System.Collections.Generic.IDictionary%602>) не поддерживаются для обнаружения коллекции. Тем не менее, <xref:System.Collections.Generic.List%601> вы можете использовать класс в <xref:System.Collections.IList> качестве <xref:System.Collections.Generic.Dictionary%602> базового класса, потому <xref:System.Collections.IDictionary> что он реализует сятворный напрямую или в качестве базового класса, потому что он реализуется напрямую.  
  
 На страницах ссылки .NET для типов коллекций этот синтаксис с преднамеренным упущением элемента объекта для коллекции иногда отмечается в разделах синтаксиса XAML как неявный синтаксис collection.  
  
 За исключением корневого элемента, каждый элемент объекта в файле XAML, вложенный в элемент ребенка другого элемента, на самом деле является элементом, который является одним или обоими из следующих случаев: член неявного свойства коллекции своего родительского элемента или элемент, опоглавяавающих значение свойства содержимого XAML для родительского элемента (свойства содержимого XAML будут обсуждаться в предстоящем разделе). Другими словами, связь родительских элементов и элементов ребенка на странице разметки на самом деле является одним объектом в корне, и каждый элемент объекта под корнем является либо одним экземпляром, обеспечивающим свойство родителя, либо одним из элементов внутри коллекция, которая также является значением свойства коллекционного типа родителя. Эта однокорневая концепция является общей для XML и часто усиливается в поведении <xref:System.Windows.Markup.XamlReader.Load%2A>AI, которые загружают XAML, такие как .  
  
 Следующим примером является синтаксис с элементом<xref:System.Windows.Media.GradientStopCollection>объекта для коллекции () явно указанный.  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <GradientStopCollection>  
      <GradientStop Offset="0.0" Color="Red" />  
      <GradientStop Offset="1.0" Color="Blue" />  
    </GradientStopCollection>  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
 Обратите внимание, что не всегда возможно прямо объявить коллекцию. Например, попытка четко <xref:System.Windows.TriggerCollection> заявить в <xref:System.Windows.Style.Triggers%2A> ранее показанном примере не увенчается неудачей. Явное объявление коллекции требует, чтобы класс коллекции поддерживал <xref:System.Windows.TriggerCollection> беспараметрыный конструктор и не имеет беспаралистерного конструктора.  
  
<a name="xaml_content_properties"></a>
## <a name="xaml-content-properties"></a>Свойства содержимого XAML  
 Синтаксис содержимого XAML — это синтаксис, <xref:System.Windows.Markup.ContentPropertyAttribute> который включен только в классах, которые указывают как часть их классной декларации. Ссылки <xref:System.Windows.Markup.ContentPropertyAttribute> на имя свойства, которое является свойством содержимого для этого типа элемента (включая производные классы). При обработке процессором XAML любые элементы ребенка или внутренний текст, найденные между тегами открытия и закрытия элемента объекта, будут приписаны к значению свойства содержимого XAML для этого объекта. Для свойства содержимого разрешается указывать явные элементы свойств, но это использование обычно не отображается в разделах синтаксиса XAML в ссылке .NET. Явный/многословный метод имеет иногдае значение для четкости разметки или как вопрос стиля разметки, но обычно цель свойства содержимого заключается в том, чтобы упорядочить разметку так, чтобы элементы, которые интуитивно связаны как родитель-ребенок, могли быть вложены напрямую. Теги элементов свойств для других свойств на элементе не присваиваются как "содержимое" в строгом определении языка XAML; они обрабатываются ранее в порядке обработки parser XAML и не считаются "контентом".  
  
### <a name="xaml-content-property-values-must-be-contiguous"></a>Значения свойств контента XAML должны быть сопредельными  
 Значение свойства содержимого XAML должно быть предоставлено либо до, так и полностью после любых других элементов свойства этого элемента объекта. Это верно независимо от того, определяется ли значение свойства содержимого XAML как строка или как один или несколько объектов. Например, следующая разметка не разбирает:  
  
```xaml  
<Button>I am a
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 Это незаконно по существу, потому что если этот синтаксис были сделаны явными с помощью синтаксиса элемента свойства для содержания свойства, то свойство содержания будет установлено дважды:  
  
```xaml  
<Button>  
  <Button.Content>I am a </Button.Content>  
  <Button.Background>Blue</Button.Background>  
  <Button.Content> blue button</Button.Content>  
</Button>  
```  
  
 Аналогичным образом незаконным примером является, если свойство содержимого является коллекцией, а элементы ребенка перемежаются с элементами свойств:  
  
```xaml  
<StackPanel>  
  <Button>This example</Button>  
  <StackPanel.Resources>  
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>  
  </StackPanel.Resources>  
  <Button>... is illegal XAML</Button>  
</StackPanel>  
```  
  
<a name="content_properties_and_collection_syntax_combined"></a>
## <a name="content-properties-and-collection-syntax-combined"></a>Объединение свойства содержимого и синтаксиса коллекции  
 Для того, чтобы принять более одного элемента объекта в качестве содержимого, тип свойства содержимого должен быть конкретно типом коллекции. Как и синтаксис элементов свойств для типов коллекций, процессор XAML должен идентифицировать типы, которые являются типами коллекций. Если элемент имеет свойство содержимого XAML, а тип свойства содержимого XAML является коллекцией, то подразумеваемый тип сбора не должен быть указан в разметке как элемент объекта, а свойство содержимого XAML не нужно указывать как свойство Элемент. Таким образом, модель очевидного содержимого в разметке теперь может иметь более одного элемента ребенка, назначенного в качестве содержимого. Ниже приводится синтаксис <xref:System.Windows.Controls.Panel> содержимого для производного класса. Все <xref:System.Windows.Controls.Panel> выведенные классы устанавливают свойство <xref:System.Windows.Controls.Panel.Children%2A>содержимого XAML, <xref:System.Windows.Controls.UIElementCollection>которое должно быть, что требует значения типа.  
  
 [!code-xaml[XAMLOvwSupport#SyntaxContent](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page5.xaml#syntaxcontent)]  
  
 Обратите внимание, что <xref:System.Windows.Controls.Panel.Children%2A> в разметке не <xref:System.Windows.Controls.UIElementCollection> требуется ни элемент свойства, ни элемент для наценки. Это особенность дизайна XAML, так что рекурсивно [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] содержащиеся элементы, которые определяют более интуитивно представлены как дерево вложенных элементов с непосредственными отношениями элементов родитель-ребенок, без вмешательства теги элементов свойств или объектов сбора. На самом <xref:System.Windows.Controls.UIElementCollection> деле, не может быть указано явно в разметке как объект элемент, по замыслу. Потому что его единственное предназначенное использование как неявная коллекция, <xref:System.Windows.Controls.UIElementCollection> не подвергает публичному конструктору параметров и, таким образом, не может быть мгновенно в качестве элемента объекта.  
  
### <a name="mixing-property-elements-and-object-elements-in-an-object-with-a-content-property"></a>Смешивание элементов свойств и элементов объекта в объекте с свойством содержимого  
 Спецификация XAML заявляет, что процессор XAML может применять элементы этого объекта, которые используются для заполнения свойства содержимого XAML в элементе объекта, должен быть смежным и не должен быть смешан. Это ограничение на смешивание элементов свойств [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] и содержимого применяется процессорами XAML.  
  
 Элемент объекта ребенка может быть первым непосредственным разметкой в элементе объекта. Затем можно ввести элементы свойств. Или можно указать один или несколько элементов свойств, затем содержимое, а затем больше элементов свойства. Но как только элемент свойства следует за содержимым, вы не можете ввести какое-либо дальнейшее содержание, можно добавить только элементы свойств.  
  
 Это требование о порядке элементов содержимого/свойства не распространяется на внутренний текст, используемый в качестве содержимого. Тем не менее, это все еще хороший стиль разметки, чтобы сохранить внутренний текст смежным, потому что значительное белое пространство будет трудно обнаружить визуально в разметке, если элементы свойства перемежаются с внутренним текстом.  
  
<a name="xaml_namespaces"></a>
## <a name="xaml-namespaces"></a>Пространства имен языка XAML  
 Ни в одном из предыдущих примеров синтаксиса не указано пространство имен XAML, кроме пространства имен XAML по умолчанию. В [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] типичных приложениях пространство имен XAML [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] по умолчанию указывается как пространство имен. Вы можете указать xAML пространства имен, кроме пространства имен XAML по умолчанию, и по-прежнему использовать аналогичный синтаксис. Но затем, где класс назван, который не доступен в пространстве имен XAML по умолчанию, этому названию класса должна предшествовать приставка пространства имен XAML, отображаемое в соответствующем пространстве имен CLR. Например, `<custom:Example/>` это синтаксис элемента объекта для `Example` мгновенного экземпляра класса, где пространство имен CLR, содержащее этот класс (и, `custom` возможно, информация о внешней сборке, содержащей типы поддержки), ранее отображалось к префиксу.  
  
 Для получения дополнительной информации о [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)пространствах имен XAML см.  
  
<a name="markup_extensions"></a>
## <a name="markup-extensions"></a>Расширения разметки  
 XAML определяет сущность программирования расширения разметки, которая позволяет избежать обычной обработки процессором XAML значений атрибутов строки или элементов объекта, и откладывает обработку на резервный класс. Символ, который определяет расширение разметки для процессора XAML при использовании синтаксиса атрибута, является открывающейся фигурной скобкой (к) за другимперсонажем, кроме закрывающейся фигурной скобки() Первая строка, следуя за вступительной скобкой, должна ссылаться на класс, обеспечивающий определенное поведение расширения, где ссылка может пропустить подстроку "Расширение", если эта подстрока является частью истинного имени класса. После этого может появиться одно пространство, а затем каждый последующий символ используется в качестве ввода реализации расширения, вплоть до встречи с закрывающейся фигурной скобкой.  
  
 Реализация .NET XAML <xref:System.Windows.Markup.MarkupExtension> использует абстрактный класс в качестве основы [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] для всех расширений разметки, поддерживаемых, а также других инфраструктур или технологий. Расширения разметки, которые [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] конкретно реализуются, часто предназначены для предоставления средств для ссылки на другие существующие объекты или для отложенных ссылок на объекты, которые будут оцениваться во время выполнения. Например, простая привязка данных WPF `{Binding}` выполняется путем указания расширения разметки вместо значения, которое обычно принимает конкретное свойство. Многие расширения разметки WPF позволяют синтаксис атрибута для свойств, где синтаксис атрибута в противном случае был бы невозможен. Например, <xref:System.Windows.Style> объект является относительно сложным типом, содержащим вложенные ряд объектов и свойств. Стили в WPF, как правило, определяются как ресурс в <xref:System.Windows.ResourceDictionary>, а затем ссылки через один из двух расширений разметки WPF, которые запрашивают ресурс. Расширение разметки откладывает оценку стоимости свойства для поиска ресурсов <xref:System.Windows.FrameworkElement.Style%2A> и позволяет <xref:System.Windows.Style>обеспечить стоимость свойства, принимая тип, в синемасе атрибутов, как в следующем примере:  
  
 `<Button Style="{StaticResource MyStyle}">My button</Button>`  
  
 Здесь `StaticResource` определяется <xref:System.Windows.StaticResourceExtension> класс, обеспечивающий реализацию расширения разметки. Следующая `MyStyle` строка используется в качестве ввода <xref:System.Windows.StaticResourceExtension> для непоумолчанию конструктора, где параметр, <xref:System.Windows.ResourceKey>взятый из строки расширения объявляет запрошенный . `MyStyle`ожидается значение [x:Key,](../../../desktop-wpf/xaml-services/xkey-directive.md) определяемое <xref:System.Windows.Style> как ресурс. Использование [расширения StaticResource Markup](staticresource-markup-extension.md) требует, чтобы ресурс <xref:System.Windows.Style> использовался для обеспечения значения свойства через логику поиска статического ресурса во время загрузки.  
  
 Подробнее о расширениях разметки см. в разделе [Расширения разметки и XAML WPF](markup-extensions-and-wpf-xaml.md). Для справки о расширениях разметки и других функциях программирования XAML, включенных в общую реализацию .NET XAML, [см. Языковые особенности](../../../desktop-wpf/xaml-services/namespace-language-features.md). Для расширения разметки WPF [см.](wpf-xaml-extensions.md)  
  
<a name="attached_properties"></a>
## <a name="attached-properties"></a>Вложенные свойства  
 Прилагаемые свойства — это концепция программирования, введенная в XAML, в соответствии с которой свойства могут принадлежать и определяться определенным типом, но устанавливаться в качестве атрибутов или элементов свойств на любом элементе. Основной сценарий, для которого предназначены прилагаемые свойства, заключается в том, чтобы позволить элементам в структуре разметки сообщать информацию родительскому элементу, не требуя широко разделяемой модели объектов во всех элементах. И наоборот, прилагаемые свойства могут использоваться родительскими элементами для сообщения информации элементам ребенка. Для получения дополнительной информации о цели прилагаемых свойств [Attached Properties Overview](attached-properties-overview.md)и о том, как создать свои собственные прилагаемые свойства, см.  
  
 Прилагаемые свойства используют синтаксис, который внешне напоминает синтаксис элемента свойства, в том, что вы также указываете *typeName.* *propertyName* комбинация. Однако имеется два важных отличия.  
  
- Вы можете использовать *typeName*. комбинация *propertyName* даже при настройке прикрепленного свойства через синтаксис атрибута. Приложенные свойства являются единственным случаем, когда квалификация имени свойства является требованием в синтаксисе атрибута.  
  
- Вы также можете использовать синтаксис элемента свойства для прилагаемых свойств. Однако для типичного синтаксиса элемента свойств *указанный typeName* является элементом объекта, содержащим элемент свойства. Если вы имеете в виду прилагаемое свойство, то *typeName* — это класс, определяющий прилагаемое свойство, а не элемент, содержащий объект.  
  
<a name="attached_events"></a>
## <a name="attached-events"></a>Вложенные события  
 Прилагаемые события — это еще одна концепция программирования, введенная в XAML, где события могут определяться определенным типом, но обработчики могут быть прикреплены к любому элементу объекта. В реализации WOF часто тип, определяющий прикрепленное событие, является статическим типом, определяющим службу, и иногда эти прилагаемые события подвергаются маршрутизированному псевдониму события в типах, которые разоблачают службу. Обработчики для прикрепленных событий определяются через синтаксис атрибутов. Как и в случае с прикрепленными событиями, синтаксис атрибута расширяется для прикрепленных событий, чтобы позволить *typeName.* использование *eventName,* где *typeName* — `Add` `Remove` это класс, предоставляющий и обработчик событий для прилагаемых инфраструктуры событий, а *EventName* — это имя события.  
  
<a name="anatomy_of_a_xaml_page_root_element"></a>
## <a name="anatomy-of-a-xaml-root-element"></a>Анатомия корневого элемента XAML  
 В следующей таблице показан типичный корневой элемент XAML, разбитый, показывающий определенные атрибуты корневого элемента:  
  
|||  
|-|-|  
|`<Page`|Открытие элемента объекта корневого элемента|  
|`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`|Пространство имен[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]XAML по умолчанию|  
|`xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`|Пространство имен на языке XAML|  
|`x:Class="ExampleNamespace.ExampleCode"`|Частичное объявление класса, которое соединяет разметку с любым кодовым за исцелением, определенным для частичного класса|  
|`>`|Конец элемента объекта для корня. Объект еще не закрыт, так как элемент содержит элементы ребенка|  
  
<a name="optional_and_nonrecommended_xaml_usages"></a>
## <a name="optional-and-nonrecommended-xaml-usages"></a>Дополнительные и нерекомендуемые xAML Usages  
 В следующих разделах описываются обычаи XAML, которые технически поддерживаются процессорами XAML, но которые создают многословие или другие эстетические проблемы, которые мешают XAML файлы остаются читаемыми человеком, когда вы разрабатываете приложения, которые содержат источники XAML.  
  
### <a name="optional-property-element-usages"></a>Дополнительные использования элементов свойства  
 Дополнительные использования элементов свойств включают явное написание свойств содержимого элементов, которые процессор XAML считает неявными. Например, когда вы объявляете <xref:System.Windows.Controls.Menu>содержимое, вы можете <xref:System.Windows.Controls.ItemsControl.Items%2A> выбрать явно <xref:System.Windows.Controls.Menu> объявить коллекцию в качестве тега `<Menu.Items>` элемента <xref:System.Windows.Controls.MenuItem> свойства, и поместить каждый внутри, `<Menu.Items>`вместо того, чтобы использовать неявное поведение процессора XAML, что все элементы ребенка <xref:System.Windows.Controls.Menu> должны быть <xref:System.Windows.Controls.MenuItem> и помещаются в <xref:System.Windows.Controls.ItemsControl.Items%2A> коллекцию. Иногда дополнительные обычаи могут помочь визуально прояснить структуру объекта, представленную в разметке. Или иногда явное использование элемента свойства может избежать разметки, которая является технически функциональной, но визуально запутанной, например, вложенные расширения разметки в значении атрибута.  
  
### <a name="full-typenamemembername-qualified-attributes"></a>Полный typeName.memberName Квалифицированные атрибуты  
 Имя *типа*. Форма *memberName* для атрибута на самом деле работает более универсально, чем просто маршрутизированный случай события. Но в других ситуациях, которые образуют сяизн, и этого следует избегать, если только по причинам стиля разметки и читаемости. В следующем примере каждая из трех <xref:System.Windows.Controls.Control.Background%2A> ссылок на атрибут полностью эквивалентна:  
  
 [!code-xaml[XAMLOvwSupport#TypeNameProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenameprop)]  
  
 `Button.Background`работает, потому что квалифицированный <xref:System.Windows.Controls.Button> поиск<xref:System.Windows.Controls.Control.Background%2A> этого свойства на успешно <xref:System.Windows.Controls.Button> (был унаследован от управления) и является классом элемента объекта или базового класса. `Control.Background`<xref:System.Windows.Controls.Control> работает, потому что <xref:System.Windows.Controls.Control.Background%2A> <xref:System.Windows.Controls.Control> класс <xref:System.Windows.Controls.Button> фактически определяет и является базовым классом.  
  
 Тем не менее, следующий *typeName*. пример формы *memberName* не работает и, таким образом, отображается прокомментировал:  
  
 [!code-xaml[XAMLOvwSupport#TypeNameBadProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenamebadprop)]  
  
 <xref:System.Windows.Controls.Label>является еще одним <xref:System.Windows.Controls.Control>производным классом , и если бы вы указали `Label.Background` в элементе <xref:System.Windows.Controls.Label> объекта, это использование работало бы. Однако, <xref:System.Windows.Controls.Label> поскольку это не <xref:System.Windows.Controls.Button>класс или базовый класс, указанное `Label.Background` поведение процессора XAML заключается в том, чтобы затем обрабатываться как прилагаемое свойство. `Label.Background`не является доступным прикрепленным свойством, и это использование завершается неудачей.  
  
### <a name="basetypenamemembername-property-elements"></a>baseTypeName.memberНаит элементы свойств  
 В аналогичном порядке, как *typeName*. *форма memberName* работает для синтаксиса атрибутов, *baseTypeName*. *syntax memberName* работает для синтаксиса элементов свойства. Например, работает следующий синтаксис:  
  
 [!code-xaml[XAMLOvwSupport#GoofyPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofype)]  
  
 Здесь элемент свойства был `Control.Background` дан так, как только `Button`элемент свойства содержался в .  
  
 Но так же, как *typeName*. *форма memberName* для атрибутов, *baseTypeName*. *memberName* плохой стиль в разметке, и вы должны избегать его.  
  
## <a name="see-also"></a>См. также раздел

- [Обзор XAML (WPF)](../../../desktop-wpf/fundamentals/xaml.md)
- [Возможности пространства имен языка XAML (x:)](../../../desktop-wpf/xaml-services/namespace-language-features.md)
- [Расширения XAML WPF](wpf-xaml-extensions.md)
- [Общие сведения о свойствах зависимости](dependency-properties-overview.md)
- [TypeConverters и XAML](typeconverters-and-xaml.md)
- [Код XAML и пользовательские классы для WPF](xaml-and-custom-classes-for-wpf.md)
