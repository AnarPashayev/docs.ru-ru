---
title: Подробное описание синтаксиса XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XML [WPF], namespaces
- XAML [WPF], parsing of attributes
- parsing of attributes [WPF]
- XAML [WPF], markup extensions
- attached properties [WPF]
- tag syntax [XAML]
- markup extensions [WPF]
- XAML [WPF], object element syntax
- XAML [WPF], syntax terminology
- attached events [WPF]
- lookup semantics [WPF]
- XAML [WPF], attached events
- XAML [WPF], content syntax
- XAML [WPF], lookup semantics
- content syntax [WPF]
- object element syntax [WPF]
- syntax terminology [XAML]
- XAML [WPF], attached properties
- attributes [XAML], parsing
- XAML [WPF], tag syntax
- XAML [WPF], attribute syntax
- property element syntax [WPF]
- terminology [XAML]
- namespaces [WPF], XML
- attribute syntax [XAML]
- XAML [WPF], property element syntax
ms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479
ms.openlocfilehash: 38c77086075e79c0ec5b4b1564ed753eded23b34
ms.sourcegitcommit: 011314e0c8eb4cf4a11d92078f58176c8c3efd2d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/11/2020
ms.locfileid: "77124498"
---
# <a name="xaml-syntax-in-detail"></a>Подробное описание синтаксиса XAML
В этом разделе определяются термины, используемые для описания элементов синтаксиса XAML. Эти термины часто используются в оставшейся части этой документации как для документации по WPF, так и для других платформ, использующих XAML, или базовых понятий XAML, включенных в поддержку языка XAML на уровне System. XAML. Этот раздел расширяет базовую терминологию, представленную в разделе [Общие сведения о XAML (WPF)](../../../desktop-wpf/fundamentals/xaml.md).  

<a name="the_xaml_language_specification"></a>   
## <a name="the-xaml-language-specification"></a>Спецификация языка XAML  
 Определенная здесь терминология синтаксиса XAML также определяется или указывается в спецификации языка XAML. XAML — это язык, основанный на XML, который следует за или расширяет согласно структурным правилам XML. Часть терминологии совместно используется или основана на терминологии, часто используемой при описании языка XML или объектной модели XML-документа.  
  
 Чтобы получить дополнительные сведения о спецификации языка XAML, скачайте [\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf) из центра загрузки Майкрософт.  
  
<a name="xaml_and_clr"></a>   
## <a name="xaml-and-clr"></a>XAML и CLR  
 XAML — это язык разметки. Среда CLR, как подразумевается ее имя, обеспечивает выполнение среды выполнения. XAML сам по себе не является одним из общих языков, которые напрямую используются средой CLR. Вместо этого XAML можно представить как поддерживающий собственную систему типов. Конкретная система анализа XAML, используемая WPF, основана на CLR и системе типов CLR. Типы XAML сопоставляются с типами CLR для создания экземпляра представления времени выполнения при синтаксическом анализе XAML для WPF. По этой причине в оставшейся части обсуждения синтаксиса в этом документе будут содержаться ссылки на систему типов CLR, несмотря на то, что аналогичные обсуждения синтаксиса в спецификации языка XAML не имеют. (На уровне спецификации языка XAML типы XAML могут быть сопоставлены с любой другой системой типов, которая не обязательно должна быть средой CLR, но для этого потребуется создание и использование другого средства синтаксического анализа XAML.)  
  
#### <a name="members-of-types-and-class-inheritance"></a>Члены типов и наследование классов  
 Свойства и события, отображаемые как члены XAML типа [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], часто наследуются от базовых типов. Например, рассмотрим следующий пример: `<Button Background="Blue" .../>`. Свойство <xref:System.Windows.Controls.Control.Background%2A> не является немедленно объявленным свойством класса <xref:System.Windows.Controls.Button>, если бы вы искали определение класса, результаты отражения или документацию. Вместо этого <xref:System.Windows.Controls.Control.Background%2A> наследуется от базового класса <xref:System.Windows.Controls.Control>.  
  
 Поведение наследования класса [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] элементов XAML значительно отличается от интерпретации XML-разметки с применением схемы. Наследование класса может стать сложным, особенно если промежуточные базовые классы являются абстрактными или используются интерфейсы. Это одна из причин того, что набор элементов XAML и их допустимых атрибутов трудно представить точно и полностью с помощью типов схем, которые обычно используются для программирования XML, например, в формате DTD или XSD. Другая причина заключается в том, что функции расширяемости и сопоставления типов в самом языке XAML не позволяют гарантировать полноту какого-либо фиксированного представления допустимых типов и членов.  
  
<a name="object_element_syntax"></a>   
## <a name="object-element-syntax"></a>Синтаксис объектных элементов  
 *Синтаксис элемента объекта* — это синтаксис разметки XAML, создающий экземпляр класса или структуры среды CLR путем объявления элемента XML. Этот синтаксис напоминает синтаксис элементов других языков разметки, таких как HTML. Синтаксис объектного элемента начинается с левой угловой скобки (\<), за которым следует сразу же имя типа класса или структуры, для которой создается экземпляр. После имени типа может содержаться ноль или более пробелов. Кроме того, в элементе Object могут быть объявлены ноль или более атрибутов с одним или несколькими пробелами, разделяющими каждую пару "имя атрибута =" значение ". Наконец, должно выполняться одно из следующих условий:  
  
- Элемент и тег должны быть закрыты косой чертой (/), за которой следует правая угловая скобка (>).  
  
- Открывающий тег должен быть заполнен правой угловой скобкой (>). Другие элементы объекта, элементы свойств или внутренний текст могут следовать за открывающим тегом. Именно содержимое, которое может содержаться здесь, обычно ограничено объектной моделью элемента. Эквивалентный закрывающий тег для объектного элемента также должен существовать в правильном вложении и сбалансировать с другими открывающими и закрывающими парами тегов.  
  
 XAML, реализованный в .NET, имеет набор правил, которые сопоставляют элементы объекта с типами, атрибутами в свойствах или событиях, а также пространства имен XAML для пространств имен CLR и сборки. Для WPF и .NET элементы объектов XAML сопоставляются с типами .NET в соответствии с определением в ссылочных сборках, а атрибуты сопоставляются с элементами этих типов. При ссылке на тип CLR в XAML у вас также есть доступ к унаследованным членам этого типа.  
  
 Например, следующий пример представляет собой синтаксис элемента объекта, который создает новый экземпляр класса <xref:System.Windows.Controls.Button>, а также задает атрибут <xref:System.Windows.FrameworkElement.Name%2A> и значение для этого атрибута:  
  
 [!code-xaml[XAMLOvwSupport#SyntaxOE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxoe)]  
  
 В следующем примере показан синтаксис элемента объекта, который также включает синтаксис свойства содержимого XAML. Внутренний текст, содержащийся в, будет использоваться для задания свойства <xref:System.Windows.Controls.TextBox>ого содержимого XAML <xref:System.Windows.Controls.TextBox.Text%2A>.  
  
 [!code-xaml[XAMLOvwSupport#ThisIsATextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#thisisatextbox)]  
  
### <a name="content-models"></a>Модели содержимого  
 Класс может поддерживать использование как объектного элемента XAML с точки зрения синтаксиса, но этот элемент будет работать правильно только в приложении или странице, когда он помещается в ожидаемую точку общей модели содержимого или дерева элементов. Например, <xref:System.Windows.Controls.MenuItem> обычно следует размещать только в качестве дочернего элемента <xref:System.Windows.Controls.Primitives.MenuBase> производного класса, например <xref:System.Windows.Controls.Menu>. Модели содержимого для конкретных элементов задокументированы как часть примечаний на страницах классов элементов управления и других [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] классов, которые могут использоваться в качестве элементов XAML.  
  
<a name="properties_of_object_elements"></a>   
## <a name="properties-of-object-elements"></a>Свойства элементов Object  
 Свойства в XAML задаются различными возможными синтаксисами. Синтаксис, который может использоваться для конкретного свойства, зависит от системных характеристик базового типа свойства, которое вы устанавливаете.  
  
 Устанавливая значения свойств, вы добавляете компоненты или характеристики в объекты, так как они существуют в графе объектов времени выполнения. Начальное состояние созданного объекта из объектного элемента основано на поведении конструктора без параметров. Как правило, приложение будет использовать нечто, отличное от полного экземпляра по умолчанию любого заданного объекта.  
  
<a name="attribute_syntax_properties"></a>   
## <a name="attribute-syntax-properties"></a>Синтаксис атрибутов (свойства)  
 Синтаксис атрибутов — это синтаксис разметки XAML, который задает значение для свойства путем объявления атрибута для существующего объектного элемента. Имя атрибута должно совпадать с именем члена CLR свойства класса, который создает соответствующий элемент объекта. За именем атрибута следует оператор присваивания (=). Значение атрибута должно быть строкой, заключенной в кавычки.  
  
> [!NOTE]
> С помощью альтернативных кавычек можно поместить литеральную кавычку в атрибут. Например, можно использовать одинарные кавычки в качестве средства для объявления строки, содержащей символ двойной кавычки в нем. Независимо от того, используются ли одинарные или двойные кавычки, следует использовать совпадающую пару для открытия и закрытия строки значения атрибута. Существуют также escape-последовательности или другие методы, доступные для обхода ограничений по символам, накладываемых любым конкретным синтаксисом XAML. См. раздел [сущности символов XML и XAML](../../../desktop-wpf/xaml-services/xml-character-entities.md).  
  
 Для настройки с помощью синтаксиса атрибутов свойство должно быть открытым и должно быть доступно для записи. Значение свойства в системе резервных типов должно быть типом значения или ссылочным типом, который может быть создан или указан в обработчике XAML при доступе к соответствующему резервному типу.  
  
 Для событий WPF XAML событие, на которое ссылается имя атрибута, должно быть открытым и иметь открытый делегат.  
  
 Свойство или событие должно быть членом класса или структуры, экземпляры которых создаются содержащим его элементом Object.  
  
### <a name="processing-of-attribute-values"></a>Обработка значений атрибутов  
 Строковое значение, содержащееся в открывающих и закрывающих кавычках, обрабатывается обработчиком XAML. Для свойств поведение обработки по умолчанию определяется типом базового свойства CLR.  
  
 Значение атрибута заполняется одним из следующих значений с использованием этого порядка обработки:  
  
1. Если обработчик XAML встречает фигурную скобку или элемент объекта, производный от <xref:System.Windows.Markup.MarkupExtension>, то расширение разметки, на которое указывает ссылка, вычисляется первыми вместо обработки значения в виде строки, а объект, возвращаемый расширением разметки, используется в качестве значения. Во многих случаях объект, возвращаемый расширением разметки, будет ссылкой на существующий объект или выражение, которое откладывает вычисление до времени выполнения и не является новым экземпляром объекта.  
  
2. Если свойство объявлено с <xref:System.ComponentModel.TypeConverter>с атрибутом или тип значения этого свойства объявлен с <xref:System.ComponentModel.TypeConverter>с атрибутом, строковое значение атрибута передается в преобразователь типов в качестве входных данных преобразования, а преобразователь возвращает новый экземпляр объекта.  
  
3. Если <xref:System.ComponentModel.TypeConverter>нет, предпринимается попытка прямого преобразования в тип свойства. Этот последний уровень является прямым преобразованием в собственном значении синтаксического анализатора между типами примитивов языка XAML или проверки имен именованных констант в перечислении (средство синтаксического анализа обращается к соответствующим значениям).  
  
#### <a name="enumeration-attribute-values"></a>Значения атрибутов перечисления  
 Перечисления в XAML обрабатываются внутренне средствами синтаксического анализа XAML, а элементы перечисления должны быть указаны путем указания имени строки одной из именованных констант перечисления.  
  
 Для непомеченных значений перечисления поведение в собственном режиме заключается в обработке строки значения атрибута и ее разрешении в одно из значений перечисления. Перечисление не указывается в *перечислении*Format. *Значение*, как и в коде. Вместо этого указывается только *значение*, а *перечисление* выводится типом свойства, которое вы устанавливаете. При указании атрибута в *перечислении*. Форма *значения* , она будет разрешаться неправильно.  
  
 Для перечислений флагового поведение основано на методе <xref:System.Enum.Parse%2A?displayProperty=nameWithType>. Можно указать несколько значений для перечисления флагового, разделяя каждое значение запятой. Однако нельзя сочетать значения перечисления, которые не являются флагового. Например, нельзя использовать синтаксис с запятой для создания <xref:System.Windows.Trigger>, который действует с несколькими условиями перечисления, не являющегося флагом:  
  
```xaml  
<!--This will not compile, because Visibility is not a flagwise enumeration.-->  
...  
<Trigger Property="Visibility" Value="Collapsed,Hidden">  
  <Setter ... />  
</Trigger>  
...  
```  
  
 Перечисления флагового, поддерживающие атрибуты, устанавливаемые в XAML, редко встречаются в WPF. Однако одно такое перечисление — <xref:System.Windows.Media.StyleSimulations>. Например, можно использовать синтаксис атрибута флагового с разделителями-запятыми для изменения примера, приведенного в комментариях к классу <xref:System.Windows.Documents.Glyphs>. `StyleSimulations = "BoldSimulation"` может быть `StyleSimulations = "BoldSimulation,ItalicSimulation"`. <xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> — это еще одно свойство, в котором можно указать несколько значений перечисления. Однако это свойство является особым случаем, так как перечисление <xref:System.Windows.Input.ModifierKeys> поддерживает собственный преобразователь типов. Преобразователь типов для модификаторов использует знак плюс (+) в качестве разделителя, а не запятую (,). Это преобразование поддерживает более традиционный синтаксис для представления сочетаний клавиш в программировании Microsoft Windows, например "Ctrl + Alt".  
  
### <a name="properties-and-event-member-name-references"></a>Ссылки на свойства и имена членов событий  
 При указании атрибута можно ссылаться на любое свойство или событие, которое существует в качестве члена типа CLR, созданного для содержащего объектного элемента.  
  
 Или можно сослаться на присоединенное свойство или присоединенное событие независимо от содержащего его элемента Object. (Присоединенные свойства обсуждаются в следующем разделе.)  
  
 Можно также присвоить любое событие любому объекту, доступному через пространство имен по умолчанию, с помощью имени *типа*. частично определенное имя *события* ; Этот синтаксис поддерживает присоединение обработчиков для перенаправленных событий, когда обработчик предназначен для обработки маршрутизации событий из дочерних элементов, но родительский элемент также не имеет этого события в таблице Members. Этот синтаксис напоминает синтаксис присоединенного события, но событие здесь не является настоящим вложенным событием. Вместо этого вы ссылаетесь на событие с полным именем. Дополнительные сведения см. в разделе [Общие сведения о перенаправленных событиях](routed-events-overview.md).  
  
 В некоторых сценариях имена свойств иногда предоставляются как значение атрибута, а не имя атрибута. Это имя свойства также может включать квалификаторы, например свойство, указанное в формате *OwnerType*. *депенденципропертинаме*. Этот сценарий часто используется при написании стилей или шаблонов в XAML. Правила обработки имен свойств, указанных в качестве значений атрибутов, отличаются и определяются типом устанавливаемого свойства или поведением конкретных подсистем WPF. Дополнительные сведения см. в разделе [Стилизация и создание шаблонов](../controls/styling-and-templating.md).  
  
 Еще одним использованием имен свойств является то, что значение атрибута описывает связь свойств свойства. Эта функция используется для привязки данных и для целей раскадровки и включается классом <xref:System.Windows.PropertyPath> и его преобразователем типов. Более полное описание семантики уточняющего запроса см. в разделе [синтаксис языка XAML PropertyPath](propertypath-xaml-syntax.md).  
  
<a name="property_element_syntax"></a>   
## <a name="property-element-syntax"></a>Синтаксис элемента свойства  
 *Синтаксис элемента свойства* — это синтаксис, который отличается от основных правил синтаксиса XML для элементов. В XML значением атрибута является строка де-факто с единственной возможной вариацией, в которой используется формат кодировки строк. В XAML можно назначить другие элементы объекта в качестве значения свойства. Эта возможность включается с помощью синтаксиса элемента свойства. Вместо свойства, указанного в качестве атрибута в теге элемента, свойство указывается с помощью открывающего тега элемента в *елементтипенаме*. *PropertyName* Form, значение свойства указывается в, а затем элемент свойства закрывается.  
  
 В частности, синтаксис начинается с левой угловой скобки (\<), за которым следует сразу же имя типа класса или структуры, в которой содержится синтаксис элемента свойства. За ним следует одиночная точка (.), затем по имени свойства, а затем по правой угловой скобке (>). Как и при использовании синтаксиса атрибутов, это свойство должно существовать в объявленных открытых членах указанного типа. Значение, присваиваемое свойству, содержится в элементе Property. Как правило, значение задается как один или несколько объектных элементов, так как указание объектов в качестве значений является сценарием, которому предназначен синтаксис элемента свойства. И, наконец, эквивалентный закрывающий тег, указывающий тот же *елементтипенаме*. необходимо указать сочетание *PropertyName* , правильно вложенное и сбалансировать с другими тегами элементов.  
  
 Например, ниже приведен синтаксис элемента свойства для свойства <xref:System.Windows.FrameworkElement.ContextMenu%2A> <xref:System.Windows.Controls.Button>.  
  
 [!code-xaml[XAMLOvwSupport#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#contextmenu)]  
  
 Значение в элементе свойства также может быть задано как внутренний текст, в случаях, когда указанный тип свойства является примитивным типом значения, например <xref:System.String>, или перечислением, где указано имя. Эти два варианта использования довольно редки, так как в каждом из этих случаев также может использоваться более простой синтаксис атрибутов. Один из сценариев заполнения элемента Property строкой предназначен для свойств, которые не являются свойством содержимого XAML, но по-прежнему используются для представления текста пользовательского интерфейса, а определенные элементы пробела, такие как символы перевода строки, должны отображаться в тексте пользовательского интерфейса. Синтаксис атрибутов не может сохранять символы перевода строки, но синтаксис элемента свойства может быть настолько длиннее, насколько активна незначительная сохранность пробелов (Дополнительные сведения см. [в разделе Обработка пробелов в XAML](../../../desktop-wpf/xaml-services/white-space-processing.md)). Другой сценарий заключается в том, что [директиву x:UID](../../../desktop-wpf/xaml-services/xuid-directive.md) можно применить к элементу Property и, таким образом, пометить значение в качестве значения, которое должно быть локализовано в выходных данных WPF BAML или другими методами.  
  
 Элемент свойства не представлен в логическом дереве WPF. Элемент Property — это просто определенный синтаксис для установки свойства, который не является элементом, имеющим резервный экземпляр или объект. (Дополнительные сведения о концепции логического дерева см. в разделе [деревья в WPF](trees-in-wpf.md).)  
  
 Для свойств, в которых поддерживаются и атрибут, и синтаксис элемента свойства, два синтаксиса обычно имеют одинаковый результат, хотя такие тонкости, как обработка пробелов, могут незначительно различаться в синтаксисе.  
  
<a name="collection_syntax"></a>   
## <a name="collection-syntax"></a>Синтаксис коллекции  
 Спецификация XAML требует реализации процессора XAML для определения свойств, в которых тип значения является коллекцией. Общая реализация процессора XAML в .NET основана на управляемом коде и среде CLR и определяет типы коллекций одним из следующих методов:  
  
- Тип реализует <xref:System.Collections.IList>.  
  
- Тип реализует <xref:System.Collections.IDictionary>.  
  
- Тип является производным от <xref:System.Array> (Дополнительные сведения о массивах в XAML см. в разделе [расширение разметки x:Array](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)  
  
 Если тип свойства является коллекцией, то выводимый тип коллекции не обязательно указывать в разметке как элемент объекта. Вместо этого элементы, которые должны стать элементами коллекции, задаются как один или несколько дочерних элементов элемента Property. Каждый такой элемент вычисляется в объект во время загрузки и добавляется в коллекцию путем вызова метода `Add` неявной коллекции. Например, свойство <xref:System.Windows.Style.Triggers%2A> <xref:System.Windows.Style> принимает специализированный тип коллекции <xref:System.Windows.TriggerCollection>, который реализует <xref:System.Collections.IList>. Нет необходимости в создании экземпляра элемента объекта <xref:System.Windows.TriggerCollection> в разметке. Вместо этого вы указываете один или несколько элементов <xref:System.Windows.Trigger> как элементы в элементе свойства `Style.Triggers`, где <xref:System.Windows.Trigger> (или производный класс) является типом, ожидаемым типом элемента для строго типизированного и неявного <xref:System.Windows.TriggerCollection>.  
  
 [!code-xaml[XAMLOvwSupport#SyntaxPECollection](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxpecollection)]  
  
 Свойство может быть как типом коллекции, так и свойством содержимого XAML для этого типа и производных типов, о которых рассказывается в следующем разделе этой статьи.  
  
 Неявный элемент коллекции создает элемент в представлении логического дерева, даже если он не отображается в разметке как элемент. Обычно конструктор родительского типа выполняет создание экземпляра для коллекции, которая является одним из ее свойств, а начальная пустая коллекция становится частью дерева объектов.  
  
> [!NOTE]
> Интерфейсы универсального списка и словаря (<xref:System.Collections.Generic.IList%601> и <xref:System.Collections.Generic.IDictionary%602>) не поддерживаются при обнаружении коллекции. Однако класс <xref:System.Collections.Generic.List%601> можно использовать в качестве базового класса, поскольку он реализует <xref:System.Collections.IList> напрямую или <xref:System.Collections.Generic.Dictionary%602> как базовый класс, так как он реализует <xref:System.Collections.IDictionary> напрямую.  
  
 На справочных страницах .NET для типов коллекций этот синтаксис с намеренным опущенным элементом объекта для коллекции иногда отмечается в разделах синтаксиса XAML как неявный синтаксис коллекции.  
  
 За исключением корневого элемента, каждый объектный элемент в файле XAML, вложенный в качестве дочернего элемента другого элемента, на самом деле является элементом, который является одним или обоими в следующих случаях: членом неявного свойства коллекции своего родительского элемента. или элемент, указывающий значение свойства содержимого XAML для родительского элемента (свойства содержимого XAML будут обсуждаться в следующем разделе). Иными словами, связь между родительскими и дочерними элементами на странице разметки на самом деле является одним объектом в корне, а каждый объектный элемент под корнем является либо единственным экземпляром, предоставляющим значение свойства родителя, либо одним из элементов в столбце. лектион, который также является значением свойства типа коллекции для родителя. Это понятие с одним корнем, которое обычно используется в XML и часто прикрепляется к поведению интерфейсов API, которые загружают XAML, например <xref:System.Windows.Markup.XamlReader.Load%2A>.  
  
 В следующем примере показан синтаксис с элементом Object для коллекции (<xref:System.Windows.Media.GradientStopCollection>), указанной явным образом.  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <GradientStopCollection>  
      <GradientStop Offset="0.0" Color="Red" />  
      <GradientStop Offset="1.0" Color="Blue" />  
    </GradientStopCollection>  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
 Обратите внимание, что не всегда можно явно объявлять коллекцию. Например, попытка объявить <xref:System.Windows.TriggerCollection> явно в ранее показанном <xref:System.Windows.Style.Triggers%2A> примере приведет к сбою. Для явного объявления коллекции необходимо, чтобы класс коллекции поддерживал конструктор без параметров, а <xref:System.Windows.TriggerCollection> не имеет конструктора без параметров.  
  
<a name="xaml_content_properties"></a>   
## <a name="xaml-content-properties"></a>Свойства содержимого XAML  
 Синтаксис содержимого XAML — это синтаксис, который включается только для классов, указывающих <xref:System.Windows.Markup.ContentPropertyAttribute> как часть объявления класса. <xref:System.Windows.Markup.ContentPropertyAttribute> ссылается на имя свойства, которое является свойством содержимого для этого типа элемента (включая производные классы). При обработке обработчиком XAML все дочерние элементы или внутренний текст, найденный между открывающим и закрывающим тегами элемента Object, будут назначены в качестве значения свойства содержимого XAML для этого объекта. Вы имеете разрешение указывать явные элементы свойств для свойства содержимого, но это использование не показано в разделах синтаксиса XAML в справочнике по .NET. Метод Explicit/verbose имеет случайное значение для ясности разметки или для стиля разметки, но обычно целью свойства содержимого является упрощение разметки, чтобы элементы, интуитивно связанные как родители-потомки, могли быть вложены напрямую. Теги элементов свойств для других свойств элемента не присваиваются как "содержимое" в соответствии с определенным определением языка XAML; они обрабатываются ранее в порядке обработки средства синтаксического анализа XAML и не считаются "содержимым".  
  
### <a name="xaml-content-property-values-must-be-contiguous"></a>Значения свойств содержимого XAML должны быть непрерывными  
 Значение свойства содержимого XAML должно быть задано либо полностью до, либо полностью после любых других элементов свойств в этом элементе Object. Это справедливо, если значение свойства содержимого XAML указано как строка или как один или несколько объектов. Например, следующая разметка не выполняет синтаксический анализ:  
  
```xaml  
<Button>I am a   
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 Это недопустимо, поскольку если этот синтаксис был сделан явным с помощью синтаксиса элемента свойства для свойства содержимого, свойство Content будет установлено дважды:  
  
```xaml  
<Button>  
  <Button.Content>I am a </Button.Content>  
  <Button.Background>Blue</Button.Background>  
  <Button.Content> blue button</Button.Content>  
</Button>  
```  
  
 Аналогичным образом является недопустимый пример, если свойство Content является коллекцией, а дочерние элементы помещаются в элементы свойств:  
  
```xaml  
<StackPanel>  
  <Button>This example</Button>  
  <StackPanel.Resources>  
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>  
  </StackPanel.Resources>  
  <Button>... is illegal XAML</Button>  
</StackPanel>  
```  
  
<a name="content_properties_and_collection_syntax_combined"></a>   
## <a name="content-properties-and-collection-syntax-combined"></a>Объединение свойства содержимого и синтаксиса коллекции  
 Чтобы принимать больше одного элемента объекта в качестве содержимого, тип свойства содержимого должен быть типом коллекции. Подобно синтаксису элементов свойств для типов коллекций, обработчик XAML должен указывать типы, которые являются типами коллекций. Если элемент имеет свойство содержимого XAML и тип свойства содержимого XAML является коллекцией, то неявный тип коллекции не обязательно указывать в разметке как элемент объекта, а свойство содержимого XAML не нужно указывать как свойство El. правления. Поэтому в качестве содержимого может быть назначено более одного дочернего элемента в разметке. Ниже приведен синтаксис содержимого для <xref:System.Windows.Controls.Panel> производного класса. Все <xref:System.Windows.Controls.Panel> производные классы устанавливают свойство содержимого XAML для <xref:System.Windows.Controls.Panel.Children%2A>, что требует значения типа <xref:System.Windows.Controls.UIElementCollection>.  
  
 [!code-xaml[XAMLOvwSupport#SyntaxContent](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page5.xaml#syntaxcontent)]  
  
 Обратите внимание, что ни элемент свойства для <xref:System.Windows.Controls.Panel.Children%2A>, ни элемент для <xref:System.Windows.Controls.UIElementCollection> не требуется в разметке. Это функция разработки XAML, позволяющая рекурсивно содержали элементы, определяющие [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], более интуитивно представленными в виде дерева вложенных элементов с непосредственными связями между родительскими и дочерними элементами без промежуточных тегов элементов свойств или объектов коллекции. На самом деле <xref:System.Windows.Controls.UIElementCollection> не может быть явно указана в разметке как элемент объекта, по дизайну. Поскольку используется только в качестве неявной коллекции, <xref:System.Windows.Controls.UIElementCollection> не предоставляет общедоступный конструктор без параметров и, таким образом, не может быть создан как объектный элемент.  
  
### <a name="mixing-property-elements-and-object-elements-in-an-object-with-a-content-property"></a>Смешивание элементов свойств и объектных элементов в объекте со свойством содержимого  
 В спецификации XAML объявляется, что обработчик XAML может принудительно применять элементы объекта, используемые для заполнения свойства содержимого XAML в элементе Object, должен быть непрерывным и не должен быть смешанным. Это ограничение для смешивания элементов свойств и содержимого обеспечивается [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] обработчиками XAML.  
  
 В качестве первой немедленной разметки в элементе Object можно использовать дочерний элемент Object. Затем можно ввести элементы свойств. Или можно указать один или несколько элементов свойств, затем содержимое, а затем дополнительные элементы свойств. Но после того, как элемент свойства последует за содержимым, вы не можете добавить никакого содержимого, но можно добавлять только элементы свойств.  
  
 Это требование порядка элементов свойства и содержимого не применяется к внутреннему тексту, используемому в качестве содержимого. Тем не менее, он по-прежнему является хорошим стилем разметки для сохранения внутреннего текста непрерывно, поскольку значащий пробел будет трудно обнаружить визуально в разметке, если элементы свойств поделены внутренним текстом.  
  
<a name="xaml_namespaces"></a>   
## <a name="xaml-namespaces"></a>Пространства имен языка XAML  
 Ни один из предыдущих примеров синтаксиса не указал пространство имен XAML, отличное от пространства имен XAML по умолчанию. В типичных [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] приложениях пространство имен XAML по умолчанию задается как пространство имен [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. Можно указать пространства имен XAML, отличные от пространства имен XAML по умолчанию, и по-прежнему использовать аналогичный синтаксис. Но в любом месте, где имя класса недоступно в пространстве имен XAML по умолчанию, этому имени класса должен предшествовать префикс пространства имен XAML, сопоставленный с соответствующим пространством имен CLR. Например, `<custom:Example/>` является синтаксисом объектного элемента для создания экземпляра класса `Example`, где пространство имен CLR, содержащее этот класс (и, возможно, сведения о внешней сборке, содержащие резервные типы), было ранее сопоставлено с префиксом `custom`.  
  
 Дополнительные сведения о пространствах имен XAML см. в разделе [пространства имен и сопоставление пространств имен XAML для WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).  
  
<a name="markup_extensions"></a>   
## <a name="markup-extensions"></a>Расширения разметки  
 XAML определяет сущность для программирования расширения разметки, которая обеспечивает escape-обработку от обычного обработчика XAML значений строковых атрибутов или элементов объектов, а также откладывает обработку на резервный класс. Символ, определяющий расширение разметки для обработчика XAML при использовании синтаксиса атрибутов, — это открывающая фигурная скобка ({), за которой следует любой символ, отличный от закрывающей фигурной скобки (}). Первая строка, следующая за открывающей фигурной скобкой, должна ссылаться на класс, предоставляющий конкретное поведение расширения, где ссылка может опускать подстроку "Extension", если эта подстрока является частью истинного имени класса. После этого может появиться одно пространство, а затем каждый последующий символ будет использоваться в качестве входных данных реализацией расширения до тех пор, пока не будет обнаружена закрывающая фигурная скобка.  
  
 Реализация XAML в .NET использует абстрактный класс <xref:System.Windows.Markup.MarkupExtension> как основу для всех расширений разметки, поддерживаемых [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], а также другими платформами или технологиями. Расширения разметки, которые [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] специально реализованы, часто предназначены для предоставления средств для ссылки на другие существующие объекты или для предоставления отложенных ссылок на объекты, которые будут вычисляться во время выполнения. Например, простая привязка данных WPF достигается путем указания `{Binding}` расширения разметки вместо значения, которое обычно принимает конкретное свойство. Многие расширения разметки WPF позволяют использовать синтаксис атрибутов для свойств, в которых использование синтаксиса атрибутов не было бы возможным. Например, объект <xref:System.Windows.Style> является относительно сложным типом, который содержит вложенные последовательности объектов и свойств. Стили в WPF обычно определяются как ресурс в <xref:System.Windows.ResourceDictionary>, а затем указываются через одно из двух расширений разметки WPF, запрашивающих ресурс. Расширение разметки откладывает оценку значения свойства на Уточняющий запрос ресурса и позволяет предоставить значение свойства <xref:System.Windows.FrameworkElement.Style%2A>, принимая в синтаксисе атрибута тип <xref:System.Windows.Style>, как показано в следующем примере:  
  
 `<Button Style="{StaticResource MyStyle}">My button</Button>`  
  
 Здесь `StaticResource` идентифицирует класс <xref:System.Windows.StaticResourceExtension>, предоставляющий реализацию расширения разметки. Следующая строка `MyStyle` используется в качестве входных данных для конструктора <xref:System.Windows.StaticResourceExtension>, отличного от по умолчанию, где параметр, взятый из строки расширения, объявляет запрошенную <xref:System.Windows.ResourceKey>. Предполагается, что `MyStyle` является значением [x:Key](../../../desktop-wpf/xaml-services/xkey-directive.md) <xref:System.Windows.Style> определенного как ресурс. Использование [расширения разметки StaticResource](staticresource-markup-extension.md) требует, чтобы ресурс использовался для предоставления значения свойства <xref:System.Windows.Style> через логику поиска статических ресурсов во время загрузки.  
  
 Подробнее о расширениях разметки см. в разделе [Расширения разметки и XAML WPF](markup-extensions-and-wpf-xaml.md). Ссылки на расширения разметки и другие функции программирования XAML, включенные в общей реализации .NET XAML, см. в разделе [пространство имен XAML (x:). Функции языка](../../../desktop-wpf/xaml-services/namespace-language-features.md). Сведения о расширениях разметки WPF см. в разделе [расширения XAML WPF](wpf-xaml-extensions.md).  
  
<a name="attached_properties"></a>   
## <a name="attached-properties"></a>Вложенные свойства  
 Присоединенные свойства — это концепция программирования, появившаяся в XAML, при которой свойства могут принадлежать определенному типу, но устанавливаться в качестве атрибутов или элементов свойств в любом элементе. Основной сценарий, в котором присоединенные свойства предназначены для, — включить дочерние элементы в структуре разметки для передачи информации родительскому элементу, не требуя совместного использования объектной модели для всех элементов. И наоборот, вложенные свойства могут использоваться родительскими элементами для передачи сведений дочерним элементам. Дополнительные сведения о назначении присоединенных свойств и о создании собственных присоединенных свойств см. в разделе [Общие сведения о вложенных](attached-properties-overview.md)свойствах.  
  
 Присоединенные свойства используют синтаксис, который внешне напоминает синтаксис элемента свойства, в котором также указывается *имя TypeName*. *PropertyName* . Однако имеется два важных отличия.  
  
- Можно использовать *имя TypeName*. *PropertyName* — даже при задании присоединенного свойства с помощью синтаксиса атрибутов. Присоединенные свойства — это единственный случай, когда уточнение имени свойства является обязательным в синтаксисе атрибута.  
  
- Для присоединенных свойств также можно использовать синтаксис элемента свойства. Однако для типичного синтаксиса элемента свойства указываемое *имя TypeName* является элементом объекта, содержащим элемент Property. Если вы ссылаетесь на присоединенное свойство, то *TypeName* является классом, который определяет присоединенное свойство, а не содержащий его элемент.  
  
<a name="attached_events"></a>   
## <a name="attached-events"></a>Вложенные события  
 Вложенные события — это еще одна концепция программирования, появившаяся в XAML, где события могут быть определены определенным типом, но обработчики могут быть присоединены к любому элементу Object. В реализации ВОФ тип, определяющий присоединенное событие, часто является статическим типом, определяющим службу, и иногда эти вложенные события предоставляются псевдонимом перенаправленных событий в типах, которые предоставляют службу. Обработчики для вложенных событий задаются с помощью синтаксиса атрибутов. Как и в случае с присоединенными событиями, синтаксис атрибута разворачивается для вложенных событий, чтобы разрешить *имя типа*. *EventName* использование, где *TypeName* — это класс, предоставляющий `Add` и `Remove` методы доступа обработчика событий для инфраструктуры подключаемых событий, а *EventName* — это имя события.  
  
<a name="anatomy_of_a_xaml_page_root_element"></a>   
## <a name="anatomy-of-a-xaml-root-element"></a>Анатомия корневого элемента XAML  
 В следующей таблице показан типичный корневой элемент XAML, в котором показаны определенные атрибуты корневого элемента:  
  
|||  
|-|-|  
|`<Page`|Открытие объектного элемента корневого элемента|  
|`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`|Пространство имен XAML по умолчанию ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)])|  
|`xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`|Пространство имен XAML языка XAML|  
|`x:Class="ExampleNamespace.ExampleCode"`|Объявление разделяемого класса, которое соединяет разметку с кодом программной части, определенными для разделяемого класса|  
|`>`|Конец элемента Object для корня. Объект еще не закрыт, так как элемент содержит дочерние элементы|  
  
<a name="optional_and_nonrecommended_xaml_usages"></a>   
## <a name="optional-and-nonrecommended-xaml-usages"></a>Необязательные и нерекомендуемые использования XAML  
 В следующих разделах описываются случаи использования XAML, которые технически поддерживаются обработчиками XAML, но они создают подробные сведения или другие Aesthetic проблемы, которые мешают работе с файлами XAML, остающимися для чтения человеком при разработке приложений, содержащих источники XAML.  
  
### <a name="optional-property-element-usages"></a>Необязательные использование элементов свойств  
 Необязательные использования элементов свойств включают явное Написание свойств содержимого элементов, которые обработчик XAML считает неявным. Например, при объявлении содержимого <xref:System.Windows.Controls.Menu>можно явно объявить <xref:System.Windows.Controls.ItemsControl.Items%2A> коллекцию <xref:System.Windows.Controls.Menu> как тег элемента свойства `<Menu.Items>` и поместить каждую <xref:System.Windows.Controls.MenuItem> в `<Menu.Items>`, вместо использования неявного поведения обработчика XAML, чтобы все дочерние элементы <xref:System.Windows.Controls.Menu> должны быть <xref:System.Windows.Controls.MenuItem> и помещены в коллекцию <xref:System.Windows.Controls.ItemsControl.Items%2A>. Иногда необязательное использование может помочь визуально уточнить структуру объекта, представленную в разметке. Или иногда использование явного элемента свойства может не допустить технически функциональной разметки, такой как вложенные расширения разметки в значении атрибута.  
  
### <a name="full-typenamemembername-qualified-attributes"></a>Полные атрибуты typeName. memberName  
 *Имя типа*. Функция *MemberName* для атрибута в действительности работает более универсально, чем только вариант перенаправленного события. Но в других ситуациях этот формат является излишним, и его следует избегать, если только причина стиля разметки и удобства чтения. В следующем примере каждая из трех ссылок на <xref:System.Windows.Controls.Control.Background%2A> атрибут полностью эквивалентна:  
  
 [!code-xaml[XAMLOvwSupport#TypeNameProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenameprop)]  
  
 `Button.Background` работает, так как квалифицированный Уточняющий запрос для этого свойства в <xref:System.Windows.Controls.Button> прошел успешно (<xref:System.Windows.Controls.Control.Background%2A> наследуется от Control), а <xref:System.Windows.Controls.Button> является классом элемента Object или базовым классом. `Control.Background` работает, поскольку класс <xref:System.Windows.Controls.Control> фактически определяет <xref:System.Windows.Controls.Control.Background%2A> и <xref:System.Windows.Controls.Control> является базовым классом <xref:System.Windows.Controls.Button>.  
  
 Однако приведенное ниже *имя TypeName*. Пример *MemberName* Form не работает и поэтому отображается с комментариями:  
  
 [!code-xaml[XAMLOvwSupport#TypeNameBadProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenamebadprop)]  
  
 <xref:System.Windows.Controls.Label> является другим производным классом <xref:System.Windows.Controls.Control>и, если вы указали `Label.Background` в элементе объекта <xref:System.Windows.Controls.Label>, это использование было бы работало. Однако, поскольку <xref:System.Windows.Controls.Label> не является классом или базовым классом <xref:System.Windows.Controls.Button>, заданное поведение обработчика XAML будет обрабатывать `Label.Background` как присоединенное свойство. `Label.Background` не является доступным присоединенным свойством, и это использование завершается неудачно.  
  
### <a name="basetypenamemembername-property-elements"></a>Элементы свойств Басетипенаме. memberName  
 Аналогичным образом, как имя *TypeName*. *MemberName* работает для синтаксиса атрибутов, *басетипенаме*. синтаксис *MemberName* работает для синтаксиса элемента свойства. Например, следующий синтаксис работает:  
  
 [!code-xaml[XAMLOvwSupport#GoofyPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofype)]  
  
 Здесь элемент свойства был передан как `Control.Background` даже несмотря на то, что элемент свойства содержится в `Button`.  
  
 Но так же, как *TypeName*. *MemberName* Form для атрибутов, *басетипенаме*. *MemberName* является неудовлетворительным стилем в разметке, и его следует избегать.  
  
## <a name="see-also"></a>См. также раздел

- [Обзор XAML (WPF)](../../../desktop-wpf/fundamentals/xaml.md)
- [Возможности пространства имен языка XAML (x:)](../../../desktop-wpf/xaml-services/namespace-language-features.md)
- [Расширения XAML WPF](wpf-xaml-extensions.md)
- [Общие сведения о свойствах зависимости](dependency-properties-overview.md)
- [TypeConverters и XAML](typeconverters-and-xaml.md)
- [Код XAML и пользовательские классы для WPF](xaml-and-custom-classes-for-wpf.md)
