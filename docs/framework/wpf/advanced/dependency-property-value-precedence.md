---
title: Приоритет значения свойств зависимостей
ms.date: 03/30/2017
helpviewer_keywords:
- dependency properties [WPF], classes as owners
- dependency properties [WPF], metadata
- classes [WPF], owners of dependency properties
- metadata [WPF], dependency properties
ms.assetid: 1fbada8e-4867-4ed1-8d97-62c07dad7ebc
ms.openlocfilehash: 1d7c644c7f7581a96ffff1a0fe1fcf2adfe071e0
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79186148"
---
# <a name="dependency-property-value-precedence"></a>Приоритет значения свойств зависимостей
<a name="introduction"></a> В этом разделе рассказывается, как работа системы свойств [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] может повлиять на значение свойства зависимости, и описывается приоритет применения аспектов системы свойств к действительному значению свойства.  

<a name="prerequisites"></a>
## <a name="prerequisites"></a>Предварительные требования  
 Предполагается, что вы имеете представление о свойствах зависимости с точки зрения потребителя существующих свойств зависимостей в классах [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] и ознакомились с разделом [Общие сведения о свойствах зависимости](dependency-properties-overview.md). Чтобы выполнить примеры в этом разделе, следует также иметь представление о [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] и написании приложений [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
<a name="intro"></a>
## <a name="the-wpf-property-system"></a>Система свойств WPF  
 Система свойств [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] предлагает эффективный способ определения значений свойств зависимостей с помощью множества факторов, включая такие возможности, как проверка свойства в режиме реального времени, позднее связывание и уведомление связанных свойств об изменениях значений других свойств. Точный порядок и логика, используемые для определения значений свойства зависимости, достаточно сложны. Знание этого порядка поможет избежать ненужной настройки свойств и путаницы в вопросах, почему определенные попытки повлиять на значение свойства зависимости или спрогнозировать его не дали ожидаемого результата.  
  
<a name="multiple_sets"></a>
## <a name="dependency-properties-might-be-set-in-multiple-places"></a>Свойства зависимостей могут быть "установлены" в нескольких расположениях  
 Ниже приводится [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] пример, где<xref:System.Windows.Controls.Control.Background%2A>одно и то же свойство () имеет три различных "набор" операций, которые могут повлиять на значение.  
  
 [!code-xaml[PropertiesOvwSupport#DPPrecedence](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#dpprecedence)]  
  
 Как вы считаете, какой цвет будет здесь использован: красный, зеленый или синий?  
  
 За исключением динамических значений и приведения наборы локальных свойств устанавливаются с наивысшим приоритетом. Если значение задается локально, можно ожидать, что значение будет соблюдаться, даже если выше все стили и шаблоны элемента управления. Здесь, в <xref:System.Windows.Controls.Control.Background%2A> примере, устанавливается на Red локально. Таким образом, стиль, определенный в этой области, даже если это неявный стиль, который в противном случае <xref:System.Windows.Controls.Control.Background%2A> применяется ко всем элементам этого типа в этой области, не является высшим приоритетом для придания свойству его стоимости.  Если удалить локальное значение Red из этого экземпляра Button, то стиль получит приоритет и кнопка получит значение Background из стиля.  Внутри стиля приоритет получают триггеры, поэтому кнопка будет синей, если указатель мыши находится над ней, и зеленым в других случаях.  
  
<a name="listing"></a>
## <a name="dependency-property-setting-precedence-list"></a>Список приоритета настройки свойств зависимости  
 Ниже приведен точный порядок, который использует система свойств при присвоении значений времени выполнения свойствам зависимостей. Сначала указаны элементы с наивысшим приоритетом. Этот список включает некоторые обобщения, сделанные в разделе [Общие сведения о свойствах зависимостей](dependency-properties-overview.md).  
  
1. **Приведение системы свойств.** Дополнительные сведения о приведении см. в теме [Приведение, анимация и базовое значение](#animations) далее в этом разделе.  
  
2. **Активные анимации или анимации с поведением Hold.** Анимация свойства имеет практический эффект только в том случае, если она может иметь приоритет над базовым (неанимированным) значением, даже если это значение было задано локально. Дополнительные сведения см. в теме [Приведение, анимация и базовое значение](#animations) далее в этом разделе.  
  
3. **Локальное значение.** Локальное значение может быть установлено через удобство свойства "обертки", что также [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]приравнивается к <xref:System.Windows.DependencyObject.SetValue%2A> настройке в качестве атрибута или элемента свойства в, или вызовом в API с использованием свойства конкретного экземпляра. Если задано локальное значение с помощью привязки или ресурса, каждый из них функционирует в таком приоритете, как если бы было задано прямое значение.  
  
4. **Свойства шаблона TemplatedParent.** Элемент имеет, <xref:System.Windows.FrameworkElement.TemplatedParent%2A> если он был создан как <xref:System.Windows.Controls.ControlTemplate> часть <xref:System.Windows.DataTemplate>шаблона (a или ). Дополнительные сведения о случаях его применения см. в теме [TemplatedParent](#templatedparent) далее в этом разделе. В шаблоне действует следующий приоритет:  
  
    1. Триггеры из <xref:System.Windows.FrameworkElement.TemplatedParent%2A> шаблона.  
  
    2. Наборы свойств [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] (обычно через <xref:System.Windows.FrameworkElement.TemplatedParent%2A> атрибуты) в шаблоне.  
  
5. **Неявный стиль.** Применяется только к свойству `Style`. Свойство `Style` заполняется любым ресурсом стиля с ключом, соответствующим типу этого элемента. Ресурс стиля должен существовать либо на странице, либо в приложении; поиск ресурса неявного стиля в темах не выполняется.  
  
6. **Триггеры стилей.** Триггеры в стилях со страницы или из приложения (эти стили могут быть явными или неявными, но не стилями по умолчанию, поскольку последние имеют более низкий приоритет).  
  
7. **Триггеры шаблонов.** Любой триггер из шаблона внутри стиля или непосредственно применяемый шаблон.  
  
8. **Методы задания стилей.** Значения из <xref:System.Windows.Setter> стилей из страницы или приложения.  
  
9. **Стиль (тема) по умолчанию.** Подробные сведения о применении этих стилей и связи стилей тем с шаблонами в стилях тем см. в теме [Стили (темы) по умолчанию](#themestyles) далее в этом разделе. В стиле по умолчанию применяется следующий порядок приоритета:  
  
    1. Активные триггеры в тематическом стиле.  
  
    2. Методы задания в тематическом стиле.  
  
10. **Наследования.** Некоторые свойства зависимостей наследуют свои значения от родительского элемента к дочерним элементам, так что их не требуется задавать по отдельности на каждом элементе в приложении. Подробные сведения см. в разделе [Наследование значений свойств](property-value-inheritance.md).  
  
11. **Значение по умолчанию из метаданных свойства зависимости.** Любое заданное свойство зависимостей может иметь значение по умолчанию, заданное при регистрации системы свойств конкретного свойства. Кроме того, производные классы, которые наследуют свойства зависимостей, имеют возможность переопределить эти метаданные (включая значение по умолчанию) на уровне отдельных типов. Дополнительные сведения см. в разделе [Метаданные свойств зависимостей](dependency-property-metadata.md). Поскольку наследование для наследуемого свойства проверяется до значения по умолчанию, значение по умолчанию родительского элемента имеет приоритет над дочерним элементом.  Следовательно, если наследуемое свойство нигде не задано, используется значение по умолчанию, как указано в корневом элементе, либо родительское значение используется вместо значения по умолчанию дочернего элемента.  
  
<a name="templatedparent"></a>
## <a name="templatedparent"></a>TemplatedParent  
 TemplatedParent как приоритетный элемент не применяется ни к какому свойству элемента, объявляемому непосредственно в стандартной разметке приложения. Понятие TemplatedParent существует только для дочерних элементов в пределах визуального дерева, которые создаются в результате применения шаблона. Когда система свойств <xref:System.Windows.FrameworkElement.TemplatedParent%2A> ищет шаблон для значения, она ищет шаблон, который создал этот элемент. Значения свойств из <xref:System.Windows.FrameworkElement.TemplatedParent%2A> шаблона обычно действуют так, как если бы они были установлены как локальное значение элемента «ребенок», но это меньшее приоритетное значение по сравнению с локальным значением существует, потому что шаблоны потенциально общие. Дополнительные сведения см. в разделе <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.  
  
<a name="style_property"></a>
## <a name="the-style-property"></a>Свойство стиля  
 Порядок поиска, описанный ранее, применяется ко всем <xref:System.Windows.FrameworkElement.Style%2A> возможным свойствам зависимости, за исключением одного: свойства. Свойство <xref:System.Windows.FrameworkElement.Style%2A> уникально в что оно не может быть само по себе стилизовано, поэтому элементы приоритета от 5 до 8 не применяются. Кроме того, либо анимация <xref:System.Windows.FrameworkElement.Style%2A> или принуждение не рекомендуется <xref:System.Windows.FrameworkElement.Style%2A> (и анимация потребует пользовательских класс анимации). Это оставляет три <xref:System.Windows.FrameworkElement.Style%2A> способа, которые могут быть установлены свойства:  
  
- **Явный стиль.** Свойство <xref:System.Windows.FrameworkElement.Style%2A> устанавливается непосредственно. В большинстве случаев стиль не определяется внутри объекта, а используется ссылка на стиль как ресурс с применением явного ключа. В этом случае само свойство Style действует как локальное значение с приоритетом 3.  
  
- **Неявный стиль.** Свойство <xref:System.Windows.FrameworkElement.Style%2A> не устанавливается напрямую. Тем не <xref:System.Windows.FrameworkElement.Style%2A> менее, существует на определенном уровне в последовательности поиска ресурсов (страница, приложение) и включит ключ с помощью ключа ресурса, который соответствует типу стиля, к которого следует применять. В этом случае <xref:System.Windows.FrameworkElement.Style%2A> само свойство действует по приоритету, указанному в последовательности как пункт 5. Это условие может быть <xref:System.Windows.DependencyPropertyHelper> обнаружено <xref:System.Windows.FrameworkElement.Style%2A> с помощью против собственности и ищет <xref:System.Windows.BaseValueSource.ImplicitStyleReference> в результатах.  
  
- **Стиль по умолчанию**, также известный как **стиль темы.** Свойство <xref:System.Windows.FrameworkElement.Style%2A> не устанавливается непосредственно, и `null` на самом деле будет читать, как до времени выполнения. В этом случае стиль поступает из оценки темы времени выполнения, которая является частью механизма презентации [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
 Для неявных стилей, не в `MyButton` `Button`темах, тип должен точно соответствовать - a-derived класс не будет неявно использовать стиль для `Button`.  
  
<a name="themestyles"></a>
## <a name="default-theme-styles"></a>Стили (темы) по умолчанию  
 Каждый элемент управления, который поставляется с [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], имеет стиль по умолчанию. Стили по умолчанию могут варьироваться по темам, поэтому иногда их называют тематическими стилями.  
  
 Наиболее важной информацией, найденной в стиле по умолчанию для элемента управления, является <xref:System.Windows.Controls.Control.Template%2A> шаблон управления, который существует в стиле темы в качестве сеттера для его свойства. При отсутствии шаблона из стилей по умолчанию элемент управления без пользовательского шаблона в составе пользовательского стиля вообще бы не имел визуального представления. Шаблон из стиля по умолчанию придает визуальному представлению каждого элемента управления базовую структуру, а также определяет подключения между свойствами, определенными в визуальном дереве шаблона и соответствующем классе элементов управления. Каждый элемент управления предоставляет набор свойств, которые могут повлиять на внешний вид элемента управления без полной замены шаблона. Например, рассмотрим внешний <xref:System.Windows.Controls.Primitives.Thumb> вид элемента управления по <xref:System.Windows.Controls.Primitives.ScrollBar>умолчанию, который является компонентом .  
  
 A <xref:System.Windows.Controls.Primitives.Thumb> имеет определенные настраиваемые свойства. Шаблон по умолчанию <xref:System.Windows.Controls.Primitives.Thumb> создает основную структуру / <xref:System.Windows.Controls.Border> визуальное дерево с несколькими вложенными компонентами для создания скобелевого вида. Если свойство, которое является частью шаблона, предназначено для настройки <xref:System.Windows.Controls.Primitives.Thumb> классом, то это свойство должно быть выставлено [TemplateBinding,](templatebinding-markup-extension.md)в пределах шаблона. В случае <xref:System.Windows.Controls.Primitives.Thumb>различных свойств этих границ имеют общий <xref:System.Windows.Controls.Border.Background%2A> шаблон, привязывающий к таким свойствам, как или <xref:System.Windows.Controls.Border.BorderThickness%2A>. Однако некоторые другие свойства или визуальные представления заданы в коде шаблона элемента управления или привязаны к значениям, которые поступают непосредственно из темы; чтобы изменить их, необходимо заменить весь шаблон. Как правило, если свойство поступает из шаблонного родительского элемента и не предоставляется привязкой шаблона, его невозможно скорректировать с помощью стилей, поскольку нет простого способа указать его в качестве целевого объекта. Однако это свойство может зависеть от наследования значения свойства в примененном шаблоне или значения по умолчанию.  
  
 Тематические стили используют тип в качестве ключа в своих определениях. Однако, когда темы применяются к данному экземпляру элемента, <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> поиск тем для этого типа выполняется путем проверки свойства на элементе управления. Это отличается от сценария неявных стилей, где используется литеральный тип. Значение <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> будет наследовать полученных классов, даже если реалитор не изменил его (предполагаемый способ изменения свойства заключается не в том, чтобы переопределить его на уровне свойств, но вместо этого изменить его значение по умолчанию в метаданных свойств). Такая опосредованность позволяет базовым классам определять тематические стили для производных элементов, которые в противном случае не имеют стиля (или, что более важно, не имеют шаблона внутри стиля и поэтому вообще не имеют визуального представления по умолчанию). Таким образом, `MyButton` вы <xref:System.Windows.Controls.Button> можете извлечь <xref:System.Windows.Controls.Button> из и будет по-прежнему получать шаблон по умолчанию. Если вы были автором `MyButton` элемента управления и хотели другое поведение, вы <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> могли `MyButton` бы переопределить метаданные свойств зависимости для `MyButton` возврата другого ключа, а затем определить соответствующие стили темы, включая шаблон, для которого необходимо упаковать его с помощью `MyButton` элемента управления. Дополнительные сведения о темах, стилях и создании элементов управления см. в разделе [Общие сведения о создании элементов управления](../controls/control-authoring-overview.md).  
  
<a name="resources"></a>
## <a name="dynamic-resource-references-and-binding"></a>Ссылки на динамические ресурсы и привязки  
 В операциях со ссылками на динамические ресурсы и привязками учитывается приоритет расположения при настройке. Например, динамический ресурс, применяемый к локальному значению, действует с приоритетом 3, привязка для метода задания свойства в тематическом стиле действует с приоритетом 9 и так далее. Поскольку ссылки на динамические ресурсы и привязки должны иметь возможность получения значений из состояния времени выполнения приложения, это предполагает, что фактический процесс определения приоритета значения свойства для какого-либо свойства распространяется и на время выполнения.  
  
 Ссылки на динамические ресурсы, строго говоря, не являются частью системы свойств, но они имеют свой порядок поиска, который перекликается с вышеуказанной последовательностью. Этот приоритет более подробно описан в разделе [Ресурсы XAML](../../../desktop-wpf/fundamentals/xaml-resources-define.md). В общем случае действует следующий приоритет: элемент корневой страницы, приложение, тема, система.  
  
 Динамические ресурсы и привязки получают приоритет расположения, в котором они были заданы, но значение откладывается. Следствием этого является тот факт, что если задать для динамического ресурса или привязки локальное значение, то при любом изменении локального значения динамический ресурс или привязка будут меняться полностью. Даже если вы <xref:System.Windows.DependencyObject.ClearValue%2A> называете метод для очистки локально установленного значения, динамический ресурс или привязка не будут восстановлены. В самом деле, <xref:System.Windows.DependencyObject.ClearValue%2A> если вы призываете свойство, которое имеет динамический ресурс или <xref:System.Windows.DependencyObject.ClearValue%2A> связывания на месте (без буквального локального значения), они очищаются вызов тоже.  
  
<a name="setcurrentvalue"></a>
## <a name="setcurrentvalue"></a>SetCurrentValue  
 Метод <xref:System.Windows.DependencyObject.SetCurrentValue%2A> является еще одним способом установки свойства, но он не в порядке приоритета. Вместо <xref:System.Windows.DependencyObject.SetCurrentValue%2A> этого позволяет изменять значение свойства без перезаписи источника предыдущего значения. Вы можете <xref:System.Windows.DependencyObject.SetCurrentValue%2A> использовать любое время, когда вы хотите установить значение, не давая этому значению приоритет локального значения. Например, если свойство устанавливается триггером, а <xref:System.Windows.DependencyObject.SetCurrentValue%2A>затем присваивается другое значение через, система свойств по-прежнему уважает триггер, и свойство изменится, если действие триггера происходит. <xref:System.Windows.DependencyObject.SetCurrentValue%2A>позволяет изменить стоимость свойства, не придав ему источник с более высоким приоритетом. Кроме того, можно <xref:System.Windows.DependencyObject.SetCurrentValue%2A> использовать для изменения значения свойства без перезаписи привязки.  
  
<a name="animations"></a>
## <a name="coercion-animations-and-base-value"></a>Приведение, анимации и базовое значение  
 Принуждение и анимация действуют на значение, которое называется "базовое значение" на протяжении всего этого SDK. Базовое значение — это любое значение, определяемое посредством восходящей оценки элементов до тех пор, пока не будет достигнут элемент 2.  
  
 Для анимации базовое значение может повлиять на анимированное значение, если анимация не указывает значения From и To для определенных моделей поведения, либо если анимация умышленно возвращается к базовому значению по завершении выполнения. Чтобы увидеть это на практике, запустите [Пример целевых значений анимации From, To, By](https://github.com/Microsoft/WPF-Samples/tree/master/Animation/TargetValues). Попробуйте установить локальные значения высоты прямоугольника в примере, чтобы начальное локальное значение отличалось от любого значения From в анимации. Обратите внимание, что анимация сразу же начинает использовать значения From и заменяет базовое значение после запуска. Анимация может указать, чтобы вернуться к значению, найденному перед анимацией после его завершения, указав стоп. <xref:System.Windows.Media.Animation.FillBehavior> После этого для определения базового значения используется обычный приоритет.  
  
 К одному свойству можно применить несколько анимаций, причем каждая из этих анимаций может быть определена в разных точках списка приоритетов значений. Однако вместо того чтобы применять анимацию с более высоким приоритетом, вероятно, анимации объединят свои значения. Это зависит от того, как именно определяются анимации, и от типа анимируемого значения. Дополнительные сведения об анимации свойств см. в разделе [Общие сведения об эффектах анимации](../graphics-multimedia/animation-overview.md).  
  
 Приведение применяется на самом высоком уровне. Приведение значения может быть выполнено даже для уже выполняющейся анимации. Некоторые существующие свойства зависимостей в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] имеют встроенные приведения. Для свойств пользовательской зависимости вы определяете поведение принуждения для <xref:System.Windows.CoerceValueCallback> пользовательского свойства зависимости, написав и передав обратный вызов как часть метаданных при создании свойства. Также можно переопределить поведение приведения существующих свойств путем переопределения метаданных для этого свойства в производном классе. Приведение взаимодействует с базовым значением таким образом, что ограничения на приведение применяются в том виде, в котором они существуют на тот момент, однако базовое значение сохраняется. Таким образом, если ограничения в приведении впоследствии будут сняты, приведение вернет ближайшее к базовому возможное значение и, возможно, влияние приведения на свойство прекратится, как только ограничение будет снято. Дополнительные сведения о поведении приведения см. в разделе [Проверка и обратные вызовы свойства зависимостей](dependency-property-callbacks-and-validation.md).  
  
<a name="triggers"></a>
## <a name="trigger-behaviors"></a>Поведения триггера  
 Элементы управления часто определяют поведение триггера в составе своего стиля по умолчанию, в темах. Установка локальных свойств для элементов управления может препятствовать реагированию триггеров на инициированные пользователями события (визуально или своими действиями). Наиболее распространенное использование триггера свойства для <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A>управления или состояния свойств, таких как . Например, по умолчанию, когда <xref:System.Windows.Controls.Button> отключен (триггер для <xref:System.Windows.UIElement.IsEnabled%2A> есть), `false`то <xref:System.Windows.Controls.Control.Foreground%2A> значение в стиле темы является то, что причины элемента появляются "серый из". Но если вы установили <xref:System.Windows.Controls.Control.Foreground%2A> локальное значение, этот нормальный серый цвет будет отменен в приоритете вашим локальным набором свойств, даже в этом сценарии, вызванном свойством. Будьте осторожны при установке значений для свойств, которые имеют поведения триггеров на уровне темы; кроме того, необходимо убедиться, что не создается ненужных помех работе пользователя с этим элементом управления.  
  
<a name="clearvalue"></a>
## <a name="clearvalue-and-value-precedence"></a>ClearValue и приоритет значения  
 Метод <xref:System.Windows.DependencyObject.ClearValue%2A> обеспечивает целесообразным средство для очистки любого локально приложенного значения от свойства зависимости, которое устанавливается на элементе. Тем не <xref:System.Windows.DependencyObject.ClearValue%2A> менее, вызов не является гарантией того, что по умолчанию, как установить в метаданных во время регистрации недвижимости является новым эффективным значением. Все остальные участники в приоритете значений будут по-прежнему активны. Только локально заданное значение удаляется из последовательности приоритетов. Например, если <xref:System.Windows.DependencyObject.ClearValue%2A> вы звоните в свойство, в котором это свойство также устанавливается стилем темы, то значение темы применяется как новое значение, а не значение на основе метаданных. Если вы хотите вывести из процесса всех участников стоимости свойств и установить значение для зарегистрированных метаданных по умолчанию, вы можете получить это значение по умолчанию окончательно, <xref:System.Windows.DependencyObject.SetValue%2A>задав запрос метаданных свойств зависимости, а затем вы можете использовать значение значения по умолчанию для локального набора свойства с вызовом.  
  
## <a name="see-also"></a>См. также раздел

- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- [Общие сведения о свойствах зависимости](dependency-properties-overview.md)
- [Пользовательские свойства зависимостей](custom-dependency-properties.md)
- [Проверка и обратные вызовы свойства зависимостей](dependency-property-callbacks-and-validation.md)
