---
title: Приоритет значения свойств зависимостей
ms.date: 03/30/2017
helpviewer_keywords:
- dependency properties [WPF], classes as owners
- dependency properties [WPF], metadata
- classes [WPF], owners of dependency properties
- metadata [WPF], dependency properties
ms.assetid: 1fbada8e-4867-4ed1-8d97-62c07dad7ebc
ms.openlocfilehash: a9ff3a4f6ac08a0f7ec6dd9fc26bf190f43f3584
ms.sourcegitcommit: 011314e0c8eb4cf4a11d92078f58176c8c3efd2d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/09/2020
ms.locfileid: "77095207"
---
# <a name="dependency-property-value-precedence"></a>Приоритет значения свойств зависимостей
<a name="introduction"></a> В этом разделе рассказывается, как работа системы свойств [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] может повлиять на значение свойства зависимости, и описывается приоритет применения аспектов системы свойств к действительному значению свойства.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>предварительные требования  
 Предполагается, что вы имеете представление о свойствах зависимости с точки зрения потребителя существующих свойств зависимостей в классах [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] и ознакомились с разделом [Общие сведения о свойствах зависимости](dependency-properties-overview.md). Чтобы выполнить примеры в этом разделе, следует также иметь представление о [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] и написании приложений [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
<a name="intro"></a>   
## <a name="the-wpf-property-system"></a>Система свойств WPF  
 Система свойств [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] предлагает эффективный способ определения значений свойств зависимостей с помощью множества факторов, включая такие возможности, как проверка свойства в режиме реального времени, позднее связывание и уведомление связанных свойств об изменениях значений других свойств. Точный порядок и логика, используемые для определения значений свойства зависимости, достаточно сложны. Знание этого порядка поможет избежать ненужной настройки свойств и путаницы в вопросах, почему определенные попытки повлиять на значение свойства зависимости или спрогнозировать его не дали ожидаемого результата.  
  
<a name="multiple_sets"></a>   
## <a name="dependency-properties-might-be-set-in-multiple-places"></a>Свойства зависимостей могут быть "установлены" в нескольких расположениях  
 Ниже приведен пример [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], где одно и то же свойство (<xref:System.Windows.Controls.Control.Background%2A>) имеет три различные операции Set, которые могут повлиять на это значение.  
  
 [!code-xaml[PropertiesOvwSupport#DPPrecedence](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#dpprecedence)]  
  
 Как вы считаете, какой цвет будет здесь использован: красный, зеленый или синий?  
  
 За исключением динамических значений и приведения наборы локальных свойств устанавливаются с наивысшим приоритетом. Если значение задается локально, можно ожидать, что значение будет соблюдаться, даже если выше все стили и шаблоны элемента управления. Здесь в примере <xref:System.Windows.Controls.Control.Background%2A> устанавливается в красный цвет локально. Таким образом, стиль, определенный в этой области, несмотря на то, что он является неявным стилем, который в противном случае применяется ко всем элементам этого типа в этой области, не имеет наивысшего приоритета для присвоения свойству <xref:System.Windows.Controls.Control.Background%2A> его значения.  Если удалить локальное значение Red из этого экземпляра Button, то стиль получит приоритет и кнопка получит значение Background из стиля.  Внутри стиля приоритет получают триггеры, поэтому кнопка будет синей, если указатель мыши находится над ней, и зеленым в других случаях.  
  
<a name="listing"></a>   
## <a name="dependency-property-setting-precedence-list"></a>Список приоритета настройки свойств зависимости  
 Ниже приведен точный порядок, который использует система свойств при присвоении значений времени выполнения свойствам зависимостей. Сначала указаны элементы с наивысшим приоритетом. Этот список включает некоторые обобщения, сделанные в разделе [Общие сведения о свойствах зависимостей](dependency-properties-overview.md).  
  
1. **Приведение системы свойств.** Дополнительные сведения о приведении см. в теме [Приведение, анимация и базовое значение](#animations) далее в этом разделе.  
  
2. **Активные анимации или анимации с поведением Hold.** Анимация свойства имеет практический эффект только в том случае, если она может иметь приоритет над базовым (неанимированным) значением, даже если это значение было задано локально. Дополнительные сведения см. в теме [Приведение, анимация и базовое значение](#animations) далее в этом разделе.  
  
3. **Локальное значение.** Локальное значение может быть задано с помощью свойства "оболочки", которое также равнозначно установке в качестве элемента атрибута или свойства в [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]или путем вызова API <xref:System.Windows.DependencyObject.SetValue%2A> с помощью свойства определенного экземпляра. Если задано локальное значение с помощью привязки или ресурса, каждый из них функционирует в таком приоритете, как если бы было задано прямое значение.  
  
4. **Свойства шаблона TemplatedParent.** Элемент имеет <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, если он был создан как часть шаблона (<xref:System.Windows.Controls.ControlTemplate> или <xref:System.Windows.DataTemplate>). Дополнительные сведения о случаях его применения см. в теме [TemplatedParent](#templatedparent) далее в этом разделе. В шаблоне действует следующий приоритет:  
  
    1. Триггеры из шаблона <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.  
  
    2. Набор свойств (обычно с помощью атрибутов [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]) в шаблоне <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.  
  
5. **Неявный стиль.** Применяется только к свойству `Style`. Свойство `Style` заполняется любым ресурсом стиля с ключом, соответствующим типу этого элемента. Ресурс стиля должен существовать либо на странице, либо в приложении; поиск ресурса неявного стиля в темах не выполняется.  
  
6. **Триггеры стилей.** Триггеры в стилях со страницы или из приложения (эти стили могут быть явными или неявными, но не стилями по умолчанию, поскольку последние имеют более низкий приоритет).  
  
7. **Триггеры шаблонов.** Любой триггер из шаблона внутри стиля или непосредственно применяемый шаблон.  
  
8. **Методы задания стилей.** Значения из <xref:System.Windows.Setter> в стилях страницы или приложения.  
  
9. **Стиль (тема) по умолчанию.** Подробные сведения о применении этих стилей и связи стилей тем с шаблонами в стилях тем см. в теме [Стили (темы) по умолчанию](#themestyles) далее в этом разделе. В стиле по умолчанию применяется следующий порядок приоритета:  
  
    1. Активные триггеры в тематическом стиле.  
  
    2. Методы задания в тематическом стиле.  
  
10. **Наследование.** Некоторые свойства зависимостей наследуют свои значения от родительского элемента к дочерним элементам, так что их не требуется задавать по отдельности на каждом элементе в приложении. Подробные сведения см. в разделе [Наследование значений свойств](property-value-inheritance.md).  
  
11. **Значение по умолчанию из метаданных свойства зависимости.** Любое заданное свойство зависимостей может иметь значение по умолчанию, заданное при регистрации системы свойств конкретного свойства. Кроме того, производные классы, которые наследуют свойства зависимостей, имеют возможность переопределить эти метаданные (включая значение по умолчанию) на уровне отдельных типов. Дополнительные сведения см. в разделе [Метаданные свойств зависимостей](dependency-property-metadata.md). Поскольку наследование для наследуемого свойства проверяется до значения по умолчанию, значение по умолчанию родительского элемента имеет приоритет над дочерним элементом.  Следовательно, если наследуемое свойство нигде не задано, используется значение по умолчанию, как указано в корневом элементе, либо родительское значение используется вместо значения по умолчанию дочернего элемента.  
  
<a name="templatedparent"></a>   
## <a name="templatedparent"></a>TemplatedParent  
 TemplatedParent как приоритетный элемент не применяется ни к какому свойству элемента, объявляемому непосредственно в стандартной разметке приложения. Понятие TemplatedParent существует только для дочерних элементов в пределах визуального дерева, которые создаются в результате применения шаблона. Когда система свойств выполняет поиск значения в шаблоне <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, он выполняет поиск в шаблоне, который создал этот элемент. Значения свойств из шаблона <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, как правило, действуют так, как если бы они были заданы как локальное значение в дочернем элементе, но этот более низкий приоритет по сравнению с локальным значением существует, так как шаблоны являются потенциально общими. Дополнительные сведения см. в разделе <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.  
  
<a name="style_property"></a>   
## <a name="the-style-property"></a>Свойство стиля  
 Порядок поиска, описанный выше, применяется ко всем возможным свойствам зависимостей, кроме одного: свойство <xref:System.Windows.FrameworkElement.Style%2A>. Свойство <xref:System.Windows.FrameworkElement.Style%2A> является уникальным в том, что оно не может иметь стиль, поэтому приоритетные элементы с 5 по 8 не применяются. Кроме того, не рекомендуется выполнять анимацию или приведение <xref:System.Windows.FrameworkElement.Style%2A> (для анимации <xref:System.Windows.FrameworkElement.Style%2A> потребуется пользовательский класс анимации). Это оставляет три способа, которым может быть задано свойство <xref:System.Windows.FrameworkElement.Style%2A>:  
  
- **Явный стиль.** Свойство <xref:System.Windows.FrameworkElement.Style%2A> задается напрямую. В большинстве случаев стиль не определяется внутри объекта, а используется ссылка на стиль как ресурс с применением явного ключа. В этом случае само свойство Style действует как локальное значение с приоритетом 3.  
  
- **Неявный стиль.** Свойство <xref:System.Windows.FrameworkElement.Style%2A> не задано напрямую. Однако <xref:System.Windows.FrameworkElement.Style%2A> существует на каком-либо уровне в последовательности поиска ресурсов (страница, приложение) и является ключом с использованием ключа ресурса, соответствующего типу, к которому применяется стиль. В этом случае само свойство <xref:System.Windows.FrameworkElement.Style%2A> действует с приоритетом, определенным в последовательности как элемент 5. Это условие можно обнаружить с помощью <xref:System.Windows.DependencyPropertyHelper> для свойства <xref:System.Windows.FrameworkElement.Style%2A> и поиска <xref:System.Windows.BaseValueSource.ImplicitStyleReference> в результатах.  
  
- **Стиль по умолчанию**, также известный как **стиль темы.** Свойство <xref:System.Windows.FrameworkElement.Style%2A> не задано напрямую, и фактически будет считаться `null` до времени выполнения. В этом случае стиль поступает из оценки темы времени выполнения, которая является частью механизма презентации [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
 Для неявных стилей, отсутствующих в темах, тип должен точно соответствовать `MyButton` `Button`производный класс не будет неявно использовать стиль для `Button`.  
  
<a name="themestyles"></a>   
## <a name="default-theme-styles"></a>Стили (темы) по умолчанию  
 Каждый элемент управления, который поставляется с [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], имеет стиль по умолчанию. Стили по умолчанию могут варьироваться по темам, поэтому иногда их называют тематическими стилями.  
  
 Наиболее важная информация, найденная в стиле по умолчанию для элемента управления, — это шаблон элемента управления, который существует в стиле темы как метод задания свойства <xref:System.Windows.Controls.Control.Template%2A>. При отсутствии шаблона из стилей по умолчанию элемент управления без пользовательского шаблона в составе пользовательского стиля вообще бы не имел визуального представления. Шаблон из стиля по умолчанию придает визуальному представлению каждого элемента управления базовую структуру, а также определяет подключения между свойствами, определенными в визуальном дереве шаблона и соответствующем классе элементов управления. Каждый элемент управления предоставляет набор свойств, которые могут повлиять на внешний вид элемента управления без полной замены шаблона. Например, рассмотрим визуальный вид по умолчанию для элемента управления <xref:System.Windows.Controls.Primitives.Thumb>, который является компонентом <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 У <xref:System.Windows.Controls.Primitives.Thumb> есть определенные настраиваемые свойства. Шаблон по умолчанию <xref:System.Windows.Controls.Primitives.Thumb> создает базовую структуру или визуальное дерево с несколькими вложенными <xref:System.Windows.Controls.Border>ными компонентами для создания скоса. Если свойство, которое является частью шаблона, должно предоставляться для настройки классом <xref:System.Windows.Controls.Primitives.Thumb>, то это свойство должно предоставляться [TemplateBinding](templatebinding-markup-extension.md)в шаблоне. В случае <xref:System.Windows.Controls.Primitives.Thumb>различные свойства этих границ совместно используют привязку шаблона к свойствам, таким как <xref:System.Windows.Controls.Border.Background%2A> или <xref:System.Windows.Controls.Border.BorderThickness%2A>. Однако некоторые другие свойства или визуальные представления заданы в коде шаблона элемента управления или привязаны к значениям, которые поступают непосредственно из темы; чтобы изменить их, необходимо заменить весь шаблон. Как правило, если свойство поступает из шаблонного родительского элемента и не предоставляется привязкой шаблона, его невозможно скорректировать с помощью стилей, поскольку нет простого способа указать его в качестве целевого объекта. Однако это свойство может зависеть от наследования значения свойства в примененном шаблоне или значения по умолчанию.  
  
 Тематические стили используют тип в качестве ключа в своих определениях. Однако при применении тем к данному экземпляру элемента Поиск тем для этого типа выполняется путем проверки свойства <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> элемента управления. Это отличается от сценария неявных стилей, где используется литеральный тип. Значение <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> будет наследоваться производным классам, даже если разработчик не изменил его (предполагаемый способ изменения свойства не переопределяет его на уровне свойства, но вместо этого измените значение по умолчанию в метаданных свойства). Такая опосредованность позволяет базовым классам определять тематические стили для производных элементов, которые в противном случае не имеют стиля (или, что более важно, не имеют шаблона внутри стиля и поэтому вообще не имеют визуального представления по умолчанию). Таким же, можно получить `MyButton` от <xref:System.Windows.Controls.Button> и по-прежнему будет получать шаблон <xref:System.Windows.Controls.Button> по умолчанию. Если разработчик элемента управления `MyButton` и требуется другое поведение, можно переопределить метаданные свойства зависимости для <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> на `MyButton`, чтобы вернуть другой ключ, а затем определить соответствующие стили темы, включая шаблон для `MyButton`, которые необходимо упаковать с элементом управления `MyButton`. Дополнительные сведения о темах, стилях и создании элементов управления см. в разделе [Общие сведения о создании элементов управления](../controls/control-authoring-overview.md).  
  
<a name="resources"></a>   
## <a name="dynamic-resource-references-and-binding"></a>Ссылки на динамические ресурсы и привязки  
 В операциях со ссылками на динамические ресурсы и привязками учитывается приоритет расположения при настройке. Например, динамический ресурс, применяемый к локальному значению, действует с приоритетом 3, привязка для метода задания свойства в тематическом стиле действует с приоритетом 9 и так далее. Поскольку ссылки на динамические ресурсы и привязки должны иметь возможность получения значений из состояния времени выполнения приложения, это предполагает, что фактический процесс определения приоритета значения свойства для какого-либо свойства распространяется и на время выполнения.  
  
 Ссылки на динамические ресурсы, строго говоря, не являются частью системы свойств, но они имеют свой порядок поиска, который перекликается с вышеуказанной последовательностью. Этот приоритет более подробно описан в разделе [Ресурсы XAML](../../../desktop-wpf/fundamentals/xaml-resources-define.md). В общем случае действует следующий приоритет: элемент корневой страницы, приложение, тема, система.  
  
 Динамические ресурсы и привязки получают приоритет расположения, в котором они были заданы, но значение откладывается. Следствием этого является тот факт, что если задать для динамического ресурса или привязки локальное значение, то при любом изменении локального значения динамический ресурс или привязка будут меняться полностью. Даже при вызове метода <xref:System.Windows.DependencyObject.ClearValue%2A> для очистки локально заданного значения динамический ресурс или привязка не будут восстановлены. На самом деле, при вызове <xref:System.Windows.DependencyObject.ClearValue%2A> для свойства, имеющего динамический ресурс или привязку (без литерального локального значения), они также очищаются <xref:System.Windows.DependencyObject.ClearValue%2A> вызовом.  
  
<a name="setcurrentvalue"></a>   
## <a name="setcurrentvalue"></a>SetCurrentValue  
 Метод <xref:System.Windows.DependencyObject.SetCurrentValue%2A> — еще один способ задания свойства, но не в порядке приоритета. Вместо этого <xref:System.Windows.DependencyObject.SetCurrentValue%2A> позволяет изменить значение свойства без перезаписи источника предыдущего значения. Можно использовать <xref:System.Windows.DependencyObject.SetCurrentValue%2A> в любое время, когда необходимо задать значение, не давая этому значению приоритет локального значения. Например, если свойство задается триггером и затем присваивается другое значение через <xref:System.Windows.DependencyObject.SetCurrentValue%2A>, система свойств по-прежнему учитывает триггер, а свойство изменяется при возникновении действия триггера. <xref:System.Windows.DependencyObject.SetCurrentValue%2A> позволяет изменить значение свойства, не присваивая ему источник с более высоким приоритетом. Аналогичным образом можно использовать <xref:System.Windows.DependencyObject.SetCurrentValue%2A> для изменения значения свойства без перезаписи привязки.  
  
<a name="animations"></a>   
## <a name="coercion-animations-and-base-value"></a>Приведение, анимации и базовое значение  
 Приведение и анимация работают со значением, которое называется "базовым значением" в этом пакете SDK. Базовое значение — это любое значение, определяемое посредством восходящей оценки элементов до тех пор, пока не будет достигнут элемент 2.  
  
 Для анимации базовое значение может повлиять на анимированное значение, если анимация не указывает значения From и To для определенных моделей поведения, либо если анимация умышленно возвращается к базовому значению по завершении выполнения. Чтобы увидеть это на практике, запустите [Пример целевых значений анимации From, To, By](https://github.com/Microsoft/WPF-Samples/tree/master/Animation/TargetValues). Попробуйте установить локальные значения высоты прямоугольника в примере, чтобы начальное локальное значение отличалось от любого значения From в анимации. Обратите внимание, что анимация сразу же начинает использовать значения From и заменяет базовое значение после запуска. Анимация может вернуться к значению, найденному до начала анимации, указав <xref:System.Windows.Media.Animation.FillBehavior>у завершения. После этого для определения базового значения используется обычный приоритет.  
  
 К одному свойству можно применить несколько анимаций, причем каждая из этих анимаций может быть определена в разных точках списка приоритетов значений. Однако вместо того чтобы применять анимацию с более высоким приоритетом, вероятно, анимации объединят свои значения. Это зависит от того, как именно определяются анимации, и от типа анимируемого значения. Дополнительные сведения об анимации свойств см. в разделе [Общие сведения об эффектах анимации](../graphics-multimedia/animation-overview.md).  
  
 Приведение применяется на самом высоком уровне. Приведение значения может быть выполнено даже для уже выполняющейся анимации. Некоторые существующие свойства зависимостей в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] имеют встроенные приведения. Для настраиваемого свойства зависимости определяется поведение приведения для настраиваемого свойства зависимости путем записи <xref:System.Windows.CoerceValueCallback> и передачи обратного вызова как части метаданных при создании свойства. Также можно переопределить поведение приведения существующих свойств путем переопределения метаданных для этого свойства в производном классе. Приведение взаимодействует с базовым значением таким образом, что ограничения на приведение применяются в том виде, в котором они существуют на тот момент, однако базовое значение сохраняется. Таким образом, если ограничения в приведении впоследствии будут сняты, приведение вернет ближайшее к базовому возможное значение и, возможно, влияние приведения на свойство прекратится, как только ограничение будет снято. Дополнительные сведения о поведении приведения см. в разделе [Проверка и обратные вызовы свойства зависимостей](dependency-property-callbacks-and-validation.md).  
  
<a name="triggers"></a>   
## <a name="trigger-behaviors"></a>Поведения триггера  
 Элементы управления часто определяют поведение триггера в составе своего стиля по умолчанию, в темах. Установка локальных свойств для элементов управления может препятствовать реагированию триггеров на инициированные пользователями события (визуально или своими действиями). Чаще всего триггер свойства используется для свойств управления или состояния, таких как <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A>. Например, по умолчанию, если <xref:System.Windows.Controls.Button> отключен (триггер для <xref:System.Windows.UIElement.IsEnabled%2A> является `false`), значение <xref:System.Windows.Controls.Control.Foreground%2A> в стиле темы приводит к тому, что элемент управления отображается серым цветом. Но если вы задали значение локального <xref:System.Windows.Controls.Control.Foreground%2A>, то этот Стандартный серый цвет будет переопределяться в приоритете локальным свойством, даже в сценарии, активируемом свойством. Будьте осторожны при установке значений для свойств, которые имеют поведения триггеров на уровне темы; кроме того, необходимо убедиться, что не создается ненужных помех работе пользователя с этим элементом управления.  
  
<a name="clearvalue"></a>   
## <a name="clearvalue-and-value-precedence"></a>ClearValue и приоритет значения  
 Метод <xref:System.Windows.DependencyObject.ClearValue%2A> предоставляет укороченного для удаления любого локально примененного значения из свойства зависимостей, установленного для элемента. Однако вызов <xref:System.Windows.DependencyObject.ClearValue%2A> не гарантирует, что значение по умолчанию, установленное в метаданных во время регистрации свойства, является новым эффективным значением. Все остальные участники в приоритете значений будут по-прежнему активны. Только локально заданное значение удаляется из последовательности приоритетов. Например, при вызове <xref:System.Windows.DependencyObject.ClearValue%2A> для свойства, в котором это свойство также задано стилем темы, значение темы применяется как новое значение, а не по умолчанию на основе метаданных. Если вы хотите, чтобы все участники значения свойств вышли из процесса и присвоить значение зарегистрированным метаданным по умолчанию, можно получить это значение по умолчанию, запросив метаданные свойства зависимостей, а затем использовать значение по умолчанию, чтобы локально задать свойство с помощью вызова <xref:System.Windows.DependencyObject.SetValue%2A>.  
  
## <a name="see-also"></a>См. также раздел

- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- [Общие сведения о свойствах зависимости](dependency-properties-overview.md)
- [Пользовательские свойства зависимостей](custom-dependency-properties.md)
- [Проверка и обратные вызовы свойства зависимостей](dependency-property-callbacks-and-validation.md)
