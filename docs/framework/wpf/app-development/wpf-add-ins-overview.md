---
title: Общие сведения о надстройках WPF
ms.date: 03/30/2017
helpviewer_keywords:
- add-ins and XAML browser applications [WPF]
- add-ins overview [WPF]
- add-ins [WPF], performance
- add-ins [WPF], benefits
- .NET Framework add-in model [WPF]
- add-ins [WPF], user interface
- add-ins and the user interface [WPF]
- add-ins [WPF], architecture
- add-ins [WPF], limitations
ms.assetid: 00b4c776-29a8-4dba-b603-280a0cdc2ade
ms.openlocfilehash: e1daf9efd59b89d5d5be5f51cf9ac5e00750dda3
ms.sourcegitcommit: 82f94a44ad5c64a399df2a03fa842db308185a76
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/25/2019
ms.locfileid: "72919725"
---
# <a name="wpf-add-ins-overview"></a>Общие сведения о надстройках WPF

<a name="Introduction"></a>.NET Framework содержит модель надстройки, которую разработчики могут использовать для создания приложений, поддерживающих расширения надстроек. Эта модель позволяет создавать надстройки, которые интегрируются с функциональностью приложения и расширяют ее. В некоторых случаях приложениям также требуется отображать пользовательские интерфейсы, предоставляемые надстройками. В этом разделе показано, как WPF дополняет модель надстройки .NET Framework, чтобы реализовать эти сценарии, архитектуру, а также ее преимущества и ограничения.

<a name="Requirements"></a>

## <a name="prerequisites"></a>Необходимые компоненты

Знание модели надстройки .NET Framework является обязательным. Дополнительные сведения см. в разделе [Надстройки и расширяемость](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)).

<a name="AddInsOverview"></a>

## <a name="add-ins-overview"></a>Общие сведения о надстройках

Чтобы избежать сложностей повторной компиляции и развертывания приложений для включения новых функциональных возможностей, приложения реализуют механизмы расширяемости, которые позволяют разработчикам (как собственным, так и сторонним) создавать другие приложения с поддержкой интеграции. Наиболее распространенным способом поддержки этого типа расширяемости является использование надстроек (также называемых "подключаемыми модулями"). Примеры реальных приложений, которые обеспечивают расширяемость с помощью надстроек:

- Надстройки Internet Explorer.

- Надстройки проигрывателя Windows Media.

- Надстройки Visual Studio.

Например, модель надстроек проигрывателя Windows Media позволяет сторонним разработчикам реализовать "подключаемые модули", расширяющие возможности проигрывателя Windows Media различными способами, включая создание декодеров и кодировщиков для форматов мультимедиа, изначально не поддерживаемых проигрывателем Windows Media (например: DVD, MP3), а также звуковых эффектов и обложек. Каждая модель надстройки создается для предоставления функций, уникальных для приложения, хотя существует несколько элементов и поведений, общих для всех моделей.

Тремя основными сущностями типичных решений расширяемости являются *контракты*, *надстройки* и *ведущие приложения*. Контракты определяют интеграцию надстроек с ведущими приложениями двумя способами:

- Надстройки интегрируются с функциональными возможностями, реализуемыми ведущими приложениями.

- Ведущие приложения предоставляют функциональные возможности для надстроек, с которыми интегрируются.

Чтобы использовать надстройки, ведущие приложения должны найти их и загрузить во время выполнения. Следовательно, приложения, поддерживающие надстройки, имеют следующие дополнительные обязанности:

- **Обнаружение**: поиск надстроек, которые соответствуют контрактам, поддерживаемым ведущими приложениями.

- **Активация**: загрузка, запуск и установка связи с надстройками.

- **Изоляция**: использование доменов приложений или процессов для установления границ изоляции, защищающих приложения от потенциальных проблем безопасности и выполнения, связанных с надстройками.

- **Обмен данными**: разрешение надстройкам и ведущим приложениям взаимодействовать друг с другом через границы изоляции путем вызова методов и передачи данных.

- **Управление жизненным циклом объекта**: загрузка и выгрузка доменов приложений и процессов ясным, прогнозируемым способом (см. [Домены приложений](../../app-domains/application-domains.md)).

- **Управление версиями**: гарантия возможности взаимодействия ведущих приложений и надстроек после создания их новых версий.

В конечном счете разработка надежной модели надстройки является нетривиальный задачей. По этой причине .NET Framework предоставляет инфраструктуру для создания моделей надстроек.

> [!NOTE]
> Более подробные сведения о надстройках см. в разделе [Надстройки и расширения среды](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)).

<a name="NETFrameworkAddInModelOverview"></a>

## <a name="net-framework-add-in-model-overview"></a>Общие сведения о модели надстроек платформы .NET Framework

Модель надстроек .NET Framework, которая находится в пространстве имен <xref:System.AddIn>, содержит набор типов, предназначенных для упрощения разработки расширяемости надстроек. Основной единицей модели надстройки .NET Framework является *контракт*, который определяет, как ведущее приложение и надстройка взаимодействуют друг с другом. Контракт предоставляется ведущему приложению с помощью специфичного для ведущего приложения *представления* контракта. Аналогичным образом надстройке предоставляется специфичное для нее *представление* контракта. *Адаптер* позволяет ведущему приложению и надстройке обмениваться данными между соответствующими представлениями контракта. Контракты, представления и адаптеры называются сегментами, а набор связанных сегментов составляет *конвейер*. Конвейеры — это основа, на основе которой модель надстроек .NET Framework поддерживает обнаружение, активацию, изоляцию безопасности, изоляцию выполнения (с помощью доменов приложений и процессов), взаимодействие, управление жизненным циклом и контроль версий.

Эта поддержка в целом позволяет разработчикам создавать надстройки, которые интегрируются с функциональностью ведущего приложения. Однако в некоторых сценариях хост-приложения должны отображать пользовательские интерфейсы, предоставляемые надстройками. Поскольку каждая технология представления в .NET Framework имеет собственную модель для реализации пользовательских интерфейсов, модель надстройки .NET Framework не поддерживает какую-либо конкретную технологию представления. Вместо этого WPF расширяет модель надстройки .NET Framework с поддержкой пользовательского интерфейса для надстроек.

<a name="WPFAddInModel"></a>

## <a name="wpf-add-ins"></a>Надстройки WPF

WPF, в сочетании с моделью надстройки .NET Framework, позволяет решать разнообразные сценарии, требующие, чтобы ведущие приложения отображали пользовательские интерфейсы из надстроек. В частности, эти сценарии решаются в WPF с помощью следующих двух моделей программирования:

1. **Надстройка возвращает пользовательский интерфейс**. Надстройка возвращает пользовательский интерфейс ведущему приложению через вызов метода, как определено контрактом. Этот сценарий используется в следующих случаях.

    - Внешний вид пользовательского интерфейса, возвращаемого надстройкой, зависит от либо данных, либо условий, которые существуют только во время выполнения, например динамически создаваемые отчеты.

    - Пользовательский интерфейс для служб, предоставляемых надстройкой, отличается от пользовательского интерфейса ведущих приложений, которые могут использовать надстройку.

    - Надстройка в основном выполняет службу для ведущего приложения и сообщает о состоянии ведущему приложению с помощью пользовательского интерфейса.

2. **Надстройка — это пользовательский интерфейс**. Надстройка — это пользовательский интерфейс, определяемый контрактом. Этот сценарий используется в следующих случаях.

    - Надстройка не предоставляет службы помимо отображения, например рекламного объявления.

    - Пользовательский интерфейс для служб, предоставляемых надстройкой, является общим для всех ведущих приложений, которые могут использовать эту надстройку, например калькулятор или выбора цвета.

В этих сценариях необходимо, чтобы объекты пользовательского интерфейса передавались между ведущими приложениями и доменами приложений надстройки. Поскольку модель надстроек .NET Framework использует удаленное взаимодействие для взаимодействия между доменами приложений, передаваемые между ними объекты должны поддерживать удаленное взаимодействие.

Объект, поддерживающий удаленную обработку, является экземпляром класса, который выполняет одну или несколько из следующих функций:

- Является производным от класса <xref:System.MarshalByRefObject>.

- Реализует интерфейс <xref:System.Runtime.Serialization.ISerializable>.

- Имеет примененный атрибут <xref:System.SerializableAttribute>.

> [!NOTE]
> Дополнительные сведения о создании объектов .NET Framework, поддерживающих удаленное взаимодействие, см. в разделе [обеспечение удаленного взаимодействия объектов](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/wcf3swha(v=vs.100)).

Типы пользовательского интерфейса WPF не поддерживают удаленное взаимодействие. Чтобы решить эту проблему, WPF расширяет модель надстройки .NET Framework, чтобы включить пользовательский интерфейс WPF, созданный надстройками, для отображения из ведущих приложений. Эта поддержка обеспечивается в WPF двумя типами: интерфейс <xref:System.AddIn.Contract.INativeHandleContract> и два статических метода, реализованные классом <xref:System.AddIn.Pipeline.FrameworkElementAdapters>: <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> и <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>. На высоком уровне эти типы и методы используются следующим образом:

1. WPF требует, чтобы пользовательские интерфейсы, предоставляемые надстройками, были классами, прямо или косвенно производными от <xref:System.Windows.FrameworkElement>, такими как фигуры, элементы управления, пользовательские элементы управления, панели макета и страницы.

2. Когда контракт объявляет, что пользовательский интерфейс будет передаваться между надстройкой и ведущим приложением, он должен быть объявлен как <xref:System.AddIn.Contract.INativeHandleContract> (а не <xref:System.Windows.FrameworkElement>). <xref:System.AddIn.Contract.INativeHandleContract> представляет собой удаленное представление пользовательского интерфейса надстройки, которое может быть передано через границы изоляции.

3. Перед передачей из домена приложения надстройки <xref:System.Windows.FrameworkElement> упаковывается как <xref:System.AddIn.Contract.INativeHandleContract> путем вызова <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>.

4. После передачи в домен приложения ведущего приложения <xref:System.AddIn.Contract.INativeHandleContract> необходимо повторно упаковать как <xref:System.Windows.FrameworkElement> путем вызова <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>.

Использование <xref:System.AddIn.Contract.INativeHandleContract>, <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>и <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> зависит от конкретного сценария. В следующих разделах содержатся сведения о каждой модели программирования.

<a name="ReturnUIFromAddInContract"></a>

## <a name="add-in-returns-a-user-interface"></a>Надстройка возвращает пользовательский интерфейс

Чтобы надстройка возвращала пользовательский интерфейс ведущему приложению, необходимо следующее:

1. Необходимо создать ведущее приложение, надстройку и конвейер, как описано в документации [надстройки и расширения](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)) .NET Framework.

2. Контракт должен реализовать <xref:System.AddIn.Contract.IContract> и, чтобы получить пользовательский интерфейс, контракт должен объявить метод с возвращаемым значением типа <xref:System.AddIn.Contract.INativeHandleContract>.

3. Пользовательский интерфейс, передаваемый между надстройкой и ведущим приложением, должен быть прямо или косвенно производным от <xref:System.Windows.FrameworkElement>.

4. Пользовательский интерфейс, возвращаемый надстройкой, должен быть преобразован из <xref:System.Windows.FrameworkElement> в <xref:System.AddIn.Contract.INativeHandleContract> до пересечения границы изоляции.

5. Возвращаемый пользовательский интерфейс должен быть преобразован из <xref:System.AddIn.Contract.INativeHandleContract> в <xref:System.Windows.FrameworkElement> после пересечения границы изоляции.

6. Ведущее приложение отображает возвращенный <xref:System.Windows.FrameworkElement>.

Пример, демонстрирующий реализацию надстройки, возвращающей пользовательский интерфейс, см. в разделе [Создание надстройки, возвращающей пользовательский интерфейс](how-to-create-an-add-in-that-returns-a-ui.md).

<a name="AddInIsAUI"></a>

## <a name="add-in-is-a-user-interface"></a>Надстройка является пользовательским интерфейсом

Если надстройка является пользовательским интерфейсом, требуются следующие условия.

1. Необходимо создать ведущее приложение, надстройку и конвейер, как описано в документации [надстройки и расширения](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)) .NET Framework.

2. Интерфейс контракта для надстройки должен реализовывать <xref:System.AddIn.Contract.INativeHandleContract>.

3. Надстройка, передаваемая ведущему приложению, должна напрямую или косвенно наследовать от <xref:System.Windows.FrameworkElement>.

4. Перед пересечением границы изоляции надстройка должна быть преобразована из <xref:System.Windows.FrameworkElement> в <xref:System.AddIn.Contract.INativeHandleContract>.

5. После пересечения границы изоляции надстройка должна быть преобразована из <xref:System.AddIn.Contract.INativeHandleContract> в <xref:System.Windows.FrameworkElement>.

6. Ведущее приложение отображает возвращенный <xref:System.Windows.FrameworkElement>.

Пример, демонстрирующий реализацию надстройки, которая является пользовательским интерфейсом, см. в разделе [Создание надстройки, которая является пользовательским интерфейсом](how-to-create-an-add-in-that-is-a-ui.md).

<a name="ReturningMultipleUIsFromAnAddIn"></a>

## <a name="returning-multiple-uis-from-an-add-in"></a>Возвращение нескольких пользовательских интерфейсов из надстройки

Надстройки часто предоставляют несколько пользовательских интерфейсов для размещения отображаемых приложений. Например, рассмотрим надстройку, которая представляет собой пользовательский интерфейс, который также предоставляет ведущему приложению сведения о состоянии, также как пользовательский интерфейс. Такие надстройки можно реализовать с помощью сочетания методов из моделей [Надстройка возвращает пользовательский интерфейс](#ReturnUIFromAddInContract) и [Надстройка является пользовательским интерфейсом](#AddInIsAUI).

<a name="AddInsAndXBAPs"></a>

## <a name="add-ins-and-xaml-browser-applications"></a>Надстройки и приложения браузера XAML

В приведенных примерах ведущее приложение было установленным автономным приложением. Однако [!INCLUDE[TLA#tla_xbap#plural](../../../../includes/tlasharptla-xbapsharpplural-md.md)] также может размещать надстройки, хотя при этом применяются следующие дополнительные требования к сборке и реализации.

- Манифест приложения [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] должен быть настроен специально для загрузки конвейера (папок и сборок) и сборки надстройки в кэш приложения ClickOnce на клиентском компьютере в той же папке, что и [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)].

- Код [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] для обнаружения и загрузки надстроек должен использовать кэш приложения ClickOnce для [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] в качестве расположения конвейера и надстройки.

- [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] должен загрузить надстройку в специальный контекст безопасности, если надстройка ссылается на свободные файлы, расположенные на исходном узле. Если они размещаются в [!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)], надстройки могут ссылаться только на свободные файлы, расположенные на исходном узле ведущего приложения.

Эти задачи подробно описаны в следующих подразделах.

### <a name="configuring-the-pipeline-and-add-in-for-clickonce-deployment"></a>Настройка конвейера и надстройки для развертывания ClickOnce

[!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)] загружаются в защищенную папку в кэше развертывания ClickOnce и запускаются из нее. Для размещения надстройки в [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] конвейер и сборка надстройки также должны быть загружены в безопасную папку. Для этого нужно настроить манифест приложения для включения и конвейера и сборки надстройки для загрузки. Это проще всего сделать в Visual Studio, хотя сборка конвейера и надстройки должна находиться в корневой папке проекта Host [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)], чтобы Visual Studio смогла обнаружить сборки конвейера.

Следовательно, первый шаг — создать сборку конвейера и надстройки в корне проекта [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)], настроив выходные данные построения для каждого проекта сборки конвейера и сборки надстройки. В следующей таблице показаны выходные пути построения для проектов сборки конвейера и проекта сборки надстройки, которые находятся в том же решении и корневой папке, что и проект ведущего приложения [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)].

Таблица 1. Создание выходных путей построения для сборок конвейера, размещаемых в XBAP

|Проект сборки конвейера|Выходной путь сборки|
|-------------------------------|-----------------------|
|Контракт|`..\HostXBAP\Contracts\`|
|Представление надстройки|`..\HostXBAP\AddInViews\`|
|Адаптер надстройки|`..\HostXBAP\AddInSideAdapters\`|
|Адаптер приложения|`..\HostXBAP\HostSideAdapters\`|
|Надстройка|`..\HostXBAP\AddIns\WPFAddIn1`|

Следующим шагом является указание сборок конвейера и сборки надстройки в качестве файлов содержимого [!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)] в Visual Studio. для этого выполните следующие действия.

1. Включение сборки конвейера и надстройки в проект. Для этого следует щелкнуть правой кнопкой мыши каждую папку конвейера в обозревателе решений и выбрать вариант **Включить в проект**.

2. Установка для **Действия при построении** для каждой сборки конвейера и надстройки значения **Содержимое** в окне **Свойства**.

Последним шагом является настройка манифеста приложения для включения файлов сборки конвейера и файла сборки надстройки для загрузки. Файлы должны находиться в папках в корне папки в кэше ClickOnce, который занимает приложение [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]. Конфигурацию можно добиться в Visual Studio, выполнив следующие действия.

1. Щелкните правой кнопкой мыши проект [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)], выберите **Свойства**, **Публиковать**, а затем нажмите кнопку **Файлы приложения**.

2. В диалоговом окне **Файлы приложения** установите для параметра **Состояния публикации** каждой DLL конвейера и надстройки значение **Включить (авто)** , а для **Группы загрузки** для каждой DLL конвейера и надстройки — значение **(обязательно)** .

### <a name="using-the-pipeline-and-add-in-from-the-application-base"></a>Использование конвейера и надстройки из базовой папки приложения

Если конвейер и надстройка настроены для развертывания ClickOnce, они загружаются в ту же папку кэша ClickOnce, что и [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]. Чтобы использовать конвейер и надстройку из [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)], код [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] должен получить их из базовой папки приложения. Различные типы и члены модели надстроек .NET Framework для использования конвейеров и надстроек предоставляют специальную поддержку для этого сценария. Во-первых, путь определяется значением перечисления <xref:System.AddIn.Hosting.PipelineStoreLocation.ApplicationBase>. Это значение используется при перегрузках соответствующих элементов надстройки для использования конвейеров, которые включают следующее:

- <xref:System.AddIn.Hosting.AddInStore.FindAddIns%28System.Type%2CSystem.AddIn.Hosting.PipelineStoreLocation%29?displayProperty=nameWithType>

- <xref:System.AddIn.Hosting.AddInStore.FindAddIns%28System.Type%2CSystem.AddIn.Hosting.PipelineStoreLocation%2CSystem.String%5B%5D%29?displayProperty=nameWithType>

- <xref:System.AddIn.Hosting.AddInStore.Rebuild%28System.AddIn.Hosting.PipelineStoreLocation%29?displayProperty=nameWithType>

- <xref:System.AddIn.Hosting.AddInStore.Update%28System.AddIn.Hosting.PipelineStoreLocation%29?displayProperty=nameWithType>

### <a name="accessing-the-hosts-site-of-origin"></a>Доступ к исходному узлу ведущего приложения

Чтобы надстройка могла ссылаться на файлы с исходного узла, она должна быть загружена с изоляцией безопасности, эквивалентной ведущему приложению. Этот уровень безопасности определяется значением перечисления <xref:System.AddIn.Hosting.AddInSecurityLevel.Host?displayProperty=nameWithType> и передается методу <xref:System.AddIn.Hosting.AddInToken.Activate%2A> при активации надстройки.

<a name="WPFAddInModelArchitecture"></a>

## <a name="wpf-add-in-architecture"></a>Архитектура надстроек WPF

На самом верхнем уровне, как мы видели, WPF позволяет .NET Framework надстроек реализовывать пользовательские интерфейсы (которые прямо или косвенно наследуются от <xref:System.Windows.FrameworkElement>) с помощью <xref:System.AddIn.Contract.INativeHandleContract>, <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> и <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>. В результате ведущее приложение возвращает <xref:System.Windows.FrameworkElement>, отображаемое в пользовательском интерфейсе в ведущем приложении.

Для простых сценариев надстройки пользовательского интерфейса это все, что необходимо для разработчиков. Для более сложных сценариев, особенно тех, которые пытаются использовать дополнительные службы WPF, такие как макет, ресурсы и привязка данных, более подробные сведения о том, как WPF расширяет модель надстройки .NET Framework с поддержкой пользовательского интерфейса, необходимы для понимания его преимуществ. и ограничения.

В основном WPF не передает пользовательский интерфейс из надстройки в ведущее приложение; Вместо этого WPF передает маркер окна Win32 для пользовательского интерфейса с помощью взаимодействия WPF. Таким образом, при передаче пользовательского интерфейса из надстройки в ведущее приложение происходит следующее:

- На стороне надстройки WPF получает обработчик окна для пользовательского интерфейса, который будет отображаться ведущим приложением. Обработчик окна инкапсулируется внутренним классом WPF, который является производным от <xref:System.Windows.Interop.HwndSource> и реализует <xref:System.AddIn.Contract.INativeHandleContract>. Экземпляр этого класса возвращается <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> и маршалируется из домена приложения надстройки в домен приложения ведущего приложения.

- На стороне ведущего приложения WPF переупаковывает <xref:System.Windows.Interop.HwndSource> как внутренний класс WPF, производный от <xref:System.Windows.Interop.HwndHost> и использующий <xref:System.AddIn.Contract.INativeHandleContract>. Экземпляр этого класса возвращается <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> ведущему приложению.

<xref:System.Windows.Interop.HwndHost> существует для вывода пользовательских интерфейсов, идентифицируемых дескрипторами окон, из пользовательских интерфейсов WPF. Более подробную информацию см. в разделе [Взаимодействие WPF и Win32](../advanced/wpf-and-win32-interoperation.md).

В сводке, <xref:System.AddIn.Contract.INativeHandleContract>, <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>и <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> существуют, чтобы разрешить передачу оконного интерфейса WPF из надстройки в ведущее приложение, где оно инкапсулируется <xref:System.Windows.Interop.HwndHost> и отображает пользовательский интерфейс ведущего приложения.

> [!NOTE]
> Поскольку ведущее приложение получает <xref:System.Windows.Interop.HwndHost>, ведущее приложение не может преобразовать объект, возвращаемый <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>, в тип, который он реализует, как надстройка (например, <xref:System.Windows.Controls.UserControl>).

По своей природе <xref:System.Windows.Interop.HwndHost> имеет определенные ограничения, влияющие на то, как ведущие приложения могут их использовать. Однако WPF расширяет <xref:System.Windows.Interop.HwndHost> с несколькими возможностями для сценариев надстройки. Эти преимущества и ограничения описаны ниже.

<a name="WPFAddInModelBenefits"></a>

## <a name="wpf-add-in-benefits"></a>Преимущества надстройки WPF

Поскольку интерфейсы пользователя надстройки WPF отображаются из ведущих приложений с помощью внутреннего класса, производного от <xref:System.Windows.Interop.HwndHost>, эти пользовательские интерфейсы ограничены возможностями <xref:System.Windows.Interop.HwndHost> в отношении служб пользовательского интерфейса WPF, таких как макет, отрисовка, данные Привязка, стили, шаблоны и ресурсы. Однако WPF дополняет свой внутренний подкласс <xref:System.Windows.Interop.HwndHost> с дополнительными возможностями, включающими следующее:

- Переход между пользовательским интерфейсом ведущего приложения и пользовательским интерфейсом надстройки. Обратите внимание, что для модели программирования "надстройка — пользовательский интерфейс" требуется адаптер надстройки, переопределяющий <xref:System.AddIn.Pipeline.ContractBase.QueryContract%2A> включить переходы, будь то надстройка полностью доверенная или частично доверенная.

- Соблюдение требований к специальным возможностям для пользовательских интерфейсов надстроек, отображаемых из пользовательских интерфейсов ведущего приложения.

- Обеспечение безопасного запуска приложений WPF в нескольких сценариях домена приложений.

- Предотвращение недопустимого доступа к дескрипторам окон пользовательского интерфейса надстройки, когда надстройки работают с изоляцией безопасности (то есть песочницей безопасности с частичным доверием). Вызов <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> обеспечивает такую безопасность:

  - Для модели программирования "надстройка возвращает пользовательский интерфейс" единственным способом передачи маркера окна для пользовательского интерфейса надстройки через границу изоляции является вызов <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>.

  - Для модели программирования "надстройка — пользовательский интерфейс" переопределение <xref:System.AddIn.Pipeline.ContractBase.QueryContract%2A> на адаптере надстройки и вызов <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> (как показано в предыдущих примерах) является обязательным, как и вызов реализации `QueryContract` адаптера надстройки из адаптера на стороне главного приложения.

- Предоставление защиты выполнения нескольких доменов приложений. Из-за ограничений, связанных с доменами приложений, необработанные исключения, которые появляются в доменах приложений надстроек, вызывают сбой всего приложения, несмотря на наличие границы изоляции. Однако WPF и модель надстройки .NET Framework предоставляют простой способ решения этой проблемы и повышения стабильности работы приложения. Надстройка WPF, которая отображает пользовательский интерфейс, создает <xref:System.Windows.Threading.Dispatcher> для потока, в котором выполняется домен приложения, если ведущее приложение является приложением WPF. Вы можете обнаружить все необработанные исключения, происходящие в домене приложения, обрабатывая событие <xref:System.Windows.Threading.Dispatcher.UnhandledException> <xref:System.Windows.Threading.Dispatcher>надстройки WPF. <xref:System.Windows.Threading.Dispatcher> можно получить из свойства <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>.

<a name="WPFAddInModelLimitations"></a>

## <a name="wpf-add-in-limitations"></a>Ограничения надстройки WPF

Помимо преимуществ, которые WPF добавляет к поведению по умолчанию, предоставляемым <xref:System.Windows.Interop.HwndSource>, <xref:System.Windows.Interop.HwndHost>и дескрипторами окон, существуют также ограничения для пользовательских интерфейсов надстроек, отображаемых из ведущих приложений:

- Пользовательские интерфейсы надстройки, отображаемые из ведущего приложения, не учитывают поведение обрезки ведущего приложения.

- Концепция *свободного пространства* в сценариях взаимодействия также применяется к надстройкам (см. [Общие сведения о технологических областях](../advanced/technology-regions-overview.md)).

- Службы пользовательского интерфейса ведущего приложения, такие как наследование ресурсов, привязка данных и команды, не автоматически доступны для пользовательских интерфейсов надстройки. Чтобы предоставить эти службы для надстройки, необходимо обновить конвейер.

- Пользовательский интерфейс надстройки нельзя поворачивать, масштабировать, отклонять или иным образом затронуть преобразованием (см. [Общие сведения о преобразованиях](../graphics-multimedia/transforms-overview.md)).

- Содержимое внутри пользовательских интерфейсов надстройки, отображаемых операциями рисования из пространства имен <xref:System.Drawing>, может включать альфа-смешение. Однако пользовательский интерфейс надстройки и пользовательский интерфейс ведущего приложения, который его содержит, должны быть 100% непрозрачны; Иными словами, свойство `Opacity` для обоих должно иметь значение 1.

- Если свойство <xref:System.Windows.Window.AllowsTransparency%2A> окна в ведущем приложении, содержащем пользовательский интерфейс надстройки, имеет значение `true`, то надстройка невидима. Это справедливо, даже если пользовательский интерфейс надстройки равен 100% непрозрачен (т. е. свойство `Opacity` имеет значение 1).

- Пользовательский интерфейс надстройки должен отображаться поверх других элементов WPF в том же окне верхнего уровня.

- Ни одна часть пользовательского интерфейса надстройки не может быть отображена с помощью <xref:System.Windows.Media.VisualBrush>. Вместо этого надстройка может создать моментальный снимок созданного пользовательского интерфейса для создания точечного рисунка, который можно передать ведущему приложению с помощью методов, определенных контрактом.

- Воспроизведение файлов мультимедиа из <xref:System.Windows.Controls.MediaElement> в пользовательском интерфейсе надстройки невозможно.

- События мыши, созданные для пользовательского интерфейса надстройки, не получены и не вызываются ведущим приложением, а свойство `IsMouseOver` для пользовательского интерфейса ведущего приложения имеет значение `false`.

- При смене фокуса между элементами управления в пользовательском интерфейсе надстройки события `GotFocus` и `LostFocus` не поступают и не вызываются ведущим приложением.

- Часть ведущего приложения, содержащего пользовательский интерфейс надстройки, отображается белым цветом при печати.

- Все диспетчеры (см. <xref:System.Windows.Threading.Dispatcher>), созданные с помощью пользовательского интерфейса надстройки, должны быть выключены вручную перед выгрузкой надстройки-владельцем, если ведущее приложение продолжит выполнение. Контракт может реализовать методы, позволяющие ведущему приложению сигнализировать надстройку до выгрузки надстройки, тем самым позволяя пользовательскому интерфейсу надстройки завершить работу своих диспетчеров.

- Если пользовательский интерфейс надстройки является <xref:System.Windows.Controls.InkCanvas> или содержит <xref:System.Windows.Controls.InkCanvas>, то надстройку нельзя выгрузить.

<a name="PerformanceOptimization"></a>

## <a name="performance-optimization"></a>Оптимизация производительности

По умолчанию при использовании нескольких доменов приложений все сборки .NET Framework, необходимые для каждого приложения, загружаются в домен этого приложения. В результате время, необходимое для создания новых доменов приложений и запуска приложений в них, может повлиять на производительность. Однако .NET Framework позволяет сократить время запуска, предписывая приложениям совместно использовать сборки в разных доменах приложений, если они уже загружены. Для этого используется атрибут <xref:System.LoaderOptimizationAttribute>, который должен быть применен к методу точки входа (`Main`). В данном случае необходимо использовать только код для реализации определения приложения (см. [Общие сведения об управлении приложением](application-management-overview.md)).

## <a name="see-also"></a>См. также

- <xref:System.LoaderOptimizationAttribute>
- [Надстройки и расширения среды](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))
- [Домены приложений](../../app-domains/application-domains.md)
- [Общие сведения об удаленном взаимодействии .NET Framework](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/kwdt6w2k(v=vs.100))
- [Обеспечение удаленного взаимодействия объектов](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/wcf3swha(v=vs.100))
- [Разделы практического руководства](how-to-topics.md)
