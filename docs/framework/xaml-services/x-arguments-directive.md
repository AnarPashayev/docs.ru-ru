---
title: Директива x:Arguments
ms.date: 03/30/2017
helpviewer_keywords:
- x:Arguments directive [XAML Services]
- Arguments directive in XAML [XAML Services]
- XAML [XAML Services], x:Arguments directive
ms.assetid: 87cc10b0-b610-4025-b6b0-ab27ca27c92e
ms.openlocfilehash: a18de9a07839f5b01620311832b85667680c12ad
ms.sourcegitcommit: 289e06e904b72f34ac717dbcc5074239b977e707
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/17/2019
ms.locfileid: "71053831"
---
# <a name="xarguments-directive"></a>Директива x:Arguments
Пакеты законструкции аргументов для объявления элемента объекта конструктора без параметров в XAML или для объявления объекта фабричного метода.  
  
## <a name="xaml-element-usage-nonparameterless-constructor"></a>Использование элементов XAML (конструктор без параметров)  
  
```xaml  
<object ...>  
  <x:Arguments>  
    oneOrMoreObjectElements  
  </x:Arguments>  
</object>  
```  
  
## <a name="xaml-element-usage-factory-method"></a>Использование элементов XAML (фабричный метод)  
  
```xaml  
<object x:FactoryMethod="methodName"...>  
  <x:Arguments>  
    oneOrMoreObjectElements  
  </x:Arguments>  
</object>  
```  
  
## <a name="xaml-values"></a>Значения XAML  
  
|||  
|-|-|  
|`oneOrMoreObjectElements`|Один или несколько объектных элементов, задающих аргументы, передаваемые в резервный конструктор без параметров или фабричный метод.<br /><br /> Типичное использование — использование текста инициализации в элементах объекта для указания фактических значений аргументов. См. раздел "примеры".<br /><br /> Порядок элементов важен. Типы XAML в порядке должны соответствовать типам и порядковому номеру метода резервного конструктора или фабричной перегрузки.|  
|`methodName`|Имя метода фабрики, который должен обрабатывать любые `x:Arguments` аргументы.|  
  
## <a name="dependencies"></a>Зависимости  
 `x:FactoryMethod`может изменять область и поведение, когда `x:Arguments` это применимо.  
  
 Если параметр `x:FactoryMethod` не указан, `x:Arguments` применяется к альтернативным (не по умолчанию) сигнатурам резервных конструкторов.  
  
 Если `x:FactoryMethod` указан аргумент, `x:Arguments` применяется к перегрузке именованного метода.  
  
## <a name="remarks"></a>Примечания  
 XAML 2006 может поддерживать инициализацию не по умолчанию посредством текста инициализации. Однако практическое применение метода создания текста инициализации ограничено. Текст инициализации рассматривается как отдельная текстовая строка; Поэтому он добавляет только возможность для инициализации одного параметра, если только преобразователь типов не определен для поведения конструирования, который может анализировать пользовательские элементы данных и пользовательские разделители из строки. Кроме того, Текстовая строка в объектной логике, возможно, является собственным преобразователем собственных типов по умолчанию средства синтаксического анализа XAML для обработки примитивов, отличных от истинной строки.  
  
 Использование `x:Arguments` XAML не является элементом свойства в типичном смысле, поскольку разметка директивы не ссылается на тип содержащего его элемента. Это более то же самое, что `x:Code` и другие директивы, например, где элемент отмечает диапазон, в котором разметка должна интерпретироваться как значение, отличное от значения по умолчанию для дочернего содержимого. В этом случае тип XAML каждого элемента объекта передает сведения о типах аргументов, которые используются анализаторами XAML для определения конкретной сигнатуры `x:Arguments` метода фабрики конструктора, на которую пытается ссылаться использование.  
  
 `x:Arguments`для создаваемого объектного элемента должен предшествовать любым другим элементам свойств, содержимому, внутреннему тексту или строкам инициализации объектного элемента. Элементы объекта в `x:Arguments` могут включать атрибуты и строки инициализации, как это разрешено этим типом XAML и его резервным конструктором или фабричным методом. Для объекта или аргументов можно указать пользовательские типы XAML или типы XAML, которые в противном случае выходят за пределы пространства имен XAML по умолчанию, ссылаясь на установленные сопоставления префиксов.  
  
 Обработчики XAML применяют следующие рекомендации, чтобы определить, как `x:Arguments` аргументы, заданные в, должны использоваться для создания объекта. Если `x:FactoryMethod` указан параметр, сведения сравниваются с указанным `x:FactoryMethod` ( `x:FactoryMethod` Обратите внимание, что значение является именем метода, а именованный метод может иметь перегрузки). Если `x:FactoryMethod` параметр не указан, сведения сравниваются с набором всех перегрузок открытого конструктора объекта. Затем логика обработки XAML сравнивает количество параметров и выбирает перегрузку с соответствующей арностью. При наличии нескольких совпадений обработчик XAML должен сравнивать типы параметров на основе типов XAML предоставленных элементов объекта. Если по-прежнему существует более одного совпадения, поведение обработчика XAML не определено. `x:FactoryMethod` Если указан, но метод не может быть разрешен, обработчик XAML должен вызвать исключение.  
  
 Использование `<x:Arguments>string</x:Arguments>` атрибута XAML технически возможно. Однако это не дает никаких возможностей, помимо того, что может быть сделано в противном случае посредством инициализации текста и преобразователей типов, и использование этого синтаксиса не является намерением разработки функций метода фабрики XAML 2009.  
  
## <a name="examples"></a>Примеры  
 В следующем примере показана сигнатура конструктора без параметров, а затем использование XAML для `x:Arguments` доступа к этой сигнатуре.  
  
```csharp  
public class Food {  
    private string _name;  
    private Int32 _calories;  
    public Food(string name, Int32 calories) {  
        _name=name;  
        _calories=calories;  
    }  
}  
```  
  
```xaml  
<my:Food>  
    <x:Arguments>  
        <x:String>Apple</x:String>  
        <x:Int32>150</x:Int32>  
    </x:Arguments>  
</my:Food>  
```  
  
 В следующем примере показана сигнатура целевого метода фабрики, а затем использование `x:Arguments` XAML для доступа к этой сигнатуре.  
  
```csharp  
public Food TryLookupFood(string name)  
{  
  switch (name) {  
    case "Apple": return new Food("Apple",150);  
    case "Chocolate": return new Food("Chocolate",200);  
    case "Cheese": return new Food("Cheese", 450);  
    default: {return new Food(name,0);  
  }  
}  
```  
  
```xaml  
<my:Food x:FactoryMethod="TryLookupFood">  
    <x:Arguments>  
        <x:String>Apple</x:String>  
    </x:Arguments>  
</my:Food>  
```  
  
## <a name="see-also"></a>См. также

- [Определение пользовательских типов для использования со службами XAML .NET Framework](defining-custom-types-for-use-with-net-framework-xaml-services.md)
- [Общие сведения о языке XAML (WPF)](../wpf/advanced/xaml-overview-wpf.md)
