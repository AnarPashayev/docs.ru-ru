---
title: Определение пользовательских типов для использования со службами XAML .NET Framework
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: e563c0d7e5113d55d4b942fb1d175a64f5b71abc
ms.sourcegitcommit: 30a83efb57c468da74e9e218de26cf88d3254597
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/20/2019
ms.locfileid: "68364290"
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a><span data-ttu-id="0e0e1-102">Определение пользовательских типов для использования со службами XAML .NET Framework</span><span class="sxs-lookup"><span data-stu-id="0e0e1-102">Defining Custom Types for Use with .NET Framework XAML Services</span></span>
<span data-ttu-id="0e0e1-103">При определении пользовательских типов, которые являются бизнес-объектами или типами, не имеющими зависимости от конкретных платформ, можно следовать определенным рекомендациям по XAML.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="0e0e1-104">При соблюдении этих рекомендаций .NET Framework службы XAML и их средства чтения и записи XAML могут обнаружить характеристики XAML вашего типа и предоставить ему соответствующее представление в потоке узлов XAML, используя систему типов XAML.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-104">If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="0e0e1-105">В этом разделе описываются рекомендации по определениям типов, определениям членов и присвоению атрибутов типов или членов в среде CLR.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="0e0e1-106">Шаблоны конструктора и определения типов для XAML</span><span class="sxs-lookup"><span data-stu-id="0e0e1-106">Constructor Patterns and Type Definitions for XAML</span></span>  
 <span data-ttu-id="0e0e1-107">Для создания экземпляра в виде объектного элемента в XAML пользовательский класс должен удовлетворять следующим требованиям.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>  
  
- <span data-ttu-id="0e0e1-108">Пользовательский класс должен быть открытым и должен предоставлять открытый конструктор по умолчанию (без параметров).</span><span class="sxs-lookup"><span data-stu-id="0e0e1-108">The custom class must be public and must expose a default (parameterless) public constructor.</span></span> <span data-ttu-id="0e0e1-109">(Примечания о структурах см. в следующем разделе.)</span><span class="sxs-lookup"><span data-stu-id="0e0e1-109">(See following section for notes regarding structures.)</span></span>  
  
- <span data-ttu-id="0e0e1-110">Пользовательский класс не должен быть вложенным классом.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="0e0e1-111">Дополнительный "точка" в пути Full-Name делает деление класса-пространства неоднозначным и влияет на другие функции XAML, такие как вложенные свойства.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="0e0e1-112">Если объект может быть создан как объектный элемент, созданный объект может заполнить форму элемента свойства любых свойств, которые принимают объект в качестве базового типа.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>  
  
 <span data-ttu-id="0e0e1-113">При включении преобразователя значений можно по-прежнему предоставлять значения объектов для типов, которые не соответствуют этим критериям.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="0e0e1-114">Дополнительные сведения см. в разделе [преобразователи типов и расширения разметки для XAML](type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="0e0e1-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
### <a name="structures"></a><span data-ttu-id="0e0e1-115">Структуры</span><span class="sxs-lookup"><span data-stu-id="0e0e1-115">Structures</span></span>  
 <span data-ttu-id="0e0e1-116">Структуры всегда могут быть построены в XAML, по определению среды CLR.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="0e0e1-117">Это обусловлено тем, что компилятор CLR неявно создает конструктор без параметров для структуры.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-117">This is because a CLR compiler implicitly creates a parameterless constructor for a structure.</span></span> <span data-ttu-id="0e0e1-118">Этот конструктор инициализирует все значения свойств значениями по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-118">This constructor initializes all property values to their defaults.</span></span>  
  
 <span data-ttu-id="0e0e1-119">В некоторых случаях поведение конструирования по умолчанию для структуры не желательно.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="0e0e1-120">Это может быть вызвано тем, что структура предназначена для заполнения значений и концептуально работает как объединение.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="0e0e1-121">Как объединение, содержащиеся значения могут иметь взаимоисключающие интерпретации, поэтому ни одно из его свойств не может быть задано.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="0e0e1-122">Примером такой структуры в словаре WPF является <xref:System.Windows.GridLength>.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="0e0e1-123">Такие структуры должны реализовывать преобразователь типов, чтобы значения можно было выразить в форме атрибутов с помощью строковых соглашений, которые создают различные интерпретации или режимы значений структуры.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="0e0e1-124">Структура должна также предоставлять аналогичное поведение для построения кода с помощью конструктора без параметров.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-124">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="0e0e1-125">Интерфейсы</span><span class="sxs-lookup"><span data-stu-id="0e0e1-125">Interfaces</span></span>  
 <span data-ttu-id="0e0e1-126">Интерфейсы можно использовать в качестве базовых типов элементов.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="0e0e1-127">Система типов XAML проверяет присваиваемый список и ждет, что объект, предоставленный в качестве значения, может быть назначен интерфейсу.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="0e0e1-128">Не существует концепции того, как интерфейс должен быть представлен как тип XAML, если соответствующий назначаемый тип поддерживает требования к конструкции XAML.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>  
  
### <a name="factory-methods"></a><span data-ttu-id="0e0e1-129">Фабричные методы</span><span class="sxs-lookup"><span data-stu-id="0e0e1-129">Factory Methods</span></span>  
 <span data-ttu-id="0e0e1-130">Заводские методы являются функцией XAML 2009.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="0e0e1-131">Они изменяют принцип XAML, в котором объекты должны иметь конструкторы без параметров.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-131">They modify the XAML principle that objects must have parameterless constructors.</span></span> <span data-ttu-id="0e0e1-132">В этом разделе не описаны заводские методы.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-132">Factory methods are not documented in this topic.</span></span> <span data-ttu-id="0e0e1-133">См. раздел [Директива x:FactoryMethod](x-factorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="0e0e1-133">See [x:FactoryMethod Directive](x-factorymethod-directive.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="0e0e1-134">Перечисления</span><span class="sxs-lookup"><span data-stu-id="0e0e1-134">Enumerations</span></span>  
 <span data-ttu-id="0e0e1-135">Перечисления имеют поведение преобразования собственного типа XAML.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="0e0e1-136">Имена констант перечисления, указанные в XAML, разрешаются для базового типа перечисления и возвращают значение перечисления в средство записи объектов XAML.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>  
  
 <span data-ttu-id="0e0e1-137">XAML поддерживает использование флагов для перечислений с <xref:System.FlagsAttribute> применением.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="0e0e1-138">Дополнительные сведения см. [в разделе Подробное описание синтаксиса XAML](../wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="0e0e1-138">For more information, see [XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="0e0e1-139">([Подробное описание синтаксиса XAML](../wpf/advanced/xaml-syntax-in-detail.md) написано для аудитории WPF, но большая часть информации в этом разделе ОТНОСИТСЯ к XAML, который не относится к конкретной реализующей платформе.)</span><span class="sxs-lookup"><span data-stu-id="0e0e1-139">([XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>  
  
## <a name="member-definitions"></a><span data-ttu-id="0e0e1-140">Определения элементов</span><span class="sxs-lookup"><span data-stu-id="0e0e1-140">Member Definitions</span></span>  
 <span data-ttu-id="0e0e1-141">Типы могут определять элементы для использования XAML.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="0e0e1-142">Типы, определяющие элементы, которые используются XAML, могут использоваться, даже если этот конкретный тип не может использоваться в XAML.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-142">It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="0e0e1-143">Это возможно благодаря наследованию CLR.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="0e0e1-144">До тех пор, пока какой-либо тип, наследующий член, поддерживает использование XAML в качестве типа, а член поддерживает использование XAML для базового типа или имеет доступ к собственному синтаксису XAML, этот член может использоваться в XAML.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>  
  
### <a name="properties"></a><span data-ttu-id="0e0e1-145">Свойства</span><span class="sxs-lookup"><span data-stu-id="0e0e1-145">Properties</span></span>  
 <span data-ttu-id="0e0e1-146">Если вы определяете свойства как общедоступное свойство CLR с помощью `get` стандартных `set` шаблонов CLR и методов доступа и ключевых слов, соответствующих языку, система типов XAML может сообщить о свойстве как члену с соответствующей информацией, предоставленной для свойства, такие как <xref:System.Xaml.XamlMember.IsReadPublic%2A> и <xref:System.Xaml.XamlMember.IsWritePublic%2A>. <xref:System.Xaml.XamlMember></span><span class="sxs-lookup"><span data-stu-id="0e0e1-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>  
  
 <span data-ttu-id="0e0e1-147">Определенные свойства могут включать текстовый синтаксис путем применения <xref:System.ComponentModel.TypeConverterAttribute>.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="0e0e1-148">Дополнительные сведения см. в разделе [преобразователи типов и расширения разметки для XAML](type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="0e0e1-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
 <span data-ttu-id="0e0e1-149">В отсутствие текстового синтаксиса или преобразования машинного кода XAML, а также при отсутствии дальнейших косвенных обращений, таких как использование расширения разметки, тип свойства (<xref:System.Xaml.XamlMember.TargetType%2A> в системе типов XAML) должен иметь возможность возвращать экземпляр в средство записи объектов XAML, рассматривая t Тип arget в виде типа CLR.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>  
  
 <span data-ttu-id="0e0e1-150">Если используется XAML 2009, [расширение разметки x:Reference](x-reference-markup-extension.md) можно использовать для предоставления значений, если предыдущие рекомендации не выполняются. Однако это является более частью проблемы использования, чем проблемы с определением типа.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-150">If using XAML 2009, [x:Reference Markup Extension](x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>  
  
### <a name="events"></a><span data-ttu-id="0e0e1-151">События</span><span class="sxs-lookup"><span data-stu-id="0e0e1-151">Events</span></span>  
 <span data-ttu-id="0e0e1-152">Если вы определяете события как общедоступное событие CLR, система типов XAML может сообщить о событии как члену `true`с <xref:System.Xaml.XamlMember.IsEvent%2A> именем.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="0e0e1-153">Связывание обработчиков событий выходит за рамки .NET Framework возможностей служб XAML. Это оставлено конкретным платформам и реализациям.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-153">Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.</span></span>  
  
### <a name="methods"></a><span data-ttu-id="0e0e1-154">Методы</span><span class="sxs-lookup"><span data-stu-id="0e0e1-154">Methods</span></span>  
 <span data-ttu-id="0e0e1-155">Встроенный код для методов не является возможностью XAML по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="0e0e1-156">В большинстве случаев не следует напрямую ссылаться на члены методов из XAML, а роль методов в XAML — предоставить поддержку для конкретных шаблонов XAML.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-156">In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="0e0e1-157">[Директива x:FactoryMethod](x-factorymethod-directive.md) является исключением.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-157">[x:FactoryMethod Directive](x-factorymethod-directive.md) is an exception.</span></span>  
  
### <a name="fields"></a><span data-ttu-id="0e0e1-158">Поля</span><span class="sxs-lookup"><span data-stu-id="0e0e1-158">Fields</span></span>  
 <span data-ttu-id="0e0e1-159">Рекомендации по проектированию среды CLR не допустают нестатических полей.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="0e0e1-160">Для статических полей доступ к значениям статических полей можно получить только с помощью [расширения разметки x:Static](x-static-markup-extension.md). в этом случае не выполняется никаких специальных действий в определении CLR для предоставления поля для использования в [x:Static](x-static-markup-extension.md) .</span><span class="sxs-lookup"><span data-stu-id="0e0e1-160">For static fields, you can access static field values only through [x:Static Markup Extension](x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](x-static-markup-extension.md) usages.</span></span>  
  
## <a name="attachable-members"></a><span data-ttu-id="0e0e1-161">Присоединяемые члены</span><span class="sxs-lookup"><span data-stu-id="0e0e1-161">Attachable Members</span></span>  
 <span data-ttu-id="0e0e1-162">Присоединяемые члены предоставляются XAML через шаблон метода доступа для определяющего типа.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="0e0e1-163">Сам определяющий тип не обязательно должен быть доступен для использования в XAML как объект.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="0e0e1-164">На самом деле, распространенным шаблоном является объявление класса службы, роль которого заключается в том, чтобы присоединить присоединяемый член и реализовать соответствующие поведения, но не обслуживает другие функции, такие как представление пользовательского интерфейса.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="0e0e1-165">В следующих разделах местозаполнитель *PropertyName* представляет имя присоединяемого члена.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="0e0e1-166">Это имя должно быть допустимым в [грамматике имяxaml](xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="0e0e1-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>  
  
 <span data-ttu-id="0e0e1-167">Соблюдайте осторожность при конфликтах имен между этими шаблонами и другими методами типа.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="0e0e1-168">Если существует элемент, совпадающий с одним из шаблонов, он может быть интерпретирован обработчиком XAML как присоединяемый путь использования члена, даже если это не ваша цель.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>  
  
#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="0e0e1-169">Метод доступа ИмяСвойства</span><span class="sxs-lookup"><span data-stu-id="0e0e1-169">The GetPropertyName Accessor</span></span>  
 <span data-ttu-id="0e0e1-170">Сигнатура для метода доступа `Get`*ИмяСвойства* должна быть следующей.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-170">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="0e0e1-171">`public static object Get` *ИмяСвойства* `(object` `target` `)`</span><span class="sxs-lookup"><span data-stu-id="0e0e1-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span></span>  
  
- <span data-ttu-id="0e0e1-172">Объект `target` можно указать как более конкретный тип в реализации.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-172">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="0e0e1-173">Его можно использовать для определения области использования присоединяемого члена; использование за пределами предполагаемой области действия приведет к созданию недопустимых исключений приведения, которые затем выводятся в результате ошибки синтаксического анализа XAML.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-173">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="0e0e1-174">Имя `target` параметра не является обязательным, но в большинстве реализаций `target` оно называется по соглашению.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-174">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>  
  
- <span data-ttu-id="0e0e1-175">Возвращаемое значение можно указать как более конкретный тип в реализации.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-175">The return value can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="0e0e1-176">Чтобы обеспечить поддержку <xref:System.ComponentModel.TypeConverter> синтаксиса текста для присоединяемого элемента, примените <xref:System.ComponentModel.TypeConverterAttribute> к `Get`методу доступа *PropertyName* .</span><span class="sxs-lookup"><span data-stu-id="0e0e1-176">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor.</span></span> <span data-ttu-id="0e0e1-177">Применение к `get` вместо `set` этого может показаться неинтуитивным; однако это соглашение может поддерживать концепцию присоединяемых членов только для чтения, которые являются сериализуемыми, что полезно в сценариях конструктора.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-177">Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>  
  
#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="0e0e1-178">Метод доступа Сетпропертинаме</span><span class="sxs-lookup"><span data-stu-id="0e0e1-178">The SetPropertyName Accessor</span></span>  
 <span data-ttu-id="0e0e1-179">Сигнатура для метода доступа set*PropertyName* должна иметь следующее значение:</span><span class="sxs-lookup"><span data-stu-id="0e0e1-179">The signature for the Set*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="0e0e1-180">`public static void Set` *ИмяСвойства* `(object` `target` `, object` `value` `)`</span><span class="sxs-lookup"><span data-stu-id="0e0e1-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span></span>  
  
- <span data-ttu-id="0e0e1-181">`target` Объект может быть указан в реализации в качестве более конкретного типа с той же логикой и последствиями, как описано в предыдущем разделе.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-181">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>  
  
- <span data-ttu-id="0e0e1-182">Объект `value` можно указать как более конкретный тип в реализации.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-182">The `value` object can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="0e0e1-183">Помните, что значение этого метода является входными данными, поступающими от использования XAML, обычно в форме атрибута.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-183">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="0e0e1-184">В форме атрибута должна быть поддержка преобразователя значений для текстового синтаксиса, и атрибут для `Get`метода доступа *PropertyName* .</span><span class="sxs-lookup"><span data-stu-id="0e0e1-184">From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.</span></span>  
  
### <a name="attachable-member-stores"></a><span data-ttu-id="0e0e1-185">Хранилища присоединяемых членов</span><span class="sxs-lookup"><span data-stu-id="0e0e1-185">Attachable Member Stores</span></span>  
 <span data-ttu-id="0e0e1-186">Методы доступа обычно недостаточно для предоставления средств для размещения значений присоединяемых членов в графе объектов, а также для извлечения значений из графа объектов и их правильной сериализации.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-186">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="0e0e1-187">Чтобы обеспечить эту функциональность, `target` объекты в предыдущих сигнатурах метода доступа должны иметь возможность хранить значения.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-187">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="0e0e1-188">Механизм хранения должен соответствовать принципу присоединяемого члена, который прикрепляется к целевым объектам, в которых присоединяемый элемент отсутствует в списке членов.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-188">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="0e0e1-189">.NET Framework службы XAML предоставляют метод реализации для присоединяемых хранилищ членов через API- <xref:System.Xaml.IAttachedPropertyStore> интерфейсы <xref:System.Xaml.AttachablePropertyServices>и.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-189">.NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="0e0e1-190"><xref:System.Xaml.IAttachedPropertyStore>используется модулями записи XAML для обнаружения реализации хранилища и должен быть реализован в типе, который является `target` методом доступа.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-190"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="0e0e1-191">Статические <xref:System.Xaml.AttachablePropertyServices> API-интерфейсы используются в теле методов доступа и ссылаются на присоединяемый член по его <xref:System.Xaml.AttachableMemberIdentifier>свойству.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-191">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>  
  
## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="0e0e1-192">Связанные с XAML атрибуты среды CLR</span><span class="sxs-lookup"><span data-stu-id="0e0e1-192">XAML-Related CLR Attributes</span></span>  
 <span data-ttu-id="0e0e1-193">Правильное присвоение атрибутов типам, членам и сборкам важно для передачи сведений о системе типов XAML .NET Framework службам XAML.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-193">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.</span></span> <span data-ttu-id="0e0e1-194">Это уместно, если вы планируете использовать типы для систем XAML, которые непосредственно основаны на .NET Framework средств чтения XAML служб XAML и модулях записи XAML, или если вы определили или используете платформу, использующую XAML, основанную на этих средствах чтения и записи XAML.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-194">This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.</span></span>  
  
 <span data-ttu-id="0e0e1-195">Список всех атрибутов, связанных с XAML, которые относятся к поддержке XAML пользовательских типов, см. в разделе связанные с XAML [атрибуты среды CLR для пользовательских типов и библиотек](xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="0e0e1-195">For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span></span>  
  
## <a name="usage"></a><span data-ttu-id="0e0e1-196">Использование</span><span class="sxs-lookup"><span data-stu-id="0e0e1-196">Usage</span></span>  
 <span data-ttu-id="0e0e1-197">Для использования пользовательских типов необходимо, чтобы автор разметки сопоставлял префикс для сборки и пространство имен CLR, которое содержит пользовательский тип.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="0e0e1-198">Эта процедура не описана в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-198">This procedure is not documented in this topic.</span></span>  
  
## <a name="access-level"></a><span data-ttu-id="0e0e1-199">Уровень доступа</span><span class="sxs-lookup"><span data-stu-id="0e0e1-199">Access Level</span></span>  
 <span data-ttu-id="0e0e1-200">XAML предоставляет средства для загрузки и создания экземпляров типов, имеющих `internal` уровень доступа.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="0e0e1-201">Эта возможность предоставляется, чтобы пользовательский код мог определять собственные типы, а затем создавать экземпляры этих классов из разметки, которая также является частью одной и той же области пользовательского кода.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>  
  
 <span data-ttu-id="0e0e1-202">Примером из WPF является каждый раз <xref:System.Windows.Controls.UserControl> , когда пользовательский код определяет, который предназначен для оптимизации поведения пользовательского интерфейса, но не является частью любого возможного механизма расширения, который может быть подразумеваемым объявлением поддерживающего класса с `public` уровнем доступа.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="0e0e1-203">Такой объект <xref:System.Windows.Controls.UserControl> может быть объявлен с `internal` доступом, если резервный код компилируется в ту же сборку, из которой он ссылается как на тип XAML.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>  
  
 <span data-ttu-id="0e0e1-204">Для приложения, которое загружает XAML в режиме полного доверия <xref:System.Xaml.XamlObjectWriter>и использует, Загрузка `internal` классов с уровнем доступа всегда включена.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>  
  
 <span data-ttu-id="0e0e1-205">Для приложения, которое загружает XAML в режиме частичного доверия, можно управлять характеристиками уровня доступа с <xref:System.Xaml.Permissions.XamlAccessLevel> помощью API.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="0e0e1-206">Кроме того, механизмы отсрочки (например, система шаблонов WPF) должны иметь возможность распространять любые разрешения уровня доступа и сохранять их для выполнения в конечном итоге. Это осуществляется внутренним образом путем передачи <xref:System.Xaml.Permissions.XamlAccessLevel> информации.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>  
  
### <a name="wpf-implementation"></a><span data-ttu-id="0e0e1-207">Реализация WPF</span><span class="sxs-lookup"><span data-stu-id="0e0e1-207">WPF Implementation</span></span>  
 <span data-ttu-id="0e0e1-208">XAML WPF использует модель доступа с частичным доверием, где при загрузке BAML в режиме частичного доверия доступ ограничен <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> для сборки, являющейся источником BAML.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="0e0e1-209">Для РБП WPF использует <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> в качестве механизма для передачи сведений об уровне доступа.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>  
  
 <span data-ttu-id="0e0e1-210">В терминологии WPF XAML *внутренний тип* — это тип, определяемый той же сборкой, которая также включает ссылающийся XAML.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="0e0e1-211">Такой тип можно сопоставить с помощью пространства имен XAML, которое намеренно опускает сборку = часть сопоставления, например `xmlns:local="clr-namespace:WPFApplication1"`.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span>  <span data-ttu-id="0e0e1-212">Если BAML ссылается на внутренний тип, а этот тип `internal` имеет уровень доступа, то `GeneratedInternalTypeHelper` создается класс для сборки.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="0e0e1-213">Если вы хотите избежать `GeneratedInternalTypeHelper`, необходимо либо использовать `public` уровень доступа, либо отнести соответствующий класс к отдельной сборке и сделать ее зависимой.</span><span class="sxs-lookup"><span data-stu-id="0e0e1-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="0e0e1-214">См. также</span><span class="sxs-lookup"><span data-stu-id="0e0e1-214">See also</span></span>

- [<span data-ttu-id="0e0e1-215">Относящиеся к XAML атрибуты среды CLR для пользовательских типов и библиотек</span><span class="sxs-lookup"><span data-stu-id="0e0e1-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](xaml-related-clr-attributes-for-custom-types-and-libraries.md)
- [<span data-ttu-id="0e0e1-216">Службы XAML</span><span class="sxs-lookup"><span data-stu-id="0e0e1-216">XAML Services</span></span>](index.md)
