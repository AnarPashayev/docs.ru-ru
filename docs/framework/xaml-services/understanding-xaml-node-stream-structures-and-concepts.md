---
title: Общее представление о понятиях и структурах потока узлов XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML node streams [XAML Services]
- nodes [XAML Services], XAML node stream
- XAML [XAML Services], XAML node streams
ms.assetid: 7c11abec-1075-474c-9d9b-778e5dab21c3
ms.openlocfilehash: 2c8093c3ef497bd836427f71098e62626f228e24
ms.sourcegitcommit: 22be09204266253d45ece46f51cc6f080f2b3fd6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/07/2019
ms.locfileid: "73733390"
---
# <a name="understanding-xaml-node-stream-structures-and-concepts"></a>Общее представление о понятиях и структурах потока узлов XAML

Средства чтения и записи XAML, реализованные в службах XAML .NET Framework, основаны на принципе проектирования потока узлов XAML. Поток узлов XAML — это концептуальное представление набора узлов XAML. В этом концептуальном представлении обработчик XAML проходит по структуре связей узлов в XAML поочередно. В каждый момент времени в открытом потоке узлов XAML существует только одна текущая запись или текущая позиция, и многие аспекты API сообщают только информацию, доступную из этой позиции. Текущий узел в потоке узлов XAML можно описать как объект, член или значение. Рассматривая XAML как поток узлов XAML, средства чтения XAML могут взаимодействовать со средствами записи XAML и позволять программе просматривать содержимое потока узлов XAML, взаимодействовать с ним или изменять его во время функционирования пути загрузки или пути сохранения, использующего XAML. Структура API средства чтения и записи XAML и концепция потока узлов XAML аналогичны предыдущим проектам и концепциям модуля чтения и записи, таким как XML-модель DOM (DOM) и классы <xref:System.Xml.XmlReader> и <xref:System.Xml.XmlWriter>. В этом разделе рассматриваются концепции потока узлов XAML и описывается, как можно создавать подпрограммы, взаимодействующие с представлениями XAML на уровне узлов XAML.

<a name="loading_into_a_xaml_reader"></a>

## <a name="loading-xaml-into-a-xaml-reader"></a>Загрузка XAML в средство чтения XAML

Базовый класс <xref:System.Xaml.XamlReader> не объявляет конкретный метод загрузки исходного XAML в средство чтения XAML. Вместо этого метод загрузки, включая общие характеристики и ограничения его источника входных данных для XAML, объявляет и реализует производный класс. Например, класс <xref:System.Xaml.XamlObjectReader> читает граф объектов, начиная с источника входных данных одного объекта, который представляет корень или базу. Затем класс <xref:System.Xaml.XamlObjectReader> создает поток узлов XAML из этого графа объектов.

Наиболее показательным подклассом <xref:System.Xaml.XamlReader> , задаваемым службами XAML .NET Framework, является <xref:System.Xaml.XamlXmlReader>. Подкласс<xref:System.Xaml.XamlXmlReader> загружает исходный XAML либо непосредственно, путем загрузки текстового файла через поток или путь к файлу, либо косвенно — через связанный класс средства чтения, такой как <xref:System.IO.TextReader>. Класс <xref:System.Xaml.XamlReader> можно рассматривать как содержащий весь источник входных данных XAML после его загрузки. Однако базовый API <xref:System.Xaml.XamlReader> разработан таким образом, чтобы средство чтения взаимодействовало с одним узлом XAML. После первой загрузки первый обнаруженный узел является корнем XAML и его начальным объектом.

### <a name="the-xaml-node-stream-concept"></a>Концепция потока узлов XAML

Если вам в целом более знакома модель DOM, представление в виде дерева или подход на основе запроса в отношении доступа к XML-технологиям, то удобнее всего объяснить поток узлов XAML следующим образом. Представьте себе загруженный XAML в виде модели DOM или дерева, где каждый возможный узел полностью развернут, а затем представлен в линейной форме. При переходе по узлам вы можете проходить «в» уровни или «из» уровней, которые относятся к модели DOM, но поток узлов XAML явно не отслеживается, так как эти понятия уровней не относятся к потоку узлов. Поток узлов имеет «текущую» позицию, но пока вы самостоятельно не сохраните другие части потока как ссылки, любой аспект потока узлов, кроме текущего положения узла, находится вне поля зрения за пределами окна просмотра.

Существенное преимущество концепции потока узлов XAML заключается в том, что при проходе по всему потоку узла будет гарантированно обработано все представление XAML; не нужно беспокоиться, что запрос, операция DOM или какой-либо другой нелинейный способ обработки информации пропустит часть представления XAML. По этой причине представление потока узлов XAML идеально подходит как для соединения средств чтения и записи XAML, так и для построения системы, в которой можно вставить собственный процесс, выполняемый между этапами чтения и записи операции обработки XAML. Во многих случаях порядок узлов в потоке узлов XAML намеренно оптимизируется или изменяется средствами чтения XAML по сравнению с тем порядком, который может отображаться в исходном тексте, двоичном объекте или графе объекта. Это поведение предусмотрено для обеспечения архитектуры обработки XAML, в которой средства записи XAML никогда не оказываются в позиции, где они должны переходить «назад» в потоке узлов. В идеале все операции записи XAML должны быть способны выполняться на основе контекста схемы и текущей позиции в потоке узлов.

<a name="a_basic_reading_node_loop"></a>

## <a name="a-basic-reading-node-loop"></a>Основной цикл узлов чтения

Основной цикл узлов чтения для анализа потока узлов XAML включает следующие концепции. Применительно к циклам узлов, рассматриваемым в этом разделе, предположим, что вы читаете понятный для пользователя текстовый файл XAML с помощью <xref:System.Xaml.XamlXmlReader>. Ссылки в этом разделе относятся к конкретному API цикла узлов XAML, реализуемому <xref:System.Xaml.XamlXmlReader>.

- Убедитесь, что вы не находитесь в конце потока узлов XAML (проверьте <xref:System.Xaml.XamlXmlReader.IsEof%2A>, или используйте возвращаемое значение <xref:System.Xaml.XamlXmlReader.Read%2A> ). Если вы находитесь в конце потока, то текущий узел отсутствует и следует выйти.

- Проверьте, какой тип узла предоставляет в настоящий момент поток узлов XAML, путем вызова <xref:System.Xaml.XamlXmlReader.NodeType%2A>.

- Если имеется связанное средство записи объектов XAML, которое подключено напрямую, то на этом этапе обычно вызывается метод <xref:System.Xaml.XamlWriter.WriteNode%2A> .

- В зависимости от типа <xref:System.Xaml.XamlNodeType> , возвращенного для текущего узла или текущей записи, вызовите один из следующих объектов, чтобы получить сведения о содержимом узла.

  - Для типа <xref:System.Xaml.XamlXmlReader.NodeType%2A> объекта <xref:System.Xaml.XamlNodeType.StartMember> или <xref:System.Xaml.XamlNodeType.EndMember>вызовите <xref:System.Xaml.XamlXmlReader.Member%2A> , чтобы получить сведения <xref:System.Xaml.XamlMember> о члене. Обратите внимание, что этот член может быть <xref:System.Xaml.XamlDirective>, и поэтому не обязательно является стандартно определяемым членом предыдущего объекта. Например, примененная к объекту директива `x:Name` отображается как член XAML, свойство <xref:System.Xaml.XamlMember.IsDirective%2A> которого имеет значение true, свойство <xref:System.Xaml.XamlMember.Name%2A> этого члена имеет значение `Name`, а другие свойства указывают, что эта директива находится в пространстве имен XAML языка XAML.

  - Для типа <xref:System.Xaml.XamlXmlReader.NodeType%2A> объекта <xref:System.Xaml.XamlNodeType.StartObject> или <xref:System.Xaml.XamlNodeType.EndObject>вызовите <xref:System.Xaml.XamlXmlReader.Type%2A> , чтобы получить сведения <xref:System.Xaml.XamlType> об объекте.

  - Для типа <xref:System.Xaml.XamlXmlReader.NodeType%2A> объекта <xref:System.Xaml.XamlNodeType.Value>вызовите <xref:System.Xaml.XamlXmlReader.Value%2A>. Узел имеет значение только в том случае, если он является простейшим выражением значения для члена или текстом инициализации объекта (однако следует иметь в виду поведение преобразования типов, как описано в следующем разделе этой статьи).

  - Для типа <xref:System.Xaml.XamlXmlReader.NodeType%2A> объекта <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>вызовите <xref:System.Xaml.XamlXmlReader.Namespace%2A> , чтобы получить сведения о пространстве имен для узла пространства имен.

- Вызовите метод <xref:System.Xaml.XamlXmlReader.Read%2A> , чтобы средство чтения XAML перешло к следующему узлу в потоке узлов XAML, и повторите эти действия.

Поток узлов XAML, предоставляемый средствами чтения XAML служб XAML .NET Framework, всегда обеспечивает полный глубокий просмотр всех возможных узлов. Типичные методы управления потоком для цикла узлов XAML включают определение текста в цикле `while (reader.Read())`и переключение на <xref:System.Xaml.XamlXmlReader.NodeType%2A> в каждой точке узла в цикле узлов.

Если поток узлов находится в конце файла, текущий узел имеет значение null.

В следующем примере показан простейший цикл, использующий средства чтения и записи.

```csharp
XamlXmlReader xxr = new XamlXmlReader(new StringReader(xamlStringToLoad));
//where xamlStringToLoad is a string of well formed XAML
XamlObjectWriter xow = new XamlObjectWriter(xxr.SchemaContext);
while (xxr.Read()) {
  xow.WriteNode(xxr);
}
```

Этот простой пример цикла узлов XAML пути загрузки прозрачно связывает средство чтения XAML и средство записи XAML, выполняя то же самое, что выполняется при использовании метода <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>. Но затем эта базовая структура расширяется для применения в сценарии чтения или записи. Далее приведены некоторые возможные сценарии.

- Переключиться в <xref:System.Xaml.XamlXmlReader.NodeType%2A>. Выполнять разные действия в зависимости от того, какой узел читается.

- Не вызывать метод <xref:System.Xaml.XamlWriter.WriteNode%2A> во всех случаях. Вызывать метод <xref:System.Xaml.XamlWriter.WriteNode%2A> только в некоторых случаях <xref:System.Xaml.XamlXmlReader.NodeType%2A> .

- В пределах логики для конкретного типа узла анализировать особенности этого узла и работать с ними. Например, вы можете записать только объекты, которые берутся из определенного пространства имен XAML, а затем удалить или задержать все объекты не из этого пространства имен XAML. Вы также можете удалить или иным образом повторно обработать все директивы XAML, которые не поддерживаются вашей системой XAML, в рамках обработки элементов.

- Определить пользовательский объект <xref:System.Xaml.XamlObjectWriter> , который переопределяет методы `Write*` , возможно, выполняя сопоставление типов, обходящее контекст схемы XAML.

- Создать объект <xref:System.Xaml.XamlXmlReader> для использования контекста схемы XAML не по умолчанию, чтобы настроенные различия в поведении XAML использовались как средством чтения, так и средством записи.

### <a name="accessing-xaml-beyond-the-node-loop-concept"></a>Доступ к XAML за рамками концепции цикла узлов

Помимо цикла узлов XAML существуют и другие способы работы с представлением XAML. Например, может существовать  средство чтения XAML, которое может читать индексированный узел, в частности обращаться к узлам напрямую с помощью директивы `x:Name`, `x:Uid`или используя другие идентификаторы. Службы XAML .NET Framework не обеспечивают полную реализацию, но предоставляют рекомендуемый шаблон с помощью служб и типов поддержки. Дополнительные сведения см. в разделах <xref:System.Xaml.IXamlIndexingReader> и <xref:System.Xaml.XamlNodeList>.

<a name="working_with_the_current_node"></a>

## <a name="working-with-the-current-node"></a>Работа с текущим узлом

В большинстве сценариев, использующих цикл узлов XAML, выполняется не только чтение узлов. В большинстве сценариев обрабатывается текущий узел, а затем каждый узел по одному передается в реализацию <xref:System.Xaml.XamlWriter>.

В типичном сценарии пути загрузки <xref:System.Xaml.XamlXmlReader> создает поток узлов XAML; узлы XAML обрабатываются в соответствии с заданной логикой и контекстом схемы XAML; затем узлы передаются в <xref:System.Xaml.XamlObjectWriter>. Затем вы интегрируете полученный граф объектов в свое приложение или структуру.

В типичном сценарии пути сохранения <xref:System.Xaml.XamlObjectReader> читает граф объектов; отдельные узлы XAML обрабатываются; затем <xref:System.Xaml.XamlXmlWriter> выдает сериализованный результат в виде текстового файла XAML. Главное заключается в том, что оба пути и сценария подразумевают работу только с одним узлом XAML в каждый момент времени, и узлы XAML доступны для стандартной обработки, которая определяется системой типов XAML и API служб XAML .NET Framework.

### <a name="frames-and-scope"></a>Фреймы и область

Цикл узлов XAML проходит по потоку узлов XAML линейным образом. Поток узлов углубляется в объекты, в члены, которые содержат другие объекты, и т. д. Часто бывает удобно отслеживать область в потоке узлов XAML путем реализации концепции фрейма и стека. В частности, это справедливо для случая активной настройки потока узла при нахождении в нем. Поддержка кадра и стека, реализуемая в рамках логики цикла узлов, может учитывать области `StartObject` (или `GetObject`) и `EndObject` по мере углубления в структуру узлов XAML, если рассматривать структуру с точки зрения модели DOM.

<a name="traversing_and_entering_object_nodes"></a>

## <a name="traversing-and-entering-object-nodes"></a>Обход узлов объекта и вход в них

Первым узлом в потоке узлов при его открытии средством чтения XAML является узел начального объекта корневого объекта. По определению этот объект всегда является узлом одного объекта и не имеет одноранговых узлов. В любом реальном примере XAML корневой объект определяется с одним или несколькими свойствами, содержащими дополнительные объекты, и эти свойства имеют узлы-члены. В свою очередь, узлы-члены могут иметь один или несколько узлов-объектов или вместо этого заканчиваться в узле значения. Корневой объект обычно определяет области имен XAML, которые синтаксически назначаются как атрибуты в текстовой разметке XAML, но соответствуют типу узла `Namescope` в представлении потока узлов XAML.

Рассмотрим следующий пример XAML (это произвольный XAML, не реализуемый существующими типами в платформе .NET Framework). Предполагается, что в этой объектной модели `FavorCollection` является `List<T>` объектов `Favor`, `Balloon` и `NoiseMaker` , которые могут быть присвоены `Favor`, свойство `Balloon.Color` поддерживается объектом `Color` аналогично тому, как в WPF цвета задаются при помощи известных названий цветов, а объект `Color` поддерживает преобразователь типов для синтаксиса атрибутов.

|Разметка XAML|Итоговый поток узлов XAML|
|-----------------|--------------------------------|
|`<Party`|`Namespace` для `Party`|
|`xmlns="PartyXamlNamespace">`|`StartObject` для `Party`|
|`<Party.Favors>`|`StartMember` для `Party.Favors`|
||`StartObject` для неявного объекта `FavorCollection`|
||Узел`StartMember` для свойства неявных элементов `FavorCollection` .|
|`<Balloon`|`StartObject` для `Balloon`|
|`Color="Red"`|`StartMember` для `Color`<br /><br /> `Value` для строки значения атрибута `"Red"`<br /><br /> `EndMember` для `Color`|
|`HasHelium="True"`|`StartMember` для `HasHelium`<br /><br /> `Value` для строки значения атрибута `"True"`<br /><br /> `EndMember` для `HasHelium`|
|`>`|`EndObject` для `Balloon`|
|`<NoiseMaker>Loudest</NoiseMaker>`|`StartObject` для `NoiseMaker`<br /><br /> `StartMember` для `_Initialization`<br /><br /> `Value` для строки значения инициализации `"Loudest"`<br /><br /> `EndMember` для `_Initialization`<br /><br /> `EndObject` для `NoiseMaker`|
||Узел`EndMember` для свойства неявных элементов `FavorCollection` .|
||`EndObject` для неявного объекта `FavorCollection`|
|`</Party.Favors>`|`EndMember` для `Favors`|
|`</Party>`|`EndObject` для `Party`|

В потоке узлов XAML можно рассчитывать на следующее поведение.

- Если узел `Namespace` существует, он добавляется в поток непосредственно перед объектом `StartObject` , который объявил пространство имен XAML с помощью `xmlns`. Давайте снова взглянем на предыдущую таблицу с XAML и примером потока узлов. Обратите внимание, как, по всей видимости, будут перемещены узлы `StartObject` и `Namespace` по сравнению с их объявленными позициями в разметке текста. Это типичное представление поведения, в котором узлы пространства имен всегда отображаются перед узлом, к которому они имеют отношение в потоке узлов. Смысл этой конструкции заключается в том, что сведения о пространстве имен, необходимые для средств записи объектов, должны быть известны до того, как средство записи объекта попытается выполнить сопоставление типов или другую обработку объекта. Помещение сведений о пространстве имен XAML перед его областью применения в потоке облегчает обработку потока узлов в представленном порядке.

- По этой причине в большинстве случаев реального использования разметки существует один или несколько узлов `Namespace` , которые читаются первыми при обходе узлов с начала, а не с объекта `StartObject` корня.

- За узлом `StartObject` может следовать `StartMember`, `Value`или непосредственно `EndObject`. За ним никогда не следует сразу же другой `StartObject`.

- За `StartMember` может следовать `StartObject`, `Value`или непосредственно `EndMember`. За ним может следовать `GetObject`, для членов, в которых значение должно быть получено из существующего значения родительского объекта, а не из `StartObject` , который может создавать экземпляр нового значения. За ним также может следовать узел `Namespace` , который относится к следующему `StartObject`. За ним никогда не следует сразу же другой `StartMember`.

- Узел `Value` представляет само значение; это не EndValue. За ним может следовать только `EndMember`.

  - Текст инициализации XAML объекта, который может использоваться конструкцией, не приводит к структуре «Объект-значение». Вместо этого создается выделенный узел для члена с именем `_Initialization` , и этот узел члена содержит строку значения инициализации. Если он существует, то `_Initialization` всегда является первым `StartMember`. Член`_Initialization` может быть определен в некоторых представлениях служб XAML при помощи области имен XAML языка XAML, чтобы уточнить, что `_Initialization` не является заданным свойством в резервных типах.

  - Комбинация «Член-значение» представляет настройку атрибута значения. В конечном итоге возможно включение преобразователя значений в обработку этого значения, и значение представляет собой простую строку. Однако это не вычисляется до тех пор, пока средство записи объектов XAML не обработает этот поток узлов. Средство записи объектов XAML обрабатывает необходимый контекст схемы XAML, сопоставление системы типов и другую поддержку, необходимую для преобразований значений.

- За узлом `EndMember` может следовать узел `StartMember` для последующего члена или узел `EndObject` для владельца этого члена.

- За узлом `EndObject` может следовать узел `EndMember` . За ним может также следовать узел `StartObject` для случаев, когда эти объекты являются одноранговыми узлами в элементах коллекции. Кроме того, за ним может следовать узел `Namespace` , который относится к следующему `StartObject`.

  - В исключительном случае закрытия всего потока узлов за объектом `EndObject` корня не следует ничего; средство чтения достигает конца файла, и метод <xref:System.Xaml.XamlReader.Read%2A> возвращает значение `false`.

<a name="value_converters_and_the_xaml_node_stream"></a>

## <a name="value-converters-and-the-xaml-node-stream"></a>Преобразователи значений и поток узлов XAML

Преобразователь значений — это общий термин для расширения разметки, преобразователя типов (включая сериализаторы значений) или другого выделенного класса, указанного как преобразователь значений в системе типов XAML. В потоке узлов XAML использование преобразователя типов и использование расширения разметки имеют совершенно разные представления.

### <a name="type-converters-in-the-xaml-node-stream"></a>Преобразователи значений в потоке узлов XAML

Набор атрибутов, который в конечном итоге приводит к использованию преобразователя типов, сообщается в поток узлов XAML как значение члена. Поток узлов XAML не пытается создать экземпляр объекта преобразователя типов и передать ему значение. Использование реализации преобразования преобразователя типов требует вызова контекста схемы XAML и использования его для сопоставления типов. Даже для определения того, какой класс преобразователя типов следует использовать для обработки значения, косвенно требуется контекст схемы языка XAML. При использовании контекста схемы XAML по умолчанию эти сведения можно получить из системы типов XAML. Если сведения класса преобразователя типов на уровне потока узлов XAML требуются до подключения к средству записи XAML, их можно получить из сведений <xref:System.Xaml.XamlMember> устанавливаемого члена. Однако в противном случае входные данные преобразователя типов должны быть сохранены в потоке узлов XAML в виде простого значения до того, как будет выполняться оставшаяся часть операций, которым требуется система сопоставления типов и контекст схемы XAML, например создание объекта средством записи объекта XAML.

Например, рассмотрим следующую структуру определения класса и использования для него XAML.

```csharp
public class BoardSizeConverter : TypeConverter {
  //converts from string to an int[2] by splitting on an "x" char
}
public class GameBoard {
  [TypeConverter(typeof(BoardSizeConverter))]
  public int[] BoardSize; //2x2 array, initialization not shown
}
```

```xaml
<GameBoard BoardSize="8x8"/>
```

Текстовое представление потока узлов XAML для данного использования можно выразить следующим образом:

`StartObject` с <xref:System.Xaml.XamlType> , представляющий `GameBoard`

`StartMember` с <xref:System.Xaml.XamlMember> , представляющий `BoardSize`

Узел`Value` с текстовой строкой "`8x8`"

`EndMember` , соответствующий `BoardSize`

`EndObject` , соответствующий `GameBoard`

Обратите внимание, что в этом потоке узлов отсутствует экземпляр преобразователя типов. Однако вы можете получить сведения о преобразователе типов, вызвав <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> в <xref:System.Xaml.XamlMember> для `BoardSize`. При наличии допустимого контекста схемы XAML можно также вызвать методы преобразователя, получив экземпляр из <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>.

### <a name="markup-extensions-in-the-xaml-node-stream"></a>Расширения разметки в потоке узлов XAML

Об использовании расширения разметки сообщается в поток узлов XAML как об узле объекта в члене, где объект представляет экземпляр расширения разметки. Таким образом, использование расширения разметки более явно представлено в представлении потока узлов, чем использование преобразователя типов, и содержит больше сведений. Сведения<xref:System.Xaml.XamlMember> могут ничего не сообщать о расширении разметки, поскольку его использование зависит от ситуации и меняется в каждом возможном случае разметки; оно не является выделенным и неявным согласно типу или члену, как в случае с преобразователями типов.

Представление потока узлов расширений разметки как узлов объектов происходит даже в случае, когда использование расширения разметки было сделано в форме атрибута в текстовой разметке XAML (что происходит часто). Использование расширения разметки с применением явных форм элементов объектов интерпретируется таким же образом.

Внутри узла объекта расширения разметки могут находиться члены этого расширения разметки. Представление потока узлов XAML сохраняет использование этого расширения разметки, будь это использование позиционного параметра или использование с помощью явно указанных параметров.

При использовании позиционного параметра поток узлов XAML содержит заданное на уровне языка XAML свойство `_PositionalParameters` , регистрирующее это использование. Это свойство является универсальным <xref:System.Collections.Generic.List%601> с ограничением <xref:System.Object> . Это ограничение является объектом, а не строкой, поскольку предположительно использование позиционного параметра может содержать в себе вложенные использования расширения разметки. Для доступа к позиционным параметрам из использования можно выполнить итерацию по списку и применять индексаторы для отдельных значений списка.

При использовании именованных параметров каждый именованный параметр представляется как узел члена с этим именем в потоке узлов. Значения членов не обязательно являются строками, поскольку может использоваться вложенное расширение разметки.

`ProvideValue` из расширения разметки еще не вызывался. Однако он вызывается при подключении средства чтения XAML и средства записи XAML, чтобы вызывался `WriteEndObject` в узле расширения разметки при его исследовании в потоке узлов. По этой причине обычно требуется доступ к тому же контексту схемы XAML, который использовался бы для формирования графа объектов в пути загрузки. В противном случае `ProvideValue` из любого расширения разметки может вызывать здесь исключения, поскольку не имеет доступа к ожидаемым службам.

<a name="xaml_and_xml_languagedefined_members_in_the_xaml_node_stream"></a>

## <a name="xaml-and-xml-language-defined-members-in-the-xaml-node-stream"></a>Члены, заданные на уровне XAML и XML, в потоке узлов XAML

Определенные члены введены в поток узлов XAML из-за определений и соглашений средства чтения XAML, вместо того чтобы использовать явный поиск или построение <xref:System.Xaml.XamlMember> . Часто эти члены являются директивами XAML. В некоторых случаях это действие чтения XAML, вводящее директиву в поток узлов XAML. Иными словами, в исходном тексте входного кода XAML не было явно указано директива Member, но средство чтения XAML вставляет директиву для удовлетворения структурного соглашения XAML и сообщает сведения в потоке узлов XAML, прежде чем эта информация будет потеряна.

В следующем списке отмечены все случаи, в которых средство чтения XAML, как ожидается, вводит узел члена директивы XAML, и как этот узел члена идентифицируется в реализациях служб XAML .NET Framework.

- **Текст инициализации для узла объекта.** Имя этого узла члена — `_Initialization`, он представляет собой директиву XAML и определен в пространстве имен XAML языка XAML. Вы можете получить для него статическую сущность из <xref:System.Xaml.XamlLanguage.Initialization%2A>.

- **Позиционные параметры для расширения разметки.** Имя этого узла члена — `_PositionalParameters`, и он определен в пространстве имен XAML языка XAML. Он всегда содержит универсальный список объектов, каждый из которых является позиционным параметром, предварительно отделенным по символу-разделителю `,` , как представлено во входных данных XAML. Вы можете получить статическую сущность для директивы позиционных параметров из <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>.

- **Неизвестное содержимое.** Имя этого узла члена — `_UnknownContent`. Строго говоря, это директива <xref:System.Xaml.XamlDirective>, которая определяется в пространстве имен XAML языка XAML. Эта директива используется как сигнальная метка в случаях, когда в элементе объекта XAML имеется содержимое в исходном XAML, но никакое свойство содержимого невозможно определить в рамках текущего доступного контекста схемы XAML. Такой случай можно обнаружить в потоке узлов XAML, проверив члены с именем `_UnknownContent`. Если в потоке узлов XAML пути загрузки никакие другие действия не выполняются, вызывается <xref:System.Xaml.XamlObjectWriter> по умолчанию при попытке `WriteEndObject` , когда в каком-либо объекте обнаруживается член `_UnknownContent` . Объект <xref:System.Xaml.XamlXmlWriter> по умолчанию не вызывается и рассматривает этот член как неявный. Вы можете получить статическую сущность для `_UnknownContent` из <xref:System.Xaml.XamlLanguage.UnknownContent%2A>.

- **Свойство коллекции коллекции:** Несмотря на то что резервный тип CLR класса коллекции, используемого для XAML, обычно имеет выделенное именованное свойство, содержащее элементы коллекции, это свойство неизвестно системе типов XAML до резервного разрешения типов. Вместо этого поток узлов XAML вводит заполнитель `Items` в качестве члена типа коллекции XAML. В реализации служб XAML .NET Framework имя этой директивы/члена в потоке узлов — `_Items`. Константу для этой директивы можно получить из <xref:System.Xaml.XamlLanguage.Items%2A>.

    Обратите внимание, что поток узлов XAML может содержать свойство Items с элементами, которые не могут быть проанализированы на основе разрешения резервных типов и контекста схемы XAML. Например, примененная к объекту директива

- **Члены, определенные в XML.** Определенные в XML члены `xml:base`, `xml:lang` и `xml:space` сообщаются как директивы XAML с именами `base`, `lang`и `space` в реализациях служб XAML .NET Framework. Их пространство имен — это пространство имен XML `http://www.w3.org/XML/1998/namespace`. Константы для каждого из них можно получить из <xref:System.Xaml.XamlLanguage>.

## <a name="node-order"></a>Порядок узлов

В некоторых случаях <xref:System.Xaml.XamlXmlReader> изменяет порядок узлов XAML в потоке узлов XAML по сравнению с порядком, в котором эти узлы отображаются при просмотре в разметке или при обработке в виде XML. Это делается для упорядочения узлов таким образом, чтобы средство записи <xref:System.Xaml.XamlObjectWriter> могло обрабатывать этот поток узлов в режиме только вперед.  В службах XAML .NET Framework средство чтения XAML изменяет порядок узлов, не оставляя эту задачу средству записи XAML, в целях оптимизации производительности для потребителей средства записи объектов XAML в потоке узлов.

Некоторые директивы предназначены специально в целях предоставления дополнительных сведений для создания объекта из элемента объекта. Это директивы `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`. Средства чтения  XAML служб XAML .NET Framework пытаются разместить эти директивы в качестве первых членов в потоке узлов, следующем за `StartObject`объекта, по причинам, которые разъясняются в следующем разделе.

### <a name="xamlobjectwriter-behavior-and-node-order"></a>Поведение XamlObjectWriter и порядок узлов

`StartObject` в <xref:System.Xaml.XamlObjectWriter> не обязательно сигнализирует средству записи объектов XAML немедленно создать экземпляр объекта. XAML включает несколько функций языка, позволяющих инициализировать объект с дополнительными входными данными, а также не полагаться полностью на вызов конструктора без параметров для создания начального объекта и только после этого установки свойств. Эти возможности включают <xref:System.Windows.Markup.XamlDeferLoadAttribute>; текст инициализации; [x: TypeArguments](x-typearguments-directive.md); позиционные параметры расширения разметки; фабричные методы и связанные узлы [x: Arguments](x-arguments-directive.md) (XAML 2009 г.). В каждом из этих случаев фактическое создание объекта задерживается, а поскольку поток узлов переупорядочивается, средство записи объектов XAML может рассчитывать на поведение фактического создания экземпляра при обнаружении начального члена, не представляющего собой директиву построения для данного типа объекта.

### <a name="getobject"></a>GetObject

`GetObject` представляет узел XAML, где вместо создания нового объекта средство записи объектов XAML должно получать значение содержащегося свойства объекта. Типичный случай, где узел `GetObject` обнаруживается в потоке узлов XAML для объекта коллекции или объекта словаря, когда содержащее свойство умышленно предназначено только для чтения в объектной модели резервного типа. В этом сценарии коллекция или словарь часто создаются и инициализируются (обычно пустыми) логикой инициализации типа-владельца.

## <a name="see-also"></a>См. также

- <xref:System.Xaml.XamlObjectReader>
- [Службы XAML](index.md)
- [Пространства имен языка XAML](xaml-namespaces-for-net-framework-xaml-services.md)
