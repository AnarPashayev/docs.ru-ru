---
title: Домены приложений
description: Сведения о доменах приложений, которые образуют границу изоляции между приложениями для обеспечения безопасности, надежности, управления версиями и выгрузки сборок в .NET.
ms.date: 03/30/2017
helpviewer_keywords:
- process boundaries for isolation
- application isolation
- application domains, about
- common language runtime, application domains
- application domains
- runtime, application domains
- isolation between applications
- code, verification process
- verification testing code
ms.assetid: 113a8bbf-6875-4a72-a49d-ca2d92e19cc8
ms.openlocfilehash: 246566265d55a3289ef37a2987ed9c40f051e3c8
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/15/2020
ms.locfileid: "90553373"
---
# <a name="application-domains"></a><span data-ttu-id="a552f-103">Домены приложений</span><span class="sxs-lookup"><span data-stu-id="a552f-103">Application domains</span></span>

<span data-ttu-id="a552f-104">Операционные системы и среды выполнения обычно содержат определенные средства изоляции приложений друг от друга.</span><span class="sxs-lookup"><span data-stu-id="a552f-104">Operating systems and runtime environments typically provide some form of isolation between applications.</span></span> <span data-ttu-id="a552f-105">Например, в ОС Windows для изоляции приложений используются процессы.</span><span class="sxs-lookup"><span data-stu-id="a552f-105">For example, Windows uses processes to isolate applications.</span></span> <span data-ttu-id="a552f-106">Эта изоляция необходима, чтобы гарантировать, что код, выполняемый одним приложением, не сможет нарушить работу других, не связанных с ним приложений.</span><span class="sxs-lookup"><span data-stu-id="a552f-106">This isolation is necessary to ensure that code running in one application cannot adversely affect other, unrelated applications.</span></span>  
  
 <span data-ttu-id="a552f-107">Домены приложений образуют изолированную область для безопасности, надежности, управления версиями и выгрузки сборок.</span><span class="sxs-lookup"><span data-stu-id="a552f-107">Application domains provide an isolation boundary for security, reliability, and versioning, and for unloading assemblies.</span></span> <span data-ttu-id="a552f-108">Домены приложений обычно создаются базовыми средами выполнения, которые отвечают за начальную загрузку среды CLR перед запуском приложения.</span><span class="sxs-lookup"><span data-stu-id="a552f-108">Application domains are typically created by runtime hosts, which are responsible for bootstrapping the common language runtime before an application is run.</span></span>  
  
## <a name="the-benefits-of-isolating-applications"></a><span data-ttu-id="a552f-109">Преимущества изоляции приложений</span><span class="sxs-lookup"><span data-stu-id="a552f-109">The benefits of isolating applications</span></span>

 <span data-ttu-id="a552f-110">Исторически сложилось так, что для разделения приложений, выполняющихся на одном компьютере, используются границы процессов.</span><span class="sxs-lookup"><span data-stu-id="a552f-110">Historically, process boundaries have been used to isolate applications running on the same computer.</span></span> <span data-ttu-id="a552f-111">Каждое приложение загружается в отдельный процесс, который отделяет его от других приложений, выполняющихся на том же компьютере.</span><span class="sxs-lookup"><span data-stu-id="a552f-111">Each application is loaded into a separate process, which isolates the application from other applications running on the same computer.</span></span>  
  
 <span data-ttu-id="a552f-112">Приложения оказываются изолированными друг от друга, поскольку адреса в памяти привязаны к процессам; бессмысленно использовать в процессе указатель, передаваемый ему из другого процесса.</span><span class="sxs-lookup"><span data-stu-id="a552f-112">The applications are isolated because memory addresses are process-relative; a memory pointer passed from one process to another cannot be used in any meaningful way in the target process.</span></span> <span data-ttu-id="a552f-113">Кроме того, прямые вызовы между процессами невозможны.</span><span class="sxs-lookup"><span data-stu-id="a552f-113">In addition, you cannot make direct calls between two processes.</span></span> <span data-ttu-id="a552f-114">Вместо этого необходимо использовать прокси, которые обеспечивают уровень косвенности.</span><span class="sxs-lookup"><span data-stu-id="a552f-114">Instead, you must use proxies, which provide a level of indirection.</span></span>  
  
 <span data-ttu-id="a552f-115">Перед запуском управляемый код должен пройти процесс проверки (если администратор не даст разрешение пропустить проверку).</span><span class="sxs-lookup"><span data-stu-id="a552f-115">Managed code must be passed through a verification process before it can be run (unless the administrator has granted permission to skip the verification).</span></span> <span data-ttu-id="a552f-116">В процессе проверки определяется, может ли код предпринимать попытки обращения к неверным адресам памяти или осуществлять другие действия, способные привести к нарушению правильной работы процесса, в котором выполняется этот код.</span><span class="sxs-lookup"><span data-stu-id="a552f-116">The verification process determines whether the code can attempt to access invalid memory addresses or perform some other action that could cause the process in which it is running to fail to operate properly.</span></span> <span data-ttu-id="a552f-117">Код, прошедший проверку, называется типобезопасным.</span><span class="sxs-lookup"><span data-stu-id="a552f-117">Code that passes the verification test is said to be type-safe.</span></span> <span data-ttu-id="a552f-118">Возможность проверки кода на безопасность типа позволяет среде CLR обеспечивать такой же высокий уровень изоляции процессов друг от друга, как и при использовании границ процессов, но со значительно более низкими затратами по производительности.</span><span class="sxs-lookup"><span data-stu-id="a552f-118">The ability to verify code as type-safe enables the common language runtime to provide as great a level of isolation as the process boundary, at a much lower performance cost.</span></span>  
  
 <span data-ttu-id="a552f-119">Домены приложений предоставляют среде CLR более безопасные и гибкие блоки, которые могут использоваться для разделения отдельных приложений.</span><span class="sxs-lookup"><span data-stu-id="a552f-119">Application domains provide a more secure and versatile unit of processing that the common language runtime can use to provide isolation between applications.</span></span> <span data-ttu-id="a552f-120">В одном процессе можно запустить несколько доменов приложений с таким же уровнем изоляции, какой обеспечивают отдельные процессы, но без дополнительных издержек на межпроцессные вызовы или переключение между процессами.</span><span class="sxs-lookup"><span data-stu-id="a552f-120">You can run several application domains in a single process with the same level of isolation that would exist in separate processes, but without incurring the additional overhead of making cross-process calls or switching between processes.</span></span> <span data-ttu-id="a552f-121">Возможность выполнения нескольких приложений в одном процессе значительно повышает масштабируемость серверов.</span><span class="sxs-lookup"><span data-stu-id="a552f-121">The ability to run multiple applications within a single process dramatically increases server scalability.</span></span>  
  
 <span data-ttu-id="a552f-122">Изоляция приложений также играет важную роль в обеспечении безопасности.</span><span class="sxs-lookup"><span data-stu-id="a552f-122">Isolating applications is also important for application security.</span></span> <span data-ttu-id="a552f-123">Так, например, можно запустить элементы управления нескольких веб-приложений в одном процессе браузера так, что эти элементы управления не смогут получить доступ к данным и ресурсам друг друга.</span><span class="sxs-lookup"><span data-stu-id="a552f-123">For example, you can run controls from several Web applications in a single browser process in such a way that the controls cannot access each other's data and resources.</span></span>  
  
 <span data-ttu-id="a552f-124">Изоляция приложений при помощи доменов приложений имеет следующие преимущества.</span><span class="sxs-lookup"><span data-stu-id="a552f-124">The isolation provided by application domains has the following benefits:</span></span>  
  
- <span data-ttu-id="a552f-125">Сбои в одном из приложений не затронут прочие приложения.</span><span class="sxs-lookup"><span data-stu-id="a552f-125">Faults in one application cannot affect other applications.</span></span> <span data-ttu-id="a552f-126">Поскольку типобезопасный код не может вызывать сбои в памяти, использование доменов приложений гарантирует, что код, выполняющийся в одном домене, не окажет воздействия на другие приложения процесса.</span><span class="sxs-lookup"><span data-stu-id="a552f-126">Because type-safe code cannot cause memory faults, using application domains ensures that code running in one domain cannot affect other applications in the process.</span></span>  
  
- <span data-ttu-id="a552f-127">Можно прекратить выполнение отдельных приложений, не останавливая процесс целиком.</span><span class="sxs-lookup"><span data-stu-id="a552f-127">Individual applications can be stopped without stopping the entire process.</span></span> <span data-ttu-id="a552f-128">Использование доменов приложений позволяет выгружать код, используемый отдельным приложением.</span><span class="sxs-lookup"><span data-stu-id="a552f-128">Using application domains enables you to unload the code running in a single application.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="a552f-129">Невозможно выгружать отдельные сборки или типы.</span><span class="sxs-lookup"><span data-stu-id="a552f-129">You cannot unload individual assemblies or types.</span></span> <span data-ttu-id="a552f-130">Выгрузить можно только домен целиком.</span><span class="sxs-lookup"><span data-stu-id="a552f-130">Only a complete domain can be unloaded.</span></span>  
  
- <span data-ttu-id="a552f-131">Код, используемый одним приложением, не может иметь непосредственного доступа к коду или ресурсам другого приложения.</span><span class="sxs-lookup"><span data-stu-id="a552f-131">Code running in one application cannot directly access code or resources from another application.</span></span> <span data-ttu-id="a552f-132">В среде CLR эта изоляция реализована за счет запрета прямых вызовов между объектами в различных доменах приложений.</span><span class="sxs-lookup"><span data-stu-id="a552f-132">The common language runtime enforces this isolation by preventing direct calls between objects in different application domains.</span></span> <span data-ttu-id="a552f-133">Объекты, передаваемые от домена к домену, копируются или взаимодействуют через прокси.</span><span class="sxs-lookup"><span data-stu-id="a552f-133">Objects that pass between domains are either copied or accessed by proxy.</span></span> <span data-ttu-id="a552f-134">Если объект копируется, вызов этого объекта является локальным.</span><span class="sxs-lookup"><span data-stu-id="a552f-134">If the object is copied, the call to the object is local.</span></span> <span data-ttu-id="a552f-135">То есть вызывающий и вызываемый объекты находятся в одном домене приложения.</span><span class="sxs-lookup"><span data-stu-id="a552f-135">That is, both the caller and the object being referenced are in the same application domain.</span></span> <span data-ttu-id="a552f-136">Если доступ к объекту осуществляется через прокси, осуществляется удаленный вызов объекта.</span><span class="sxs-lookup"><span data-stu-id="a552f-136">If the object is accessed through a proxy, the call to the object is remote.</span></span> <span data-ttu-id="a552f-137">В этом случае вызывающий и вызываемый объекты находятся в разных доменах приложений.</span><span class="sxs-lookup"><span data-stu-id="a552f-137">In this case, the caller and the object being referenced are in different application domains.</span></span> <span data-ttu-id="a552f-138">При междоменных вызовах используется та же инфраструктура удаленных вызовов, что и при вызовах между двумя разными процессами или двумя разными компьютерами.</span><span class="sxs-lookup"><span data-stu-id="a552f-138">Cross-domain calls use the same remote call infrastructure as calls between two processes or between two machines.</span></span> <span data-ttu-id="a552f-139">Для правильной JIT-компиляции вызова метода метаданные используемого объекта должны быть доступны для обоих доменов приложений.</span><span class="sxs-lookup"><span data-stu-id="a552f-139">As such, the metadata for the object being referenced must be available to both application domains to allow the method call to be JIT-compiled properly.</span></span> <span data-ttu-id="a552f-140">Если вызывающий домен не имеет доступа к метаданным для вызванного объекта, компиляция может завершиться ошибкой с исключением типа <xref:System.IO.FileNotFoundException>.</span><span class="sxs-lookup"><span data-stu-id="a552f-140">If the calling domain does not have access to the metadata for the object being called, the compilation might fail with an exception of type <xref:System.IO.FileNotFoundException>.</span></span> <span data-ttu-id="a552f-141">Для получения дополнительной информации см. [Remote Objects](/previous-versions/dotnet/netframework-4.0/72x4h507(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="a552f-141">For more information, see [Remote Objects](/previous-versions/dotnet/netframework-4.0/72x4h507(v=vs.100)).</span></span> <span data-ttu-id="a552f-142">Механизм определения способов междоменного доступа для объекта зависит от объекта.</span><span class="sxs-lookup"><span data-stu-id="a552f-142">The mechanism for determining how objects can be accessed across domains is determined by the object.</span></span> <span data-ttu-id="a552f-143">Для получения дополнительной информации см. <xref:System.MarshalByRefObject?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a552f-143">For more information, see <xref:System.MarshalByRefObject?displayProperty=nameWithType>.</span></span>  
  
- <span data-ttu-id="a552f-144">Поведение кода определяется границами приложения, в котором он выполняется.</span><span class="sxs-lookup"><span data-stu-id="a552f-144">The behavior of code is scoped by the application in which it runs.</span></span> <span data-ttu-id="a552f-145">Другими словами, домен приложения предоставляет параметры конфигурации, такие как политики управления версиями приложения, местоположение удаленных сборок, к которым выполняется обращение, и сведения о том, где следует искать локальные сборки, загруженные в домен.</span><span class="sxs-lookup"><span data-stu-id="a552f-145">In other words, the application domain provides configuration settings such as application version policies, the location of any remote assemblies it accesses, and information about where to locate assemblies that are loaded into the domain.</span></span>  
  
- <span data-ttu-id="a552f-146">Разрешения, предоставленные коду, могут управляться доменом приложения, в котором выполняется этот код.</span><span class="sxs-lookup"><span data-stu-id="a552f-146">Permissions granted to code can be controlled by the application domain in which the code is running.</span></span>  
  
## <a name="application-domains-and-assemblies"></a><span data-ttu-id="a552f-147">Домены приложений и сборки</span><span class="sxs-lookup"><span data-stu-id="a552f-147">Application domains and assemblies</span></span>

 <span data-ttu-id="a552f-148">В этом разделе описывается связью между доменами приложений и сборками.</span><span class="sxs-lookup"><span data-stu-id="a552f-148">This section describes the relationship between application domains and assemblies.</span></span> <span data-ttu-id="a552f-149">Чтобы выполнить код сборки, ее необходимо загрузить в домен приложения.</span><span class="sxs-lookup"><span data-stu-id="a552f-149">You must load an assembly into an application domain before you can execute the code it contains.</span></span> <span data-ttu-id="a552f-150">Как правило, для запуска приложения в домен приложения необходимо загрузить несколько сборок.</span><span class="sxs-lookup"><span data-stu-id="a552f-150">Running a typical application causes several assemblies to be loaded into an application domain.</span></span>  
  
 <span data-ttu-id="a552f-151">Способ загрузки определяет, можно ли использовать JIT-скомпилированный код сборки в нескольких доменах приложений в процессе и можно ли выгружать сборку из процесса.</span><span class="sxs-lookup"><span data-stu-id="a552f-151">The way an assembly is loaded determines whether its just-in-time (JIT) compiled code can be shared by multiple application domains in the process, and whether the assembly can be unloaded from the process.</span></span>  
  
- <span data-ttu-id="a552f-152">Если сборка загружается как нейтральная к домену, то все домены приложений с одним набором разрешений безопасности могут совместно использовать JIT-скомпилированный код, что снижает требуемый для приложения объем памяти.</span><span class="sxs-lookup"><span data-stu-id="a552f-152">If an assembly is loaded domain-neutral, all application domains that share the same security grant set can share the same JIT-compiled code, which reduces the memory required by the application.</span></span> <span data-ttu-id="a552f-153">Однако сборку нельзя выгружать из процесса.</span><span class="sxs-lookup"><span data-stu-id="a552f-153">However, the assembly can never be unloaded from the process.</span></span>  
  
- <span data-ttu-id="a552f-154">Если сборка не загружается как нейтральная к домену, она должна быть JIT-скомпилирована в каждом домене приложения, в который она загружается.</span><span class="sxs-lookup"><span data-stu-id="a552f-154">If an assembly is not loaded domain-neutral, it must be JIT-compiled in every application domain in which it is loaded.</span></span> <span data-ttu-id="a552f-155">Однако сборку можно выгрузить из процесса, выгрузив все домены приложений, в которые она загружается.</span><span class="sxs-lookup"><span data-stu-id="a552f-155">However, the assembly can be unloaded from the process by unloading all the application domains in which it is loaded.</span></span>  
  
 <span data-ttu-id="a552f-156">Следует ли загружать сборки как нейтральные к домену, определяется в хост-приложении среды выполнения при загрузке среды выполнения в процесс.</span><span class="sxs-lookup"><span data-stu-id="a552f-156">The runtime host determines whether to load assemblies as domain-neutral when it loads the runtime into a process.</span></span> <span data-ttu-id="a552f-157">Для управляемых приложений примените атрибут <xref:System.LoaderOptimizationAttribute> к методу точки входа процесса и укажите значение из связанного перечисления <xref:System.LoaderOptimization>.</span><span class="sxs-lookup"><span data-stu-id="a552f-157">For managed applications, apply the <xref:System.LoaderOptimizationAttribute> attribute to the entry-point method for the process, and specify a value from the associated <xref:System.LoaderOptimization> enumeration.</span></span> <span data-ttu-id="a552f-158">Для неуправляемых приложений, в которых размещается среда CLR, при вызове функции [CorBindToRuntimeEx](../unmanaged-api/hosting/corbindtoruntimeex-function.md) задайте соответствующий флаг.</span><span class="sxs-lookup"><span data-stu-id="a552f-158">For unmanaged applications that host the common language runtime, specify the appropriate flag when you call the [CorBindToRuntimeEx Function](../unmanaged-api/hosting/corbindtoruntimeex-function.md) method.</span></span>  
  
 <span data-ttu-id="a552f-159">Существует три варианта загрузки нейтральных к домену сборок.</span><span class="sxs-lookup"><span data-stu-id="a552f-159">There are three options for loading domain-neutral assemblies:</span></span>  
  
- <span data-ttu-id="a552f-160"><xref:System.LoaderOptimization.SingleDomain?displayProperty=nameWithType> не загружает сборки как нейтральные к домену, за исключением Mscorlib, которая всегда загружается как нейтральная к домену.</span><span class="sxs-lookup"><span data-stu-id="a552f-160"><xref:System.LoaderOptimization.SingleDomain?displayProperty=nameWithType> loads no assemblies as domain-neutral, except Mscorlib, which is always loaded domain-neutral.</span></span> <span data-ttu-id="a552f-161">Этот вариант называется однодоменным, поскольку обычно он используется, когда в хост-приложении запускается только одно приложение в процессе.</span><span class="sxs-lookup"><span data-stu-id="a552f-161">This setting is called single domain because it is commonly used when the host is running only a single application in the process.</span></span>

- <span data-ttu-id="a552f-162"><xref:System.LoaderOptimization.MultiDomain?displayProperty=nameWithType> загружает все сборки как нейтральные к домену.</span><span class="sxs-lookup"><span data-stu-id="a552f-162"><xref:System.LoaderOptimization.MultiDomain?displayProperty=nameWithType> loads all assemblies as domain-neutral.</span></span> <span data-ttu-id="a552f-163">Этот вариант используется при наличии нескольких доменов приложений, в каждом из которых выполняется одинаковый код.</span><span class="sxs-lookup"><span data-stu-id="a552f-163">Use this setting when there are multiple application domains in the process, all of which run the same code.</span></span>

- <span data-ttu-id="a552f-164"><xref:System.LoaderOptimization.MultiDomainHost?displayProperty=nameWithType> загружает сборки со строгими именами как нейтральные к домену, если они и все их зависимости установлены в глобальном кэше сборок.</span><span class="sxs-lookup"><span data-stu-id="a552f-164"><xref:System.LoaderOptimization.MultiDomainHost?displayProperty=nameWithType> loads strong-named assemblies as domain-neutral, if they and all their dependencies have been installed in the global assembly cache.</span></span> <span data-ttu-id="a552f-165">Другие сборки загружаются и JIT-компилируются отдельно для каждого домена приложения, в котором они загружаются, поэтому могут выгружаться из процесса.</span><span class="sxs-lookup"><span data-stu-id="a552f-165">Other assemblies are loaded and JIT-compiled separately for each application domain in which they are loaded, and thus can be unloaded from the process.</span></span> <span data-ttu-id="a552f-166">Этот вариант используется при работе нескольких приложений в одном процессе или при наличии набора сборок, которые являются общими для нескольких доменов приложений, и сборок, которые должны выгружаться из процесса.</span><span class="sxs-lookup"><span data-stu-id="a552f-166">Use this setting when running more than one application in the same process, or if you have a mixture of assemblies that are shared by many application domains and assemblies that need to be unloaded from the process.</span></span>
  
 <span data-ttu-id="a552f-167">JIT-скомпилированный код нельзя сделать общим для сборок, загруженных в контекст загрузки с помощью метода <xref:System.Reflection.Assembly.LoadFrom%2A> класса <xref:System.Reflection.Assembly> или загруженных из образов с помощью перегрузок метода <xref:System.Reflection.Assembly.Load%2A>, задающего байтовые массивы.</span><span class="sxs-lookup"><span data-stu-id="a552f-167">JIT-compiled code cannot be shared for assemblies loaded into the load-from context, using the <xref:System.Reflection.Assembly.LoadFrom%2A> method of the <xref:System.Reflection.Assembly> class, or loaded from images using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify byte arrays.</span></span>  
  
 <span data-ttu-id="a552f-168">Сборки, которые были скомпилированы в машинный код с помощью [Ngen.exe (средства для создания машинных образов)](../tools/ngen-exe-native-image-generator.md), могут совместно использоваться доменами приложений, если они загружены как нейтральные к домену при первой загрузке в процесс.</span><span class="sxs-lookup"><span data-stu-id="a552f-168">Assemblies that have been compiled to native code by using the [Ngen.exe (Native Image Generator)](../tools/ngen-exe-native-image-generator.md) can be shared between application domains, if they are loaded domain-neutral the first time they are loaded into a process.</span></span>  
  
 <span data-ttu-id="a552f-169">JIT-скомпилированный код для сборки, содержащей точку входа приложения, может быть общим, только если все его зависимости могут использоваться совместно.</span><span class="sxs-lookup"><span data-stu-id="a552f-169">JIT-compiled code for the assembly that contains the application entry point is shared only if all its dependencies can be shared.</span></span>  
  
 <span data-ttu-id="a552f-170">Сборка, нейтральная к домену, может JIT-компилироваться более одного раза.</span><span class="sxs-lookup"><span data-stu-id="a552f-170">A domain-neutral assembly can be JIT-compiled more than once.</span></span> <span data-ttu-id="a552f-171">Например, когда наборы разрешений безопасности двух доменов приложений отличаются, они не могут совместно использовать один и тот же JIT-скомпилированный код.</span><span class="sxs-lookup"><span data-stu-id="a552f-171">For example, when the security grant sets of two application domains are different, they cannot share the same JIT-compiled code.</span></span> <span data-ttu-id="a552f-172">Однако каждая копия JIT-скомпилированной сборки может использоваться совместно с другими доменами приложений, имеющими такой же набор разрешений.</span><span class="sxs-lookup"><span data-stu-id="a552f-172">However, each copy of the JIT-compiled assembly can be shared with other application domains that have the same grant set.</span></span>  
  
 <span data-ttu-id="a552f-173">При принятии решения о том, следует ли загружать сборки как нейтральные, осуществляется компромисс между сокращением расхода памяти и производительностью.</span><span class="sxs-lookup"><span data-stu-id="a552f-173">When you decide whether to load assemblies as domain-neutral, you must make a tradeoff between reducing memory use and other performance factors.</span></span>  
  
- <span data-ttu-id="a552f-174">Доступ к статическим данным и методам для нейтральных к домену сборок осуществляется медленнее из-за необходимости изоляции сборок.</span><span class="sxs-lookup"><span data-stu-id="a552f-174">Access to static data and methods is slower for domain-neutral assemblies because of the need to isolate assemblies.</span></span> <span data-ttu-id="a552f-175">Каждый домен приложения, обращающийся к сборке, должен обладать собственной копией статических данных, чтобы избежать ссылок на объекты в статических полях, пересекающих границы домена.</span><span class="sxs-lookup"><span data-stu-id="a552f-175">Each application domain that accesses the assembly must have a separate copy of the static data, to prevent references to objects in static fields from crossing domain boundaries.</span></span> <span data-ttu-id="a552f-176">В результате среда выполнения содержит дополнительные правила для перенаправления вызывающего объекта к соответствующей копии статических данных или метода.</span><span class="sxs-lookup"><span data-stu-id="a552f-176">As a result, the runtime contains additional logic to direct a caller to the appropriate copy of the static data or method.</span></span> <span data-ttu-id="a552f-177">Эти дополнительные правила замедляют вызов.</span><span class="sxs-lookup"><span data-stu-id="a552f-177">This extra logic slows down the call.</span></span>  
  
- <span data-ttu-id="a552f-178">При загрузке сборки как нейтральной к домену необходимо найти и загрузить все зависимости сборки, поскольку зависимость, которую нельзя загрузить как нейтральную, не позволяет загрузить сборку как нейтральную.</span><span class="sxs-lookup"><span data-stu-id="a552f-178">All the dependencies of an assembly must be located and loaded when the assembly is loaded domain-neutral, because a dependency that cannot be loaded domain-neutral prevents the assembly from being loaded domain-neutral.</span></span>  
  
## <a name="application-domains-and-threads"></a><span data-ttu-id="a552f-179">Домены приложений и потоки</span><span class="sxs-lookup"><span data-stu-id="a552f-179">Application domains and threads</span></span>

 <span data-ttu-id="a552f-180">Домен приложения формирует изолированную область для безопасности, управления версиями, надежности и выгрузки управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="a552f-180">An application domain forms an isolation boundary for security, versioning, reliability, and unloading of managed code.</span></span> <span data-ttu-id="a552f-181">Поток представляет собой конструкцию операционной системы, используемую в среде CLR для выполнения кода.</span><span class="sxs-lookup"><span data-stu-id="a552f-181">A thread is the operating system construct used by the common language runtime to execute code.</span></span> <span data-ttu-id="a552f-182">Во время выполнения весь управляемый код загружается в домен приложения и выполняется в одном или нескольких управляемых потоках.</span><span class="sxs-lookup"><span data-stu-id="a552f-182">At run time, all managed code is loaded into an application domain and is run by one or more managed threads.</span></span>  
  
 <span data-ttu-id="a552f-183">Однозначного соответствия между потоками и доменами приложений не существует.</span><span class="sxs-lookup"><span data-stu-id="a552f-183">There is not a one-to-one correlation between application domains and threads.</span></span> <span data-ttu-id="a552f-184">В одном домене приложения могут одновременно выполняться несколько потоков, при этом конкретный поток не ограничен одним доменом приложения.</span><span class="sxs-lookup"><span data-stu-id="a552f-184">Several threads can execute in a single application domain at any given time, and a particular thread is not confined to a single application domain.</span></span> <span data-ttu-id="a552f-185">Таким образом, потоки могут использоваться в разных доменах приложений. Новый поток для каждого домена приложения не создается.</span><span class="sxs-lookup"><span data-stu-id="a552f-185">That is, threads are free to cross application domain boundaries; a new thread is not created for each application domain.</span></span>  
  
 <span data-ttu-id="a552f-186">В любой момент времени каждый поток выполняется в каком-либо домене приложения.</span><span class="sxs-lookup"><span data-stu-id="a552f-186">At any given time, every thread executes in an application domain.</span></span> <span data-ttu-id="a552f-187">В домене приложения может выполняться один или несколько потоков или не выполняться ни одного потока.</span><span class="sxs-lookup"><span data-stu-id="a552f-187">Zero, one, or multiple threads might be executing in any given application domain.</span></span> <span data-ttu-id="a552f-188">Среда выполнения отслеживает соответствие потоков и доменов приложений, в которых они выполняются.</span><span class="sxs-lookup"><span data-stu-id="a552f-188">The runtime keeps track of which threads are running in which application domains.</span></span> <span data-ttu-id="a552f-189">В любой момент времени можно найти домен, в котором выполняется поток, вызвав метод <xref:System.Threading.Thread.GetDomain%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a552f-189">You can locate the domain in which a thread is executing at any time by calling the <xref:System.Threading.Thread.GetDomain%2A?displayProperty=nameWithType> method.</span></span>

### <a name="application-domains-and-cultures"></a><span data-ttu-id="a552f-190">Домены приложений и язык и региональные параметры</span><span class="sxs-lookup"><span data-stu-id="a552f-190">Application domains and cultures</span></span>

 <span data-ttu-id="a552f-191">Язык и региональные параметры, представляемые объектом <xref:System.Globalization.CultureInfo>, связаны с потоками.</span><span class="sxs-lookup"><span data-stu-id="a552f-191">Culture, which is represented by a <xref:System.Globalization.CultureInfo> object, is associated with threads.</span></span> <span data-ttu-id="a552f-192">Чтобы получить язык и региональные параметры, связанные с выполняющимся в данный момент потоком, используйте свойство <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>, а чтобы получить или задать язык и региональные параметры, связанные с выполняющимся в данный момент потоком, используйте свойство <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a552f-192">You can get the culture that is associated with the currently executing thread by using the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property, and you can get or set the culture that is associated with the currently executing thread by using the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="a552f-193">Если связанные с потоком язык и региональные параметры явно заданы с помощью свойства <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType>, они будут связаны с этим потоком и за пределами домена приложения.</span><span class="sxs-lookup"><span data-stu-id="a552f-193">If the culture that is associated with a thread has been explicitly set by using the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> property, it continues to be associated with that thread when the thread crosses application domain boundaries.</span></span> <span data-ttu-id="a552f-194">В противном случае связанные с потоком язык и региональные параметры в любой момент времени определяются значением свойства <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> в домене приложения, где выполняется поток:</span><span class="sxs-lookup"><span data-stu-id="a552f-194">Otherwise, the culture that is associated with the thread at any given time is determined by the value of the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> property in the application domain in which the thread is executing:</span></span>  
  
- <span data-ttu-id="a552f-195">Если значение этого свойства — не `null`, возвращаемые им язык и региональные параметры связаны с потоком (и следовательно возвращаются свойствами <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> и <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="a552f-195">If the value of the property is not `null`, the culture that is returned by the property is associated with the thread (and therefore returned by the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> properties).</span></span>  
  
- <span data-ttu-id="a552f-196">Если значение этого свойства – `null`, с потоком связываются текущие настройки языка и региональных параметров системы.</span><span class="sxs-lookup"><span data-stu-id="a552f-196">If the value of the property is `null`, the current system culture is associated with the thread.</span></span>  
  
## <a name="programming-with-application-domains"></a><span data-ttu-id="a552f-197">Программирование с использованием доменов приложений</span><span class="sxs-lookup"><span data-stu-id="a552f-197">Programming with application domains</span></span>

 <span data-ttu-id="a552f-198">Домены приложений обычно создаются и управляются программно, хост-приложениями среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="a552f-198">Application domains are usually created and manipulated programmatically by runtime hosts.</span></span> <span data-ttu-id="a552f-199">Однако иногда работать с доменами приложений требуется самим приложениям.</span><span class="sxs-lookup"><span data-stu-id="a552f-199">However, sometimes an application program might also want to work with application domains.</span></span> <span data-ttu-id="a552f-200">Например, приложение может загружать компонент в домен, чтобы иметь возможность выгрузить домен (и компонент) без необходимости останавливать все приложение.</span><span class="sxs-lookup"><span data-stu-id="a552f-200">For example, an application program could load an application component into a domain to be able to unload the domain (and the component) without having to stop the entire application.</span></span>  
  
 <span data-ttu-id="a552f-201"><xref:System.AppDomain> — это программный интерфейс для доменов приложений.</span><span class="sxs-lookup"><span data-stu-id="a552f-201">The <xref:System.AppDomain> is the programmatic interface to application domains.</span></span> <span data-ttu-id="a552f-202">Этот класс содержит методы для создания и выгрузки доменов, для создания экземпляров типов в доменах и для подписки на различные уведомления, такие как выгрузка домена приложения.</span><span class="sxs-lookup"><span data-stu-id="a552f-202">This class includes methods to create and unload domains, to create instances of types in domains, and to register for various notifications such as application domain unloading.</span></span> <span data-ttu-id="a552f-203">В следующей таблице перечислены часто используемые методы <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="a552f-203">The following table lists commonly used <xref:System.AppDomain> methods.</span></span>  
  
|<span data-ttu-id="a552f-204">Метод AppDomain</span><span class="sxs-lookup"><span data-stu-id="a552f-204">AppDomain Method</span></span>|<span data-ttu-id="a552f-205">Описание</span><span class="sxs-lookup"><span data-stu-id="a552f-205">Description</span></span>|  
|----------------------|-----------------|  
|<xref:System.AppDomain.CreateDomain%2A>|<span data-ttu-id="a552f-206">Создает новый домен приложения.</span><span class="sxs-lookup"><span data-stu-id="a552f-206">Creates a new application domain.</span></span> <span data-ttu-id="a552f-207">Рекомендуется использовать перегрузку этого метода, в которой определяется объект <xref:System.AppDomainSetup>.</span><span class="sxs-lookup"><span data-stu-id="a552f-207">It is recommended that you use an overload of this method that specifies an <xref:System.AppDomainSetup> object.</span></span> <span data-ttu-id="a552f-208">Это предпочтительный способ установки свойств нового домена, таких как база приложения или корневой каталог приложения, расположение файла конфигурации домена и путь поиска, используемый средой CLR для загрузки сборок в домен.</span><span class="sxs-lookup"><span data-stu-id="a552f-208">This is the preferred way to set the properties of a new domain, such as the application base, or root directory for the application; the location of the configuration file for the domain; and the search path that the common language runtime is to use to load assemblies into the domain.</span></span>|  
|<span data-ttu-id="a552f-209"><xref:System.AppDomain.ExecuteAssembly%2A> и <xref:System.AppDomain.ExecuteAssemblyByName%2A></span><span class="sxs-lookup"><span data-stu-id="a552f-209"><xref:System.AppDomain.ExecuteAssembly%2A> and <xref:System.AppDomain.ExecuteAssemblyByName%2A></span></span>|<span data-ttu-id="a552f-210">Выполняет сборку в домене приложения.</span><span class="sxs-lookup"><span data-stu-id="a552f-210">Executes an assembly in the application domain.</span></span> <span data-ttu-id="a552f-211">Это метод экземпляра, поэтому его можно использовать для выполнения кода в другом домене приложения, на который имеется ссылка.</span><span class="sxs-lookup"><span data-stu-id="a552f-211">This is an instance method, so it can be used to execute code in another application domain to which you have a reference.</span></span>|  
|<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>|<span data-ttu-id="a552f-212">Создает экземпляр указанного типа в домене приложения и возвращает прокси.</span><span class="sxs-lookup"><span data-stu-id="a552f-212">Creates an instance of a specified type in the application domain, and returns a proxy.</span></span> <span data-ttu-id="a552f-213">Этот метод служит для избежания загрузки сборки, содержащей созданный тип, в вызывающую сборку.</span><span class="sxs-lookup"><span data-stu-id="a552f-213">Use this method to avoid loading the assembly containing the created type into the calling assembly.</span></span>|  
|<xref:System.AppDomain.Unload%2A>|<span data-ttu-id="a552f-214">Корректно завершает работу домена.</span><span class="sxs-lookup"><span data-stu-id="a552f-214">Performs a graceful shutdown of the domain.</span></span> <span data-ttu-id="a552f-215">Домен приложения не выгружается до тех пор, пока все запущенные в домене потоки не будут остановлены или исключены из домена.</span><span class="sxs-lookup"><span data-stu-id="a552f-215">The application domain is not unloaded until all threads running in the domain have either stopped or are no longer in the domain.</span></span>|  
  
> [!NOTE]
> <span data-ttu-id="a552f-216">Среда CLR не поддерживает сериализацию глобальных методов, поэтому для выполнения глобальных методов в других доменах приложений использовать делегаты нельзя.</span><span class="sxs-lookup"><span data-stu-id="a552f-216">The common language runtime does not support serialization of global methods, so delegates cannot be used to execute global methods in other application domains.</span></span>  
  
 <span data-ttu-id="a552f-217">Неуправляемые интерфейсы, описанные в спецификации Hosting Interfaces Specification для среды CLR, также предоставляют доступ к доменам приложений.</span><span class="sxs-lookup"><span data-stu-id="a552f-217">The unmanaged interfaces described in the common language runtime Hosting Interfaces Specification also provide access to application domains.</span></span> <span data-ttu-id="a552f-218">Хост-приложения среды выполнения могут использовать интерфейсы из неуправляемого кода для создания доменов приложений внутри процесса и для получения доступа к ним.</span><span class="sxs-lookup"><span data-stu-id="a552f-218">Runtime hosts can use interfaces from unmanaged code to create and gain access to the application domains within a process.</span></span>  
  
## <a name="the-complus_loaderoptimization-environment-variable"></a><span data-ttu-id="a552f-219">Переменная среды COMPLUS_LoaderOptimization</span><span class="sxs-lookup"><span data-stu-id="a552f-219">The COMPLUS_LoaderOptimization environment variable</span></span>

 <span data-ttu-id="a552f-220">Переменная среды, которая задает политику оптимизации загрузчика по умолчанию для исполняемого приложения.</span><span class="sxs-lookup"><span data-stu-id="a552f-220">An environment variable that sets the default loader optimization policy of an executable application.</span></span>  
  
### <a name="syntax"></a><span data-ttu-id="a552f-221">Синтаксис</span><span class="sxs-lookup"><span data-stu-id="a552f-221">Syntax</span></span>  
  
```env  
COMPLUS_LoaderOptimization = 1  
```  
  
### <a name="remarks"></a><span data-ttu-id="a552f-222">Примечания</span><span class="sxs-lookup"><span data-stu-id="a552f-222">Remarks</span></span>

 <span data-ttu-id="a552f-223">Стандартное приложение загружает в домен приложения несколько сборок. После этого можно выполнить содержащийся в них код.</span><span class="sxs-lookup"><span data-stu-id="a552f-223">A typical application loads several assemblies into an application domain before the code they contain can be executed.</span></span>  
  
 <span data-ttu-id="a552f-224">Способ загрузки определяет, может ли JIT-скомпилированный код сборки использоваться несколькими доменами приложения в одном процессе.</span><span class="sxs-lookup"><span data-stu-id="a552f-224">The way the assembly is loaded determines whether its just-in-time (JIT) compiled code can be shared by multiple application domains in the process.</span></span>  
  
- <span data-ttu-id="a552f-225">Если сборка загружается как независимая от домена, то все домены приложения с одним набором разрешений безопасности могут использовать один JIT-скомпилированный код.</span><span class="sxs-lookup"><span data-stu-id="a552f-225">If an assembly is loaded domain-neutral, all application domains that share the same security grant set can share the same JIT-compiled code.</span></span> <span data-ttu-id="a552f-226">В этом случае приложение использует меньше памяти.</span><span class="sxs-lookup"><span data-stu-id="a552f-226">This reduces the memory required by the application.</span></span>  
  
- <span data-ttu-id="a552f-227">Если сборка загружается как зависимая от домена, ее необходимо JIT-компилировать во всех соответствующих доменах приложения, при этом в каждом случае загрузчик должен использовать разные внутренние ресурсы.</span><span class="sxs-lookup"><span data-stu-id="a552f-227">If an assembly is not loaded domain-neutral, it must be JIT-compiled in every application domain in which it is loaded and the loader must not share internal resources across application domains.</span></span>  
  
 <span data-ttu-id="a552f-228">Если значение флага среды COMPLUS_LoaderOptimization — 1, то хост-приложение среды выполнения использует способ загрузки SingleDomain.</span><span class="sxs-lookup"><span data-stu-id="a552f-228">When set to 1, the COMPLUS_LoaderOptimization environment flag forces the runtime host to load all assemblies in non-domain-neutral way known as SingleDomain.</span></span> <span data-ttu-id="a552f-229">Он принудительно загружает все сборки как зависимые от домена, за исключением сборки Mscorlib, которая всегда загружается как независимая.</span><span class="sxs-lookup"><span data-stu-id="a552f-229">SingleDomain loads no assemblies as domain-neutral, except Mscorlib, which is always loaded domain-neutral.</span></span> <span data-ttu-id="a552f-230">Этот вариант называется однодоменным, поскольку обычно он используется, когда в хост-приложении запускается только одно приложение в процессе.</span><span class="sxs-lookup"><span data-stu-id="a552f-230">This setting is called single domain because it is commonly used when the host is running only a single application in the process.</span></span>  
  
> [!CAUTION]
> <span data-ttu-id="a552f-231">Флаг среды COMPLUS_LoaderOptimization предназначен для сценариев диагностики и тестирования.</span><span class="sxs-lookup"><span data-stu-id="a552f-231">The COMPLUS_LoaderOptimization environment flag was designed to be used in diagnostic and test scenarios.</span></span> <span data-ttu-id="a552f-232">Когда он включен, работа может существенно замедляться, а использование памяти — увеличиваться.</span><span class="sxs-lookup"><span data-stu-id="a552f-232">Having the flag turned on can cause severe slow-down and increase in memory usage.</span></span>  
  
### <a name="code-example"></a><span data-ttu-id="a552f-233">Пример кода</span><span class="sxs-lookup"><span data-stu-id="a552f-233">Code example</span></span>

 <span data-ttu-id="a552f-234">Чтобы все сборки для службы IISADMIN загружались как зависимые от домена, добавьте код `COMPLUS_LoaderOptimization=1` в многострочный параметр среды в разделе HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\IISADMIN.</span><span class="sxs-lookup"><span data-stu-id="a552f-234">To force all assemblies not to be loaded as domain-neutral for the IISADMIN service can be achieved by appending `COMPLUS_LoaderOptimization=1` to the Environment’s Multi-String Value in the HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\IISADMIN key.</span></span>  
  
```env  
Key = HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\IISADMIN  
Name = Environment  
Type = REG_MULTI_SZ  
Value (to append) = COMPLUS_LoaderOptimization=1  
```  
  
## <a name="see-also"></a><span data-ttu-id="a552f-235">См. также</span><span class="sxs-lookup"><span data-stu-id="a552f-235">See also</span></span>

- <xref:System.AppDomain?displayProperty=nameWithType>
- <xref:System.MarshalByRefObject?displayProperty=nameWithType>
- [<span data-ttu-id="a552f-236">Программирование с использованием доменов приложений и сборок</span><span class="sxs-lookup"><span data-stu-id="a552f-236">Programming with Application Domains and Assemblies</span></span>](index.md)
- [<span data-ttu-id="a552f-237">Использование доменов приложений</span><span class="sxs-lookup"><span data-stu-id="a552f-237">Using Application Domains</span></span>](use.md)
