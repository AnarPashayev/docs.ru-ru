---
title: Метод ICorProfilerInfo2::DoStackSnapshot
ms.date: 03/30/2017
api_name:
- ICorProfilerInfo2.DoStackSnapshot
api_location:
- mscorwks.dll
api_type:
- COM
f1_keywords:
- ICorProfilerInfo2::DoStackSnapshot
helpviewer_keywords:
- ICorProfilerInfo2::DoStackSnapshot method [.NET Framework profiling]
- DoStackSnapshot method [.NET Framework profiling]
ms.assetid: 287b11e9-7c52-4a13-ba97-751203fa97f4
topic_type:
- apiref
ms.openlocfilehash: 64bcf6ee58d743a26e31c49a425f36cc808b5080
ms.sourcegitcommit: 9a39f2a06f110c9c7ca54ba216900d038aa14ef3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/23/2019
ms.locfileid: "74426826"
---
# <a name="icorprofilerinfo2dostacksnapshot-method"></a>Метод ICorProfilerInfo2::DoStackSnapshot
Просматривает управляемые кадры в стеке для указанного потока и отправляет сведения профилировщику через обратный вызов.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
HRESULT DoStackSnapshot(  
    [in] ThreadID thread,  
    [in] StackSnapshotCallback *callback,  
    [in] ULONG32 infoFlags,  
    [in] void *clientData,  
    [in, size_is(contextSize), length_is(contextSize)] BYTE context[],  
    [in] ULONG32 contextSize);  
```  
  
## <a name="parameters"></a>Параметры  
 `thread`  
 окне Идентификатор целевого потока.  
  
 При передаче значения NULL в `thread` выдается моментальный снимок текущего потока. Если передается `ThreadID` другого потока, среда CLR приостанавливает этот поток, выполняет моментальный снимок и возобновляет работу.  
  
 `callback`  
 окне Указатель на реализацию метода [стаккснапшоткаллбакк](../../../../docs/framework/unmanaged-api/profiling/stacksnapshotcallback-function.md) , который ВЫЗЫВАЕТся средой CLR для предоставления профилировщику сведений о каждом управляемом кадре и каждом запуске неуправляемых фреймов.  
  
 Метод `StackSnapshotCallback` реализуется модулем записи профилировщика.  
  
 `infoFlags`  
 окне Значение перечисления [COR_PRF_SNAPSHOT_INFO](../../../../docs/framework/unmanaged-api/profiling/cor-prf-snapshot-info-enumeration.md) , которое указывает объем данных, которые необходимо передать обратно для каждого кадра путем `StackSnapshotCallback`.  
  
 `clientData`  
 окне Указатель на клиентские данные, которые передаются непосредственно в функцию обратного вызова `StackSnapshotCallback`.  
  
 `context`  
 окне Указатель на структуру Win32 `CONTEXT`, которая используется для заполнения прохода стека. Структура Win32 `CONTEXT` содержит значения регистров ЦП и представляет состояние ЦП в определенный момент времени.  
  
 Начальное значение помогает среде CLR определить, где следует начать анализ стека, если вершина стека является неуправляемым вспомогательным кодом. в противном случае начальное значение игнорируется. Для асинхронного прохода необходимо указать начальное значение. При выполнении синхронного анализа начальное значение не требуется.  
  
 Параметр `context` действителен только в том случае, если флаг COR_PRF_SNAPSHOT_CONTEXT был передан в параметре `infoFlags`.  
  
 `contextSize`  
 окне Размер структуры `CONTEXT`, на которую ссылается параметр `context`.  
  
## <a name="remarks"></a>Заметки  
 Передача значения NULL для `thread` дает моментальный снимок текущего потока. Моментальные снимки могут создаваться для других потоков, только если целевой поток приостановлен в данный момент времени.  
  
 Когда профилировщик хочет проанализировать стек, он вызывает `DoStackSnapshot`. Перед возвратом из этого вызова среда CLR вызывает `StackSnapshotCallback` несколько раз, по одному разу для каждого управляемого кадра (или выполнения неуправляемых фреймов) в стеке. При обнаружении неуправляемых кадров их необходимо проанализировать самостоятельно.  
  
 Порядок, в котором выполняется продвижение стека, — это обратная процедура, с которой кадры помещаются в стек: первый кадр (последний отправленный), основной кадр (с первой передачей) последним.  
  
 Дополнительные сведения о программировании профилировщика для прохода по управляемым стекам см. в статьях анализ [стека профилировщика в .NET Framework 2,0: основы и больше](https://go.microsoft.com/fwlink/?LinkId=73638).  
  
 Анализ стека может быть синхронным или асинхронным, как описано в следующих разделах.  
  
## <a name="synchronous-stack-walk"></a>Синхронный анализ стека  
 Синхронный анализ стека включает в себя проход стека текущего потока в ответ на обратный вызов. Для этого не требуется заполнение или приостановка.  
  
 Синхронный вызов выполняется, когда в ответ на CLR, вызывающий один из методов [ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) (или [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)) профилировщика, вызывается `DoStackSnapshot` для прохода по стеку текущего потока. Это полезно, если нужно увидеть, как выглядит стек на уведомлении, например, с помощью [ICorProfilerCallback:: ObjectAllocated](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-objectallocated-method.md). Вы просто вызываете `DoStackSnapshot` в методе `ICorProfilerCallback`, передавая значение NULL в параметрах `context` и `thread`.  
  
## <a name="asynchronous-stack-walk"></a>Асинхронный анализ стека  
 Асинхронный проход стека включает в себя проход стека другого потока или проход стека текущего потока, а не в ответ на обратный вызов, но путем захвата указателя инструкций текущего потока. Асинхронный проход требует начального значения, если вершина стека является неуправляемым кодом, который не является частью вызова неуправляемого кода (PInvoke) или вызовов COM, но вспомогательный код в самой среде CLR. Например, код, выполняющий JIT-компиляцию или сборку мусора, является вспомогательным кодом.  
  
 Вы получаете начальное значение, напрямую приостанавливая целевой поток и проследуя его стек, пока не найдете самый верхний управляемый фрейм. После приостановки целевого потока получите текущий контекст регистров целевого потока. Затем определите, указывает ли контекст регистрации на неуправляемый код, вызвав [ICorProfilerInfo:: GetFunctionFromIP](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getfunctionfromip-method.md) — если он возвращает `FunctionID` равно нулю, кадр является неуправляемым кодом. Теперь пройдите по стеку, пока не дойдете до первого управляемого фрейма, а затем вычислите контекст начального значения в зависимости от контекста регистров для этого кадра.  
  
 Вызовите `DoStackSnapshot` с контекстом начального значения, чтобы начать асинхронный обход стека. Если начальное значение не задано, `DoStackSnapshot` может пропустить управляемые фреймы в верхней части стека и, следовательно, даст вам неполную проверку стека. Если указать начальное значение, оно должно указывать на JIT-скомпилированный или генератор образов в машинном коде (Ngen. exe), созданный кодом; в противном случае `DoStackSnapshot` возвращает код ошибки CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX.  
  
 Асинхронные проверки стека могут привести к взаимоблокировкам или нарушениям доступа, если не следовать приведенным ниже рекомендациям.  
  
- При прямой приостановке потоков Помните, что только поток, который никогда не выполнял управляемый код, может приостановить другой поток.  
  
- Всегда заблокируйте в обратном вызове [ICorProfilerCallback:: ThreadDestroyed](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-threaddestroyed-method.md) , пока не завершится проверка стека этого потока.  
  
- Не держите блокировку во время вызова профилировщика в функцию CLR, которая может активировать сборку мусора. Это значит, что блокировка не удерживается, если владеющий поток может выполнить вызов, который активирует сборку мусора.  
  
 Существует также риск взаимоблокировки при вызове `DoStackSnapshot` из потока, созданного профилировщиком, чтобы можно было пройти по стеку отдельного целевого потока. В первый раз, когда созданный поток вводит определенные `ICorProfilerInfo*` методы (в том числе `DoStackSnapshot`), среда CLR будет выполнять для этого потока инициализацию, зависящую от среды CLR, для каждого потока. Если профилировщик приостановил целевой поток, стек которого вы пытаетесь проанализировать, и если этот целевой поток был владельцем блокировки, необходимой для выполнения этой инициализации для каждого потока, произойдет взаимоблокировка. Чтобы избежать этой взаимоблокировки, сделайте начальный вызов `DoStackSnapshot` из потока, созданного профилировщиком, для прохода по отдельному целевому потоку, но сначала не приостанавливаете целевой поток. Этот начальный вызов гарантирует, что инициализация для каждого потока может завершиться без взаимоблокировки. Если `DoStackSnapshot` проходит успешный и сообщает по крайней мере один кадр, после этой точки он будет защищен для этого потока, созданного профилировщиком, для приостановки любого целевого потока и вызова `DoStackSnapshot` для прохода стека этого целевого потока.  
  
## <a name="requirements"></a>Требования  
 **Платформы:** см. раздел [Требования к системе](../../../../docs/framework/get-started/system-requirements.md).  
  
 **Заголовок:** CorProf.idl, CorProf.h  
  
 **Библиотека:** CorGuids.lib  
  
 **Версии платформы .NET Framework:** [!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]  
  
## <a name="see-also"></a>См. также

- [Интерфейс ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md)
- [Интерфейс ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md)
