---
title: Метод ICorProfilerInfo2::DoStackSnapshot
ms.date: 03/30/2017
api_name:
- ICorProfilerInfo2.DoStackSnapshot
api_location:
- mscorwks.dll
api_type:
- COM
f1_keywords:
- ICorProfilerInfo2::DoStackSnapshot
helpviewer_keywords:
- ICorProfilerInfo2::DoStackSnapshot method [.NET Framework profiling]
- DoStackSnapshot method [.NET Framework profiling]
ms.assetid: 287b11e9-7c52-4a13-ba97-751203fa97f4
topic_type:
- apiref
ms.openlocfilehash: 49b1769ade8e8b71c146a818523b124984c44ed6
ms.sourcegitcommit: b11efd71c3d5ce3d9449c8d4345481b9f21392c6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/29/2020
ms.locfileid: "76868894"
---
# <a name="icorprofilerinfo2dostacksnapshot-method"></a><span data-ttu-id="3c554-102">Метод ICorProfilerInfo2::DoStackSnapshot</span><span class="sxs-lookup"><span data-stu-id="3c554-102">ICorProfilerInfo2::DoStackSnapshot Method</span></span>
<span data-ttu-id="3c554-103">Просматривает управляемые кадры в стеке для указанного потока и отправляет сведения профилировщику через обратный вызов.</span><span class="sxs-lookup"><span data-stu-id="3c554-103">Walks the managed frames on the stack for the specified thread, and sends information to the profiler through a callback.</span></span>  
  
## <a name="syntax"></a><span data-ttu-id="3c554-104">Синтаксис</span><span class="sxs-lookup"><span data-stu-id="3c554-104">Syntax</span></span>  
  
```cpp  
HRESULT DoStackSnapshot(  
    [in] ThreadID thread,  
    [in] StackSnapshotCallback *callback,  
    [in] ULONG32 infoFlags,  
    [in] void *clientData,  
    [in, size_is(contextSize), length_is(contextSize)] BYTE context[],  
    [in] ULONG32 contextSize);  
```  
  
## <a name="parameters"></a><span data-ttu-id="3c554-105">Параметры</span><span class="sxs-lookup"><span data-stu-id="3c554-105">Parameters</span></span>  
 `thread`  
 <span data-ttu-id="3c554-106">окне Идентификатор целевого потока.</span><span class="sxs-lookup"><span data-stu-id="3c554-106">[in] The ID of the target thread.</span></span>  
  
 <span data-ttu-id="3c554-107">При передаче значения NULL в `thread` выдается моментальный снимок текущего потока.</span><span class="sxs-lookup"><span data-stu-id="3c554-107">Passing null in `thread` yields a snapshot of the current thread.</span></span> <span data-ttu-id="3c554-108">Если передается `ThreadID` другого потока, среда CLR приостанавливает этот поток, выполняет моментальный снимок и возобновляет работу.</span><span class="sxs-lookup"><span data-stu-id="3c554-108">If a `ThreadID` of a different thread is passed, the common language runtime (CLR) suspends that thread, performs the snapshot, and resumes.</span></span>  
  
 `callback`  
 <span data-ttu-id="3c554-109">окне Указатель на реализацию метода [стаккснапшоткаллбакк](stacksnapshotcallback-function.md) , который ВЫЗЫВАЕТся средой CLR для предоставления профилировщику сведений о каждом управляемом кадре и каждом запуске неуправляемых фреймов.</span><span class="sxs-lookup"><span data-stu-id="3c554-109">[in] A pointer to the implementation of the [StackSnapshotCallback](stacksnapshotcallback-function.md) method, which is called by the CLR to provide the profiler with information on each managed frame and each run of unmanaged frames.</span></span>  
  
 <span data-ttu-id="3c554-110">Метод `StackSnapshotCallback` реализуется модулем записи профилировщика.</span><span class="sxs-lookup"><span data-stu-id="3c554-110">The `StackSnapshotCallback` method is implemented by the profiler writer.</span></span>  
  
 `infoFlags`  
 <span data-ttu-id="3c554-111">окне Значение перечисления [COR_PRF_SNAPSHOT_INFO](cor-prf-snapshot-info-enumeration.md) , которое указывает объем данных, которые необходимо передать обратно для каждого кадра путем `StackSnapshotCallback`.</span><span class="sxs-lookup"><span data-stu-id="3c554-111">[in] A value of the [COR_PRF_SNAPSHOT_INFO](cor-prf-snapshot-info-enumeration.md) enumeration, which specifies the amount of data to be passed back for each frame by `StackSnapshotCallback`.</span></span>  
  
 `clientData`  
 <span data-ttu-id="3c554-112">окне Указатель на клиентские данные, которые передаются непосредственно в функцию обратного вызова `StackSnapshotCallback`.</span><span class="sxs-lookup"><span data-stu-id="3c554-112">[in] A pointer to the client data, which is passed straight through to the `StackSnapshotCallback` callback function.</span></span>  
  
 `context`  
 <span data-ttu-id="3c554-113">окне Указатель на структуру Win32 `CONTEXT`, которая используется для заполнения прохода стека.</span><span class="sxs-lookup"><span data-stu-id="3c554-113">[in] A pointer to a Win32 `CONTEXT` structure, which is used to seed the stack walk.</span></span> <span data-ttu-id="3c554-114">Структура Win32 `CONTEXT` содержит значения регистров ЦП и представляет состояние ЦП в определенный момент времени.</span><span class="sxs-lookup"><span data-stu-id="3c554-114">The Win32 `CONTEXT` structure contains values of the CPU registers and represents the state of the CPU at a particular moment in time.</span></span>  
  
 <span data-ttu-id="3c554-115">Начальное значение помогает среде CLR определить, где следует начать анализ стека, если вершина стека является неуправляемым вспомогательным кодом. в противном случае начальное значение игнорируется.</span><span class="sxs-lookup"><span data-stu-id="3c554-115">The seed helps the CLR determine where to begin the stack walk, if the top of the stack is unmanaged helper code; otherwise, the seed is ignored.</span></span> <span data-ttu-id="3c554-116">Для асинхронного прохода необходимо указать начальное значение.</span><span class="sxs-lookup"><span data-stu-id="3c554-116">A seed must be supplied for an asynchronous walk.</span></span> <span data-ttu-id="3c554-117">При выполнении синхронного анализа начальное значение не требуется.</span><span class="sxs-lookup"><span data-stu-id="3c554-117">If you are doing a synchronous walk, no seed is necessary.</span></span>  
  
 <span data-ttu-id="3c554-118">Параметр `context` действителен только в том случае, если флаг COR_PRF_SNAPSHOT_CONTEXT был передан в параметре `infoFlags`.</span><span class="sxs-lookup"><span data-stu-id="3c554-118">The `context` parameter is valid only if the COR_PRF_SNAPSHOT_CONTEXT flag was passed in the `infoFlags` parameter.</span></span>  
  
 `contextSize`  
 <span data-ttu-id="3c554-119">окне Размер структуры `CONTEXT`, на которую ссылается параметр `context`.</span><span class="sxs-lookup"><span data-stu-id="3c554-119">[in] The size of the `CONTEXT` structure, which is referenced by the `context` parameter.</span></span>  
  
## <a name="remarks"></a><span data-ttu-id="3c554-120">Заметки</span><span class="sxs-lookup"><span data-stu-id="3c554-120">Remarks</span></span>  
 <span data-ttu-id="3c554-121">Передача значения NULL для `thread` дает моментальный снимок текущего потока.</span><span class="sxs-lookup"><span data-stu-id="3c554-121">Passing null for `thread` yields a snapshot of the current thread.</span></span> <span data-ttu-id="3c554-122">Моментальные снимки могут создаваться для других потоков, только если целевой поток приостановлен в данный момент времени.</span><span class="sxs-lookup"><span data-stu-id="3c554-122">Snapshots can be taken of other threads only if the target thread is suspended at the time.</span></span>  
  
 <span data-ttu-id="3c554-123">Когда профилировщик хочет проанализировать стек, он вызывает `DoStackSnapshot`.</span><span class="sxs-lookup"><span data-stu-id="3c554-123">When the profiler wants to walk the stack, it calls `DoStackSnapshot`.</span></span> <span data-ttu-id="3c554-124">Перед возвратом из этого вызова среда CLR вызывает `StackSnapshotCallback` несколько раз, по одному разу для каждого управляемого кадра (или выполнения неуправляемых фреймов) в стеке.</span><span class="sxs-lookup"><span data-stu-id="3c554-124">Before the CLR returns from that call, it calls your `StackSnapshotCallback` several times, once for each managed frame (or run of unmanaged frames) on the stack.</span></span> <span data-ttu-id="3c554-125">При обнаружении неуправляемых кадров их необходимо проанализировать самостоятельно.</span><span class="sxs-lookup"><span data-stu-id="3c554-125">When unmanaged frames are encountered, you must walk them yourself.</span></span>  
  
 <span data-ttu-id="3c554-126">Порядок, в котором выполняется продвижение стека, — это обратная процедура, с которой кадры помещаются в стек: первый кадр (последний отправленный), основной кадр (с первой передачей) последним.</span><span class="sxs-lookup"><span data-stu-id="3c554-126">The order in which the stack is walked is the reverse of how the frames were pushed onto the stack: leaf (last-pushed) frame first, main (first-pushed) frame last.</span></span>  
  
 <span data-ttu-id="3c554-127">Дополнительные сведения о программировании профилировщика для прохода по управляемым стекам см. в статьях анализ [стека профилировщика в .NET Framework 2,0: основы и больше](https://docs.microsoft.com/previous-versions/dotnet/articles/bb264782(v=msdn.10)).</span><span class="sxs-lookup"><span data-stu-id="3c554-127">For more information about how to program the profiler to walk managed stacks, see [Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond](https://docs.microsoft.com/previous-versions/dotnet/articles/bb264782(v=msdn.10)).</span></span>  
  
 <span data-ttu-id="3c554-128">Анализ стека может быть синхронным или асинхронным, как описано в следующих разделах.</span><span class="sxs-lookup"><span data-stu-id="3c554-128">A stack walk can be synchronous or asynchronous, as explained in the following sections.</span></span>  
  
## <a name="synchronous-stack-walk"></a><span data-ttu-id="3c554-129">Синхронный анализ стека</span><span class="sxs-lookup"><span data-stu-id="3c554-129">Synchronous Stack Walk</span></span>  
 <span data-ttu-id="3c554-130">Синхронный анализ стека включает в себя проход стека текущего потока в ответ на обратный вызов.</span><span class="sxs-lookup"><span data-stu-id="3c554-130">A synchronous stack walk involves walking the stack of the current thread in response to a callback.</span></span> <span data-ttu-id="3c554-131">Для этого не требуется заполнение или приостановка.</span><span class="sxs-lookup"><span data-stu-id="3c554-131">It does not require seeding or suspending.</span></span>  
  
 <span data-ttu-id="3c554-132">Синхронный вызов выполняется, когда в ответ на CLR, вызывающий один из методов [ICorProfilerCallback](icorprofilercallback-interface.md) (или [ICorProfilerCallback2](icorprofilercallback2-interface.md)) профилировщика, вызывается `DoStackSnapshot` для прохода по стеку текущего потока.</span><span class="sxs-lookup"><span data-stu-id="3c554-132">You make a synchronous call when, in response to the CLR calling one of your profiler's [ICorProfilerCallback](icorprofilercallback-interface.md) (or [ICorProfilerCallback2](icorprofilercallback2-interface.md)) methods, you call `DoStackSnapshot` to walk the stack of the current thread.</span></span> <span data-ttu-id="3c554-133">Это полезно, если нужно увидеть, как выглядит стек на уведомлении, например, с помощью [ICorProfilerCallback:: ObjectAllocated](icorprofilercallback-objectallocated-method.md).</span><span class="sxs-lookup"><span data-stu-id="3c554-133">This is useful when you want to see what the stack looks like at a notification such as [ICorProfilerCallback::ObjectAllocated](icorprofilercallback-objectallocated-method.md).</span></span> <span data-ttu-id="3c554-134">Вы просто вызываете `DoStackSnapshot` в методе `ICorProfilerCallback`, передавая значение NULL в параметрах `context` и `thread`.</span><span class="sxs-lookup"><span data-stu-id="3c554-134">You just call `DoStackSnapshot` from within your `ICorProfilerCallback` method, passing null in the `context` and `thread` parameters.</span></span>  
  
## <a name="asynchronous-stack-walk"></a><span data-ttu-id="3c554-135">Асинхронный анализ стека</span><span class="sxs-lookup"><span data-stu-id="3c554-135">Asynchronous Stack Walk</span></span>  
 <span data-ttu-id="3c554-136">Асинхронный проход стека включает в себя проход стека другого потока или проход стека текущего потока, а не в ответ на обратный вызов, но путем захвата указателя инструкций текущего потока.</span><span class="sxs-lookup"><span data-stu-id="3c554-136">An asynchronous stack walk entails walking the stack of a different thread, or walking the stack of the current thread, not in response to a callback, but by hijacking the current thread's instruction pointer.</span></span> <span data-ttu-id="3c554-137">Асинхронный проход требует начального значения, если вершина стека является неуправляемым кодом, который не является частью вызова неуправляемого кода (PInvoke) или вызовов COM, но вспомогательный код в самой среде CLR.</span><span class="sxs-lookup"><span data-stu-id="3c554-137">An asynchronous walk requires a seed if the top of the stack is unmanaged code that is not part of a platform invoke (PInvoke) or COM call, but helper code in the CLR itself.</span></span> <span data-ttu-id="3c554-138">Например, код, выполняющий JIT-компиляцию или сборку мусора, является вспомогательным кодом.</span><span class="sxs-lookup"><span data-stu-id="3c554-138">For example, code that does just-in-time (JIT) compiling or garbage collection is helper code.</span></span>  
  
 <span data-ttu-id="3c554-139">Вы получаете начальное значение, напрямую приостанавливая целевой поток и проследуя его стек, пока не найдете самый верхний управляемый фрейм.</span><span class="sxs-lookup"><span data-stu-id="3c554-139">You obtain a seed by directly suspending the target thread and walking its stack yourself, until you find the topmost managed frame.</span></span> <span data-ttu-id="3c554-140">После приостановки целевого потока получите текущий контекст регистров целевого потока.</span><span class="sxs-lookup"><span data-stu-id="3c554-140">After the target thread is suspended, get the target thread's current register context.</span></span> <span data-ttu-id="3c554-141">Затем определите, указывает ли контекст регистрации на неуправляемый код, вызвав [ICorProfilerInfo:: GetFunctionFromIP](icorprofilerinfo-getfunctionfromip-method.md) — если он возвращает `FunctionID` равно нулю, кадр является неуправляемым кодом.</span><span class="sxs-lookup"><span data-stu-id="3c554-141">Next, determine whether the register context points to unmanaged code by calling [ICorProfilerInfo::GetFunctionFromIP](icorprofilerinfo-getfunctionfromip-method.md) — if it returns a `FunctionID` equal to zero, the frame is unmanaged code.</span></span> <span data-ttu-id="3c554-142">Теперь пройдите по стеку, пока не дойдете до первого управляемого фрейма, а затем вычислите контекст начального значения в зависимости от контекста регистров для этого кадра.</span><span class="sxs-lookup"><span data-stu-id="3c554-142">Now, walk the stack until you reach the first managed frame, and then calculate the seed context based on the register context for that frame.</span></span>  
  
 <span data-ttu-id="3c554-143">Вызовите `DoStackSnapshot` с контекстом начального значения, чтобы начать асинхронный обход стека.</span><span class="sxs-lookup"><span data-stu-id="3c554-143">Call `DoStackSnapshot` with your seed context to begin the asynchronous stack walk.</span></span> <span data-ttu-id="3c554-144">Если начальное значение не задано, `DoStackSnapshot` может пропустить управляемые фреймы в верхней части стека и, следовательно, даст вам неполную проверку стека.</span><span class="sxs-lookup"><span data-stu-id="3c554-144">If you do not supply a seed, `DoStackSnapshot` might skip managed frames at the top of the stack and, consequently, will give you an incomplete stack walk.</span></span> <span data-ttu-id="3c554-145">Если указать начальное значение, оно должно указывать на JIT-скомпилированный или генератор образов в машинном коде (Ngen. exe), созданный кодом; в противном случае `DoStackSnapshot` возвращает код ошибки CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX.</span><span class="sxs-lookup"><span data-stu-id="3c554-145">If you do supply a seed, it must point to JIT-compiled or Native Image Generator (Ngen.exe)-generated code; otherwise, `DoStackSnapshot` returns the failure code, CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX.</span></span>  
  
 <span data-ttu-id="3c554-146">Асинхронные проверки стека могут привести к взаимоблокировкам или нарушениям доступа, если не следовать приведенным ниже рекомендациям.</span><span class="sxs-lookup"><span data-stu-id="3c554-146">Asynchronous stack walks can easily cause deadlocks or access violations, unless you follow these guidelines:</span></span>  
  
- <span data-ttu-id="3c554-147">При прямой приостановке потоков Помните, что только поток, который никогда не выполнял управляемый код, может приостановить другой поток.</span><span class="sxs-lookup"><span data-stu-id="3c554-147">When you directly suspend threads, remember that only a thread that has never run managed code can suspend another thread.</span></span>  
  
- <span data-ttu-id="3c554-148">Всегда заблокируйте в обратном вызове [ICorProfilerCallback:: ThreadDestroyed](icorprofilercallback-threaddestroyed-method.md) , пока не завершится проверка стека этого потока.</span><span class="sxs-lookup"><span data-stu-id="3c554-148">Always block in your [ICorProfilerCallback::ThreadDestroyed](icorprofilercallback-threaddestroyed-method.md) callback until that thread's stack walk is complete.</span></span>  
  
- <span data-ttu-id="3c554-149">Не держите блокировку во время вызова профилировщика в функцию CLR, которая может активировать сборку мусора.</span><span class="sxs-lookup"><span data-stu-id="3c554-149">Do not hold a lock while your profiler calls into a CLR function that can trigger a garbage collection.</span></span> <span data-ttu-id="3c554-150">Это значит, что блокировка не удерживается, если владеющий поток может выполнить вызов, который активирует сборку мусора.</span><span class="sxs-lookup"><span data-stu-id="3c554-150">That is, do not hold a lock if the owning thread might make a call that triggers a garbage collection.</span></span>  
  
 <span data-ttu-id="3c554-151">Существует также риск взаимоблокировки при вызове `DoStackSnapshot` из потока, созданного профилировщиком, чтобы можно было пройти по стеку отдельного целевого потока.</span><span class="sxs-lookup"><span data-stu-id="3c554-151">There is also a risk of deadlock if you call `DoStackSnapshot` from a thread that your profiler has created so that you can walk the stack of a separate target thread.</span></span> <span data-ttu-id="3c554-152">В первый раз, когда созданный поток вводит определенные `ICorProfilerInfo*` методы (в том числе `DoStackSnapshot`), среда CLR будет выполнять для этого потока инициализацию, зависящую от среды CLR, для каждого потока.</span><span class="sxs-lookup"><span data-stu-id="3c554-152">The first time the thread you created enters certain `ICorProfilerInfo*` methods (including `DoStackSnapshot`), the CLR will perform per-thread, CLR-specific initialization on that thread.</span></span> <span data-ttu-id="3c554-153">Если профилировщик приостановил целевой поток, стек которого вы пытаетесь проанализировать, и если этот целевой поток был владельцем блокировки, необходимой для выполнения этой инициализации для каждого потока, произойдет взаимоблокировка.</span><span class="sxs-lookup"><span data-stu-id="3c554-153">If your profiler has suspended the target thread whose stack you are trying to walk, and if that target thread happened to own a lock necessary for performing this per-thread initialization, a deadlock will occur.</span></span> <span data-ttu-id="3c554-154">Чтобы избежать этой взаимоблокировки, сделайте начальный вызов `DoStackSnapshot` из потока, созданного профилировщиком, для прохода по отдельному целевому потоку, но сначала не приостанавливаете целевой поток.</span><span class="sxs-lookup"><span data-stu-id="3c554-154">To avoid this deadlock, make an initial call into `DoStackSnapshot` from your profiler-created thread to walk a separate target thread, but do not suspend the target thread first.</span></span> <span data-ttu-id="3c554-155">Этот начальный вызов гарантирует, что инициализация для каждого потока может завершиться без взаимоблокировки.</span><span class="sxs-lookup"><span data-stu-id="3c554-155">This initial call ensures that the per-thread initialization can complete without deadlock.</span></span> <span data-ttu-id="3c554-156">Если `DoStackSnapshot` проходит успешный и сообщает по крайней мере один кадр, после этой точки он будет защищен для этого потока, созданного профилировщиком, для приостановки любого целевого потока и вызова `DoStackSnapshot` для прохода стека этого целевого потока.</span><span class="sxs-lookup"><span data-stu-id="3c554-156">If `DoStackSnapshot` succeeds and reports at least one frame, after that point, it will be safe for that profiler-created thread to suspend any target thread and call `DoStackSnapshot` to walk the stack of that target thread.</span></span>  
  
## <a name="requirements"></a><span data-ttu-id="3c554-157">Требования</span><span class="sxs-lookup"><span data-stu-id="3c554-157">Requirements</span></span>  
 <span data-ttu-id="3c554-158">**Платформы:** см. раздел [Требования к системе](../../../../docs/framework/get-started/system-requirements.md).</span><span class="sxs-lookup"><span data-stu-id="3c554-158">**Platforms:** See [System Requirements](../../../../docs/framework/get-started/system-requirements.md).</span></span>  
  
 <span data-ttu-id="3c554-159">**Заголовок:** CorProf.idl, CorProf.h</span><span class="sxs-lookup"><span data-stu-id="3c554-159">**Header:** CorProf.idl, CorProf.h</span></span>  
  
 <span data-ttu-id="3c554-160">**Библиотека:** CorGuids.lib</span><span class="sxs-lookup"><span data-stu-id="3c554-160">**Library:** CorGuids.lib</span></span>  
  
 <span data-ttu-id="3c554-161">**Версии платформы .NET Framework:** [!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]</span><span class="sxs-lookup"><span data-stu-id="3c554-161">**.NET Framework Versions:** [!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3c554-162">См. также:</span><span class="sxs-lookup"><span data-stu-id="3c554-162">See also</span></span>

- [<span data-ttu-id="3c554-163">Интерфейс ICorProfilerInfo</span><span class="sxs-lookup"><span data-stu-id="3c554-163">ICorProfilerInfo Interface</span></span>](icorprofilerinfo-interface.md)
- [<span data-ttu-id="3c554-164">Интерфейс ICorProfilerInfo2</span><span class="sxs-lookup"><span data-stu-id="3c554-164">ICorProfilerInfo2 Interface</span></span>](icorprofilerinfo2-interface.md)
