---
title: Общие сведения о профилировании
ms.date: 03/30/2017
helpviewer_keywords:
- managed code, profiling API support
- unmanaged code, combining with managed code in profiling
- notification threads [.NET Framework profiling]
- unmanaged code, profiling
- profiling API [.NET Framework], and COM
- profiling API [.NET Framework], unmanaged code profiling
- profilers, writing
- profiling API [.NET Framework], call stacks
- code profilers, writing
- profiling API [.NET Framework], security considerations
- profiling API [.NET Framework], managed code support
- common language runtime, profiling
- profiling API [.NET Framework], notification threads
- call stacks [.NET Framework profiling]
- profiling API [.NET Framework], stack depth
- common language runtime, writing a profiler
- profiling API [.NET Framework], information retrieval interfaces
- shadow stacks [.NET Framework profiling]
- COM, using in the profiling API
- stack snapshots [.NET Framework profiling]
- profiling API [.NET Framework], supported features
- profiling API [.NET Framework], overview
- security, profiling API considerations
- stack depth [.NET Framework profiling]
ms.assetid: 864c2344-71dc-46f9-96b2-ed59fb6427a8
ms.openlocfilehash: 3836b562d969726a6587d702d3edf45abb147d10
ms.sourcegitcommit: 961ec21c22d2f1d55c9cc8a7edf2ade1d1fd92e3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/02/2020
ms.locfileid: "80588506"
---
# <a name="profiling-overview"></a>Общие сведения о профилировании

Профилировщик — это инструмент, который наблюдает за выполнением другого приложения. Профилировщик среды CLR — это библиотека DLL, содержащая функции, которые получают сообщения из среды CLR и отправляют сообщения в среду CLR с помощью API профилирования. Библиотека DLL профилировщика загружается средой CLR во время выполнения.

Традиционные средства профилирования основное внимание уделяют измерению выполнения приложения. То есть они измеряют время, затраченное на каждую функцию, или использование памяти приложением за период времени. API профилирования предназначен для более широкого класса диагностических средств, таких как служебные программы с покрытием кода и расширенные средства отладки. Сфера их применения — вся диагностика в природе. API профилирования не только измеряет, но также наблюдает за выполнением приложения. По этой причине API профилирования никогда не должен использоваться самим приложением, и выполнение приложения не должно ни зависеть от профилировщика, ни подвергаться его влиянию.

Для профилирования приложения среды CLR требуется дополнительная поддержка по сравнению с профилированием стандартно скомпилированного машинного кода. Это объясняется тем, что в среде CLR вводятся такие понятия, как домены приложений, сборка мусора, обработка управляемых исключений, JIT-компиляция кода (преобразование кода MSIL в машинный код) и другие аналогичные возможности. Механизмы традиционного профилирования не могут обнаруживать эти возможности или предоставлять полезные сведения о них. API профилирования эффективно предоставляет эти отсутствующие сведения с минимальным влиянием на производительность среды CLR и профилируемого приложения.

JIT-компиляция во время выполнения обеспечивает прекрасные возможности для профилирования. API профилирования позволяет профилировщику вносить изменения потока кода MSIL в памяти для подпрограммы перед ее JIT-компиляцией. Таким образом, профилировщик может динамически добавлять код инструментирования в определенные подпрограммы, требующие более глубокого анализа. Хотя такой подход возможен в обычных сценариях, его гораздо проще реализовать для среды CLR с помощью API профилирования.

## <a name="the-profiling-api"></a>API профилирования

Как правило, API профилирования используется для записи *профилировщика кода,* который является программой, которая отслеживает выполнение управляемого приложения.

API профилирования используется библиотекой DLL профилировщика, которая загружается в один процесс с профилируемым приложением. Профайлер DLL реализует интерфейс обратного откидки[(ICorProfilerCallback](icorprofilercallback-interface.md) в версии .NET Framework 1.0 и 1.1, [ICorProfilerCallback2](icorprofilercallback2-interface.md) в версии 2.0 и позже). Среда CLR вызывает методы этого интерфейса для уведомления профилировщика о событиях в процессе профилирования. Профайлер может перезвонить в время выполнения, используя методы в интерфейсах [ICorProfilerInfo](icorprofilerinfo-interface.md) и [ICorProfilerInfo2](icorprofilerinfo2-interface.md) для получения информации о состоянии профилированного приложения.

> [!NOTE]
> В одном процессе с профилируемым приложением должна запускаться только часть решения профилировщика, отвечающая за сбор данных. Весь анализ пользовательского интерфейса и данных должен выполняться в отдельном процессе.

На следующем рисунке показано, как библиотека DLL профилировщика взаимодействует с профилируемым приложением и средой CLR.

![Скриншот, отображающие архитектуру профилирования.](./media/profiling-overview/profiling-architecture.png)

### <a name="the-notification-interfaces"></a>Интерфейсы уведомлений

[Интерфейсы ICorProfilerCallback](icorprofilercallback-interface.md) и [ICorProfilerCallback2](icorprofilercallback2-interface.md) можно считать интерфейсами уведомлений. Эти интерфейсы состоят из таких методов, как [ClassLoadStarted](icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished](icorprofilercallback-classloadfinished-method.md)и [JITCompilationStarted.](icorprofilercallback-jitcompilationstarted-method.md) Каждый раз, когда среда CLR загружает или выгружает класс, компилирует функцию и т. д., она вызывает соответствующий метод в интерфейсе `ICorProfilerCallback` или `ICorProfilerCallback2` профилировщика.

Например, профайлер может измерять производительность кода с помощью двух функций уведомления: [FunctionEnter2](functionenter2-function.md) и [FunctionLeave2.](functionleave2-function.md) Он просто устанавливает метки времени для каждого уведомления, собирает результаты и выводит список, в котором указывается, на какие функции было затрачено больше ресурсов ЦП или физического времени во время выполнения приложения.

### <a name="the-information-retrieval-interfaces"></a>Интерфейсы для извлечения сведений

Другими основными интерфейсами, участвующими в профилировании, являются [ICorProfilerInfo](icorprofilerinfo-interface.md) и [ICorProfilerInfo2.](icorprofilerinfo2-interface.md) Профилировщик вызывает эти интерфейсы по мере необходимости для получения дополнительных сведений, помогающих выполнить анализ. Например, всякий раз, когда CLR вызывает функцию [FunctionEnter2,](functionenter2-function.md) она поставляет идентификатор функции. Профайлер может получить больше информации об этой функции, позвонив в метод [ICorProfilerInfo2::GetFunctionInfo2,](icorprofilerinfo2-getfunctioninfo2-method.md) чтобы обнаружить родительский класс функции, ее название и так далее.

## <a name="supported-features"></a>Поддерживаемые функции

API профилирования предоставляет сведения о различных событиях и действиях, которые происходят в среде CLR. Эти сведения можно использовать для мониторинга внутренней работы процессов и анализа производительности приложения .NET Framework.

API профилирования извлекает сведения о следующих действиях и событиях, происходящих в среде CLR.

- События запуска и завершения работы среды CLR.

- События создания и завершения работы домена приложения.

- События загрузки и выгрузки сборки.

- События загрузки и выгрузки модуля.

- События создания и удаления таблицы VTable COM.

- События JIT-компиляции и пошагового выполнения кода.

- События загрузки и выгрузки класса.

- События создания и удаления потока.

- События входа и выхода функции.

- Исключения.

- Переходы между выполнением управляемого и неуправляемого кода.

- Переходы между различными контекстами среды выполнения.

- Сведения о приостановках среды выполнения.

- Сведения о действиях сборки мусора и кучи в памяти времени выполнения.

API профилирования можно вызывать из любого (неуправляемого) языка, совместимого с COM.

Этот API является эффективным с точки зрения потребления ресурсов ЦП и памяти. Профилирование не влечет за собой изменения профилируемого приложения, которые могут привести к недостоверным результатам.

API профилирования полезен для профилировщиков как с выборкой, так и без выборки. *Профайлер выборки* проверяет профиль на обычных таковых тиках, скажем, на 5 миллисекундах друг от друга. Профайлер, не вызывающий *выборку,* информируется о событии синхронно с потоком, который вызывает событие.

### <a name="unsupported-functionality"></a>Неподдерживаемые функциональные возможности

API профилирования не поддерживает следующие функциональные возможности.

- Неуправляемый код, который необходимо профилировать с помощью стандартных методов Win32. Однако профилировщик среды CLR включает события переходов для определения границ между управляемым и неуправляемым кодом.

- Самоизменяющиеся приложения, которые изменяют собственный код приложения, которые изменяют собственный код, например в целях аспектно-ориентированного программирования.

- Проверка привязок, поскольку API профилирования не предоставляет эти сведения. Среда CLR предоставляет существенную поддержку для проверки границ всего управляемого кода.

- Удаленное профилирование, которое не поддерживается по следующим причинам.

  - Удаленное профилирование увеличивает время выполнения. При использовании интерфейсов профилирования необходимо минимизировать время выполнения, чтобы оно не слишком сильно сказывалось на результатах профилирования. Это особенно важно при мониторинге производительности. Тем не менее удаленное профилирование не является ограничением при использовании интерфейсов профилирования для мониторинга использования памяти или для получения сведений времени выполнения о кадрах стека, объектах и т. п.

  - Профилировщик кода среды CLR должен зарегистрировать один или несколько интерфейсов обратного вызова в среде выполнения на локальном компьютере, на котором выполняется профилируемое приложение. Это ограничивает возможность создания удаленного профилировщика кода.

## <a name="notification-threads"></a>Потоки уведомлений

В большинстве случаев поток, который создает событие, также выполняет уведомления. Такие уведомления (например, [FunctionEnter](functionenter-function.md) и [FunctionLeave)](functionleave-function.md)не `ThreadID`должны поставлять явные . Кроме того, профилировщик может использовать локальное хранилище потока для хранения и обновления своих блоков анализа вместо индексирования этих блоков в глобальном хранилище на основе `ThreadID` затронутого потока.

Обратите внимание, что эти обратные вызовы не сериализуются. Пользователи должны защищать свой код, путем создания потокобезопасных структур данных и путем блокировки кода профилировщика в тех случаях, когда необходимо предотвратить параллельный доступ из нескольких потоков. Таким образом, в некоторых случаях можно получить необычную последовательность обратных вызовов. Например, предположим, что управляемое приложение порождает два потока, выполняющие идентичный код. В этом случае можно получить [ICorProfilerCallback::JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md) событие для некоторых функций из одного потока и обратный `FunctionEnter` вызов от другого потока до получения [ICorProfilerCallback::JITCompilationFinished](icorprofilercallback-jitcompilationfinished-method.md) обратный вызов. В этом случае пользователь получит обратный вызов `FunctionEnter` для функции, которая могла быть не полностью JIT-скомпилирована.

## <a name="security"></a>Безопасность

Библиотека DLL профилировщика — это неуправляемая библиотека DLL, которая выполняется в рамках подсистемы выполнения среды CLR. В результате на код в библиотеке DLL профилировщика DLL не налагаются ограничения управления доступом для управляемого кода. Для библиотеки DLL профилировщика действуют только ограничения, накладываемые операционной системой на пользователя, запускающего профилируемое приложение.

Разработчики профилировщика должны принять соответствующие меры предосторожности, чтобы избежать проблем, связанных с безопасностью. Например, во время установки библиотека DLL профилировщика должна добавляться в список управления доступом (ACL), чтобы злоумышленник не мог изменить ее.

## <a name="combining-managed-and-unmanaged-code-in-a-code-profiler"></a>Объединение управляемого и неуправляемого кода в коде профилировщика

Неправильно написанный профилировщик может вызвать циклические ссылки на себя, что приводит к непредсказуемому поведению.

Обзор API профилирования среды CLR может создать впечатление, что можно написать профилировщик, содержащий управляемые и неуправляемые компоненты, которые вызывают друг друга посредством COM-взаимодействия или непрямых вызовов.

Хотя это возможно с точки зрения проектирования, API профилирования не поддерживает управляемые компоненты. Профилировщик среды CLR должен быть полностью неуправляемым. Попытки объединить управляемый и неуправляемый код в профилировщике среды CLR могут привести к нарушениям прав доступа, сбоям программы или взаимоблокировкам. Управляемые компоненты профилировщика будут возвращать события обратно их неуправляемым компонентам, что будет затем вызывать управляемые компоненты снова, и таким образом будут создаваться циклические ссылки.

Единственное место, где профилировщик CLR может безопасно вызывать управляемый код, это текст MSIL в теле метода. Рекомендуемая практика для изменения тела MSIL заключается в использовании методов перекомпивания JIT в интерфейсе [ICorProfilerCallback4.](icorprofilercallback4-interface.md)

Кроме того, для изменения MSIL можно использовать старые методы инструментирования. Перед завершением компиляции функции (JIT) можно вставить управляемые вызовы в тело метода MSIL, а затем JIT-компилировать его (см. метод [ICorProfilerInfo::GetILFunctionBody).](icorprofilerinfo-getilfunctionbody-method.md) Этот способ можно успешно использовать для выборочного инструментирования управляемого кода или для сбора статистики и данных производительности касательно JIT.

Кроме того, профилировщик кода может вставлять собственные обработчики в текст MSIL любой управляемой функции, которая вызывает неуправляемый код. Этот способ можно использовать для инструментирования и покрытия. Например, профилировщик кода может вставить обработчики инструментирования после каждого блока MSIL для обеспечения выполнения блока. Изменение текста MSIL метода следует выполнять очень аккуратно и принимать во внимание множество факторов.

## <a name="profiling-unmanaged-code"></a>Профилирование неуправляемого кода

API профилирования среды CLR предоставляет минимальную поддержку профилирования неуправляемого кода. Предоставляются следующие функциональные возможности.

- Перечисление цепочек стека. Эта возможность позволяет профилировщику кода определить границу между управляемым и неуправляемым кодом.

- Определение, соответствует ли цепочка стека управляемому коду или машинному коду.

В .NET Framework версий 1.0 и 1.1 эти методы доступны через внутрипроцессное подмножество API отладки среды CLR. Они определяются в файле CorDebug.idl.

В рамках .NET 2.0 и позже, вы можете использовать [метод ICorProfilerInfo2::DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) для этой функциональности.

## <a name="using-com"></a>Использование модели COM

Хотя интерфейсы профилирования определяются как COM-интерфейсы, среда CLR в действительности не инициализирует модель COM для использования этих интерфейсов. Причина заключается в том, чтобы избежать необходимости установки модели потоков с помощью функции [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) до того, как управляемое приложение получило возможность указать желаемую модель потоков. Аналогично, сам профилировщик не должен вызывать `CoInitialize`, поскольку он может выбрать потоковую модель, несовместимую с профилируемым приложением, что может привести к сбою приложения.

## <a name="call-stacks"></a>Стеки вызовов

API профилирования предоставляет два способа получения стеков вызова: метод моментальных снимков стека, который позволяет реже выполнять сбор стеков вызовов, и метод теневого стека, который отслеживает стек вызовов в каждый момент времени.

### <a name="stack-snapshot"></a>Моментальный снимок стека

Моментальный снимок стека — это трассировка стека потока в момент времени. API профилирования поддерживает трассировку управляемых функций в стеке, но оставляет трассировку неуправляемых функций собственному обходчику стека профилировщика.

Для получения дополнительной информации о том, как запрограммировать профайлера ходить управляемых стеков, [см. ICorProfilerInfo2: :DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) метод в этом наборе документации, и [Профайлер Стек Ходьба в .NET Framework 2.0: Основы и за его пределами](https://docs.microsoft.com/previous-versions/dotnet/articles/bb264782(v=msdn.10)).

### <a name="shadow-stack"></a>Теневой стек

Слишком частое использование метода моментального снимка может быстро создавать проблемы производительности. Если вы хотите часто принимать следы стека, ваш профайлер должен вместо этого построить теневый стек с помощью [FunctionEnter2,](functionenter2-function.md) [FunctionLeave2,](functionleave2-function.md) [FunctionTailcall2](functiontailcall2-function.md)и [ICorProfilerCallback2](icorprofilercallback2-interface.md) исключения обратных вызовов. Теневой стек всегда является текущим, и его можно быстро скопировать в хранилище каждый раз, когда требуется моментальный снимок стека.

Теневой стек может получать аргументы функций, возвращать значения и сведения об универсальных экземплярах. Эти сведения доступны только посредством теневого стека и могут быть получены, когда управление передается в функцию. Однако эти сведения могут оказаться недоступны позднее, во время выполнения функции.

## <a name="callbacks-and-stack-depth"></a>Обратные вызовы и глубина стека вызовов

Обратные вызовы профилировщика могут осуществляться в условиях очень ограниченного стека, и переполнение стека в обратном вызове профилировщика приведет к немедленному завершению выполнения процесса. В ответ на обратные вызовы профилировщик должен гарантированно использовать минимально возможный стек. Если профилировщик предназначен для использования в процессах, устойчивых к переполнению стека, сам профилировщик должен также избегать активации переполнения стека.

## <a name="related-topics"></a>См. также

|Заголовок|Описание|
|-----------|-----------------|
|[Установка профилирующей среды](setting-up-a-profiling-environment.md)|В этом разделе объясняется, как можно инициализировать профилировщик, установить уведомления о событиях и профилировать службу Windows.|
|[Профилирующие интерфейсы](profiling-interfaces.md)|В этом разделе описываются неуправляемые интерфейсы, которые использует API профилирования.|
|[Глобальные статические функции профилирования](profiling-global-static-functions.md)|В этом разделе описываются неуправляемые глобальные статистические функции, которые использует API профилирования.|
|[Перечисления профилирования](profiling-enumerations.md)|В этом разделе описываются неуправляемые перечисления, которые использует API профилирования.|
|[Структуры профилирования](profiling-structures.md)|В этом разделе описываются неуправляемые структуры, которые использует API профилирования.|
