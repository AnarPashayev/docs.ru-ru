---
title: Разработка рабочих процессов, действий и выражений с помощью императивного кода
ms.date: 03/30/2017
ms.assetid: cefc9cfc-2882-4eb9-8c94-7a6da957f2b2
ms.openlocfilehash: 97f57067e72be2ed2fb6b3846e2ab876c13e049f
ms.sourcegitcommit: 32a575bf4adccc901f00e264f92b759ced633379
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/04/2019
ms.locfileid: "74802704"
---
# <a name="authoring-workflows-activities-and-expressions-using-imperative-code"></a><span data-ttu-id="e6360-102">Разработка рабочих процессов, действий и выражений с помощью императивного кода</span><span class="sxs-lookup"><span data-stu-id="e6360-102">Authoring Workflows, Activities, and Expressions Using Imperative Code</span></span>
<span data-ttu-id="e6360-103">Определение рабочего процесса представляет собой дерево настроенных объектов действий.</span><span class="sxs-lookup"><span data-stu-id="e6360-103">A workflow definition is a tree of configured activity objects.</span></span> <span data-ttu-id="e6360-104">Это дерево действий можно определить многими способами, включая редактирование XAML вручную и использование конструктора рабочих процессов для создания XAML.</span><span class="sxs-lookup"><span data-stu-id="e6360-104">This tree of activities can be defined many ways, including by hand-editing XAML or by using the Workflow Designer to produce XAML.</span></span> <span data-ttu-id="e6360-105">Но использование XAML не является обязательным.</span><span class="sxs-lookup"><span data-stu-id="e6360-105">Use of XAML, however, is not a requirement.</span></span> <span data-ttu-id="e6360-106">Определения рабочих процессов могут быть также созданы вручную.</span><span class="sxs-lookup"><span data-stu-id="e6360-106">Workflow definitions can also be created programmatically.</span></span> <span data-ttu-id="e6360-107">В этом разделе представлены общие сведения о создании определений, действий и выражений рабочего процесса с помощью кода.</span><span class="sxs-lookup"><span data-stu-id="e6360-107">This topic provides an overview of creating workflow definitions, activities, and expressions by using code.</span></span> <span data-ttu-id="e6360-108">Примеры работы с рабочими процессами XAML с помощью кода см. [в разделе Сериализация рабочих процессов и действий в XAML и обратно](serializing-workflows-and-activities-to-and-from-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="e6360-108">For examples of working with XAML workflows using code, see [Serializing Workflows and Activities to and from XAML](serializing-workflows-and-activities-to-and-from-xaml.md).</span></span>  
  
## <a name="creating-workflow-definitions"></a><span data-ttu-id="e6360-109">Создание определений рабочих процессов</span><span class="sxs-lookup"><span data-stu-id="e6360-109">Creating Workflow Definitions</span></span>  
 <span data-ttu-id="e6360-110">Определение рабочего процесса можно создать путем создания экземпляра типа действия и настройки свойств объекта действия.</span><span class="sxs-lookup"><span data-stu-id="e6360-110">A workflow definition can be created by instantiating an instance of an activity type and configuring the activity object’s properties.</span></span> <span data-ttu-id="e6360-111">Для действий, которые не содержат дочерних действий, определение можно создать программно с помощью нескольких строк кода.</span><span class="sxs-lookup"><span data-stu-id="e6360-111">For activities that do not contain child activities, this can be accomplished using a few lines of code.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#47](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#47)]  
  
> [!NOTE]
> <span data-ttu-id="e6360-112">В примерах этого раздела для запуска рабочих процессов образцов используется <xref:System.Activities.WorkflowInvoker>.</span><span class="sxs-lookup"><span data-stu-id="e6360-112">The examples in this topic use <xref:System.Activities.WorkflowInvoker> to run the sample workflows.</span></span> <span data-ttu-id="e6360-113">Дополнительные сведения о вызове рабочих процессов, передаче аргументов и различных доступных вариантах размещения см. в разделе [использование WorkflowInvoker и WorkflowApplication](using-workflowinvoker-and-workflowapplication.md).</span><span class="sxs-lookup"><span data-stu-id="e6360-113">For more information about invoking workflows, passing arguments, and the different hosting choices that are available, see [Using WorkflowInvoker and WorkflowApplication](using-workflowinvoker-and-workflowapplication.md).</span></span>  
  
 <span data-ttu-id="e6360-114">В этом примере создается рабочий процесс, состоящий из одного действия <xref:System.Activities.Statements.WriteLine>.</span><span class="sxs-lookup"><span data-stu-id="e6360-114">In this example, a workflow that consists of a single <xref:System.Activities.Statements.WriteLine> activity is created.</span></span> <span data-ttu-id="e6360-115">Задается аргумент <xref:System.Activities.Statements.WriteLine> действия <xref:System.Activities.Statements.WriteLine.Text%2A> и выполняется вызов рабочего процесса.</span><span class="sxs-lookup"><span data-stu-id="e6360-115">The <xref:System.Activities.Statements.WriteLine> activity’s <xref:System.Activities.Statements.WriteLine.Text%2A> argument is set, and the workflow is invoked.</span></span> <span data-ttu-id="e6360-116">Если в действии содержатся дочерние действия, то используется аналогичный метод построения.</span><span class="sxs-lookup"><span data-stu-id="e6360-116">If an activity contains child activities, the method of construction is similar.</span></span> <span data-ttu-id="e6360-117">В следующем примере используется действие <xref:System.Activities.Statements.Sequence>, которое содержит два действия <xref:System.Activities.Statements.WriteLine>.</span><span class="sxs-lookup"><span data-stu-id="e6360-117">The following example uses a <xref:System.Activities.Statements.Sequence> activity that contains two <xref:System.Activities.Statements.WriteLine> activities.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#48](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#48)]  
  
### <a name="using-object-initializers"></a><span data-ttu-id="e6360-118">Использование инициализаторов объектов</span><span class="sxs-lookup"><span data-stu-id="e6360-118">Using Object Initializers</span></span>  
 <span data-ttu-id="e6360-119">В примерах в этом разделе используется синтаксис инициализации объектов.</span><span class="sxs-lookup"><span data-stu-id="e6360-119">The examples in this topic use object initialization syntax.</span></span> <span data-ttu-id="e6360-120">Синтаксис инициализации объектов можно использовать для создания определений рабочих процессов в коде, поскольку он обеспечивает иерархическое представление действий в рабочем процессе и показывает связи между действиями.</span><span class="sxs-lookup"><span data-stu-id="e6360-120">Object initialization syntax can be a useful way to create workflow definitions in code because it provides a hierarchical view of the activities in the workflow and shows the relationship between the activities.</span></span> <span data-ttu-id="e6360-121">При программном создании рабочих процессов нет необходимости использовать синтаксис инициализации объектов.</span><span class="sxs-lookup"><span data-stu-id="e6360-121">There is no requirement to use object initialization syntax when you programmatically create workflows.</span></span> <span data-ttu-id="e6360-122">Следующий пример функционально эквивалентен предыдущему примеру.</span><span class="sxs-lookup"><span data-stu-id="e6360-122">The following example is functionally equivalent to the previous example.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#49](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#49)]  
  
 <span data-ttu-id="e6360-123">Дополнительные сведения об инициализаторах объектов см. [в разделе как инициализировать объекты без вызова конструктора (C# руководство по программированию)](../../csharp/programming-guide/classes-and-structs/how-to-initialize-objects-by-using-an-object-initializer.md) и [как объявить объект с помощью инициализатора объекта](../../visual-basic/programming-guide/language-features/objects-and-classes/how-to-declare-an-object-by-using-an-object-initializer.md).</span><span class="sxs-lookup"><span data-stu-id="e6360-123">For more information about object initializers, see [How to: Initialize Objects without Calling a Constructor (C# Programming Guide)](../../csharp/programming-guide/classes-and-structs/how-to-initialize-objects-by-using-an-object-initializer.md) and [How to: Declare an Object by Using an Object Initializer](../../visual-basic/programming-guide/language-features/objects-and-classes/how-to-declare-an-object-by-using-an-object-initializer.md).</span></span>  
  
### <a name="working-with-variables-literal-values-and-expressions"></a><span data-ttu-id="e6360-124">Работа с переменными, литеральными значениями и выражениями</span><span class="sxs-lookup"><span data-stu-id="e6360-124">Working with Variables, Literal Values, and Expressions</span></span>  
 <span data-ttu-id="e6360-125">При создании определения рабочего процесса с помощью кода необходимо помнить, какая часть кода выполняется как часть создания определения рабочего процесса и какая часть кода выполняется как часть выполнения экземпляра рабочего процесса.</span><span class="sxs-lookup"><span data-stu-id="e6360-125">When creating a workflow definition using code, be aware of what code executes as part of the creation of the workflow definition and what code executes as part of the execution of an instance of that workflow.</span></span> <span data-ttu-id="e6360-126">Например, следующий рабочий процесс должен создавать случайное число и записывать его в консоль.</span><span class="sxs-lookup"><span data-stu-id="e6360-126">For example, the following workflow is intended to generate a random number and write it to the console.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#50](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#50)]  
  
 <span data-ttu-id="e6360-127">После выполнения кода определения рабочего процесса происходит вызов `Random.Next` и результат сохраняется в определении рабочего процесса как литеральное значение.</span><span class="sxs-lookup"><span data-stu-id="e6360-127">When this workflow definition code is executed, the call to `Random.Next` is made and the result is stored in the workflow definition as a literal value.</span></span> <span data-ttu-id="e6360-128">Можно вызвать несколько экземпляров этого рабочего процесса, при этом все они отобразят одно и то же число.</span><span class="sxs-lookup"><span data-stu-id="e6360-128">Many instances of this workflow can be invoked, and all would display the same number.</span></span> <span data-ttu-id="e6360-129">Чтобы обеспечить создание случайного числа во время выполнения рабочего процесса, необходимо использовать выражение, которое вычисляется при каждом запуске рабочего процесса.</span><span class="sxs-lookup"><span data-stu-id="e6360-129">To have the random number generation occur during workflow execution, an expression must be used that is evaluated each time the workflow runs.</span></span> <span data-ttu-id="e6360-130">В следующем примере выражение Visual Basic используется вместе с <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601>.</span><span class="sxs-lookup"><span data-stu-id="e6360-130">In the following example, a Visual Basic expression is used with a <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601>.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#51](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#51)]  
  
 <span data-ttu-id="e6360-131">Выражение из предыдущего примера также могло быть реализовано с помощью выражения <xref:Microsoft.CSharp.Activities.CSharpValue%601> и выражения C#.</span><span class="sxs-lookup"><span data-stu-id="e6360-131">The expression in the previous example could also be implemented using a <xref:Microsoft.CSharp.Activities.CSharpValue%601> and a C# expression.</span></span>  
  
```csharp  
new Assign<int>  
{  
    To = n,  
    Value = new CSharpValue<int>("new Random().Next(1, 101)")  
}  
```  
  
 <span data-ttu-id="e6360-132">Выражения C# необходимо компилировать до того, как будет вызван рабочий процесс, содержащий их.</span><span class="sxs-lookup"><span data-stu-id="e6360-132">C# expressions must be compiled before the workflow containing them is invoked.</span></span> <span data-ttu-id="e6360-133">Если выражения C# не компилируются, выдается метод <xref:System.NotSupportedException>, когда рабочий процесс вызывается с помощью сообщения следующего вида: ``Expression Activity type 'CSharpValue`1' requires compilation in order to run.  Please ensure that the workflow has been compiled.`` В большинстве сценариев вызова рабочих процессов, созданных в Visual Studio, выражения C# компилируются автоматически, но в определенных случаях, например для рабочих процессов кода, выражения C# необходимо скомпилировать вручную.</span><span class="sxs-lookup"><span data-stu-id="e6360-133">If the C# expressions are not compiled, a <xref:System.NotSupportedException> is thrown when the workflow is invoked with a message similar to the following: ``Expression Activity type 'CSharpValue`1' requires compilation in order to run.  Please ensure that the workflow has been compiled.`` In most scenarios involving workflows created in Visual Studio the C# expressions are compiled automatically, but in some scenarios, such as code workflows, the C# expressions must be manually compiled.</span></span> <span data-ttu-id="e6360-134">Пример компиляции C# выражений см. в разделе [ C# использование выражений в рабочих процессах кода](csharp-expressions.md#CodeWorkflows) в разделе [ C# выражения](csharp-expressions.md) .</span><span class="sxs-lookup"><span data-stu-id="e6360-134">For an example of how to compile C# expressions, see the [Using C# expressions in code workflows](csharp-expressions.md#CodeWorkflows) section of the [C# Expressions](csharp-expressions.md) topic.</span></span>  
  
 <span data-ttu-id="e6360-135"><xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> представляет выражение в синтаксисе Visual Basic, которое может быть использовано в качестве правостороннего значения в выражении, а <xref:Microsoft.CSharp.Activities.CSharpValue%601> представляет выражение в синтаксисе Visual C#, которое может быть использовано в качестве правостороннего значения в выражении.</span><span class="sxs-lookup"><span data-stu-id="e6360-135">A <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> represents an expression in Visual Basic syntax that can be used as an r-value in an expression, and a <xref:Microsoft.CSharp.Activities.CSharpValue%601> represents an expression in C# syntax that can be used as an r-value in an expression.</span></span> <span data-ttu-id="e6360-136">Значения этих выражений вычисляются каждый раз при выполнении содержащего их действия.</span><span class="sxs-lookup"><span data-stu-id="e6360-136">These expressions are evaluated each time the containing activity is executed.</span></span> <span data-ttu-id="e6360-137">Результат выражения назначается переменной рабочего процесса `n`, и эти результаты используются следующим действием в рабочем процессе.</span><span class="sxs-lookup"><span data-stu-id="e6360-137">The result of the expression is assigned to the workflow variable `n`, and these results are used by the next activity in the workflow.</span></span> <span data-ttu-id="e6360-138">Для получения доступа к значению переменной рабочего процесса `n` во время выполнения необходим контекст <xref:System.Activities.ActivityContext>.</span><span class="sxs-lookup"><span data-stu-id="e6360-138">To access the value of the workflow variable `n` at runtime, the <xref:System.Activities.ActivityContext> is required.</span></span> <span data-ttu-id="e6360-139">Доступ может быть получен с помощью следующего лямбда-выражения.</span><span class="sxs-lookup"><span data-stu-id="e6360-139">This can be accessed by using the following lambda expression.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e6360-140">Обратите внимание, что в обоих примерах используется код на языке C#, но в одном используется <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601>, а во втором - <xref:Microsoft.CSharp.Activities.CSharpValue%601>.</span><span class="sxs-lookup"><span data-stu-id="e6360-140">Note that both of these code are examples are using C# as the programming language, but one uses a <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> and one uses a <xref:Microsoft.CSharp.Activities.CSharpValue%601>.</span></span> <span data-ttu-id="e6360-141"><xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> и <xref:Microsoft.CSharp.Activities.CSharpValue%601> могут использоваться в проектах Visual Basic и C#.</span><span class="sxs-lookup"><span data-stu-id="e6360-141"><xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> and <xref:Microsoft.CSharp.Activities.CSharpValue%601> can be used in both Visual Basic and C# projects.</span></span> <span data-ttu-id="e6360-142">По умолчанию выражения, созданные в конструкторе рабочих процессов, соответствуют языку проекта для размещения.</span><span class="sxs-lookup"><span data-stu-id="e6360-142">By default, expressions created in the workflow designer match the language of the hosting project.</span></span> <span data-ttu-id="e6360-143">При создании рабочих процессов в коде выбор языка остается за автором рабочего процесса.</span><span class="sxs-lookup"><span data-stu-id="e6360-143">When creating workflows in code, the desired language is at the discretion of the workflow author.</span></span>  
  
 <span data-ttu-id="e6360-144">В этих примерах результат выражения назначается переменной рабочего процесса `n` и эти результаты используются следующим действием в рабочем процессе.</span><span class="sxs-lookup"><span data-stu-id="e6360-144">In these examples the result of the expression is assigned to the workflow variable `n`, and these results are used by the next activity in the workflow.</span></span> <span data-ttu-id="e6360-145">Для получения доступа к значению переменной рабочего процесса `n` во время выполнения необходим контекст <xref:System.Activities.ActivityContext>.</span><span class="sxs-lookup"><span data-stu-id="e6360-145">To access the value of the workflow variable `n` at runtime, the <xref:System.Activities.ActivityContext> is required.</span></span> <span data-ttu-id="e6360-146">Доступ может быть получен с помощью следующего лямбда-выражения.</span><span class="sxs-lookup"><span data-stu-id="e6360-146">This can be accessed by using the following lambda expression.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#52](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#52)]  
  
 <span data-ttu-id="e6360-147">Дополнительные сведения о лямбда-выражениях см. в разделе [лямбда-выражения (C# руководством по программированию)](../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md) или [лямбда-выражения (Visual Basic)](../../visual-basic/programming-guide/language-features/procedures/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="e6360-147">For more information about lambda expressions, see [Lambda Expressions (C# Programming Guide)](../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md) or [Lambda Expressions (Visual Basic)](../../visual-basic/programming-guide/language-features/procedures/lambda-expressions.md).</span></span>  
  
 <span data-ttu-id="e6360-148">Лямбда-выражения не могут быть сериализованы в формат XAML.</span><span class="sxs-lookup"><span data-stu-id="e6360-148">Lambda expressions are not serializable to XAML format.</span></span> <span data-ttu-id="e6360-149">При попытке сериализовать рабочий процесс лямбда-выражениями возникает исключение <xref:System.Activities.Expressions.LambdaSerializationException> со следующим сообщением: «Этот рабочий процесс содержит указанные в коде лямбда-выражения.</span><span class="sxs-lookup"><span data-stu-id="e6360-149">If an attempt to serialize a workflow with lambda expressions is made, a <xref:System.Activities.Expressions.LambdaSerializationException> is thrown with the following message: "This workflow contains lambda expressions specified in code.</span></span> <span data-ttu-id="e6360-150">Эти выражения XAML-несериализуемы.</span><span class="sxs-lookup"><span data-stu-id="e6360-150">These expressions are not XAML serializable.</span></span> <span data-ttu-id="e6360-151">Чтобы сделать рабочий процесс XAML-сериализуемым, используйте или VisualBasicValue/VisualBasicReference, или ExpressionServices.Convert(lambda).</span><span class="sxs-lookup"><span data-stu-id="e6360-151">In order to make your workflow XAML-serializable, either use VisualBasicValue/VisualBasicReference or ExpressionServices.Convert(lambda).</span></span> <span data-ttu-id="e6360-152">При этом лямбда-выражения будут преобразованы в действия выражений».</span><span class="sxs-lookup"><span data-stu-id="e6360-152">This will convert your lambda expressions into expression activities."</span></span> <span data-ttu-id="e6360-153">Чтобы обеспечить совместимость этого выражения с XAML, используйте <xref:System.Activities.Expressions.ExpressionServices> и <xref:System.Activities.Expressions.ExpressionServices.Convert%2A>, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="e6360-153">To make this expression compatible with XAML, use <xref:System.Activities.Expressions.ExpressionServices> and <xref:System.Activities.Expressions.ExpressionServices.Convert%2A>, as shown in the following example.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#53](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#53)]  
  
 <span data-ttu-id="e6360-154">Можно также использовать <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601>.</span><span class="sxs-lookup"><span data-stu-id="e6360-154">A <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> could also be used.</span></span> <span data-ttu-id="e6360-155">Обратите внимание, что при использовании выражений Visual Basic можно обойтись без лямбда-выражений.</span><span class="sxs-lookup"><span data-stu-id="e6360-155">Note that no lambda expression is required when using a Visual Basic expression.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#54](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#54)]  
  
 <span data-ttu-id="e6360-156">Во время выполнения выражения Visual Basic компилируются в выражения LINQ.</span><span class="sxs-lookup"><span data-stu-id="e6360-156">At run time, Visual Basic expressions are compiled into LINQ expressions.</span></span> <span data-ttu-id="e6360-157">Оба приведенных примера сериализуются в языке XAML, однако, если сериализованный язык XAML должен просматриваться и изменяться в конструкторе рабочих процессов, используйте для выражений <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601>.</span><span class="sxs-lookup"><span data-stu-id="e6360-157">Both of the previous examples are serializable to XAML, but if the serialized XAML is intended to be viewed and edited in the workflow designer, use <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> for your expressions.</span></span> <span data-ttu-id="e6360-158">Сериализованные рабочие процессы, использующие `ExpressionServices.Convert`, могут быть открыты в конструкторе, но значение выражения будет пустым.</span><span class="sxs-lookup"><span data-stu-id="e6360-158">Serialized workflows that use `ExpressionServices.Convert` can be opened in the designer, but the value of the expression will be blank.</span></span> <span data-ttu-id="e6360-159">Дополнительные сведения о сериализации рабочих процессов в XAML см. [в разделе Сериализация рабочих процессов и действий в XAML и обратно](serializing-workflows-and-activities-to-and-from-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="e6360-159">For more information about serializing workflows to XAML, see [Serializing Workflows and Activities to and from XAML](serializing-workflows-and-activities-to-and-from-xaml.md).</span></span>  
  
#### <a name="literal-expressions-and-reference-types"></a><span data-ttu-id="e6360-160">Литеральные выражения и ссылочные типы</span><span class="sxs-lookup"><span data-stu-id="e6360-160">Literal Expressions and Reference Types</span></span>  
 <span data-ttu-id="e6360-161">Литеральные выражения представляются действием <xref:System.Activities.Expressions.Literal%601> в рабочем процессе.</span><span class="sxs-lookup"><span data-stu-id="e6360-161">Literal expressions are represented in workflows by the <xref:System.Activities.Expressions.Literal%601> activity.</span></span> <span data-ttu-id="e6360-162">Следующие действия <xref:System.Activities.Statements.WriteLine> функционально эквивалентны.</span><span class="sxs-lookup"><span data-stu-id="e6360-162">The following <xref:System.Activities.Statements.WriteLine> activities are functionally equivalent.</span></span>  
  
```csharp  
new WriteLine  
{  
    Text = "Hello World."  
},  
new WriteLine  
{  
    Text = new Literal<string>("Hello World.")  
}  
```  
  
 <span data-ttu-id="e6360-163">Недопустимо инициализировать литеральное выражение любым ссылочным типом, за исключением <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="e6360-163">It is invalid to initialize a literal expression with any reference type except <xref:System.String>.</span></span> <span data-ttu-id="e6360-164">В следующем примере свойство <xref:System.Activities.Statements.Assign> действия <xref:System.Activities.Statements.Assign.Value%2A> инициализируется литеральным выражением с помощью `List<string>`.</span><span class="sxs-lookup"><span data-stu-id="e6360-164">In the following example, an <xref:System.Activities.Statements.Assign> activity's <xref:System.Activities.Statements.Assign.Value%2A> property is initialized with a literal expression using a `List<string>`.</span></span>  
  
```csharp  
new Assign  
{  
    To = new OutArgument<List<string>>(items),  
    Value = new InArgument<List<string>>(new List<string>())  
},  
```  
  
 <span data-ttu-id="e6360-165">Когда рабочий процесс, содержащий это действие, проверяется, возникает следующая ошибка проверки: «Литералы поддерживают лишь типы значений и неизменяемый тип System.String.</span><span class="sxs-lookup"><span data-stu-id="e6360-165">When the workflow containing this activity is validated, the following validation error is returned: "Literal only supports value types and the immutable type System.String.</span></span> <span data-ttu-id="e6360-166">Тип System.Collections.Generic.List\`1[System.String] нельзя использовать в качестве литерала».</span><span class="sxs-lookup"><span data-stu-id="e6360-166">The type System.Collections.Generic.List\`1[System.String] cannot be used as a literal."</span></span> <span data-ttu-id="e6360-167">Если вызывается рабочий процесс, появляется уведомление <xref:System.Activities.InvalidWorkflowException>, содержащее сообщение об ошибке проверки.</span><span class="sxs-lookup"><span data-stu-id="e6360-167">If the workflow is invoked, an <xref:System.Activities.InvalidWorkflowException> is thrown that contains the text of the validation error.</span></span> <span data-ttu-id="e6360-168">Это ошибка проверки, поскольку при создании литерального выражения со ссылочным типом не создается новый экземпляр ссылочного типа для каждого из экземпляров рабочего процесса.</span><span class="sxs-lookup"><span data-stu-id="e6360-168">This is a validation error because creating a literal expression with a reference type does not create a new instance of the reference type for each instance of the workflow.</span></span> <span data-ttu-id="e6360-169">Чтобы устранить эту проблему, замените литеральное выражение таким, которое создает и возвращает новый экземпляр ссылочного типа.</span><span class="sxs-lookup"><span data-stu-id="e6360-169">To resolve this, replace the literal expression with one that creates and returns a new instance of the reference type.</span></span>  
  
```csharp  
new Assign  
{  
    To = new OutArgument<List<string>>(items),  
    Value = new InArgument<List<string>>(new VisualBasicValue<List<string>>("New List(Of String)"))  
},  
```  
  
 <span data-ttu-id="e6360-170">Дополнительные сведения о выражениях см. в разделе [выражения](expressions.md).</span><span class="sxs-lookup"><span data-stu-id="e6360-170">For more information about expressions, see [Expressions](expressions.md).</span></span>  
  
#### <a name="invoking-methods-on-objects-using-expressions-and-the-invokemethod-activity"></a><span data-ttu-id="e6360-171">Вызов методов в объектах с помощью выражений и действия InvokeMethod</span><span class="sxs-lookup"><span data-stu-id="e6360-171">Invoking Methods on Objects using Expressions and the InvokeMethod Activity</span></span>  
 <span data-ttu-id="e6360-172">Действие <xref:System.Activities.Expressions.InvokeMethod%601> можно использовать для вызова статических методов и методов экземпляров классов в платформе .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="e6360-172">The <xref:System.Activities.Expressions.InvokeMethod%601> activity can be used to invoke static and instance methods of classes in the .NET Framework.</span></span> <span data-ttu-id="e6360-173">В предыдущем примере этого раздела случайное число было создано с помощью класса <xref:System.Random>.</span><span class="sxs-lookup"><span data-stu-id="e6360-173">In a previous example in this topic, a random number was generated using the <xref:System.Random> class.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#51](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#51)]  
  
 <span data-ttu-id="e6360-174">Действие <xref:System.Activities.Expressions.InvokeMethod%601> может также использоваться для вызова метода <xref:System.Random.Next%2A> класса <xref:System.Random>.</span><span class="sxs-lookup"><span data-stu-id="e6360-174">The <xref:System.Activities.Expressions.InvokeMethod%601> activity could also have been used to call the <xref:System.Random.Next%2A> method of the <xref:System.Random> class.</span></span>  
  
```csharp  
new InvokeMethod<int>  
{  
    TargetObject = new InArgument<Random>(new VisualBasicValue<Random>("New Random()")),  
    MethodName = "Next",  
    Parameters =   
    {  
        new InArgument<int>(1),  
        new InArgument<int>(101)  
    },  
    Result = n  
}  
```  
  
 <span data-ttu-id="e6360-175">Поскольку <xref:System.Random.Next%2A> не статический метод, предоставляется экземпляр класса <xref:System.Random> для свойства <xref:System.Activities.Expressions.InvokeMethod%601.TargetObject%2A>.</span><span class="sxs-lookup"><span data-stu-id="e6360-175">Since <xref:System.Random.Next%2A> is not a static method, an instance of the <xref:System.Random> class is supplied for the <xref:System.Activities.Expressions.InvokeMethod%601.TargetObject%2A> property.</span></span> <span data-ttu-id="e6360-176">В этом примере создается новый экземпляр класса с использованием выражения Visual Basic, но он мог быть также создан ранее и сохранен в переменной рабочего процесса.</span><span class="sxs-lookup"><span data-stu-id="e6360-176">In this example a new instance is created using a Visual Basic expression, but it could also have been created previously and stored in a workflow variable.</span></span> <span data-ttu-id="e6360-177">В этом примере будет проще использовать действие <xref:System.Activities.Statements.Assign%601> вместо действия <xref:System.Activities.Expressions.InvokeMethod%601>.</span><span class="sxs-lookup"><span data-stu-id="e6360-177">In this example, it would be simpler to use the <xref:System.Activities.Statements.Assign%601> activity instead of the <xref:System.Activities.Expressions.InvokeMethod%601> activity.</span></span> <span data-ttu-id="e6360-178">Если вызов метода, в конечном счете осуществляемый действием <xref:System.Activities.Statements.Assign%601> или действием <xref:System.Activities.Expressions.InvokeMethod%601>, является долго выполняющимся, преимущество имеет <xref:System.Activities.Expressions.InvokeMethod%601> за счет наличия свойства <xref:System.Activities.Expressions.InvokeMethod%601.RunAsynchronously%2A>.</span><span class="sxs-lookup"><span data-stu-id="e6360-178">If the method call ultimately invoked by either the <xref:System.Activities.Statements.Assign%601> or <xref:System.Activities.Expressions.InvokeMethod%601> activities is long running, <xref:System.Activities.Expressions.InvokeMethod%601> has an advantage since it has a <xref:System.Activities.Expressions.InvokeMethod%601.RunAsynchronously%2A> property.</span></span> <span data-ttu-id="e6360-179">Если это свойство имеет значение `true`, вызванный метод работает асинхронно относительно рабочего процесса.</span><span class="sxs-lookup"><span data-stu-id="e6360-179">When this property is set to `true`, the invoked method will run asynchronously with regard to the workflow.</span></span> <span data-ttu-id="e6360-180">Если параллельно работают другие действия, они не будут заблокированы, пока метод выполняется асинхронно.</span><span class="sxs-lookup"><span data-stu-id="e6360-180">If other activities are in parallel, they will not be blocked while the method is asynchronously executing.</span></span> <span data-ttu-id="e6360-181">Кроме того, если вызываемый метод не имеет возвращаемого значения, то для его вызова подойдет <xref:System.Activities.Expressions.InvokeMethod%601>.</span><span class="sxs-lookup"><span data-stu-id="e6360-181">Also, if the method to be invoked has no return value, then <xref:System.Activities.Expressions.InvokeMethod%601> is the appropriate way to invoke the method.</span></span>  
  
## <a name="arguments-and-dynamic-activities"></a><span data-ttu-id="e6360-182">Аргументы и динамические действия</span><span class="sxs-lookup"><span data-stu-id="e6360-182">Arguments and Dynamic Activities</span></span>  
 <span data-ttu-id="e6360-183">Определение рабочего процесса создается в коде путем сборки действий в дерево действий и настройки всех свойств и аргументов.</span><span class="sxs-lookup"><span data-stu-id="e6360-183">A workflow definition is created in code by assembling activities into an activity tree and configuring any properties and arguments.</span></span> <span data-ttu-id="e6360-184">Для существующих аргументов можно выполнить привязку, но новые аргументы нельзя добавить к действиям.</span><span class="sxs-lookup"><span data-stu-id="e6360-184">Existing arguments can be bound, but new arguments cannot be added to activities.</span></span> <span data-ttu-id="e6360-185">Сюда относятся аргументы рабочего процесса, передаваемые корневому действию.</span><span class="sxs-lookup"><span data-stu-id="e6360-185">This includes workflow arguments passed to the root activity.</span></span> <span data-ttu-id="e6360-186">В императивном коде аргументы рабочего процесса указываются как свойства для нового CLR-типа, а в XAML они объявляются с помощью `x:Class` и `x:Member`.</span><span class="sxs-lookup"><span data-stu-id="e6360-186">In imperative code, workflow arguments are specified as properties on a new CLR type, and in XAML they are declared by using `x:Class` and `x:Member`.</span></span> <span data-ttu-id="e6360-187">Поскольку при создании определения рабочего процесса как дерева объектов, содержащихся в памяти, не создается нового CLR-типа, аргументы не могут быть добавлены.</span><span class="sxs-lookup"><span data-stu-id="e6360-187">Because there is no new CLR type created when a workflow definition is created as a tree of in-memory objects, arguments cannot be added.</span></span> <span data-ttu-id="e6360-188">Однако аргументы могут быть добавлены к <xref:System.Activities.DynamicActivity>.</span><span class="sxs-lookup"><span data-stu-id="e6360-188">However, arguments can be added to a <xref:System.Activities.DynamicActivity>.</span></span> <span data-ttu-id="e6360-189">В этом примере создается действие <xref:System.Activities.DynamicActivity%601>, которое принимает и складывает два целочисленных аргумента и возвращает результат.</span><span class="sxs-lookup"><span data-stu-id="e6360-189">In this example, a <xref:System.Activities.DynamicActivity%601> is created that takes two integer arguments, adds them together, and returns the result.</span></span> <span data-ttu-id="e6360-190">Для каждого аргумента создается свойство <xref:System.Activities.DynamicActivityProperty>, результат операции присваивается аргументу <xref:System.Activities.Activity%601.Result%2A> действия <xref:System.Activities.DynamicActivity%601>.</span><span class="sxs-lookup"><span data-stu-id="e6360-190">A <xref:System.Activities.DynamicActivityProperty> is created for each argument, and the result of the operation is assigned to the <xref:System.Activities.Activity%601.Result%2A> argument of the <xref:System.Activities.DynamicActivity%601>.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#55](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#55)]  
  
 <span data-ttu-id="e6360-191">Дополнительные сведения о динамических действиях см. [в разделе Создание действия во время выполнения](creating-an-activity-at-runtime-with-dynamicactivity.md).</span><span class="sxs-lookup"><span data-stu-id="e6360-191">For more information about dynamic activities, see [Creating an Activity at Runtime](creating-an-activity-at-runtime-with-dynamicactivity.md).</span></span>  
  
## <a name="compiled-activities"></a><span data-ttu-id="e6360-192">Скомпилированные действия</span><span class="sxs-lookup"><span data-stu-id="e6360-192">Compiled Activities</span></span>  
 <span data-ttu-id="e6360-193">Динамические действия - это один из способов определить действие, которое содержит аргументы в коде, но действия также можно создавать в коде и компилировать в типы.</span><span class="sxs-lookup"><span data-stu-id="e6360-193">Dynamic activities are one way to define an activity that contains arguments using code, but activities can also be created in code and compiled into types.</span></span> <span data-ttu-id="e6360-194">Можно создавать простые действия, производные от класса <xref:System.Activities.CodeActivity>, и асинхронные действия, производные от класса <xref:System.Activities.AsyncCodeActivity>.</span><span class="sxs-lookup"><span data-stu-id="e6360-194">Simple activities can be created that derive from <xref:System.Activities.CodeActivity>, and asynchronous activities that derive from <xref:System.Activities.AsyncCodeActivity>.</span></span> <span data-ttu-id="e6360-195">Эти действия могут иметь аргументы и возвращаемые значения и задают логику с помощью императивного кода.</span><span class="sxs-lookup"><span data-stu-id="e6360-195">These activities can have arguments, return values, and define their logic using imperative code.</span></span> <span data-ttu-id="e6360-196">Примеры создания таких типов действий см. в статьях [базовый класс CodeActivity](workflow-activity-authoring-using-the-codeactivity-class.md) и [Создание асинхронных действий](creating-asynchronous-activities-in-wf.md).</span><span class="sxs-lookup"><span data-stu-id="e6360-196">For examples of creating these types of activities, see [CodeActivity Base Class](workflow-activity-authoring-using-the-codeactivity-class.md) and [Creating Asynchronous Activities](creating-asynchronous-activities-in-wf.md).</span></span>  
  
 <span data-ttu-id="e6360-197">Действия, производные от <xref:System.Activities.NativeActivity>, могут определять свою логику с помощью императивного кода и содержать дочерние действия, определяющие логику.</span><span class="sxs-lookup"><span data-stu-id="e6360-197">Activities that derive from <xref:System.Activities.NativeActivity> can define their logic using imperative code and they can also contain child activities that define the logic.</span></span> <span data-ttu-id="e6360-198">Кроме того, они имеют полный доступ к возможностям среды выполнения, таким как создание закладок.</span><span class="sxs-lookup"><span data-stu-id="e6360-198">They also have full access to the features of the runtime such as creating bookmarks.</span></span> <span data-ttu-id="e6360-199">Примеры создания действия на основе <xref:System.Activities.NativeActivity>см. в разделе [базовый класс NativeActivity](nativeactivity-base-class.md), [инструкции: Создание действия](how-to-create-an-activity.md)и пример [пользовательской составной модели с использованием собственного действия](./samples/custom-composite-using-native-activity.md) .</span><span class="sxs-lookup"><span data-stu-id="e6360-199">For examples of creating a <xref:System.Activities.NativeActivity>-based activity, see [NativeActivity Base Class](nativeactivity-base-class.md), [How to: Create an Activity](how-to-create-an-activity.md), and the [Custom Composite using Native Activity](./samples/custom-composite-using-native-activity.md) sample.</span></span>  
  
 <span data-ttu-id="e6360-200">Действия, производные от <xref:System.Activities.Activity>, задают логику исключительно с помощью дочерних действий.</span><span class="sxs-lookup"><span data-stu-id="e6360-200">Activities that derive from <xref:System.Activities.Activity> define their logic solely through the use of child activities.</span></span> <span data-ttu-id="e6360-201">Эти действия обычно создаются с помощью конструктора рабочих процессов, а также могут быть заданы с помощью кода.</span><span class="sxs-lookup"><span data-stu-id="e6360-201">These activities are typically created by using the workflow designer, but can also be defined by using code.</span></span> <span data-ttu-id="e6360-202">В следующем примере определяется действие `Square`, являющееся производным от `Activity<int>`.</span><span class="sxs-lookup"><span data-stu-id="e6360-202">In the following example, a `Square` activity is defined that derives from `Activity<int>`.</span></span> <span data-ttu-id="e6360-203">Действие `Square` содержит класс <xref:System.Activities.InArgument%601> с именем `Value` и задает его логику, указав действие <xref:System.Activities.Statements.Sequence> с помощью свойства <xref:System.Activities.Activity.Implementation%2A>.</span><span class="sxs-lookup"><span data-stu-id="e6360-203">The `Square` activity has a single <xref:System.Activities.InArgument%601> named `Value`, and defines its logic by specifying a <xref:System.Activities.Statements.Sequence> activity using the <xref:System.Activities.Activity.Implementation%2A> property.</span></span> <span data-ttu-id="e6360-204">Действие <xref:System.Activities.Statements.Sequence> содержит действие <xref:System.Activities.Statements.WriteLine> и действие <xref:System.Activities.Statements.Assign%601>.</span><span class="sxs-lookup"><span data-stu-id="e6360-204">The <xref:System.Activities.Statements.Sequence> activity contains a <xref:System.Activities.Statements.WriteLine> activity and an <xref:System.Activities.Statements.Assign%601> activity.</span></span> <span data-ttu-id="e6360-205">Совместно эти три действия реализуют логику действия `Square`.</span><span class="sxs-lookup"><span data-stu-id="e6360-205">Together, these three activities implement the logic of the `Square` activity.</span></span>  
  
```csharp  
class Square : Activity<int>  
{  
    [RequiredArgument]  
    public InArgument<int> Value { get; set; }  
  
    public Square()  
    {  
        this.Implementation = () => new Sequence  
        {  
            Activities =  
            {  
                new WriteLine  
                {  
                    Text = new InArgument<string>((env) => "Squaring the value: " + this.Value.Get(env))  
                },  
                new Assign<int>  
                {  
                    To = new OutArgument<int>((env) => this.Result.Get(env)),  
                    Value = new InArgument<int>((env) => this.Value.Get(env) * this.Value.Get(env))  
                }  
            }  
        };  
    }  
}  
```  
  
 <span data-ttu-id="e6360-206">В следующем примере вызывается определение рабочего процесса, состоящего из одного действия `Square`, с помощью метода <xref:System.Activities.WorkflowInvoker>.</span><span class="sxs-lookup"><span data-stu-id="e6360-206">In the following example, a workflow definition consisting of a single `Square` activity is invoked using <xref:System.Activities.WorkflowInvoker>.</span></span>  
  
```csharp  
Dictionary<string, object> inputs = new Dictionary<string, object> {{ "Value", 5}};  
int result = WorkflowInvoker.Invoke(new Square(), inputs);  
Console.WriteLine("Result: {0}", result);  
```  
  
 <span data-ttu-id="e6360-207">При вызове рабочего процесса на консоль выводятся следующие данные:</span><span class="sxs-lookup"><span data-stu-id="e6360-207">When the workflow is invoked, the following output is displayed to the console:</span></span>  
  
 <span data-ttu-id="e6360-208">**Возведение в возведение значения: 5**</span><span class="sxs-lookup"><span data-stu-id="e6360-208">**Squaring the value: 5**</span></span>  
<span data-ttu-id="e6360-209">**Результат: 25**</span><span class="sxs-lookup"><span data-stu-id="e6360-209">**Result: 25**</span></span>
