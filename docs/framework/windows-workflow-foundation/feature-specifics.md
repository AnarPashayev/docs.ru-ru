---
title: Особенности возможностей Windows Workflow Foundation
ms.date: 03/30/2017
ms.assetid: e84d12da-a055-45f6-b4d1-878d127b46b6
ms.openlocfilehash: 063d2472443431423cea9b164831cd1e7a669408
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2019
ms.locfileid: "64753718"
---
# <a name="windows-workflow-foundation-feature-specifics"></a>Особенности возможностей Windows Workflow Foundation

[!INCLUDE[netfx40_long](../../../includes/netfx40-long-md.md)] добавляет ряд функциональных возможностей в Windows Workflow Foundation. В этом документе описываются некоторые новые функциональные возможности и приведены подробные сведения о сценариях, в которых они могут оказаться полезными.

## <a name="messaging-activities"></a>Действия обмена сообщениями

Действия обмена сообщениями (<xref:System.ServiceModel.Activities.Receive>, <xref:System.ServiceModel.Activities.SendReply>, <xref:System.ServiceModel.Activities.Send>, <xref:System.ServiceModel.Activities.ReceiveReply>) используются для отправки и получения сообщений WCF из рабочего процесса. <xref:System.ServiceModel.Activities.Receive> и <xref:System.ServiceModel.Activities.SendReply> действия используются для формирования операции службы Windows Communication Foundation (WCF), которая выполняется через WSDL так же, как и стандартные веб-службы WCF. <xref:System.ServiceModel.Activities.Send> и <xref:System.ServiceModel.Activities.ReceiveReply> используются использовать веб-службу, аналогичную WCF <xref:System.ServiceModel.ChannelFactory>; **Add Service Reference** интерфейс существует и для Workflow Foundation, который создает предварительно настроенных действий.

### <a name="getting-started-with-messaging-activities"></a>Приступая к работе с действиями обмена сообщениями

- В Visual Studio 2012 создайте проект приложения службы рабочего процесса WCF. На полотне будут расположены <xref:System.ServiceModel.Activities.Receive> и <xref:System.ServiceModel.Activities.SendReply>.

- Щелкните правой кнопкой мыши проект и выберите **Add Service Reference**. Пункты существующей веб-службы WSDL и **ОК**. Постройте проект, чтобы показать созданные действия (реализованные с помощью <xref:System.ServiceModel.Activities.Send> и <xref:System.ServiceModel.Activities.ReceiveReply>) в вашем инструментарии.

- [Документация служб рабочего процесса](../wcf/feature-details/workflow-services.md)

### <a name="messaging-activities-example-scenario"></a>Пример сценария действий обмена сообщениями

Объект `BestPriceFinder` службы обращается к нескольким службам авиалиний, пытаясь найти только лучшие цены билет для определенного маршрута. Реализации этого сценария необходимо использовать действия сообщений для получения запроса о цене, извлечения цен из внутренних служб и ответа на запрос наилучшей цены. Это также потребует использования других действий out-of-box Создание бизнес-логику для вычисления наилучшей цены.

## <a name="workflowservicehost"></a>WorkflowServiceHost

<xref:System.ServiceModel.WorkflowServiceHost> Является узлом out-of-box рабочего процесса, который поддерживает несколько экземпляров, конфигурации и обмена сообщениями WCF (несмотря на то, что рабочие процессы не обязательно должны использовать обмен сообщениями, чтобы разместить). Он также реализует сохраняемость, отслеживание и контроль за экземплярами через набор поведений службы. Так же, как WCF <xref:System.ServiceModel.ServiceHost>, <xref:System.ServiceModel.WorkflowServiceHost> может быть резидентно в консоли и WinForms или WPF-приложения или службы Windows или веб сервере (в виде файла xamlx) в службах IIS или WAS.

### <a name="getting-started-with-workflow-service-host"></a>Приступая к работе со службой рабочего процесса

- В Visual Studio 2010 создайте проект приложения службы рабочего процесса WCF: этот проект будет настраиваться для использования <xref:System.ServiceModel.WorkflowServiceHost> в веб сервере среде.

- Чтобы разместить рабочий процесс, не связанный с обменом сообщениями, добавьте пользовательский класс <xref:System.ServiceModel.Activities.WorkflowHostingEndpoint>, который создаст экземпляр на основе сообщения.

- Экземплярами рабочих процессов можно управлять (приостанавливать или завершать их работу). Это делается путем добавления <xref:System.ServiceModel.Activities.WorkflowControlEndpoint> в <xref:System.ServiceModel.WorkflowServiceHost> с последующим вызовом <xref:System.ServiceModel.Activities.WorkflowControlClient>.

- Образцы <xref:System.ServiceModel.WorkflowServiceHost> приведены в следующих разделах:

  - [Выполнение](./samples/execution.md)

  - Приложение: [Управление приостановленным экземпляром](./samples/suspended-instance-management.md)

- [Общие сведения о размещении служб рабочих процессов](../wcf/feature-details/hosting-workflow-services-overview.md)

### <a name="workflowservicehost-scenario"></a>Сценарий WorkflowServiceHost

Служба BestPriceFinder обращается к нескольким службам авиалиний, пытаясь найти только лучшие цены билет для определенного маршрута. Реализации этого сценария потребуется разместить рабочий процесс в <xref:System.ServiceModel.WorkflowServiceHost>. Сообщение действия также служат для получения запроса о цене, извлечения цен из внутренних служб и ответа на запрос наилучшей цены.

## <a name="correlation"></a>Корреляция

Корреляцией называют два следующих явления:

- Способ группирования сообщений, т. е. связь между сообщением с запросом и ответом на него.

- Способ сопоставления порции данных с экземпляром службы.

### <a name="getting-started"></a>Начало работы

- Чтобы начать работу с корреляцией, создайте новый проект в Visual Studio. Создайте переменную типа <xref:System.ServiceModel.Activities.CorrelationHandle>.

- Примером корреляции для группирования сообщений является корреляция по схеме «запрос-ответ», группирующая сообщения.

  - На <xref:System.ServiceModel.Activities.Receive> действия, щелкните <xref:System.ServiceModel.Activities.Receive.CorrelationInitializers%2A> свойство и добавьте <xref:System.ServiceModel.Activities.RequestReplyCorrelationInitializer> с помощью типа CorrelationHandle созданные на первом шаге выше.

  - Создать <xref:System.ServiceModel.Activities.SendReply> действия, щелкните правой кнопкой мыши <xref:System.ServiceModel.Activities.Receive> и нажав кнопку «Создать SendReply». Вставьте его в рабочий процесс после действия <xref:System.ServiceModel.Activities.Receive>.

- Примером сопоставления порции данных с экземпляром службы является корреляция на основе содержимого, сопоставляющая данные (например, идентификатор заказа) с определенным экземпляром рабочего процесса.

  - Для любого действия обмена сообщениями щелкните свойство `CorrelationInitializers` и добавьте <xref:System.ServiceModel.Activities.QueryCorrelationInitializer> с помощью переменной <xref:System.ServiceModel.Activities.CorrelationHandle>, созданной ранее. Дважды щелкните нужное свойство сообщения (например, OrderID) в раскрывающемся меню. Установите свойство `CorrelatesWith` в значение переменной <xref:System.ServiceModel.Activities.CorrelationHandle>, определенной выше.

- [Основная документация по корреляции](../wcf/feature-details/correlation.md)

### <a name="correlation-scenario"></a>Сценарий корреляции

Рабочий процесс обработки заказов, используется для обработки, создание нового заказа и обновляет существующие заказы, находящиеся в процессе. Реализации этого сценария потребуется разместить рабочий процесс в <xref:System.ServiceModel.WorkflowServiceHost> и использовать действия обмена сообщениями. Он также потребует выполнения корреляции на основе `orderId` чтобы убедиться, что при обновлении верному рабочему потоку.

## <a name="simplified-configuration"></a>Упрощенная конфигурация

Схема конфигурации WCF сложна и содержит много трудно найти функции. В [!INCLUDE[netfx_current_short](../../../includes/netfx-current-short-md.md)], мы уделили внимание как помочь пользователям WCF при настройке служб с помощью следующих средств:

- Устранена необходимость явной настройки каждой службы отдельно. Если вы не настраиваются \<службы > элементы для вашей службы, а служба не может определить программным способом любой конечной точки, то набор конечных точек будет автоматически добавляется к службе, по одной на каждый базовый адрес службы и на каждый контракт реализовано, используемый службой.

- Позволяет пользователю определять для привязок WCF и поведений значения по умолчанию, которые будут применяться к службам без явно заданной конфигурации.

- Стандартные конечные точки определяют повторно используемые, заранее настроенные конечные точки, имеющие фиксированные значения для одного или нескольких свойств (адрес, привязка и контракт), а также позволяют определить пользовательские свойства.

- Наконец <xref:System.ServiceModel.Configuration.ConfigurationChannelFactory%601> позволяет централизованно управлять конфигурация клиента WCF, полезно в сценариях, когда конфигурация выбирается или изменяется после времени загрузки домена приложения.

### <a name="getting-started"></a>Начало работы

- [Руководство разработчика WCF 4.0](https://go.microsoft.com/fwlink/?LinkId=204940)

- [Производство канала настройки](https://go.microsoft.com/fwlink/?LinkId=204941)

- [Элемент стандартной конечной точки](https://go.microsoft.com/fwlink/?LinkId=204942)

- [Улучшения конфигурации службы в .NET Framework 4](https://go.microsoft.com/fwlink/?LinkId=204943)

- [Распространенная ошибка пользователей в .NET 4: Опечатки в имени конфигурации служб WF и WCF](https://go.microsoft.com/fwlink/?LinkId=204944)

### <a name="simplified-configuration-scenarios"></a>Сценарии упрощенной конфигурации

- Опытному разработчику ASMX для запуска с помощью WCF. Тем не менее WCF кажется чересчур сложным! Что означает вся информация, которую нужно указать в файле конфигурации? В .NET 4 можно вообще не использовать файл конфигурации.

- Существующий набор служб WCF очень сложно настраивать и обслуживать. Файл конфигурации содержит тысячи строк XML-кода, которые очень опасно трогать. Потребуется помощь, чтобы уменьшить объем кода и сделать его более управляемым.

## <a name="data-contract-resolver"></a>Арбитр контрактов данных

В .NET 3.5 имелись некоторые ограничения в разработке известных типов.

- Было невозможно динамически добавлять известные типы во время сериализации и десериализации.

- Сериализаторы не могли работать с неизвестными данными в xsi:type.

- Пользователи не смогли указать xsi:type, который должен появиться в канале, например уменьшить размер экземпляра сериализации в канале.

[DataContractResolver](../wcf/samples/datacontractresolver.md) решает эти проблемы в .NET 4.5.

### <a name="getting-started"></a>Начало работы

- [Документация по API арбитра контрактов данных](https://go.microsoft.com/fwlink/?LinkId=204946)

- [Введение в арбитре контрактов данных](https://go.microsoft.com/fwlink/?LinkId=204947)

- Образцы:

  - [DataContractResolver](../wcf/samples/datacontractresolver.md)

  - [Атрибут KnownAssemblyAttribute](../wcf/samples/knownassemblyattribute.md)

### <a name="data-contract-resolver-scenarios"></a>Сценарии арбитра контрактов данных

- Как избежать необходимости объявлять десятки объектов <xref:System.Runtime.Serialization.KnownTypeAttribute> в службе.

- Уменьшение размера большого двоичного объекта XML.

## <a name="flowchart"></a>Блок-схема

Блок-схема - это распространенный способ визуального представления проблем домена. Это новая разновидность потока управления, появившаяся в .NET 4. Основная особенность блок-схемы заключается в том, что в определенное время выполняется только одно действие. Блок-схемы могут представлять циклы и альтернативные результаты, но не могут стандартно представлять параллельное выполнение нескольких узлов.

### <a name="getting-started"></a>Начало работы

- В Visual Studio 2012 создайте консольное приложение рабочего процесса. В конструкторе рабочих процессов добавьте блок-схему.

- В блок-схеме используются следующие классы:

  - <xref:System.Activities.Statements.Flowchart>

  - <xref:System.Activities.Statements.FlowNode>

  - <xref:System.Activities.Statements.FlowDecision>

  - <xref:System.Activities.Statements.FlowStep>

  - <xref:System.Activities.Statements.FlowSwitch%601>

- Образцы:

  - [Обработка ошибок в действии блок-схемы с помощью TryCatch](./samples/fault-handling-in-a-flowchart-activity-using-trycatch.md)

  - [Процесс найма](./samples/hiring-process.md)

- Документация по конструктору:

  - [Конструкторы действий блок-схемы](/visualstudio/workflow-designer/flowchart-activity-designers)

### <a name="flowchart-scenarios"></a>Сценарии блок-схем

Действие блок-схемы можно использовать для реализации игры по угадыванию числа. Эта игра очень проста: компьютер выбирает случайное число, а игрок должен его угадать. Когда игрок дает ответ, компьютер выводит подсказку (т. е. «Попробуйте меньшее число»). Если игрок угадывает число менее чем за 7 попыток, то он получает особое поздравление от компьютера. Эта игра может быть реализована с помощью сочетания следующих процедурных действий:

- <xref:System.Activities.Statements.Sequence>

- <xref:System.Activities.Statements.While>

- <xref:System.Activities.Statements.Switch%601>

- <xref:System.Activities.Statements.TryCatch>

- <xref:System.Activities.Statements.Assign%601>

- <xref:System.Activities.Statements.If>

## <a name="procedural-activities-sequence-if-foreach-switch-assign-dowhile-while"></a>Процедурные действия (Sequence, If, ForEach, Switch, Assign, DoWhile, While)

Процедурные действия предоставляют механизм моделирования последовательного потока управления, используя знакомые программистам концепции. Эти действия используют традиционно структурированные конструкции языка программирования и при необходимости предоставляют соответствие с распространенными процедурными языками, такими как C# и VB.

### <a name="getting-started"></a>Начало работы

- В Visual Studio 2012 создайте консольное приложение рабочего процесса. Добавьте в конструкторе рабочих процессов процедурные действия.

- Образцы:

  - [Процесс найма](./samples/hiring-process.md)

  - [Процесс корпоративных закупок](./samples/corporate-purchase-process.md)

- Документация по конструктору:

  - [Конструктор действия Parallel](/visualstudio/workflow-designer/parallel-activity-designer)

  - [ParallelForEach\<T > конструктора действий](/visualstudio/workflow-designer/parallelforeach-t-activity-designer)

### <a name="procedural-activity-scenarios"></a>Сценарии процедурных действий

- <xref:System.Activities.Statements.Parallel>: Системы управления документами интрасети имеет рабочий процесс утверждения документа. Документы перед публикацией в интрасети должны утверждаться сотрудниками нескольких отделов. Нет установленного порядка утверждений; они могут возникнуть в любое время, пока документ находится на этапе «ожидает утверждения». Когда пользователь получает документ для рецензирования, он должен быть утвержден непосредственным руководителем, администратором интрасети и менеджером по внутренним коммуникациям.

- <xref:System.Activities.Statements.ParallelForEach%601>: Приложение WF управляет корпоративными закупками в большой компании. Корпоративные правила предписывают перед планированием каждой операции закупки произвести оценку трех разных поставщиков. Сотрудник отдела, выполняющего закупку, выбирает трех поставщиков из списка поставщиков компании. После того как эти поставщики выбраны и проинформированы, компания ожидает от них коммерческих предложений. Предложения могут поступить в любом порядке. Чтобы реализовать этот сценарий в WF, выполните действие <xref:System.Activities.Statements.ParallelForEach%601> для всех поставщиков в коллекции, запросив от них коммерческие предложения. После того как все предложения собраны, выбирается и отображается лучшее из них.

## <a name="invokemethod"></a>InvokeMethod

Действие <xref:System.Activities.Statements.InvokeMethod> позволяет вызывать открытые методы для объектов или типов в области. Оно поддерживает вызов методов экземпляров и статических методов с параметрами или без параметров (включая массивы параметров) и универсальных методов. Оно также позволяет выполнять метод синхронно и асинхронно.

### <a name="getting-started"></a>Начало работы

- В Visual Studio 2012 создайте консольное приложение рабочего процесса. Добавьте действие <xref:System.Activities.Statements.InvokeMethod> в конструкторе рабочих процессов и настройте для него метод экземпляра и статический метод.

- Документация по конструктору: [Конструктор действия InvokeMethod](/visualstudio/workflow-designer/invokemethod-activity-designer)

### <a name="invokemethod-scenarios"></a>Сценарии InvokeMethod

- Необходимо вызвать метод для объекта в области. Например, в словарь необходимо добавить значение. Вызывается метод Add для экземпляра словаря, указываются ключ и значение.

- Метод необходимо вызывать для унаследованного объекта CLR. Вместо создания пользовательского действия для заключения вызова унаследованного класса в оболочку, если он находится в области во время выполнения рабочего процесса, можно использовать <xref:System.Activities.Statements.InvokeMethod>.

## <a name="error-handling-activities"></a>Действия по обработке ошибок

Действие <xref:System.Activities.Statements.TryCatch> предоставляет механизм для перехвата исключений, возникающих во время выполнения набора содержащихся действий (аналогично конструкции Try/Catch в C# и VB). <xref:System.Activities.Statements.TryCatch> обеспечивает обработку исключений на уровне рабочего процесса. При возникновении необработанного исключения рабочий процесс прерывается и блок Finally не будет выполнен. Такое поведение согласуется с C#.

### <a name="getting-started"></a>Начало работы

- В Visual Studio 2012 создайте консольное приложение рабочего процесса. В конструкторе рабочих процессов добавьте действие <xref:System.Activities.Statements.TryCatch>.

- Пример: [Обработка ошибок в действии блок-схемы с помощью TryCatch](./samples/fault-handling-in-a-flowchart-activity-using-trycatch.md)

- Документация по конструктору: [Конструкторы действий обработки ошибок](/visualstudio/workflow-designer/error-handling-activity-designers)

### <a name="error-handling-scenarios"></a>Сценарии обработки ошибок

При возникновении ошибки должен быть выполнен набор действий и определенная логика. Если логика обработки ошибок обнаружила, что ошибку устранить нельзя, то исключение будет выдано повторно и проблема будет обрабатываться родительским действием (или узлом).

## <a name="pick-activity"></a>Действие Pick

Действие <xref:System.Activities.Statements.Pick> обеспечивает моделирование потока управления на основе событий в WF. Класс <xref:System.Activities.Statements.Pick> содержит множество ветвей, каждая из которых перед выполнением ожидает наступления конкретного события. В такой конфигурации действие <xref:System.Activities.Statements.Pick> ведет себя подобно <xref:System.Activities.Statements.Switch%601>, в котором действие выполнено только для одного события из набора прослушиваемых событий. Всеми ветвями управляют события, и появившееся событие запускает соответствующую ветвь. Все другие ветви отменяются и прекращают ожидать передачу данных, связанных с событиями.

### <a name="getting-started"></a>Начало работы

- В Visual Studio 2012 создайте консольное приложение рабочего процесса. В конструкторе рабочих процессов добавьте действие <xref:System.Activities.Statements.Pick>.

- Пример: [Использование действия Pick](./samples/using-the-pick-activity.md)

- Документация по конструктору: [Конструктор действия Pick](/visualstudio/workflow-designer/pick-activity-designer)

### <a name="pick-scenario"></a>Сценарий Pick

Пользователь должен получать приглашение ввести данные. В обычных условиях разработчик может для запроса пользовательского ввода вызвать такой метод, как <xref:System.Console.ReadLine%2A>. Проблема в данном случае состоит в том, что программа должна ожидать ввода данных пользователем. В этом сценарии для разблокирования блокирующего действия необходимо время ожидания. В распространенном сценарии задача должна быть выполнена в течение заданного промежутка времени. Использование времени ожидания для блокирующего действия - это сценарий, где действие Pick имеет очень большое значение.

## <a name="wcf-routing-service"></a>Служба маршрутизации WCF

Служба маршрутизации должен быть универсальный программный маршрутизатор, который позволяет управлять как сообщения WCF передавать между клиентами и службами. Служба маршрутизации позволяет отделить клиенты из служб, дающий гораздо большую гибкость с точки зрения конфигурации, можно поддерживать, и гибкость, имеется рассматривая способы размещения служб. В .NET 3.5 клиенты и службы были тесно связаны; клиент должны были быть известны обо всех служб, необходимо обратиться к и где они были найдены. Кроме того WCF в .NET Framework 3.5 имеет следующие ограничения:

- Обработка ошибок была сложной задачей, так как эта логика должна была быть жестко закодирована в клиенте.

- Клиенты и службы должны были всегда использовать одни и те же привязки.

- Службы редко были хорошо факторизованы: проще настроить клиент для работы с одной службой, реализующей все, что нужно, чем выбирать из множества служб.

Служба маршрутизации в .NET 4 позволяет упростить для решения этих проблем. Новая служба маршрутизации имеет следующие функциональные возможности:

1. Маршрутизация на основе содержимого (Объекты <xref:System.ServiceModel.Dispatcher.MessageFilter> исследуют сообщение и определяют, куда оно должно быть отправлено.)

2. Протокол привязки (транспортного и сообщений)

3. Обработка ошибок (маршрутизатор перехватывает исключения и при возникновении сбоя переходит к резервным конечным точкам)

4. Динамическое (в памяти) обновление <xref:System.ServiceModel.Dispatcher.MessageFilterTable%601> и конфигурации маршрутизации.

### <a name="getting-started"></a>Начало работы

1. Документация: [Routing](../wcf/feature-details/routing.md)

2. Образцы: [Службы маршрутизации &#91;образцы WCF&#93;](../wcf/samples/routing-services.md)

3. Блог: [Правила маршрутизации!](https://go.microsoft.com/fwlink/?LinkId=204956)

### <a name="routing-scenarios"></a>Сценарии маршрутизации

Служба маршрутизации полезна в следующих сценариях.

- Клиенты могут работать с несколькими службами, не обращаясь к ним непосредственно.

- Клиенты могут выполнять дополнительные операции с запросами, чтобы определить, куда их направить.

- Распределение операций, выполняемых клиентом, между несколькими реализациями службы без оптимизации кода клиента.

- Клиенты и службы могут согласовать различные привязки с различными параметрами безопасности.

- Клиенты могут быть более устойчивыми к сбоям или недоступности служб.

## <a name="wcf-discovery"></a>Обнаружение WCF

Обнаружение WCF — это технология платформы, которая позволяет внедрять механизм обнаружения в инфраструктуру приложения. Его можно использовать для того, чтобы сделать службы доступными для обнаружения и настроить на клиентах поиск служб. Конечные точки больше не нужно жестко прописывать в клиентах, что позволяет делать приложения более надежными и отказоустойчивыми. Обнаружение - это превосходная основа для создания возможностей автоматической настройки приложений.

Продукт создается по стандарту WS-Discovery. Он обладает возможностью взаимодействия, расширяемости и универсальности. Продукт поддерживает два режима функционирования.

1. Управляемый: в сети имеется сущность, осведомленная о существующих службах; клиенты направляют запросы непосредственно к ней. Такая схема работы аналогична Active Directory.

2. Нерегламентированный: клиенты используют многоадресные сообщения для обнаружения служб.

Более того, сообщения обнаружения не зависят от сетевого протокола; их можно использовать с любым протоколом, поддерживающим требования режима. Например, обнаружение многоадресные сообщения могут отправляться по каналу UDP или любой другой сети, поддерживающей многоадресные сообщения. Эти расчетные точки в сочетании с гибкостью функций позволяют адаптировать обнаружение специально для вашего решения.

### <a name="getting-started"></a>Начало работы

- Документация: [Обнаружение WCF](../wcf/feature-details/wcf-discovery.md)

- Образцы: [Обнаружение (образцы)](../wcf/samples/discovery-samples.md)

### <a name="discovery-scenarios"></a>Сценарии обнаружения

Разработчик не хочет жестко задавать конечные точки, хотя неизвестно, когда служба будет доступна. Вместо этого разработчик хочет выбирать службу во время выполнения. Компоненты в приложении должны быть лучше разделены, более надежны и доступны для автоматической настройки.

## <a name="tracking"></a>Отслеживание

Отслеживание рабочих процессов обеспечивает понимание выполнения экземпляра рабочего процесса. События отслеживания создаются из рабочего процесса на уровне экземпляра рабочего процесса и при выполнении действий в рабочем процессе. Участник отслеживания в рабочем процессе должен быть добавлен к узлу рабочего процесса для подписки на записи отслеживания. Записи отслеживания фильтруются с помощью профиля отслеживания. Платформа .NET Framework предоставляет участника отслеживания ETW (события трассировки для Windows), и базовый профиль будет установлено в файле machine.config.

### <a name="getting-started"></a>Начало работы

1. В Visual Studio 2010 создайте новый проект служебного приложения рабочего процесса WCF. Пара <xref:System.ServiceModel.Activities.Receive> и <xref:System.ServiceModel.Activities.SendReply> будет расположена на полотне для запуска.

2. Откройте файл web.config и добавьте поведение отслеживания трассировки событий Windows без профиля.

    1. Будет использован профиль по умолчанию.

    2. Откройте средство просмотра событий и включите канал аналитики для следующего узла: **Средство просмотра событий**, **журналы приложений и служб**, **Microsoft**, **Windows**, **Application Server-Applications**. Щелкните правой кнопкой мыши **аналитический** и выберите **включить журнал**.

    3. Запустите службу рабочего процесса.

    4. Просмотрите события отслеживания рабочего процесса в средстве просмотра событий.

3. Образцы: [Отслеживание](./samples/tracking.md)

4. Основная документация: [Отслеживание и трассировка рабочих процессов](workflow-tracking-and-tracing.md)

## <a name="sql-workflow-instance-store"></a>Хранилище экземпляров рабочих процессов SQL

<xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> - это реализация хранилища экземпляров на основе SQL Server. Хранилище экземпляров служит для хранения состояния запущенного экземпляра вместе со всеми данными, необходимыми для загрузки и возобновления работы экземпляра. Узел службы сохраняет состояние экземпляра в хранилище экземпляров при сохранении рабочего процесса, а также загружает состояние экземпляра при получении сообщения для этого экземпляра или после истечения срока действия действий задержки.

### <a name="getting-started"></a>Начало работы

1. В Visual Studio 2012, создать рабочий процесс, который содержит явный или неявный <xref:System.Activities.Statements.Persist> действия. Добавьте поведение <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> на узел службы рабочего процесса. Это можно сделать в коде или в файле конфигурации приложения.

2. Образцы: [Сохраняемость](./samples/persistence.md)

3. Основная документация: [Store экземпляра рабочего процесса SQL](sql-workflow-instance-store.md).
