---
title: Особенности возможностей Windows Workflow Foundation
ms.date: 03/30/2017
ms.assetid: e84d12da-a055-45f6-b4d1-878d127b46b6
ms.openlocfilehash: 11bde5edea44f09ef1a5658cdf0e20ec1349c84b
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79182925"
---
# <a name="windows-workflow-foundation-feature-specifics"></a>Особенности возможностей Windows Workflow Foundation

.NET Framework 4 добавляет ряд функций в Фонд рабочего процесса Windows. В этом документе описываются некоторые новые функциональные возможности и приведены подробные сведения о сценариях, в которых они могут оказаться полезными.

## <a name="messaging-activities"></a>Действия обмена сообщениями

Действия обмена<xref:System.ServiceModel.Activities.Receive>сообщениями <xref:System.ServiceModel.Activities.Send> <xref:System.ServiceModel.Activities.ReceiveReply>(, <xref:System.ServiceModel.Activities.SendReply>, , ) используются для отправки и получения сообщений WCF из вашего рабочего процесса. <xref:System.ServiceModel.Activities.Receive>и <xref:System.ServiceModel.Activities.SendReply> мероприятия используются для формирования службы Windows Communication Foundation (WCF), которая подвергается через WSDL так же, как стандартные веб-сервисы WCF. <xref:System.ServiceModel.Activities.Send>и <xref:System.ServiceModel.Activities.ReceiveReply> используются для потребления веб-сервиса, <xref:System.ServiceModel.ChannelFactory>аналогичного WCF; Также существует опыт **справки о добавлении** службы для Фонда рабочего процесса, который генерирует предварительно настроенные действия.

### <a name="getting-started-with-messaging-activities"></a>Приступая к работе с действиями обмена сообщениями

- В Visual Studio 2012 создайте проект приложения для обслуживания рабочих процессов WCF. На полотне будут расположены <xref:System.ServiceModel.Activities.Receive> и <xref:System.ServiceModel.Activities.SendReply>.

- Нажмите на проект справа и выберите **Справку по сервису Add**Service. Укажите на существующий веб-сервис WSDL и нажмите **OK**. Создайте свой проект, чтобы показать <xref:System.ServiceModel.Activities.Send> <xref:System.ServiceModel.Activities.ReceiveReply>генерируемые действия (реализованные с использованием и) в вашем наборе инструментов.

- [Документация служб рабочего процесса](../wcf/feature-details/workflow-services.md)

### <a name="messaging-activities-example-scenario"></a>Пример сценария действий обмена сообщениями

Служба `BestPriceFinder` призывает несколько авиакомпаний услуг, чтобы найти лучшую цену билета для конкретного маршрута. Реализация этого сценария потребует от вас использования действий по сообщению для получения ценового запроса, получения ценовых цен из услуг бэк-энда и ответа на запрос о цене с лучшей ценой. Это также потребует от вас использовать другие вне коробки деятельности для создания бизнес-логики для расчета лучшей цены.

## <a name="workflowservicehost"></a>WorkflowServiceHost

Это <xref:System.ServiceModel.WorkflowServiceHost> узла из окна рабочего процесса, который поддерживает несколько экземпляров, конфигурацию и сообщения WCF (хотя рабочие процессы не требуются для использования сообщений для размещения). Он также реализует сохраняемость, отслеживание и контроль за экземплярами через набор поведений службы. Так же, как <xref:System.ServiceModel.ServiceHost>WCF, <xref:System.ServiceModel.WorkflowServiceHost> может быть самостоятельно размещены в консоли / WinForms / WPF приложения или службы Windows, или веб-хостинга (как файл .xamlx) в IIS или WAS.

### <a name="getting-started-with-workflow-service-host"></a>Приступая к работе со службой рабочего процесса

- В Visual Studio 2010 создайте проект приложения для обслуживания рабочих процессов <xref:System.ServiceModel.WorkflowServiceHost> WCF: этот проект будет создан для использования в среде веб-хостинга.

- Чтобы разместить рабочий процесс, не связанный с обменом сообщениями, добавьте пользовательский класс <xref:System.ServiceModel.Activities.WorkflowHostingEndpoint>, который создаст экземпляр на основе сообщения.

- Экземплярами рабочих процессов можно управлять (приостанавливать или завершать их работу). Это делается путем добавления <xref:System.ServiceModel.Activities.WorkflowControlEndpoint> в <xref:System.ServiceModel.WorkflowServiceHost> с последующим вызовом <xref:System.ServiceModel.Activities.WorkflowControlClient>.

- Образцы <xref:System.ServiceModel.WorkflowServiceHost> приведены в следующих разделах:

  - [Выполнения](./samples/execution.md)

  - Применение: [Приостановлено управление экземплярами](./samples/suspended-instance-management.md)

- [Обзор служб рабочего процесса](../wcf/feature-details/hosting-workflow-services-overview.md)

### <a name="workflowservicehost-scenario"></a>Сценарий WorkflowServiceHost

Служба BestPriceFinder призывает несколько авиакомпаний, чтобы найти лучшую цену билета для конкретного маршрута. Реализация этого сценария потребует размещения рабочего <xref:System.ServiceModel.WorkflowServiceHost>процесса в. Он также будет использовать действия сообщения для получения ценового запроса, получения ценовых цен от бэк-энд-услуг и ответа на запрос о цене с лучшей ценой.

## <a name="correlation"></a>Correlation

Корреляцией называют два следующих явления:

- Способ группирования сообщений, т. е. связь между сообщением с запросом и ответом на него.

- Способ сопоставления порции данных с экземпляром службы.

### <a name="getting-started"></a>Приступая к работе

- Чтобы начать работу с корреляцией, создайте новый проект в Visual Studio. Создайте переменную типа <xref:System.ServiceModel.Activities.CorrelationHandle>.

- Примером корреляции для группирования сообщений является корреляция по схеме «запрос-ответ», группирующая сообщения.

  - На <xref:System.ServiceModel.Activities.Receive> действия, нажмите <xref:System.ServiceModel.Activities.Receive.CorrelationInitializers%2A> на свойство и добавить <xref:System.ServiceModel.Activities.RequestReplyCorrelationInitializer> с помощью CorrelationHandle создан в первом шаге выше.

  - Создайте <xref:System.ServiceModel.Activities.SendReply> действие, нажав <xref:System.ServiceModel.Activities.Receive> на кнопку «Создайте SendReply». Вставьте его в рабочий процесс после действия <xref:System.ServiceModel.Activities.Receive>.

- Примером сопоставления порции данных с экземпляром службы является корреляция на основе содержимого, сопоставляющая данные (например, идентификатор заказа) с определенным экземпляром рабочего процесса.

  - Для любого действия обмена сообщениями щелкните свойство `CorrelationInitializers` и добавьте <xref:System.ServiceModel.Activities.QueryCorrelationInitializer> с помощью переменной <xref:System.ServiceModel.Activities.CorrelationHandle>, созданной ранее. Дважды щелкните нужное свойство сообщения (например, OrderID) в раскрывающемся меню. Установите свойство `CorrelatesWith` в значение переменной <xref:System.ServiceModel.Activities.CorrelationHandle>, определенной выше.

- [Основная документация по корреляции](../wcf/feature-details/correlation.md)

### <a name="correlation-scenario"></a>Сценарий корреляции

Рабочий процесс обработки заказов используется для обработки новых заказов и обновления существующих в настоящее время заказов. Реализация этого сценария потребует размещения рабочего <xref:System.ServiceModel.WorkflowServiceHost> процесса и использования действий обмена сообщениями. Это также потребует корреляции, основанной `orderId` на том, чтобы обеспечить внесение обновлений в правильный рабочий процесс.

## <a name="simplified-configuration"></a>Упрощенная конфигурация

Схема конфигурации WCF сложна и предоставляет пользователям множество труднонайти функции. В [!INCLUDE[netfx_current_short](../../../includes/netfx-current-short-md.md)], мы сосредоточились на оказании помощи пользователям WCF настроить свои услуги со следующими функциями:

- Устранена необходимость явной настройки каждой службы отдельно. Если вы не настройте какую-либо \<службу> элементов для вашего сервиса, и ваша служба не определяет программную конечную точку, то в ваш сервис автоматически будет добавлен набор конечных точек, один адрес базы обслуживания и контракт, реализованный вашей службой.

- Позволяет пользователю определять для привязок WCF и поведений значения по умолчанию, которые будут применяться к службам без явно заданной конфигурации.

- Стандартные конечные точки определяют повторно используемые, заранее настроенные конечные точки, имеющие фиксированные значения для одного или нескольких свойств (адрес, привязка и контракт), а также позволяют определить пользовательские свойства.

- Наконец, <xref:System.ServiceModel.Configuration.ConfigurationChannelFactory%601> позволяет делать центральное управление конфигурацией клиента WCF, полезное в сценариях, в которых конфигурация выбрана или изменена после времени загрузки домена приложения.

### <a name="getting-started"></a>Приступая к работе

- [Руководство разработчика WCF 4.0](https://docs.microsoft.com/previous-versions/dotnet/articles/ee354381(v=msdn.10))

- [Производство канала настройки](xref:System.ServiceModel.Configuration.ConfigurationChannelFactory%601)

- [Элемент стандартной конечной точки](xref:System.ServiceModel.Configuration.StandardEndpointElement)

- [Улучшения конфигурации обслуживания в .NET Framework 4](https://docs.microsoft.com/archive/blogs/endpoint/service-configuration-improvements-in-net-4)

- [Распространенная ошибка пользователей в .NET 4: опечатки в имени конфигурации служб WF и WCF](https://docs.microsoft.com/archive/blogs/endpoint/common-user-mistake-in-net-4-mistyping-the-wfwcf-service-configuration-name)

### <a name="simplified-configuration-scenarios"></a>Сценарии упрощенной конфигурации

- Опытный разработчик ASMX хочет начать использовать WCF. Тем не менее, WCF кажется слишком сложным! Что означает вся информация, которую нужно указать в файле конфигурации? В .NET 4 можно вообще не использовать файл конфигурации.

- Существующий набор служб WCF очень сложно настраивать и обслуживать. Файл конфигурации содержит тысячи строк XML-кода, которые очень опасно трогать. Потребуется помощь, чтобы уменьшить объем кода и сделать его более управляемым.

## <a name="data-contract-resolver"></a>Арбитр контрактов данных

В .NET 3.5 имелись некоторые ограничения в разработке известных типов.

- Было невозможно динамически добавлять известные типы во время сериализации и десериализации.

- Сериализаторы не могли работать с неизвестными данными в xsi:type.

- Пользователи не смогли указать xsi:type, который должен появиться в канале, например уменьшить размер экземпляра сериализации в канале.

[DataContractResolver](../wcf/samples/datacontractresolver.md) решает эти проблемы в .NET 4.5.

### <a name="getting-started"></a>Приступая к работе

- [Документация по API арбитра контрактов данных](xref:System.Runtime.Serialization.DataContractResolver)

- [Представление арбитра контрактов данных](https://docs.microsoft.com/archive/blogs/youssefm/configuring-known-types-dynamically-introducing-the-datacontractresolver)

- Примеры:

  - [DataContractResolver](../wcf/samples/datacontractresolver.md)

  - [Атрибут KnownAssemblyAttribute](../wcf/samples/knownassemblyattribute.md)

### <a name="data-contract-resolver-scenarios"></a>Сценарии арбитра контрактов данных

- Как избежать необходимости объявлять десятки объектов <xref:System.Runtime.Serialization.KnownTypeAttribute> в службе.

- Уменьшение размера большого двоичного объекта XML.

## <a name="flowchart"></a>Блок-схема

Блок-схема - это распространенный способ визуального представления проблем домена. Это новый стиль потока управления, который мы вводим в .NET 4. Основная особенность блок-схемы заключается в том, что в определенное время выполняется только одно действие. Блок-схемы могут представлять циклы и альтернативные результаты, но не могут стандартно представлять параллельное выполнение нескольких узлов.

### <a name="getting-started"></a>Приступая к работе

- В Visual Studio 2012 создайте приложение консоли рабочего процесса. В конструкторе рабочих процессов добавьте блок-схему.

- В блок-схеме используются следующие классы:

  - <xref:System.Activities.Statements.Flowchart>

  - <xref:System.Activities.Statements.FlowNode>

  - <xref:System.Activities.Statements.FlowDecision>

  - <xref:System.Activities.Statements.FlowStep>

  - <xref:System.Activities.Statements.FlowSwitch%601>

- Примеры:

  - [Обработка ошибок в действии блок-схемы с помощью TryCatch](./samples/fault-handling-in-a-flowchart-activity-using-trycatch.md)

  - [Процесс найма](./samples/hiring-process.md)

- Документация по конструктору:

  - [Конструкторы действий блок-схемы](/visualstudio/workflow-designer/flowchart-activity-designers)

### <a name="flowchart-scenarios"></a>Сценарии блок-схем

Действие блок-схемы можно использовать для реализации игры по угадыванию числа. Эта игра очень проста: компьютер выбирает случайное число, а игрок должен его угадать. Когда игрок отправляет каждую догадку, компьютер показывает им подсказку (т.е. "попробовать меньшее число"). Если игрок находит номер менее чем за 7 попыток, он получает специальное поздравление с компьютера. Эта игра может быть реализована с помощью сочетания следующих процедурных действий:

- <xref:System.Activities.Statements.Sequence>

- <xref:System.Activities.Statements.While>

- <xref:System.Activities.Statements.Switch%601>

- <xref:System.Activities.Statements.TryCatch>

- <xref:System.Activities.Statements.Assign%601>

- <xref:System.Activities.Statements.If>

## <a name="procedural-activities-sequence-if-foreach-switch-assign-dowhile-while"></a>Процедурные действия (Sequence, If, ForEach, Switch, Assign, DoWhile, While)

Процедурные действия предоставляют механизм моделирования последовательного потока управления, используя знакомые программистам концепции. Эти мероприятия позволяют традиционно структурированные конструкции языка программирования и, при необходимости, обеспечивают языковой паритет с общими процедурными языками, такими как C и Visual Basic.

### <a name="getting-started"></a>Приступая к работе

- В Visual Studio 2012 создайте приложение консоли рабочего процесса. Добавьте в конструкторе рабочих процессов процедурные действия.

- Примеры:

  - [Процесс найма](./samples/hiring-process.md)

  - [Процесс корпоративных закупок](./samples/corporate-purchase-process.md)

- Документация по конструктору:

  - [Конструктор действия Parallel](/visualstudio/workflow-designer/parallel-activity-designer)

  - [ParallelForEach\<T>-дизайнер деятельности](/visualstudio/workflow-designer/parallelforeach-t-activity-designer)

### <a name="procedural-activity-scenarios"></a>Сценарии процедурных действий

- <xref:System.Activities.Statements.Parallel>: Система управления внутрисетевом документооборотом имеет рабочий процесс утверждения документов. Документы перед публикацией в интрасети должны утверждаться сотрудниками нескольких отделов. Нет установленного порядка для утверждений; они могут возникнуть в любое время, пока документ находится в стадии утверждения в ожидании. Когда пользователь отправляет документ на проверку, он должен быть одобрен его непосредственным менеджером, администратором интрасети и менеджером внутренних коммуникаций.

- <xref:System.Activities.Statements.ParallelForEach%601>: приложение WF управляет корпоративными закупками в большой компании. Корпоративные правила предписывают перед планированием каждой операции закупки произвести оценку трех разных поставщиков. Сотрудник отдела закупок выбирает трех поставщиков из списка поставщиков компании. После того как эти поставщики выбраны и проинформированы, компания ожидает от них коммерческих предложений. Предложения могут поступить в любом порядке. Чтобы реализовать этот сценарий в WF, выполните действие <xref:System.Activities.Statements.ParallelForEach%601> для всех поставщиков в коллекции, запросив от них коммерческие предложения. После того как все предложения собраны, выбирается и отображается лучшее из них.

## <a name="invokemethod"></a>InvokeMethod

Действие <xref:System.Activities.Statements.InvokeMethod> позволяет вызывать открытые методы для объектов или типов в области. Оно поддерживает вызов методов экземпляров и статических методов с параметрами или без параметров (включая массивы параметров) и универсальных методов. Оно также позволяет выполнять метод синхронно и асинхронно.

### <a name="getting-started"></a>Приступая к работе

- В Visual Studio 2012 создайте приложение консоли рабочего процесса. Добавьте действие <xref:System.Activities.Statements.InvokeMethod> в конструкторе рабочих процессов и настройте для него метод экземпляра и статический метод.

- Дизайнер документация: [InvokeMethod деятельности Дизайнер](/visualstudio/workflow-designer/invokemethod-activity-designer)

### <a name="invokemethod-scenarios"></a>Сценарии InvokeMethod

- Необходимо вызвать метод для объекта в области. Например, в словарь необходимо добавить значение. Вызывается метод Add для экземпляра словаря, указываются ключ и значение.

- Метод необходимо вызывать для унаследованного объекта CLR. Вместо создания пользовательского действия для заключения вызова унаследованного класса в оболочку, если он находится в области во время выполнения рабочего процесса, можно использовать <xref:System.Activities.Statements.InvokeMethod>.

## <a name="error-handling-activities"></a>Действия по обработке ошибок

Действие <xref:System.Activities.Statements.TryCatch> обеспечивает механизм ловли исключений, которые происходят во время выполнения набора содержащихся действий (по аналогии с конструкцией Try/Catch в C и Visual Basic). <xref:System.Activities.Statements.TryCatch> обеспечивает обработку исключений на уровне рабочего процесса. При необработанном исключении рабочий процесс прерывается и блок «Наконец» не выполняется. Такое поведение согласуется с C#.

### <a name="getting-started"></a>Приступая к работе

- В Visual Studio 2012 создайте приложение консоли рабочего процесса. В конструкторе рабочих процессов добавьте действие <xref:System.Activities.Statements.TryCatch>.

- Пример: [Обработка неисправностей в flowchart деятельности с помощью TryCatch](./samples/fault-handling-in-a-flowchart-activity-using-trycatch.md)

- Документация конструктора: [Конструкторы деятельности обработки ошибки](/visualstudio/workflow-designer/error-handling-activity-designers)

### <a name="error-handling-scenarios"></a>Сценарии обработки ошибок

При возникновении ошибки должен быть выполнен набор действий и определенная логика. Если логика обработки ошибок обнаружила, что ошибку устранить нельзя, то исключение будет выдано повторно и проблема будет обрабатываться родительским действием (или узлом).

## <a name="pick-activity"></a>Действие Pick

Действие <xref:System.Activities.Statements.Pick> обеспечивает моделирование потока управления на основе событий в WF. Класс <xref:System.Activities.Statements.Pick> содержит множество ветвей, каждая из которых перед выполнением ожидает наступления конкретного события. В такой конфигурации действие <xref:System.Activities.Statements.Pick> ведет себя подобно <xref:System.Activities.Statements.Switch%601>, в котором действие выполнено только для одного события из набора прослушиваемых событий. Всеми ветвями управляют события, и появившееся событие запускает соответствующую ветвь. Все другие ветви отменяются и прекращают ожидать передачу данных, связанных с событиями.

### <a name="getting-started"></a>Приступая к работе

- В Visual Studio 2012 создайте приложение консоли рабочего процесса. В конструкторе рабочих процессов добавьте действие <xref:System.Activities.Statements.Pick>.

- Пример: [Использование действия «Выбрать»](./samples/using-the-pick-activity.md)

- Дизайнерская документация: [Выберите проектировщик активности](/visualstudio/workflow-designer/pick-activity-designer)

### <a name="pick-scenario"></a>Сценарий Pick

Пользователь должен получать приглашение ввести данные. При обычных обстоятельствах разработчик использует <xref:System.Console.ReadLine%2A> вызов метода, который может подсказать для ввода пользователя. Проблема в данном случае состоит в том, что программа должна ожидать ввода данных пользователем. В этом сценарии для разблокирования блокирующего действия необходимо время ожидания. В распространенном сценарии задача должна быть выполнена в течение заданного промежутка времени. Использование времени ожидания для блокирующего действия - это сценарий, где действие Pick имеет очень большое значение.

## <a name="wcf-routing-service"></a>Служба маршрутизации WCF

Служба маршрутизаний разработана как универсальный программный маршрутизатор, который позволяет контролировать, как сообщения WCF перетекают между вашими клиентами и службами. Служба реуктора позволяет отделить клиентов от ваших услуг, что дает вам гораздо больше свободы с точки зрения конфигураций, которые вы можете поддерживать, и гибкости, которую вы имеете при рассмотрении того, как разместить ваши услуги. В .NET 3.5 клиенты и услуги были тесно связаны; клиент должен знать обо всех услугах, с которые ему необходимо поговорить, и о том, где они находятся. Кроме того, WCF в рамках .NET 3.5 имеет следующие ограничения:

- Обработка ошибок была сложной задачей, так как эта логика должна была быть жестко закодирована в клиенте.

- Клиенты и службы должны были всегда использовать одни и те же привязки.

- Службы редко были хорошо факторизованы: проще настроить клиент для работы с одной службой, реализующей все, что нужно, чем выбирать из множества служб.

Служба разгрома в .NET 4 предназначена для упрощения решения этих проблем. Новая служба маршрутизации имеет следующие функциональные возможности:

1. Маршрутизация на основе содержимого (Объекты <xref:System.ServiceModel.Dispatcher.MessageFilter> исследуют сообщение и определяют, куда оно должно быть отправлено.)

2. Преодоление протокола (сообщение о транспортном &)

3. Обработка ошибок (маршрутизатор перехватывает исключения и при возникновении сбоя переходит к резервным конечным точкам)

4. Динамическое (в памяти) обновление <xref:System.ServiceModel.Dispatcher.MessageFilterTable%601> и конфигурации маршрутизации.

### <a name="getting-started"></a>Приступая к работе

1. Документация: [Реутовство](../wcf/feature-details/routing.md)

2. Образцы: [Услуги по реукторе &#91;&#93;WCF](../wcf/samples/routing-services.md)

3. Блог: [Правила реуктора!](https://docs.microsoft.com/archive/blogs/RoutingRules/)

### <a name="routing-scenarios"></a>Сценарии маршрутизации

Служба маршрутизации полезна в следующих сценариях.

- Клиенты могут работать с несколькими службами, не обращаясь к ним непосредственно.

- Клиенты могут выполнять дополнительные операции с запросами, чтобы определить, куда их направить.

- Распределение операций, выполняемых клиентом, между несколькими реализациями службы без оптимизации кода клиента.

- Клиенты и службы могут согласовать различные привязки с различными параметрами безопасности.

- Клиенты могут быть более устойчивыми к сбоям или недоступности служб.

## <a name="wcf-discovery"></a>Обнаружение WCF

WCF Discovery — это рамочная технология, которая позволяет включить механизм обнаружения в инфраструктуру приложений. Его можно использовать для того, чтобы сделать службы доступными для обнаружения и настроить на клиентах поиск служб. Конечные точки больше не нужно жестко прописывать в клиентах, что позволяет делать приложения более надежными и отказоустойчивыми. Обнаружение - это превосходная основа для создания возможностей автоматической настройки приложений.

Продукт создается по стандарту WS-Discovery. Он разработан, чтобы быть совместимым, расширяемым и общим. Продукт поддерживает два режима функционирования.

1. Управляемый: в сети имеется сущность, осведомленная о существующих службах; клиенты направляют запросы непосредственно к ней. Такая схема работы аналогична Active Directory.

2. Нерегламентированный: клиенты используют многоадресные сообщения для обнаружения служб.

Более того, сообщения обнаружения не зависят от сетевого протокола; их можно использовать с любым протоколом, поддерживающим требования режима. Например, многокастрные сообщения обнаружения могут быть отправлены через канал UDP или любую другую сеть, поддерживающую мультикастрные сообщения. Эти точки проектирования, в сочетании с гибкостью функций, позволяют адаптировать открытие специально к вашему решению.

### <a name="getting-started"></a>Приступая к работе

- Документация: [WCF Discovery](../wcf/feature-details/wcf-discovery.md)

- Образцы: [Открытие (Образцы)](../wcf/samples/discovery-samples.md)

### <a name="discovery-scenarios"></a>Сценарии обнаружения

Разработчик не хочет жестко задавать конечные точки, хотя неизвестно, когда служба будет доступна. Вместо этого разработчик хочет выбирать службу во время выполнения. Компоненты в приложении должны быть лучше разделены, более надежны и доступны для автоматической настройки.

## <a name="tracking"></a>Отслеживание

Отслеживание рабочего процесса позволяет получить представление об выполнении экземпляра рабочего процесса. События отслеживания испускаются из рабочего процесса на уровне экземпляра рабочего процесса и при выполнении действий в рабочем процессе. Участник отслеживания в рабочем процессе должен быть добавлен к узлу рабочего процесса для подписки на записи отслеживания. Записи отслеживания фильтруются с помощью профиля отслеживания. Рамочная .NET обеспечивает участника отслеживания ETW (Отслеживание событий для Windows), а базовый профиль установлен в файле machine.config.

### <a name="getting-started"></a>Приступая к работе

1. В Visual Studio 2010 создайте новый проект служебного приложения рабочего процесса WCF. Пара <xref:System.ServiceModel.Activities.Receive> и <xref:System.ServiceModel.Activities.SendReply> будет расположена на полотне для запуска.

2. Откройте файл web.config и добавьте поведение отслеживания трассировки событий Windows без профиля.

    1. Будет использован профиль по умолчанию.

    2. Откройте для просмотра событий и включите аналитический канал в следующем узло: **Viewer Event,** **Журналы приложений и служб,** **Microsoft,** **Windows,** **Application Server-Applications**. Нажмите правой кнопкой **аналитический** и выберите **Включить журнал**.

    3. Запустите службу рабочего процесса.

    4. Просмотрите события отслеживания рабочего процесса в средстве просмотра событий.

3. Образцы: [Отслеживание](./samples/tracking.md)

4. Концептуальная [документация: Отслеживание и отслеживание рабочего процесса](workflow-tracking-and-tracing.md)

## <a name="sql-workflow-instance-store"></a>Хранилище экземпляров рабочих процессов SQL

<xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> - это реализация хранилища экземпляров на основе SQL Server. Хранилище экземпляров служит для хранения состояния запущенного экземпляра вместе со всеми данными, необходимыми для загрузки и возобновления работы экземпляра. Узел службы сохраняет состояние экземпляра в хранилище экземпляров при сохранении рабочего процесса, а также загружает состояние экземпляра при получении сообщения для этого экземпляра или после истечения срока действия действий задержки.

### <a name="getting-started"></a>Приступая к работе

1. В Visual Studio 2012 создайте рабочий процесс, содержащий неявную или явную <xref:System.Activities.Statements.Persist> активность. Добавьте поведение <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> на узел службы рабочего процесса. Это можно сделать в коде или в файле конфигурации приложения.

2. Образцы: [Настойчивость](/previous-versions/dotnet/netframework-4.0/dd699769(v%3dvs.100))

3. Концептуальная документация: [Магазин экземпляров рабочего процесса S'L](sql-workflow-instance-store.md).
