---
title: Устранение рисков. Десериализация объектов между доменами приложений
ms.date: 03/30/2017
ms.assetid: 30c2d66c-04a8-41a5-ad31-646b937f61b5
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: fd0cbd4c688815139d83a742bb75c54eebbe55b7
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2019
ms.locfileid: "64648477"
---
# <a name="mitigation-deserialization-of-objects-across-app-domains"></a>Устранение рисков. Десериализация объектов между доменами приложений
В некоторых случаях, когда приложение использует два или большее количество доменов с разными базовыми папками приложения, при попытке выполнить десериализацию объектов в логическом контексте вызова между доменами приложения возникнет исключение.  
  
## <a name="diagnosing-the-issue"></a>Диагностика проблемы  
 Проблема возникает при следующей последовательности условий.  
  
1. Приложение использует два или большее количество доменов приложений с разными базовыми папками приложения.  
  
2. Некоторые типы явно добавляются в <xref:System.Runtime.Remoting.Messaging.LogicalCallContext> путем вызова метода, например <xref:System.Runtime.Remoting.Messaging.LogicalCallContext.SetData%2A?displayProperty=nameWithType> или <xref:System.Runtime.Remoting.Messaging.CallContext.LogicalSetData%2A?displayProperty=nameWithType>. Эти типы не отмечены как сериализуемые и не сохраняются в глобальном кэше сборок.  
  
3. Затем код, выполняющийся в домене приложения не по умолчанию, пытается считать значение из файла конфигурации или использовать XML для десериализации объекта.  
  
4. Чтобы считать значение из файла конфигурации или десериализовать объект, объект <xref:System.Xml.XmlReader> пытается получить доступ к системе конфигурации.  
  
5. Если система конфигурации еще не была инициализирована, это следует сделать. Это означает, что, помимо прочего, среда выполнения должна создать стабильный путь для системы конфигурации, следующим образом.  
  
    1. Выполняется поиск сведений о том, что домен приложений не является доменом по умолчанию.  
  
    2. Среда выполнения пытается вычислить свидетельство наличия домена приложений не по умолчанию, основываясь на домене приложений по умолчанию.  
  
    3. Вызов для получения свидетельства о наличии домена приложений по умолчанию активирует вызов домена для нескольких приложений из домена приложений не по умолчанию в домен приложений по умолчанию.  
  
    4. Являясь частью контракта домена для нескольких приложений в .NET Framework, содержимое логического контекста вызова также должно быть маршалировано за пределами границ домена приложений.  
  
6. Поскольку типы логическом контексте вызова не могут быть разрешены в домене приложений по умолчанию, возникает исключение.  
  
## <a name="mitigation"></a>Устранение рисков  
 Чтобы устранить эту проблему, выполните следующие действия.  
  
1. При возникновении исключения найдите вызов `get_Evidence` в стеке вызовов. Может возникать любое исключение из подмножества исключений, включая <xref:System.IO.FileNotFoundException> и <xref:System.Runtime.Serialization.SerializationException>.  
  
2. Найдите в приложении место, где в логический контекст вызова не добавляются никакие объекты, и добавьте следующий код.  
  
    ```  
    System.Configuration.ConfigurationManager.GetSection("system.xml/xmlReader");  
    ```  
  
## <a name="see-also"></a>См. также

- [Изменения среды выполнения](../../../docs/framework/migration-guide/runtime-changes-in-the-net-framework-4-5-1.md)
