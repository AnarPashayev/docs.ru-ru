---
title: Основные сведения об изменении состояния
ms.date: 03/30/2017
ms.assetid: a79ed2aa-e49a-47a8-845a-c9f436ec9987
ms.openlocfilehash: 5bfee392053d9f3fd529d68b533a046e53f20dd1
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61771622"
---
# <a name="understanding-state-changes"></a><span data-ttu-id="e3601-102">Основные сведения об изменении состояния</span><span class="sxs-lookup"><span data-stu-id="e3601-102">Understanding State Changes</span></span>
<span data-ttu-id="e3601-103">В данном разделе рассматриваются состояния и переходы каналов, а также типы, используемые для структуризации каналов, и способы их реализации.</span><span class="sxs-lookup"><span data-stu-id="e3601-103">This topic discusses the states and transitions that channels have, the types used to structure channel states, and how to implement them.</span></span>  
  
## <a name="state-machines-and-channels"></a><span data-ttu-id="e3601-104">Конечные автоматы и каналы</span><span class="sxs-lookup"><span data-stu-id="e3601-104">State Machines and Channels</span></span>  
 <span data-ttu-id="e3601-105">Объекты, задействованные для связи, например сокеты, обычно представляют собой конечный автомат, переходы состояния которого связаны с выделением сетевых ресурсов, установлением и принятием соединений, а также закрытием соединений и завершением сеансов связи.</span><span class="sxs-lookup"><span data-stu-id="e3601-105">Objects that deal with communication, for example sockets, usually present a state machine whose state transitions relate to allocating network resources, making or accepting connections, closing connections and terminating communication.</span></span> <span data-ttu-id="e3601-106">Конечный автомат каналов обеспечивает единую модель состояний коммуникационного объекта, в которой приводится краткое описание базовой реализации данного объекта.</span><span class="sxs-lookup"><span data-stu-id="e3601-106">The channel state machine provides a uniform model of the states of a communication object that abstracts the underlying implementation of that object.</span></span> <span data-ttu-id="e3601-107">Интерфейс <xref:System.ServiceModel.ICommunicationObject> обеспечивает набор состояний, а также методы и события перехода состояний.</span><span class="sxs-lookup"><span data-stu-id="e3601-107">The <xref:System.ServiceModel.ICommunicationObject> interface provides a set of states, state transition methods and state transition events.</span></span> <span data-ttu-id="e3601-108">Все каналы, а также их фабрики и прослушиватели реализуют конечный автомат каналов.</span><span class="sxs-lookup"><span data-stu-id="e3601-108">All channels, channel factories and channel listeners implement the channel state machine.</span></span>  
  
 <span data-ttu-id="e3601-109">События Closed, Closing, Faulted, Opened и Opening уведомляют внешнего наблюдателя после перехода состояния.</span><span class="sxs-lookup"><span data-stu-id="e3601-109">The events Closed, Closing, Faulted, Opened and Opening signal an external observer after a state transition occurs.</span></span>  
  
 <span data-ttu-id="e3601-110">Методы Abort, Close и Open (а также их асинхронные эквиваленты) вызывают переходы состояния.</span><span class="sxs-lookup"><span data-stu-id="e3601-110">The methods Abort, Close, and Open (and their asynchronous equivalents) cause state transitions.</span></span>  
  
 <span data-ttu-id="e3601-111">Свойство состояния возвращает текущее состояние, определенное классом <xref:System.ServiceModel.CommunicationState>.</span><span class="sxs-lookup"><span data-stu-id="e3601-111">The state property returns the current state as defined by <xref:System.ServiceModel.CommunicationState>:</span></span>  
  
## <a name="icommunicationobject-communicationobject-and-states-and-state-transition"></a><span data-ttu-id="e3601-112">ICommunicationObject, CommunicationObject, а также состояния и переход состояния</span><span class="sxs-lookup"><span data-stu-id="e3601-112">ICommunicationObject, CommunicationObject, and States and State Transition</span></span>  
 <span data-ttu-id="e3601-113">Объект <xref:System.ServiceModel.ICommunicationObject> запускается в состоянии Created, где можно настроить его различные свойства.</span><span class="sxs-lookup"><span data-stu-id="e3601-113">An <xref:System.ServiceModel.ICommunicationObject> starts out in the Created state where its various properties can be configured.</span></span> <span data-ttu-id="e3601-114">В состоянии Opened объект используется для отправки и получения сообщений, но его свойства считаются неизменяемыми.</span><span class="sxs-lookup"><span data-stu-id="e3601-114">Once in the Opened state, the object is usable for sending and receiving messages but its properties are considered immutable.</span></span> <span data-ttu-id="e3601-115">В состоянии Closing объект больше не может обрабатывать новые запросы отправки и получения, но существующие запросы могут быть завершены, пока не истечет время ожидания закрытия.</span><span class="sxs-lookup"><span data-stu-id="e3601-115">Once in the Closing state, the object can no longer process new send or receive requests, but existing requests have a chance to complete until the Close timeout is reached.</span></span>  <span data-ttu-id="e3601-116">В случае неустранимой ошибки объект переходит в состояние Faulted, где можно проверить сведения об ошибке и в конечном счете закрыть объект.</span><span class="sxs-lookup"><span data-stu-id="e3601-116">If an unrecoverable error occurs, the object transitions to the Faulted state where it can be inspected for information about the error and ultimately closed.</span></span> <span data-ttu-id="e3601-117">В состоянии Closed объект по сути завершает конечный автомат.</span><span class="sxs-lookup"><span data-stu-id="e3601-117">When in the Closed state the object has essentially reached the end of the state machine.</span></span> <span data-ttu-id="e3601-118">После того как объект переходит из одного состояния в другое, он не возвращается в предыдущее состояние.</span><span class="sxs-lookup"><span data-stu-id="e3601-118">Once an object transitions from one state to the next, it does not go back to a previous state.</span></span>  
  
 <span data-ttu-id="e3601-119">На следующей схеме показаны состояния и переходы состояния объекта <xref:System.ServiceModel.ICommunicationObject>.</span><span class="sxs-lookup"><span data-stu-id="e3601-119">The following diagram shows the <xref:System.ServiceModel.ICommunicationObject> states and state transitions.</span></span> <span data-ttu-id="e3601-120">Переходы состояния может быть вызвана вызова одного из трех методов: Abort, Open или закрыть.</span><span class="sxs-lookup"><span data-stu-id="e3601-120">State transitions can be caused by calling one of the three methods: Abort, Open, or Close.</span></span> <span data-ttu-id="e3601-121">Их также можно вызвать другими методами, которые зависят от реализации.</span><span class="sxs-lookup"><span data-stu-id="e3601-121">They could also be caused by calling other implementation-specific methods.</span></span> <span data-ttu-id="e3601-122">Переход в состояние Faulted может произойти в результате ошибки во время или после открытия коммуникационного объекта.</span><span class="sxs-lookup"><span data-stu-id="e3601-122">Transitioning to the Faulted state could happen as a result of errors while opening or after having opened the communication object.</span></span>  
  
 <span data-ttu-id="e3601-123">Каждый объект <xref:System.ServiceModel.ICommunicationObject> запускается в состоянии Created.</span><span class="sxs-lookup"><span data-stu-id="e3601-123">Every <xref:System.ServiceModel.ICommunicationObject> starts out in the Created state.</span></span> <span data-ttu-id="e3601-124">В этом состоянии приложение может настраивать объект с помощью изменения его свойств.</span><span class="sxs-lookup"><span data-stu-id="e3601-124">In this state, an application can configure the object by setting its properties.</span></span> <span data-ttu-id="e3601-125">После того как объект находится в состоянии, отличном от Created, он считается неизменяемым.</span><span class="sxs-lookup"><span data-stu-id="e3601-125">Once an object is in a state other than Created, it is considered immutable.</span></span>  
  
 <span data-ttu-id="e3601-126">![Канал transitition состояние](../../../../docs/framework/wcf/extending/media/channelstatetranitionshighleveldiagram.gif "ChannelStateTranitionsHighLevelDiagram")</span><span class="sxs-lookup"><span data-stu-id="e3601-126">![Channel state transitition](../../../../docs/framework/wcf/extending/media/channelstatetranitionshighleveldiagram.gif "ChannelStateTranitionsHighLevelDiagram")</span></span>  
<span data-ttu-id="e3601-127">Рис. 1.</span><span class="sxs-lookup"><span data-stu-id="e3601-127">Figure 1.</span></span> <span data-ttu-id="e3601-128">Конечный автомат ICommunicationObject.</span><span class="sxs-lookup"><span data-stu-id="e3601-128">The ICommunicationObject State Machine.</span></span>  
  
 <span data-ttu-id="e3601-129">Windows Communication Foundation (WCF) предоставляет абстрактный базовый класс с именем <xref:System.ServiceModel.Channels.CommunicationObject> , реализующий <xref:System.ServiceModel.ICommunicationObject> и конечный автомат каналов.</span><span class="sxs-lookup"><span data-stu-id="e3601-129">Windows Communication Foundation (WCF) provides an abstract base class named <xref:System.ServiceModel.Channels.CommunicationObject> that implements <xref:System.ServiceModel.ICommunicationObject> and the channel state machine.</span></span> <span data-ttu-id="e3601-130">Ниже приведена схема изменившегося состояния, относящаяся к <xref:System.ServiceModel.Channels.CommunicationObject>.</span><span class="sxs-lookup"><span data-stu-id="e3601-130">The following graphic is a modified state diagram that is specific to <xref:System.ServiceModel.Channels.CommunicationObject>.</span></span> <span data-ttu-id="e3601-131">Кроме конечного автомата <xref:System.ServiceModel.ICommunicationObject>, на схеме также показано время, когда вызываются дополнительные методы <xref:System.ServiceModel.Channels.CommunicationObject>.</span><span class="sxs-lookup"><span data-stu-id="e3601-131">In addition to the <xref:System.ServiceModel.ICommunicationObject> state machine, it shows the timing when additional <xref:System.ServiceModel.Channels.CommunicationObject> methods are invoked.</span></span>  
  
 <span data-ttu-id="e3601-132">![Изменений состояния](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsigure5statetransitionsdetailsc.gif "wcfc_WCFChannelsigure5StateTransitionsDetailsc")</span><span class="sxs-lookup"><span data-stu-id="e3601-132">![State changes](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsigure5statetransitionsdetailsc.gif "wcfc_WCFChannelsigure5StateTransitionsDetailsc")</span></span>  
<span data-ttu-id="e3601-133">Рис. 2.</span><span class="sxs-lookup"><span data-stu-id="e3601-133">Figure 2.</span></span> <span data-ttu-id="e3601-134">Реализация CommunicationObject конечного автомата ICommunicationObject, включая вызовы событий и защищенных методов.</span><span class="sxs-lookup"><span data-stu-id="e3601-134">The CommunicationObject implementation of the ICommunicationObject state machine including calls to events and protected methods.</span></span>  
  
### <a name="icommunicationobject-events"></a><span data-ttu-id="e3601-135">События ICommunicationObject</span><span class="sxs-lookup"><span data-stu-id="e3601-135">ICommunicationObject Events</span></span>  
 <span data-ttu-id="e3601-136">Класс <xref:System.ServiceModel.Channels.CommunicationObject> предоставляет пять событий, определяемых <xref:System.ServiceModel.ICommunicationObject>.</span><span class="sxs-lookup"><span data-stu-id="e3601-136"><xref:System.ServiceModel.Channels.CommunicationObject> exposes the five events defined by <xref:System.ServiceModel.ICommunicationObject>.</span></span> <span data-ttu-id="e3601-137">Эти события предназначены, чтобы уведомить код, использующий коммуникационный объект, о переходах состояния.</span><span class="sxs-lookup"><span data-stu-id="e3601-137">These events are designed for code using the communication object to be notified of state transitions.</span></span> <span data-ttu-id="e3601-138">Как показано выше на рисунке 2, каждое событие выполняется после того как состояние объекта переходит в состояние с именем этого события.</span><span class="sxs-lookup"><span data-stu-id="e3601-138">As shown in Figure 2 above, each event is fired once after the object’s state transitions to the state named by the event.</span></span> <span data-ttu-id="e3601-139">Все пять событий относятся к типу `EventHandler`, который определяется следующим образом.</span><span class="sxs-lookup"><span data-stu-id="e3601-139">All five events are of the `EventHandler` type which is defined as:</span></span>  
  
 `public delegate void EventHandler(object sender, EventArgs e);`  
  
 <span data-ttu-id="e3601-140">В реализации <xref:System.ServiceModel.Channels.CommunicationObject> отправитель либо сам является объектом <xref:System.ServiceModel.Channels.CommunicationObject> либо тем, что было передано в качестве отправителя конструктору <xref:System.ServiceModel.Channels.CommunicationObject> (если используется эта перегрузка конструктора).</span><span class="sxs-lookup"><span data-stu-id="e3601-140">In the <xref:System.ServiceModel.Channels.CommunicationObject> implementation, the sender is either the <xref:System.ServiceModel.Channels.CommunicationObject> itself or whatever was passed in as the sender to the <xref:System.ServiceModel.Channels.CommunicationObject> constructor (if that constructor overload was used).</span></span> <span data-ttu-id="e3601-141">Значение параметра EventArgs (`e`) всегда равно `EventArgs.Empty`.</span><span class="sxs-lookup"><span data-stu-id="e3601-141">The EventArgs parameter, `e`, is always `EventArgs.Empty`.</span></span>  
  
### <a name="derived-object-callbacks"></a><span data-ttu-id="e3601-142">Обратные вызовы производного объекта</span><span class="sxs-lookup"><span data-stu-id="e3601-142">Derived Object Callbacks</span></span>  
 <span data-ttu-id="e3601-143">В дополнение к пяти событиям класс <xref:System.ServiceModel.Channels.CommunicationObject> объявляет восемь защищенных виртуальных методов, позволяющих выполнить обратный вызов объекта до или после переходов состояния.</span><span class="sxs-lookup"><span data-stu-id="e3601-143">In addition to the five events, <xref:System.ServiceModel.Channels.CommunicationObject> declares eight protected virtual methods designed to allow a derived object to be called back before and after state transitions occur.</span></span>  
  
 <span data-ttu-id="e3601-144">Для методов <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A?displayProperty=nameWithType> и <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A?displayProperty=nameWithType> имеется три обратных вызова, связанных с каждым из них.</span><span class="sxs-lookup"><span data-stu-id="e3601-144">The <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A?displayProperty=nameWithType> methods have three such callbacks associated with each of them.</span></span> <span data-ttu-id="e3601-145">Например, методу <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A?displayProperty=nameWithType> соответствуют методы <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%2A?displayProperty=nameWithType> и <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e3601-145">For example, corresponding to <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A?displayProperty=nameWithType> there is <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%2A?displayProperty=nameWithType>, and <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e3601-146">С методом <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A?displayProperty=nameWithType> связаны методы <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A?displayProperty=nameWithType> и <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e3601-146">Associated with <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A?displayProperty=nameWithType> are the <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A?displayProperty=nameWithType>, and <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="e3601-147">Аналогичным образом, методу <xref:System.ServiceModel.Channels.CommunicationObject.Abort%2A?displayProperty=nameWithType> соответствует метод <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e3601-147">Similarly, the <xref:System.ServiceModel.Channels.CommunicationObject.Abort%2A?displayProperty=nameWithType> method has a corresponding <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="e3601-148">Реализация по умолчанию отсутствует в методах <xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A?displayProperty=nameWithType> и <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A?displayProperty=nameWithType>, но она используется в других обратных вызовах, где реализация по умолчанию необходима для правильности конечного автомата.</span><span class="sxs-lookup"><span data-stu-id="e3601-148">While <xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A?displayProperty=nameWithType>, and <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A?displayProperty=nameWithType> have no default implementation, the other callbacks do have a default implementation which is necessary for state machine correctness.</span></span> <span data-ttu-id="e3601-149">Если эти методы переопределены, необходимо вызвать базовую реализацию или правильно заменить ее.</span><span class="sxs-lookup"><span data-stu-id="e3601-149">If you override those methods be sure to call the base implementation or correctly replace it.</span></span>  
  
 <span data-ttu-id="e3601-150"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A?displayProperty=nameWithType> и <xref:System.ServiceModel.Channels.CommunicationObject.OnFaulted%2A?displayProperty=nameWithType> вызывают соответствующие события <xref:System.ServiceModel.Channels.CommunicationObject.Opening?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.Closing?displayProperty=nameWithType> и <xref:System.ServiceModel.Channels.CommunicationObject.Faulted?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e3601-150"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.OnFaulted%2A?displayProperty=nameWithType> fire the corresponding <xref:System.ServiceModel.Channels.CommunicationObject.Opening?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.Closing?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.Faulted?displayProperty=nameWithType> events.</span></span> <span data-ttu-id="e3601-151"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A?displayProperty=nameWithType> и <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A?displayProperty=nameWithType> устанавливают объект в состояние Opened и Closed соответственно, а затем вызывают соответствующие события <xref:System.ServiceModel.Channels.CommunicationObject.Opened?displayProperty=nameWithType><xref:System.ServiceModel.Channels.CommunicationObject.Closed?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e3601-151"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A?displayProperty=nameWithType> set the object state to Opened and Closed respectively then fire the corresponding <xref:System.ServiceModel.Channels.CommunicationObject.Opened?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.Closed?displayProperty=nameWithType> events.</span></span>  
  
### <a name="state-transition-methods"></a><span data-ttu-id="e3601-152">Методы перехода состояния</span><span class="sxs-lookup"><span data-stu-id="e3601-152">State Transition Methods</span></span>  
 <span data-ttu-id="e3601-153">Класс <xref:System.ServiceModel.Channels.CommunicationObject> обеспечивает реализацию методов Abort, Close и Open.</span><span class="sxs-lookup"><span data-stu-id="e3601-153"><xref:System.ServiceModel.Channels.CommunicationObject> provides implementations of Abort, Close and Open.</span></span> <span data-ttu-id="e3601-154">Он также предоставляет метод Fault, вызывающий переход в состояние Faulted.</span><span class="sxs-lookup"><span data-stu-id="e3601-154">It also provides a Fault method which causes a state transition to the Faulted state.</span></span> <span data-ttu-id="e3601-155">На рисунке 2 показан конечный автомат <xref:System.ServiceModel.ICommunicationObject>, где каждый переход помечен методом, который его вызвал (непомеченные переходы выполняются внутри реализации метода, вызвавшего последний помеченный переход).</span><span class="sxs-lookup"><span data-stu-id="e3601-155">Figure 2 shows the <xref:System.ServiceModel.ICommunicationObject> state machine with each transition labeled by the method that causes it (unlabeled transitions happen inside the implementation of the method that caused the last labeled transition).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e3601-156">Все реализации <xref:System.ServiceModel.Channels.CommunicationObject> для получения или задания состояния связи синхронизированы с потоком.</span><span class="sxs-lookup"><span data-stu-id="e3601-156">All <xref:System.ServiceModel.Channels.CommunicationObject> implementations of communication state gets/sets are thread-synchronized.</span></span>  
  
 <span data-ttu-id="e3601-157">Конструктор</span><span class="sxs-lookup"><span data-stu-id="e3601-157">Constructor</span></span>  
  
 <span data-ttu-id="e3601-158">Класс <xref:System.ServiceModel.Channels.CommunicationObject> предоставляет три конструктора, которые оставляют объект в состоянии Created.</span><span class="sxs-lookup"><span data-stu-id="e3601-158"><xref:System.ServiceModel.Channels.CommunicationObject> provides three constructors, all of which leave the object in the Created state.</span></span> <span data-ttu-id="e3601-159">Конструкторы определяются следующим образом.</span><span class="sxs-lookup"><span data-stu-id="e3601-159">The constructors are defined as:</span></span>  
  
 <span data-ttu-id="e3601-160">Первый конструктор - это конструктор по умолчанию, который делегирует перегрузке конструктора, приминающей объект:</span><span class="sxs-lookup"><span data-stu-id="e3601-160">The first constructor is a default constructor that delegates to the constructor overload that takes an object:</span></span>  
  
 `protected CommunicationObject() : this(new object()) { … }`  
  
 <span data-ttu-id="e3601-161">Конструктор, принимающий объект, использует этот параметр в качестве объекта, который будет заблокирован при синхронизации доступа к состоянию коммуникационного объекта:</span><span class="sxs-lookup"><span data-stu-id="e3601-161">The constructor that takes an object uses that parameter as the object to be locked when synchronizing access to communication object state:</span></span>  
  
 `protected CommunicationObject(object mutex) { … }`  
  
 <span data-ttu-id="e3601-162">Наконец, третий конструктор принимает дополнительный параметр, используемый в качестве аргумента отправителя при запуске событий <xref:System.ServiceModel.ICommunicationObject>.</span><span class="sxs-lookup"><span data-stu-id="e3601-162">Finally, a third constructor takes an additional parameter that is used as the sender argument when <xref:System.ServiceModel.ICommunicationObject> events are fired.</span></span>  
  
 `protected CommunicationObject(object mutex, object eventSender) { … }`  
  
 <span data-ttu-id="e3601-163">Предыдущие два конструктора задают для отправителя следующие параметры.</span><span class="sxs-lookup"><span data-stu-id="e3601-163">The previous two constructors set the sender to this.</span></span>  
  
 <span data-ttu-id="e3601-164">Метод Open</span><span class="sxs-lookup"><span data-stu-id="e3601-164">Open Method</span></span>  
  
 <span data-ttu-id="e3601-165">Предусловие: Состояние Created.</span><span class="sxs-lookup"><span data-stu-id="e3601-165">Precondition: State is Created.</span></span>  
  
 <span data-ttu-id="e3601-166">Постусловие: Находится в состоянии Opened или Faulted.</span><span class="sxs-lookup"><span data-stu-id="e3601-166">Post-condition: State is Opened or Faulted.</span></span> <span data-ttu-id="e3601-167">Может создаваться исключение.</span><span class="sxs-lookup"><span data-stu-id="e3601-167">May throw an exception.</span></span>  
  
 <span data-ttu-id="e3601-168">Метод Open() попытается открыть коммуникационный объект и установить состояние Opened.</span><span class="sxs-lookup"><span data-stu-id="e3601-168">The Open() method will try to open the communication object and set the state to Opened.</span></span> <span data-ttu-id="e3601-169">При возникновении ошибки метод установит состояние Faulted.</span><span class="sxs-lookup"><span data-stu-id="e3601-169">If it encounters an error, it will set the state to Faulted.</span></span>  
  
 <span data-ttu-id="e3601-170">Метод сначала проверяет, что текущим состоянием является Created.</span><span class="sxs-lookup"><span data-stu-id="e3601-170">The method first checks that the current state is Created.</span></span> <span data-ttu-id="e3601-171">Если текущим состоянием является Opening или Opened, метод создает исключение <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="e3601-171">If the current state is Opening or Opened it throws an <xref:System.InvalidOperationException>.</span></span> <span data-ttu-id="e3601-172">Если текущим состоянием является Closing или Closed, метод создает исключение <xref:System.ServiceModel.CommunicationObjectAbortedException>, если объект был завершен, в противном случае - <xref:System.ObjectDisposedException>.</span><span class="sxs-lookup"><span data-stu-id="e3601-172">If the current state is Closing or Closed, it throws a <xref:System.ServiceModel.CommunicationObjectAbortedException> if the object has been terminated and <xref:System.ObjectDisposedException> otherwise.</span></span> <span data-ttu-id="e3601-173">Если текущим состоянием является Faulted, метод создает исключение <xref:System.ServiceModel.CommunicationObjectFaultedException>.</span><span class="sxs-lookup"><span data-stu-id="e3601-173">If the current state is Faulted, it throws a <xref:System.ServiceModel.CommunicationObjectFaultedException>.</span></span>  
  
 <span data-ttu-id="e3601-174">Затем устанавливается состояние Opening и вызывается метод OnOpening() (создающий событие Opening), OnOpen() и OnOpened() в указанном порядке.</span><span class="sxs-lookup"><span data-stu-id="e3601-174">It then sets the state to Opening and calls OnOpening() (which raises the Opening event), OnOpen() and OnOpened() in that order.</span></span> <span data-ttu-id="e3601-175">Метод OnOpened() устанавливает состояние Opened и вызывает событие Opened.</span><span class="sxs-lookup"><span data-stu-id="e3601-175">OnOpened() sets the state to Opened and raises the Opened event.</span></span> <span data-ttu-id="e3601-176">Если любое из этих событий создает исключение, метод Open() вызывает Fault() и выдает исключение.</span><span class="sxs-lookup"><span data-stu-id="e3601-176">If any of these throws an exception, Open()calls Fault() and lets the exception bubble up.</span></span> <span data-ttu-id="e3601-177">Следующая схема содержит подробные сведения о процессе Open.</span><span class="sxs-lookup"><span data-stu-id="e3601-177">The following diagram shows the Open process in more detail.</span></span>  
  
 <span data-ttu-id="e3601-178">![Изменений состояния](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsigurecoopenflowchartf.gif "wcfc_WCFChannelsigureCOOpenFlowChartf")</span><span class="sxs-lookup"><span data-stu-id="e3601-178">![State changes](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsigurecoopenflowchartf.gif "wcfc_WCFChannelsigureCOOpenFlowChartf")</span></span>  
<span data-ttu-id="e3601-179">Переопределите метод OnOpen, чтобы реализовать пользовательскую логику открытия, например, открыть внутренний коммуникационный объект.</span><span class="sxs-lookup"><span data-stu-id="e3601-179">Override the OnOpen method to implement custom open logic such as opening an inner communication object.</span></span>  
  
 <span data-ttu-id="e3601-180">Метод Close</span><span class="sxs-lookup"><span data-stu-id="e3601-180">Close Method</span></span>  
  
 <span data-ttu-id="e3601-181">Предусловие: Отсутствует.</span><span class="sxs-lookup"><span data-stu-id="e3601-181">Precondition: None.</span></span>  
  
 <span data-ttu-id="e3601-182">Постусловие: Состояние Closed.</span><span class="sxs-lookup"><span data-stu-id="e3601-182">Post-condition: State is Closed.</span></span> <span data-ttu-id="e3601-183">Может создаваться исключение.</span><span class="sxs-lookup"><span data-stu-id="e3601-183">May throw an exception.</span></span>  
  
 <span data-ttu-id="e3601-184">Метод Close() можно вызвать в любом состоянии.</span><span class="sxs-lookup"><span data-stu-id="e3601-184">The Close() method can be called at any state.</span></span> <span data-ttu-id="e3601-185">Метод пытается закрыть объект в обычном режиме.</span><span class="sxs-lookup"><span data-stu-id="e3601-185">It tries to close the object normally.</span></span> <span data-ttu-id="e3601-186">Если происходит ошибка, метод завершает выполнение объекта.</span><span class="sxs-lookup"><span data-stu-id="e3601-186">If an error is encountered, it terminates the object.</span></span> <span data-ttu-id="e3601-187">Метод не выполняет никаких действий, если текущим состоянием является Closing или Closed.</span><span class="sxs-lookup"><span data-stu-id="e3601-187">The method does nothing if the current state is Closing or Closed.</span></span> <span data-ttu-id="e3601-188">В противном случае он устанавливает состояние Closing.</span><span class="sxs-lookup"><span data-stu-id="e3601-188">Otherwise it sets the state to Closing.</span></span> <span data-ttu-id="e3601-189">Если исходным состоянием является Created, Opening или Faulted, метод вызывает Abort() (см. следующую схему).</span><span class="sxs-lookup"><span data-stu-id="e3601-189">If the original state was Created, Opening or Faulted, it calls Abort() (see the following diagram).</span></span> <span data-ttu-id="e3601-190">Если исходным состоянием является Opened, вызывается метод OnClosing() (создающий событие Closing), OnClose() и OnClosed() в указанном порядке.</span><span class="sxs-lookup"><span data-stu-id="e3601-190">If the original state was Opened, it calls OnClosing() (which raises the Closing event), OnClose() and OnClosed() in that order.</span></span> <span data-ttu-id="e3601-191">Если любое из этих событий создает исключение, метод Close() вызывает Abort() и выдает исключение.</span><span class="sxs-lookup"><span data-stu-id="e3601-191">If any of these throws an exception, Close()calls Abort() and lets the exception bubble up.</span></span> <span data-ttu-id="e3601-192">Метод OnClosed() устанавливает состояние Closed и вызывает событие Closed.</span><span class="sxs-lookup"><span data-stu-id="e3601-192">OnClosed() sets the state to Closed and raises the Closed event.</span></span> <span data-ttu-id="e3601-193">Следующая схема содержит подробные сведения о процессе Close.</span><span class="sxs-lookup"><span data-stu-id="e3601-193">The following diagram shows the Close process in more detail.</span></span>  
  
 <span data-ttu-id="e3601-194">![Изменений состояния](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsguire7ico-closeflowchartc.gif "wcfc_WCFChannelsguire7ICO CloseFlowChartc")</span><span class="sxs-lookup"><span data-stu-id="e3601-194">![State changes](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsguire7ico-closeflowchartc.gif "wcfc_WCFChannelsguire7ICO-CloseFlowChartc")</span></span>  
<span data-ttu-id="e3601-195">Переопределите метод OnClose, чтобы реализовать пользовательскую логику закрытия, например, закрыть внутренний коммуникационный объект.</span><span class="sxs-lookup"><span data-stu-id="e3601-195">Override the OnClose method to implement custom close logic, such as closing an inner communication object.</span></span> <span data-ttu-id="e3601-196">Для мягкой логики закрытия, которая может выполнять блокировку на длительное время (например, для ожидания ответа другой стороны), следует реализовать метод OnClose(), поскольку он использует параметр времени ожидания и не вызывается как часть Abort().</span><span class="sxs-lookup"><span data-stu-id="e3601-196">All graceful closing logic that may block for a long time (for example, waiting for the other side to respond) should be implemented in OnClose() because it takes a timeout parameter and because it is not called as part of Abort().</span></span>  
  
 <span data-ttu-id="e3601-197">Прервать</span><span class="sxs-lookup"><span data-stu-id="e3601-197">Abort</span></span>  
  
 <span data-ttu-id="e3601-198">Предусловие: Отсутствует.</span><span class="sxs-lookup"><span data-stu-id="e3601-198">Precondition: None.</span></span>  
<span data-ttu-id="e3601-199">Постусловие: Состояние Closed.</span><span class="sxs-lookup"><span data-stu-id="e3601-199">Post-condition: State is Closed.</span></span> <span data-ttu-id="e3601-200">Может создаваться исключение.</span><span class="sxs-lookup"><span data-stu-id="e3601-200">May throw an exception.</span></span>  
  
 <span data-ttu-id="e3601-201">Метод Abort() не выполняет никаких действий, если текущим состоянием является Closed или объект был завершен ранее (например, с помощью выполнения метода Abort() в другом потоке).</span><span class="sxs-lookup"><span data-stu-id="e3601-201">The Abort() method does nothing if the current state is Closed or if the object has been terminated before (for example, possibly by having Abort() executing on another thread).</span></span> <span data-ttu-id="e3601-202">В противном случае устанавливается состояние Closing и вызывается метод OnClosing() (создающий событие Closing), OnAbort() и OnClosed() в указанном порядке (метод OnClose не вызывается, поскольку объект завершается, а не закрывается).</span><span class="sxs-lookup"><span data-stu-id="e3601-202">Otherwise it sets the state to Closing and calls OnClosing() (which raises the Closing event), OnAbort(), and OnClosed() in that order (does not call OnClose because the object is being terminated, not closed).</span></span> <span data-ttu-id="e3601-203">Метод OnClosed() устанавливает состояние Closed и вызывает событие Closed.</span><span class="sxs-lookup"><span data-stu-id="e3601-203">OnClosed() sets the state to Closed and raises the Closed event.</span></span> <span data-ttu-id="e3601-204">Если какое-либо из этих событий создает исключение, оно повторно выдается объекту, вызвавшему метод Abort.</span><span class="sxs-lookup"><span data-stu-id="e3601-204">If any of these throw an exception, it is re-thrown to the caller of Abort.</span></span> <span data-ttu-id="e3601-205">Реализации методов OnClosing(), OnClosed() и OnAbort() не должны выполнять блокировку (например, ввода-вывода).</span><span class="sxs-lookup"><span data-stu-id="e3601-205">Implementations of OnClosing(), OnClosed() and OnAbort() should not block (for example, on input/output).</span></span> <span data-ttu-id="e3601-206">Следующая схема содержит подробные сведения о процессе Abort.</span><span class="sxs-lookup"><span data-stu-id="e3601-206">The following diagram shows the Abort process in more detail.</span></span>  
  
 <span data-ttu-id="e3601-207">![Изменений состояния](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsigure8ico-abortflowchartc.gif "wcfc_WCFChannelsigure8ICO AbortFlowChartc")</span><span class="sxs-lookup"><span data-stu-id="e3601-207">![State changes](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsigure8ico-abortflowchartc.gif "wcfc_WCFChannelsigure8ICO-AbortFlowChartc")</span></span>  
<span data-ttu-id="e3601-208">Переопределите метод OnAbort, чтобы реализовать пользовательскую логику завершения, например, завершить внутренний коммуникационный объект.</span><span class="sxs-lookup"><span data-stu-id="e3601-208">Override the OnAbort method to implement custom terminate logic such as terminating an inner communication object.</span></span>  
  
 <span data-ttu-id="e3601-209">Fault</span><span class="sxs-lookup"><span data-stu-id="e3601-209">Fault</span></span>  
  
 <span data-ttu-id="e3601-210">Метод Fault относится конкретно к классу <xref:System.ServiceModel.Channels.CommunicationObject> и не является частью интерфейса <xref:System.ServiceModel.ICommunicationObject>.</span><span class="sxs-lookup"><span data-stu-id="e3601-210">The Fault method is specific to <xref:System.ServiceModel.Channels.CommunicationObject> and is not part of the <xref:System.ServiceModel.ICommunicationObject> interface.</span></span> <span data-ttu-id="e3601-211">Указан для полноты представления информации.</span><span class="sxs-lookup"><span data-stu-id="e3601-211">It is included here for completeness.</span></span>  
  
 <span data-ttu-id="e3601-212">Предусловие: Отсутствует.</span><span class="sxs-lookup"><span data-stu-id="e3601-212">Precondition: None.</span></span>  
  
 <span data-ttu-id="e3601-213">Постусловие: Состояние Faulted.</span><span class="sxs-lookup"><span data-stu-id="e3601-213">Post-condition: State is Faulted.</span></span> <span data-ttu-id="e3601-214">Может создаваться исключение.</span><span class="sxs-lookup"><span data-stu-id="e3601-214">May throw an exception.</span></span>  
  
 <span data-ttu-id="e3601-215">Метод Fault() не выполняет никаких действий, если текущим состоянием является Faulted или Closed.</span><span class="sxs-lookup"><span data-stu-id="e3601-215">The Fault() method does nothing if the current state is Faulted or Closed.</span></span> <span data-ttu-id="e3601-216">В противном случае устанавливается состояние Faulted и вызывается метод OnFaulted(), который создает событие Faulted.</span><span class="sxs-lookup"><span data-stu-id="e3601-216">Otherwise it sets the state to Faulted and call OnFaulted(), which raises the Faulted event.</span></span> <span data-ttu-id="e3601-217">Если метод OnFaulted вызывает исключение, оно вызывается повторно.</span><span class="sxs-lookup"><span data-stu-id="e3601-217">If OnFaulted throws an exception it is re-thrown.</span></span>  
  
### <a name="throwifxxx-methods"></a><span data-ttu-id="e3601-218">Методы ThrowIfXxx</span><span class="sxs-lookup"><span data-stu-id="e3601-218">ThrowIfXxx Methods</span></span>  
 <span data-ttu-id="e3601-219">В классе CommunicationObject имеется три защищенных метода, которые можно использовать для вызова исключений, если объект находится в определенном состоянии.</span><span class="sxs-lookup"><span data-stu-id="e3601-219">CommunicationObject has three protected methods that can be used to throw exceptions if the object is in a specific state.</span></span>  
  
 <span data-ttu-id="e3601-220"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposed%2A> вызывает исключение в состоянии Closing, Closed или Faulted.</span><span class="sxs-lookup"><span data-stu-id="e3601-220"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposed%2A> throws an exception if the state is Closing, Closed or Faulted.</span></span>  
  
 <span data-ttu-id="e3601-221"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrImmutable%2A> вызывает исключение, если состояние отлично от Created.</span><span class="sxs-lookup"><span data-stu-id="e3601-221"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrImmutable%2A> throws an exception if the state is not Created.</span></span>  
  
 <span data-ttu-id="e3601-222"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrNotOpen%2A> вызывает исключение, если состояние отлично от Opened.</span><span class="sxs-lookup"><span data-stu-id="e3601-222"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrNotOpen%2A> throws an exception if the state is not Opened.</span></span>  
  
 <span data-ttu-id="e3601-223">Вызываемые исключения зависят от состояния.</span><span class="sxs-lookup"><span data-stu-id="e3601-223">The exceptions thrown depend on the state.</span></span> <span data-ttu-id="e3601-224">В следующей таблице показаны различные состояния и соответствующие типы исключений, которые метод ThrowIfXxx вызывает для них.</span><span class="sxs-lookup"><span data-stu-id="e3601-224">The following table shows the different states and the corresponding exception type thrown by calling a ThrowIfXxx that throws on that state.</span></span>  
  
|<span data-ttu-id="e3601-225">Регион</span><span class="sxs-lookup"><span data-stu-id="e3601-225">State</span></span>|<span data-ttu-id="e3601-226">Вызван метод Abort?</span><span class="sxs-lookup"><span data-stu-id="e3601-226">Has Abort been called?</span></span>|<span data-ttu-id="e3601-227">Исключение</span><span class="sxs-lookup"><span data-stu-id="e3601-227">Exception</span></span>|  
|-----------|----------------------------|---------------|  
|<span data-ttu-id="e3601-228">Создано</span><span class="sxs-lookup"><span data-stu-id="e3601-228">Created</span></span>|<span data-ttu-id="e3601-229">Н/Д</span><span class="sxs-lookup"><span data-stu-id="e3601-229">N/A</span></span>|<xref:System.InvalidOperationException?displayProperty=nameWithType>|  
|<span data-ttu-id="e3601-230">Открытие</span><span class="sxs-lookup"><span data-stu-id="e3601-230">Opening</span></span>|<span data-ttu-id="e3601-231">Н/Д</span><span class="sxs-lookup"><span data-stu-id="e3601-231">N/A</span></span>|<xref:System.InvalidOperationException?displayProperty=nameWithType>|  
|<span data-ttu-id="e3601-232">Открыто</span><span class="sxs-lookup"><span data-stu-id="e3601-232">Opened</span></span>|<span data-ttu-id="e3601-233">Н/Д</span><span class="sxs-lookup"><span data-stu-id="e3601-233">N/A</span></span>|<xref:System.InvalidOperationException?displayProperty=nameWithType>|  
|<span data-ttu-id="e3601-234">закрытие</span><span class="sxs-lookup"><span data-stu-id="e3601-234">Closing</span></span>|<span data-ttu-id="e3601-235">Да</span><span class="sxs-lookup"><span data-stu-id="e3601-235">Yes</span></span>|<xref:System.ServiceModel.CommunicationObjectAbortedException?displayProperty=nameWithType>|  
|<span data-ttu-id="e3601-236">закрытие</span><span class="sxs-lookup"><span data-stu-id="e3601-236">Closing</span></span>|<span data-ttu-id="e3601-237">Нет</span><span class="sxs-lookup"><span data-stu-id="e3601-237">No</span></span>|<xref:System.ObjectDisposedException?displayProperty=nameWithType>|  
|<span data-ttu-id="e3601-238">Closed</span><span class="sxs-lookup"><span data-stu-id="e3601-238">Closed</span></span>|<span data-ttu-id="e3601-239">Да</span><span class="sxs-lookup"><span data-stu-id="e3601-239">Yes</span></span>|<span data-ttu-id="e3601-240">Исключение <xref:System.ServiceModel.CommunicationObjectAbortedException?displayProperty=nameWithType>, если объект был закрыт предыдущим и явным вызовом метода Abort.</span><span class="sxs-lookup"><span data-stu-id="e3601-240"><xref:System.ServiceModel.CommunicationObjectAbortedException?displayProperty=nameWithType> in the case that an object was closed by a previous and explicit call of Abort.</span></span> <span data-ttu-id="e3601-241">При вызове метода Close для объекта выдается исключение <xref:System.ObjectDisposedException?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e3601-241">If you call Close on the object then an <xref:System.ObjectDisposedException?displayProperty=nameWithType> is thrown.</span></span>|  
|<span data-ttu-id="e3601-242">Closed</span><span class="sxs-lookup"><span data-stu-id="e3601-242">Closed</span></span>|<span data-ttu-id="e3601-243">Нет</span><span class="sxs-lookup"><span data-stu-id="e3601-243">No</span></span>|<xref:System.ObjectDisposedException?displayProperty=nameWithType>|  
|<span data-ttu-id="e3601-244">Faulted</span><span class="sxs-lookup"><span data-stu-id="e3601-244">Faulted</span></span>|<span data-ttu-id="e3601-245">Н/Д</span><span class="sxs-lookup"><span data-stu-id="e3601-245">N/A</span></span>|<xref:System.ServiceModel.CommunicationObjectFaultedException?displayProperty=nameWithType>|  
  
### <a name="timeouts"></a><span data-ttu-id="e3601-246">Время ожидания</span><span class="sxs-lookup"><span data-stu-id="e3601-246">Timeouts</span></span>  
 <span data-ttu-id="e3601-247">Некоторые из рассмотренных методов используют параметры времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="e3601-247">Several of the methods we discussed take timeout parameters.</span></span> <span data-ttu-id="e3601-248">Это методы Close, Open (некоторые перегрузки и асинхронные версии), OnClose и OnOpen.</span><span class="sxs-lookup"><span data-stu-id="e3601-248">These are Close, Open (certain overloads and asynchronous versions), OnClose and OnOpen.</span></span> <span data-ttu-id="e3601-249">Эти методы позволяют использовать длительные операции (например, блокирование при вводе-выводе во время мягкого закрытия соединения), поэтому параметр времени ожидания указывает, как долго могут продолжаться такие операции до прерывания.</span><span class="sxs-lookup"><span data-stu-id="e3601-249">These methods are designed to allow for lengthy operations (for example, blocking on input/output while gracefully closing down a connection) so the timeout parameter indicates how long such operations can take before being interrupted.</span></span> <span data-ttu-id="e3601-250">В реализациях любых методов необходимо использовать предоставленное значение времени ожидания, чтобы оно возвращалось к вызывающей стороне в течение этого времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="e3601-250">Implementations of any of these methods should use the supplied timeout value to ensure it returns to the caller within that timeout.</span></span> <span data-ttu-id="e3601-251">Реализации других методов, которые не используют время ожидания, не предназначены для длительных операций и не должны блокироваться при вводе-выводе.</span><span class="sxs-lookup"><span data-stu-id="e3601-251">Implementations of other methods that do not take a timeout are not designed for lengthy operations and should not block on input/output.</span></span>  
  
 <span data-ttu-id="e3601-252">Исключениями являются перегрузки Open() и Close(), которые не используют параметр времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="e3601-252">The exception are the Open() and Close() overloads that do not take a timeout.</span></span> <span data-ttu-id="e3601-253">Они используют значение времени ожидания по умолчанию, предоставленное производным классом.</span><span class="sxs-lookup"><span data-stu-id="e3601-253">These use a default timeout value supplied by the derived class.</span></span> <span data-ttu-id="e3601-254"><xref:System.ServiceModel.Channels.CommunicationObject> обеспечивает доступ к двум абстрактным свойствам с именами <xref:System.ServiceModel.Channels.CommunicationObject.DefaultCloseTimeout%2A> и <xref:System.ServiceModel.Channels.CommunicationObject.DefaultOpenTimeout%2A>, которые определены как:</span><span class="sxs-lookup"><span data-stu-id="e3601-254"><xref:System.ServiceModel.Channels.CommunicationObject> exposes two protected abstract properties named <xref:System.ServiceModel.Channels.CommunicationObject.DefaultCloseTimeout%2A> and <xref:System.ServiceModel.Channels.CommunicationObject.DefaultOpenTimeout%2A> defined as:</span></span>  
  
 `protected abstract TimeSpan DefaultCloseTimeout { get; }`  
  
 `protected abstract TimeSpan DefaultOpenTimeout { get; }`  
  
 <span data-ttu-id="e3601-255">Производный класс реализует эти свойства, чтобы предоставить время ожидания по умолчанию для перегрузок Open() и Close(), не использующих значение по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="e3601-255">A derived class implements these properties to provide the default timeout for the Open() and Close() overloads that do not take a timeout value.</span></span> <span data-ttu-id="e3601-256">Затем в реализациях Open() и Close() выполняется делегирование в перегрузку, которая передает время ожидания в значение времени ожидания по умолчанию, например:</span><span class="sxs-lookup"><span data-stu-id="e3601-256">Then the Open() and Close() implementations delegate to the overload that takes a timeout passing it the default timeout value, for example:</span></span>  
  
 `public void Open()`  
  
 `{`  
  
 `this.Open(this.DefaultOpenTimeout);`  
  
 `}`  
  
#### <a name="idefaultcommunicationtimeouts"></a><span data-ttu-id="e3601-257">IDefaultCommunicationTimeouts</span><span class="sxs-lookup"><span data-stu-id="e3601-257">IDefaultCommunicationTimeouts</span></span>  
 <span data-ttu-id="e3601-258">В этом интерфейсе имеется четыре свойства только для чтения, которые предоставляют значения времени по умолчанию для открытия, отправки, получения и закрытия.</span><span class="sxs-lookup"><span data-stu-id="e3601-258">This interface has four read-only properties for providing default timeout values for open, send, receive, and close.</span></span> <span data-ttu-id="e3601-259">Каждая реализация отвечает за получение значений по умолчанию соответствующим образом.</span><span class="sxs-lookup"><span data-stu-id="e3601-259">Each implementation is responsible for obtaining the default values in whatever manner appropriate.</span></span> <span data-ttu-id="e3601-260">Для удобства в классах <xref:System.ServiceModel.Channels.ChannelFactoryBase> и <xref:System.ServiceModel.Channels.ChannelListenerBase> по умолчанию используется значение 1 минута.</span><span class="sxs-lookup"><span data-stu-id="e3601-260">As a convenience, <xref:System.ServiceModel.Channels.ChannelFactoryBase> and <xref:System.ServiceModel.Channels.ChannelListenerBase> default these values to 1 minute each.</span></span>
