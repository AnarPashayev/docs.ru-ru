---
title: Выбор шаблона обмена сообщениями
ms.date: 03/30/2017
ms.assetid: 0f502ca1-6a8e-4607-ba15-59198c0e6146
ms.openlocfilehash: 98788fb89fc68dc1220d9bf8d9ad89df5ca69e6e
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61922867"
---
# <a name="choosing-a-message-exchange-pattern"></a><span data-ttu-id="def9b-102">Выбор шаблона обмена сообщениями</span><span class="sxs-lookup"><span data-stu-id="def9b-102">Choosing a Message Exchange Pattern</span></span>
<span data-ttu-id="def9b-103">Является первым шагом в создании пользовательского транспорта необходимо решить, какие *шаблоны обмена сообщениями* (или MEP) требуются для разрабатываемого канала.</span><span class="sxs-lookup"><span data-stu-id="def9b-103">The first step in writing a custom transport is to decide which *message exchange patterns* (or MEPs) are required for the channel you are developing.</span></span> <span data-ttu-id="def9b-104">В этом разделе описаны возможные варианты и различные требования.</span><span class="sxs-lookup"><span data-stu-id="def9b-104">This topic describes the options available and discusses the various requirements.</span></span> <span data-ttu-id="def9b-105">Это первая задача в списке задач разработки канала, описанные в [каналы развивающихся](../../../../docs/framework/wcf/extending/developing-channels.md).</span><span class="sxs-lookup"><span data-stu-id="def9b-105">This is the first task in the channel development task list described in [Developing Channels](../../../../docs/framework/wcf/extending/developing-channels.md).</span></span>  
  
## <a name="six-message-exchange-patterns"></a><span data-ttu-id="def9b-106">Шесть шаблонов обмена сообщениями</span><span class="sxs-lookup"><span data-stu-id="def9b-106">Six Message Exchange Patterns</span></span>  
 <span data-ttu-id="def9b-107">Можно выбирать из трех шаблонов обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="def9b-107">There are three MEPs to choose from:</span></span>  
  
- <span data-ttu-id="def9b-108">Датаграмма (<xref:System.ServiceModel.Channels.IInputChannel> и <xref:System.ServiceModel.Channels.IOutputChannel>)</span><span class="sxs-lookup"><span data-stu-id="def9b-108">Datagram (<xref:System.ServiceModel.Channels.IInputChannel> and <xref:System.ServiceModel.Channels.IOutputChannel>)</span></span>  
  
     <span data-ttu-id="def9b-109">Если вы используете датаграмму шаблон обмена Сообщениями, клиент отправляет сообщения с помощью *отправить и забыть* exchange.</span><span class="sxs-lookup"><span data-stu-id="def9b-109">When using a datagram MEP, a client sends a message using a *fire and forget* exchange.</span></span> <span data-ttu-id="def9b-110">В этом случае требуется внешнее подтверждение успешной доставки.</span><span class="sxs-lookup"><span data-stu-id="def9b-110">A fire and forget exchange is one that requires out-of-band confirmation of successful delivery.</span></span> <span data-ttu-id="def9b-111">Сообщение может быть потеряно при передаче и может не достичь службы.</span><span class="sxs-lookup"><span data-stu-id="def9b-111">The message might be lost in transit and never reach the service.</span></span> <span data-ttu-id="def9b-112">Если операция отправки успешно выполняется на стороне клиента, это не гарантирует, что удаленная конечная точка получит сообщение.</span><span class="sxs-lookup"><span data-stu-id="def9b-112">If the send operation completes successfully at the client end, it does not guarantee that the remote endpoint has received the message.</span></span> <span data-ttu-id="def9b-113">Датаграмма - фундаментальный элемент обмена сообщениями, на основе которого можно строить собственные протоколы, в том числе надежные и безопасные.</span><span class="sxs-lookup"><span data-stu-id="def9b-113">The datagram is a fundamental building block for messaging, as you can build your own protocols on top of it—including reliable protocols and secure protocols.</span></span> <span data-ttu-id="def9b-114">Каналы датаграмм клиентов реализуют интерфейс <xref:System.ServiceModel.Channels.IOutputChannel>, а каналы датаграмм служб - интерфейс <xref:System.ServiceModel.Channels.IInputChannel>.</span><span class="sxs-lookup"><span data-stu-id="def9b-114">Client datagram channels implement the <xref:System.ServiceModel.Channels.IOutputChannel> interface and service datagram channels implement the <xref:System.ServiceModel.Channels.IInputChannel> interface.</span></span>  
  
- <span data-ttu-id="def9b-115">Запрос-ответ (<xref:System.ServiceModel.Channels.IRequestChannel> и <xref:System.ServiceModel.Channels.IReplyChannel>)</span><span class="sxs-lookup"><span data-stu-id="def9b-115">Request-Response (<xref:System.ServiceModel.Channels.IRequestChannel> and <xref:System.ServiceModel.Channels.IReplyChannel>)</span></span>  
  
     <span data-ttu-id="def9b-116">При использовании этого шаблона происходит отправка сообщения и получение ответа.</span><span class="sxs-lookup"><span data-stu-id="def9b-116">In this MEP, a message is sent, and a reply is received.</span></span> <span data-ttu-id="def9b-117">Шаблон состоит из пар «запрос-ответ».</span><span class="sxs-lookup"><span data-stu-id="def9b-117">The pattern consists of request-response pairs.</span></span> <span data-ttu-id="def9b-118">Примерами вызовов "запрос-ответ" являются удаленные вызовы процедур (RPC) и запросы GET браузера.</span><span class="sxs-lookup"><span data-stu-id="def9b-118">Examples of request-response calls are remote procedure calls (RPC) and browser GET requests.</span></span> <span data-ttu-id="def9b-119">Этот шаблон также называют полудуплексным.</span><span class="sxs-lookup"><span data-stu-id="def9b-119">This pattern is also known as half-duplex.</span></span> <span data-ttu-id="def9b-120">При использовании этого шаблона обмена сообщениями каналы клиентов реализуют интерфейс <xref:System.ServiceModel.Channels.IRequestChannel>, а каналы служб - интерфейс <xref:System.ServiceModel.Channels.IReplyChannel>.</span><span class="sxs-lookup"><span data-stu-id="def9b-120">In this MEP, client channels implement <xref:System.ServiceModel.Channels.IRequestChannel> and service channels implement <xref:System.ServiceModel.Channels.IReplyChannel>.</span></span>  
  
- <span data-ttu-id="def9b-121">Дуплексный (<xref:System.ServiceModel.Channels.IDuplexChannel>)</span><span class="sxs-lookup"><span data-stu-id="def9b-121">Duplex (<xref:System.ServiceModel.Channels.IDuplexChannel>)</span></span>  
  
     <span data-ttu-id="def9b-122">Дуплексный шаблон обмена сообщениями позволяет клиенту отправлять произвольное количество сообщений и принимать их в произвольном порядке.</span><span class="sxs-lookup"><span data-stu-id="def9b-122">The duplex MEP allows an arbitrary number of messages to be sent by a client and received in any order.</span></span> <span data-ttu-id="def9b-123">Применение дуплексного шаблона похоже на разговор по телефону, когда каждое произносимое слово является сообщением.</span><span class="sxs-lookup"><span data-stu-id="def9b-123">The duplex MEP is like a phone conversation, where each word being spoken is a message.</span></span> <span data-ttu-id="def9b-124">Поскольку в данном случае принимать и отправлять сообщения могут обе стороны, каналы клиента и службы реализуют интерфейс <xref:System.ServiceModel.Channels.IDuplexChannel>.</span><span class="sxs-lookup"><span data-stu-id="def9b-124">Because both sides can send and receive in this MEP, the interface implemented by the client and service channels is <xref:System.ServiceModel.Channels.IDuplexChannel>.</span></span>  
  
 <span data-ttu-id="def9b-125">![Выбор шаблона обмена сообщениями](../../../../docs/framework/wcf/extending/media/wcfc-basicthreemepsc.gif "wcfc_BasicThreeMEPsc")</span><span class="sxs-lookup"><span data-stu-id="def9b-125">![Choosing a message exchange pattern](../../../../docs/framework/wcf/extending/media/wcfc-basicthreemepsc.gif "wcfc_BasicThreeMEPsc")</span></span>  
<span data-ttu-id="def9b-126">Три базовых шаблона обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="def9b-126">The three basic message exchange patterns.</span></span> <span data-ttu-id="def9b-127">Сверху вниз: датаграмма, запрос-ответ и дуплексный.</span><span class="sxs-lookup"><span data-stu-id="def9b-127">Top to bottom: datagram, request-response, and duplex.</span></span>  
  
 <span data-ttu-id="def9b-128">Каждый из этих шаблонов обмена сообщениями также поддерживает *сеансы*.</span><span class="sxs-lookup"><span data-stu-id="def9b-128">Each of these MEPs can also support *sessions*.</span></span> <span data-ttu-id="def9b-129">Сеанс (реализация интерфейса <xref:System.ServiceModel.Channels.ISessionChannel%601?displayProperty=nameWithType> типа <xref:System.ServiceModel.Channels.ISession?displayProperty=nameWithType>) согласует все сообщения, отправляемые и принимаемые через канал.</span><span class="sxs-lookup"><span data-stu-id="def9b-129">A session (and implementation of <xref:System.ServiceModel.Channels.ISessionChannel%601?displayProperty=nameWithType> of type <xref:System.ServiceModel.Channels.ISession?displayProperty=nameWithType>) correlates all messages sent and received on a channel.</span></span> <span data-ttu-id="def9b-130">Шаблон "запрос-ответ" является отдельным сеансом из двух сообщений, поскольку запрос и ответ связаны друг с другом.</span><span class="sxs-lookup"><span data-stu-id="def9b-130">The request-response pattern is a stand-alone two-message session, as the request and reply are correlated.</span></span> <span data-ttu-id="def9b-131">В отличие от него в поддерживающем сеансы дуплексном шаблоне предполагается, что все пары "запрос-ответ" в канале связаны друг с другом.</span><span class="sxs-lookup"><span data-stu-id="def9b-131">In contrast, the request-response pattern that supports sessions implies that all request/response pairs on that channel are correlated with each other.</span></span> <span data-ttu-id="def9b-132">Таким образом, можно выбирать из шести шаблонов обмена сообщениями:</span><span class="sxs-lookup"><span data-stu-id="def9b-132">This gives you a total of six MEPs to choose from:</span></span>  
  
- <span data-ttu-id="def9b-133">Datagram</span><span class="sxs-lookup"><span data-stu-id="def9b-133">Datagram</span></span>  
  
- <span data-ttu-id="def9b-134">запрос-ответ;</span><span class="sxs-lookup"><span data-stu-id="def9b-134">Request-response</span></span>  
  
- <span data-ttu-id="def9b-135">Дуплекс</span><span class="sxs-lookup"><span data-stu-id="def9b-135">Duplex</span></span>  
  
- <span data-ttu-id="def9b-136">датаграмма с сеансами;</span><span class="sxs-lookup"><span data-stu-id="def9b-136">Datagram with sessions</span></span>  
  
- <span data-ttu-id="def9b-137">запрос-ответ с сеансами;</span><span class="sxs-lookup"><span data-stu-id="def9b-137">Request-response with sessions</span></span>  
  
- <span data-ttu-id="def9b-138">дуплексный с сеансами.</span><span class="sxs-lookup"><span data-stu-id="def9b-138">Duplex with sessions</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="def9b-139">Для транспорта по протоколу UDP единственным поддерживаемым шаблоном обмена сообщения является использование датаграмм, поскольку протокол UDP предназначен только для отправки сообщений.</span><span class="sxs-lookup"><span data-stu-id="def9b-139">For the UDP transport, the only MEP that is supported is datagram, because UDP is inherently a fire and forget protocol.</span></span>  
  
## <a name="sessions-and-sessionful-channels"></a><span data-ttu-id="def9b-140">Сеансы и каналы, связанные с сеансами</span><span class="sxs-lookup"><span data-stu-id="def9b-140">Sessions and Sessionful Channels</span></span>  
 <span data-ttu-id="def9b-141">Среди сетевых протоколов существуют протоколы, использующие подключения (например, TCP), и протоколы, не использующие подключения (например, UDP).</span><span class="sxs-lookup"><span data-stu-id="def9b-141">In the networking world, there are connection-oriented protocols (for example, TCP) and connection-less protocols (for example, UDP).</span></span> <span data-ttu-id="def9b-142">WCF использует сеанс термин для обозначения абстрактного логического соединения.</span><span class="sxs-lookup"><span data-stu-id="def9b-142">WCF uses the term session to mean a connection-like logical abstraction.</span></span> <span data-ttu-id="def9b-143">Протоколы WCF, связанные с сеансами, похожи на сетевые протоколы, использующие подключения, а протоколы WCF, не связанные с сеансами, похожи на сетевые протоколы, не использующие подключения.</span><span class="sxs-lookup"><span data-stu-id="def9b-143">Sessionful WCF protocols are similar to connection-oriented network protocols and sessionless WCF protocols are similar to connection-less network protocols.</span></span>  
  
 <span data-ttu-id="def9b-144">В объектной модели канала каждый логический сеанс объявляется в качестве экземпляра канала, связанного с сеансом.</span><span class="sxs-lookup"><span data-stu-id="def9b-144">In the channel object model, each logical session manifests as an instance of a sessionful channel.</span></span> <span data-ttu-id="def9b-145">Поэтому каждый новый сеанс, создаваемый клиентом и принимаемый службой, соответствует новому каналу, связанному с сеансом, на каждой из сторон.</span><span class="sxs-lookup"><span data-stu-id="def9b-145">Therefore every new session created by the client, and accepted on the service, corresponds to a new sessionful channel on each side.</span></span> <span data-ttu-id="def9b-146">В верхней части следующей схемы показана структура каналов, связанных с сеансами, а в нижней - структура каналов, не связанных с сеансами.</span><span class="sxs-lookup"><span data-stu-id="def9b-146">The following diagram shows, on the top, the structure of sessionless channels, and on the bottom, the structure of sessionful channels.</span></span>  
  
 <span data-ttu-id="def9b-147">![Выбор шаблона обмена сообщениями](../../../../docs/framework/wcf/extending/media/wcfc-sessionandsessionlesschannelsc.gif "wcfc_SessionAndSessionlessChannelsc")</span><span class="sxs-lookup"><span data-stu-id="def9b-147">![Choosing a message exchange pattern](../../../../docs/framework/wcf/extending/media/wcfc-sessionandsessionlesschannelsc.gif "wcfc_SessionAndSessionlessChannelsc")</span></span>  
  
 <span data-ttu-id="def9b-148">Клиент создает новый канал, связанный с сеансом.</span><span class="sxs-lookup"><span data-stu-id="def9b-148">A client creates a new sessionful channel and sends a message.</span></span> <span data-ttu-id="def9b-149">На стороне службы прослушиватель канала получает сообщение и определяет, что оно принадлежит к новому сеансу, поэтому он создает новый канал, связанный с сеансом, и передает его приложению (в ответ на вызов AcceptChannel приложением в прослушивателе канала).</span><span class="sxs-lookup"><span data-stu-id="def9b-149">On the service side, the channel listener receives this message and detects that it belongs to a new session so it creates a new sessionful channel and hands it to the application (in response to the application calling AcceptChannel on the channel listener).</span></span> <span data-ttu-id="def9b-150">Затем приложение получает это сообщение и все последующие сообщения, передаваемые в рамках того же сеанса через тот же канал, связанный с сеансом.</span><span class="sxs-lookup"><span data-stu-id="def9b-150">The application then receives this message and all subsequent messages sent in the same session through the same sessionful channel.</span></span>  
  
 <span data-ttu-id="def9b-151">Другой клиент (или тот же клиент) создает новый канал, связанный с сеансом, и отправляет сообщение.</span><span class="sxs-lookup"><span data-stu-id="def9b-151">Another client (or the same client) creates a new sessionful and sends a message.</span></span> <span data-ttu-id="def9b-152">Прослушиватель канала определяет это сообщение в новом сеансе и создает новый канал, связанный с сеансом, после чего процесс повторяется.</span><span class="sxs-lookup"><span data-stu-id="def9b-152">The channel listener detects this message is in a new session and creates a new sessionful channel and the process repeats.</span></span>  
  
 <span data-ttu-id="def9b-153">Без сеансов согласованности между каналами и сеансами нет.</span><span class="sxs-lookup"><span data-stu-id="def9b-153">Without sessions, there is no correlation between channels and sessions.</span></span> <span data-ttu-id="def9b-154">Поэтому прослушиватель канала создает только один канал, через который все получаемые сообщения передаются приложению.</span><span class="sxs-lookup"><span data-stu-id="def9b-154">Therefore a channel listener creates only one channel through which all received messages are delivered to the application.</span></span> <span data-ttu-id="def9b-155">Сообщения не упорядочиваются, поскольку отсутствует сеанс, в котором можно было бы поддерживать порядок сообщений.</span><span class="sxs-lookup"><span data-stu-id="def9b-155">There is also no message ordering because there is no session within which to maintain message order.</span></span> <span data-ttu-id="def9b-156">В верхней части последнего рисунка показан обмен сообщениями без сеанса.</span><span class="sxs-lookup"><span data-stu-id="def9b-156">The top portion of the preceding graphic illustrates a sessionless message exchange.</span></span>  
  
## <a name="starting-and-terminating-sessions"></a><span data-ttu-id="def9b-157">Запуск и завершение сеансов</span><span class="sxs-lookup"><span data-stu-id="def9b-157">Starting and Terminating Sessions</span></span>  
 <span data-ttu-id="def9b-158">Сеансы запускаются на клиенте путем простого создания канала, связанного с сеансами.</span><span class="sxs-lookup"><span data-stu-id="def9b-158">Sessions are started on the client by simply creating a new sessionful channel.</span></span> <span data-ttu-id="def9b-159">Они запускаются в службе, когда служба получает сообщение, которое было отправлено в новом сеансе.</span><span class="sxs-lookup"><span data-stu-id="def9b-159">They are started on the service when the service receives a message that was sent in a new session.</span></span> <span data-ttu-id="def9b-160">Аналогично сеансы завершаются путем закрытия или прерывания канала, связанного с сеансом.</span><span class="sxs-lookup"><span data-stu-id="def9b-160">Likewise, sessions are terminated by closing or aborting a sessionful channel.</span></span>  
  
 <span data-ttu-id="def9b-161">Единственным исключением является канал <xref:System.ServiceModel.Channels.IDuplexSessionChannel>, который используется для отправки и получения сообщений при дуплексном шаблоне с поддержкой сеансов.</span><span class="sxs-lookup"><span data-stu-id="def9b-161">The exception to this is <xref:System.ServiceModel.Channels.IDuplexSessionChannel> which is used for both sending and receiving messages in a duplex, sessionful communication pattern.</span></span> <span data-ttu-id="def9b-162">Одна сторона может прекратить отправку сообщений но продолжить их получение, поэтому при использовании канала <xref:System.ServiceModel.Channels.IDuplexSessionChannel> имеется механизм, позволяющий закрыть исходящий сеанс, чтобы показать, что новые сообщения отправляться не будут, но оставить открытым входящий сеанс, чтобы можно было и дальше получать сообщения.</span><span class="sxs-lookup"><span data-stu-id="def9b-162">It is possible that one side will want to stop sending messages but continue to receive messages therefore when using <xref:System.ServiceModel.Channels.IDuplexSessionChannel> there is a mechanism that lets you close the output session indicating you will not send any more messages but keep the input session opened allowing you to continue to receive messages.</span></span>  
  
 <span data-ttu-id="def9b-163">В общем случае сеансы закрываются отправляющей, а не принимающей стороной.</span><span class="sxs-lookup"><span data-stu-id="def9b-163">In general, sessions are closed on the outgoing side and not on the incoming side.</span></span> <span data-ttu-id="def9b-164">Это значит, что исходящий канал, связанный с сеансом, можно закрыть, в результате чего сеанс будет аккуратно прерван.</span><span class="sxs-lookup"><span data-stu-id="def9b-164">That is, sessionful output channels can be closed, thereby cleanly terminating the session.</span></span> <span data-ttu-id="def9b-165">Закрытие связанного с сеансом исходящего канала приводит к тому, что соответствующий связанный с сеансом входящий канал возвращает значение NULL приложению, которое вызывает метод <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> объекта <xref:System.ServiceModel.Channels.IDuplexSessionChannel>.</span><span class="sxs-lookup"><span data-stu-id="def9b-165">Closing a sessionful output channel causes the corresponding sessionful input channel to return null to the application calling <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel>.</span></span>  
  
 <span data-ttu-id="def9b-166">Но в большинстве случае входящие каналы не следует закрывать, пока метод <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> объекта <xref:System.ServiceModel.Channels.IDuplexSessionChannel> не вернет значение NULL, указывая на то, что сеанс уже закрыт.</span><span class="sxs-lookup"><span data-stu-id="def9b-166">However sessionful input channels should not be closed unless <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel> returns null, indicating that the session is already closed.</span></span> <span data-ttu-id="def9b-167">Если метод <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> объекта <xref:System.ServiceModel.Channels.IDuplexSessionChannel> не вернул значение NULL, закрытие связанного с сеансом входящего канала может привести к возникновению исключения, поскольку во время закрытия через канал может неожиданно прийти сообщение.</span><span class="sxs-lookup"><span data-stu-id="def9b-167">If <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel> has not returned null, closing a sessionful input channel may throw an exception because it may receive unexpected messages while closing.</span></span> <span data-ttu-id="def9b-168">Если принимающей стороне нужно завершить сеанс, прежде чем это сделает отправляющая сторона, необходимо вызвать метод <xref:System.ServiceModel.ICommunicationObject.Abort%2A> входящего канала, в результате чего сеанс будет сразу же прерван.</span><span class="sxs-lookup"><span data-stu-id="def9b-168">If a receiver wishes to terminate a session before the sender does, it should call <xref:System.ServiceModel.ICommunicationObject.Abort%2A> on the input channel, which abruptly terminates the session.</span></span>  
  
## <a name="writing-sessionful-channels"></a><span data-ttu-id="def9b-169">Разработка каналов, связанных с сеансами</span><span class="sxs-lookup"><span data-stu-id="def9b-169">Writing Sessionful Channels</span></span>  
 <span data-ttu-id="def9b-170">Для реализации сеансов разработчики каналов должны помнить о нескольких моментах.</span><span class="sxs-lookup"><span data-stu-id="def9b-170">As a sessionful channel author, there are a few things your channel must do to provide sessions.</span></span> <span data-ttu-id="def9b-171">На стороне отправки канал должен выполнять следующие действия.</span><span class="sxs-lookup"><span data-stu-id="def9b-171">On the send side, your channel needs to:</span></span>  
  
- <span data-ttu-id="def9b-172">Для каждого нового канала необходимо создавать новый сеанс и связывать его с новым ИД сеанса, являющимся уникальной строкой.</span><span class="sxs-lookup"><span data-stu-id="def9b-172">For each new channel, create a new session and associate it with a new session id which is a unique string.</span></span> <span data-ttu-id="def9b-173">Либо необходимо получать новый сеанс из предыдущего связанного с сеансами канала в стеке.</span><span class="sxs-lookup"><span data-stu-id="def9b-173">Or obtain a new session from the sessionful channel below you in the stack.</span></span>  
  
- <span data-ttu-id="def9b-174">Для каждого сообщения, отправленного с помощью данного канала, если канал создал сеанс (а не получил его из стека), необходимо связать сообщение с сеансом.</span><span class="sxs-lookup"><span data-stu-id="def9b-174">For each message sent using this channel, if your channel created the session (as opposed to obtaining it from the layer below you), you need to associate the message with the session.</span></span> <span data-ttu-id="def9b-175">Для каналов протоколов эта задача обычно решается путем добавления заголовка SOAP.</span><span class="sxs-lookup"><span data-stu-id="def9b-175">For protocol channels, this is typically done by adding a SOAP header.</span></span> <span data-ttu-id="def9b-176">Для каналов транспорта эта задача обычно решается путем создания нового подключения транспорта или включения сведений о сеансе во внешний протокол.</span><span class="sxs-lookup"><span data-stu-id="def9b-176">For transport channels, this is typically done by creating a new transport connection or adding session information to the framing protocol.</span></span>  
  
- <span data-ttu-id="def9b-177">Для каждого сообщения, отправленного с помощью данного канала, необходимо реализовать описанные выше способы гарантии доставки.</span><span class="sxs-lookup"><span data-stu-id="def9b-177">For each message sent using this channel, you need to provide the delivery guarantees mentioned above.</span></span> <span data-ttu-id="def9b-178">Если для получения сеанса используется следующий канал в стеке, этот канал также гарантирует доставку.</span><span class="sxs-lookup"><span data-stu-id="def9b-178">If you are relying on the channel below you to provide the session, that channel will also provide the delivery guarantees.</span></span> <span data-ttu-id="def9b-179">Если создается новый сеанс, необходимо реализовать механизмы получения гарантии в протоколе.</span><span class="sxs-lookup"><span data-stu-id="def9b-179">If you’re providing the session yourself, you need to implement those guarantees as part of your protocol.</span></span> <span data-ttu-id="def9b-180">В общем случае при создании канала протокола, который предполагает использование на обеих сторонах платформы WCF, можно потребовать использования транспорта TCP или канала надежного обмена сообщениями и использовать любой из этих механизмов для создания сеанса.</span><span class="sxs-lookup"><span data-stu-id="def9b-180">In general, if you are writing a protocol channel that assumes WCF on both sides you may require the TCP transport or the Reliable Messaging channel and rely on either one to provide a session.</span></span>  
  
- <span data-ttu-id="def9b-181">При вызове метода <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> канала следует выполнить операции, необходимые для закрытия канала, используя заданное время ожидания или время ожидания по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="def9b-181">When <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> is called on your channel, perform the necessary work to close the session using either the specified timeout or the default one.</span></span> <span data-ttu-id="def9b-182">Для этого достаточно вызвать метод <xref:System.ServiceModel.ICommunicationObject.Close%2A> следующего канала в стеке (если сеанс был получен через него), отправить специальное сообщение SOAP или закрыть подключение транспорта.</span><span class="sxs-lookup"><span data-stu-id="def9b-182">This can be as simple as calling <xref:System.ServiceModel.ICommunicationObject.Close%2A> on the channel below you (if you just obtained the session from it) or sending a special SOAP message or closing a transport connection.</span></span>  
  
- <span data-ttu-id="def9b-183">При вызове метода <xref:System.ServiceModel.ICommunicationObject.Abort%2A> для канала необходимо сразу же завершить сеанс без выполнения операций ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="def9b-183">When <xref:System.ServiceModel.ICommunicationObject.Abort%2A> is called on your channel, terminate the session abruptly without performing I/O.</span></span> <span data-ttu-id="def9b-184">Это может означать, что ничего делать не требуется, или что нужно разорвать сетевое подключение или высвободить какие-либо другие ресурсы.</span><span class="sxs-lookup"><span data-stu-id="def9b-184">This may mean doing nothing or may involve aborting a network connection or some other resource.</span></span>  
  
 <span data-ttu-id="def9b-185">На принимающей стороне канал должен выполнять следующие действия.</span><span class="sxs-lookup"><span data-stu-id="def9b-185">On the receive side, your channel needs to:</span></span>  
  
- <span data-ttu-id="def9b-186">Для каждого входящего сообщения прослушиватель канала должен определить сеанс, к которому относится это сообщение.</span><span class="sxs-lookup"><span data-stu-id="def9b-186">For each incoming message, the channel listener must detect the session it belongs to.</span></span> <span data-ttu-id="def9b-187">Если это первое сообщение в сеансе, прослушиватель канала должен создать новый канал и вернуть его в результате вызова метода <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="def9b-187">If this is the first message in the session, the channel listener must create a new channel and return it from the call to <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="def9b-188">В противном случае прослушиватель канала должен найти существующий канал, который относится к сеансу, и передать сообщение через этот канал.</span><span class="sxs-lookup"><span data-stu-id="def9b-188">Otherwise the channel listener must find the existing channel that corresponds to the session and deliver the message through that channel.</span></span>  
  
- <span data-ttu-id="def9b-189">Если канал предоставляет сеанс (а также необходимые гарантии доставки), может потребоваться, чтобы получающая сторона выполнила определенные действия, например изменила порядок сообщений или отправила подтверждения.</span><span class="sxs-lookup"><span data-stu-id="def9b-189">If your channel is providing the session (along with the required delivery guarantees) the receive side may be required to perform some actions such as re-order messages or send acknowledgements.</span></span>  
  
- <span data-ttu-id="def9b-190">При вызове метода <xref:System.ServiceModel.ICommunicationObject.Close%2A> канала следует выполнить операции, необходимые для закрытия канала, используя заданное время ожидания или время ожидания по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="def9b-190">When <xref:System.ServiceModel.ICommunicationObject.Close%2A> is called on your channel, perform the necessary work to close the session either the specified timeout or the default one.</span></span> <span data-ttu-id="def9b-191">Это может привести к появлению исключений, если канал получает сообщение, пока он ожидает истечения времени закрытия канала.</span><span class="sxs-lookup"><span data-stu-id="def9b-191">This could result in exceptions if the channel receives a message while waiting for the close timeout to expire.</span></span> <span data-ttu-id="def9b-192">Такая ситуация будет обусловлена тем, что при получении сообщения канал будет находится в состоянии закрытия.</span><span class="sxs-lookup"><span data-stu-id="def9b-192">That’s because the channel will be in the Closing state when it receives a message so it would throw.</span></span>  
  
- <span data-ttu-id="def9b-193">При вызове метода <xref:System.ServiceModel.ICommunicationObject.Abort%2A> для канала необходимо сразу же завершить сеанс без выполнения операций ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="def9b-193">When <xref:System.ServiceModel.ICommunicationObject.Abort%2A> is called on your channel, terminate the session abruptly without performing I/O.</span></span> <span data-ttu-id="def9b-194">С другой стороны, это может означать, что ничего делать не требуется, или что нужно разорвать сетевое подключение или высвободить какие-либо другие ресурсы.</span><span class="sxs-lookup"><span data-stu-id="def9b-194">Again, this may mean doing nothing or may involve aborting a network connection or some other resource.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="def9b-195">См. также</span><span class="sxs-lookup"><span data-stu-id="def9b-195">See also</span></span>

- [<span data-ttu-id="def9b-196">Общие сведения о модели каналов</span><span class="sxs-lookup"><span data-stu-id="def9b-196">Channel Model Overview</span></span>](../../../../docs/framework/wcf/extending/channel-model-overview.md)
