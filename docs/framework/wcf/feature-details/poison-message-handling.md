---
title: Обработка подозрительных сообщений
ms.date: 03/30/2017
ms.assetid: 8d1c5e5a-7928-4a80-95ed-d8da211b8595
ms.openlocfilehash: fe748ac40f03ed22cacb254ab464a6caf3d27a8c
ms.sourcegitcommit: 558d78d2a68acd4c95ef23231c8b4e4c7bac3902
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2019
ms.locfileid: "59305030"
---
# <a name="poison-message-handling"></a>Обработка подозрительных сообщений
Объект *подозрительное сообщение* — это сообщение, для которого превышено максимальное число попыток доставки в приложение. Такая ситуация может возникнуть, если приложение с очередью не может обработать сообщение из-за ошибок. Чтобы отвечать требованиям надежности, приложение с очередью получает сообщения транзакционно. Прерывание транзакции, в которой получено очередное сообщение, приводит к тому, что сообщение остается в очереди и новая попытка доставить его предпринимается в новой транзакции. Если причина прерывания транзакции не устранена, принимающее приложение может зациклиться, получая и прерывая прием одного и того же сообщения, до достижения максимального числа попыток доставки и пометки сообщения как подозрительного.  
  
 Сообщение может стать подозрительным по многим причинам. Самые распространенные причины связаны с приложением. Например, если приложение читает сообщение из очереди и выполняет определенную обработку базы данных, приложение может потерпеть неудачу при попытке заблокировать базу данных и транзакция будет прервана. Из-за прерывания транзакции базы данных сообщение остается в очереди, поэтому приложение повторно читает сообщение и делает попытку заблокировать базу данных. Сообщения также могут быть подозрительными, если они содержат недопустимую информацию. Например, заказ на покупку может содержать недопустимый номер заказчика. В таких случаях приложение может по своему выбору прервать транзакцию и пометить сообщение как подозрительное.  
  
 В редких случаях не удается отправить сообщения приложению. На уровне Windows Communication Foundation (WCF) может оказаться проблему с сообщением, например, если сообщение имеет неверный фрейм, недопустимое сообщение учетные данные присоединены к или недопустимый заголовок действия. В таких случаях приложение не получает сообщение. Однако сообщение все еще может превратиться в подозрительное и быть обработано вручную.  
  
## <a name="handling-poison-messages"></a>Обработка подозрительных сообщений  
 В WCF обработка подозрительных сообщений предоставляет механизм для принимающему приложению для обработки сообщений, которые не удалось доставить приложению или сообщений, которые доставлены в приложение, но не могут быть обработаны из-за конкретного приложения причины. Обработка подозрительных сообщений настраивается при помощи следующих свойств в каждой доступной привязке очереди.  
  
-   `ReceiveRetryCount`. Целое значение, указывающее максимальное число повторных попыток доставить сообщение из очереди приложения в приложение. Значение по умолчанию — 5. Это важно в тех случаях, когда немедленная повторная попытка решает проблему, например проблему со временной взаимоблокировкой в базе данных.  
  
-   `MaxRetryCycles`. Целое значение, указывающее максимальное число циклов повторных попыток. Цикл повторной попытки состоит из передачи сообщения из очереди приложения во вложенную очередь повторной отправки и, через настраиваемый промежуток времени, передачи из вложенной очереди повторной отправки обратно в очередь приложения для новой попытки доставки. Значение по умолчанию — 2. В [!INCLUDE[wv](../../../../includes/wv-md.md)] сообщение отправляется за максимум (`ReceiveRetryCount` +1) * (`MaxRetryCycles` + 1) попыток. `MaxRetryCycles` учитывается на [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] и [!INCLUDE[wxp](../../../../includes/wxp-md.md)].  
  
-   `RetryCycleDelay`. Промежуток времени между циклами повторных попыток. Значение по умолчанию — 30 минут. `MaxRetryCycles` и `RetryCycleDelay` вместе формируют механизм для решения проблемы, когда повторная попытка с периодической задержкой решает проблему. Например, это помогает для блокированного набора строк при отложенном завершении транзакции в SQL Server.  
  
-   `ReceiveErrorHandling`. Перечисление, указывающее, какое действие выполняется для сообщения, доставка которого не удалась после максимального числа повторных попыток. Возможные значения: Fault, Drop, Reject и Move. Значение по умолчанию - Fault.  
  
-   Fault. Отправляется ошибка прослушивателю, который привел к сбою `ServiceHost`. Сообщение должно быть удалено из очереди приложения при помощи внешнего механизма, прежде чем приложение сможет продолжить обрабатывать сообщения очереди.  
  
-   Drop. Подозрительное сообщение отбрасывается и никогда не будет доставлено в приложение. Если к этому моменту время, заданное свойством `TimeToLive` сообщения, истекло, сообщение может появиться в очереди недоставленных сообщений отправителя. Если не истекло, сообщение нигде не появляется. Этот вариант означает, что пользователь не позаботился о том, что должно произойти в случае потери сообщения.  
  
-   Reject. Этот вариант доступен только в [!INCLUDE[wv](../../../../includes/wv-md.md)]. Он указывает очереди сообщений (MSMQ) послать диспетчеру передающей очереди уведомление о том, что сообщение не может быть доставлено приложению. Сообщение помещается в очередь недоставленных сообщений диспетчера передающей очереди.  
  
-   Move. Этот вариант доступен только в [!INCLUDE[wv](../../../../includes/wv-md.md)]. Подозрительное сообщение перемещается в очередь подозрительных сообщений для дальнейшей обработки приложением по работе с подозрительными сообщениями. Очередь подозрительных сообщений является вложенной очередью очереди приложения. Приложение обработки подозрительных сообщений может быть службы WCF, которая считывает сообщения из очереди подозрительных сообщений. Очередь подозрительных сообщений является вложенной очередью очереди приложения и можно обращаться как net.msmq://\<*имя_компьютера*>/*Очередь_приложения*; poison, где  *имя машины* — имя компьютера, на котором расположена очередь и *Очередь_приложения* имя очереди конкретного приложения.  
  
 Далее приведены максимальные числа попыток доставки для сообщения.  
  
-   ((ReceiveRetryCount+1) * (MaxRetryCycles + 1)) в [!INCLUDE[wv](../../../../includes/wv-md.md)].  
  
-   (ReceiveRetryCount + 1) в [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] и [!INCLUDE[wxp](../../../../includes/wxp-md.md)].  
  
> [!NOTE]
>  Для успешно доставленного сообщения повторных попыток доставки не выполняется.  
  
 Чтобы отслеживать число попыток чтения сообщения, в [!INCLUDE[wv](../../../../includes/wv-md.md)] есть устойчивое свойство сообщения, которое подсчитывает число прекращений, и свойство подсчета перемещений, считающее, сколько раз сообщение перемещалось между очередью приложения и вложенными очередями. Канал WCF они используются для вычисления количества повторных попыток получения и количества циклов повторных попыток. На [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] и [!INCLUDE[wxp](../../../../includes/wxp-md.md)], число прекращений хранится в памяти каналом WCF и сбрасывается в случае сбоя приложения. Кроме того канал WCF может содержать что подсчет прекращений максимально для 256 сообщений в памяти в любое время. Когда прочитывается 257-е сообщение, подсчет числа прекращений для самого старого сообщения сбрасывается.  
  
 Свойства подсчета прекращений и перемещений доступны для операции службы через контекст операции. В следующем примере кода представлен способ обращения к ним.  
  
 [!code-csharp[S_UE_MSMQ_Poison#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_ue_msmq_poison/cs/service.cs#1)]  
  
 WCF предоставляет два стандартных привязок в очереди:  
  
-   <xref:System.ServiceModel.NetMsmqBinding>. Объект [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] привязка, подходящая для взаимодействия на основе очередей с другими конечными точками WCF.  
  
-   <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding>. Привязка, подходящая для взаимодействия с существующими приложениями MSMQ.  
  
> [!NOTE]
>  Можно изменить свойства в этих привязок, в соответствии с требованиями службы WCF. Весь механизм обработки подозрительных сообщений является локальным для принимающего приложения. Этот процесс невидим для отправляющего приложения, если только принимающее приложение не останавливается и не посылает отправителю уведомление о недоставке. В таком случае сообщение перемещается в очередь недоставленных сообщений отправителя.  
  
## <a name="best-practice-handling-msmqpoisonmessageexception"></a>Лучшие методики: Обработка исключения MsmqPoisonMessageException  
 Когда служба определяет, что сообщение подозрительно, транспорт очереди создает исключение <xref:System.ServiceModel.MsmqPoisonMessageException>, содержащее `LookupId` подозрительного сообщения.  
  
 Принимающее приложение может реализовывать интерфейс <xref:System.ServiceModel.Dispatcher.IErrorHandler> для обработки всех необходимых ошибок. Дополнительные сведения см. в разделе [расширение элемента управления по обработке ошибок и отчеты](../../../../docs/framework/wcf/samples/extending-control-over-error-handling-and-reporting.md).  
  
 Приложению может требоваться определенная автоматическая обработка подозрительных сообщений, перемещающая подозрительные сообщения в очередь подозрительных сообщений, чтобы служба могла получить доступ к оставшимся сообщениям в очереди. Использование механизма обработчика ошибок для ожидания возникновения исключений, связанных с подозрительными сообщениями, возможно только если параметр <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveErrorHandling%2A> имеет значение <xref:System.ServiceModel.ReceiveErrorHandling.Fault>. Пример подозрительного сообщения для MSMQ 3.0 иллюстрирует такое поведение. Далее описаны основные шаги, которые необходимо предпринять для обработки подозрительных сообщений, также даны рекомендации.  
  
1. Убедитесь, что параметры, заданные для подозрительных сообщений, отражают требования приложения. При работе с параметрами убедитесь, что понимаете разницу между возможностями очереди сообщений в [!INCLUDE[wv](../../../../includes/wv-md.md)], [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] и [!INCLUDE[wxp](../../../../includes/wxp-md.md)].  
  
2. Если необходимо, реализуйте `IErrorHandler` для обработки ошибок, связанных с подозрительными сообщениями. Поскольку, если задать для свойства `ReceiveErrorHandling` значение `Fault`, потребуется ручной механизм для перемещения подозрительного сообщения из очереди или для исправления проблем, связанных со внешними обстоятельствами, стандартное использование - реализация `IErrorHandler` со значением `ReceiveErrorHandling` свойства `Fault`, как показано в следующем коде.  
  
     [!code-csharp[S_UE_MSMQ_Poison#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_ue_msmq_poison/cs/poisonerrorhandler.cs#2)]  
  
3. Создайте атрибут `PoisonBehaviorAttribute`, который сможет использовать поведение службы. Поведение устанавливает `IErrorHandler` в диспетчере. См. следующий пример кода.  
  
     [!code-csharp[S_UE_MSMQ_Poison#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_ue_msmq_poison/cs/poisonbehaviorattribute.cs#3)]  
  
4. Убедитесь, что служба помечена атрибутом PoisonBehaviorAttribute.  

 Кроме того, если свойство `ReceiveErrorHandling` имеет значение `Fault`, `ServiceHost` завершает работу с ошибкой, если встречает подозрительное сообщение. Можно подключиться к событию с ошибкой и завершить работу службы, предпринять действия по исправлению ошибки и перезапустить службу. Например, `LookupId` в исключении <xref:System.ServiceModel.MsmqPoisonMessageException>, распространенный на объект `IErrorHandler`, может запоминаться, и когда узел службы завершает работу с ошибкой, можно использовать API `System.Messaging` для получения сообщения из очереди с помощью `LookupId`, чтобы удалить сообщение из очереди и сохранить его во внешнем хранилище или другой очереди. Затем можно перезапустить `ServiceHost`, чтобы возобновить нормальную работу. [Обработка подозрительных сообщений в MSMQ 4.0](../../../../docs/framework/wcf/samples/poison-message-handling-in-msmq-4-0.md) демонстрирует такое поведение.  
  
## <a name="transaction-time-out-and-poison-messages"></a>Время ожидания транзакции и подозрительные сообщения  
 Между транспортным каналом очереди и пользовательским кодом может возникнуть класс ошибок. Эти ошибки могут быть обнаружены промежуточными уровнями, например уровнем безопасности сообщений или логикой отправки службы. Например, отсутствие сертификата X.509, обнаруженное на уровне безопасности SOAP, и отсутствие действия - случаи отправки сообщения приложению. Когда возникает такая ситуация, модель службы отбрасывает сообщение. Так как чтение сообщения происходит в транзакции и результат транзакции не может быт получен, время ожидания транзакции истекает, транзакция прерывается и сообщение помещается обратно в очередь. Другими словами, для определенного класса ошибок не происходит немедленного прерывания транзакции, прерывание происходит, когда истекает время ожидания транзакции. Можно изменить время ожидания транзакции для службы с атрибутом <xref:System.ServiceModel.ServiceBehaviorAttribute>.  
  
 Чтобы изменить время ожидания транзакции на уровне компьютера, измените файл machine.config, задав требуемое время ожидания. Важно обратить внимание, что в зависимости от заданного времени ожидания транзакция со временем прерывается и возвращается в очередь, число ее прекращений увеличивается. В итоге сообщение становится подозрительным и предпринимаются действия в соответствии с параметрами пользователя.  
  
## <a name="sessions-and-poison-messages"></a>Сеансы и подозрительные сообщения  
 Сеанс проходит те же процедуры повторных попыток и обработки подозрительных сообщений, что и отдельное сообщение. Свойства, перечисленные ранее для подозрительных сообщений, применимы и к целому сеансу. Это значит, что происходит повторная попытка выполнения сеанса целиком, и он перемещается в конечную очередь подозрительных сообщений или очередь недоставленных сообщений отправителя, если сообщение не принято.  
  
## <a name="batching-and-poison-messages"></a>Пакетирование и подозрительные сообщения  
 Если сообщение о сбое становится подозрительным и представляет собой часть пакета, весь пакет откатывается и канал возвращается к чтению сообщений по одному. Дополнительные сведения о пакетной обработке см. в разделе [Пакетная обработка сообщений в одну транзакцию](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md)  
  
## <a name="poison-message-handling-for-messages-in-a-poison-queue"></a>Обработка подозрительных сообщений из очереди подозрительных сообщений  
 Обработка подозрительного сообщения не заканчивается его перемещением в очередь подозрительных сообщений. Сообщения из очереди подозрительных сообщений по прежнему должны прочитываться и обрабатываться. При чтении сообщений из конечной вложенной очереди подозрительных сообщений можно использовать подмножество параметров обработки подозрительных сообщений. Применимые параметры: `ReceiveRetryCount` и `ReceiveErrorHandling`. `ReceiveErrorHandling` можно установить в значение Drop, Reject или Fault. `MaxRetryCycles` учитывается и создается исключение если `ReceiveErrorHandling` имеет значение Move.  
  
## <a name="windows-vista-windows-server-2003-and-windows-xp-differences"></a>Различия Windows Vista, Windows Server 2003 и Windows XP  
 Как уже упоминалось, не все параметры обработки подозрительных сообщений применимы для [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] и [!INCLUDE[wxp](../../../../includes/wxp-md.md)]. Следующие ключевые различия для очереди сообщений в [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)], [!INCLUDE[wxp](../../../../includes/wxp-md.md)] и [!INCLUDE[wv](../../../../includes/wv-md.md)] важны для обработки подозрительных сообщений.  
  
-   Очередь сообщений в [!INCLUDE[wv](../../../../includes/wv-md.md)] поддерживает вложенные очереди, тогда как [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] и [!INCLUDE[wxp](../../../../includes/wxp-md.md)] не поддерживают вложенные очереди. Вложенные очереди используются при обработке подозрительных сообщений. Очереди повторных попыток и очередь подозрительных сообщений являются вложенными очередями очереди приложения, созданной на основе параметров обработки подозрительных сообщений. Значение `MaxRetryCycles` указывает, сколько необходимо создать вложенных очередей повторных попыток. Поэтому при работе с [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] или [!INCLUDE[wxp](../../../../includes/wxp-md.md)] параметр `MaxRetryCycles` игнорируется, а значение `ReceiveErrorHandling.Move` не допускается.  
  
-   Очередь сообщений в [!INCLUDE[wv](../../../../includes/wv-md.md)] поддерживает уведомление о недоставке, тогда как [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] и [!INCLUDE[wxp](../../../../includes/wxp-md.md)] не поддерживают его. Уведомление о недоставке от диспетчера принимающей очереди приводит к тому, что диспетчер передающей очереди помещает сообщение в очередь недоставленных сообщений. Поэтому значение `ReceiveErrorHandling.Reject` не допускается в [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] и [!INCLUDE[wxp](../../../../includes/wxp-md.md)].  
  
-   Очередь сообщений в [!INCLUDE[wv](../../../../includes/wv-md.md)] поддерживает свойство сообщения, подсчитывающее число попыток доставки сообщения. Это свойство подсчета прекращений недоступно в [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] и [!INCLUDE[wxp](../../../../includes/wxp-md.md)]. WCF хранит число прекращений в памяти, так что вполне возможно, что это свойство не может содержать неточное значение, если то же сообщение прочитывается более одной службы WCF в ферме.  
  
## <a name="see-also"></a>См. также

- [Общие сведения об очередях](../../../../docs/framework/wcf/feature-details/queues-overview.md)
- [Различия в возможностях очередей в Windows Vista, Windows Server 2003 и Windows XP](../../../../docs/framework/wcf/feature-details/diff-in-queue-in-vista-server-2003-windows-xp.md)
- [Задание и обработка сбоев в контрактах и службах](../../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md)
