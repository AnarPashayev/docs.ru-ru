---
title: Использование класса XmlSerializer
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- XmlSerializer [WCF], using
ms.assetid: c680602d-39d3-44f1-bf22-8e6654ad5069
ms.openlocfilehash: 29ce9b165c3823d7d06008431294f67716ccf8e1
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/08/2019
ms.locfileid: "59105447"
---
# <a name="using-the-xmlserializer-class"></a><span data-ttu-id="50ba0-102">Использование класса XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="50ba0-102">Using the XmlSerializer Class</span></span>
<span data-ttu-id="50ba0-103">Windows Communication Foundation (WCF) можно использовать две разные технологии сериализации для преобразования данных в приложении в XML, передаваемая между клиентами и службами, процесс называется сериализацией.</span><span class="sxs-lookup"><span data-stu-id="50ba0-103">Windows Communication Foundation (WCF) can use two different serialization technologies to turn the data in your application into XML that is transmitted between clients and services, a process called serialization.</span></span>  
  
## <a name="datacontractserializer-as-the-default"></a><span data-ttu-id="50ba0-104">DataContractSerializer по умолчанию</span><span class="sxs-lookup"><span data-stu-id="50ba0-104">DataContractSerializer as the Default</span></span>  
 <span data-ttu-id="50ba0-105">По умолчанию WCF использует <xref:System.Runtime.Serialization.DataContractSerializer> класс для сериализации типов данных.</span><span class="sxs-lookup"><span data-stu-id="50ba0-105">By default WCF uses the <xref:System.Runtime.Serialization.DataContractSerializer> class to serialize data types.</span></span> <span data-ttu-id="50ba0-106">Данный сериализатор поддерживает следующие типы:</span><span class="sxs-lookup"><span data-stu-id="50ba0-106">This serializer supports the following types:</span></span>  
  
-   <span data-ttu-id="50ba0-107">Примитивные типы (например, целые числа, строки и массивы байтов), а также некоторые специальные типы, такие как <xref:System.Xml.XmlElement> и <xref:System.DateTime>, обрабатываемые как примитивы.</span><span class="sxs-lookup"><span data-stu-id="50ba0-107">Primitive types (for example, integers, strings, and byte arrays), as well as some special types, such as <xref:System.Xml.XmlElement> and <xref:System.DateTime>, which are treated as primitives.</span></span>  
  
-   <span data-ttu-id="50ba0-108">Типы контрактов данных (типы, отмеченные атрибутом <xref:System.Runtime.Serialization.DataContractAttribute>).</span><span class="sxs-lookup"><span data-stu-id="50ba0-108">Data contract types (types marked with the <xref:System.Runtime.Serialization.DataContractAttribute> attribute).</span></span>  
  
-   <span data-ttu-id="50ba0-109">Типы, отмеченные атрибутом <xref:System.SerializableAttribute>, включающие типы, реализующие интерфейс <xref:System.Runtime.Serialization.ISerializable>.</span><span class="sxs-lookup"><span data-stu-id="50ba0-109">Types marked with the <xref:System.SerializableAttribute> attribute, which include types that implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span>  
  
-   <span data-ttu-id="50ba0-110">Типы, реализующие интерфейс <xref:System.Xml.Serialization.IXmlSerializable>.</span><span class="sxs-lookup"><span data-stu-id="50ba0-110">Types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>  
  
-   <span data-ttu-id="50ba0-111">Множество типов общих коллекций, включающих множество типов универсальных коллекций.</span><span class="sxs-lookup"><span data-stu-id="50ba0-111">Many common collection types, which include many generic collection types.</span></span>  
  
 <span data-ttu-id="50ba0-112">Множество типов [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] попадает в последние две категории и поэтому является сериализуемым.</span><span class="sxs-lookup"><span data-stu-id="50ba0-112">Many [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] types fall into the latter two categories and are thus serializable.</span></span> <span data-ttu-id="50ba0-113">Массивы сериализуемых типов также являются сериализуемыми.</span><span class="sxs-lookup"><span data-stu-id="50ba0-113">Arrays of serializable types are also serializable.</span></span> <span data-ttu-id="50ba0-114">Полный список см. в разделе [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="50ba0-114">For a complete list, see [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).</span></span>  
  
 <span data-ttu-id="50ba0-115"><xref:System.Runtime.Serialization.DataContractSerializer>, Используемый вместе с данными типов контрактов, рекомендуется использовать для написания новых служб WCF.</span><span class="sxs-lookup"><span data-stu-id="50ba0-115">The <xref:System.Runtime.Serialization.DataContractSerializer>, used together with data contract types, is the recommended way to write new WCF services.</span></span> <span data-ttu-id="50ba0-116">Дополнительные сведения см. в разделе [Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="50ba0-116">For more information, see [Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md).</span></span>  
  
## <a name="when-to-use-the-xmlserializer-class"></a><span data-ttu-id="50ba0-117">Когда использовать класс XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="50ba0-117">When to Use the XmlSerializer Class</span></span>  
 <span data-ttu-id="50ba0-118">WCF также поддерживает <xref:System.Xml.Serialization.XmlSerializer> класса.</span><span class="sxs-lookup"><span data-stu-id="50ba0-118">WCF also supports the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="50ba0-119"><xref:System.Xml.Serialization.XmlSerializer> Класс не является уникальным для WCF.</span><span class="sxs-lookup"><span data-stu-id="50ba0-119">The <xref:System.Xml.Serialization.XmlSerializer> class is not unique to WCF.</span></span> <span data-ttu-id="50ba0-120">Это тот же модуль сериализации, который используется в веб-службах [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)].</span><span class="sxs-lookup"><span data-stu-id="50ba0-120">It is the same serialization engine that [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] Web services use.</span></span> <span data-ttu-id="50ba0-121">Класс <xref:System.Xml.Serialization.XmlSerializer> поддерживает более узкий набор типов по сравнению с классом <xref:System.Runtime.Serialization.DataContractSerializer>, но позволяет более четко контролировать получаемый XML-код и более полно поддерживает стандарт языка определения схемы XML (XSD).</span><span class="sxs-lookup"><span data-stu-id="50ba0-121">The <xref:System.Xml.Serialization.XmlSerializer> class supports a much narrower set of types than the <xref:System.Runtime.Serialization.DataContractSerializer> class, but allows much more control over the resulting XML and supports much more of the XML Schema definition language (XSD) standard.</span></span> <span data-ttu-id="50ba0-122">Кроме того, данный класс не требует никаких декларативных атрибутов на сериализуемых типах.</span><span class="sxs-lookup"><span data-stu-id="50ba0-122">It also does not require any declarative attributes on the serializable types.</span></span> <span data-ttu-id="50ba0-123">Дополнительные сведения см. в разделе XML-сериализации [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] документации.</span><span class="sxs-lookup"><span data-stu-id="50ba0-123">For more information, see the XML Serialization topic in the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] documentation.</span></span> <span data-ttu-id="50ba0-124">Класс <xref:System.Xml.Serialization.XmlSerializer> не поддерживает типы контрактов данных.</span><span class="sxs-lookup"><span data-stu-id="50ba0-124">The <xref:System.Xml.Serialization.XmlSerializer> class does not support data contract types.</span></span>  
  
 <span data-ttu-id="50ba0-125">При использовании Svcutil.exe или **Add Service Reference** для вас автоматически включена функция в Visual Studio для создания кода клиента для службы сторонних или для доступа к схеме третьей стороны, соответствующий сериализатор.</span><span class="sxs-lookup"><span data-stu-id="50ba0-125">When using Svcutil.exe or the **Add Service Reference** feature in Visual Studio to generate client code for a third-party service, or to access a third-party schema, an appropriate serializer is automatically selected for you.</span></span> <span data-ttu-id="50ba0-126">Если схема не совместима с <xref:System.Runtime.Serialization.DataContractSerializer>, выбирается <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="50ba0-126">If the schema is not compatible with the <xref:System.Runtime.Serialization.DataContractSerializer>, the <xref:System.Xml.Serialization.XmlSerializer> is selected.</span></span>  
  
## <a name="manually-switching-to-the-xmlserializer"></a><span data-ttu-id="50ba0-127">Ручное переключение на XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="50ba0-127">Manually Switching to the XmlSerializer</span></span>  
 <span data-ttu-id="50ba0-128">Иногда может понадобиться ручное переключение на <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="50ba0-128">At times, you may have to manually switch to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="50ba0-129">Это происходит, например, в следующих случаях:</span><span class="sxs-lookup"><span data-stu-id="50ba0-129">This happens, for example, in the following cases:</span></span>  
  
-   <span data-ttu-id="50ba0-130">При миграции приложения из [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] веб-служб для WCF, может потребоваться повторное использование существующих <xref:System.Xml.Serialization.XmlSerializer>-совместимых типов вместо создания новых данных типов контрактов.</span><span class="sxs-lookup"><span data-stu-id="50ba0-130">When migrating an application from [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] Web services to WCF, you may want to reuse existing, <xref:System.Xml.Serialization.XmlSerializer>-compatible types instead of creating new data contract types.</span></span>  
  
-   <span data-ttu-id="50ba0-131">Если важен четкий контроль над XML-кодом, появляющимся в сообщении, но документ WSDL отсутствует - например, при создании службы с типами, которые должны соответствовать некоторой стандартизированной опубликованной схеме, которая не совместима с DataContractSerializer.</span><span class="sxs-lookup"><span data-stu-id="50ba0-131">When precise control over the XML that appears in messages is important, but a Web Services Description Language (WSDL) document is not available, for example, when creating a service with types that have to comply to a certain standardized, published schema that is not compatible with the DataContractSerializer.</span></span>  
  
-   <span data-ttu-id="50ba0-132">При создании служб, которые используют стандарт предыдущих версий с кодировкой SOAP.</span><span class="sxs-lookup"><span data-stu-id="50ba0-132">When creating services that follow the legacy SOAP Encoding standard.</span></span>  
  
 <span data-ttu-id="50ba0-133">В этом и в других случаях может понадобиться ручное переключение на класс <xref:System.Xml.Serialization.XmlSerializer> путем применения атрибута `XmlSerializerFormatAttribute` к службе, как показано в следующем коде.</span><span class="sxs-lookup"><span data-stu-id="50ba0-133">In these and other cases, you can manually switch to the <xref:System.Xml.Serialization.XmlSerializer> class by applying the `XmlSerializerFormatAttribute` attribute to your service, as shown in the following code.</span></span>  
  
 [!code-csharp[c_XmlSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#1)]
 [!code-vb[c_XmlSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#1)]  
  
## <a name="security-considerations"></a><span data-ttu-id="50ba0-134">Вопросы безопасности</span><span class="sxs-lookup"><span data-stu-id="50ba0-134">Security Considerations</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="50ba0-135">При переключении модулей сериализации необходимо соблюдать меры предосторожности.</span><span class="sxs-lookup"><span data-stu-id="50ba0-135">It is important to be careful when switching serialization engines.</span></span> <span data-ttu-id="50ba0-136">Один и тот же тип может быть сериализован в XML-код по-разному, в зависимости от используемого сериализатора.</span><span class="sxs-lookup"><span data-stu-id="50ba0-136">The same type can serialize to XML differently depending on the serializer being used.</span></span> <span data-ttu-id="50ba0-137">Если случайно был использован не тот сериализатор, может быть раскрыта информация из типа, который раскрывать не предполагалось.</span><span class="sxs-lookup"><span data-stu-id="50ba0-137">If you accidentally use the wrong serializer, you might be disclosing information from the type that you did not intend to disclose.</span></span>  
  
 <span data-ttu-id="50ba0-138">Например, класс <xref:System.Runtime.Serialization.DataContractSerializer> при сериализации типов контрактов данных сериализует только элементы, отмеченные атрибутом <xref:System.Runtime.Serialization.DataMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="50ba0-138">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> class only serializes members marked with the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute when serializing data contract types.</span></span> <span data-ttu-id="50ba0-139">Класс <xref:System.Xml.Serialization.XmlSerializer> сериализует любой открытый элемент.</span><span class="sxs-lookup"><span data-stu-id="50ba0-139">The <xref:System.Xml.Serialization.XmlSerializer> class serializes any public member.</span></span> <span data-ttu-id="50ba0-140">Смотрите тип в следующем коде.</span><span class="sxs-lookup"><span data-stu-id="50ba0-140">See the type in the following code.</span></span>  
  
 [!code-csharp[c_XmlSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#2)]
 [!code-vb[c_XmlSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#2)]  
  
 <span data-ttu-id="50ba0-141">Если тип был случайно использован в контракте службы, где выбран класс <xref:System.Xml.Serialization.XmlSerializer>, сериализуется элемент `creditCardNumber`, который, судя по всему, для этого не предназначен.</span><span class="sxs-lookup"><span data-stu-id="50ba0-141">If the type is inadvertently used in a service contract where the <xref:System.Xml.Serialization.XmlSerializer> class is selected, the `creditCardNumber` member is serialized, which is probably not intended.</span></span>  
  
 <span data-ttu-id="50ba0-142">Даже если класс <xref:System.Runtime.Serialization.DataContractSerializer> является значением по умолчанию, можно явным образом выбрать его для своей службы (хотя делать это не всегда обязательно), применив атрибут <xref:System.ServiceModel.DataContractFormatAttribute> к типу контракта данных.</span><span class="sxs-lookup"><span data-stu-id="50ba0-142">Even though the <xref:System.Runtime.Serialization.DataContractSerializer> class is the default, you can explicitly select it for your service (although doing this should never be required) by applying the <xref:System.ServiceModel.DataContractFormatAttribute> attribute to the service contract type.</span></span>  
  
 <span data-ttu-id="50ba0-143">Сериализатор, используемый для службы, является неотъемлемой частью контракта и не может быть изменен путем выбора другой привязки или путем изменения других параметров конфигурации.</span><span class="sxs-lookup"><span data-stu-id="50ba0-143">The serializer used for the service is an integral part of the contract and cannot be changed by selecting a different binding or by changing other configuration settings.</span></span>  
  
 <span data-ttu-id="50ba0-144">Другие важные вопросы безопасности распространяются на класс <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="50ba0-144">Other important security considerations apply to the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="50ba0-145">Во-первых, настоятельно рекомендуется все приложения WCF, использование <xref:System.Xml.Serialization.XmlSerializer> класс подписывается ключом, который защищен от раскрытия.</span><span class="sxs-lookup"><span data-stu-id="50ba0-145">First, it is strongly recommended that any WCF application that uses the <xref:System.Xml.Serialization.XmlSerializer> class is signed with a key that is safeguarded from disclosure.</span></span> <span data-ttu-id="50ba0-146">Данная рекомендация применяется и при переключении на <xref:System.Xml.Serialization.XmlSerializer> вручную, и при выполнении автоматического переключения (с помощью Svcutil.exe, добавления ссылки на службы или подобных средств).</span><span class="sxs-lookup"><span data-stu-id="50ba0-146">This recommendation applies both when a manual switch to the <xref:System.Xml.Serialization.XmlSerializer> is performed and when an automatic switch is performed (by Svcutil.exe, Add Service Reference, or a similar tool).</span></span> <span data-ttu-id="50ba0-147">Это обусловлено <xref:System.Xml.Serialization.XmlSerializer> модуль сериализации поддерживает загрузку *заранее созданных сборок сериализации* до тех пор, пока они подписаны тем же ключом, что приложение.</span><span class="sxs-lookup"><span data-stu-id="50ba0-147">This is because the <xref:System.Xml.Serialization.XmlSerializer> serialization engine supports the loading of *pre-generated serialization assemblies* as long as they are signed with the same key as the application.</span></span> <span data-ttu-id="50ba0-148">Неподписанное приложение совершенно не защищено от возможности совпадения злонамеренной сборки с ожидаемым именем заранее созданной сборки сериализации, размещенной в папке приложения или в глобальном кэше сборок.</span><span class="sxs-lookup"><span data-stu-id="50ba0-148">An unsigned application is completely unprotected from the possibility of a malicious assembly matching the expected name of the pre-generated serialization assembly being placed in the application folder or the global assembly cache.</span></span> <span data-ttu-id="50ba0-149">Чтобы попытаться сделать это, злоумышленнику, конечно, сначала нужно получить доступ с правами записи к одному из этих двух расположений.</span><span class="sxs-lookup"><span data-stu-id="50ba0-149">Of course, an attacker must first gain write access to one of these two locations to attempt this action.</span></span>  
  
 <span data-ttu-id="50ba0-150">Другая угроза, которая существует при использовании <xref:System.Xml.Serialization.XmlSerializer>, относится к доступу с правами записи к временной папке системы.</span><span class="sxs-lookup"><span data-stu-id="50ba0-150">Another threat that exists whenever you use <xref:System.Xml.Serialization.XmlSerializer> is related to write access to the system temporary folder.</span></span> <span data-ttu-id="50ba0-151"><xref:System.Xml.Serialization.XmlSerializer> Модуль сериализации, создает и использует временные *сборки сериализации* в этой папке.</span><span class="sxs-lookup"><span data-stu-id="50ba0-151">The <xref:System.Xml.Serialization.XmlSerializer> serialization engine creates and uses temporary *serialization assemblies* in this folder.</span></span> <span data-ttu-id="50ba0-152">Следует иметь в виду, что любой процесс с доступом на запись к временной папке может перезаписать эти сборки сериализации с помощью вредоносного кода.</span><span class="sxs-lookup"><span data-stu-id="50ba0-152">You should be aware that any process with write access to the temporary folder may overwrite these serialization assemblies with malicious code.</span></span>  
  
## <a name="rules-for-xmlserializer-support"></a><span data-ttu-id="50ba0-153">Правила для поддержки XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="50ba0-153">Rules for XmlSerializer support</span></span>  
 <span data-ttu-id="50ba0-154">Нельзя непосредственно применить <xref:System.Xml.Serialization.XmlSerializer>-совместимые атрибуты к параметрам операции контракта или возвратить значения.</span><span class="sxs-lookup"><span data-stu-id="50ba0-154">You cannot directly apply <xref:System.Xml.Serialization.XmlSerializer>-compatible attributes to contract operation parameters or return values.</span></span> <span data-ttu-id="50ba0-155">Однако они могут быть применены к типизированным сообщениям (части тела контракта сообщения), как показано в следующем коде.</span><span class="sxs-lookup"><span data-stu-id="50ba0-155">However, they can be applied to typed messages (message contract body parts), as shown in the following code.</span></span>  
  
 [!code-csharp[c_XmlSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#3)]
 [!code-vb[c_XmlSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#3)]  
  
 <span data-ttu-id="50ba0-156">При применении к типизированным элементам сообщений данные атрибуты переопределяют свойства, конфликтующие с атрибутами типизированного сообщения.</span><span class="sxs-lookup"><span data-stu-id="50ba0-156">When applied to typed message members, these attributes override properties that conflict on the typed message attributes.</span></span> <span data-ttu-id="50ba0-157">Например, в следующем коде `ElementName` переопределяет `Name`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-157">For example, in the following code, `ElementName` overrides `Name`.</span></span>  
  
 [!code-csharp[c_XmlSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#4)]
 [!code-vb[c_XmlSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#4)]  
  
 <span data-ttu-id="50ba0-158">Атрибут <xref:System.ServiceModel.MessageHeaderArrayAttribute> не поддерживается при использовании <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="50ba0-158">The <xref:System.ServiceModel.MessageHeaderArrayAttribute> attribute is not supported when using the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="50ba0-159">В этом случае <xref:System.Xml.Serialization.XmlSerializer> вызывает следующее исключение, которое освобождается до WCF: «Не может иметь элемент, объявленный на верхнем уровне схемы `maxOccurs` > 1.</span><span class="sxs-lookup"><span data-stu-id="50ba0-159">In this case, the <xref:System.Xml.Serialization.XmlSerializer> throws the following exception, which is released prior to WCF: "An element declared at the top level of a schema cannot have `maxOccurs` > 1.</span></span> <span data-ttu-id="50ba0-160">Укажите элемент-оболочку для more, указав `XmlArray` или `XmlArrayItem` вместо `XmlElementAttribute` или стиль параметров Wrapped».</span><span class="sxs-lookup"><span data-stu-id="50ba0-160">Provide a wrapper element for 'more' by using `XmlArray` or `XmlArrayItem` instead of `XmlElementAttribute`, or by using the Wrapped parameter style."</span></span>  
>   
>  <span data-ttu-id="50ba0-161">При получении такого исключения, разберитесь, с такой ли ситуацией пришлось столкнуться.</span><span class="sxs-lookup"><span data-stu-id="50ba0-161">If you receive such an exception, investigate whether this situation applies.</span></span>  
  
 <span data-ttu-id="50ba0-162">WCF не поддерживает <xref:System.Xml.Serialization.SoapIncludeAttribute> и <xref:System.Xml.Serialization.XmlIncludeAttribute> контракты атрибутов в контрактах сообщений и операции; используйте <xref:System.Runtime.Serialization.KnownTypeAttribute> атрибутом.</span><span class="sxs-lookup"><span data-stu-id="50ba0-162">WCF does not support the <xref:System.Xml.Serialization.SoapIncludeAttribute> and <xref:System.Xml.Serialization.XmlIncludeAttribute> attributes in message contracts and operation contracts; use the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute instead.</span></span>  
  
## <a name="types-that-implement-the-ixmlserializable-interface"></a><span data-ttu-id="50ba0-163">Типы, реализующие интерфейс IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="50ba0-163">Types that Implement the IXmlSerializable Interface</span></span>  
 <span data-ttu-id="50ba0-164">Типы, реализующие интерфейс `IXmlSerializable`, полностью поддерживаются сериализатором `DataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-164">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="50ba0-165">К данным типам всегда нужно применять атрибут <xref:System.Xml.Serialization.XmlSchemaProviderAttribute>, необходимый для управления их схемой.</span><span class="sxs-lookup"><span data-stu-id="50ba0-165">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="50ba0-166">Если выполняется сериализация полиморфных типов, необходимо применить атрибут <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> к типу, чтобы убедиться, что сериализуется правильный тип.</span><span class="sxs-lookup"><span data-stu-id="50ba0-166">If you are serializing polymorphic types you must apply the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> to the type to ensure the correct type is serialized.</span></span>  
  
 <span data-ttu-id="50ba0-167">Существует три разновидности типов, реализующих интерфейс `IXmlSerializable`: типы, представляющие производное содержимое; типы, представляющие одиночный элемент; устаревшие типы <xref:System.Data.DataSet>.</span><span class="sxs-lookup"><span data-stu-id="50ba0-167">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>  
  
-   <span data-ttu-id="50ba0-168">Типы содержимого используют метод поставщика схемы, заданный атрибутом `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-168">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="50ba0-169">Метод не возвращает значение `null`, и свойство <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> атрибута остается в значении по умолчанию `false`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-169">The method does not return `null` and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="50ba0-170">Это наиболее распространенное использование типов `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-170">This is the most common usage of `IXmlSerializable` types.</span></span>  
  
-   <span data-ttu-id="50ba0-171">Типы элемента используется в том случае, когда тип `IXmlSerializable` должен управлять собственным именем корневого элемента.</span><span class="sxs-lookup"><span data-stu-id="50ba0-171">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="50ba0-172">Чтобы пометить тип как тип элемента, установите свойство <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> атрибута <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> в значение `true` или верните значение `null` из метода поставщика схемы.</span><span class="sxs-lookup"><span data-stu-id="50ba0-172">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return `null` from the schema provider method.</span></span> <span data-ttu-id="50ba0-173">Наличие метода поставщика схемы является необязательным для типов элементов - вместо имени метода в `null` можно указать значение `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-173">Having a schema provider method is optional for element types – you may specify `null` instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="50ba0-174">Однако если `IsAny` имеет значение `true` и указан метод поставщика схемы, то метод должен возвращать значение `null`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-174">However, if `IsAny` is `true` and a schema provider method is specified, the method must return `null`.</span></span>  
  
-   <span data-ttu-id="50ba0-175">Устаревшие типы <xref:System.Data.DataSet> являются типами `IXmlSerializable`, не отмеченными атрибутом `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-175">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="50ba0-176">Вместо этого они используют для создания схемы метод <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A>.</span><span class="sxs-lookup"><span data-stu-id="50ba0-176">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="50ba0-177">Данный шаблон используется для типа `DataSet`, и его типизированный набор данных наследует класс в более ранних версиях .NET Framework; в настоящее время он устарел и поддерживается только из соображений совместимости с более ранними версиями.</span><span class="sxs-lookup"><span data-stu-id="50ba0-177">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="50ba0-178">Не используйте данный шаблон и всегда применяйте атрибут `XmlSchemaProviderAttribute` к своим типам `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-178">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>  
  
### <a name="ixmlserializable-content-types"></a><span data-ttu-id="50ba0-179">Типы содержимого IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="50ba0-179">IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="50ba0-180">При сериализации элемента данных типа, который реализует интерфейс `IXmlSerializable` и относится к определенному ранее типу содержимого, сериализатор записывает элемент-оболочку для элемента данных и передает управление методу <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A>.</span><span class="sxs-lookup"><span data-stu-id="50ba0-180">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="50ba0-181">Реализация <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> может записывать любой XML-код, включая добавление атрибутов в элемент-оболочку.</span><span class="sxs-lookup"><span data-stu-id="50ba0-181">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, which includes adding attributes to the wrapper element.</span></span> <span data-ttu-id="50ba0-182">После выполнения `WriteXml` сериализатор закрывает элемент.</span><span class="sxs-lookup"><span data-stu-id="50ba0-182">After `WriteXml` is done, the serializer closes the element.</span></span>  
  
 <span data-ttu-id="50ba0-183">При десериализации элемента данных типа, который реализует интерфейс `IXmlSerializable` и относится к определенному ранее типу содержимого, десериализатор помещает модуль чтения XML в элемент-оболочку для элемента данных и передает управление методу <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A>.</span><span class="sxs-lookup"><span data-stu-id="50ba0-183">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="50ba0-184">Метод должен прочесть весь элемент, включая открывающий и закрывающий теги.</span><span class="sxs-lookup"><span data-stu-id="50ba0-184">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="50ba0-185">Убедитесь, что код `ReadXml` обрабатывает случай, когда элемент пуст.</span><span class="sxs-lookup"><span data-stu-id="50ba0-185">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="50ba0-186">Кроме того, реализация `ReadXml` не должна использовать элемент программы-оболочки, именованный особым образом.</span><span class="sxs-lookup"><span data-stu-id="50ba0-186">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="50ba0-187">Имя, выбранное сериализатором, может изменяться.</span><span class="sxs-lookup"><span data-stu-id="50ba0-187">The name is chosen by the serializer can vary.</span></span>  
  
 <span data-ttu-id="50ba0-188">Разрешается полиморфно присваивать типы содержимого `IXmlSerializable`, например, элементам данных типа <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="50ba0-188">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="50ba0-189">Кроме того, для экземпляров типа разрешено значение null.</span><span class="sxs-lookup"><span data-stu-id="50ba0-189">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="50ba0-190">И наконец, можно использовать типы `IXmlSerializable` с включенным режимом сохранения графов объектов и с <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="50ba0-190">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="50ba0-191">Все эти функции требуют сериализатор WCF, вложил некоторые атрибуты в элемент программы-оболочки («nil» и «type» в пространстве имен экземпляра схемы XML и «Id», «Ref», «Type» и «Assembly» в пространстве имен относящиеся конкретно к WCF).</span><span class="sxs-lookup"><span data-stu-id="50ba0-191">All these features require the WCF serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a WCF-specific namespace).</span></span>  
  
#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="50ba0-192">Атрибуты, игнорируемые при реализации ReadXml</span><span class="sxs-lookup"><span data-stu-id="50ba0-192">Attributes to Ignore when Implementing ReadXml</span></span>  
 <span data-ttu-id="50ba0-193">Перед передачей управления коду `ReadXml` десериализатор проверяет XML-элемент, обнаруживает данные специальные атрибуты XML и работает с ними.</span><span class="sxs-lookup"><span data-stu-id="50ba0-193">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="50ba0-194">Например, если "nil" имеет значение `true`, десериализуется значение null, и `ReadXml` не вызывается.</span><span class="sxs-lookup"><span data-stu-id="50ba0-194">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="50ba0-195">Если обнаружен полиморфизм, содержимое десериализуется так, как если бы это был другой тип.</span><span class="sxs-lookup"><span data-stu-id="50ba0-195">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="50ba0-196">Вызывается реализация `ReadXml` полиморфно назначенного типа.</span><span class="sxs-lookup"><span data-stu-id="50ba0-196">The polymorphically-assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="50ba0-197">В любом случае, реализация `ReadXml` игнорирует данные специальные атрибуты, поскольку они обрабатываются десериализатором.</span><span class="sxs-lookup"><span data-stu-id="50ba0-197">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>  
  
### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="50ba0-198">Замечания по схемам для типов содержимого IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="50ba0-198">Schema Considerations for IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="50ba0-199">При экспорте схемы и типа содержимого `IXmlSerializable` вызывается метод поставщика схемы.</span><span class="sxs-lookup"><span data-stu-id="50ba0-199">When exporting schema and an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="50ba0-200"><xref:System.Xml.Schema.XmlSchemaSet> передается в метод поставщика схемы.</span><span class="sxs-lookup"><span data-stu-id="50ba0-200">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="50ba0-201">Метод может добавить любую допустимую схему в набор схем.</span><span class="sxs-lookup"><span data-stu-id="50ba0-201">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="50ba0-202">Набор схем содержит схему, которая уже была известна на момент экспорта схемы.</span><span class="sxs-lookup"><span data-stu-id="50ba0-202">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="50ba0-203">Если метод поставщика схем должен добавить элемент в набор схем, он должен определить, имеется ли в наборе схема <xref:System.Xml.Schema.XmlSchema> с соответствующим пространством имен.</span><span class="sxs-lookup"><span data-stu-id="50ba0-203">When the schema provider method must add an item to the schema set, it must determine whether an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="50ba0-204">Если это так, метод поставщика схемы должен добавить новый элемент в существующую схему `XmlSchema`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-204">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="50ba0-205">В противном случае, метод создает новый экземпляр `XmlSchema`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-205">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="50ba0-206">Это важно, если используются массивы типов `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-206">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="50ba0-207">Например, если есть тип `IXmlSerializable`, который экспортируется как тип "A" в пространстве имен "Б", возможно, что к моменту вызова метода поставщика схем, набор схем уже содержит схему для "Б" для удержания типа "ArrayOfA".</span><span class="sxs-lookup"><span data-stu-id="50ba0-207">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>  
  
 <span data-ttu-id="50ba0-208">Кроме добавления типов в <xref:System.Xml.Schema.XmlSchemaSet>, метод поставщика схемы для типов содержимого должен возвратить ненулевое значение.</span><span class="sxs-lookup"><span data-stu-id="50ba0-208">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="50ba0-209">Метод может возвратить <xref:System.Xml.XmlQualifiedName>, указывающий имя типа схемы, которая будет использоваться для заданного типа `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-209">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="50ba0-210">Полное имя также служит именем контракта данных и пространством имен для типа.</span><span class="sxs-lookup"><span data-stu-id="50ba0-210">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="50ba0-211">Не разрешается возвращать тип, не существующий в наборе схем, немедленно при возврате метода поставщика.</span><span class="sxs-lookup"><span data-stu-id="50ba0-211">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="50ba0-212">Однако предполагается, что к моменту экспорта всех типов (метод <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> вызывается для всех соответствующих типов <xref:System.Runtime.Serialization.XsdDataContractExporter> и выполняется доступ к свойству <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A>) тип существует в наборе схем.</span><span class="sxs-lookup"><span data-stu-id="50ba0-212">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="50ba0-213">Доступ к свойству `Schemas` до того, как были выполнены все соответствующие вызовы `Export`, может привести к созданию исключения <xref:System.Xml.Schema.XmlSchemaException>.</span><span class="sxs-lookup"><span data-stu-id="50ba0-213">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> <span data-ttu-id="50ba0-214">Дополнительные сведения о процессе экспорта см. в разделе [Экспорт схем из классов](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span><span class="sxs-lookup"><span data-stu-id="50ba0-214">For more information about the export process, see [Exporting Schemas from Classes](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span></span>  
  
 <span data-ttu-id="50ba0-215">Метод поставщика схемы также может возвратить тип <xref:System.Xml.Schema.XmlSchemaType> для использования.</span><span class="sxs-lookup"><span data-stu-id="50ba0-215">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="50ba0-216">Тип может быть или не быть анонимным.</span><span class="sxs-lookup"><span data-stu-id="50ba0-216">The type may or may not be anonymous.</span></span> <span data-ttu-id="50ba0-217">Если тип анонимный, схема для типа `IXmlSerializable` экспортируется как анонимный тип при каждом использовании типа `IXmlSerializable` в качестве элемента данных.</span><span class="sxs-lookup"><span data-stu-id="50ba0-217">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="50ba0-218">Тип `IXmlSerializable` все еще имеет контракт данных и пространство имен.</span><span class="sxs-lookup"><span data-stu-id="50ba0-218">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="50ba0-219">(Это определяется, как описано в разделе [имена контрактов данных](../../../../docs/framework/wcf/feature-details/data-contract-names.md) за исключением того, что <xref:System.Runtime.Serialization.DataContractAttribute> атрибут не может использоваться для настройки имени.) Если тип не анонимный, он должен быть одним из типов в наборе схем `XmlSchemaSet`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-219">(This is determined as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="50ba0-220">Данный случай эквивалентен возврату `XmlQualifiedName` типа.</span><span class="sxs-lookup"><span data-stu-id="50ba0-220">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>  
  
 <span data-ttu-id="50ba0-221">Кроме того, для типа экспортируется глобальное объявление элемента.</span><span class="sxs-lookup"><span data-stu-id="50ba0-221">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="50ba0-222">Если к типу не применен атрибут <xref:System.Xml.Serialization.XmlRootAttribute>, то элемент имеет те же имя и пространство имен, что и контракт данных, а его свойство nillable имеет значение `true`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-222">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is `true`.</span></span> <span data-ttu-id="50ba0-223">Единственным исключением из этого является пространство имен схемы (`http://www.w3.org/2001/XMLSchema`) — Если в этом пространстве имен типа контракта данных, соответствующий глобальный элемент находится в пустом пространстве имен, поскольку запрещена для добавления новых элементов к пространству имен схемы.</span><span class="sxs-lookup"><span data-stu-id="50ba0-223">The only exception to this is the schema namespace (`http://www.w3.org/2001/XMLSchema`) – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="50ba0-224">Если тип имеет применяемый к нему атрибут `XmlRootAttribute`, глобальное объявление элемента экспортируется с помощью свойств <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> и <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A>.</span><span class="sxs-lookup"><span data-stu-id="50ba0-224">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="50ba0-225">Значениями по умолчанию при применении атрибута `XmlRootAttribute` являются имя контракта данных, пустое пространство имен, а свойство «nillable» имеет значение `true`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-225">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being `true`.</span></span>  
  
 <span data-ttu-id="50ba0-226">Те же правила объявления глобального элемента применяются и к устаревшим типам наборов данных.</span><span class="sxs-lookup"><span data-stu-id="50ba0-226">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="50ba0-227">Важно отметить, что `XmlRootAttribute` не может переопределить объявления глобальных элементов, добавленных с помощью пользовательского кода или добавленных в набор схем `XmlSchemaSet` с помощью метода поставщика схем или посредством метода `GetSchema` для устаревших типов наборов данных.</span><span class="sxs-lookup"><span data-stu-id="50ba0-227">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>  
  
### <a name="ixmlserializable-element-types"></a><span data-ttu-id="50ba0-228">Типы элемента IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="50ba0-228">IXmlSerializable Element Types</span></span>  
 `IXmlSerializable` <span data-ttu-id="50ba0-229">типы элементов имеющие `IsAny` свойство значение `true` или их метод поставщика схем возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-229">element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>  
  
 <span data-ttu-id="50ba0-230">Сериализация и десериализация типа элемента очень похожа на сериализацию и десериализацию типа содержимого.</span><span class="sxs-lookup"><span data-stu-id="50ba0-230">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="50ba0-231">Однако есть некоторые важные отличия.</span><span class="sxs-lookup"><span data-stu-id="50ba0-231">However, there are some important differences:</span></span>  
  
-   <span data-ttu-id="50ba0-232">Как правило, реализация `WriteXml` записывает только один элемент (который, конечно, может содержать несколько дочерних элементов).</span><span class="sxs-lookup"><span data-stu-id="50ba0-232">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="50ba0-233">Она не должна записывать атрибуты вне данного одиночного элемента, несколько родственных элементов или смешанное содержимое.</span><span class="sxs-lookup"><span data-stu-id="50ba0-233">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="50ba0-234">Элемент может быть пустым.</span><span class="sxs-lookup"><span data-stu-id="50ba0-234">The element may be empty.</span></span>  
  
-   <span data-ttu-id="50ba0-235">Реализация `ReadXml` не должна прочитывать элемент программы-оболочки.</span><span class="sxs-lookup"><span data-stu-id="50ba0-235">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="50ba0-236">Как правило, реализация прочитывает один элемент, создаваемый методом `WriteXml`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-236">It is expected to read the one element that `WriteXml` produces.</span></span>  
  
-   <span data-ttu-id="50ba0-237">При регулярной сериализации типа элемента (например, как элемента данных в контракте данных) сериализатор, как и в случае с типами содержимого, выводит элемент программы-оболочки до вызова метода `WriteXml`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-237">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="50ba0-238">Однако при сериализации типа элемента на верхнем уровне сериализатор обычно не выводит элемент-оболочку в окружение элемента, который записывается методом `WriteXml`, кроме случая, когда корневое имя и пространство имен явно заданы при конструировании сериализатора в конструкторах `DataContractSerializer` или `NetDataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-238">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace are explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> <span data-ttu-id="50ba0-239">Дополнительные сведения см. в разделе [сериализации и десериализации](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="50ba0-239">For more information, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span></span>  
  
-   <span data-ttu-id="50ba0-240">При сериализации типа элемента на верхнем уровне без указания корневого имени и пространства имен во время создания <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> и <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> обычно не выполняют никаких операций, а <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> вызывает `WriteXml`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-240">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially do nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="50ba0-241">В данном режиме сериализуемый объект не может иметь значение `null` и не может быть назначен полиморфно.</span><span class="sxs-lookup"><span data-stu-id="50ba0-241">In this mode, the object being serialized cannot be `null` and cannot be polymorphically assigned.</span></span> <span data-ttu-id="50ba0-242">Кроме того, не может быть включено сохранение графов объектов и не может использоваться `NetDataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-242">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>  
  
-   <span data-ttu-id="50ba0-243">При десериализации типа элемента на верхнем уровне без указания корневого имени и пространства имен во время построения <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> возвращает значение `true`, если не может найти начало хотя бы одного из элементов.</span><span class="sxs-lookup"><span data-stu-id="50ba0-243">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> <span data-ttu-id="50ba0-244">с помощью `verifyObjectName` параметру присвоить `true` ведет себя так же, как `IsStartObject` перед фактическим считыванием объекта.</span><span class="sxs-lookup"><span data-stu-id="50ba0-244">with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> `ReadObject` <span data-ttu-id="50ba0-245">затем передает управление `ReadXml` метод.</span><span class="sxs-lookup"><span data-stu-id="50ba0-245">then passes control to `ReadXml` method.</span></span>  
  
 <span data-ttu-id="50ba0-246">Схема, экспортированная для типов элементов, аналогична схеме для типа `XmlElement`, как описано в предыдущем разделе, за исключением того, что метод поставщика схемы может добавлять дополнительную схему в <xref:System.Xml.Schema.XmlSchemaSet> как типы содержимого.</span><span class="sxs-lookup"><span data-stu-id="50ba0-246">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="50ba0-247">Использование атрибута `XmlRootAttribute` с типами элемента не разрешено, и для данных типов никогда не выдаются глобальные объявления элемента.</span><span class="sxs-lookup"><span data-stu-id="50ba0-247">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>  
  
### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="50ba0-248">Отличия от XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="50ba0-248">Differences from the XmlSerializer</span></span>  
 <span data-ttu-id="50ba0-249">Сериализатор `IXmlSerializable` также понимает интерфейс `XmlSchemaProviderAttribute` и атрибуты `XmlRootAttribute` и <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="50ba0-249">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="50ba0-250">Однако есть некоторые отличия в том, как данные атрибуты обрабатываются в модели контракта данных.</span><span class="sxs-lookup"><span data-stu-id="50ba0-250">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="50ba0-251">Сводка важнейших отличий представлена ниже.</span><span class="sxs-lookup"><span data-stu-id="50ba0-251">The important differences are summarized in the following list:</span></span>  
  
-   <span data-ttu-id="50ba0-252">Метод поставщика схемы должен быть открытым для использования в `XmlSerializer`, но не должен быть открытым для использования в модели контракта данных.</span><span class="sxs-lookup"><span data-stu-id="50ba0-252">The schema provider method must be public to be used in the `XmlSerializer`, but does not have to be public to be used in the data contract model.</span></span>  
  
-   <span data-ttu-id="50ba0-253">Метод поставщика схемы вызывается, если свойству `IsAny` имеет значение `true` в модели контракта данных, но не с `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-253">The schema provider method is called when `IsAny` is `true` in the data contract model but not with the `XmlSerializer`.</span></span>  
  
-   <span data-ttu-id="50ba0-254">Если атрибут `XmlRootAttribute` не присутствует в содержимом или устаревших типах набора данных, сериализатор `XmlSerializer` экспортирует глобальное объявление элемента в пустое пространство имени.</span><span class="sxs-lookup"><span data-stu-id="50ba0-254">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="50ba0-255">В модели контракта данных используемым пространством имен обычно является пространство имен контракта данных, как было описано ранее.</span><span class="sxs-lookup"><span data-stu-id="50ba0-255">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>  
  
 <span data-ttu-id="50ba0-256">Помните об этих отличиях при создании типов, которые используются с обеими технологиями сериализации.</span><span class="sxs-lookup"><span data-stu-id="50ba0-256">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>  
  
### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="50ba0-257">Импорт схемы IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="50ba0-257">Importing IXmlSerializable Schema</span></span>  
 <span data-ttu-id="50ba0-258">При импорте схемы, созданной из типов `IXmlSerializable`, существует несколько возможностей.</span><span class="sxs-lookup"><span data-stu-id="50ba0-258">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>  
  
-   <span data-ttu-id="50ba0-259">Созданная схема может быть действительной схемой контракта данных, как описано в разделе [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="50ba0-259">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span> <span data-ttu-id="50ba0-260">В таком случае, схема может быть импортирована обычным образом, и создаются обычные типы контракта данных.</span><span class="sxs-lookup"><span data-stu-id="50ba0-260">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>  
  
-   <span data-ttu-id="50ba0-261">Созданная схема может не быть действительной схемой контракта данных.</span><span class="sxs-lookup"><span data-stu-id="50ba0-261">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="50ba0-262">Например, метод поставщика схемы может создать схему, которая включает XML-атрибуты, не поддерживаемые в модели контракта данных.</span><span class="sxs-lookup"><span data-stu-id="50ba0-262">For example, your schema provider method may generate schema that involves XML attributes that are not supported in the data contract model.</span></span> <span data-ttu-id="50ba0-263">В данном случае можно импортировать схему как типы `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-263">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="50ba0-264">Этот режим импорта по умолчанию не установлен, но можно легко включить — например, с помощью `/importXmlTypes` параметр командной строки для [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span><span class="sxs-lookup"><span data-stu-id="50ba0-264">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="50ba0-265">Это подробно описан в [Импорт схемы для создания классов](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="50ba0-265">This is described in detail in the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="50ba0-266">Обратите внимание, что работать нужно непосредственно с XML собственных экземпляров типа.</span><span class="sxs-lookup"><span data-stu-id="50ba0-266">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="50ba0-267">Кроме того, следует принимать во внимание другую технологию сериализации, поддерживающую широкий диапазон схем - см. раздел, посвященный использованию `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="50ba0-267">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>  
  
-   <span data-ttu-id="50ba0-268">Возможно, вам понадобится повторно использовать существующие типы `IXmlSerializable` в прокси, вместо того чтобы создавать новые.</span><span class="sxs-lookup"><span data-stu-id="50ba0-268">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="50ba0-269">В таком случае для указания типа для повторного использования может использоваться функция ссылочных типов, описанная в разделе «Импорт схемы для создания типов».</span><span class="sxs-lookup"><span data-stu-id="50ba0-269">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="50ba0-270">Это соответствует использованию параметра `/reference` программы svcutil.exe, указывающего на сборку, которая содержит типы для повторного использования.</span><span class="sxs-lookup"><span data-stu-id="50ba0-270">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>  
  
### <a name="xmlserializer-legacy-behavior"></a><span data-ttu-id="50ba0-271">Поведение предыдущих версий XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="50ba0-271">XmlSerializer Legacy Behavior</span></span>  
 <span data-ttu-id="50ba0-272">В .NET Framework 4.0 и более ранних версиях XmlSerializer формировал временные сборки сериализации путем записи кода C# в файл.</span><span class="sxs-lookup"><span data-stu-id="50ba0-272">In the .NET Framework 4.0 and earlier, the XmlSerializer generated temporary serialization assemblies by writing C# code to a file.</span></span> <span data-ttu-id="50ba0-273">Затем файл компилировался в сборку.</span><span class="sxs-lookup"><span data-stu-id="50ba0-273">The file was then compiled into an assembly.</span></span>  <span data-ttu-id="50ba0-274">Это имело некоторые нежелательные последствия, например замедление времени запуска для сериализатора.</span><span class="sxs-lookup"><span data-stu-id="50ba0-274">This behavior had some undesirable consequences like slowing the startup time for the serializer.</span></span> <span data-ttu-id="50ba0-275">В .NET Framework 4.5 сборки формируются без использования компилятора.</span><span class="sxs-lookup"><span data-stu-id="50ba0-275">In .NET Framework 4.5, this behavior was changed to generate the assemblies without requiring use of the compiler.</span></span> <span data-ttu-id="50ba0-276">Некоторым разработчикам может потребоваться просмотр сформированного кода C#.</span><span class="sxs-lookup"><span data-stu-id="50ba0-276">Some developers may wish to see the generated C# code.</span></span> <span data-ttu-id="50ba0-277">Вернуться к поведению предыдущих версий можно с помощью следующих настроек:</span><span class="sxs-lookup"><span data-stu-id="50ba0-277">You can specify to use this legacy behavior by the following configuration:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
  <system.xml.serialization>  
    <xmlSerializer tempFilesLocation='e:\temp\XmlSerializerBug' useLegacySerializerGeneration="true" />  
  </system.xml.serialization>  
  <system.diagnostics>  
    <switches>  
      <add name="XmlSerialization.Compilation" value="1" />  
    </switches>  
  </system.diagnostics>  
</configuration>  
```  
  
 <span data-ttu-id="50ba0-278">Если возникли проблемы с совместимостью, такие как `XmlSerializer` не удается сериализовать производный класс с является переопределением нового закрытым, вы можете переключиться обратно `XMLSerializer` устаревшее поведение с помощью следующей конфигурации:</span><span class="sxs-lookup"><span data-stu-id="50ba0-278">If you run into compatibility issues,  such as the `XmlSerializer` failing to serialize a derived class with a non-public new override, you can switch back to the  `XMLSerializer` legacy behavior by using the following configuration:</span></span>  
  
```xml  
<configuration>  
<appSettings>   
<add key="System:Xml:Serialization:UseLegacySerializerGeneration" value="true" />  
               </appSettings>  
</configuration>  
```  
  
 <span data-ttu-id="50ba0-279">В качестве альтернативы для представленной выше конфигурации на компьютере под управлением .NET Framework 4.5 или более поздней версии можно использовать следующую конфигурацию:</span><span class="sxs-lookup"><span data-stu-id="50ba0-279">As an alternative to the above configuration, you can use the following configuration on a machine running .NET Framework 4.5 or later version:</span></span>  
  
```xml  
<configuration>  
<system.xml.serialization>  
<xmlSerializer useLegacySerializerGeneration="true"/>  
</system.xml.serialization>  
</configuration>  
```  
  
> [!NOTE]
>  <span data-ttu-id="50ba0-280">`<xmlSerializer useLegacySerializerGeneration="true"/>` Коммутатор работает только на компьютере под управлением .NET Framework 4.5 или более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="50ba0-280">The `<xmlSerializer useLegacySerializerGeneration="true"/>` switch only works on a machine running .NET Framework 4.5 or later version.</span></span> <span data-ttu-id="50ba0-281">Выше `appSettings` подход работает во всех версиях .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="50ba0-281">The above `appSettings` approach works on all .NET Framework versions.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="50ba0-282">См. также</span><span class="sxs-lookup"><span data-stu-id="50ba0-282">See also</span></span>

- <xref:System.ServiceModel.DataContractFormatAttribute>
- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.Serialization.XmlSerializer>
- <xref:System.ServiceModel.MessageHeaderArrayAttribute>
- [<span data-ttu-id="50ba0-283">Задание передачи данных в контрактах служб</span><span class="sxs-lookup"><span data-stu-id="50ba0-283">Specifying Data Transfer in Service Contracts</span></span>](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)
- [<span data-ttu-id="50ba0-284">Использование контрактов данных</span><span class="sxs-lookup"><span data-stu-id="50ba0-284">Using Data Contracts</span></span>](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)
- [<span data-ttu-id="50ba0-285">Практическое руководство. Сокращение времени запуска клиентских приложений WCF с использованием XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="50ba0-285">How to: Improve the Startup Time of WCF Client Applications using the XmlSerializer</span></span>](../../../../docs/framework/wcf/feature-details/startup-time-of-wcf-client-applications-using-the-xmlserializer.md)
