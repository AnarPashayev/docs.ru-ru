---
title: Сериализация и десериализация
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 3d71814c-bda7-424b-85b7-15084ff9377a
ms.openlocfilehash: d9afa49525f03c06f94b1b7b704fb3d9caa9e19d
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/08/2019
ms.locfileid: "59101820"
---
# <a name="serialization-and-deserialization"></a><span data-ttu-id="3a71e-102">Сериализация и десериализация</span><span class="sxs-lookup"><span data-stu-id="3a71e-102">Serialization and Deserialization</span></span>
<span data-ttu-id="3a71e-103">Windows Communication Foundation (WCF) включает новый модуль сериализации, <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="3a71e-103">Windows Communication Foundation (WCF) includes a new serialization engine, the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="3a71e-104">Сериализатор <xref:System.Runtime.Serialization.DataContractSerializer> преобразует объекты [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] в формат XML и обратно.</span><span class="sxs-lookup"><span data-stu-id="3a71e-104">The <xref:System.Runtime.Serialization.DataContractSerializer> translates between [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] objects and XML, in both directions.</span></span> <span data-ttu-id="3a71e-105">В данном разделе объясняется, как работает сериализатор.</span><span class="sxs-lookup"><span data-stu-id="3a71e-105">This topic explains how the serializer works.</span></span>  
  
 <span data-ttu-id="3a71e-106">При сериализации объектов [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] сериализатор поддерживает различные модели программирования сериализации, включая новую модель *контракта данных* .</span><span class="sxs-lookup"><span data-stu-id="3a71e-106">When serializing [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] objects, the serializer understands a variety of serialization programming models, including the new *data contract* model.</span></span> <span data-ttu-id="3a71e-107">Полный список поддерживаемых типов см. в разделе [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="3a71e-107">For a full list of supported types, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="3a71e-108">Вводные сведения о контрактах данных см. в разделе [Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="3a71e-108">For an introduction to data contracts, see [Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md).</span></span>  
  
 <span data-ttu-id="3a71e-109">При десериализации XML-кода сериализатор использует классы <xref:System.Xml.XmlReader> и <xref:System.Xml.XmlWriter> .</span><span class="sxs-lookup"><span data-stu-id="3a71e-109">When deserializing XML, the serializer uses the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="3a71e-110">Она также поддерживает <xref:System.Xml.XmlDictionaryReader> и <xref:System.Xml.XmlDictionaryWriter> классы, чтобы включить может создавать оптимизированный XML-код в некоторых случаях, например когда форматирование с использованием двоичного XML WCF.</span><span class="sxs-lookup"><span data-stu-id="3a71e-110">It also supports the <xref:System.Xml.XmlDictionaryReader> and <xref:System.Xml.XmlDictionaryWriter> classes to enable it to produce optimized XML in some cases, such as when using the WCF binary XML format.</span></span>  
  
 <span data-ttu-id="3a71e-111">WCF также включает сопровождающий сериализатор <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="3a71e-111">WCF also includes a companion serializer, the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="3a71e-112">Сериализатор <xref:System.Runtime.Serialization.NetDataContractSerializer> аналогичен сериализаторам <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> и <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> в том, что он отображает имена типов [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] как часть сериализованных данных.</span><span class="sxs-lookup"><span data-stu-id="3a71e-112">The <xref:System.Runtime.Serialization.NetDataContractSerializer> is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> serializers because it also emits [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] type names as part of the serialized data.</span></span> <span data-ttu-id="3a71e-113">Он применяется при совместном использовании одних и тех же типов на концах сериализации и десериализации.</span><span class="sxs-lookup"><span data-stu-id="3a71e-113">It is used when the same types are shared on the serializing and the deserializing ends.</span></span> <span data-ttu-id="3a71e-114">Оба сериализатора ( <xref:System.Runtime.Serialization.DataContractSerializer> и <xref:System.Runtime.Serialization.NetDataContractSerializer> ) являются производными от общего базового класса <xref:System.Runtime.Serialization.XmlObjectSerializer>.</span><span class="sxs-lookup"><span data-stu-id="3a71e-114">Both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Runtime.Serialization.NetDataContractSerializer> derive from a common base class, the <xref:System.Runtime.Serialization.XmlObjectSerializer>.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="3a71e-115">Класс <xref:System.Runtime.Serialization.DataContractSerializer> сериализует строки, содержащие управляющие символы с шестнадцатеричным значением меньше 20 в виде сущностей XML.</span><span class="sxs-lookup"><span data-stu-id="3a71e-115">The <xref:System.Runtime.Serialization.DataContractSerializer> serializes strings containing control characters with a hexadecimal value below 20 as XML entities.</span></span> <span data-ttu-id="3a71e-116">Это может вызвать проблем с клиентом не WCF, при отправке таких данных к службе WCF.</span><span class="sxs-lookup"><span data-stu-id="3a71e-116">This may cause a problem with a non-WCF client when sending such data to a WCF service.</span></span>  
  
## <a name="creating-a-datacontractserializer-instance"></a><span data-ttu-id="3a71e-117">Создание экземпляра DataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="3a71e-117">Creating a DataContractSerializer Instance</span></span>  
 <span data-ttu-id="3a71e-118">Создание экземпляра <xref:System.Runtime.Serialization.DataContractSerializer> является важным этапом.</span><span class="sxs-lookup"><span data-stu-id="3a71e-118">Constructing an instance of the <xref:System.Runtime.Serialization.DataContractSerializer> is an important step.</span></span> <span data-ttu-id="3a71e-119">После создания экземпляра невозможно менять какие-либо настройки.</span><span class="sxs-lookup"><span data-stu-id="3a71e-119">After construction, you cannot change any of the settings.</span></span>  
  
### <a name="specifying-the-root-type"></a><span data-ttu-id="3a71e-120">Задание корневого типа</span><span class="sxs-lookup"><span data-stu-id="3a71e-120">Specifying the Root Type</span></span>  
 <span data-ttu-id="3a71e-121">*Корневой тип* - это тип, экземпляры которого сериализуются и десериализуются.</span><span class="sxs-lookup"><span data-stu-id="3a71e-121">The *root type* is the type of which instances are serialized or deserialized.</span></span> <span data-ttu-id="3a71e-122">Сериализатор <xref:System.Runtime.Serialization.DataContractSerializer> имеет множество перегрузок конструктора, однако хотя бы корневой тип должен предоставляться с использованием параметра `type` .</span><span class="sxs-lookup"><span data-stu-id="3a71e-122">The <xref:System.Runtime.Serialization.DataContractSerializer> has many constructor overloads, but, at a minimum, a root type must be supplied using the `type` parameter.</span></span>  
  
 <span data-ttu-id="3a71e-123">Сериализатор, созданный для определенного корневого типа, невозможно использовать для сериализации (или десериализации) другого типа, если только он не наследуется от корневого типа.</span><span class="sxs-lookup"><span data-stu-id="3a71e-123">A serializer created for a certain root type cannot be used to serialize (or deserialize) another type, unless the type is derived from the root type.</span></span> <span data-ttu-id="3a71e-124">В следующем примере показаны два класса.</span><span class="sxs-lookup"><span data-stu-id="3a71e-124">The following example shows two classes.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#1)]
 [!code-vb[c_StandaloneDataContractSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#1)]  
  
 <span data-ttu-id="3a71e-125">Этот код создает экземпляр `DataContractSerializer` , который можно использовать только для сериализации и десериализации экземпляров класса `Person` .</span><span class="sxs-lookup"><span data-stu-id="3a71e-125">This code constructs an instance of the `DataContractSerializer` that can be used only to serialize or deserialize instances of the `Person` class.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#2)]
 [!code-vb[c_StandaloneDataContractSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#2)]  
  
### <a name="specifying-known-types"></a><span data-ttu-id="3a71e-126">Задание известных типов</span><span class="sxs-lookup"><span data-stu-id="3a71e-126">Specifying Known Types</span></span>  
 <span data-ttu-id="3a71e-127">Если в сериализуемых типах, которые еще не были обработаны с помощью атрибута <xref:System.Runtime.Serialization.KnownTypeAttribute> или какого-либо другого механизма, применяется полиморфизм, то конструктору сериализатора с помощью параметра `knownTypes` необходимо передать список возможных известных типов.</span><span class="sxs-lookup"><span data-stu-id="3a71e-127">If polymorphism is involved in the types being serialized that is not already handled using the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute or some other mechanism, a list of possible known types must be passed to the serializer’s constructor using the `knownTypes` parameter.</span></span> <span data-ttu-id="3a71e-128">Дополнительные сведения об известных типах см. в разделе [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span><span class="sxs-lookup"><span data-stu-id="3a71e-128">For more information about known types, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span></span>  
  
 <span data-ttu-id="3a71e-129">В следующем примере продемонстрирован класс `LibraryPatron`, который включает коллекцию указанного типа `LibraryItem`.</span><span class="sxs-lookup"><span data-stu-id="3a71e-129">The following example shows a class, `LibraryPatron`, that includes a collection of a specific type, the `LibraryItem`.</span></span> <span data-ttu-id="3a71e-130">Второй класс определяет тип `LibraryItem` .</span><span class="sxs-lookup"><span data-stu-id="3a71e-130">The second class defines the `LibraryItem` type.</span></span> <span data-ttu-id="3a71e-131">Третий и четвертый классы (`Book` и `Newspaper`) наследуются от класса `LibraryItem` .</span><span class="sxs-lookup"><span data-stu-id="3a71e-131">The third and four classes (`Book` and `Newspaper`) inherit from the `LibraryItem` class.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#3)]  
 [!code-vb[c_StandaloneDataContractSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#3)]  
  
 <span data-ttu-id="3a71e-132">В следующем примере кода демонстрируется создание экземпляра сериализатора с использованием параметра `knownTypes` .</span><span class="sxs-lookup"><span data-stu-id="3a71e-132">The following code constructs an instance of the serializer using the `knownTypes` parameter.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#4)]
 [!code-vb[c_StandaloneDataContractSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#4)]  
  
### <a name="specifying-the-default-root-name-and-namespace"></a><span data-ttu-id="3a71e-133">Задание корневого имени и пространства имен по умолчанию</span><span class="sxs-lookup"><span data-stu-id="3a71e-133">Specifying the Default Root Name and Namespace</span></span>  
 <span data-ttu-id="3a71e-134">Как правило, при сериализации объекта имя и пространство имен по умолчанию внешнего элемента XML определяются в соответствии с именем и пространством имен контракта данных.</span><span class="sxs-lookup"><span data-stu-id="3a71e-134">Normally, when an object is serialized, the default name and namespace of the outermost XML element are determined according to the data contract name and namespace.</span></span> <span data-ttu-id="3a71e-135">Имена всех внутренних элементов определяются на основе имен членов данных, а их пространство имен представляет собой пространство имен контракта данных.</span><span class="sxs-lookup"><span data-stu-id="3a71e-135">The names of all inner elements are determined from data member names, and their namespace is the data contract’s namespace.</span></span> <span data-ttu-id="3a71e-136">В следующем примере задаются значения имени `Name` и пространства имен `Namespace` в конструкторах классов <xref:System.Runtime.Serialization.DataContractAttribute> и <xref:System.Runtime.Serialization.DataMemberAttribute> .</span><span class="sxs-lookup"><span data-stu-id="3a71e-136">The following example sets `Name` and `Namespace` values in the constructors of the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute> classes.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#5)]
 [!code-vb[c_StandaloneDataContractSerializer#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#5)]  
  
 <span data-ttu-id="3a71e-137">В ходе сериализации экземпляра класса `Person` создается XML-код, подобный следующему.</span><span class="sxs-lookup"><span data-stu-id="3a71e-137">Serializing an instance of the `Person` class produces XML similar to the following.</span></span>  
  
```xml  
<PersonContract xmlns="http://schemas.contoso.com">  
  <AddressMember>  
    <StreetMember>123 Main Street</StreetMember>  
   </AddressMember>  
</PersonContract>  
```  
  
 <span data-ttu-id="3a71e-138">Однако можно настроить имя и пространство имен корневого элемента по умолчанию, передав значения параметров `rootName` и `rootNamespace` конструктору <xref:System.Runtime.Serialization.DataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="3a71e-138">However, you can customize the default name and namespace of the root element by passing the values of the `rootName` and `rootNamespace` parameters to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor.</span></span> <span data-ttu-id="3a71e-139">Обратите внимание, что пространство имен `rootNamespace` не влияет на пространство имен содержащихся в нем элементов, которые соответствуют членам данных.</span><span class="sxs-lookup"><span data-stu-id="3a71e-139">Note that the `rootNamespace` does not affect the namespace of the contained elements that correspond to data members.</span></span> <span data-ttu-id="3a71e-140">Оно влияет только на пространство имен внешнего элемента.</span><span class="sxs-lookup"><span data-stu-id="3a71e-140">It affects only the namespace of the outermost element.</span></span>  
  
 <span data-ttu-id="3a71e-141">Эти значения могут быть переданы в виде строк или экземпляров класса <xref:System.Xml.XmlDictionaryString> , что позволяет их оптимизировать с использованием двоичного XML-формата.</span><span class="sxs-lookup"><span data-stu-id="3a71e-141">These values can be passed as strings or instances of the <xref:System.Xml.XmlDictionaryString> class to allow for their optimization using the binary XML format.</span></span>  
  
### <a name="setting-the-maximum-objects-quota"></a><span data-ttu-id="3a71e-142">Задание максимальной квоты объекта</span><span class="sxs-lookup"><span data-stu-id="3a71e-142">Setting the Maximum Objects Quota</span></span>  
 <span data-ttu-id="3a71e-143">Некоторые перегрузки конструктора `DataContractSerializer` имеют параметр `maxItemsInObjectGraph` .</span><span class="sxs-lookup"><span data-stu-id="3a71e-143">Some `DataContractSerializer` constructor overloads have a `maxItemsInObjectGraph` parameter.</span></span> <span data-ttu-id="3a71e-144">Этот параметр определяет максимальное число объектов, которые сериализатор сериализует или десериализует за один вызов метода <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> .</span><span class="sxs-lookup"><span data-stu-id="3a71e-144">This parameter determines the maximum number of objects the serializer serializes or deserializes in a single <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method call.</span></span> <span data-ttu-id="3a71e-145">(Этот метод всегда считывает один корневой объект, но в элементах данных этого объекта могут иметься другие объекты.</span><span class="sxs-lookup"><span data-stu-id="3a71e-145">(The method always reads one root object, but this object may have other objects in its data members.</span></span> <span data-ttu-id="3a71e-146">Эти объекты, в свою очередь, могут иметь в своем составе другие объекты и т. д.) Значение по умолчанию — 65536.</span><span class="sxs-lookup"><span data-stu-id="3a71e-146">Those objects may have other objects, and so on.) The default is 65536.</span></span> <span data-ttu-id="3a71e-147">Обратите внимание, что при сериализации или десериализации массивов каждая запись массива считается отдельным объектом.</span><span class="sxs-lookup"><span data-stu-id="3a71e-147">Note that when serializing or deserializing arrays, every array entry counts as a separate object.</span></span> <span data-ttu-id="3a71e-148">Также обратите внимание, что некоторые объекты могут иметь большое представление в памяти, поэтому одной этой квоты может быть недостаточно для предотвращения атак типа "отказ в обслуживании".</span><span class="sxs-lookup"><span data-stu-id="3a71e-148">Also, note that some objects may have a large memory representation, and so this quota alone may not be sufficient to prevent a denial of service attack.</span></span> <span data-ttu-id="3a71e-149">Дополнительные сведения см. в разделе [вопросы безопасности для данных](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md).</span><span class="sxs-lookup"><span data-stu-id="3a71e-149">For more information, see [Security Considerations for Data](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md).</span></span> <span data-ttu-id="3a71e-150">При необходимости увеличить квоту по сравнению со значением по умолчанию следует увеличить ее как на стороне отправки (сериализации), так и на стороне получения (десериализации), так как квота действует как при считывании, так и при записи данных.</span><span class="sxs-lookup"><span data-stu-id="3a71e-150">If you need to increase this quota beyond the default value, it is important to do so both on the sending (serializing) and receiving (deserializing) sides because it applies to both when reading and writing data.</span></span>  
  
### <a name="round-trips"></a><span data-ttu-id="3a71e-151">Циклы обработки</span><span class="sxs-lookup"><span data-stu-id="3a71e-151">Round Trips</span></span>  
 <span data-ttu-id="3a71e-152">*Цикл обработки* совершается, когда объект десериализуется и повторно сериализуется за одну операцию.</span><span class="sxs-lookup"><span data-stu-id="3a71e-152">A *round trip* occurs when an object is deserialized and re-serialized in one operation.</span></span> <span data-ttu-id="3a71e-153">Таким образом, он перемещается от XML-кода к экземпляру объекта, а затем возвращается в поток XML.</span><span class="sxs-lookup"><span data-stu-id="3a71e-153">Thus, it goes from XML to an object instance, and back again into an XML stream.</span></span>  
  
 <span data-ttu-id="3a71e-154">Некоторые перегрузки конструктора `DataContractSerializer` имеют параметр `ignoreExtensionDataObject` , для которого по умолчанию задано значение `false` .</span><span class="sxs-lookup"><span data-stu-id="3a71e-154">Some `DataContractSerializer` constructor overloads have an `ignoreExtensionDataObject` parameter, which is set to `false` by default.</span></span> <span data-ttu-id="3a71e-155">В этом режиме по умолчанию данные можно без потерь отправлять в цикл обработки от новой версии контракта данных через старую версию обратно к новой при условии, что контракт данных реализует интерфейс <xref:System.Runtime.Serialization.IExtensibleDataObject> .</span><span class="sxs-lookup"><span data-stu-id="3a71e-155">In this default mode, data can be sent on a round trip from a newer version of a data contract through an older version and back to the newer version without loss, as long as the data contract implements the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="3a71e-156">Предположим, например, что версия 1 контракта данных `Person` содержит члены данных `Name` и `PhoneNumber` , а версия 2 добавляет член `Nickname` .</span><span class="sxs-lookup"><span data-stu-id="3a71e-156">For example, suppose version 1 of the `Person` data contract contains the `Name` and `PhoneNumber` data members, and version 2 adds a `Nickname` member.</span></span> <span data-ttu-id="3a71e-157">Если реализуется объект `IExtensibleDataObject` , то при отправке информации из версии 2 в версию 1 данные `Nickname` сохраняются, а затем снова выдаются при повторной сериализации данных, поэтому данные не теряются при прохождении цикла обработки.</span><span class="sxs-lookup"><span data-stu-id="3a71e-157">If `IExtensibleDataObject` is implemented, when sending information from version 2 to version 1, the `Nickname` data is stored, and then re-emitted when the data is serialized again; therefore, no data is lost in the round trip.</span></span> <span data-ttu-id="3a71e-158">Дополнительные сведения см. в разделе [контракты данных обладает прямой совместимостью](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md) и [управление версиями контракта данных](../../../../docs/framework/wcf/feature-details/data-contract-versioning.md).</span><span class="sxs-lookup"><span data-stu-id="3a71e-158">For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md) and [Data Contract Versioning](../../../../docs/framework/wcf/feature-details/data-contract-versioning.md).</span></span>  
  
#### <a name="security-and-schema-validity-concerns-with-round-trips"></a><span data-ttu-id="3a71e-159">Проблемы безопасности и допустимости схемы в циклах обработки</span><span class="sxs-lookup"><span data-stu-id="3a71e-159">Security and Schema Validity Concerns with Round Trips</span></span>  
 <span data-ttu-id="3a71e-160">Циклы обработки влияют на безопасность.</span><span class="sxs-lookup"><span data-stu-id="3a71e-160">Round trips may have security implications.</span></span> <span data-ttu-id="3a71e-161">Например, десериализация и сохранение больших объемов лишних данных могут представлять угрозу безопасности.</span><span class="sxs-lookup"><span data-stu-id="3a71e-161">For example, deserializing and storing large amounts of extraneous data may be a security risk.</span></span> <span data-ttu-id="3a71e-162">Проблемы безопасности при повторной выдаче этих данных обусловлены невозможностью провести проверку, особенно если в процессе задействованы цифровые сигнатуры.</span><span class="sxs-lookup"><span data-stu-id="3a71e-162">There may be security concerns about re-emitting this data that there is no way to verify, especially if digital signatures are involved.</span></span> <span data-ttu-id="3a71e-163">Например, в вышеприведенном сценарии конечная точка версии 1 могла бы подписать значение `Nickname` , которое содержит вредоносные данные.</span><span class="sxs-lookup"><span data-stu-id="3a71e-163">For example, in the previous scenario, the version 1 endpoint could be signing a `Nickname` value that contains malicious data.</span></span> <span data-ttu-id="3a71e-164">Наконец, могут возникнуть проблемы с допустимостью схемы: конечная точка может всегда выдавать только данные, которые строго соответствуют ее заявленному контракту, и не поддерживать других значений.</span><span class="sxs-lookup"><span data-stu-id="3a71e-164">Finally, there may be schema validity concerns: an endpoint may want to always emit data that strictly adheres to its stated contract and not any extra values.</span></span> <span data-ttu-id="3a71e-165">В предыдущем примере в контракте конечной точки версии 1 говорится, что точка выдает только данные `Name` и `PhoneNumber`, а при использовании проверки допустимости схемы выдача дополнительного значения `Nickname` приводит к сбою проверки.</span><span class="sxs-lookup"><span data-stu-id="3a71e-165">In the previous example, the version 1 endpoint’s contract says that it emits only `Name` and `PhoneNumber`, and if schema validation is being used, emitting the extra `Nickname` value causes validation to fail.</span></span>  
  
#### <a name="enabling-and-disabling-round-trips"></a><span data-ttu-id="3a71e-166">Включение и отключение циклов обработки</span><span class="sxs-lookup"><span data-stu-id="3a71e-166">Enabling and Disabling Round Trips</span></span>  
 <span data-ttu-id="3a71e-167">Для отключения циклов обработки не реализуйте интерфейс <xref:System.Runtime.Serialization.IExtensibleDataObject> .</span><span class="sxs-lookup"><span data-stu-id="3a71e-167">To turn off round trips, do not implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="3a71e-168">Если невозможно управлять типами, для достижения такого же эффекта необходимо задать параметру `ignoreExtensionDataObject` значение `true` .</span><span class="sxs-lookup"><span data-stu-id="3a71e-168">If you have no control over the types, set the `ignoreExtensionDataObject` parameter to `true` to achieve the same effect.</span></span>  
  
### <a name="object-graph-preservation"></a><span data-ttu-id="3a71e-169">Сохранение графа объекта</span><span class="sxs-lookup"><span data-stu-id="3a71e-169">Object Graph Preservation</span></span>  
 <span data-ttu-id="3a71e-170">Как правило, удостоверение объекта не имеет значения для сериализатора, как показано в следующем примере кода.</span><span class="sxs-lookup"><span data-stu-id="3a71e-170">Normally, the serializer does not care about object identity, as in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#6)]
 [!code-vb[c_StandaloneDataContractSerializer#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#6)]  
  
 <span data-ttu-id="3a71e-171">В следующем примере кода демонстрируется создание заказа на покупку.</span><span class="sxs-lookup"><span data-stu-id="3a71e-171">The following code creates a purchase order.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#7)]
 [!code-vb[c_StandaloneDataContractSerializer#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#7)]  
  
 <span data-ttu-id="3a71e-172">Обратите внимание, что полям `billTo` и `shipTo` задан один и тот же экземпляр объекта.</span><span class="sxs-lookup"><span data-stu-id="3a71e-172">Notice that `billTo` and `shipTo` fields are set to the same object instance.</span></span> <span data-ttu-id="3a71e-173">Однако созданный XML-код дублирует повторяющуюся информацию и по внешнему виду аналогичен следующему XML-коду.</span><span class="sxs-lookup"><span data-stu-id="3a71e-173">However, the generated XML duplicates the information duplicated, and looks similar to the following XML.</span></span>  
  
```xml  
<PurchaseOrder>  
  <billTo><street>123 Main St.</street></billTo>  
  <shipTo><street>123 Main St.</street></shipTo>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="3a71e-174">Этот подход имеет следующие характеристики, которые могут оказаться нежелательными.</span><span class="sxs-lookup"><span data-stu-id="3a71e-174">However, this approach has the following characteristics, which may be undesirable:</span></span>  
  
-   <span data-ttu-id="3a71e-175">Производительность.</span><span class="sxs-lookup"><span data-stu-id="3a71e-175">Performance.</span></span> <span data-ttu-id="3a71e-176">Репликация данных неэффективна.</span><span class="sxs-lookup"><span data-stu-id="3a71e-176">Replicating data is inefficient.</span></span>  
  
-   <span data-ttu-id="3a71e-177">Циклические ссылки.</span><span class="sxs-lookup"><span data-stu-id="3a71e-177">Circular references.</span></span> <span data-ttu-id="3a71e-178">Если объекты ссылаются на самих себя (даже через другие объекты), сериализация результатов репликации приводит к бесконечному циклу.</span><span class="sxs-lookup"><span data-stu-id="3a71e-178">If objects refer to themselves, even through other objects, serializing by replication results in an infinite loop.</span></span> <span data-ttu-id="3a71e-179">(В этом случае сериализатор создает исключение <xref:System.Runtime.Serialization.SerializationException> .)</span><span class="sxs-lookup"><span data-stu-id="3a71e-179">(The serializer throws a <xref:System.Runtime.Serialization.SerializationException> if this happens.)</span></span>  
  
-   <span data-ttu-id="3a71e-180">Семантика.</span><span class="sxs-lookup"><span data-stu-id="3a71e-180">Semantics.</span></span> <span data-ttu-id="3a71e-181">Иногда очень важно сохранить отнесение двух ссылок к одному и тому же объекту, а не к двум идентичным объектам.</span><span class="sxs-lookup"><span data-stu-id="3a71e-181">Sometimes it is important to preserve the fact that two references are to the same object, and not to two identical objects.</span></span>  
  
 <span data-ttu-id="3a71e-182">По этим причинам некоторые перегрузки конструктора `DataContractSerializer` имеют параметр `preserveObjectReferences` (по умолчанию ему задано значение `false`).</span><span class="sxs-lookup"><span data-stu-id="3a71e-182">For these reasons, some `DataContractSerializer` constructor overloads have a `preserveObjectReferences` parameter (the default is `false`).</span></span> <span data-ttu-id="3a71e-183">Если этот параметр имеет значение `true`, используется специальный метод кодирования ссылок на объекты, которые понимает только WCF,.</span><span class="sxs-lookup"><span data-stu-id="3a71e-183">When this parameter is set to `true`, a special method of encoding object references, which only WCF understands, is used.</span></span> <span data-ttu-id="3a71e-184">Если задано значение `true`, пример XML-кода выглядит следующим образом.</span><span class="sxs-lookup"><span data-stu-id="3a71e-184">When set to `true`, the XML code example now resembles the following.</span></span>  
  
```xml  
<PurchaseOrder ser:id="1">  
  <billTo ser:id="2"><street ser:id="3">123 Main St.</street></billTo>  
  <shipTo ser:ref="2"/>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="3a71e-185">Пространство имен «ser» относится к пространству имен стандартную сериализацию `http://schemas.microsoft.com/2003/10/Serialization/`.</span><span class="sxs-lookup"><span data-stu-id="3a71e-185">The "ser" namespace refers to the standard serialization namespace, `http://schemas.microsoft.com/2003/10/Serialization/`.</span></span> <span data-ttu-id="3a71e-186">Каждый блок данных сериализуется только один раз, ему присваивается идентификационный номер, и при использовании этих блоков в будущем создается ссылка на уже сериализованные данные.</span><span class="sxs-lookup"><span data-stu-id="3a71e-186">Each piece of data is serialized only once and given an ID number, and subsequent uses result in a reference to the already serialized data.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3a71e-187">Если в контракте данных `XMLElement`присутствует и атрибут "id", и атрибут "ref", используется атрибут "ref", а атрибут "id" игнорируется.</span><span class="sxs-lookup"><span data-stu-id="3a71e-187">If both "id" and "ref" attributes are present in the data contract `XMLElement`, then the "ref" attribute is honored and the "id" attribute is ignored.</span></span>  
  
 <span data-ttu-id="3a71e-188">Важно понимать существующие в этом режиме ограничения.</span><span class="sxs-lookup"><span data-stu-id="3a71e-188">It is important to understand the limitations of this mode:</span></span>  
  
-   <span data-ttu-id="3a71e-189">XML-код, создаваемый сериализатором `DataContractSerializer` с помощью `preserveObjectReferences` с заданным значением `true` , не поддерживает возможность взаимодействия с какими-либо другими технологиями, доступ к нему может осуществлять только другой экземпляр `DataContractSerializer` , для `preserveObjectReferences` которого также задано значение `true`.</span><span class="sxs-lookup"><span data-stu-id="3a71e-189">The XML the `DataContractSerializer` produces with `preserveObjectReferences` set to `true` is not interoperable with any other technologies, and can be accessed only by another `DataContractSerializer` instance, also with `preserveObjectReferences` set to `true`.</span></span>  
  
-   <span data-ttu-id="3a71e-190">Эта функция не обеспечивается поддержкой метаданных (схемы).</span><span class="sxs-lookup"><span data-stu-id="3a71e-190">There is no metadata (schema) support for this feature.</span></span> <span data-ttu-id="3a71e-191">Созданная схема действительна, только если `preserveObjectReferences` задано значение `false`.</span><span class="sxs-lookup"><span data-stu-id="3a71e-191">The schema that is produced is valid only for the case when `preserveObjectReferences` is set to `false`.</span></span>  
  
-   <span data-ttu-id="3a71e-192">Эта функция может замедлить процесс сериализации и десериализации.</span><span class="sxs-lookup"><span data-stu-id="3a71e-192">This feature may cause the serialization and deserialization process to run slower.</span></span> <span data-ttu-id="3a71e-193">Несмотря на отсутствие необходимости в репликации данных, в этом режиме необходимо выполнять дополнительные сравнения объектов.</span><span class="sxs-lookup"><span data-stu-id="3a71e-193">Although data does not have to be replicated, extra object comparisons must be performed in this mode.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="3a71e-194">Если включен режим `preserveObjectReferences` , очень важно задать правильную квоту значению `maxItemsInObjectGraph` .</span><span class="sxs-lookup"><span data-stu-id="3a71e-194">When the `preserveObjectReferences` mode is enabled, it is especially important to set the `maxItemsInObjectGraph` value to the correct quota.</span></span> <span data-ttu-id="3a71e-195">Особенности обработки массивов в этом режиме позволяют злоумышленнику легко создавать небольшое вредоносное сообщение, которое приводит к расходованию больших объемов памяти, и препятствовать этому можно только заданием квоты `maxItemsInObjectGraph` .</span><span class="sxs-lookup"><span data-stu-id="3a71e-195">Due to the way arrays are handled in this mode, it is easy for an attacker to construct a small malicious message that results in large memory consumption limited only by the `maxItemsInObjectGraph` quota.</span></span>  
  
### <a name="specifying-a-data-contract-surrogate"></a><span data-ttu-id="3a71e-196">Задание суррогата контракта данных</span><span class="sxs-lookup"><span data-stu-id="3a71e-196">Specifying a Data Contract Surrogate</span></span>  
 <span data-ttu-id="3a71e-197">Некоторые перегрузки конструктора `DataContractSerializer` имеют параметр `dataContractSurrogate` , для которого может быть задано значение `null`.</span><span class="sxs-lookup"><span data-stu-id="3a71e-197">Some `DataContractSerializer` constructor overloads have a `dataContractSurrogate` parameter, which may be set to `null`.</span></span> <span data-ttu-id="3a71e-198">В противном случае можно использовать этот параметр для задания *суррогата контракта данных*, представляющего собой тип, который реализует интерфейс <xref:System.Runtime.Serialization.IDataContractSurrogate> .</span><span class="sxs-lookup"><span data-stu-id="3a71e-198">Otherwise, you can use it to specify a *data contract surrogate*, which is a type that implements the <xref:System.Runtime.Serialization.IDataContractSurrogate> interface.</span></span> <span data-ttu-id="3a71e-199">Затем с помощью интерфейса можно настроить процесс сериализации и десериализации.</span><span class="sxs-lookup"><span data-stu-id="3a71e-199">You can then use the interface to customize the serialization and deserialization process.</span></span> <span data-ttu-id="3a71e-200">Дополнительные сведения см. в разделе [суррогаты контрактов данных](../../../../docs/framework/wcf/extending/data-contract-surrogates.md).</span><span class="sxs-lookup"><span data-stu-id="3a71e-200">For more information, see [Data Contract Surrogates](../../../../docs/framework/wcf/extending/data-contract-surrogates.md).</span></span>  
  
## <a name="serialization"></a><span data-ttu-id="3a71e-201">Сериализация</span><span class="sxs-lookup"><span data-stu-id="3a71e-201">Serialization</span></span>  
 <span data-ttu-id="3a71e-202">Следующая информация применима к любому классу, наследуемому от сериализатора <xref:System.Runtime.Serialization.XmlObjectSerializer>, включая классы <xref:System.Runtime.Serialization.DataContractSerializer> и <xref:System.Runtime.Serialization.NetDataContractSerializer></span><span class="sxs-lookup"><span data-stu-id="3a71e-202">The following information applies to any class that inherits from the <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> classes.</span></span>  
  
### <a name="simple-serialization"></a><span data-ttu-id="3a71e-203">Простая сериализация</span><span class="sxs-lookup"><span data-stu-id="3a71e-203">Simple Serialization</span></span>  
 <span data-ttu-id="3a71e-204">Основным способом сериализации объекта является его передача методу <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> .</span><span class="sxs-lookup"><span data-stu-id="3a71e-204">The most basic way to serialize an object is to pass it to the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> method.</span></span> <span data-ttu-id="3a71e-205">Существует три перегрузки, каждая из которых предназначена для записи в <xref:System.IO.Stream>, <xref:System.Xml.XmlWriter>или <xref:System.Xml.XmlDictionaryWriter>соответственно.</span><span class="sxs-lookup"><span data-stu-id="3a71e-205">There are three overloads, one each for writing to a <xref:System.IO.Stream>, an <xref:System.Xml.XmlWriter>, or an <xref:System.Xml.XmlDictionaryWriter>.</span></span> <span data-ttu-id="3a71e-206">При использовании перегрузки <xref:System.IO.Stream> на выходе получается XML-код в кодировке UTF-8.</span><span class="sxs-lookup"><span data-stu-id="3a71e-206">With the <xref:System.IO.Stream> overload, the output is XML in the UTF-8 encoding.</span></span> <span data-ttu-id="3a71e-207">При использовании перегрузки <xref:System.Xml.XmlDictionaryWriter> сериализатор оптимизирует объекты на выходе для двоичного XML-формата.</span><span class="sxs-lookup"><span data-stu-id="3a71e-207">With the <xref:System.Xml.XmlDictionaryWriter> overload, the serializer optimizes its output for binary XML.</span></span>  
  
 <span data-ttu-id="3a71e-208">При использовании <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> метод, сериализатор использует стандартное имя и пространство имен элемента программы-оболочки и записывает ее вместе с содержимым (см. в предыдущем разделе «Задание по умолчанию корневого имени и пространства имен»).</span><span class="sxs-lookup"><span data-stu-id="3a71e-208">When using the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> method, the serializer uses the default name and namespace for the wrapper element and writes it out along with the contents (see the previous "Specifying the Default Root Name and Namespace" section).</span></span>  
  
 <span data-ttu-id="3a71e-209">Следующий пример демонстрирует запись с помощью <xref:System.Xml.XmlDictionaryWriter>.</span><span class="sxs-lookup"><span data-stu-id="3a71e-209">The following example demonstrates writing with an <xref:System.Xml.XmlDictionaryWriter>.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#8)]
 [!code-vb[c_StandaloneDataContractSerializer#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#8)]  
  
 <span data-ttu-id="3a71e-210">Это позволяет создать XML-код, подобный следующему.</span><span class="sxs-lookup"><span data-stu-id="3a71e-210">This produces XML similar to the following.</span></span>  
  
```xml  
<Person>  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</Person>  
```  
  
### <a name="step-by-step-serialization"></a><span data-ttu-id="3a71e-211">Пошаговая сериализация</span><span class="sxs-lookup"><span data-stu-id="3a71e-211">Step-By-Step Serialization</span></span>  
 <span data-ttu-id="3a71e-212">Для записи конечного элемента и содержимого объекта и закрытия программы-оболочки используйте методы <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A>и <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> соответственно.</span><span class="sxs-lookup"><span data-stu-id="3a71e-212">Use the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A>, and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> methods to write the end element, write the object contents, and close the wrapper element, respectively.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3a71e-213">Перегрузок этих методов <xref:System.IO.Stream> нет.</span><span class="sxs-lookup"><span data-stu-id="3a71e-213">There are no <xref:System.IO.Stream> overloads of these methods.</span></span>  
  
 <span data-ttu-id="3a71e-214">Описанная здесь пошаговая сериализация, как правило, используется в двух случаях.</span><span class="sxs-lookup"><span data-stu-id="3a71e-214">This step-by-step serialization has two common uses.</span></span> <span data-ttu-id="3a71e-215">Во-первых, чтобы вставлять содержимое, такое как атрибуты или комментарии, между `WriteStartObject` и `WriteObjectContent`, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="3a71e-215">One is to insert contents such as attributes or comments between `WriteStartObject` and `WriteObjectContent`,  as shown in the following example.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#9)]
 [!code-vb[c_StandaloneDataContractSerializer#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#9)]  
  
 <span data-ttu-id="3a71e-216">Это позволяет создать XML-код, подобный следующему.</span><span class="sxs-lookup"><span data-stu-id="3a71e-216">This produces XML similar to the following.</span></span>  
  
```xml  
<Person serializedBy="myCode">  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</Person>  
```  
  
 <span data-ttu-id="3a71e-217">Во-вторых, пошаговая сериализация часто применяется, чтобы полностью избежать использования <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> и <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> и создать собственную пользовательскую программу-оболочку (или пропустить создание программы-оболочки в принципе), как показано в следующем примере кода.</span><span class="sxs-lookup"><span data-stu-id="3a71e-217">Another common use is to avoid using <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> entirely, and to write your own custom wrapper element (or even skip writing a wrapper altogether), as shown in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#10)]
 [!code-vb[c_StandaloneDataContractSerializer#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#10)]  
  
 <span data-ttu-id="3a71e-218">Это позволяет создать XML-код, подобный следующему.</span><span class="sxs-lookup"><span data-stu-id="3a71e-218">This produces XML similar to the following.</span></span>  
  
```xml  
<MyCustomWrapper>  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</MyCustomWrapper>  
```  
  
> [!NOTE]
>  <span data-ttu-id="3a71e-219">Использование пошаговой сериализации может привести к созданию XML-кода с недействительной схемой.</span><span class="sxs-lookup"><span data-stu-id="3a71e-219">Using step-by-step serialization may result in schema-invalid XML.</span></span>  
  
## <a name="deserialization"></a><span data-ttu-id="3a71e-220">Десериализация</span><span class="sxs-lookup"><span data-stu-id="3a71e-220">Deserialization</span></span>  
 <span data-ttu-id="3a71e-221">Следующая информация применима к любому классу, наследуемому от сериализатора <xref:System.Runtime.Serialization.XmlObjectSerializer>, включая классы <xref:System.Runtime.Serialization.DataContractSerializer> и <xref:System.Runtime.Serialization.NetDataContractSerializer></span><span class="sxs-lookup"><span data-stu-id="3a71e-221">The following information applies to any class that inherits from the <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> classes.</span></span>  
  
 <span data-ttu-id="3a71e-222">Основным способом десериализации объекта является вызов одной из перегрузок метода <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> .</span><span class="sxs-lookup"><span data-stu-id="3a71e-222">The most basic way to deserialize an object is to call one of the <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method overloads.</span></span> <span data-ttu-id="3a71e-223">Существует три перегрузки, каждая из которых предназначена для считывания с помощью <xref:System.Xml.XmlDictionaryReader>, `XmlReader`или `Stream`соответственно.</span><span class="sxs-lookup"><span data-stu-id="3a71e-223">There are three overloads, one each for reading with a <xref:System.Xml.XmlDictionaryReader>, an `XmlReader`, or a `Stream`.</span></span> <span data-ttu-id="3a71e-224">Обратите внимание, что перегрузка `Stream` создает текстовое средство чтения <xref:System.Xml.XmlDictionaryReader> , не защищенное никакими квотами, следовательно, его нужно использовать только для чтения надежных данных.</span><span class="sxs-lookup"><span data-stu-id="3a71e-224">Note that the `Stream` overload creates a textual <xref:System.Xml.XmlDictionaryReader> that is not protected by any quotas, and should be used only to read trusted data.</span></span>  
  
 <span data-ttu-id="3a71e-225">Также обратите внимание, что объект, возвращаемый методом `ReadObject` , должен быть приведен к соответствующему типу.</span><span class="sxs-lookup"><span data-stu-id="3a71e-225">Also note that the object the `ReadObject` method returns must be cast to the appropriate type.</span></span>  
  
 <span data-ttu-id="3a71e-226">В следующем примере кода демонстрируется создание экземпляра сериализатора <xref:System.Runtime.Serialization.DataContractSerializer> и средства чтения <xref:System.Xml.XmlDictionaryReader>, а также последующая десериализация экземпляра `Person` .</span><span class="sxs-lookup"><span data-stu-id="3a71e-226">The following code constructs an instance of the <xref:System.Runtime.Serialization.DataContractSerializer> and an <xref:System.Xml.XmlDictionaryReader>, then deserializes a `Person` instance.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#11)]
 [!code-vb[c_StandaloneDataContractSerializer#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#11)]  
  
 <span data-ttu-id="3a71e-227">Прежде чем вызывать метод <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> , необходимо разместить средство чтения XML в программе-оболочке или не имеющем содержимого узле, который предшествует программе-оболочке.</span><span class="sxs-lookup"><span data-stu-id="3a71e-227">Before calling the <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method, position the XML reader on the wrapper element or on a non-content node that precedes the wrapper element.</span></span> <span data-ttu-id="3a71e-228">Это можно осуществить вызовом метода <xref:System.Xml.XmlReader.Read%2A> устройства чтения <xref:System.Xml.XmlReader> или производного метода и тестированием типа <xref:System.Xml.XmlReader.NodeType%2A>, как показано в следующем примере кода.</span><span class="sxs-lookup"><span data-stu-id="3a71e-228">You can do this by calling the <xref:System.Xml.XmlReader.Read%2A> method of the <xref:System.Xml.XmlReader> or its derivation, and testing the <xref:System.Xml.XmlReader.NodeType%2A>, as shown in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#12](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#12)]
 [!code-vb[c_StandaloneDataContractSerializer#12](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#12)]  
  
 <span data-ttu-id="3a71e-229">Обратите внимание, что до передачи устройства чтения методу `ReadObject`в этой программе-оболочке можно прочитать атрибуты.</span><span class="sxs-lookup"><span data-stu-id="3a71e-229">Note that you can read attributes on this wrapper element before handing the reader to `ReadObject`.</span></span>  
  
 <span data-ttu-id="3a71e-230">При использовании одной из простых `ReadObject` перегрузки, десериализатор ищет стандартное имя и пространство имен элемента программы-оболочки (см. предшествующий раздел «Задание по умолчанию корневого имени и пространства имен») и создает исключение, если он обнаруживает Неизвестный элемент.</span><span class="sxs-lookup"><span data-stu-id="3a71e-230">When using one of the simple `ReadObject` overloads, the deserializer looks for the default name and namespace on the wrapper element (see the preceding section, "Specifying the Default Root Name and Namespace") and throws an exception if it finds an unknown element.</span></span> <span data-ttu-id="3a71e-231">Предполагается, что в предыдущем примере используется программа-оболочка `<Person>` .</span><span class="sxs-lookup"><span data-stu-id="3a71e-231">In the preceding example, the `<Person>` wrapper element is expected.</span></span> <span data-ttu-id="3a71e-232">Метод <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> вызывается, чтобы убедиться, что средство чтения размещено в элементе, именованном как ожидается.</span><span class="sxs-lookup"><span data-stu-id="3a71e-232">The <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> method is called to verify that the reader is positioned on an element that is named as expected.</span></span>  
  
 <span data-ttu-id="3a71e-233">Можно отключить такую проверку имени программы-оболочки; некоторые перегрузки метода `ReadObject` используют логический параметр `verifyObjectName`, которому по умолчанию задано значение `true` .</span><span class="sxs-lookup"><span data-stu-id="3a71e-233">There is a way to disable this wrapper element name check; some overloads of the `ReadObject` method take the Boolean parameter `verifyObjectName`, which is set to `true` by default.</span></span> <span data-ttu-id="3a71e-234">Если параметру задано значение `false`, имя и пространство имен программы-оболочки игнорируются.</span><span class="sxs-lookup"><span data-stu-id="3a71e-234">When set to `false`, the name and namespace of the wrapper element is ignored.</span></span> <span data-ttu-id="3a71e-235">Эта функция полезна при чтении XML-кода, который был создан с использованием механизма пошаговой сериализации, описанной ранее.</span><span class="sxs-lookup"><span data-stu-id="3a71e-235">This is useful for reading XML that was written using the step-by-step serialization mechanism described previously.</span></span>  
  
## <a name="using-the-netdatacontractserializer"></a><span data-ttu-id="3a71e-236">Использование NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="3a71e-236">Using the NetDataContractSerializer</span></span>  
 <span data-ttu-id="3a71e-237">Основное различие между сериализаторами `DataContractSerializer` и <xref:System.Runtime.Serialization.NetDataContractSerializer> заключается в том, что `DataContractSerializer` использует имена контракта данных, а `NetDataContractSerializer` выводит полную сборку [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] и имена типов в сериализованном XML-коде.</span><span class="sxs-lookup"><span data-stu-id="3a71e-237">The primary difference between the `DataContractSerializer` and the <xref:System.Runtime.Serialization.NetDataContractSerializer> is that the `DataContractSerializer` uses data contract names, whereas the `NetDataContractSerializer` outputs full [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] assembly and type names in the serialized XML.</span></span> <span data-ttu-id="3a71e-238">Это означает, что одни и те же типы должны совместно использоваться конечными точками сериализации и десериализации.</span><span class="sxs-lookup"><span data-stu-id="3a71e-238">This means that the exact same types must be shared between the serialization and deserialization endpoints.</span></span> <span data-ttu-id="3a71e-239">Так как при использовании сериализатора `NetDataContractSerializer` всегда известны точные типы, которые должны быть десериализованы, механизм известных типов не требуется.</span><span class="sxs-lookup"><span data-stu-id="3a71e-239">This means that the known types mechanism is not required with the `NetDataContractSerializer` because the exact types to be deserialized are always known.</span></span>  
  
 <span data-ttu-id="3a71e-240">Однако в связи с этим могут возникнуть некоторые проблемы:</span><span class="sxs-lookup"><span data-stu-id="3a71e-240">However, several problems can occur:</span></span>  
  
-   <span data-ttu-id="3a71e-241">Безопасность.</span><span class="sxs-lookup"><span data-stu-id="3a71e-241">Security.</span></span> <span data-ttu-id="3a71e-242">Загружается любой тип, обнаруживаемый в десериализуемом XML-коде.</span><span class="sxs-lookup"><span data-stu-id="3a71e-242">Any type found in the XML being deserialized is loaded.</span></span> <span data-ttu-id="3a71e-243">Этим можно воспользоваться для принудительной загрузки вредоносных типов.</span><span class="sxs-lookup"><span data-stu-id="3a71e-243">This can be exploited to force the loading of malicious types.</span></span> <span data-ttu-id="3a71e-244">Использование сериализатора `NetDataContractSerializer` с ненадежными данными возможно только при условии применения *связывателя сериализации* (с использованием свойства <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> или параметра конструктора).</span><span class="sxs-lookup"><span data-stu-id="3a71e-244">Using the `NetDataContractSerializer` with untrusted data should be done only if a *Serialization Binder* is used (using the <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> property or constructor parameter).</span></span> <span data-ttu-id="3a71e-245">Связыватель позволяет загружать только надежные типы.</span><span class="sxs-lookup"><span data-stu-id="3a71e-245">The binder permits only safe types to be loaded.</span></span> <span data-ttu-id="3a71e-246">Механизм связывателя аналогичен используемому типами в пространстве имен <xref:System.Runtime.Serialization> .</span><span class="sxs-lookup"><span data-stu-id="3a71e-246">The Binder mechanism is identical to the one that types in the <xref:System.Runtime.Serialization> namespace use.</span></span>  
  
-   <span data-ttu-id="3a71e-247">Управление версиями.</span><span class="sxs-lookup"><span data-stu-id="3a71e-247">Versioning.</span></span> <span data-ttu-id="3a71e-248">Использование полных имен типов и сборок в XML-коде строго ограничивает возможности управления версиями типов.</span><span class="sxs-lookup"><span data-stu-id="3a71e-248">Using full type and assembly names in the XML severely restricts how types can be versioned.</span></span> <span data-ttu-id="3a71e-249">При этом невозможно изменить имена типов, пространства имен, имена и версии сборок.</span><span class="sxs-lookup"><span data-stu-id="3a71e-249">The following cannot be changed: type names, namespaces, assembly names, and assembly versions.</span></span> <span data-ttu-id="3a71e-250">Задание свойству <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> или параметру конструктора значения <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> вместо значения по умолчанию <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Full> позволяет изменить версию сборки, но не универсальные типы параметров.</span><span class="sxs-lookup"><span data-stu-id="3a71e-250">Setting the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property or constructor parameter to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> instead of the default value of <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Full> allows for assembly version changes, but not for generic parameter types.</span></span>  
  
-   <span data-ttu-id="3a71e-251">Взаимодействие.</span><span class="sxs-lookup"><span data-stu-id="3a71e-251">Interoperability.</span></span> <span data-ttu-id="3a71e-252">Так как имена типов и сборок [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] включены в XML-код, никакие другие платформы, кроме [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] , не могут получить доступ к получаемым данным.</span><span class="sxs-lookup"><span data-stu-id="3a71e-252">Because [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] type and assembly names are included in the XML, platforms other than the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] cannot access the resulting data.</span></span>  
  
-   <span data-ttu-id="3a71e-253">Производительность.</span><span class="sxs-lookup"><span data-stu-id="3a71e-253">Performance.</span></span> <span data-ttu-id="3a71e-254">Запись имен типов и сборок значительно увеличивает размер получаемого XML-кода.</span><span class="sxs-lookup"><span data-stu-id="3a71e-254">Writing out the type and assembly names significantly increases the size of the resulting XML.</span></span>  
  
 <span data-ttu-id="3a71e-255">Этот механизм аналогичен двоичной сериализации или сериализации SOAP, используемой удаленным взаимодействием [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] (а именно, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> и <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>).</span><span class="sxs-lookup"><span data-stu-id="3a71e-255">This mechanism is similar to binary or SOAP serialization used by [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] remoting (specifically, the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>).</span></span>  
  
 <span data-ttu-id="3a71e-256">Сериализаторы `NetDataContractSerializer` и `DataContractSerializer`используются практически аналогично со следующими отличиями.</span><span class="sxs-lookup"><span data-stu-id="3a71e-256">Using the `NetDataContractSerializer` is similar to using the `DataContractSerializer`, with the following differences:</span></span>  
  
-   <span data-ttu-id="3a71e-257">Конструкторы не требуют указания корневого типа.</span><span class="sxs-lookup"><span data-stu-id="3a71e-257">The constructors do not require you to specify a root type.</span></span> <span data-ttu-id="3a71e-258">Любой тип можно сериализовать с помощью одного и того же экземпляра сериализатора `NetDataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="3a71e-258">You can serialize any type with the same instance of the `NetDataContractSerializer`.</span></span>  
  
-   <span data-ttu-id="3a71e-259">Конструкторы не принимают список известных типов.</span><span class="sxs-lookup"><span data-stu-id="3a71e-259">The constructors do not accept a list of known types.</span></span> <span data-ttu-id="3a71e-260">Если имена типов сериализуются в XML-код, механизм известных типов не требуется.</span><span class="sxs-lookup"><span data-stu-id="3a71e-260">The known types mechanism is unnecessary if type names are serialized into the XML.</span></span>  
  
-   <span data-ttu-id="3a71e-261">Конструкторы не принимают суррогаты контракта данных.</span><span class="sxs-lookup"><span data-stu-id="3a71e-261">The constructors do not accept a data contract surrogate.</span></span> <span data-ttu-id="3a71e-262">Вместо этого они принимают параметр <xref:System.Runtime.Serialization.ISurrogateSelector> , называемый `surrogateSelector` (который сопоставляется со свойством <xref:System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector%2A> ).</span><span class="sxs-lookup"><span data-stu-id="3a71e-262">Instead, they accept an <xref:System.Runtime.Serialization.ISurrogateSelector> parameter called `surrogateSelector` (which maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector%2A> property).</span></span> <span data-ttu-id="3a71e-263">Это устаревший суррогатный механизм.</span><span class="sxs-lookup"><span data-stu-id="3a71e-263">This is a legacy surrogate mechanism.</span></span>  
  
-   <span data-ttu-id="3a71e-264">Конструкторы принимают параметр стиля `assemblyFormat` , называемый <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> , который сопоставляется со свойством <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> .</span><span class="sxs-lookup"><span data-stu-id="3a71e-264">The constructors accept a parameter called `assemblyFormat` of the <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> that maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property.</span></span> <span data-ttu-id="3a71e-265">Как уже отмечалось ранее, эту особенность можно использовать для расширения возможностей сериализатора по управлению версиями.</span><span class="sxs-lookup"><span data-stu-id="3a71e-265">As discussed previously, this can be used to enhance the versioning capabilities of the serializer.</span></span> <span data-ttu-id="3a71e-266">Этот подход аналогичен механизму <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> в двоичной сериализации или сериализации SOAP.</span><span class="sxs-lookup"><span data-stu-id="3a71e-266">This is identical to the <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> mechanism in binary or SOAP serialization.</span></span>  
  
-   <span data-ttu-id="3a71e-267">Конструкторы принимают параметр <xref:System.Runtime.Serialization.StreamingContext> , называемый `context` , который сопоставляется со свойством <xref:System.Runtime.Serialization.NetDataContractSerializer.Context%2A> .</span><span class="sxs-lookup"><span data-stu-id="3a71e-267">The constructors accept a <xref:System.Runtime.Serialization.StreamingContext> parameter called `context` that maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.Context%2A> property.</span></span> <span data-ttu-id="3a71e-268">Эту особенность можно использовать для передачи информации в сериализуемые типы.</span><span class="sxs-lookup"><span data-stu-id="3a71e-268">You can use this to pass information into types being serialized.</span></span> <span data-ttu-id="3a71e-269">Данный подход аналогичен использованию механизма <xref:System.Runtime.Serialization.StreamingContext> в других классах <xref:System.Runtime.Serialization> .</span><span class="sxs-lookup"><span data-stu-id="3a71e-269">This usage is identical to that of the <xref:System.Runtime.Serialization.StreamingContext> mechanism used in other <xref:System.Runtime.Serialization> classes.</span></span>  
  
-   <span data-ttu-id="3a71e-270">Методы <xref:System.Runtime.Serialization.NetDataContractSerializer.Serialize%2A> и <xref:System.Runtime.Serialization.NetDataContractSerializer.Deserialize%2A> представляют собой псевдонимы для методов <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> и <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> .</span><span class="sxs-lookup"><span data-stu-id="3a71e-270">The <xref:System.Runtime.Serialization.NetDataContractSerializer.Serialize%2A> and <xref:System.Runtime.Serialization.NetDataContractSerializer.Deserialize%2A> methods are aliases for the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> methods.</span></span> <span data-ttu-id="3a71e-271">Они предоставляют более последовательную модель программирования с двоичной сериализацией или сериализацией SOAP.</span><span class="sxs-lookup"><span data-stu-id="3a71e-271">These exist to provide a more consistent programming model with binary or SOAP serialization.</span></span>  
  
 <span data-ttu-id="3a71e-272">Дополнительные сведения об этих функциях см. в разделе [двоичной сериализации](../../../../docs/standard/serialization/binary-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="3a71e-272">For more information about these features, see [Binary Serialization](../../../../docs/standard/serialization/binary-serialization.md).</span></span>  
  
 <span data-ttu-id="3a71e-273">Форматы XML, используемые сериализаторами `NetDataContractSerializer` и `DataContractSerializer` , как правило, не совместимы.</span><span class="sxs-lookup"><span data-stu-id="3a71e-273">The XML formats that the `NetDataContractSerializer` and the `DataContractSerializer` use are normally not compatible.</span></span> <span data-ttu-id="3a71e-274">Следовательно, возможность сериализации с помощью одного из них и десериализации с помощью другого не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="3a71e-274">That is, attempting to serialize with one of these serializers and deserialize with the other is not a supported scenario.</span></span>  
  
 <span data-ttu-id="3a71e-275">Обратите также внимание, что сериализатор `NetDataContractSerializer` не выдает полное имя типа и сборки [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] для каждого узла в графе объекта.</span><span class="sxs-lookup"><span data-stu-id="3a71e-275">Also, note that the `NetDataContractSerializer` does not output the full [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] type and assembly name for each node in the object graph.</span></span> <span data-ttu-id="3a71e-276">Он выводит эту информацию, только если она неоднозначна.</span><span class="sxs-lookup"><span data-stu-id="3a71e-276">It outputs that information only where it is ambiguous.</span></span> <span data-ttu-id="3a71e-277">Таким образом, вывод данных осуществляется на уровне корневого объекта и для любых полиморфных случаев.</span><span class="sxs-lookup"><span data-stu-id="3a71e-277">That is, it outputs at the root object level and for any polymorphic cases.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3a71e-278">См. также</span><span class="sxs-lookup"><span data-stu-id="3a71e-278">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Runtime.Serialization.NetDataContractSerializer>
- <xref:System.Runtime.Serialization.XmlObjectSerializer>
- [<span data-ttu-id="3a71e-279">Двоичная сериализация</span><span class="sxs-lookup"><span data-stu-id="3a71e-279">Binary Serialization</span></span>](../../../../docs/standard/serialization/binary-serialization.md)
- [<span data-ttu-id="3a71e-280">Типы, поддерживаемые сериализатором контракта данных</span><span class="sxs-lookup"><span data-stu-id="3a71e-280">Types Supported by the Data Contract Serializer</span></span>](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)
