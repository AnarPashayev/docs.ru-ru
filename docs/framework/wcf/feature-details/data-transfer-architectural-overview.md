---
title: Общие сведения об архитектуре передачи данных
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- data transfer [WCF], architectural overview
ms.assetid: 343c2ca2-af53-4936-a28c-c186b3524ee9
ms.openlocfilehash: 6b6e77dea17d71b74c2c06534fd3a941e3e867a8
ms.sourcegitcommit: c7a7e1468bf0fa7f7065de951d60dfc8d5ba89f5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/14/2019
ms.locfileid: "65592551"
---
# <a name="data-transfer-architectural-overview"></a><span data-ttu-id="50410-102">Общие сведения об архитектуре передачи данных</span><span class="sxs-lookup"><span data-stu-id="50410-102">Data Transfer Architectural Overview</span></span>
<span data-ttu-id="50410-103">Windows Communication Foundation (WCF) может рассматриваться как инфраструктуру обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="50410-103">Windows Communication Foundation (WCF) can be thought of as a messaging infrastructure.</span></span> <span data-ttu-id="50410-104">где происходит получение, обработка и направление сообщений в пользовательский код для дальнейших действий или создание сообщений из данных, предоставленных пользовательским кодом, и доставка этих сообщений по назначению.</span><span class="sxs-lookup"><span data-stu-id="50410-104">It can receive messages, process them, and dispatch them to user code for further action, or it can construct messages from data given by user code and deliver them to a destination.</span></span> <span data-ttu-id="50410-105">В данном разделе, предназначенном для опытных программистов, описывается архитектура для обработки сообщений и данных, которые в них содержатся.</span><span class="sxs-lookup"><span data-stu-id="50410-105">This topic, which is intended for advanced developers, describes the architecture for handling messages and the contained data.</span></span> <span data-ttu-id="50410-106">Упрощенное изложение практических аспектов отправки и получения данных приводится в разделе [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="50410-106">For a simpler, task-oriented view of how to send and receive data, see [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="50410-107">В этом разделе рассматриваются сведения о реализации WCF, которые не отображаются с помощью проверки объектной модели WCF.</span><span class="sxs-lookup"><span data-stu-id="50410-107">This topic discusses WCF implementation details that are not visible by examining the WCF object model.</span></span> <span data-ttu-id="50410-108">Прежде чем приступать к описанию задокументированной реализации компонента, необходимо принять во внимание два замечания.</span><span class="sxs-lookup"><span data-stu-id="50410-108">Two words of caution are in order with regard to documented implementation details.</span></span> <span data-ttu-id="50410-109">Во-первых, все представленные описания упрощены, на практике реализация может быть более сложной из-за оптимизаций или по другим причинам.</span><span class="sxs-lookup"><span data-stu-id="50410-109">First, the descriptions are simplified; actual implementation may be more complex due to optimizations or other reasons.</span></span> <span data-ttu-id="50410-110">Во-вторых, никогда не стоит полагаться на определенные сведения о реализации (даже задокументированные), так как они могут изменяться без уведомления от версии к версии или даже в отдельных наборах исправлений.</span><span class="sxs-lookup"><span data-stu-id="50410-110">Second, you should never rely on specific implementation details, even documented ones, because these may change without notice from version to version or even in a servicing release.</span></span>  
  
## <a name="basic-architecture"></a><span data-ttu-id="50410-111">Базовая архитектура</span><span class="sxs-lookup"><span data-stu-id="50410-111">Basic Architecture</span></span>  
 <span data-ttu-id="50410-112">В основе возможности обработки сообщений WCF лежит <xref:System.ServiceModel.Channels.Message> класс, который подробно описана [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="50410-112">At the core of WCF message-handling capabilities is the <xref:System.ServiceModel.Channels.Message> class, which is described in detail in [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).</span></span> <span data-ttu-id="50410-113">Компоненты среды выполнения WCF можно разделить на две основные части: стек каналов и инфраструктура служб, с помощью <xref:System.ServiceModel.Channels.Message> класс точки подключения.</span><span class="sxs-lookup"><span data-stu-id="50410-113">The run-time components of WCF can be divided into two major parts: the channel stack and the service framework, with the <xref:System.ServiceModel.Channels.Message> class being the connection point.</span></span>  
  
 <span data-ttu-id="50410-114">Стек каналов отвечает за преобразование между допустимым экземпляром <xref:System.ServiceModel.Channels.Message> и определенным действием, соответствующим отправке или получению данных сообщения.</span><span class="sxs-lookup"><span data-stu-id="50410-114">The channel stack is responsible for converting between a valid <xref:System.ServiceModel.Channels.Message> instance and some action that corresponds to the sending or receiving of message data.</span></span> <span data-ttu-id="50410-115">На отправляющей стороне стек каналов берет допустимый экземпляр <xref:System.ServiceModel.Channels.Message> и после определенной обработки совершает некое действие, логически соответствующее отправке сообщения.</span><span class="sxs-lookup"><span data-stu-id="50410-115">On the sending side, the channel stack takes a valid <xref:System.ServiceModel.Channels.Message> instance and, after some processing, performs some action that logically corresponds to sending the message.</span></span> <span data-ttu-id="50410-116">Это действие может заключаться в отправке TCP- или HTTP-пакетов, постановке сообщения в очередь сообщений, записи сообщения в базу данных, сохранении его в общей папке или любой другой операции в зависимости от реализации.</span><span class="sxs-lookup"><span data-stu-id="50410-116">The action may be sending TCP or HTTP packets, queuing the message in Message Queuing, writing the message to a database, saving it to a file share, or any other action, depending on the implementation.</span></span> <span data-ttu-id="50410-117">Наиболее распространенным действием является отправка сообщения по сетевому протоколу.</span><span class="sxs-lookup"><span data-stu-id="50410-117">The most common action is sending the message over a network protocol.</span></span> <span data-ttu-id="50410-118">На получающей стороне происходят противоположные процессы: стек каналов обнаруживает действие (например, прибытие TCP- или HTTP-пакетов или любое другое действие), обрабатывает его и преобразует в допустимый экземпляр <xref:System.ServiceModel.Channels.Message> .</span><span class="sxs-lookup"><span data-stu-id="50410-118">On the receive side, the opposite happens—an action is detected (which may be TCP or HTTP packets arriving or any other action), and, after processing, the channel stack converts this action into a valid <xref:System.ServiceModel.Channels.Message> instance.</span></span>  
  
 <span data-ttu-id="50410-119">С помощью WCF с помощью <xref:System.ServiceModel.Channels.Message> класс и канал стека напрямую.</span><span class="sxs-lookup"><span data-stu-id="50410-119">You can use WCF by using the <xref:System.ServiceModel.Channels.Message> class and the channel stack directly.</span></span> <span data-ttu-id="50410-120">Однако такой подход сложен и может занимать много времени.</span><span class="sxs-lookup"><span data-stu-id="50410-120">However, doing so is difficult and time-consuming.</span></span> <span data-ttu-id="50410-121">Кроме того <xref:System.ServiceModel.Channels.Message> объект не поддерживает метаданные, поэтому если вы используете WCF таким образом, не удается создать строго типизированные клиенты WCF.</span><span class="sxs-lookup"><span data-stu-id="50410-121">Additionally, the <xref:System.ServiceModel.Channels.Message> object provides no metadata support, so you cannot generate strongly typed WCF clients if you use WCF in this manner.</span></span>  
  
 <span data-ttu-id="50410-122">Таким образом, WCF включает инфраструктуру службы, предоставляет простой в использовании модель программирования, можно использовать для создания и получения `Message` объектов.</span><span class="sxs-lookup"><span data-stu-id="50410-122">Therefore, WCF includes a service framework that provides an easy-to-use programming model that you can use to construct and receive `Message` objects.</span></span> <span data-ttu-id="50410-123">Инфраструктура службы сопоставляет службы с типами .NET Framework через понятие контрактов служб и направляет сообщения в операции пользователей, которые являются просто .NET Framework, методы, помеченные как <xref:System.ServiceModel.OperationContractAttribute> атрибут (Дополнительные сведения см. в разделе [ Разработке контрактов службы](../../../../docs/framework/wcf/designing-service-contracts.md)).</span><span class="sxs-lookup"><span data-stu-id="50410-123">The service framework maps services to .NET Framework types through the notion of service contracts, and dispatches messages to user operations that are simply .NET Framework methods marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute (for more details, see [Designing Service Contracts](../../../../docs/framework/wcf/designing-service-contracts.md)).</span></span> <span data-ttu-id="50410-124">Эти методы могут содержать параметры и возвращать значения.</span><span class="sxs-lookup"><span data-stu-id="50410-124">These methods may have parameters and return values.</span></span> <span data-ttu-id="50410-125">На стороне службы инфраструктура службы преобразует входящие экземпляры <xref:System.ServiceModel.Channels.Message> в параметры, а возвращаемые значения - в исходящие экземпляры <xref:System.ServiceModel.Channels.Message> .</span><span class="sxs-lookup"><span data-stu-id="50410-125">On the service side, the service framework converts incoming <xref:System.ServiceModel.Channels.Message> instances into parameters and converts return values into outgoing <xref:System.ServiceModel.Channels.Message> instances.</span></span> <span data-ttu-id="50410-126">На стороне клиента инфраструктура службы выполняет противоположные действия.</span><span class="sxs-lookup"><span data-stu-id="50410-126">On the client side, it does the opposite.</span></span> <span data-ttu-id="50410-127">Например, см. операцию `FindAirfare` ниже.</span><span class="sxs-lookup"><span data-stu-id="50410-127">For example, consider the `FindAirfare` operation below.</span></span>  
  
 [!code-csharp[c_DataArchitecture#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#1)]
 [!code-vb[c_DataArchitecture#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#1)]  
  
 <span data-ttu-id="50410-128">Предположим, операция `FindAirfare` вызывается на стороне клиента.</span><span class="sxs-lookup"><span data-stu-id="50410-128">Suppose `FindAirfare` is called on the client.</span></span> <span data-ttu-id="50410-129">Инфраструктура службы на стороне клиента преобразует параметры `FromCity` и `ToCity` в исходящий экземпляр <xref:System.ServiceModel.Channels.Message> и передает его стеку каналов для отправки.</span><span class="sxs-lookup"><span data-stu-id="50410-129">The service framework on the client converts the `FromCity` and `ToCity` parameters into an outgoing <xref:System.ServiceModel.Channels.Message> instance and passes it to the channel stack to be sent.</span></span>  
  
 <span data-ttu-id="50410-130">Когда экземпляр <xref:System.ServiceModel.Channels.Message> прибывает из стека каналов, на стороне службы инфраструктура службы извлекает из сообщения необходимые для заполнения параметров `FromCity` и `ToCity` данные, а затем вызывает метод `FindAirfare` на стороне службы.</span><span class="sxs-lookup"><span data-stu-id="50410-130">On the service side, when a <xref:System.ServiceModel.Channels.Message> instance arrives from the channel stack, the service framework extracts the relevant data from the message to populate the `FromCity` and `ToCity` parameters and then calls the service-side `FindAirfare` method.</span></span> <span data-ttu-id="50410-131">Когда метод возвращается, инфраструктура службы создает из возвращенного целочисленного значения и выходного параметра `IsDirectFlight` экземпляр объекта <xref:System.ServiceModel.Channels.Message> , содержащий данную информацию.</span><span class="sxs-lookup"><span data-stu-id="50410-131">When the method returns, the service framework takes the returned integer value and the `IsDirectFlight` output parameter and creates a <xref:System.ServiceModel.Channels.Message> object instance that contains this information.</span></span> <span data-ttu-id="50410-132">Затем инфраструктура службы передает экземпляр `Message` стеку каналов для отправки обратно клиенту.</span><span class="sxs-lookup"><span data-stu-id="50410-132">It then passes the `Message` instance to the channel stack to be sent back to the client.</span></span>  
  
 <span data-ttu-id="50410-133">На стороне клиента из стека каналов появляется экземпляр <xref:System.ServiceModel.Channels.Message> , содержащий ответное сообщение.</span><span class="sxs-lookup"><span data-stu-id="50410-133">On the client side, a <xref:System.ServiceModel.Channels.Message> instance that contains the response message emerges from the channel stack.</span></span> <span data-ttu-id="50410-134">Инфраструктура службы извлекает возвращаемое значение и значение `IsDirectFlight` и возвращает их вызывающему объекту на стороне клиента.</span><span class="sxs-lookup"><span data-stu-id="50410-134">The service framework extracts the return value and the `IsDirectFlight` value and returns these to the caller of the client.</span></span>  
  
## <a name="message-class"></a><span data-ttu-id="50410-135">Класс сообщений</span><span class="sxs-lookup"><span data-stu-id="50410-135">Message Class</span></span>  
 <span data-ttu-id="50410-136">Подразумевается, что класс <xref:System.ServiceModel.Channels.Message> является абстрактным представлением сообщения, однако его структура строго связана с сообщением SOAP.</span><span class="sxs-lookup"><span data-stu-id="50410-136">The <xref:System.ServiceModel.Channels.Message> class is intended to be an abstract representation of a message, but its design is strongly tied to the SOAP message.</span></span> <span data-ttu-id="50410-137">Сообщение <xref:System.ServiceModel.Channels.Message> содержит три основных элемента информации: текст сообщения, заголовки сообщения и свойства сообщения.</span><span class="sxs-lookup"><span data-stu-id="50410-137">A <xref:System.ServiceModel.Channels.Message> contains three major pieces of information: a message body, message headers, and message properties.</span></span>  
  
## <a name="message-body"></a><span data-ttu-id="50410-138">Текст сообщения</span><span class="sxs-lookup"><span data-stu-id="50410-138">Message Body</span></span>  
 <span data-ttu-id="50410-139">В теле сообщения представляется фактическая полезная нагрузка данных сообщения.</span><span class="sxs-lookup"><span data-stu-id="50410-139">The message body is intended to represent the actual data payload of the message.</span></span> <span data-ttu-id="50410-140">Текст сообщения всегда представляется как набор сведений XML.</span><span class="sxs-lookup"><span data-stu-id="50410-140">The message body is always represented as an XML Infoset.</span></span> <span data-ttu-id="50410-141">Это означает, что все сообщения, создаваемые или получаемые в WCF должно быть в формате XML.</span><span class="sxs-lookup"><span data-stu-id="50410-141">This does not mean that all messages created or received in WCF must be in XML format.</span></span> <span data-ttu-id="50410-142">Стек каналов определяет, как интерпретировать текст сообщения.</span><span class="sxs-lookup"><span data-stu-id="50410-142">It is up to the channel stack to decide how to interpret the message body.</span></span> <span data-ttu-id="50410-143">Он может отобразить текст сообщения в формате XML, преобразовать в другой формат или даже опустить его.</span><span class="sxs-lookup"><span data-stu-id="50410-143">It may emit it as XML, convert it to some other format, or even omit it entirely.</span></span> <span data-ttu-id="50410-144">Конечно с большинством из источников привязки WCF, текст сообщения представляется как XML-содержимое в основном разделе конверта SOAP.</span><span class="sxs-lookup"><span data-stu-id="50410-144">Of course, with most of the bindings WCF supplies, the message body is represented as XML content in the body section of a SOAP envelope.</span></span>  
  
 <span data-ttu-id="50410-145">Следует помнить, что в классе `Message` не обязательно содержится буфер с представляющими текст данными в формате XML.</span><span class="sxs-lookup"><span data-stu-id="50410-145">It is important to realize that the `Message` class does not necessarily contain a buffer with XML data representing the body.</span></span> <span data-ttu-id="50410-146">Логически сообщение `Message` содержит набор сведений XML, однако этот набор данных может создаваться динамически и никогда физически не существовать в памяти.</span><span class="sxs-lookup"><span data-stu-id="50410-146">Logically, `Message` contains an XML Infoset, but this Infoset may be dynamically constructed and may never physically exist in memory.</span></span>  
  
### <a name="putting-data-into-the-message-body"></a><span data-ttu-id="50410-147">Размещение данных в теле сообщения</span><span class="sxs-lookup"><span data-stu-id="50410-147">Putting Data into the Message Body</span></span>  
 <span data-ttu-id="50410-148">Не существует универсального механизма размещения данных в теле сообщения.</span><span class="sxs-lookup"><span data-stu-id="50410-148">There is no uniform mechanism to put data into a message body.</span></span> <span data-ttu-id="50410-149">Класс <xref:System.ServiceModel.Channels.Message> имеет абстрактный метод ( <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>), который принимает <xref:System.Xml.XmlDictionaryWriter>.</span><span class="sxs-lookup"><span data-stu-id="50410-149">The <xref:System.ServiceModel.Channels.Message> class has an abstract method, <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, which takes an <xref:System.Xml.XmlDictionaryWriter>.</span></span> <span data-ttu-id="50410-150">Каждый подкласс класса <xref:System.ServiceModel.Channels.Message> отвечает за переопределение этого метода и запись собственного содержимого.</span><span class="sxs-lookup"><span data-stu-id="50410-150">Each subclass of the <xref:System.ServiceModel.Channels.Message> class is responsible for overriding this method and writing out its own contents.</span></span> <span data-ttu-id="50410-151">Текст сообщения логически содержит набор сведений XML, создаваемый `OnWriteBodyContent` .</span><span class="sxs-lookup"><span data-stu-id="50410-151">The message body logically contains the XML Infoset that `OnWriteBodyContent` produces.</span></span> <span data-ttu-id="50410-152">Например, рассмотрим следующий подкласс `Message` .</span><span class="sxs-lookup"><span data-stu-id="50410-152">For example, consider the following `Message` subclass.</span></span>  
  
 [!code-csharp[c_DataArchitecture#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#2)]
 [!code-vb[c_DataArchitecture#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#2)]  
  
 <span data-ttu-id="50410-153">Физически экземпляр `AirfareRequestMessage` содержит только две строки ("fromCity" и "toCity").</span><span class="sxs-lookup"><span data-stu-id="50410-153">Physically, an `AirfareRequestMessage` instance contains only two strings ("fromCity" and "toCity").</span></span> <span data-ttu-id="50410-154">Однако логически сообщение содержит следующий набор сведений XML:</span><span class="sxs-lookup"><span data-stu-id="50410-154">However, logically the message contains the following XML infoset:</span></span>  
  
```xml  
<airfareRequest>  
    <from>Tokyo</from>  
    <to>London</to>  
</airfareRequest>  
```  
  
 <span data-ttu-id="50410-155">Конечно, обычно сообщения не создаются таким образом, потому что сообщения, подобные предыдущему, создаются с помощью инфраструктуры службы из параметров контракта операций подобно предыдущему.</span><span class="sxs-lookup"><span data-stu-id="50410-155">Of course, you would normally not create messages in this manner, because you can use the service framework to create a message like the preceding one from operation contract parameters.</span></span> <span data-ttu-id="50410-156">Более того, класс <xref:System.ServiceModel.Channels.Message> содержит статические методы `CreateMessage` , которые могут использоваться для создания сообщений с содержимым стандартных типов: пустое сообщение, сообщение, которое содержит сериализованный в XML с <xref:System.Runtime.Serialization.DataContractSerializer>объект, сообщение, которое содержит ошибку SOAP, сообщение, которое содержит XML, представленный <xref:System.Xml.XmlReader>, и т. д.</span><span class="sxs-lookup"><span data-stu-id="50410-156">Additionally, the <xref:System.ServiceModel.Channels.Message> class has static `CreateMessage` methods that you can use to create messages with common types of content: an empty message, a message that contains an object serialized to XML with the <xref:System.Runtime.Serialization.DataContractSerializer>, a message that contains a SOAP fault, a message that contains XML represented by an <xref:System.Xml.XmlReader>, and so on.</span></span>  
  
### <a name="getting-data-from-a-message-body"></a><span data-ttu-id="50410-157">Получение данных из тела сообщения</span><span class="sxs-lookup"><span data-stu-id="50410-157">Getting Data from a Message Body</span></span>  
 <span data-ttu-id="50410-158">Данные, которые хранятся в теле сообщения, можно извлекать двумя основными способами:</span><span class="sxs-lookup"><span data-stu-id="50410-158">You can extract the data stored in a message body in two main ways:</span></span>  
  
- <span data-ttu-id="50410-159">Вы можете получить весь текст сообщения одновременно, вызвав метод <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> и передавая в средство записи XML.</span><span class="sxs-lookup"><span data-stu-id="50410-159">You can get the entire message body at one time by calling the <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> method and passing in an XML writer.</span></span> <span data-ttu-id="50410-160">Весь текст сообщения записывается в это средство записи.</span><span class="sxs-lookup"><span data-stu-id="50410-160">The complete message body is written out to this writer.</span></span> <span data-ttu-id="50410-161">Получение всего тела сообщения одновременно также называется *запись сообщения*.</span><span class="sxs-lookup"><span data-stu-id="50410-161">Getting the entire message body at one time is also called *writing a message*.</span></span> <span data-ttu-id="50410-162">Запись осуществляется в основном стеком каналов при отправке сообщений - как правило, какая-либо часть стека каналов получает доступ к всему телу сообщения, кодирует и отправляет его.</span><span class="sxs-lookup"><span data-stu-id="50410-162">Writing is done primarily by the channel stack when sending messages—some part of the channel stack will usually get access to the entire message body, encode it, and send it.</span></span>  
  
- <span data-ttu-id="50410-163">Еще одним способом извлечения информации из тела сообщения является вызов <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> и получение средства чтения XML.</span><span class="sxs-lookup"><span data-stu-id="50410-163">Another way to get information out of the message body is to call <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> and get an XML reader.</span></span> <span data-ttu-id="50410-164">В этом случае доступ к телу сообщения может осуществляться последовательно по мере необходимости посредством вызова методов для средства чтения.</span><span class="sxs-lookup"><span data-stu-id="50410-164">The message body can then be accessed sequentially as needed by calling methods on the reader.</span></span> <span data-ttu-id="50410-165">Получение тела сообщения по частям также называется *прочтение сообщения*.</span><span class="sxs-lookup"><span data-stu-id="50410-165">Getting the message body piece-by-piece is also called *reading a message*.</span></span> <span data-ttu-id="50410-166">Прочтение сообщения в основном используется инфраструктурой службы при получении сообщений.</span><span class="sxs-lookup"><span data-stu-id="50410-166">Reading the message is primarily used by the service framework when receiving messages.</span></span> <span data-ttu-id="50410-167">Например, при использовании <xref:System.Runtime.Serialization.DataContractSerializer> инфраструктура службы размещает средство чтения XML над текстом сообщения, а затем передает его механизму десериализации, который начинает считывать сообщение по элементам и создавать соответствующий граф объекта.</span><span class="sxs-lookup"><span data-stu-id="50410-167">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> is in use, the service framework will get an XML reader over the body and pass it to the deserialization engine, which will then start reading the message element-by-element and constructing the corresponding object graph.</span></span>  
  
 <span data-ttu-id="50410-168">Текст сообщения можно извлечь только один раз.</span><span class="sxs-lookup"><span data-stu-id="50410-168">A message body can be retrieved only once.</span></span> <span data-ttu-id="50410-169">Это позволяет работать с потоками только в прямом направлении.</span><span class="sxs-lookup"><span data-stu-id="50410-169">This makes it possible to work with forward-only streams.</span></span> <span data-ttu-id="50410-170">Например, вы можете записать переопределение <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> , выполняющее чтение из потока <xref:System.IO.FileStream> и возвращающее результаты в виде набора сведений XML.</span><span class="sxs-lookup"><span data-stu-id="50410-170">For example, you can write an <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> override that reads from a <xref:System.IO.FileStream> and returns the results as an XML Infoset.</span></span> <span data-ttu-id="50410-171">Вы никогда не потребуется «перемотке назад» в начало файла.</span><span class="sxs-lookup"><span data-stu-id="50410-171">You will never need to "rewind" to the beginning of the file.</span></span>  
  
 <span data-ttu-id="50410-172">Методы `WriteBodyContents` и `GetReaderAtBodyContents` просто проверяют, что тело сообщения никогда ранее не извлекалось, а затем вызывают `OnWriteBodyContents` или `OnGetReaderAtBodyContents`соответственно.</span><span class="sxs-lookup"><span data-stu-id="50410-172">The `WriteBodyContents` and `GetReaderAtBodyContents` methods simply check that the message body has never been retrieved before, and then call `OnWriteBodyContents` or `OnGetReaderAtBodyContents`, respectively.</span></span>  
  
## <a name="message-usage-in-wcf"></a><span data-ttu-id="50410-173">Использование сообщений в WCF</span><span class="sxs-lookup"><span data-stu-id="50410-173">Message Usage in WCF</span></span>  
 <span data-ttu-id="50410-174">Большинство сообщений можно разбить на две группы: *исходящие* (создаваемые инфраструктурой службы для отправки стеком каналов) или *входящие* (прибывающие из стека каналов и интерпретируемые инфраструктурой службы).</span><span class="sxs-lookup"><span data-stu-id="50410-174">Most messages can be classified as either *outgoing* (those that are created by the service framework to be sent by the channel stack) or *incoming* (those that arrive from the channel stack and are interpreted by the service framework).</span></span> <span data-ttu-id="50410-175">Более того, стек каналов может работать в режиме буферизации или в режиме потока.</span><span class="sxs-lookup"><span data-stu-id="50410-175">Furthermore, the channel stack can operate in either buffered or streaming mode.</span></span> <span data-ttu-id="50410-176">Инфраструктура службы также может отображать потоковую или непотоковую модель программирования.</span><span class="sxs-lookup"><span data-stu-id="50410-176">The service framework may also expose a streamed or nonstreamed programming model.</span></span> <span data-ttu-id="50410-177">В связи с этим необходимо привести следующую таблицу, в которой перечисляются различные варианты использования сообщений, а также сообщаются упрощенные сведения об их реализации.</span><span class="sxs-lookup"><span data-stu-id="50410-177">This leads to the cases listed in the following table, along with simplified details of their implementation.</span></span>  
  
|<span data-ttu-id="50410-178">Тип сообщения</span><span class="sxs-lookup"><span data-stu-id="50410-178">Message type</span></span>|<span data-ttu-id="50410-179">Данные основного текста в сообщении</span><span class="sxs-lookup"><span data-stu-id="50410-179">Body data in message</span></span>|<span data-ttu-id="50410-180">Реализация записи (OnWriteBodyContents)</span><span class="sxs-lookup"><span data-stu-id="50410-180">Write (OnWriteBodyContents) implementation</span></span>|<span data-ttu-id="50410-181">Реализация чтения (OnGetReaderAtBodyContents)</span><span class="sxs-lookup"><span data-stu-id="50410-181">Read (OnGetReaderAtBodyContents) Implementation</span></span>|  
|------------------|--------------------------|--------------------------------------------------|-------------------------------------------------------|  
|<span data-ttu-id="50410-182">Исходящие, созданные из непотоковой модели программирования</span><span class="sxs-lookup"><span data-stu-id="50410-182">Outgoing, created from nonstreamed programming model</span></span>|<span data-ttu-id="50410-183">Данные, необходимые для записи сообщения (например, объект и экземпляр <xref:System.Runtime.Serialization.DataContractSerializer> , необходимый для его сериализации)\*</span><span class="sxs-lookup"><span data-stu-id="50410-183">The data needed to write the message (for example, an object and the <xref:System.Runtime.Serialization.DataContractSerializer> instance needed to serialize it)\*</span></span>|<span data-ttu-id="50410-184">Пользовательская логика для записи сообщения на основании сохраненных данных (например, вызов метода `WriteObject` сериализатора `DataContractSerializer` , если используется именно этот сериализатор)\*</span><span class="sxs-lookup"><span data-stu-id="50410-184">Custom logic to write out the message based on the stored data (for example, call `WriteObject` on the `DataContractSerializer` if that is the serializer in use)\*</span></span>|<span data-ttu-id="50410-185">Вызов `OnWriteBodyContents`, буферизация результатов, возврат средства чтения XML над буфером</span><span class="sxs-lookup"><span data-stu-id="50410-185">Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer</span></span>|  
|<span data-ttu-id="50410-186">Исходящие, созданные из потоковой модели программирования</span><span class="sxs-lookup"><span data-stu-id="50410-186">Outgoing, created from streamed programming model</span></span>|<span data-ttu-id="50410-187">Объект `Stream` с записываемыми данными\*</span><span class="sxs-lookup"><span data-stu-id="50410-187">The `Stream` with the data to be written\*</span></span>|<span data-ttu-id="50410-188">Запись данных из сохраненного потока с помощью механизма <xref:System.Xml.IStreamProvider> \*</span><span class="sxs-lookup"><span data-stu-id="50410-188">Write out data from the stored stream using the <xref:System.Xml.IStreamProvider> mechanism\*</span></span>|<span data-ttu-id="50410-189">Вызов `OnWriteBodyContents`, буферизация результатов, возврат средства чтения XML над буфером</span><span class="sxs-lookup"><span data-stu-id="50410-189">Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer</span></span>|  
|<span data-ttu-id="50410-190">Входящие из потокового стека каналов</span><span class="sxs-lookup"><span data-stu-id="50410-190">Incoming from streaming channel stack</span></span>|<span data-ttu-id="50410-191">Объект `Stream` , который представляет поступающие через сеть данные с помощью <xref:System.Xml.XmlReader> над ним</span><span class="sxs-lookup"><span data-stu-id="50410-191">A `Stream` object that represents the data coming in over the network with an <xref:System.Xml.XmlReader> over it</span></span>|<span data-ttu-id="50410-192">Запись содержимого из сохраненного `XmlReader` с помощью `WriteNode`</span><span class="sxs-lookup"><span data-stu-id="50410-192">Write out the contents from the stored `XmlReader` using `WriteNode`</span></span>|<span data-ttu-id="50410-193">Возвращает сохраненное средство чтения `XmlReader`.</span><span class="sxs-lookup"><span data-stu-id="50410-193">Returns the stored `XmlReader`</span></span>|  
|<span data-ttu-id="50410-194">Входящие из непотокового стека каналов</span><span class="sxs-lookup"><span data-stu-id="50410-194">Incoming from nonstreaming channel stack</span></span>|<span data-ttu-id="50410-195">Буфер, который содержит данные основного текста и `XmlReader` над ними</span><span class="sxs-lookup"><span data-stu-id="50410-195">A buffer that contains body data with an `XmlReader` over it</span></span>|<span data-ttu-id="50410-196">Записывает содержимое из сохраненного `XmlReader` с помощью `WriteNode`</span><span class="sxs-lookup"><span data-stu-id="50410-196">Writes out the contents from the stored `XmlReader` using `WriteNode`</span></span>|<span data-ttu-id="50410-197">Возвращает сохраненный атрибут lang</span><span class="sxs-lookup"><span data-stu-id="50410-197">Returns the stored lang</span></span>|  
  
 <span data-ttu-id="50410-198">\* Эти элементы не реализованы непосредственно в `Message` подклассов, а в подклассах класса <xref:System.ServiceModel.Channels.BodyWriter> класса.</span><span class="sxs-lookup"><span data-stu-id="50410-198">\* These items are not implemented directly in `Message` subclasses, but in subclasses of the <xref:System.ServiceModel.Channels.BodyWriter> class.</span></span> <span data-ttu-id="50410-199">Дополнительные сведения о веб-службе <xref:System.ServiceModel.Channels.BodyWriter>см. в разделе [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="50410-199">For more information about the <xref:System.ServiceModel.Channels.BodyWriter>, see [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).</span></span>  
  
## <a name="message-headers"></a><span data-ttu-id="50410-200">Заголовки сообщений</span><span class="sxs-lookup"><span data-stu-id="50410-200">Message Headers</span></span>  
 <span data-ttu-id="50410-201">Сообщение может содержать заголовки.</span><span class="sxs-lookup"><span data-stu-id="50410-201">A message may contain headers.</span></span> <span data-ttu-id="50410-202">Логически заголовок состоит из набора сведений XML, связанного с именем, пространством имен и несколькими другими свойствами.</span><span class="sxs-lookup"><span data-stu-id="50410-202">A header logically consists of an XML Infoset that is associated with a name, a namespace, and a few other properties.</span></span> <span data-ttu-id="50410-203">Доступ к заголовкам сообщения осуществляется с помощью свойства `Headers` сообщения <xref:System.ServiceModel.Channels.Message>.</span><span class="sxs-lookup"><span data-stu-id="50410-203">Message headers are accessed using the `Headers` property on <xref:System.ServiceModel.Channels.Message>.</span></span> <span data-ttu-id="50410-204">Каждый заголовок представляется классом <xref:System.ServiceModel.Channels.MessageHeader> .</span><span class="sxs-lookup"><span data-stu-id="50410-204">Each header is represented by a <xref:System.ServiceModel.Channels.MessageHeader> class.</span></span> <span data-ttu-id="50410-205">Как правило, заголовки сообщения сопоставляются с заголовками сообщения SOAP при использовании стека каналов, настроенного на работу с сообщениями SOAP.</span><span class="sxs-lookup"><span data-stu-id="50410-205">Normally, message headers are mapped to SOAP message headers when using a channel stack configured to work with SOAP messages.</span></span>  
  
 <span data-ttu-id="50410-206">Размещение данных в заголовке сообщения и извлечение данных из заголовка аналогичны использованию тела сообщения.</span><span class="sxs-lookup"><span data-stu-id="50410-206">Putting information into a message header and extracting information from it is similar to using the message body.</span></span> <span data-ttu-id="50410-207">Процесс несколько упрощается из-за того, что в заголовках не поддерживается потоковая передача.</span><span class="sxs-lookup"><span data-stu-id="50410-207">The process is somewhat simplified because streaming is not supported.</span></span> <span data-ttu-id="50410-208">Доступ к содержимому одного и того же заголовка можно осуществлять более одного раза, кроме того, это можно делать в произвольном порядке, каждый раз принудительно вызывая буферизацию заголовков.</span><span class="sxs-lookup"><span data-stu-id="50410-208">It is possible to access the contents of the same header more than once, and headers can be accessed in arbitrary order, forcing headers to always be buffered.</span></span> <span data-ttu-id="50410-209">Существует универсального механизма получить средство чтения XML над заголовком, но есть `MessageHeader` WCF, которая представляет доступные для чтения заголовок с такой возможностью внутренний подкласс.</span><span class="sxs-lookup"><span data-stu-id="50410-209">There is no general-purpose mechanism available to get an XML reader over a header, but there is a `MessageHeader` subclass internal to WCF that represents a readable header with such a capability.</span></span> <span data-ttu-id="50410-210">Этот тип заголовка `MessageHeader` создается стеком каналов, когда приходит сообщение с заголовками пользовательского приложения.</span><span class="sxs-lookup"><span data-stu-id="50410-210">This type of `MessageHeader` is created by the channel stack when a message with custom application headers comes in.</span></span> <span data-ttu-id="50410-211">Это позволяет инфраструктуре службы использовать для интерпретации этих заголовков механизм десериализации, такой как <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="50410-211">This enables the service framework to use a deserialization engine, such as the <xref:System.Runtime.Serialization.DataContractSerializer>, to interpret these headers.</span></span>  
  
 <span data-ttu-id="50410-212">Дополнительные сведения см. в разделе [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="50410-212">For more information, see [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).</span></span>  
  
## <a name="message-properties"></a><span data-ttu-id="50410-213">Свойства сообщения</span><span class="sxs-lookup"><span data-stu-id="50410-213">Message Properties</span></span>  
 <span data-ttu-id="50410-214">Сообщение может содержать свойства.</span><span class="sxs-lookup"><span data-stu-id="50410-214">A message may contain properties.</span></span> <span data-ttu-id="50410-215">Объект *свойство* — это любой объект .NET Framework, которая связана с именем строки.</span><span class="sxs-lookup"><span data-stu-id="50410-215">A *property* is any .NET Framework object that is associated with a string name.</span></span> <span data-ttu-id="50410-216">Доступ к свойствам осуществляется через свойство `Properties` сообщения `Message`.</span><span class="sxs-lookup"><span data-stu-id="50410-216">Properties are accessed through the `Properties` property on `Message`.</span></span>  
  
 <span data-ttu-id="50410-217">В отличие от тела и заголовков сообщения (которые обычно сопоставляются с текстом и заголовками сообщения SOAP соответственно) свойства сообщения, как правило, не отправляются и не принимаются вместе с этими сообщениями.</span><span class="sxs-lookup"><span data-stu-id="50410-217">Unlike the message body and message headers (which normally map to the SOAP body and SOAP headers, respectively), message properties are normally not sent or received along with the messages.</span></span> <span data-ttu-id="50410-218">Свойства сообщения существуют в основном в качестве механизма связи для передачи данных о сообщении между различными каналами в стеке каналов, а также между стеком каналов и моделью служб.</span><span class="sxs-lookup"><span data-stu-id="50410-218">Message properties exist primarily as a communication mechanism to pass data about the message between the various channels in the channel stack, and between the channel stack and the service model.</span></span>  
  
 <span data-ttu-id="50410-219">Например, канал транспорта HTTP, являющемся частью WCF может создать различные коды состояния HTTP, такие как «404 (не найдено)» и «500 (Внутренняя ошибка сервера),» при отправке ответов клиентам.</span><span class="sxs-lookup"><span data-stu-id="50410-219">For example, the HTTP transport channel included as part of WCF is capable of producing various HTTP status codes, such as "404 (Not Found)" and "500 (Internal Server Error)," when it sends replies to clients.</span></span> <span data-ttu-id="50410-220">Перед отправкой сообщения ответа, проверяется ли `Properties` из `Message` содержат свойство с именем «httpResponse», который содержит объект типа <xref:System.ServiceModel.Channels.HttpResponseMessageProperty>.</span><span class="sxs-lookup"><span data-stu-id="50410-220">Before sending a reply message, it checks to see whether the `Properties` of the `Message` contain a property called "httpResponse" that contains an object of type <xref:System.ServiceModel.Channels.HttpResponseMessageProperty>.</span></span> <span data-ttu-id="50410-221">Если это свойство найдено, канал транспорта обращается к свойству <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> и использует указанный код состояния.</span><span class="sxs-lookup"><span data-stu-id="50410-221">If such a property is found, it will look at the <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> property and use that status code.</span></span> <span data-ttu-id="50410-222">Если свойство не найдено, используется код по умолчанию - «200 (ОК)».</span><span class="sxs-lookup"><span data-stu-id="50410-222">If it is not found, the default "200 (OK)" code is used.</span></span>  
  
 <span data-ttu-id="50410-223">Дополнительные сведения см. в разделе [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="50410-223">For more information, see [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).</span></span>  
  
### <a name="the-message-as-a-whole"></a><span data-ttu-id="50410-224">Сообщение как единое целое</span><span class="sxs-lookup"><span data-stu-id="50410-224">The Message as a Whole</span></span>  
 <span data-ttu-id="50410-225">До сих пор мы обсуждали методы доступа к различным частям сообщения по отдельности.</span><span class="sxs-lookup"><span data-stu-id="50410-225">So far, we have discussed methods for accessing the various parts of the message in isolation.</span></span> <span data-ttu-id="50410-226">Однако класс <xref:System.ServiceModel.Channels.Message> также предоставляет методы для работы с сообщением как единым целым.</span><span class="sxs-lookup"><span data-stu-id="50410-226">However, the <xref:System.ServiceModel.Channels.Message> class also provides methods to work with the entire message as a whole.</span></span> <span data-ttu-id="50410-227">Например, метод `WriteMessage` записывает все сообщение в средство записи XML.</span><span class="sxs-lookup"><span data-stu-id="50410-227">For example, the `WriteMessage` method writes out the entire message to an XML writer.</span></span>  
  
 <span data-ttu-id="50410-228">Для этого необходимо задать сопоставление между всем экземпляром `Message` и набором сведений XML.</span><span class="sxs-lookup"><span data-stu-id="50410-228">For this to be possible, a mapping must be defined between the entire `Message` instance and an XML Infoset.</span></span> <span data-ttu-id="50410-229">Такое сопоставление на самом деле, существует: WCF использует стандарт SOAP для определения такого сопоставления.</span><span class="sxs-lookup"><span data-stu-id="50410-229">Such a mapping, in fact, exists: WCF uses the SOAP standard to define this mapping.</span></span> <span data-ttu-id="50410-230">Когда экземпляр `Message` записывается как набор сведений XML, итоговый набор данных является допустимым конвертом SOAP, который содержит соответствующее сообщение.</span><span class="sxs-lookup"><span data-stu-id="50410-230">When a `Message` instance is written out as an XML Infoset, the resulting Infoset is the valid SOAP envelope that contains the message.</span></span> <span data-ttu-id="50410-231">Следовательно, `WriteMessage` , как правило, выполняет следующие шаги:</span><span class="sxs-lookup"><span data-stu-id="50410-231">Thus, `WriteMessage` would normally perform the following steps:</span></span>  
  
1. <span data-ttu-id="50410-232">записывает открывающий тег элемента конверта SOAP,</span><span class="sxs-lookup"><span data-stu-id="50410-232">Write the SOAP envelope element opening tag.</span></span>  
  
2. <span data-ttu-id="50410-233">записывает открывающий тег элемента заголовка SOAP, записывает все заголовки и закрывает элемент заголовка,</span><span class="sxs-lookup"><span data-stu-id="50410-233">Write the SOAP header element opening tag, write out all of the headers, and close the header element.</span></span>  
  
3. <span data-ttu-id="50410-234">записывает открывающий тег элемента тела сообщения SOAP,</span><span class="sxs-lookup"><span data-stu-id="50410-234">Write the SOAP body element opening tag.</span></span>  
  
4. <span data-ttu-id="50410-235">вызывает `WriteBodyContents` или другой эквивалентный метод для записи тела сообщения,</span><span class="sxs-lookup"><span data-stu-id="50410-235">Call `WriteBodyContents` or an equivalent method to write out the body.</span></span>  
  
5. <span data-ttu-id="50410-236">закрывает элементы тела и конверта.</span><span class="sxs-lookup"><span data-stu-id="50410-236">Close the body and envelope elements.</span></span>  
  
 <span data-ttu-id="50410-237">Описанные выше шаги тесно связаны со стандартом SOAP.</span><span class="sxs-lookup"><span data-stu-id="50410-237">The preceding steps are closely tied to the SOAP standard.</span></span> <span data-ttu-id="50410-238">Ситуация осложняется наличием нескольких версий SOAP, так как, например, невозможно правильно записать элемент конверта SOAP, не имея точной информации об используемой версии SOAP.</span><span class="sxs-lookup"><span data-stu-id="50410-238">This is complicated by the fact that multiple versions of SOAP exist, for example, it is impossible to write out the SOAP envelope element correctly without knowing the SOAP version in use.</span></span> <span data-ttu-id="50410-239">В некоторых случаях, кроме того, желательно полностью отключить это сложное сопоставление с протоколом SOAP.</span><span class="sxs-lookup"><span data-stu-id="50410-239">Also, in some cases, it may be desirable to turn off this complex SOAP-specific mapping completely.</span></span>  
  
 <span data-ttu-id="50410-240">Для этих целей в сообщении `Version` предусмотрено свойство `Message`.</span><span class="sxs-lookup"><span data-stu-id="50410-240">For these purposes, a `Version` property is provided on `Message`.</span></span> <span data-ttu-id="50410-241">Это свойство можно настроить на указание версии SOAP, которая должна использоваться при записи сообщения, или установить на `None` , чтобы запретить любые сопоставления с протоколом SOAP.</span><span class="sxs-lookup"><span data-stu-id="50410-241">It can be set to the SOAP version to use when writing out the message, or it can be set to `None` to prevent any SOAP-specific mappings.</span></span> <span data-ttu-id="50410-242">Если свойство `Version` установлено на `None`, методы, работающие с целым сообщением, функционируют как если бы сообщение состояло только из тела, например метод `WriteMessage` в этом случае просто вызывает `WriteBodyContents` , а не выполняет описанную выше последовательность действий.</span><span class="sxs-lookup"><span data-stu-id="50410-242">If the `Version` property is set to `None`, methods that work with the entire message act as if the message consisted of its body only, for example, `WriteMessage` would simply call `WriteBodyContents` instead of performing the multiple steps listed above.</span></span> <span data-ttu-id="50410-243">Предполагается, что для входящих сообщений `Version` будет определяться автоматически и, следовательно, задаваться верно.</span><span class="sxs-lookup"><span data-stu-id="50410-243">It is expected that on incoming messages, `Version` will be auto-detected and set correctly.</span></span>  
  
## <a name="the-channel-stack"></a><span data-ttu-id="50410-244">Стек каналов</span><span class="sxs-lookup"><span data-stu-id="50410-244">The Channel Stack</span></span>  
  
### <a name="channels"></a><span data-ttu-id="50410-245">Каналы</span><span class="sxs-lookup"><span data-stu-id="50410-245">Channels</span></span>  
 <span data-ttu-id="50410-246">Как уже говорилось выше, стек каналов отвечает за преобразование исходящих экземпляров <xref:System.ServiceModel.Channels.Message> в какое-либо действие (например, отправку пакетов по сети) или преобразование какого-либо действия (например, получения сетевых пакетов) во входящие экземпляры `Message` .</span><span class="sxs-lookup"><span data-stu-id="50410-246">As stated before, the channel stack is responsible for converting outgoing <xref:System.ServiceModel.Channels.Message> instances into some action (such as sending packets over the network), or converting some action (such as receiving network packets) into incoming `Message` instances.</span></span>  
  
 <span data-ttu-id="50410-247">Стек каналов представляет собой один или более каналов, упорядоченных определенным образом.</span><span class="sxs-lookup"><span data-stu-id="50410-247">The channel stack is composed of one or more channels ordered in a sequence.</span></span> <span data-ttu-id="50410-248">Исходящий экземпляр `Message` передается первому каналу стека (также называемому *верхним каналом*), который передает экземпляр следующему каналу стека (каналу более низкого уровня) и т. д.</span><span class="sxs-lookup"><span data-stu-id="50410-248">An outgoing `Message` instance is passed to the first channel in the stack (also called the *topmost channel*), which passes it to the next channel down in stack, and so on.</span></span> <span data-ttu-id="50410-249">Завершение сообщения происходит в последнем канале, именуемом *канал транспорта*.</span><span class="sxs-lookup"><span data-stu-id="50410-249">The message terminates in the last channel, which is called the *transport channel*.</span></span> <span data-ttu-id="50410-250">Входящие сообщения создаются в канале транспорта и передаются в стеке от каналов более низкого уровня к каналам более высокого уровня.</span><span class="sxs-lookup"><span data-stu-id="50410-250">Incoming messages originate in the transport channel and are passed from channel to channel up the stack.</span></span> <span data-ttu-id="50410-251">С верхнего канала сообщение, как правило, передается в инфраструктуру службы.</span><span class="sxs-lookup"><span data-stu-id="50410-251">From the topmost channel, the message is usually passed into the service framework.</span></span> <span data-ttu-id="50410-252">Хотя это стандартная процедура обработки сообщений приложения, некоторые каналы могут работать по несколько иной схеме, например они могут отправлять собственные инфраструктурные сообщения, а не передавать сообщения, полученные от каналов более высокого уровня.</span><span class="sxs-lookup"><span data-stu-id="50410-252">While this is the usual pattern for application messages, some channels may work slightly differently, for example, they may send their own infrastructure messages without being passed a message from a channel above.</span></span>  
  
 <span data-ttu-id="50410-253">Каналы могут по-разному оперировать сообщениями при прохождении последних через стек.</span><span class="sxs-lookup"><span data-stu-id="50410-253">Channels may operate on the message in various ways as it passes through the stack.</span></span> <span data-ttu-id="50410-254">Наиболее распространенной операцией является добавление заголовка к исходящему сообщению и чтение заголовков входящего сообщения.</span><span class="sxs-lookup"><span data-stu-id="50410-254">The most common operation is adding a header to an outgoing message and reading headers on an incoming message.</span></span> <span data-ttu-id="50410-255">Например, канал может вычислить цифровую подпись в сообщении и добавить ее в качестве заголовка.</span><span class="sxs-lookup"><span data-stu-id="50410-255">For example, a channel may compute the digital signature of a message and add it as a header.</span></span> <span data-ttu-id="50410-256">Канал также может проверить заголовок входящих сообщений, содержащий цифровую подпись, и заблокировать сообщения, которые не имеют действительной подписи (т. е. запретить их передачу по стеку каналов).</span><span class="sxs-lookup"><span data-stu-id="50410-256">A channel may also inspect this digital signature header on incoming messages and block messages that do not have a valid signature from making their way up the channel stack.</span></span> <span data-ttu-id="50410-257">Каналы часто используются для установки и проверки свойств сообщения.</span><span class="sxs-lookup"><span data-stu-id="50410-257">Channels also often set or inspect message properties.</span></span> <span data-ttu-id="50410-258">Обычно является тело сообщения не изменяется, хотя это допустимо, например, канал безопасности WCF может шифровать текст сообщения.</span><span class="sxs-lookup"><span data-stu-id="50410-258">The message body is usually not modified, although this is allowed, for example, the WCF security channel can encrypt the message body.</span></span>  
  
### <a name="transport-channels-and-message-encoders"></a><span data-ttu-id="50410-259">Каналы транспорта и кодировщики сообщений</span><span class="sxs-lookup"><span data-stu-id="50410-259">Transport Channels and Message Encoders</span></span>  
 <span data-ttu-id="50410-260">Самый нижний канал стека отвечает за фактическое преобразование исходящего сообщения <xref:System.ServiceModel.Channels.Message>, измененного другими каналами, в какое-либо действие.</span><span class="sxs-lookup"><span data-stu-id="50410-260">The bottommost channel in the stack is responsible for actually transforming an outgoing <xref:System.ServiceModel.Channels.Message>, as modified by other channels, into some action.</span></span> <span data-ttu-id="50410-261">На принимающей стороне этот канал преобразует действие в сообщение `Message` , которое обрабатывается другими каналами.</span><span class="sxs-lookup"><span data-stu-id="50410-261">On the receive side, this is the channel that converts some action into a `Message` that other channels process.</span></span>  
  
 <span data-ttu-id="50410-262">Как уже говорилось ранее, действия могут быть самыми разнообразными: например, отправка или получение сетевых пакетов по различным протоколам, чтение или запись сообщений в базу данных, постановка сообщений в очередь сообщений или удаление сообщений из очереди.</span><span class="sxs-lookup"><span data-stu-id="50410-262">As stated previously, the actions may be varied: sending or receiving network packets over various protocols, reading or writing the message in a database, or queuing or dequeuing the message in a Message Queuing queue, to provide but a few examples.</span></span> <span data-ttu-id="50410-263">Все эти действия характерны одну вещь: их выполнение требует преобразования между WCF`Message` экземпляра и фактической группой байтов, которые могут быть отправлять, принимать, читать, записывать, в очереди или из очереди.</span><span class="sxs-lookup"><span data-stu-id="50410-263">All these actions have one thing in common: they require a transformation between the WCF`Message` instance and an actual group of bytes that can be sent, received, read, written, queued, or dequeued.</span></span> <span data-ttu-id="50410-264">Процесс преобразования `Message` в группу байтов называется *кодированием*, а обратный процесс создания `Message` из группы байтов - *декодированием*.</span><span class="sxs-lookup"><span data-stu-id="50410-264">The process of converting a `Message` into a group of bytes is called *encoding*, and the reverse process of creating a `Message` from a group of bytes is called *decoding*.</span></span>  
  
 <span data-ttu-id="50410-265">Большинство каналов транспорта для кодирования и декодирования используют компоненты под названием *кодировщики сообщений* .</span><span class="sxs-lookup"><span data-stu-id="50410-265">Most transport channels use components called *message encoders* to accomplish the encoding and decoding work.</span></span> <span data-ttu-id="50410-266">Кодировщик сообщений - это подкласс класса <xref:System.ServiceModel.Channels.MessageEncoder> .</span><span class="sxs-lookup"><span data-stu-id="50410-266">A message encoder is a subclass of the <xref:System.ServiceModel.Channels.MessageEncoder> class.</span></span> <span data-ttu-id="50410-267">`MessageEncoder` включает различные перегрузки метода `ReadMessage` и `WriteMessage` , позволяющие производить преобразование из `Message` в группу байтов и обратно.</span><span class="sxs-lookup"><span data-stu-id="50410-267">`MessageEncoder` includes various `ReadMessage` and `WriteMessage` method overloads to convert between `Message` and groups of bytes.</span></span>  
  
 <span data-ttu-id="50410-268">На отправляющей стороне буферизующий канал транспорта передает объект `Message` , полученный от канала более высокого уровня, методу `WriteMessage`.</span><span class="sxs-lookup"><span data-stu-id="50410-268">On the sending side, a buffering transport channel passes the `Message` object that it received from a channel above it to `WriteMessage`.</span></span> <span data-ttu-id="50410-269">Он возвращает массив байтов, который затем использует для выполнения действия (например, упаковки этих байтов в виде действительных TCP-пакетов и отправки их по назначению).</span><span class="sxs-lookup"><span data-stu-id="50410-269">It gets back an array of bytes, which it then uses to perform its action (such as packaging these bytes as valid TCP packets and sending them to the correct destination).</span></span> <span data-ttu-id="50410-270">Потоковый канал транспорта сначала создает поток `Stream` (например, через исходящее TCP-соединение), а затем передает поток `Stream` и сообщение `Message` , которые он должен отправить записывающей сообщение перегрузке соответствующего метода `WriteMessage` .</span><span class="sxs-lookup"><span data-stu-id="50410-270">A streaming transport channel first creates a `Stream` (for example, over the outgoing TCP connection), and then passes both the `Stream` and the `Message` it needs to send to the appropriate `WriteMessage` overload, which writes out the message.</span></span>  
  
 <span data-ttu-id="50410-271">На получающей стороне буферизующий канал транспорта извлекает входящие байты (например, от входящих TCP-пакетов) в массив и вызывает метод `ReadMessage` , чтобы получить объект `Message` для передачи по стеку каналов.</span><span class="sxs-lookup"><span data-stu-id="50410-271">On the receiving side, a buffering transport channel extracts incoming bytes (for example, from incoming TCP packets) into an array and calls `ReadMessage` to get a `Message` object that it can pass further up the channel stack.</span></span> <span data-ttu-id="50410-272">Потоковый канал транспорта создает объект `Stream` (например, сетевой поток по входящему TCP-подключению) и передает его `ReadMessage` , чтобы возвратить объект `Message` .</span><span class="sxs-lookup"><span data-stu-id="50410-272">A streaming transport channel creates a `Stream` object (for example, a network stream over the incoming TCP connection) and passes that to `ReadMessage` to get back a `Message` object.</span></span>  
  
 <span data-ttu-id="50410-273">Разделение между каналами транспорта и кодировщиком сообщений не является обязательным; можно создать канал транспорта, который не использует кодировщик сообщений.</span><span class="sxs-lookup"><span data-stu-id="50410-273">The separation between the transport channels and the message encoder is not mandatory; it is possible to write a transport channel that does not use a message encoder.</span></span> <span data-ttu-id="50410-274">Однако преимуществом подобного разделения является простота построения.</span><span class="sxs-lookup"><span data-stu-id="50410-274">However, the advantage of this separation is ease of composition.</span></span> <span data-ttu-id="50410-275">До тех пор, пока канал транспорта использует только базу <xref:System.ServiceModel.Channels.MessageEncoder>, он может работать с WCF и кодировщик сообщений независимых производителей.</span><span class="sxs-lookup"><span data-stu-id="50410-275">As long as a transport channel uses only the base <xref:System.ServiceModel.Channels.MessageEncoder>, it can work with any WCF or third-party message encoder.</span></span> <span data-ttu-id="50410-276">Аналогично, один и тот же кодировщик, как правило, можно использовать в любом канале транспорта.</span><span class="sxs-lookup"><span data-stu-id="50410-276">Likewise, the same encoder can normally be used in any transport channel.</span></span>  
  
### <a name="message-encoder-operation"></a><span data-ttu-id="50410-277">Операции кодировщика сообщений</span><span class="sxs-lookup"><span data-stu-id="50410-277">Message Encoder Operation</span></span>  
 <span data-ttu-id="50410-278">Для того чтобы описать стандартные операции, выполняемые кодировщиком сообщений, рекомендуется рассмотреть следующие четыре случая.</span><span class="sxs-lookup"><span data-stu-id="50410-278">To describe the typical operation of an encoder, it is useful to consider the following four cases.</span></span>  
  
|<span data-ttu-id="50410-279">Операция</span><span class="sxs-lookup"><span data-stu-id="50410-279">Operation</span></span>|<span data-ttu-id="50410-280">Комментарий</span><span class="sxs-lookup"><span data-stu-id="50410-280">Comment</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="50410-281">Кодирование (с буферизацией)</span><span class="sxs-lookup"><span data-stu-id="50410-281">Encoding, Buffered</span></span>|<span data-ttu-id="50410-282">В режиме буферизации кодировщик, как правило, создает буфер с переменным размером, а затем создает над ним средство записи XML.</span><span class="sxs-lookup"><span data-stu-id="50410-282">In buffered mode, the encoder normally creates a variable-size buffer and then creates an XML writer over it.</span></span> <span data-ttu-id="50410-283">После этого кодировщик вызывает метод <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> для кодируемого сообщения, который записывает заголовки и текст сообщения с помощью <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>(см. пояснение в предыдущем подразделе данного раздела, `Message` ).</span><span class="sxs-lookup"><span data-stu-id="50410-283">It then calls <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> on the message being encoded, which writes out the headers and then the body using <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, as explained in the preceding section about `Message` in this topic.</span></span> <span data-ttu-id="50410-284">Содержимое буфера (представленное в виде массива байтов) затем возвращается каналу транспорта для дальнейшего использования.</span><span class="sxs-lookup"><span data-stu-id="50410-284">The contents of the buffer (represented as an array of bytes) are then returned for the transport channel to use.</span></span>|  
|<span data-ttu-id="50410-285">Кодирование (потоковое)</span><span class="sxs-lookup"><span data-stu-id="50410-285">Encoding, Streamed</span></span>|<span data-ttu-id="50410-286">При работе в потоковом режиме операция также выполняется согласно данному выше описанию, при этом ситуация упрощается тем,</span><span class="sxs-lookup"><span data-stu-id="50410-286">In streamed mode, the operation is similar to the above, but simpler.</span></span> <span data-ttu-id="50410-287">что нет необходимости использовать буфер.</span><span class="sxs-lookup"><span data-stu-id="50410-287">There is no need for a buffer.</span></span> <span data-ttu-id="50410-288">Как правило, средство записи XML создается над потоком, а метод <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> вызывается для сообщения `Message` , чтобы записать его в это средство записи.</span><span class="sxs-lookup"><span data-stu-id="50410-288">An XML writer is normally created over the stream and <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> is called on the `Message` to write it out to this writer.</span></span>|  
|<span data-ttu-id="50410-289">Декодирование (с буферизацией)</span><span class="sxs-lookup"><span data-stu-id="50410-289">Decoding, Buffered</span></span>|<span data-ttu-id="50410-290">При декодировании в режиме буферизации, как правило, создается специальный подкласс `Message` , который содержит буферизованные данные.</span><span class="sxs-lookup"><span data-stu-id="50410-290">When decoding in buffered mode, a special `Message` subclass that contains the buffered data is normally created.</span></span> <span data-ttu-id="50410-291">Считываются заголовки сообщения, создается средство чтения XML и устанавливается в теле письма.</span><span class="sxs-lookup"><span data-stu-id="50410-291">The headers of the message are read, and an XML reader positioned on the message body is created.</span></span> <span data-ttu-id="50410-292">Это средство чтения, которое будет возвращено с <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span><span class="sxs-lookup"><span data-stu-id="50410-292">This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span></span>|  
|<span data-ttu-id="50410-293">Декодирование (потоковое)</span><span class="sxs-lookup"><span data-stu-id="50410-293">Decoding, Streamed</span></span>|<span data-ttu-id="50410-294">При декодировании в потоковом режиме, как правило, создается специальный подкласс "Сообщения".</span><span class="sxs-lookup"><span data-stu-id="50410-294">When decoding in streamed mode, a special Message subclass is normally created.</span></span> <span data-ttu-id="50410-295">Поток перемещается вперед ровно настолько, чтобы прочитать все заголовки и разместить их в теле сообщения.</span><span class="sxs-lookup"><span data-stu-id="50410-295">The stream is advanced just enough to read all the headers and position it on the message body.</span></span> <span data-ttu-id="50410-296">Затем над потоком создается средство чтения XML.</span><span class="sxs-lookup"><span data-stu-id="50410-296">An XML reader is then created over the stream.</span></span> <span data-ttu-id="50410-297">Это средство чтения, которое будет возвращено с <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span><span class="sxs-lookup"><span data-stu-id="50410-297">This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span></span>|  
  
 <span data-ttu-id="50410-298">Кодировщики могут выполнять и другие функции.</span><span class="sxs-lookup"><span data-stu-id="50410-298">Encoders can perform other functions as well.</span></span> <span data-ttu-id="50410-299">Например, они могут объединять в пул средства чтения и записи XML.</span><span class="sxs-lookup"><span data-stu-id="50410-299">For example, the encoders can pool XML readers and writers.</span></span> <span data-ttu-id="50410-300">Не рационально создавать новое средство чтения или записи XML всякий раз, когда в них возникает необходимость.</span><span class="sxs-lookup"><span data-stu-id="50410-300">It is expensive to create a new XML reader or writer every time one is needed.</span></span> <span data-ttu-id="50410-301">Поэтому кодировщики, как правило, поддерживают пул средств чтения и пул средств записи настраиваемого размера.</span><span class="sxs-lookup"><span data-stu-id="50410-301">Therefore, encoders normally maintain a pool of readers and a pool of writers of configurable size.</span></span> <span data-ttu-id="50410-302">В соответствии с описанием операции кодировщика, описанных ранее каждый раз, когда фраза «создать средство чтения/записи XML» используется, это обычно означает «выполните одно из пула или создайте его, если он не доступен.»</span><span class="sxs-lookup"><span data-stu-id="50410-302">In the descriptions of encoder operation described previously, whenever the phrase "create an XML reader/writer" is used, it normally means "take one from the pool, or create one if one is not available."</span></span> <span data-ttu-id="50410-303">Кодировщик (и подклассы `Message` , создаваемые им при декодировании) содержит логику для возвращения средств чтения и записи в пулы, если эти средства более не нужны (например, при закрытии `Message` ).</span><span class="sxs-lookup"><span data-stu-id="50410-303">The encoder (and the `Message` subclasses it creates while decoding) contain logic to return readers and writers to the pools once they are no longer needed (for example, when the `Message` is closed).</span></span>  
  
 <span data-ttu-id="50410-304">WCF предоставляет три кодировщика сообщений, несмотря на то, что можно создать дополнительные пользовательские типы.</span><span class="sxs-lookup"><span data-stu-id="50410-304">WCF provides three message encoders, although it is possible to create additional custom types.</span></span> <span data-ttu-id="50410-305">Это текстовое и двоичное кодирование и механизм оптимизации передачи сообщений (MTOM).</span><span class="sxs-lookup"><span data-stu-id="50410-305">The supplied types are Text, Binary, and Message Transmission Optimization Mechanism (MTOM).</span></span> <span data-ttu-id="50410-306">Эти типы подробно описаны в разделе [Choosing a Message Encoder](../../../../docs/framework/wcf/feature-details/choosing-a-message-encoder.md).</span><span class="sxs-lookup"><span data-stu-id="50410-306">These are described in detail in [Choosing a Message Encoder](../../../../docs/framework/wcf/feature-details/choosing-a-message-encoder.md).</span></span>  
  
### <a name="the-istreamprovider-interface"></a><span data-ttu-id="50410-307">Интерфейс IStreamProvider</span><span class="sxs-lookup"><span data-stu-id="50410-307">The IStreamProvider Interface</span></span>  
 <span data-ttu-id="50410-308">При записи исходящего сообщения с потоковым текстом в средство записи XML <xref:System.ServiceModel.Channels.Message> использует в реализации <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> последовательность вызовов, подобную описанной ниже:</span><span class="sxs-lookup"><span data-stu-id="50410-308">When writing an outgoing message that contains a streamed body to an XML writer, the <xref:System.ServiceModel.Channels.Message> uses a sequence of calls similar to the following in its <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> implementation:</span></span>  
  
- <span data-ttu-id="50410-309">Запись всех необходимых данных, предшествующих потоку (например, открывающий тег XML).</span><span class="sxs-lookup"><span data-stu-id="50410-309">Write any necessary information preceding the stream (for example, the opening XML tag).</span></span>  
  
- <span data-ttu-id="50410-310">запись потока;</span><span class="sxs-lookup"><span data-stu-id="50410-310">Write the stream.</span></span>  
  
- <span data-ttu-id="50410-311">Запись данных, следующих за потоком (например, закрывающий тег XML).</span><span class="sxs-lookup"><span data-stu-id="50410-311">Write any information following the stream (for example, the closing XML tag).</span></span>  
  
 <span data-ttu-id="50410-312">Этот подход хорошо работает с кодировками, подобными текстовой кодировке XML.</span><span class="sxs-lookup"><span data-stu-id="50410-312">This works well with encodings that are similar to the textual XML encoding.</span></span> <span data-ttu-id="50410-313">Однако некоторые кодировки не размещают информацию набора сведений XML (например, теги начальных и конечных XML-элементов) вместе с данными, которые содержатся внутри элементов.</span><span class="sxs-lookup"><span data-stu-id="50410-313">However, some encodings do not place XML Infoset information (for example, tags for starting and ending XML elements) together with the data contained within elements.</span></span> <span data-ttu-id="50410-314">Например, при кодировании MTOM сообщение разделяется на несколько частей.</span><span class="sxs-lookup"><span data-stu-id="50410-314">For example, in the MTOM encoding, the message is split into multiple parts.</span></span> <span data-ttu-id="50410-315">Одна часть содержит набор сведений XML, в том числе, возможно, и ссылки на другие части фактического содержимого элемента.</span><span class="sxs-lookup"><span data-stu-id="50410-315">One part contains the XML Infoset, which may contain references to other parts for actual element contents.</span></span> <span data-ttu-id="50410-316">Набор сведений XML, как правило, сравнительно мал по сравнению с потоковым содержимым, поэтому имеет смысл его буферизировать, сохранить, а затем записать содержимое потоковым способом.</span><span class="sxs-lookup"><span data-stu-id="50410-316">The XML Infoset is normally small compared to the streamed contents, so it makes sense to buffer the Infoset, write it out, and then write the contents in a streamed way.</span></span> <span data-ttu-id="50410-317">Это означает, что к моменту записи закрывающего тега элемента поток должен быть не сохранен.</span><span class="sxs-lookup"><span data-stu-id="50410-317">This means that by the time the closing element tag is written, the stream should not have been written out yet.</span></span>  
  
 <span data-ttu-id="50410-318">Для этого используется интерфейс <xref:System.Xml.IStreamProvider> .</span><span class="sxs-lookup"><span data-stu-id="50410-318">For this purpose, the <xref:System.Xml.IStreamProvider> interface is used.</span></span> <span data-ttu-id="50410-319">Этот интерфейс содержит метод <xref:System.Xml.IStreamProvider.GetStream> , который возвращает поток, подлежащий записи.</span><span class="sxs-lookup"><span data-stu-id="50410-319">The interface has a <xref:System.Xml.IStreamProvider.GetStream> method that returns the stream to be written.</span></span> <span data-ttu-id="50410-320">Ниже описан правильный способ сохранения потокового тела сообщения в <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> .</span><span class="sxs-lookup"><span data-stu-id="50410-320">The correct way to write out a streamed message body in <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> is as follows:</span></span>  
  
1. <span data-ttu-id="50410-321">Запись всех необходимых данных, предшествующих потоку (например, открывающий тег XML).</span><span class="sxs-lookup"><span data-stu-id="50410-321">Write any necessary information preceding the stream (for example, the opening XML tag).</span></span>  
  
2. <span data-ttu-id="50410-322">Вызов перегрузки `WriteValue` для <xref:System.Xml.XmlDictionaryWriter> , принимающего <xref:System.Xml.IStreamProvider>, с реализацией `IStreamProvider` , возвращающей подлежащий записи поток.</span><span class="sxs-lookup"><span data-stu-id="50410-322">Call the `WriteValue` overload on the <xref:System.Xml.XmlDictionaryWriter> that takes an <xref:System.Xml.IStreamProvider>, with an `IStreamProvider` implementation that returns the stream to be written.</span></span>  
  
3. <span data-ttu-id="50410-323">Запись данных, следующих за потоком (например, закрывающий тег XML).</span><span class="sxs-lookup"><span data-stu-id="50410-323">Write any information following the stream (for example, the closing XML tag).</span></span>  
  
 <span data-ttu-id="50410-324">Используя этот подход, средство записи XML может выбирать, когда вызывать <xref:System.Xml.IStreamProvider.GetStream> и сохранять потоковые данные.</span><span class="sxs-lookup"><span data-stu-id="50410-324">With this approach, the XML writer has a choice of when to call <xref:System.Xml.IStreamProvider.GetStream> and write out the streamed data.</span></span> <span data-ttu-id="50410-325">Например, средства записи текстовых и двоичных данных XML немедленно вызывают его и записывают потоковое содержимое между открывающим и закрывающим тегами.</span><span class="sxs-lookup"><span data-stu-id="50410-325">For example, the textual and binary XML writers will call it immediately and write out the streamed contents in-between the start and end tags.</span></span> <span data-ttu-id="50410-326">Средство записи MTOM может вызвать <xref:System.Xml.IStreamProvider.GetStream> позже, когда будет готово к записи соответствующей части сообщения.</span><span class="sxs-lookup"><span data-stu-id="50410-326">The MTOM writer may decide to call <xref:System.Xml.IStreamProvider.GetStream> later, when it is ready to write the appropriate part of the message.</span></span>  
  
## <a name="representing-data-in-the-service-framework"></a><span data-ttu-id="50410-327">Представление данных в инфраструктуре службы</span><span class="sxs-lookup"><span data-stu-id="50410-327">Representing Data in the Service Framework</span></span>  
 <span data-ttu-id="50410-328">Как уже говорилось в разделе «Базовая архитектура» данного раздела, инфраструктура службы является частью WCF, которая, помимо прочего, отвечает за преобразование между понятное модель программирования данных сообщения, фактически `Message` экземпляров.</span><span class="sxs-lookup"><span data-stu-id="50410-328">As stated in the "Basic Architecture" section of this topic, the service framework is the part of WCF that, among other things, is responsible for converting between a user-friendly programming model for message data and actual `Message` instances.</span></span> <span data-ttu-id="50410-329">Как правило, обмен сообщениями представляется в инфраструктуре службы как .NET Framework метод, помеченный <xref:System.ServiceModel.OperationContractAttribute> атрибута.</span><span class="sxs-lookup"><span data-stu-id="50410-329">Normally, a message exchange is represented in the service framework as a .NET Framework method marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute.</span></span> <span data-ttu-id="50410-330">Метод может брать несколько параметров и возвращать возвращаемое значение или выходные параметры (или и то, и другое).</span><span class="sxs-lookup"><span data-stu-id="50410-330">The method can take in some parameters and can return a return value or out parameters (or both).</span></span> <span data-ttu-id="50410-331">На стороне службы входные параметры представляют входящее сообщение, а возвращаемое значение и выходные параметры - исходящее сообщение.</span><span class="sxs-lookup"><span data-stu-id="50410-331">On the service side, the input parameters represent the incoming message, and the return value and out parameters represent the outgoing message.</span></span> <span data-ttu-id="50410-332">На стороне клиента происходит обратное представление.</span><span class="sxs-lookup"><span data-stu-id="50410-332">On the client side, the reverse is true.</span></span> <span data-ttu-id="50410-333">Подробные сведения о модели программирования для описания сообщений с помощью параметров и возвращаемого значения см. в разделе [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="50410-333">The programming model for describing messages using parameters and the return value is described in detail in [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).</span></span> <span data-ttu-id="50410-334">А в этом разделе приводится краткий обзор моделей.</span><span class="sxs-lookup"><span data-stu-id="50410-334">However, this section will provide a brief overview.</span></span>  
  
## <a name="programming-models"></a><span data-ttu-id="50410-335">Модели программирования</span><span class="sxs-lookup"><span data-stu-id="50410-335">Programming Models</span></span>  
 <span data-ttu-id="50410-336">Инфраструктура службы WCF поддерживает пять разных моделей программирования для описания сообщений:</span><span class="sxs-lookup"><span data-stu-id="50410-336">The WCF service framework supports five different programming models for describing messages:</span></span>  
  
### <a name="1-the-empty-message"></a><span data-ttu-id="50410-337">1. Пустое сообщение</span><span class="sxs-lookup"><span data-stu-id="50410-337">1. The Empty Message</span></span>  
 <span data-ttu-id="50410-338">Это простейший случай.</span><span class="sxs-lookup"><span data-stu-id="50410-338">This is the simplest case.</span></span> <span data-ttu-id="50410-339">Для описания пустого входящего сообщения не нужно использовать какие-либо входные параметры.</span><span class="sxs-lookup"><span data-stu-id="50410-339">To describe an empty incoming message, do not use any input parameters.</span></span>  
  
 [!code-csharp[C_DataArchitecture#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#3)]
 [!code-vb[C_DataArchitecture#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#3)]  
  
 <span data-ttu-id="50410-340">Для описания пустого исходящего сообщения нужно использовать возвращаемое значение типа void, выходные параметры при этом не используются.</span><span class="sxs-lookup"><span data-stu-id="50410-340">To describe an empty outgoing message, use a void return value and do not use any out parameters:</span></span>  
  
 [!code-csharp[C_DataArchitecture#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#4)]
 [!code-vb[C_DataArchitecture#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#4)]  
  
 <span data-ttu-id="50410-341">Обратите внимание, что это описание отличается от контракта односторонних операций.</span><span class="sxs-lookup"><span data-stu-id="50410-341">Note that this is different from a one-way operation contract:</span></span>  
  
 [!code-csharp[C_DataArchitecture#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#5)]
 [!code-vb[C_DataArchitecture#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#5)]  
  
 <span data-ttu-id="50410-342">В примере `SetDesiredTemperature` описывается шаблон двустороннего обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="50410-342">In the `SetDesiredTemperature` example, a two-way message exchange pattern is described.</span></span> <span data-ttu-id="50410-343">Сообщение возвращается от операции, но при этом оно пустое.</span><span class="sxs-lookup"><span data-stu-id="50410-343">A message is returned from the operation, but it is empty.</span></span> <span data-ttu-id="50410-344">От операции также можно возвратить ошибку.</span><span class="sxs-lookup"><span data-stu-id="50410-344">It is possible to return a fault from the operation.</span></span> <span data-ttu-id="50410-345">В примере "Set Lightbulb" описывается шаблон одностороннего обмена сообщениями, поэтому не требуется описание исходящего сообщения.</span><span class="sxs-lookup"><span data-stu-id="50410-345">In the "Set Lightbulb" example, the message exchange pattern is one-way, so there is no outgoing message to describe.</span></span> <span data-ttu-id="50410-346">В этом случае служба не может передать обратно клиенту какое-либо состояние.</span><span class="sxs-lookup"><span data-stu-id="50410-346">The service cannot communicate any status back to the client in this case.</span></span>  
  
### <a name="2-using-the-message-class-directly"></a><span data-ttu-id="50410-347">2. Использование класса сообщений напрямую</span><span class="sxs-lookup"><span data-stu-id="50410-347">2. Using the Message Class Directly</span></span>  
 <span data-ttu-id="50410-348">Класс <xref:System.ServiceModel.Channels.Message> (или один из его подклассов) можно использовать напрямую в контракте операций.</span><span class="sxs-lookup"><span data-stu-id="50410-348">It is possible to use the <xref:System.ServiceModel.Channels.Message> class (or one of its subclasses) directly in an operation contract.</span></span> <span data-ttu-id="50410-349">В этом случае инфраструктура службы только передает сообщение `Message` от операции стеку каналов и обратно без какой-либо дальнейшей обработки.</span><span class="sxs-lookup"><span data-stu-id="50410-349">In this case, the service framework just passes the `Message` from the operation to the channel stack and vice versa, with no further processing.</span></span>  
  
 <span data-ttu-id="50410-350">Существует два основных варианта непосредственного использования `Message` .</span><span class="sxs-lookup"><span data-stu-id="50410-350">There are two main use cases for using `Message` directly.</span></span> <span data-ttu-id="50410-351">Его можно использовать в продвинутых сценариях, если ни одна из других моделей программирования не является достаточно гибкой для описания данного сообщения.</span><span class="sxs-lookup"><span data-stu-id="50410-351">You can use this for advanced scenarios, when none of the other programming models gives you enough flexibility to describe your message.</span></span> <span data-ttu-id="50410-352">Например, для описания сообщения можно использовать файлы на диске, тогда свойства файла становятся заголовками сообщения, а его содержимое - текстом сообщения.</span><span class="sxs-lookup"><span data-stu-id="50410-352">For example, you might want to use files on disk to describe a message, with the file’s properties becoming message headers and the file’s contents becoming the message body.</span></span> <span data-ttu-id="50410-353">В этом случае можно создать что-нибудь подобное описанному ниже.</span><span class="sxs-lookup"><span data-stu-id="50410-353">You can then create something similar to the following.</span></span>  
  
 [!code-csharp[C_DataArchitecture#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#6)]
 [!code-vb[C_DataArchitecture#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#6)]  
  
 <span data-ttu-id="50410-354">Второй распространенный вариант использования `Message` в контракте операций применяется в случае, когда для службы не имеет значения содержимое конкретного сообщения, и служба рассматривает сообщение в качестве "черного ящика".</span><span class="sxs-lookup"><span data-stu-id="50410-354">The second common use for `Message` in an operation contract is when a service does not care about the particular message contents and acts on the message as on a black box.</span></span> <span data-ttu-id="50410-355">Например, имеется служба, которая пересылает сообщения нескольким другим получателям.</span><span class="sxs-lookup"><span data-stu-id="50410-355">For example, you might have a service that forwards messages to multiple other recipients.</span></span> <span data-ttu-id="50410-356">В этом случае контракт можно записать следующим образом.</span><span class="sxs-lookup"><span data-stu-id="50410-356">The contract can be written as follows.</span></span>  
  
 [!code-csharp[C_DataArchitecture#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#7)]
 [!code-vb[C_DataArchitecture#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#7)]  
  
 <span data-ttu-id="50410-357">Действие = "\*» строки эффективно отключает функцию перенаправления сообщений и гарантирует, что всех сообщений, отправленных `IForwardingService` контракта все же встречаются несущественные для `ForwardMessage` операции.</span><span class="sxs-lookup"><span data-stu-id="50410-357">The Action="\*" line effectively turns off message dispatching and ensures that all messages sent to the `IForwardingService` contract make their way to the `ForwardMessage` operation.</span></span> <span data-ttu-id="50410-358">(Как правило, диспетчер анализирует заголовок «Действие» сообщения, чтобы определить, какую операцию, он предназначен для.</span><span class="sxs-lookup"><span data-stu-id="50410-358">(Normally, the dispatcher would examine the message’s "Action" header to determine which operation it is intended for.</span></span> <span data-ttu-id="50410-359">Действие =»\*"означает «все возможные значения для заголовка действия».) Сочетание Action =»\*"и использование Message в качестве параметра называется «универсальный контракт», так как он сможет получать все возможные сообщения.</span><span class="sxs-lookup"><span data-stu-id="50410-359">Action="\*" means "all possible values of the Action header".) The combination of Action="\*" and using Message as a parameter is known as the "universal contract" because it is able to receive all possible messages.</span></span> <span data-ttu-id="50410-360">Чтобы иметь возможность отправлять все возможные сообщения, использовать Message как возвращаемое значение и задайте `ReplyAction` для "\*«.</span><span class="sxs-lookup"><span data-stu-id="50410-360">To be able to send all possible messages, use Message as the return value and set `ReplyAction` to "\*".</span></span> <span data-ttu-id="50410-361">В этом случае инфраструктура службы не сможет добавить свой собственный заголовок действия, и вы сможете управлять этим заголовком с помощью возвращаемого вами объекта `Message` .</span><span class="sxs-lookup"><span data-stu-id="50410-361">This will prevent the service framework from adding its own Action header, enabling you to control this header using the `Message` object you return.</span></span>  
  
### <a name="3-message-contracts"></a><span data-ttu-id="50410-362">3. Контракты сообщений</span><span class="sxs-lookup"><span data-stu-id="50410-362">3. Message Contracts</span></span>  
 <span data-ttu-id="50410-363">WCF предоставляет декларативную модель программирования для описания сообщений, называемую *контракты сообщений*.</span><span class="sxs-lookup"><span data-stu-id="50410-363">WCF provides a declarative programming model for describing messages, called *message contracts*.</span></span> <span data-ttu-id="50410-364">Эта модель более подробно описана в разделе [Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="50410-364">This model is described in detail in [Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md).</span></span> <span data-ttu-id="50410-365">По сути, все сообщение представляется одного типа .NET Framework, который использует атрибуты <xref:System.ServiceModel.MessageBodyMemberAttribute> и <xref:System.ServiceModel.MessageHeaderAttribute> для описания того, какие части класса контракта сообщений должны сопоставляться к какой части сообщения.</span><span class="sxs-lookup"><span data-stu-id="50410-365">Essentially, the entire message is represented by a single .NET Framework type that uses attributes like the <xref:System.ServiceModel.MessageBodyMemberAttribute> and <xref:System.ServiceModel.MessageHeaderAttribute> to describe which parts of the message contract class should map to which part of the message.</span></span>  
  
 <span data-ttu-id="50410-366">Контракты сообщений обеспечивают значительную степень управления над получаемыми экземплярами `Message` (хотя в данном случае степень управления все равно ниже, чем при непосредственном использовании класса `Message` ).</span><span class="sxs-lookup"><span data-stu-id="50410-366">Message contracts provide a lot of control over the resulting `Message` instances (although obviously not as much control as using the `Message` class directly).</span></span> <span data-ttu-id="50410-367">Например, тела сообщений часто состоят из многочисленных элементов данных, каждый из которых представлен собственным XML-элементом.</span><span class="sxs-lookup"><span data-stu-id="50410-367">For example, message bodies are often composed of multiple pieces of information, each represented by its own XML element.</span></span> <span data-ttu-id="50410-368">Эти элементы могут встречаться непосредственно в теле сообщения (режим*bare* ) или помещаться в *программу-оболочку* содержащегося в теле XML-элемента.</span><span class="sxs-lookup"><span data-stu-id="50410-368">These elements can either occur directly in the body (*bare* mode) or can be *wrapped* in an encompassing XML element.</span></span> <span data-ttu-id="50410-369">Использование модели программирования контракта сообщений позволяет выбирать способ представления элементов (в режиме "bare" или в программе-оболочке) и управлять именем программы-оболочки и пространством имен.</span><span class="sxs-lookup"><span data-stu-id="50410-369">Using the message contract programming model enables you to make the bare-versus-wrapped decision and control the name of the wrapper name and namespace.</span></span>  
  
 <span data-ttu-id="50410-370">В следующем примере кода контракта сообщений проиллюстрированы эти возможности.</span><span class="sxs-lookup"><span data-stu-id="50410-370">The following code example of a message contract demonstrates these features.</span></span>  
  
 [!code-csharp[C_DataArchitecture#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#9)]
 [!code-vb[C_DataArchitecture#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#9)]  
  
 <span data-ttu-id="50410-371">Элементы, отмеченные для сериализации (с атрибутами <xref:System.ServiceModel.MessageBodyMemberAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>или любыми другими связанными атрибутами), должны быть сериализуемыми, иначе они не могут находиться в контракте сообщения.</span><span class="sxs-lookup"><span data-stu-id="50410-371">Items marked to be serialized (with the <xref:System.ServiceModel.MessageBodyMemberAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, or other related attributes) must be serializable to participate in a message contract.</span></span> <span data-ttu-id="50410-372">Дополнительные сведения см. в разделе «Сериализация» далее в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="50410-372">For more information, see the "Serialization" section later in this topic.</span></span>  
  
### <a name="4-parameters"></a><span data-ttu-id="50410-373">4. Параметры</span><span class="sxs-lookup"><span data-stu-id="50410-373">4. Parameters</span></span>  
 <span data-ttu-id="50410-374">Часто для описания операции с несколькими элементами данных разработчику не требуется тот высокий уровень управления, который обеспечивается контрактами сообщений.</span><span class="sxs-lookup"><span data-stu-id="50410-374">Often, a developer who wants to describe an operation that acts on multiple pieces of data does not need the degree of control that message contracts provide.</span></span> <span data-ttu-id="50410-375">Например, при создании новых служб, как правило, не приходится принимать решение о способе представления элементов (в режиме "bare" или в программе-оболочке) и выбирать имя программы-оболочки.</span><span class="sxs-lookup"><span data-stu-id="50410-375">For example, when creating new services, one does not usually want to make the bare-versus-wrapped decision and decide on the wrapper element name.</span></span> <span data-ttu-id="50410-376">Зачастую для принятия таких решений необходимы глубокие знания о функционировании веб-служб и протокола SOAP.</span><span class="sxs-lookup"><span data-stu-id="50410-376">Making these decisions often requires deep knowledge of Web services and SOAP.</span></span>  
  
 <span data-ttu-id="50410-377">Инфраструктура службы WCF могут автоматически получать лучшие и наиболее широкими возможностями взаимодействия SOAP-представление для отправки или получения нескольких связанных частей данных, не заставляя эти параметры необходимо настроить для пользователя.</span><span class="sxs-lookup"><span data-stu-id="50410-377">The WCF service framework can automatically pick the best and most interoperable SOAP representation for sending or receiving multiple related pieces of information, without forcing these choices on the user.</span></span> <span data-ttu-id="50410-378">Это возможно благодаря тому, что данные элементы данных описаны как параметры или возвращаемые значения контракта операций.</span><span class="sxs-lookup"><span data-stu-id="50410-378">This is accomplished by simply describing these pieces of information as parameters or return values of an operation contract.</span></span> <span data-ttu-id="50410-379">Например, рассмотрим следующий контракт операций.</span><span class="sxs-lookup"><span data-stu-id="50410-379">For example, consider the following operation contract.</span></span>  
  
 [!code-csharp[C_DataArchitecture#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#11)]
 [!code-vb[C_DataArchitecture#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#11)]  
  
 <span data-ttu-id="50410-380">Инфраструктура службы автоматически принимает решение о размещении всех трех элементов данных (`customerID`, `item`и `quantity`) в теле сообщения и помещении их в программу-оболочку с именем `SubmitOrderRequest`.</span><span class="sxs-lookup"><span data-stu-id="50410-380">The service framework automatically decides to put all three pieces of information (`customerID`, `item`, and `quantity`) into the message body and wrap them in a wrapper element named `SubmitOrderRequest`.</span></span>  
  
 <span data-ttu-id="50410-381">Рекомендуется описывать информацию, которую необходимо отправить или получить, в виде простого списка параметров контракта операций, если, конечно, не имеется особых причин, вынуждающих перейти к использованию более сложного контракта сообщений или моделей программирования на основе `Message`.</span><span class="sxs-lookup"><span data-stu-id="50410-381">Describing the information to be sent or received as a simple list of operation contract parameters is the recommended approach, unless special reasons exist to move to the more-complex message contract or `Message`-based programming models.</span></span>  
  
### <a name="5-stream"></a><span data-ttu-id="50410-382">5. Поток</span><span class="sxs-lookup"><span data-stu-id="50410-382">5. Stream</span></span>  
 <span data-ttu-id="50410-383">Использование потока `Stream` или одного из его подклассов в контракте операций либо в качестве единственной части тела сообщения в контракте сообщений может считаться отдельной моделью программирования, которая отличается от описанных выше моделей.</span><span class="sxs-lookup"><span data-stu-id="50410-383">Using `Stream` or one of its subclasses in an operation contract or as a sole message body part in a message contract can be considered a separate programming model from the ones described above.</span></span> <span data-ttu-id="50410-384">Только использование `Stream` подобным образом гарантирует возможность использования контракта в потоковом режиме; во всех остальных случаях необходимо самостоятельно создавать подкласс `Message` , совместимый с потоковым режимом.</span><span class="sxs-lookup"><span data-stu-id="50410-384">Using `Stream` in this way is the only way to guarantee that your contract will be usable in a streamed fashion, short of writing your own streaming-compatible `Message` subclass.</span></span> <span data-ttu-id="50410-385">Дополнительные сведения см. в разделе [большие наборы данных и потоковая передача](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md).</span><span class="sxs-lookup"><span data-stu-id="50410-385">For more information, see [Large Data and Streaming](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md).</span></span>  
  
 <span data-ttu-id="50410-386">При использовании `Stream` или одного из его подклассов таким образом сериализатор не вызывается.</span><span class="sxs-lookup"><span data-stu-id="50410-386">When `Stream` or one of its subclasses is used in this way, the serializer is not invoked.</span></span> <span data-ttu-id="50410-387">Для исходящих сообщений создается специальный потоковый подкласс `Message` , а поток записывается в интерфейсе <xref:System.Xml.IStreamProvider> описанным в данном разделе способом.</span><span class="sxs-lookup"><span data-stu-id="50410-387">For outgoing messages, a special streaming `Message` subclass is created and the stream is written out as described in the section on the <xref:System.Xml.IStreamProvider> interface.</span></span> <span data-ttu-id="50410-388">Для входящих сообщений инфраструктура службы создает подкласс `Stream` над входящими сообщениями и предоставляет этот подкласс операции.</span><span class="sxs-lookup"><span data-stu-id="50410-388">For incoming messages, the service framework creates a `Stream` subclass over the incoming message and provides it to the operation.</span></span>  
  
## <a name="programming-model-restrictions"></a><span data-ttu-id="50410-389">Ограничения модели программирования</span><span class="sxs-lookup"><span data-stu-id="50410-389">Programming Model Restrictions</span></span>  
 <span data-ttu-id="50410-390">Вышеописанные модели программирования нельзя сочетать произвольно.</span><span class="sxs-lookup"><span data-stu-id="50410-390">The programming models described above cannot be arbitrarily combined.</span></span> <span data-ttu-id="50410-391">Например, если операция принимает определенный тип контракта сообщений, этот контракт сообщений должен стать единственным входным параметром операции.</span><span class="sxs-lookup"><span data-stu-id="50410-391">For example, if an operation accepts a message contract type, the message contract must be its only input parameter.</span></span> <span data-ttu-id="50410-392">Более того, после этого операция должна вернуть либо пустое сообщение (возвращаемый тип "void"), либо другой контракт сообщений.</span><span class="sxs-lookup"><span data-stu-id="50410-392">Furthermore, the operation must then either return an empty message (return type of void) or another message contract.</span></span> <span data-ttu-id="50410-393">Эти ограничения моделей программирования описаны в разделах по каждой конкретной модели программирования: [Использование контрактов сообщений](../../../../docs/framework/wcf/feature-details/using-message-contracts.md), [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md), и [большие наборы данных и потоковой передачи](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md).</span><span class="sxs-lookup"><span data-stu-id="50410-393">These programming model restrictions are described in the topics for each specific programming model: [Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md), [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md), and [Large Data and Streaming](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md).</span></span>  
  
## <a name="message-formatters"></a><span data-ttu-id="50410-394">Модули форматирования сообщений</span><span class="sxs-lookup"><span data-stu-id="50410-394">Message Formatters</span></span>  
 <span data-ttu-id="50410-395">Описанные выше модели программирования поддерживаются подключением компонентов под названием *модули форматирования сообщений* в инфраструктуру службы.</span><span class="sxs-lookup"><span data-stu-id="50410-395">The programming models described above are supported by plugging in components called *message formatters* into the service framework.</span></span> <span data-ttu-id="50410-396">Модули форматирования сообщений представляют собой типы, реализующие <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> или <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> интерфейс (или оба) для использования в клиентах и клиентах службы WCF, соответственно.</span><span class="sxs-lookup"><span data-stu-id="50410-396">Message formatters are types that implement the <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> or <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> interface, or both, for use in clients and service WCF clients, respectively.</span></span>  
  
 <span data-ttu-id="50410-397">Как правило, модули форматирования сообщений подключаются поведениями.</span><span class="sxs-lookup"><span data-stu-id="50410-397">Message formatters are normally plugged in by behaviors.</span></span> <span data-ttu-id="50410-398">Например, поведение <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> подключает модуль форматирования сообщений контракта данных.</span><span class="sxs-lookup"><span data-stu-id="50410-398">For example, the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> plugs in the data contract message formatter.</span></span> <span data-ttu-id="50410-399">На стороне службы это достигается благодаря установке <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> на соответствующий модуль форматирования в методе <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> , а на стороне клиента - благодаря установке <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> на соответствующий модуль форматирования в методе <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> .</span><span class="sxs-lookup"><span data-stu-id="50410-399">This is done on the service side by setting <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> method, or on the client side by setting <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> method.</span></span>  
  
 <span data-ttu-id="50410-400">В таблице ниже приведены методы, которые могут реализовываться модулем форматирования сообщений.</span><span class="sxs-lookup"><span data-stu-id="50410-400">The following tables lists the methods that a message formatter may implement.</span></span>  
  
|<span data-ttu-id="50410-401">Интерфейс</span><span class="sxs-lookup"><span data-stu-id="50410-401">Interface</span></span>|<span data-ttu-id="50410-402">Метод</span><span class="sxs-lookup"><span data-stu-id="50410-402">Method</span></span>|<span data-ttu-id="50410-403">Действие</span><span class="sxs-lookup"><span data-stu-id="50410-403">Action</span></span>|  
|---------------|------------|------------|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.DeserializeRequest%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|<span data-ttu-id="50410-404">преобразует входящее сообщение `Message` в параметры операции</span><span class="sxs-lookup"><span data-stu-id="50410-404">Converts an incoming `Message` to operation parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.SerializeReply%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%2CSystem.Object%29>|<span data-ttu-id="50410-405">создает исходящее сообщение `Message` из возвращаемого значения/выходных параметров операции</span><span class="sxs-lookup"><span data-stu-id="50410-405">Creates an outgoing `Message` from operation return value/out parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.SerializeRequest%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%29>|<span data-ttu-id="50410-406">создает исходящее сообщение `Message` из параметров операции</span><span class="sxs-lookup"><span data-stu-id="50410-406">Creates an outgoing `Message` from operation parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.DeserializeReply%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|<span data-ttu-id="50410-407">преобразует входящее сообщение `Message` в возвращаемое значение/выходные параметры</span><span class="sxs-lookup"><span data-stu-id="50410-407">Converts an incoming `Message` to a return value/out parameters</span></span>|  
  
## <a name="serialization"></a><span data-ttu-id="50410-408">Сериализация</span><span class="sxs-lookup"><span data-stu-id="50410-408">Serialization</span></span>  
 <span data-ttu-id="50410-409">При использовании контрактов сообщений или параметров для описания содержимого сообщений необходимо использовать сериализацию для преобразования между типами .NET Framework и набора сведений XML-представление.</span><span class="sxs-lookup"><span data-stu-id="50410-409">Whenever you use message contracts or parameters to describe message contents, you must use serialization to convert between .NET Framework types and XML Infoset representation.</span></span> <span data-ttu-id="50410-410">Сериализация используется в других местах в WCF, например, <xref:System.ServiceModel.Channels.Message> содержит универсальный <xref:System.ServiceModel.Channels.Message.GetBody%2A> метод, который можно использовать для прочтения всего тела сообщения, десериализованного в объект.</span><span class="sxs-lookup"><span data-stu-id="50410-410">Serialization is used in other places in WCF, for example, <xref:System.ServiceModel.Channels.Message> has a Generic <xref:System.ServiceModel.Channels.Message.GetBody%2A> method that you can use to read the entire body of the message deserialized into an object.</span></span>  
  
 <span data-ttu-id="50410-411">WCF поддерживает две технологии сериализации «стандартной» для сериализации и десериализации параметров и частей сообщений: <xref:System.Runtime.Serialization.DataContractSerializer> и `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="50410-411">WCF supports two serialization technologies "out of the box" for serializing and deserializing parameters and message parts: the <xref:System.Runtime.Serialization.DataContractSerializer> and the `XmlSerializer`.</span></span> <span data-ttu-id="50410-412">Более того, можно создать настраиваемые сериализаторы.</span><span class="sxs-lookup"><span data-stu-id="50410-412">Additionally, you can write custom serializers.</span></span> <span data-ttu-id="50410-413">Тем не менее другие части WCF (например, универсальный `GetBody` сериализация ошибок метод или SOAP) может быть ограничен для использования только <xref:System.Runtime.Serialization.XmlObjectSerializer> подклассы (<xref:System.Runtime.Serialization.DataContractSerializer> и <xref:System.Runtime.Serialization.NetDataContractSerializer>, но не <xref:System.Xml.Serialization.XmlSerializer>), или даже может быть жестко запрограммированы для использования только <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="50410-413">However, other parts of WCF (such as the Generic `GetBody` method or SOAP fault serialization) may be restricted to use only the <xref:System.Runtime.Serialization.XmlObjectSerializer> subclasses (<xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>, but not the <xref:System.Xml.Serialization.XmlSerializer>), or may even be hard-coded to use only the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span>  
  
 <span data-ttu-id="50410-414">`XmlSerializer` представляет собой модуль сериализации, используемый в веб-службах [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="50410-414">The `XmlSerializer` is the serialization engine used in [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] Web services.</span></span> <span data-ttu-id="50410-415">Новый модуль сериализации `DataContractSerializer` , совместимый с новой моделью программирования на основе контрактов данных.</span><span class="sxs-lookup"><span data-stu-id="50410-415">The `DataContractSerializer` is the new serialization engine that understands the new data contract programming model.</span></span> <span data-ttu-id="50410-416">`DataContractSerializer` выбирается по умолчанию, однако можно выбрать `XmlSerializer` для отдельных операций с помощью атрибута <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> .</span><span class="sxs-lookup"><span data-stu-id="50410-416">`DataContractSerializer` is the default choice, and the choice to use the `XmlSerializer` can be made on a per-operation basis using the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> attribute.</span></span>  
  
 <span data-ttu-id="50410-417"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> и <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> - это поведения операции, ответственные за подключение модулей форматирования сообщений для `DataContractSerializer` и `XmlSerializer`соответственно.</span><span class="sxs-lookup"><span data-stu-id="50410-417"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> and <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> are the operation behaviors responsible for plugging in the message formatters for the `DataContractSerializer` and the `XmlSerializer`, respectively.</span></span> <span data-ttu-id="50410-418">Фактически, поведение <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> может работать с любым сериализатором, наследуемым от <xref:System.Runtime.Serialization.XmlObjectSerializer>, включая <xref:System.Runtime.Serialization.NetDataContractSerializer> (подробное описание см. в разделе "Использование автономной сериализации").</span><span class="sxs-lookup"><span data-stu-id="50410-418">The <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> behavior can actually operate with any serializer that derives from <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.NetDataContractSerializer> (described in detail in Using Stand-Alone Serialization).</span></span> <span data-ttu-id="50410-419">Поведение вызывает одну из перегрузок виртуального метода `CreateSerializer` для получения сериализатора.</span><span class="sxs-lookup"><span data-stu-id="50410-419">The behavior calls one of the `CreateSerializer` virtual method overloads to obtain the serializer.</span></span> <span data-ttu-id="50410-420">Для подключения иного сериализатора необходимо создать новый подкласс <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> и переопределить обе перегрузки метода `CreateSerializer` .</span><span class="sxs-lookup"><span data-stu-id="50410-420">To plug in a different serializer, create a new <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> subclass and override both `CreateSerializer` overloads.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="50410-421">См. также</span><span class="sxs-lookup"><span data-stu-id="50410-421">See also</span></span>

- [<span data-ttu-id="50410-422">Задание передачи данных в контрактах служб</span><span class="sxs-lookup"><span data-stu-id="50410-422">Specifying Data Transfer in Service Contracts</span></span>](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)
