---
title: Типы коллекций в контрактах данных
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- collection types [WCF], data contracts
- data contracts [WCF], collection types
- collection types [WCF]
ms.assetid: 9b45b28e-0a82-4ea3-8c33-ec0094aff9d5
ms.openlocfilehash: 810238ee631808dac472456f910eb52f8bbf550c
ms.sourcegitcommit: 30a83efb57c468da74e9e218de26cf88d3254597
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/20/2019
ms.locfileid: "68363813"
---
# <a name="collection-types-in-data-contracts"></a><span data-ttu-id="c9a2b-102">Типы коллекций в контрактах данных</span><span class="sxs-lookup"><span data-stu-id="c9a2b-102">Collection Types in Data Contracts</span></span>

<span data-ttu-id="c9a2b-103">Под *коллекцией* понимается список элементов определенного типа.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-103">A *collection* is a list of items of a certain type.</span></span> <span data-ttu-id="c9a2b-104">В .NET Framework такие списки можно представить с помощью массивов или различных типов (универсальный список, универсальный <xref:System.ComponentModel.BindingList%601>тип, <xref:System.Collections.Specialized.StringCollection>или <xref:System.Collections.ArrayList>).</span><span class="sxs-lookup"><span data-stu-id="c9a2b-104">In the .NET Framework, such lists can be represented using arrays or a variety of other types (Generic List, Generic <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, or <xref:System.Collections.ArrayList>).</span></span> <span data-ttu-id="c9a2b-105">Например, в коллекции может содержаться список адресов конкретного клиента.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-105">For example, a collection may hold a list of Addresses for a given Customer.</span></span> <span data-ttu-id="c9a2b-106">Такие коллекции называются *коллекциями списков*, независимо от их фактического типа.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-106">These collections are called *list collections*, regardless of their actual type.</span></span>

<span data-ttu-id="c9a2b-107">Существует специальная форма коллекции, которая представляет собой сопоставление одного элемента ("ключа") другому ("значению").</span><span class="sxs-lookup"><span data-stu-id="c9a2b-107">A special form of collection exists that represents an association between one item (the "key") and another (the "value").</span></span> <span data-ttu-id="c9a2b-108">В .NET Framework они представлены типами, такими как <xref:System.Collections.Hashtable> и универсальный словарь.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-108">In the .NET Framework, these are represented by types such as <xref:System.Collections.Hashtable> and the generic dictionary.</span></span> <span data-ttu-id="c9a2b-109">Например, в коллекции сопоставлений город ("ключ") может быть сопоставлен его населению ("значению").</span><span class="sxs-lookup"><span data-stu-id="c9a2b-109">For example, an association collection may map a city ("key") to its population ("value").</span></span> <span data-ttu-id="c9a2b-110">Такие коллекции называются *коллекциями-словарями*, независимо от их фактического типа.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-110">These collections are called *dictionary collections*, regardless of their actual type.</span></span>

<span data-ttu-id="c9a2b-111">Коллекции подвергаются специальной обработке в модели контракта данных.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-111">Collections receive special treatment in the data contract model.</span></span>

<span data-ttu-id="c9a2b-112">Типы, реализующие интерфейс <xref:System.Collections.IEnumerable> , включая массивы и универсальные коллекции, распознаются как коллекции.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-112">Types that implement the <xref:System.Collections.IEnumerable> interface, including arrays and generic collections, are recognized as collections.</span></span> <span data-ttu-id="c9a2b-113">Те из них, которые реализуют интерфейс <xref:System.Collections.IDictionary> или универсальный интерфейс <xref:System.Collections.Generic.IDictionary%602> , относятся к коллекциям-словарям; все остальные относятся к коллекциям списков.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-113">Of those, types that implement the <xref:System.Collections.IDictionary> or Generic <xref:System.Collections.Generic.IDictionary%602> interfaces are dictionary collections; all others are list collections.</span></span>

<span data-ttu-id="c9a2b-114">Дополнительные требования к типам коллекций, например наличие метода с именем `Add` и конструктора без параметров, подробно описаны в следующих разделах.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-114">Additional requirements on collection types, such as having a method called `Add` and a parameterless constructor, are discussed in detail in the following sections.</span></span> <span data-ttu-id="c9a2b-115">Этим обеспечивается возможность как сериализации, так и десериализации таких типов коллекций.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-115">This ensures that collection types can be both serialized and deserialized.</span></span> <span data-ttu-id="c9a2b-116">Это означает, что некоторые коллекции не поддерживаются напрямую, например универсальный <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (поскольку в нем нет конструктора без параметров).</span><span class="sxs-lookup"><span data-stu-id="c9a2b-116">This means that some collections are not directly supported, such as the Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (because it has no parameterless constructor).</span></span> <span data-ttu-id="c9a2b-117">Тем не менее, информацию о том, как обойти эти ограничения, см. далее в разделе «Использование типов интерфейса и коллекций только для чтения».</span><span class="sxs-lookup"><span data-stu-id="c9a2b-117">However, for information about circumventing these restrictions, see the section "Using Collection Interface Types and Read-Only Collections" later in this topic.</span></span>

<span data-ttu-id="c9a2b-118">Типы, содержащиеся в коллекциях, должны быть контрактными данными, либо сериализуемые другим способом.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-118">The types contained in collections must be data contract types, or be otherwise serializable.</span></span> <span data-ttu-id="c9a2b-119">Дополнительные сведения см. [в разделе Типы, поддерживаемые сериализатором контрактов данных](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="c9a2b-119">For more information, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span>

<span data-ttu-id="c9a2b-120">Дополнительные сведения о том, что такое и что не считается допустимой коллекцией, а также о том, как сериализуются коллекции, см. в разделе "Сериализация коллекций" раздела "дополнительные правила коллекции" этого раздела.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-120">For more information about what is and what is not considered a valid collection, as well as about how collections are serialized, see the information about serializing collections in the "Advanced Collection Rules" section of this topic.</span></span>

## <a name="interchangeable-collections"></a><span data-ttu-id="c9a2b-121">Взаимозаменяемые коллекции</span><span class="sxs-lookup"><span data-stu-id="c9a2b-121">Interchangeable Collections</span></span>

<span data-ttu-id="c9a2b-122">Считается, что все коллекции-списки одного типа имеют одинаковый контракт данных (кроме случая, когда они создаются пользователем с помощью атрибута <xref:System.Runtime.Serialization.CollectionDataContractAttribute> как будет описано ниже в статье).</span><span class="sxs-lookup"><span data-stu-id="c9a2b-122">All list collections of the same type are considered to have the same data contract (unless they are customized using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, as discussed later in this topic).</span></span> <span data-ttu-id="c9a2b-123">Таким образом, указанные ниже контракты данных являются эквивалентными.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-123">Thus, for example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#0](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#0)]
[!code-vb[c_collection_types_in_data_contracts#0](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#0)]

<span data-ttu-id="c9a2b-124">В итоге, от обоих контрактов данных получается код XML, подобный приведенному ниже.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-124">Both data contracts result in XML similar to the following code.</span></span>

```xml
<PurchaseOrder>
    <customerName>...</customerName>
    <items>
        <Item>...</Item>
        <Item>...</Item>
        <Item>...</Item>
        ...
    </items>
    <comments>
        <string>...</string>
        <string>...</string>
        <string>...</string>
        ...
    </comments>
</PurchaseOrder>
```

<span data-ttu-id="c9a2b-125">Взаимозаменяемость коллекций позволяет, например, использовать тип коллекции, оптимизированный для производительности, на сервере, а тип коллекции, предназначенный для привязки к компонентам пользовательского интерфейса - на клиенте.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-125">Collection interchangeability allows you to use, for example, a collection type optimized for performance on the server and a collection type designed to be bound to user interface components on the client.</span></span>

<span data-ttu-id="c9a2b-126">Подобно коллекциям списков, все коллекции-словари, имеющие одинаковые ключи и типы значений, рассматриваются как имеющие одинаковый контракт данных (кроме случаев настройки с помощью атрибута <xref:System.Runtime.Serialization.CollectionDataContractAttribute> ).</span><span class="sxs-lookup"><span data-stu-id="c9a2b-126">Similar to list collections, all dictionary collections that have the same key and value types are considered to have the same data contract (unless customized by the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute).</span></span>

<span data-ttu-id="c9a2b-127">Поскольку рассматривается эквивалентность коллекции, значение имеет только тип контракта данных, а не типы .NET.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-127">Only the data contract type matters as far as collection equivalence is concerned, not .NET types.</span></span> <span data-ttu-id="c9a2b-128">То есть, коллекция типа1 считается эквивалентной коллекции типа2, если тип1 и тип2 имеют эквивалентные контракты данных.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-128">That is, a collection of Type1 is considered equivalent to a collection of Type2 if Type1 and Type2 have equivalent data contracts.</span></span>

<span data-ttu-id="c9a2b-129">Считается, что неуниверсальные коллекции имеют тот же контракт данных, что и универсальные коллекции типа `Object`.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-129">Non-generic collections are considered to have the same data contract as generic collections of type `Object`.</span></span> <span data-ttu-id="c9a2b-130">(Например, контракты данных для <xref:System.Collections.ArrayList> и универсального <xref:System.Collections.Generic.List%601>					`Object` являются одинаковыми.)</span><span class="sxs-lookup"><span data-stu-id="c9a2b-130">(For example, the data contracts for <xref:System.Collections.ArrayList> and Generic <xref:System.Collections.Generic.List%601> of `Object` are the same.)</span></span>

## <a name="using-collection-interface-types-and-read-only-collections"></a><span data-ttu-id="c9a2b-131">Использование типов интерфейса коллекции и коллекций только для чтения</span><span class="sxs-lookup"><span data-stu-id="c9a2b-131">Using Collection Interface Types and Read-Only Collections</span></span>

<span data-ttu-id="c9a2b-132">Типы интерфейсов коллекции (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, универсальный <xref:System.Collections.Generic.IDictionary%602>или интерфейсы, наследованные от данных интерфейсов) также считаются интерфейсам, имеющими контракты данных коллекций, эквивалентные контрактам данных коллекций текущих типов коллекций.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-132">Collection interface types (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, generic <xref:System.Collections.Generic.IDictionary%602>, or interfaces derived from these interfaces) are also considered as having collection data contracts, equivalent to collection data contracts for actual collection types.</span></span> <span data-ttu-id="c9a2b-133">Таким образом, можно объявить сериализуемый тип как тип коллекции интерфейса, и результаты будут такими же, как если бы использовался текущий тип коллекции.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-133">Thus, it is possible to declare the type being serialized as a collection interface type and the results are the same as if an actual collection type had been used.</span></span> <span data-ttu-id="c9a2b-134">Например, указанные ниже контракты данных эквивалентны.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-134">For example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#1)]
[!code-vb[c_collection_types_in_data_contracts#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#1)]

<span data-ttu-id="c9a2b-135">Во время сериализации, если объявленный тип является интерфейсом, текущий используемый тип экземпляра может быть любым типом, реализующим этот интерфейс.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-135">During serialization, when the declared type is an interface, the actual instance type used can be any type that implements that interface.</span></span> <span data-ttu-id="c9a2b-136">Описанные выше ограничения (наличие конструктора без параметров и `Add` метода) не применяются.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-136">Restrictions discussed previously (having a parameterless constructor and an `Add` method) do not apply.</span></span> <span data-ttu-id="c9a2b-137">Например, можно задать адреса в Customer2 в экземпляре универсального <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> значения Address, даже несмотря на то что непосредственно объявить элемент данных универсального класса <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>невозможно.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-137">For example, you can set addresses in Customer2 to an instance of Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> of Address, even though you cannot directly declare a data member of type Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span></span>

<span data-ttu-id="c9a2b-138">Во время десериализации, если объявленный тип является интерфейсом, ядро сериализации выбирает тип, который реализует объявленный интерфейс, и создается экземпляр типа.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-138">During deserialization, when the declared type is an interface, the serialization engine chooses a type that implements the declared interface, and the type is instantiated.</span></span> <span data-ttu-id="c9a2b-139">Механизм известных типов (описанный в разделе « [известные типы контрактов данных](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)») не оказывает никакого влияния; выбранный тип встроен в WCF.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-139">The known types mechanism (described in [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)) has no effect here; the choice of type is built into WCF.</span></span>

## <a name="customizing-collection-types"></a><span data-ttu-id="c9a2b-140">Настройка типов коллекции</span><span class="sxs-lookup"><span data-stu-id="c9a2b-140">Customizing Collection Types</span></span>

<span data-ttu-id="c9a2b-141">Настройка типов коллекции может быть выполнена с помощью атрибута <xref:System.Runtime.Serialization.CollectionDataContractAttribute> , имеющего несколько вариантов использования.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-141">You can customize collection types by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, which has several uses.</span></span>

<span data-ttu-id="c9a2b-142">Обратите внимание, что настройка типов коллекции отрицательно влияет на взаимозаменяемость коллекции, т. е. обычно рекомендуется избегать использования данного атрибута.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-142">Note that customizing collection types compromises collection interchangeability, so it is generally recommended to avoid applying this attribute whenever possible.</span></span> <span data-ttu-id="c9a2b-143">Дополнительные сведения об этой ошибке см. в подразделе "дополнительные правила коллекции" Далее в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-143">For more information about this issue, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="collection-data-contract-naming"></a><span data-ttu-id="c9a2b-144">Именование контракта данных коллекции</span><span class="sxs-lookup"><span data-stu-id="c9a2b-144">Collection Data Contract Naming</span></span>

<span data-ttu-id="c9a2b-145">Правила именования типов коллекций подобны правилам именования обычных типов контракта данных, как описано в разделе [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md). Однако есть некоторые различия.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-145">The rules for naming collection types are similar to those for naming regular data contract types, as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md), although some important differences exist:</span></span>

- <span data-ttu-id="c9a2b-146">Для пользовательского имени вместо атрибута <xref:System.Runtime.Serialization.CollectionDataContractAttribute> используется атрибут <xref:System.Runtime.Serialization.DataContractAttribute> .</span><span class="sxs-lookup"><span data-stu-id="c9a2b-146">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is used to customize the name, instead of the <xref:System.Runtime.Serialization.DataContractAttribute> attribute.</span></span> <span data-ttu-id="c9a2b-147">Атрибут <xref:System.Runtime.Serialization.CollectionDataContractAttribute> также имеет свойства `Name` и `Namespace` .</span><span class="sxs-lookup"><span data-stu-id="c9a2b-147">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute also has `Name` and `Namespace` properties.</span></span>

- <span data-ttu-id="c9a2b-148">Если атрибут <xref:System.Runtime.Serialization.CollectionDataContractAttribute> не применяется, имя по умолчанию и пространство имен типов коллекций зависит от имен и пространств имен типов, входящих в коллекцию.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-148">When the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is not applied, the default name and namespace for collection types depend on the names and namespaces of types contained within the collection.</span></span> <span data-ttu-id="c9a2b-149">На них не влияют имя и пространство имен самого типа коллекции.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-149">They are not affected by the name and namespace of the collection type itself.</span></span> <span data-ttu-id="c9a2b-150">Например, см. следующие типы.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-150">For an example, see the following types.</span></span>

  ```csharp
  public CustomerList1 : Collection<string> {}
  public StringList1 : Collection<string> {}
  ```

<span data-ttu-id="c9a2b-151">Имя контракта данных обоих типов "ArrayOfstring", а не "CustomerList1" или "StringList1".</span><span class="sxs-lookup"><span data-stu-id="c9a2b-151">Both types’ data contract name is "ArrayOfstring" and not "CustomerList1" or "StringList1".</span></span> <span data-ttu-id="c9a2b-152">Это значит, что при сериализации любого из данных типов на корневом уровне будет получен код XML, подобный приведенному ниже.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-152">This means that serializing any one of these types at the root level yields XML similar to the following code.</span></span>

```xml
<ArrayOfstring>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</ArrayOfstring>
```

<span data-ttu-id="c9a2b-153">Правило именования выбрано таким образом, чтобы любой не настроенный пользователем тип, являющийся списком строк, имел одинаковый контракт данных и представление XML.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-153">This naming rule was chosen to ensure that any non-customized type that represents a list of strings has the same data contract and XML representation.</span></span> <span data-ttu-id="c9a2b-154">Это делает возможной взаимозаменяемость коллекции.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-154">This makes collection interchangeability possible.</span></span> <span data-ttu-id="c9a2b-155">В данном примере CustomerList1 и StringList1 полностью взаимозаменяемы.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-155">In this example, CustomerList1 and StringList1 are completely interchangeable.</span></span>

<span data-ttu-id="c9a2b-156">Однако при применении атрибута <xref:System.Runtime.Serialization.CollectionDataContractAttribute> коллекция становится настроенным пользователем контрактом данных коллекции, даже если к атрибуту не применяются свойства.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-156">However, when the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is applied, the collection becomes a customized collection data contract, even if no properties are set on the attribute.</span></span> <span data-ttu-id="c9a2b-157">Теперь имя и пространство имен контракта данных коллекции зависят от типа самой коллекции.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-157">The name and namespace of the collection data contract then depend on the collection type itself.</span></span> <span data-ttu-id="c9a2b-158">Например, см. следующий тип.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-158">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#2)]
[!code-vb[c_collection_types_in_data_contracts#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#2)]

<span data-ttu-id="c9a2b-159">При сериализации получаемый код XML подобен приведенному ниже.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-159">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CustomerList2>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</CustomerList2>
```

<span data-ttu-id="c9a2b-160">Необходимо обратить внимание, что полученный XML уже не эквивалентен XML-представлению ненастроенных типов.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-160">Notice that this is no longer equivalent to the XML representation of the non-customized types.</span></span>

- <span data-ttu-id="c9a2b-161">Для дополнительной настройки можно использовать свойства `Name` и `Namespace` .</span><span class="sxs-lookup"><span data-stu-id="c9a2b-161">You can use the `Name` and `Namespace` properties to further customize the naming.</span></span> <span data-ttu-id="c9a2b-162">См. приведенный ниже класс.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-162">See the following class.</span></span>

  [!code-csharp[c_collection_types_in_data_contracts#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#3)]
  [!code-vb[c_collection_types_in_data_contracts#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#3)]

<span data-ttu-id="c9a2b-163">Получаемый код XML подобен приведенному ниже.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-163">The resulting XML is similar to the following.</span></span>

```xml
<cust_list>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</cust_list>
```

<span data-ttu-id="c9a2b-164">Дополнительные сведения см. в подразделе «Дополнительные правила коллекции» далее в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-164">For more information, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="customizing-the-repeating-element-name-in-list-collections"></a><span data-ttu-id="c9a2b-165">Настройка имени повторяющегося элемента в коллекциях списков</span><span class="sxs-lookup"><span data-stu-id="c9a2b-165">Customizing the Repeating Element Name in List Collections</span></span>

<span data-ttu-id="c9a2b-166">Коллекции списков содержат повторяющиеся записи.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-166">List collections contain repeating entries.</span></span> <span data-ttu-id="c9a2b-167">Обычно каждая повторяющаяся запись представляется как элемент с именем, соответствующим имени контракта данных типа, содержащегося в коллекции.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-167">Normally, each repeating entry is represented as an element named according to the data contract name of the type contained in the collection.</span></span>

<span data-ttu-id="c9a2b-168">В примерах `CustomerList` коллекции содержали строки.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-168">In the `CustomerList` examples, the collections contained strings.</span></span> <span data-ttu-id="c9a2b-169">Имя контракта данных для строкового примитивного типа — String, поэтому повторяющийся элемент был "\<String >".</span><span class="sxs-lookup"><span data-stu-id="c9a2b-169">The data contract name for the string primitive type is "string", so the repeating element was "\<string>".</span></span>

<span data-ttu-id="c9a2b-170">Однако при применении свойства <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> к атрибуту <xref:System.Runtime.Serialization.CollectionDataContractAttribute> данное имя повторяющегося элемента может быть настроено.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-170">However, using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property on the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, this repeating element name can be customized.</span></span> <span data-ttu-id="c9a2b-171">Например, см. следующий тип.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-171">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#4)]
[!code-vb[c_collection_types_in_data_contracts#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#4)]

<span data-ttu-id="c9a2b-172">Получаемый код XML подобен приведенному ниже.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-172">The resulting XML is similar to the following.</span></span>

```xml
<CustomerList4>
    <customer>...</customer>
    <customer>...</customer>
    <customer>...</customer>
    ...
</CustomerList4>
```

<span data-ttu-id="c9a2b-173">Пространство имен повторяющегося элемента всегда такое же, как пространство имен коллекции контракта данных, которое может быть настроено с помощью свойства `Namespace` , как было описано выше.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-173">The namespace of the repeating element is always the same as the namespace of the collection data contract, which can be customized using the `Namespace` property, as described previously.</span></span>

### <a name="customizing-dictionary-collections"></a><span data-ttu-id="c9a2b-174">Настройка коллекций-словарей</span><span class="sxs-lookup"><span data-stu-id="c9a2b-174">Customizing Dictionary Collections</span></span>

<span data-ttu-id="c9a2b-175">Коллекции-словари в основном являются списками записей, где каждая запись имеет ключ с последующим значением.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-175">Dictionary collections are essentially lists of entries, where each entry has a key followed by a value.</span></span> <span data-ttu-id="c9a2b-176">Как и с обычными списками, имя элемента, которое соответствует повторяющемуся элементу, можно изменить с помощью свойства <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> .</span><span class="sxs-lookup"><span data-stu-id="c9a2b-176">Just as with regular lists, you can change the element name that corresponds to the repeating element by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property.</span></span>

<span data-ttu-id="c9a2b-177">Кроме того, можно изменить имена элементов, представляющих ключ и значение, с помощью свойств <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> и <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> .</span><span class="sxs-lookup"><span data-stu-id="c9a2b-177">Additionally, you can change the element names that represent the key and the value by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> and <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> properties.</span></span> <span data-ttu-id="c9a2b-178">Пространства имен для данных элементов такие же, как пространство имен контракта данных коллекции.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-178">The namespaces for these elements are the same as the namespace of the collection data contract.</span></span>

<span data-ttu-id="c9a2b-179">Например, см. следующий тип.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-179">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#5)]
[!code-vb[c_collection_types_in_data_contracts#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#5)]

<span data-ttu-id="c9a2b-180">При сериализации получаемый код XML подобен приведенному ниже.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-180">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CountriesOrRegionsWithCapitals>
    <entry>
        <countryorregion>USA</countryorregion>
        <capital>Washington</capital>
    </entry>
    <entry>
        <countryorregion>France</countryorregion>
        <capital>Paris</capital>
    </entry>
    ...
</CountriesOrRegionsWithCapitals>
```

<span data-ttu-id="c9a2b-181">Дополнительные сведения о коллекциях словарей см. в подразделе «Дополнительные правила коллекции» далее в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-181">For more information about dictionary collections, see the "Advanced Collection Rules" section later in this topic.</span></span>

## <a name="collections-and-known-types"></a><span data-ttu-id="c9a2b-182">Коллекции и известные типы</span><span class="sxs-lookup"><span data-stu-id="c9a2b-182">Collections and Known Types</span></span>

<span data-ttu-id="c9a2b-183">При полиморфном использовании вместо других коллекций или интерфейсов коллекций не нужно добавлять типы коллекций в известные типы.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-183">You do not need to add collection types to known types when used polymorphically in place of other collections or collection interfaces.</span></span> <span data-ttu-id="c9a2b-184">Например, при объявлении элемента данных типа <xref:System.Collections.IEnumerable> и использовании его для отправки экземпляра <xref:System.Collections.ArrayList>не нужно добавлять <xref:System.Collections.ArrayList> в известные типы.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-184">For example, if you declare a data member of type <xref:System.Collections.IEnumerable> and use it to send an instance of <xref:System.Collections.ArrayList>, you do not need to add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="c9a2b-185">При полиморфном использовании вместо типов, не являющихся коллекциями, коллекции должны быть добавлены в известные типы.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-185">When you use collections polymorphically in place of non-collection types, they must be added to known types.</span></span> <span data-ttu-id="c9a2b-186">Например, при объявлении члена данных типа `Object` и использовании его для отправки экземпляра <xref:System.Collections.ArrayList>не нужно добавлять <xref:System.Collections.ArrayList> в известные типы.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-186">For example, if you declare a data member of type `Object` and use it to send an instance of <xref:System.Collections.ArrayList>, add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="c9a2b-187">Это не позволяет сериализовать какую-либо эквивалентную коллекцию полиморфно.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-187">This does not allow you to serialize any equivalent collection polymorphically.</span></span> <span data-ttu-id="c9a2b-188">Например, добавление <xref:System.Collections.ArrayList> в список известных типов в предыдущем примере не позволяет присвоить класс `Array of Object` , несмотря на то что он имеет эквивалентный контракт данных.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-188">For example, when you add <xref:System.Collections.ArrayList> to the list of known types in the preceding example, this does not let you assign the `Array of Object` class, even though it has an equivalent data contract.</span></span> <span data-ttu-id="c9a2b-189">Такое поведение не отличается от обычного поведения известных типов при сериализации типов, не являющихся коллекциями, но в случае с коллекциями особенно важно понимать это, поскольку эквивалентность коллекций является очень распространенным свойством.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-189">This is no different from regular known types behavior on serialization for non-collection types, but it is especially important to understand in the case of collections because it is very common for collections to be equivalent.</span></span>

<span data-ttu-id="c9a2b-190">Во время сериализации только один тип может быть известен в данной области для данного контракта данных, а все эквивалентные коллекции имеют те же контракты данных.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-190">During serialization, only one type can be known in any given scope for a given data contract, and equivalent collections all have the same data contracts.</span></span> <span data-ttu-id="c9a2b-191">Это означает, что в предыдущем примере нельзя добавить одновременно <xref:System.Collections.ArrayList> и `Array of Object` в известные типы в той же области.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-191">This means that, in the previous example, you cannot add both <xref:System.Collections.ArrayList> and `Array of Object` to known types at the same scope.</span></span> <span data-ttu-id="c9a2b-192">И вновь, такое поведение эквивалентно поведению известных типов для типов, не являющихся коллекциями, но особенно важно понимать этот принцип при работе с коллекциями.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-192">Again, this is equivalent to known types behavior for non-collection types, but it is especially important to understand for collections.</span></span>

<span data-ttu-id="c9a2b-193">Известные типы также могут требоваться для содержимого коллекций.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-193">Known types may also be required for contents of collections.</span></span> <span data-ttu-id="c9a2b-194">Например, если <xref:System.Collections.ArrayList> в настоящий момент содержит экземпляры `Type1` и `Type2`, оба данных типа должны быть добавлены в известные типы.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-194">For example, if an <xref:System.Collections.ArrayList> actually contains instances of `Type1` and `Type2`, both of these types should be added to known types.</span></span>

<span data-ttu-id="c9a2b-195">В следующем примере показан правильно сконструированный с помощью коллекций и известных типов граф объекта.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-195">The following example shows a properly constructed object graph using collections and known types.</span></span> <span data-ttu-id="c9a2b-196">Пример несколько надуманный, поскольку в настоящем приложении следующие члены данных обычно не определяются как `Object`и поэтому не имеют каких-либо проблем с известным типом/полиморфизмом.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-196">The example is somewhat contrived, because in an actual application you would normally not define the following data members as `Object`, and thus do not have any known type/polymorphism issues.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#6)]
[!code-vb[c_collection_types_in_data_contracts#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#6)]

<span data-ttu-id="c9a2b-197">Во время десериализации, если объявленный тип является коллекцией, экземпляр объявленного типа создается независимо от типа, который был фактически отправлен.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-197">On deserialization, if the declared type is a collection type, the declared type is instantiated regardless of the type that was actually sent.</span></span> <span data-ttu-id="c9a2b-198">Если объявленный тип является интерфейсом коллекции, десериализатор выбирает тип для создания экземпляра независимо от известных типов.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-198">If the declared type is a collection interface, the deserializer picks a type to be instantiated with no regard to known types.</span></span>

<span data-ttu-id="c9a2b-199">Кроме того, если объявленный тип не является типом коллекции, но при десериализации отправляется тип коллекции, совпадающий тип коллекции извлекается из списка известных типов.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-199">Also on deserialization, if the declared type is not a collection type but a collection type is being sent, a matching collection type is picked out of the known types list.</span></span> <span data-ttu-id="c9a2b-200">Типы интерфейса коллекций можно добавить в список известных типов при десериализации.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-200">It is possible to add collection interface types to the list of known types on deserialization.</span></span> <span data-ttu-id="c9a2b-201">В таком случае ядро десериализации повторно выбирает тип для создания экземпляра.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-201">In this case, the deserialization engine again picks a type to be instantiated.</span></span>

## <a name="collections-and-the-netdatacontractserializer-class"></a><span data-ttu-id="c9a2b-202">Коллекции и класс NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="c9a2b-202">Collections and the NetDataContractSerializer Class</span></span>

<span data-ttu-id="c9a2b-203">При использовании класса <xref:System.Runtime.Serialization.NetDataContractSerializer> ненастроенные типы коллекций (без атрибута <xref:System.Runtime.Serialization.CollectionDataContractAttribute> ), не являющиеся массивами, теряют свое особое значение.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-203">When the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use, non-customized collection types (without the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute) that are not arrays lose their special meaning.</span></span>

<span data-ttu-id="c9a2b-204">Ненастроенные типы коллекций, отмеченные атрибутом <xref:System.SerializableAttribute> , все равно могут быть сериализованы с помощью класса <xref:System.Runtime.Serialization.NetDataContractSerializer> в соответствии с атрибутом <xref:System.SerializableAttribute> или правилами интерфейса <xref:System.Runtime.Serialization.ISerializable> .</span><span class="sxs-lookup"><span data-stu-id="c9a2b-204">Non-customized collection types marked with the <xref:System.SerializableAttribute> attribute can still be serialized by the <xref:System.Runtime.Serialization.NetDataContractSerializer> class according to the <xref:System.SerializableAttribute> attribute or the <xref:System.Runtime.Serialization.ISerializable> interface rules.</span></span>

<span data-ttu-id="c9a2b-205">Настроенные типы коллекций, интерфейсы коллекций и массивы даже при использовании класса <xref:System.Runtime.Serialization.NetDataContractSerializer> обрабатываются как коллекции.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-205">Customized collection types, collection interfaces, and arrays are still treated as collections, even when the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use.</span></span>

## <a name="collections-and-schema"></a><span data-ttu-id="c9a2b-206">Коллекции и схема</span><span class="sxs-lookup"><span data-stu-id="c9a2b-206">Collections and Schema</span></span>

<span data-ttu-id="c9a2b-207">Все эквивалентные коллекции имеют одинаковое представление в схеме на языке определения схемы XML (XSD).</span><span class="sxs-lookup"><span data-stu-id="c9a2b-207">All equivalent collections have the same representation in XML Schema definition language (XSD) schema.</span></span> <span data-ttu-id="c9a2b-208">По этой причине, в коде, созданном клиентом, и в коде, созданном на сервере, тип коллекции обычно отличается.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-208">Because of this, you normally do not get the same collection type in the generated client code as the one on the server.</span></span> <span data-ttu-id="c9a2b-209">Например, сервер может использовать контракт данных с универсальным <xref:System.Collections.Generic.List%601> целочисленного элемента данных, а в коде, созданном клиентом, тот же элемент данных может стать массивом целых чисел.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-209">For example, the server may use a data contract with a Generic <xref:System.Collections.Generic.List%601> of Integer data member, but in the generated client code the same data member may become an array of integers.</span></span>

<span data-ttu-id="c9a2b-210">Коллекции словарей помечены заметкой схемы, зависящей от WCF, которая указывает, что они являются словарями; в противном случае они становятся неразличимыми из простых списков, содержащих записи с ключом и значением.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-210">Dictionary collections are marked with a WCF-specific schema annotation that indicate that they are dictionaries; otherwise, they are indistinguishable from simple lists that contain entries with a key and a value.</span></span> <span data-ttu-id="c9a2b-211">Подробное описание представлений коллекций в схеме контракта данных см. в статье [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="c9a2b-211">For an exact description of how collections are represented in data contract schema, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>

<span data-ttu-id="c9a2b-212">По умолчанию в импортированном коде типы для ненастроенных коллекций не создаются.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-212">By default, types are not generated for non-customized collections in imported code.</span></span> <span data-ttu-id="c9a2b-213">Элементы данных коллекций списков импортируются как массивы, а элементы данных коллекций-словарей импортируются как универсальный словарь.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-213">Data members of list collection types are imported as arrays, and data members of dictionary collection types are imported as Generic Dictionary.</span></span>

<span data-ttu-id="c9a2b-214">Тем не менее, для настроенных коллекций создаются отдельные типы, отмеченные атрибутом <xref:System.Runtime.Serialization.CollectionDataContractAttribute> .</span><span class="sxs-lookup"><span data-stu-id="c9a2b-214">However, for customized collections, separate types are generated, marked with the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute.</span></span> <span data-ttu-id="c9a2b-215">(Тип настроенной коллекции в схеме является типом, который не использует пространство имен, имя, имя повторяющегося элемента или имена ключа/значения элемента по умолчанию). Данные типы являются пустыми типами, наследованными от универсального <xref:System.Collections.Generic.List%601> для типов списков и универсальным словарем для типов словаря.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-215">(A customized collection type in the schema is one that does not use the default namespace, name, repeating element name, or key/value element names.) These types are empty types that derive from Generic <xref:System.Collections.Generic.List%601> for list types and Generic Dictionary for dictionary types.</span></span>

<span data-ttu-id="c9a2b-216">Например, на сервере могут быть следующие типы.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-216">For example, you may have the following types on the server.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#7)]
[!code-vb[c_collection_types_in_data_contracts#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#7)]

<span data-ttu-id="c9a2b-217">При экспорте схемы и ее импорте обратно, созданный клиентом код подобен следующему коду (для простоты чтения вместо свойств показаны поля).</span><span class="sxs-lookup"><span data-stu-id="c9a2b-217">When the schema is exported and imported back again, the generated client code is similar to the following (fields are shown instead of properties for ease of reading).</span></span>

[!code-csharp[c_collection_types_in_data_contracts#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#8)]
[!code-vb[c_collection_types_in_data_contracts#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#8)]

<span data-ttu-id="c9a2b-218">Возможно, пользователь захочет использовать в созданном коде другие типы, отличные от типов по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-218">You may want to use different types in generated code than the default ones.</span></span> <span data-ttu-id="c9a2b-219">Например, чтобы облегчить привязку элементов данных к компонентам интерфейса, пользователь может использовать для элементов данных универсальный класс <xref:System.ComponentModel.BindingList%601> вместо обычных массивов.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-219">For example, you may want to use Generic <xref:System.ComponentModel.BindingList%601> instead of regular arrays for your data members to make it easier to bind them to user interface components.</span></span>

<span data-ttu-id="c9a2b-220">Чтобы выбрать тип коллекции для создания, передайте во время импорта схемы желаемый список типов коллекции в свойство <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> объекта <xref:System.Runtime.Serialization.ImportOptions> .</span><span class="sxs-lookup"><span data-stu-id="c9a2b-220">To choose collection types to generate, pass a list of collection types you want to use into the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property of the <xref:System.Runtime.Serialization.ImportOptions> object when importing schema.</span></span> <span data-ttu-id="c9a2b-221">Данные типы называются *ссылочными типами коллекций*.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-221">These types are called *referenced collection types*.</span></span>

<span data-ttu-id="c9a2b-222">При создании ссылки на них, универсальные типы должны быть либо полностью открытыми универсальными шаблонами, либо полностью закрытыми универсальными шаблонами.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-222">When generic types are being referenced, they must either be fully-open generics or fully-closed generics.</span></span>

> [!NOTE]
> <span data-ttu-id="c9a2b-223">При использовании средства Svcutil.exe данная ссылка может быть выполнена с помощью параметра командной строки **/collectionType** (сокращенная форма: **/ct**).</span><span class="sxs-lookup"><span data-stu-id="c9a2b-223">When using the Svcutil.exe tool, this reference can be accomplished by using the **/collectionType** command-line switch (short form: **/ct**).</span></span> <span data-ttu-id="c9a2b-224">Следует помнить, что нужно также указать сборку для ссылочных типов коллекций с помощью параметра **/reference** (сокращенная форма: **/r**).</span><span class="sxs-lookup"><span data-stu-id="c9a2b-224">Keep in mind that you must also specify the assembly for the referenced collection types using the **/reference** switch (short form: **/r**).</span></span> <span data-ttu-id="c9a2b-225">Если тип является универсальным, после имени типа должен следовать обратный апостроф и число, указывающее количество универсальных параметров.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-225">If the type is generic, it must be followed by a back quote and the number of generic parameters.</span></span> <span data-ttu-id="c9a2b-226">Обратная кавычка\`() не следует путать с символом одинарной кавычки (').</span><span class="sxs-lookup"><span data-stu-id="c9a2b-226">The back quote (\`) is not to be confused with the single quote (‘) character.</span></span> <span data-ttu-id="c9a2b-227">Несколько ссылочных типов коллекций можно указывать несколько раз с помощью параметра **/collectionType** .</span><span class="sxs-lookup"><span data-stu-id="c9a2b-227">You can specify multiple referenced collection types by using the **/collectionType** switch more than once.</span></span>

<span data-ttu-id="c9a2b-228">Например, чтобы все списки были импортированы как универсальные <xref:System.Collections.Generic.List%601>.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-228">For example, to cause all lists to be imported as Generic <xref:System.Collections.Generic.List%601>.</span></span>

```console
svcutil.exe MyService.wsdl MyServiceSchema.xsd /r:C:\full_path_to_system_dll\System.dll /ct:System.Collections.Generic.List`1
```

<span data-ttu-id="c9a2b-229">При импорте какой-либо коллекции сканируется список коллекций ссылочного типа, и наиболее подходящая коллекция, если таковая найдена, используется как элемент данных (для ненастроенных коллекций) или как базовый тип для получения производных (для настроенных коллекций).</span><span class="sxs-lookup"><span data-stu-id="c9a2b-229">When importing any collection, this list of referenced collection types is scanned, and the best-matching collection is used if one is found, either as a data member type (for non-customized collections) or as a base type to derive from (for customized collections).</span></span> <span data-ttu-id="c9a2b-230">Словари подходят только к словарям, а списки подходят только к спискам.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-230">Dictionaries are only matched against dictionaries, while lists are matched against lists.</span></span>

<span data-ttu-id="c9a2b-231">Например, при добавлении универсальных классов <xref:System.ComponentModel.BindingList%601> и <xref:System.Collections.Hashtable> в список ссылочных типов созданный клиентом код для предыдущего примера будет подобен следующему.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-231">For example, if you add the Generic <xref:System.ComponentModel.BindingList%601> and <xref:System.Collections.Hashtable> to the list of referenced types, the generated client code for the preceding example is similar to the following.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#9)]
[!code-vb[c_collection_types_in_data_contracts#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#9)]

<span data-ttu-id="c9a2b-232">Типы интерфейсов коллекции можно указать как коллекции ссылочного типа, но нельзя указать недействительные типы коллекций (такие как коллекции без метода `Add` или открытого конструктора).</span><span class="sxs-lookup"><span data-stu-id="c9a2b-232">You can specify collection interface types as part of your referenced collection types, but you cannot specify invalid collection types (such as ones with no `Add` method or public constructor).</span></span>

<span data-ttu-id="c9a2b-233">Закрытый универсальный шаблон считается наиболее подходящим.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-233">A closed generic is considered to be the best match.</span></span> <span data-ttu-id="c9a2b-234">(Неуниверсальные типы считаются эквивалентными закрытым универсальным `Object`).</span><span class="sxs-lookup"><span data-stu-id="c9a2b-234">(Non-generic types are considered equivalent to closed generics of `Object`).</span></span> <span data-ttu-id="c9a2b-235">Например, если типы универсальных <xref:System.Collections.Generic.List%601> , относящихся к <xref:System.DateTime>, универсального <xref:System.ComponentModel.BindingList%601> (открытый универсальный шаблон) и <xref:System.Collections.ArrayList> являются коллекциями ссылочного типа, создается следующий код.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-235">For example, if the types Generic <xref:System.Collections.Generic.List%601> of <xref:System.DateTime>, Generic <xref:System.ComponentModel.BindingList%601> (open generic), and <xref:System.Collections.ArrayList> are the referenced collection types, the following is generated.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#10)]
[!code-vb[c_collection_types_in_data_contracts#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#10)]

<span data-ttu-id="c9a2b-236">При работе с коллекциями списков поддерживаются только указанные в следующей таблице случаи.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-236">For list collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="c9a2b-237">Ссылочный тип</span><span class="sxs-lookup"><span data-stu-id="c9a2b-237">Referenced type</span></span>|<span data-ttu-id="c9a2b-238">Интерфейс, реализованный ссылочным типом</span><span class="sxs-lookup"><span data-stu-id="c9a2b-238">Interface implemented by referenced type</span></span>|<span data-ttu-id="c9a2b-239">Пример</span><span class="sxs-lookup"><span data-stu-id="c9a2b-239">Example</span></span>|<span data-ttu-id="c9a2b-240">Тип обрабатывается как:</span><span class="sxs-lookup"><span data-stu-id="c9a2b-240">Type treated as:</span></span>|
|---------------------|----------------------------------------------|-------------|----------------------|
|<span data-ttu-id="c9a2b-241">Неуниверсальный или закрытый универсальный (любое количество параметров)</span><span class="sxs-lookup"><span data-stu-id="c9a2b-241">Non-generic or closed generic (any number of parameters)</span></span>|<span data-ttu-id="c9a2b-242">неуниверсальный</span><span class="sxs-lookup"><span data-stu-id="c9a2b-242">Non-generic</span></span>|`MyType : IList`<br /><br /> <span data-ttu-id="c9a2b-243">или диспетчер конфигурации служб</span><span class="sxs-lookup"><span data-stu-id="c9a2b-243">or</span></span><br /><br /> `MyType<T> : IList`<br /><br /> <span data-ttu-id="c9a2b-244">где T= `int`</span><span class="sxs-lookup"><span data-stu-id="c9a2b-244">where T= `int`</span></span>|<span data-ttu-id="c9a2b-245">Закрытый универсальный тип `Object` (например, `IList<object>`)</span><span class="sxs-lookup"><span data-stu-id="c9a2b-245">Closed generic of `Object` (for example, `IList<object>`)</span></span>|
|<span data-ttu-id="c9a2b-246">Неуниверсальный или закрытый универсальный (любое количество параметров, которое не обязательно совпадает с типом коллекции)</span><span class="sxs-lookup"><span data-stu-id="c9a2b-246">Non-generic or closed generic (any number of parameters that do not necessarily match the collection type)</span></span>|<span data-ttu-id="c9a2b-247">Закрытый универсальный тип</span><span class="sxs-lookup"><span data-stu-id="c9a2b-247">Closed generic</span></span>|`MyType : IList<string>`<br /><br /> <span data-ttu-id="c9a2b-248">или диспетчер конфигурации служб</span><span class="sxs-lookup"><span data-stu-id="c9a2b-248">or</span></span><br /><br /> <span data-ttu-id="c9a2b-249">`MyType<T> : IList<string>` где T=`int`</span><span class="sxs-lookup"><span data-stu-id="c9a2b-249">`MyType<T> : IList<string>` where T=`int`</span></span>|<span data-ttu-id="c9a2b-250">Закрытый универсальный тип (например, `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="c9a2b-250">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="c9a2b-251">Закрытый универсальный тип с любым количеством параметров</span><span class="sxs-lookup"><span data-stu-id="c9a2b-251">Closed generic with any number of parameters</span></span>|<span data-ttu-id="c9a2b-252">Открытый универсальный тип с использованием одного из параметров типа</span><span class="sxs-lookup"><span data-stu-id="c9a2b-252">Open generic using any one of the type’s parameters</span></span>|`MyType<T,U,V> : IList<U>`<br /><br /> <span data-ttu-id="c9a2b-253">где T=`int`, U=`string`, V=`bool`</span><span class="sxs-lookup"><span data-stu-id="c9a2b-253">where T=`int`, U=`string`, V=`bool`</span></span>|<span data-ttu-id="c9a2b-254">Закрытый универсальный тип (например, `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="c9a2b-254">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="c9a2b-255">Открытый универсальный тип с одним параметром</span><span class="sxs-lookup"><span data-stu-id="c9a2b-255">Open generic with one parameter</span></span>|<span data-ttu-id="c9a2b-256">Открытый универсальный тип с использованием параметра типа</span><span class="sxs-lookup"><span data-stu-id="c9a2b-256">Open generic using the type’s parameter</span></span>|<span data-ttu-id="c9a2b-257">`MyType<T> : IList<T>`, T является открытым</span><span class="sxs-lookup"><span data-stu-id="c9a2b-257">`MyType<T> : IList<T>`, T is open</span></span>|<span data-ttu-id="c9a2b-258">Открытый универсальный тип (например, `IList<T>`)</span><span class="sxs-lookup"><span data-stu-id="c9a2b-258">Open generic (for example, `IList<T>`)</span></span>|

<span data-ttu-id="c9a2b-259">Если тип реализует несколько интерфейсов коллекции списка, применяются следующие ограничения.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-259">If a type implements more than one list collection interface, the following restrictions apply:</span></span>

- <span data-ttu-id="c9a2b-260">Если тип несколько раз для разных типов реализует интерфейс <xref:System.Collections.Generic.IEnumerable%601> (или наследованные от него интерфейсы), тип не рассматривается как действительная коллекция ссылочного типа и не учитываются.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-260">If the type implements Generic <xref:System.Collections.Generic.IEnumerable%601> (or its derived interfaces) multiple times for different types, the type is not considered a valid referenced collection type and is ignored.</span></span> <span data-ttu-id="c9a2b-261">Это верно, даже если некоторые реализации недействительны или используют открытые универсальные шаблоны.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-261">This is true even if some implementations are invalid or use open generics.</span></span> <span data-ttu-id="c9a2b-262">Например, тип, реализующий универсальный интерфейс <xref:System.Collections.Generic.IEnumerable%601> , относящийся к `int` , и универсальный интерфейс <xref:System.Collections.Generic.IEnumerable%601> , относящийся к T, никогда не будет использован как коллекция ссылочного типа `int` или другого типа, независимо от того, имеется ли в типе метод `Add` , принимающий метод `int` , или `Add` , принимающий параметр типа T, или оба.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-262">For example, a type that implements Generic <xref:System.Collections.Generic.IEnumerable%601> of `int` and Generic <xref:System.Collections.Generic.IEnumerable%601> of T would never be used as a referenced collection of `int` or any other type, regardless of whether the type has an `Add` method accepting `int` or an `Add` method accepting a parameter of type T, or both.</span></span>

- <span data-ttu-id="c9a2b-263">Если тип реализует универсальный интерфейс коллекции, а так же интерфейс <xref:System.Collections.IList>, тип никогда не будет использован как коллекция ссылочного типа, кроме случая, когда интерфейс универсальной коллекции является закрытым универсальным шаблоном типа <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-263">If the type implements a generic collection interface as well as <xref:System.Collections.IList>, the type is never used as a referenced collection type unless the generic collection interface is a closed generic of type <xref:System.Object>.</span></span>

<span data-ttu-id="c9a2b-264">При работе с коллекциями-словарями поддерживаются только указанные в следующей таблице случаи.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-264">For dictionary collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="c9a2b-265">Ссылочный тип</span><span class="sxs-lookup"><span data-stu-id="c9a2b-265">Referenced type</span></span>|<span data-ttu-id="c9a2b-266">Интерфейс, реализованный ссылочным типом</span><span class="sxs-lookup"><span data-stu-id="c9a2b-266">Interface implemented by referenced type</span></span>|<span data-ttu-id="c9a2b-267">Пример</span><span class="sxs-lookup"><span data-stu-id="c9a2b-267">Example</span></span>|<span data-ttu-id="c9a2b-268">Тип обрабатывается как</span><span class="sxs-lookup"><span data-stu-id="c9a2b-268">Type treated as</span></span>|
|---------------------|----------------------------------------------|-------------|---------------------|
|<span data-ttu-id="c9a2b-269">Неуниверсальный или закрытый универсальный (любое количество параметров)</span><span class="sxs-lookup"><span data-stu-id="c9a2b-269">Non-generic or closed generic (any number of parameters)</span></span>|<xref:System.Collections.IDictionary>|`MyType : IDictionary`<br /><br /> <span data-ttu-id="c9a2b-270">или диспетчер конфигурации служб</span><span class="sxs-lookup"><span data-stu-id="c9a2b-270">or</span></span><br /><br /> <span data-ttu-id="c9a2b-271">`MyType<T> : IDictionary` где T=`int`</span><span class="sxs-lookup"><span data-stu-id="c9a2b-271">`MyType<T> : IDictionary` where T=`int`</span></span>|<span data-ttu-id="c9a2b-272">Закрытый универсальный тип `IDictionary<object,object>`</span><span class="sxs-lookup"><span data-stu-id="c9a2b-272">Closed generic `IDictionary<object,object>`</span></span>|
|<span data-ttu-id="c9a2b-273">Закрытый универсальный тип (любое количество параметров)</span><span class="sxs-lookup"><span data-stu-id="c9a2b-273">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="c9a2b-274"><xref:System.Collections.Generic.IDictionary%602>, закрытый</span><span class="sxs-lookup"><span data-stu-id="c9a2b-274"><xref:System.Collections.Generic.IDictionary%602>, closed</span></span>|<span data-ttu-id="c9a2b-275">`MyType<T> : IDictionary<string, bool>` где T=`int`</span><span class="sxs-lookup"><span data-stu-id="c9a2b-275">`MyType<T> : IDictionary<string, bool>` where T=`int`</span></span>|<span data-ttu-id="c9a2b-276">Закрытый универсальный тип (например, `IDIctionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="c9a2b-276">Closed generic (for example, `IDIctionary<string,bool>`)</span></span>|
|<span data-ttu-id="c9a2b-277">Закрытый универсальный тип (любое количество параметров)</span><span class="sxs-lookup"><span data-stu-id="c9a2b-277">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="c9a2b-278">Универсальный <xref:System.Collections.Generic.IDictionary%602>, ключ или значение закрыто, другой (ключ или значение) открыт и использует один из параметров типа.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-278">Generic <xref:System.Collections.Generic.IDictionary%602>, one of either key or value is closed, the other is open and uses one of type’s parameters</span></span>|<span data-ttu-id="c9a2b-279">`MyType<T,U,V> : IDictionary<string,V>` , где T=`int`, U=`float`, V=`bool`</span><span class="sxs-lookup"><span data-stu-id="c9a2b-279">`MyType<T,U,V> : IDictionary<string,V>` where T=`int`, U=`float`,V=`bool`</span></span><br /><br /> <span data-ttu-id="c9a2b-280">или диспетчер конфигурации служб</span><span class="sxs-lookup"><span data-stu-id="c9a2b-280">or</span></span><br /><br /> <span data-ttu-id="c9a2b-281">`MyType<Z> : IDictionary<Z,bool>` , где Z=`string`</span><span class="sxs-lookup"><span data-stu-id="c9a2b-281">`MyType<Z> : IDictionary<Z,bool>` where Z=`string`</span></span>|<span data-ttu-id="c9a2b-282">Закрытый универсальный тип (например, `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="c9a2b-282">Closed generic (For example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="c9a2b-283">Закрытый универсальный тип (любое количество параметров)</span><span class="sxs-lookup"><span data-stu-id="c9a2b-283">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="c9a2b-284">Универсальный <xref:System.Collections.Generic.IDictionary%602>, ключ и значение открыты, и оба используют один из параметров типа</span><span class="sxs-lookup"><span data-stu-id="c9a2b-284">Generic <xref:System.Collections.Generic.IDictionary%602>, both key and value are open and each uses one of the type’s parameters</span></span>|<span data-ttu-id="c9a2b-285">`MyType<T,U,V> : IDictionary<V,U>` где T=`int`, U=`bool`, V=`string`</span><span class="sxs-lookup"><span data-stu-id="c9a2b-285">`MyType<T,U,V> : IDictionary<V,U>` where T=`int`, U=`bool`, V=`string`</span></span>|<span data-ttu-id="c9a2b-286">Закрытый универсальный тип (например, `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="c9a2b-286">Closed generic (for example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="c9a2b-287">Открытый универсальный тип (два параметра)</span><span class="sxs-lookup"><span data-stu-id="c9a2b-287">Open generic (two parameters)</span></span>|<span data-ttu-id="c9a2b-288">Универсальный <xref:System.Collections.Generic.IDictionary%602>, открытый, использует оба типа универсальных параметров в порядке их появления</span><span class="sxs-lookup"><span data-stu-id="c9a2b-288">Generic <xref:System.Collections.Generic.IDictionary%602>, open, uses both of the type’s generic parameters in the order they appear</span></span>|<span data-ttu-id="c9a2b-289">`MyType<K,V> : IDictionary<K,V>`, K и V, оба открыты</span><span class="sxs-lookup"><span data-stu-id="c9a2b-289">`MyType<K,V> : IDictionary<K,V>`, K and V both open</span></span>|<span data-ttu-id="c9a2b-290">Открытый универсальный тип (например, `IDictionary<K,V>`)</span><span class="sxs-lookup"><span data-stu-id="c9a2b-290">Open generic (for example, `IDictionary<K,V>`)</span></span>|

<span data-ttu-id="c9a2b-291">Если тип реализует и интерфейс <xref:System.Collections.IDictionary> , и универсальный интерфейс <xref:System.Collections.Generic.IDictionary%602>, рассматривается только универсальный <xref:System.Collections.Generic.IDictionary%602> .</span><span class="sxs-lookup"><span data-stu-id="c9a2b-291">If the type implements both <xref:System.Collections.IDictionary> and Generic <xref:System.Collections.Generic.IDictionary%602>, only Generic <xref:System.Collections.Generic.IDictionary%602> is considered.</span></span>

<span data-ttu-id="c9a2b-292">Ссылка на частично универсальные типы не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-292">Referencing partial generic types is not supported.</span></span>

<span data-ttu-id="c9a2b-293">Дубликаты не разрешены. Например, нельзя добавить одновременно универсальный класс <xref:System.Collections.Generic.List%601> типа `Integer` и универсальную коллекцию `Integer` в <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, поскольку в таком случае будет невозможно определить, какой из них использовать при обнаружении списка целых чисел в схеме.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-293">Duplicates are not allowed, for example, you cannot add both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` to <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, because this makes it impossible to determine which one to use when a list of integers is found in the schema.</span></span> <span data-ttu-id="c9a2b-294">Дубликаты обнаруживаются, только если в схеме есть тип, указывающий на проблему дубликатов.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-294">Duplicates are detected only if there is a type in the schema that exposes the duplicates problem.</span></span> <span data-ttu-id="c9a2b-295">Например, если импортируемая схема не содержит список целых чисел, допускается иметь в <xref:System.Collections.Generic.List%601> как универсальный `Integer` типа `Integer` , так и универсальную коллекцию <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, но ни тот, ни другой не будут действовать.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-295">For example, if the schema being imported does not contain lists of integers, it is allowed to have both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` in the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, but neither has any effect.</span></span>

## <a name="advanced-collection-rules"></a><span data-ttu-id="c9a2b-296">Расширенные правила коллекции</span><span class="sxs-lookup"><span data-stu-id="c9a2b-296">Advanced Collection Rules</span></span>

### <a name="serializing-collections"></a><span data-ttu-id="c9a2b-297">Сериализация коллекций</span><span class="sxs-lookup"><span data-stu-id="c9a2b-297">Serializing Collections</span></span>

<span data-ttu-id="c9a2b-298">Далее приводится список правил сериализации коллекций.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-298">The following is a list of collection rules for serialization:</span></span>

- <span data-ttu-id="c9a2b-299">Разрешено комбинирование типов коллекции (наличие коллекций коллекций).</span><span class="sxs-lookup"><span data-stu-id="c9a2b-299">Combining collection types (having collections of collections) is allowed.</span></span> <span data-ttu-id="c9a2b-300">Неровные массивы обрабатываются как коллекции коллекций.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-300">Jagged arrays are treated as collections of collections.</span></span> <span data-ttu-id="c9a2b-301">Многомерные массивы не поддерживаются.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-301">Multidimensional arrays are not supported.</span></span>

- <span data-ttu-id="c9a2b-302">Массивы байтов и массивы <xref:System.Xml.XmlNode> являются специальными типами массивов, которые обрабатываются как базисные элементы, а не коллекции.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-302">Arrays of byte and arrays of <xref:System.Xml.XmlNode> are special array types that are treated as primitives, not collections.</span></span> <span data-ttu-id="c9a2b-303">В результате сериализации массива байтов получается один XML-элемент, содержащий фрагмент данных в кодировке Base64, вместо отдельного элемента для каждого байта.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-303">Serializing an array of byte results in a single XML element that contains a chunk of Base64-encoded data, instead of a separate element for each byte.</span></span> <span data-ttu-id="c9a2b-304">Дополнительные сведения о том, как обрабатывается <xref:System.Xml.XmlNode> массив, см. [в разделе Типы XML и ADO.NET в контрактах данных](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="c9a2b-304">For more information about how an array of <xref:System.Xml.XmlNode> is treated, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span> <span data-ttu-id="c9a2b-305">Конечно, такие специальные типы могут сами по себе участвовать в коллекциях: результатом массива массивов байтов является несколько элементов XML, каждый из которых содержит фрагмент данных, закодированных в Base64.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-305">Of course, these special types can themselves participate in collections: an array of array of byte results in multiple XML elements, with each containing a chunk of Base64-encoded data.</span></span>

- <span data-ttu-id="c9a2b-306">Если к типу коллекции применяется атрибут <xref:System.Runtime.Serialization.DataContractAttribute> , тип обрабатывается как тип с обычным контрактом данных, а не как коллекция.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-306">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a collection type, the type is treated as a regular data contract type, not as a collection.</span></span>

- <span data-ttu-id="c9a2b-307">Если тип коллекции реализует интерфейс <xref:System.Xml.Serialization.IXmlSerializable> , применяются следующие правила для типа `myType:IList<string>, IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-307">If a collection type implements the <xref:System.Xml.Serialization.IXmlSerializable> interface, the following rules apply, given a type `myType:IList<string>, IXmlSerializable`:</span></span>

  - <span data-ttu-id="c9a2b-308">Если объявленный тип - `IList<string>`, тип сериализуется как список.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-308">If the declared type is `IList<string>`, the type is serialized as a list.</span></span>

  - <span data-ttu-id="c9a2b-309">Если объявленный тип - `myType`, он сериализуется как `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-309">If the declared type is `myType`, it is serialized as `IXmlSerializable`.</span></span>

  - <span data-ttu-id="c9a2b-310">Если объявленный тип - `IXmlSerializable`, он сериализуется как `IXmlSerializable`, но только при условии добавления `myType` в список известных типов.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-310">If the declared type is `IXmlSerializable`, it is serialized as `IXmlSerializable`, but only if you add `myType` to the list of known types.</span></span>

- <span data-ttu-id="c9a2b-311">Коллекции сериализуются и десериализуются с помощью методов, показанных в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-311">Collections are serialized and deserialized using the methods shown in the following table.</span></span>

|<span data-ttu-id="c9a2b-312">Реализованные в коллекции элементы</span><span class="sxs-lookup"><span data-stu-id="c9a2b-312">Collection type implements</span></span>|<span data-ttu-id="c9a2b-313">Методы, вызываемые при сериализации</span><span class="sxs-lookup"><span data-stu-id="c9a2b-313">Method(s) called on serialization</span></span>|<span data-ttu-id="c9a2b-314">Методы, вызываемые при десериализации</span><span class="sxs-lookup"><span data-stu-id="c9a2b-314">Method(s) called on deserialization</span></span>|
|--------------------------------|-----------------------------------------|-------------------------------------------|
|<span data-ttu-id="c9a2b-315">Универсальный тип <xref:System.Collections.Generic.IDictionary%602></span><span class="sxs-lookup"><span data-stu-id="c9a2b-315">Generic <xref:System.Collections.Generic.IDictionary%602></span></span>|<span data-ttu-id="c9a2b-316">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="c9a2b-316">`get_Keys`, `get_Values`</span></span>|<span data-ttu-id="c9a2b-317">Универсальное добавление</span><span class="sxs-lookup"><span data-stu-id="c9a2b-317">Generic Add</span></span>|
|<xref:System.Collections.IDictionary>|<span data-ttu-id="c9a2b-318">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="c9a2b-318">`get_Keys`, `get_Values`</span></span>|`Add`|
|<span data-ttu-id="c9a2b-319">Универсальный тип <xref:System.Collections.Generic.IList%601></span><span class="sxs-lookup"><span data-stu-id="c9a2b-319">Generic <xref:System.Collections.Generic.IList%601></span></span>|<span data-ttu-id="c9a2b-320">Универсальный индексатор <xref:System.Collections.Generic.IList%601></span><span class="sxs-lookup"><span data-stu-id="c9a2b-320">Generic <xref:System.Collections.Generic.IList%601> indexer</span></span>|<span data-ttu-id="c9a2b-321">Универсальное добавление</span><span class="sxs-lookup"><span data-stu-id="c9a2b-321">Generic Add</span></span>|
|<span data-ttu-id="c9a2b-322">Универсальный тип <xref:System.Collections.Generic.ICollection%601></span><span class="sxs-lookup"><span data-stu-id="c9a2b-322">Generic <xref:System.Collections.Generic.ICollection%601></span></span>|<span data-ttu-id="c9a2b-323">Перечислитель</span><span class="sxs-lookup"><span data-stu-id="c9a2b-323">Enumerator</span></span>|<span data-ttu-id="c9a2b-324">Универсальное добавление</span><span class="sxs-lookup"><span data-stu-id="c9a2b-324">Generic Add</span></span>|
|<xref:System.Collections.IList>|<span data-ttu-id="c9a2b-325">Индексатор<xref:System.Collections.IList></span><span class="sxs-lookup"><span data-stu-id="c9a2b-325"><xref:System.Collections.IList> Indexer</span></span>|`Add`|
|<span data-ttu-id="c9a2b-326">Универсальный тип <xref:System.Collections.Generic.IEnumerable%601></span><span class="sxs-lookup"><span data-stu-id="c9a2b-326">Generic <xref:System.Collections.Generic.IEnumerable%601></span></span>|`GetEnumerator`|<span data-ttu-id="c9a2b-327">Нестатический метод с названием `Add` , принимающий один параметр соответствующего типа (тип универсального параметра или один из его базовых типов).</span><span class="sxs-lookup"><span data-stu-id="c9a2b-327">A non-static method called `Add` that takes one parameter of the appropriate type (the type of the generic parameter or one of its base types).</span></span> <span data-ttu-id="c9a2b-328">Такой метод должен быть предусмотрен для обработки коллекции сериализатором во время сериализации и десериализации.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-328">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|
|<span data-ttu-id="c9a2b-329"><xref:System.Collections.IEnumerable> (и, следовательно, унаследованный от него <xref:System.Collections.ICollection>)</span><span class="sxs-lookup"><span data-stu-id="c9a2b-329"><xref:System.Collections.IEnumerable> (and thus <xref:System.Collections.ICollection>, which derives from it)</span></span>|`GetEnumerator`|<span data-ttu-id="c9a2b-330">Нестатический метод с названием `Add` , принимающий один параметр типа `Object`.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-330">A non-static method called `Add` that takes one parameter of type `Object`.</span></span> <span data-ttu-id="c9a2b-331">Такой метод должен быть предусмотрен для обработки коллекции сериализатором во время сериализации и десериализации.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-331">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|

<span data-ttu-id="c9a2b-332">В предыдущей таблице приведен список интерфейсов коллекции, упорядоченный по убыванию приоритета.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-332">The preceding table lists collection interfaces in descending order of precedence.</span></span> <span data-ttu-id="c9a2b-333">Это означает, что, например, если тип реализует интерфейс <xref:System.Collections.IList> и универсальный интерфейс <xref:System.Collections.Generic.IEnumerable%601>, коллекция сериализуется и десериализуется согласно правилам интерфейса <xref:System.Collections.IList> :</span><span class="sxs-lookup"><span data-stu-id="c9a2b-333">This means, for example, that if a type implements both <xref:System.Collections.IList> and Generic <xref:System.Collections.Generic.IEnumerable%601>, the collection is serialized and deserialized according to the <xref:System.Collections.IList> rules:</span></span>

- <span data-ttu-id="c9a2b-334">При десериализации все коллекции десериализуются путем создания экземпляра типа путем вызова конструктора без параметров, который должен присутствовать, чтобы сериализатор рассматривал тип коллекции как коллекцию во время сериализации и десериализации.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-334">At deserialization, all collections are deserialized by first creating an instance of the type by calling the parameterless constructor, which must be present for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>

- <span data-ttu-id="c9a2b-335">Если один и тот же универсальный интерфейс коллекции реализуется несколько раз (например, если тип одновременно реализует как универсальный интерфейс <xref:System.Collections.Generic.ICollection%601> типа `Integer` , так и универсальный интерфейс <xref:System.Collections.Generic.ICollection%601> типа <xref:System.String>), и при этом не обнаружен интерфейс с более высоким приоритетом, коллекция не обрабатывается как действительная.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-335">If the same generic collection interface is implemented more than once (for example, if a type implements both Generic <xref:System.Collections.Generic.ICollection%601> of `Integer` and Generic <xref:System.Collections.Generic.ICollection%601> of <xref:System.String>) and no higher-precedence interface is found, the collection is not treated as a valid collection.</span></span>

- <span data-ttu-id="c9a2b-336">Типы коллекций могут иметь применяемый к ним атрибут <xref:System.SerializableAttribute> и могут реализовать интерфейс <xref:System.Runtime.Serialization.ISerializable> .</span><span class="sxs-lookup"><span data-stu-id="c9a2b-336">Collection types can have the <xref:System.SerializableAttribute> attribute applied to them and can implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span> <span data-ttu-id="c9a2b-337">Оба данных типа не учитываются.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-337">Both of these are ignored.</span></span> <span data-ttu-id="c9a2b-338">Однако если тип не полностью соответствует требованиям к типу коллекции (например, отсутствует метод `Add` ), тип не рассматривается как тип коллекции, и поэтому для определения того, можно ли сериализовать данный тип, используются атрибут <xref:System.SerializableAttribute> и интерфейс <xref:System.Runtime.Serialization.ISerializable> .</span><span class="sxs-lookup"><span data-stu-id="c9a2b-338">However, if the type does not fully meet collection type requirements (for example, the `Add` method is missing), the type is not considered a collection type, and thus the <xref:System.SerializableAttribute> attribute and the <xref:System.Runtime.Serialization.ISerializable> interface are used to determine whether the type can be serialized.</span></span>

- <span data-ttu-id="c9a2b-339">При применении атрибута <xref:System.Runtime.Serialization.CollectionDataContractAttribute> к коллекции для ее настройки удаляется предшествующий резервный механизм <xref:System.SerializableAttribute> .</span><span class="sxs-lookup"><span data-stu-id="c9a2b-339">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a collection to customize it removes the <xref:System.SerializableAttribute> preceding fallback mechanism.</span></span> <span data-ttu-id="c9a2b-340">Вместо этого, если настроенная коллекция не соответствует требованиям к типу коллекции, выдается исключение <xref:System.Runtime.Serialization.InvalidDataContractException> .</span><span class="sxs-lookup"><span data-stu-id="c9a2b-340">Instead, if a customized collection does not meet collection type requirements, an <xref:System.Runtime.Serialization.InvalidDataContractException> exception is thrown.</span></span> <span data-ttu-id="c9a2b-341">Строка исключения часто содержит сведения, объясняющие, почему данный тип не считается допустимой коллекцией (без `Add` метода, без параметров и т. д.), поэтому часто бывает полезно <xref:System.Runtime.Serialization.CollectionDataContractAttribute> применять атрибут для отладки. целях.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-341">The exception string often contains information that explains why a given type is not considered a valid collection (no `Add` method, no parameterless constructor, and so on), so it is often useful to apply the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute for debugging purposes.</span></span>

### <a name="collection-naming"></a><span data-ttu-id="c9a2b-342">Именование коллекций</span><span class="sxs-lookup"><span data-stu-id="c9a2b-342">Collection Naming</span></span>

<span data-ttu-id="c9a2b-343">Далее приводится список правил именования коллекций.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-343">The following is a list of collection naming rules:</span></span>

- <span data-ttu-id="c9a2b-344">Пространство имен по умолчанию для всех контрактов данных коллекции Dictionary, а также для контрактов данных коллекции списков, содержащих примитивные типы `http://schemas.microsoft.com/2003/10/Serialization/Arrays` , —, если не переопределяется с помощью пространства имен.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-344">The default namespace for all dictionary collection data contracts, as well as for list collection data contracts that contain primitive types, is `http://schemas.microsoft.com/2003/10/Serialization/Arrays` unless overridden using Namespace.</span></span> <span data-ttu-id="c9a2b-345">С этой целью типы, сопоставляемые встроенным типам XSD, а также типы `char`, `Timespan`и `Guid` рассматриваются как примитивы.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-345">Types that map to built-in XSD types, as well as `char`, `Timespan`, and `Guid` types, are considered primitives for this purpose.</span></span>

- <span data-ttu-id="c9a2b-346">По умолчанию пространство имен для типов коллекции, содержащей не типы-примитивы, кроме случая, когда оно переопределено с помощью пространства имени, является таким же, как пространство имен контракта данных, содержащегося в коллекции типа.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-346">The default namespace for collection types that contain non-primitive types, unless it is overridden using Namespace, is the same as the data contract namespace of the type contained in the collection.</span></span>

- <span data-ttu-id="c9a2b-347">Имя по умолчанию контрактов данных коллекций списков, если оно не переопределено с помощью Name, является строкой "ArrayOf", комбинированной с именем контракта данных типа, содержащегося в коллекции.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-347">The default name for list collection data contracts, unless overridden using Name, is the string "ArrayOf" combined with the data contract name of the type contained in the collection.</span></span> <span data-ttu-id="c9a2b-348">Например, именем контракта данных для универсального списка целых чисел является "ArrayOfint".</span><span class="sxs-lookup"><span data-stu-id="c9a2b-348">For example, the data contract name for a Generic List of Integers is "ArrayOfint".</span></span> <span data-ttu-id="c9a2b-349">Следует иметь в виду, что именем контракта данных `Object` является "anyType", т. е. именем контракта данных неуниверсальных списков, таких как <xref:System.Collections.ArrayList> , является "ArrayOfanyType".</span><span class="sxs-lookup"><span data-stu-id="c9a2b-349">Keep in mind that the data contract name of `Object` is "anyType", so the data contract name of non-generic lists like <xref:System.Collections.ArrayList> is "ArrayOfanyType".</span></span>

<span data-ttu-id="c9a2b-350">Имя по умолчанию контрактов данных коллекций-словарей, если оно не переопределено с помощью `Name`, является строкой "ArrayOfKeyValueOf", комбинированной с именем контракта данных ключевого типа, за которым следует имя контракта данных типа значения.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-350">The default name for dictionary collection data contracts, unless overridden using `Name`, is the string "ArrayOfKeyValueOf" combined with the data contract name of the key type followed by the data contract name of the value type.</span></span> <span data-ttu-id="c9a2b-351">Например, именем контракта данных для универсального словаря строк и целых чисел является "ArrayOfKeyValueOfstringint".</span><span class="sxs-lookup"><span data-stu-id="c9a2b-351">For example, the data contract name for a Generic Dictionary of String and Integer is "ArrayOfKeyValueOfstringint".</span></span> <span data-ttu-id="c9a2b-352">Кроме того, если ключ или типы значения не являются типами-примитивами, к имени присоединяется хэш пространств имен ключа или типов значения.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-352">Additionally, if either the key or the value types are not primitive types, a namespace hash of the data contract namespaces of the key and value types is appended to the name.</span></span> <span data-ttu-id="c9a2b-353">Дополнительные сведения о хэш-значениях пространств имен см. в разделе [имена контрактов данных](../../../../docs/framework/wcf/feature-details/data-contract-names.md).</span><span class="sxs-lookup"><span data-stu-id="c9a2b-353">For more information about namespace hashes, see [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md).</span></span>

<span data-ttu-id="c9a2b-354">Каждый контракт данных коллекции-словаря имеет сопровождающий контракт данных, который представляет одну запись в словаре.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-354">Each dictionary collection data contract has a companion data contract that represents one entry in the dictionary.</span></span> <span data-ttu-id="c9a2b-355">Имя у него такое же, как у контракта данных словаря, кроме префикса "ArrayOf", и его пространство имен такое же, как у контракта данных словаря.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-355">Its name is the same as for the dictionary data contract, except for the "ArrayOf" prefix, and its namespace is the same as for the dictionary data contract.</span></span> <span data-ttu-id="c9a2b-356">Например, для контракта данных словаря "ArrayOfKeyValueOfstringint", контракт данных "KeyValueofstringint" представляет одну запись в словаре.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-356">For example, for the "ArrayOfKeyValueOfstringint" dictionary data contract, the "KeyValueofstringint" data contract represents one entry in the dictionary.</span></span> <span data-ttu-id="c9a2b-357">Имя данного контракта данных можно настроить с помощью свойства `ItemName` , как описано в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-357">You can customize the name of this data contract by using the `ItemName` property, as described in the next section.</span></span>

<span data-ttu-id="c9a2b-358">Правила именования универсальных типов, как описано в разделе [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md), полностью применяются к типам коллекций, то есть для обозначения параметров универсального типа можно использовать фигурные скобки.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-358">Generic type naming rules, as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md), fully apply to collection types; that is, you can use curly braces within Name to indicate generic type parameters.</span></span> <span data-ttu-id="c9a2b-359">Однако числа, указанные в скобках, относятся к универсальным параметрам, а не к типам, содержащимся в коллекции.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-359">However, numbers within the braces refer to generic parameters and not types contained within the collection.</span></span>

## <a name="collection-customization"></a><span data-ttu-id="c9a2b-360">Настройка коллекции</span><span class="sxs-lookup"><span data-stu-id="c9a2b-360">Collection Customization</span></span>

<span data-ttu-id="c9a2b-361">Следующие варианты использования атрибута <xref:System.Runtime.Serialization.CollectionDataContractAttribute> запрещены и приводят к вызову исключения <xref:System.Runtime.Serialization.InvalidDataContractException> :</span><span class="sxs-lookup"><span data-stu-id="c9a2b-361">The following uses of the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute are forbidden and result in an <xref:System.Runtime.Serialization.InvalidDataContractException> exception:</span></span>

- <span data-ttu-id="c9a2b-362">Применение атрибута <xref:System.Runtime.Serialization.DataContractAttribute> к типу, к которому был применен атрибут <xref:System.Runtime.Serialization.CollectionDataContractAttribute> , или к одному из наследованных от него типов.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-362">Applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to a type to which the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute has been applied, or to one of its derived types.</span></span>

- <span data-ttu-id="c9a2b-363">Применение атрибута <xref:System.Runtime.Serialization.CollectionDataContractAttribute> к типу, реализующему интерфейс <xref:System.Xml.Serialization.IXmlSerializable> .</span><span class="sxs-lookup"><span data-stu-id="c9a2b-363">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a type that implements the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>

- <span data-ttu-id="c9a2b-364">Применение атрибута <xref:System.Runtime.Serialization.CollectionDataContractAttribute> к типу, не являющемуся коллекцией.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-364">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a non-collection type.</span></span>

- <span data-ttu-id="c9a2b-365">Попытка задать <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> или <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> атрибуту <xref:System.Runtime.Serialization.CollectionDataContractAttribute> , применяемому к типу, не являющемуся словарем.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-365">Attempting to set <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> or <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> on a <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute applied to a non-dictionary type.</span></span>

### <a name="polymorphism-rules"></a><span data-ttu-id="c9a2b-366">Правила полиморфизма</span><span class="sxs-lookup"><span data-stu-id="c9a2b-366">Polymorphism Rules</span></span>

<span data-ttu-id="c9a2b-367">Как было указано выше, настройка коллекций с помощью атрибута <xref:System.Runtime.Serialization.CollectionDataContractAttribute> может мешать взаимозаменяемости коллекций.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-367">As previously mentioned, customizing collections by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute may interfere with collection interchangeability.</span></span> <span data-ttu-id="c9a2b-368">Два типа настроенных коллекций могут считаться эквивалентными только при условии совпадения их имен, пространств имен, имен элементов, а также имен ключей и значений (если это коллекции-словари).</span><span class="sxs-lookup"><span data-stu-id="c9a2b-368">Two customized collection types can only be considered equivalent if their name, namespace, item name, as well as key and value names (if these are dictionary collections) match.</span></span>

<span data-ttu-id="c9a2b-369">Благодаря возможности настроек, можно случайно использовать один контракт данных там, где ожидается другой.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-369">Due to customizations, it is possible to inadvertently use one collection data contract where another is expected.</span></span> <span data-ttu-id="c9a2b-370">Этого следует избегать.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-370">This should be avoided.</span></span> <span data-ttu-id="c9a2b-371">См. указанные ниже типы.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-371">See the following types.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#11)]
[!code-vb[c_collection_types_in_data_contracts#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#11)]

<span data-ttu-id="c9a2b-372">В таком случае экземпляру `Marks1` может быть присвоен `testMarks`.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-372">In this case, an instance of `Marks1` can be assigned to `testMarks`.</span></span> <span data-ttu-id="c9a2b-373">Однако `Marks2` не должен использоваться, поскольку его контракт данных рассматривается как эквивалентный контракту данных `IList<int>` .</span><span class="sxs-lookup"><span data-stu-id="c9a2b-373">However, `Marks2` should not be used because its data contract is not considered equivalent to the `IList<int>` data contract.</span></span> <span data-ttu-id="c9a2b-374">Имя контракта данных — "Marks2", а не "аррайофинт", а имя повторяющегося элемента — "\<Mark >", а не "\<int >".</span><span class="sxs-lookup"><span data-stu-id="c9a2b-374">The data contract name is "Marks2" and not "ArrayOfint", and the repeating element name is "\<mark>" and not "\<int>".</span></span>

<span data-ttu-id="c9a2b-375">Правила, приведенные в следующей таблице, применяются к полиморфному назначению коллекций.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-375">The rules in the following table apply to polymorphic assignment of collections.</span></span>

|<span data-ttu-id="c9a2b-376">Объявленный тип</span><span class="sxs-lookup"><span data-stu-id="c9a2b-376">Declared type</span></span>|<span data-ttu-id="c9a2b-377">Назначение ненастроенной коллекции</span><span class="sxs-lookup"><span data-stu-id="c9a2b-377">Assigning a non-customized collection</span></span>|<span data-ttu-id="c9a2b-378">Назначение настроенной коллекции</span><span class="sxs-lookup"><span data-stu-id="c9a2b-378">Assigning a customized collection</span></span>|
|-------------------|--------------------------------------------|---------------------------------------|
|<span data-ttu-id="c9a2b-379">Object</span><span class="sxs-lookup"><span data-stu-id="c9a2b-379">Object</span></span>|<span data-ttu-id="c9a2b-380">Имя контракта сериализовано.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-380">Contract name is serialized.</span></span>|<span data-ttu-id="c9a2b-381">Имя контракта сериализовано.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-381">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="c9a2b-382">Используется настройка.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-382">Customization is used.</span></span>|
|<span data-ttu-id="c9a2b-383">Интерфейс коллекции</span><span class="sxs-lookup"><span data-stu-id="c9a2b-383">Collection interface</span></span>|<span data-ttu-id="c9a2b-384">Имя контракта не сериализовано.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-384">Contract name is not serialized.</span></span>|<span data-ttu-id="c9a2b-385">Имя контракта не сериализовано.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-385">Contract name is not serialized.</span></span><br /><br /> <span data-ttu-id="c9a2b-386">Настройка не используется.\*</span><span class="sxs-lookup"><span data-stu-id="c9a2b-386">Customization is not used.\*</span></span>|
|<span data-ttu-id="c9a2b-387">Ненастроенная коллекция</span><span class="sxs-lookup"><span data-stu-id="c9a2b-387">Non-customized collection</span></span>|<span data-ttu-id="c9a2b-388">Имя контракта не сериализовано.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-388">Contract name is not serialized.</span></span>|<span data-ttu-id="c9a2b-389">Имя контракта сериализовано.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-389">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="c9a2b-390">Используется настройка.\*\*</span><span class="sxs-lookup"><span data-stu-id="c9a2b-390">Customization is used.\*\*</span></span>|
|<span data-ttu-id="c9a2b-391">Настроенная коллекция</span><span class="sxs-lookup"><span data-stu-id="c9a2b-391">Customized collection</span></span>|<span data-ttu-id="c9a2b-392">Имя контракта сериализовано.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-392">Contract name is serialized.</span></span> <span data-ttu-id="c9a2b-393">Настройка не используется.\*\*</span><span class="sxs-lookup"><span data-stu-id="c9a2b-393">Customization is not used.\*\*</span></span>|<span data-ttu-id="c9a2b-394">Имя контракта сериализовано.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-394">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="c9a2b-395">Используется настройка назначенного типа.\*\*</span><span class="sxs-lookup"><span data-stu-id="c9a2b-395">Customization of the assigned type is used.\*\*</span></span>|

<span data-ttu-id="c9a2b-396">\*В этом случае используется настройка класса.<xref:System.Runtime.Serialization.NetDataContractSerializer></span><span class="sxs-lookup"><span data-stu-id="c9a2b-396">\*With the <xref:System.Runtime.Serialization.NetDataContractSerializer> class, customization is used in this case.</span></span> <span data-ttu-id="c9a2b-397">В данном случае класс <xref:System.Runtime.Serialization.NetDataContractSerializer> также сериализует текущее имя типа, т. е. десериализация выполняется так, как ожидалось.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-397">The <xref:System.Runtime.Serialization.NetDataContractSerializer> class also serializes the actual type name in this case, so deserialization works as expected.</span></span>

<span data-ttu-id="c9a2b-398">\*\*Это приводит к созданию недопустимых экземпляров схемы, поэтому их следует избегать.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-398">\*\*These cases result in schema-invalid instances and thus should be avoided.</span></span>

<span data-ttu-id="c9a2b-399">В случаях, когда имя контракта сериализовано, назначенный тип коллекции должен находиться в списке известных типов.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-399">In the cases where the contract name is serialized, the assigned collection type should be in the known types list.</span></span> <span data-ttu-id="c9a2b-400">Также верно и противоположное: в случаях, когда имя не сериализовалось, добавление типа в список известных типов не требуется.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-400">The opposite is also true: in the cases where the name is not serialized, adding the type to the known types list is not required.</span></span>

<span data-ttu-id="c9a2b-401">Массив унаследованного типа может быть соотнесен с массивом базового типа.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-401">An array of a derived type can be assigned to an array of a base type.</span></span> <span data-ttu-id="c9a2b-402">В таком случае имя контракта наследованного типа сериализуется для каждого повторяющегося элемента.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-402">In this case, the contract name for the derived type is serialized for each repeating element.</span></span> <span data-ttu-id="c9a2b-403">Например, если тип `Book` унаследован от типа `LibraryItem`, массив `Book` можно соотнести с массивом `LibraryItem`.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-403">For example, if a type `Book` derives from the type `LibraryItem`, you can assign an array of `Book` to an array of `LibraryItem`.</span></span> <span data-ttu-id="c9a2b-404">Это не распространяется на другие типы коллекций.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-404">This does not apply to other collection types.</span></span> <span data-ttu-id="c9a2b-405">Например, нельзя соотнести `Generic List of Book` с `Generic List of LibraryItem`.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-405">For example, you cannot assign a `Generic List of Book` to a `Generic List of LibraryItem`.</span></span> <span data-ttu-id="c9a2b-406">Можно, однако, соотнести `Generic List of LibraryItem` , содержащий экземпляры `Book` .</span><span class="sxs-lookup"><span data-stu-id="c9a2b-406">You can, however, assign a `Generic List of LibraryItem` that contains `Book` instances.</span></span> <span data-ttu-id="c9a2b-407">В обоих случаях, с массивом и без массива, `Book` должен быть в списке известных типов.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-407">In both the array and the non-array case, `Book` should be in the known types list.</span></span>

## <a name="collections-and-object-reference-preservation"></a><span data-ttu-id="c9a2b-408">Сохранение коллекций и ссылок на объект</span><span class="sxs-lookup"><span data-stu-id="c9a2b-408">Collections and Object Reference Preservation</span></span>

<span data-ttu-id="c9a2b-409">Когда сериализатор работает в режиме сохранения ссылок на объект, сохранение ссылок на объект также распространяется на коллекции.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-409">When a serializer functions in a mode where it preserves object references, object reference preservation also applies to collections.</span></span> <span data-ttu-id="c9a2b-410">В частности, идентичность объекта сохраняется и во всей коллекции, и в отдельных элементах, содержащихся в коллекциях.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-410">Specifically, object identity is preserved for both entire collections and individual items contained in collections.</span></span> <span data-ttu-id="c9a2b-411">В словарях удостоверение объекта сохраняется как в объектах пары ключ-значение, так и в отдельных объектах ключа и значения.</span><span class="sxs-lookup"><span data-stu-id="c9a2b-411">For dictionaries, object identity is preserved both for the key/value pair objects and the individual key and value objects.</span></span>

## <a name="see-also"></a><span data-ttu-id="c9a2b-412">См. также</span><span class="sxs-lookup"><span data-stu-id="c9a2b-412">See also</span></span>

- <xref:System.Runtime.Serialization.CollectionDataContractAttribute>
