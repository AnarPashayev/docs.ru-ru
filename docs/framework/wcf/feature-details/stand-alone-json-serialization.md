---
title: Автономная серия JSON с использованием DataContractJsonSerializer
ms.date: 03/30/2017
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
ms.openlocfilehash: 36945f2d42f22ef3aa4f27bcbe403466f124a279
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79184412"
---
# <a name="stand-alone-json-serialization-using-datacontractjsonserializer"></a>Автономная серия JSON с использованием DataContractJsonSerializer

> [!NOTE]
> Эта статья <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>о . Для большинства сценариев, связанных с сериализуем и десериализизацией JSON, мы рекомендуем AA в [пространстве имен System.Text.Json.](../../../standard/serialization/system-text-json-overview.md)

JSON (JavaScript Object Notation, объектная нотация JavaScript) - формат данных, предназначенный специально для использования JavaScript-кодом, выполняемым на веб-страницах внутри браузера. Это формат данных по умолчанию, используемый ASP.NET службами AJAX, созданными в Фонде связи Windows (WCF).

Его также можно использовать при создании служб AJAX без интеграции с ASP.NET; в данном случае форматом по умолчанию является XML, однако можно выбрать и JSON.

Наконец, если требуется поддержка JSON, однако создаваемая служба не является службой AJAX, сериализатор <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> позволяет непосредственно сериализовать объекты .NET в данные JSON и десериализовать такие данные обратно в экземпляры типов .NET. Для описания того, как это сделать, [см.](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md)

При работе с JSON поддерживаются те же (за некоторыми исключениями) типы .NET, что поддерживаются сериализатором <xref:System.Runtime.Serialization.DataContractSerializer>. Для списка поддерживаемых типов [см.](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md) К ним относится большинство примитивных типов, большинство типов массивов и коллекций, а также сложные типы, в которых используются атрибуты <xref:System.Runtime.Serialization.DataContractAttribute> и <xref:System.Runtime.Serialization.DataMemberAttribute>.

## <a name="mapping-net-types-to-json-types"></a>Сопоставление типов .NET типам JSON

В следующей таблице показано соответствие между типами .NET и типами JSON/JavaScript, используемое при сопоставлении в процедурах сериализации и десериализации.

|Типы .NET|JSON/JavaScript|Примечания|
|----------------|----------------------|-----------|
|Все числовые типы, например <xref:System.Int32>, <xref:System.Decimal> или <xref:System.Double>|Number|Специальные значения, такие как `Double.NaN`, `Double.PositiveInfinity` и `Double.NegativeInfinity`, не поддерживаются и приводят к получению недопустимых JSON-данных.|
|<xref:System.Enum>|Number|См. раздел «Перечисления и JSON» ниже.|
|<xref:System.Boolean>|Логическое|--|
|<xref:System.String>, <xref:System.Char>|Строка|--|
|<xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri>|Строка|Формат этих типов в JSON такой же, как и в XML (по сути, TimeSpan в формате ISO 8601 Продолжительность, GUID в "12345678-ABCD-ABCD-ABCD-1234567890AB" формат и URI в своей естественной форме строки, как "").http://www.example.com Для получения точной информации [см.](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)|
|<xref:System.Xml.XmlQualifiedName>|Строка|Формат - «имя:пространство_имен» (все до первого двоеточия является именем). Имя или пространство имен может отсутствовать. При отсутствии пространства имен можно также опустить двоеточие.|
|<xref:System.Array> типа <xref:System.Byte>|Массив чисел|Каждое число представляет значение одного байта.|
|<xref:System.DateTime>|DateTime или String|См. раздел «Даты-времена и JSON» ниже.|
|<xref:System.DateTimeOffset>|Сложный тип|См. раздел «Даты-времена и JSON» ниже.|
|Типы XML и ADO.NET (<xref:System.Xml.XmlElement>,<br /><br /> <xref:System.Xml.Linq.XElement>. Массивы <xref:System.Xml.XmlNode>,<br /><br /> <xref:System.Runtime.Serialization.ISerializable>,<br /><br /> <xref:System.Data.DataSet>).|Строка|См. раздел «Типы XML и JSON» ниже.|
|<xref:System.DBNull>|Пустой сложный тип|--|
|Коллекции, словари и массивы|Array|См. раздел «Коллекции, словари и массивы» ниже.|
|Сложные типы (с примененным атрибутом <xref:System.Runtime.Serialization.DataContractAttribute> или <xref:System.SerializableAttribute>)|Сложный тип|Элементы данных становятся элементами сложного типа JavaScript.|
|Сложные типы (реализующие интерфейс <xref:System.Runtime.Serialization.ISerializable>)|Сложный тип|Сопоставляется аналогично другим сложным типам, однако некоторые типы <xref:System.Runtime.Serialization.ISerializable> не поддерживаются; см. раздел «Поддержка интерфейса ISerializable» ниже, в разделе «Дополнительные сведения для опытных пользователей».|
|Значение `Null` для любого типа|NULL|Типы, допускающие значение null, также поддерживаются и сопоставляются с JSON так же, как и типы, не допускающие значение null.|

### <a name="enumerations-and-json"></a>Перечисления и JSON

Значения элементов перечислений в JSON рассматриваются как числа в отличие от контрактов данных, куда они включаются как имена элементов. Для получения дополнительной информации о [Enumeration Types in Data Contracts](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md)обработке контрактов данных см.

- Например, в случае перечисления `public enum Color {red, green, blue, yellow, pink}` при сериализации члена `yellow` получается число 3, а не строка "yellow".

- Все члены типа `enum` сериализуемы. Атрибуты <xref:System.Runtime.Serialization.EnumMemberAttribute> и <xref:System.NonSerializedAttribute> (если они используются) игнорируются.

- Также возможна десериализация несуществующего значения `enum` - например, значение 87 можно десериализовать в упомянутое выше перечисление Color, даже несмотря на отсутствие соответствующего определенного имени цвета.

- Флаговый тип `enum` не является особенным и рассматривается так же, как любой другой тип `enum`.

### <a name="datestimes-and-json"></a>Даты-времена и JSON

Формат JSON не предусматривает непосредственной поддержки дат и времен. Тем не менее, они очень часто используются, и в ASP.NET AJAX предусмотрена особая поддержка для этих типов. При использовании прокси-объектов ASP.NET AJAX тип <xref:System.DateTime> в .NET полностью соответствует типу `DateTime` в JavaScript.

- Если ASP.NET не используется, тип <xref:System.DateTime> представляется в JSON в виде строки особого формата, который описан в разделе "Дополнительные сведения для опытных пользователей" ниже.

- <xref:System.DateTimeOffset> представляется в JSON как сложный тип: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}. Член `offsetMinutes` - это смещение местного времени относительно времени по Гринвичу (GMT, теперь также называемого временем в формате UTC), связанное с местоположением интересующего события. Элемент `dateTime` представляет момент во времени, когда произошло интересующее событие (опять этот элемент становится типом `DateTime` в JavaScript, когда используется ASP.NET AJAX, и строкой, когда ASP.NET AJAX не используется). При сериализации член `dateTime` всегда сериализуется в GMT. Так, если описывается время 3:00 по Нью-Йорку, компонентом времени члена `dateTime` будет "8:00", а смещение в минутах `offsetMinutes` составит 300 (минус 300 минут, или 5 часов, относительно GMT).

  > [!NOTE]
  > В объектах <xref:System.DateTime> и <xref:System.DateTimeOffset> при сериализации в JSON информация сохраняется с точностью только до миллисекунд. Значения меньше миллисекунды (микро- и наносекунды) при сериализации теряются.

### <a name="xml-types-and-json"></a>Типы XML и JSON

Типы XML становятся строками JSON.

- Например, если участник данных "q" \<типа XElement содержит abc/>,\<то JSON является "q":" abc/>".

- Существуют некоторые особые правила, определяющие, как XML-данные заключаются в оболочку; более подробные сведения см. в разделе "Дополнительные сведения для опытных пользователей" ниже.

- При использовании ASP.NET AJAX, если вместо строк JavaScript требуется использовать модель DOM XML, присвойте значение «XML» свойству <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> в атрибуте <xref:System.ServiceModel.Web.WebGetAttribute> или свойству <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> в атрибуте <xref:System.ServiceModel.Web.WebInvokeAttribute>.

### <a name="collections-dictionaries-and-arrays"></a>Коллекции, словари и массивы

Все коллекции, словари и массивы представляются в JSON в виде массивов.

- Все пользовательские типы с атрибутом <xref:System.Runtime.Serialization.CollectionDataContractAttribute> в JSON-представлении игнорируются.

- Словари не являются способом непосредственной работы с JSON. Строка\<словаря, объект> не может быть поддержана таким же образом в WCF, как ожидалось от работы с другими технологиями JSON. Например, если в словаре строка "abc" сопоставлена строке "xyz", а строка "def" строке 42, JSON-представление будет иметь вид не {"abc":"xyz","def":42}, а [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}].

- Если требуется работать непосредственно с JSON (обращаться к ключам и значениям динамически, без предварительного определения жесткого контракта), можно рассмотреть следующие варианты.

  - Рассмотрите возможность использования [образца сериализации JSON (AJAX) со слабого типа.](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md)

  - Использование интерфейса <xref:System.Runtime.Serialization.ISerializable> и конструкторов десериализации - эти два механизма позволяют обращаться к парам "ключ-значение" JSON при сериализации и десериализации соответственно, однако не работают в сценариях с частичным доверием.

  - Вместо того, чтобы использовать сериализатор, можно поработать с [картографией между JSON и XML.](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md)

  - *Полиморфизм* в контексте сериализации относится к способности сериализировать производный тип, где ожидается его базовый тип. Существуют особые (только для JSON) правила, применяющиеся при полиморфном использовании коллекций, например при присвоении коллекции объекту <xref:System.Object>. Этот вопрос более подробно рассмотрен в разделе "Дополнительные сведения для опытных пользователей" ниже.

## <a name="additional-details"></a>Дополнительные сведения

### <a name="order-of-data-members"></a>Порядок членов данных

Порядок членов данных при использовании JSON не имеет значения. В частности, даже если задан атрибут <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>, JSON-данные все равно можно сериализовать в любом порядке.

### <a name="json-types"></a>Типы JSON

Тип JSON при десериализации не обязательно должен соответствовать приведенной выше таблице. Например, тип `Int` обычно сопоставляется числу JSON, однако может быть успешно десериализован из строки JSON, при условии, что строка содержит допустимое число. То есть, и {"q":42}, и {"q":"42"} допустимы, если имеется член данных типа `Int` с именем "q".

### <a name="polymorphism"></a>Полиморфизм

Полиморфная сериализация состоит в возможности сериализовать производный тип там, где ожидается его базовый тип. Это поддерживается для JSON сериализации WCF сопоставимы с тем, как XML сериализации поддерживается. `MyDerivedType` Например, можно выписать, где `MyBaseType` это `Int` ожидается, или сериализировать, где `Object` это ожидается.

При десериализации производного типа там, где ожидается базовый тип, информация типа может быть потеряна, за исключением случаев десериализации сложных типов. Например, при сериализации типа <xref:System.Uri> там, где ожидается тип <xref:System.Object>, будет получена строка JSON. Если эту строку затем десериализовать обратно в тип <xref:System.Object>, будет возвращен .NET-тип <xref:System.String>. Десериализатор не знает, что строка изначально имела тип <xref:System.Uri>. Как правило, когда ожидается тип <xref:System.Object>, все строки JSON десериализуются как строки .NET, а все массивы JSON, используемые для сериализации коллекций, словарей и массивов .NET, десериализуются как .NET-объекты <xref:System.Array> типа <xref:System.Object>, вне зависимости от того, какими были исходные типы. Логический тип JSON сопоставляется .NET-типу <xref:System.Boolean>. Однако, когда ожидается тип <xref:System.Object>, числа JSON десериализуются в .NET-типы <xref:System.Int32>, <xref:System.Decimal> или <xref:System.Double> (наиболее подходящий тип выбирается автоматически).

При десериализации в тип интерфейса <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> выполняет десериализацию так, как будто объявленный тип - объект.

При работе со своими собственными базовыми и производными типами обычно требуется использовать атрибуты <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> или эквивалентный механизм. Например, если у вас есть `Animal` операция, которая имеет значение `Cat` возврата, `Animal`и она фактически <xref:System.Runtime.Serialization.KnownTypeAttribute>возвращает экземпляр `Animal` (выведенный из), вы должны либо применить , к <xref:System.ServiceModel.ServiceKnownTypeAttribute> типу или к операции и указать `Cat` тип в этих атрибутах. Для получения дополнительной [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)информации см.

Подробное описание работы полиморфной сериализации и некоторых ограничений, которые необходимо принимать во внимание при ее использовании, см. в разделе "Дополнительные сведения для опытных пользователей" ниже.

### <a name="versioning"></a>Управление версиями

Возможности управления версиями контрактов данных, включая интерфейс <xref:System.Runtime.Serialization.IExtensibleDataObject>, полностью поддерживаются в JSON. Кроме того, в большинстве случаев можно десериализовать тип в один формат (например, XML) и затем сериализовать его в другой формат (например, JSON) и при этом сохранить данные в <xref:System.Runtime.Serialization.IExtensibleDataObject>. Дополнительные сведения о создании контрактов данных, обладающих прямой совместимостью, см. в разделе [Контракты данных, совместимые с любыми будущими изменениями](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md). Следует помнить, что JSON не придает значения порядку, поэтому любая информация о порядке будет потеряна. Кроме того, JSON не поддерживает множественные пары "ключ/значение" с одним и тем же именем ключа. Наконец, все операции над объектом <xref:System.Runtime.Serialization.IExtensibleDataObject> по своей природе полиморфны - то есть, их производные типы присваиваются типу <xref:System.Object>, базовому типу для всех типов.

## <a name="json-in-urls"></a>JSON в URL-адресах

При использовании конечных точек ASP.NET AJAX с командой GET HTTP (с помощью атрибута <xref:System.ServiceModel.Web.WebGetAttribute>), входящие параметры присутствуют в URL-адресе запроса, а не в теле сообщения. JSON поддерживается даже в URL-адресе запроса, `Int` так что если `Person` у вас есть операция, которая занимает называется "число" и сложный тип под названием "p", URL может напоминать следующий URL.

```html
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}
```

При использовании диспетчера скриптов ASP.NET AJAX и прокси-объекта для вызова службы этот URL-адрес автоматически формируется прокси-объектом, и увидеть его нельзя. JSON нельзя использовать в URL-адресах на конечных точках, не являющихся конечными точками ASP.NET AJAX.

## <a name="advanced-information"></a>Дополнительные сведения для опытных пользователей

### <a name="iserializable-support"></a>Поддержка интерфейса ISerializable

#### <a name="supported-and-unsupported-iserializable-types"></a>Поддерживаемые и неподдерживаемые типы ISerializable

Как правило, типы, реализующие интерфейс <xref:System.Runtime.Serialization.ISerializable>, полностью поддерживаются при сериализации/десериализации JSON. Однако некоторые из этих типов (включая некоторые типы платформы .NET Framework) реализованы так, что некоторые аспекты, присущие именно сериализации в JSON, не позволяют им правильно десериализоваться:

- При использовании интерфейса <xref:System.Runtime.Serialization.ISerializable> тип отдельных членов данных никогда не известен заранее. Это ведет к полиморфной ситуации, аналогичной десериализации типов в объект. Как уже говорилось, это может привести к потере информации типов в JSON. Например, если тип сериализует в своей реализации `enum` тип <xref:System.Runtime.Serialization.ISerializable>, попытка десериализовать данные обратно в `enum` (без надлежащих приведений) завершится неудачей, поскольку тип `enum` сериализуется в JSON в виде чисел, а числа JSON десериализуются во встроенные числовые типы .NET (Int32, Decimal или Double). Поэтому тот факт, что число когда-то было значением перечисления (`enum`), теряется.

- Тип с интерфейсом <xref:System.Runtime.Serialization.ISerializable>, конструктор десериализации которого основан на определенном порядке десериализации, также может выдать ошибку при десериализации некоторых JSON-данных, поскольку большинство сериализаторов JSON не гарантируют никакого определенного порядка.

#### <a name="factory-types"></a>Типы производства

В то время как интерфейс <xref:System.Runtime.Serialization.IObjectReference> в общем случае поддерживается в JSON, все типы, требующие возможности "типа производства" (возвращения методом <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> экземпляра типа, отличного от типа, реализующего интерфейс), не поддерживаются.

### <a name="datetime-wire-format"></a>Формат DateTime при передаче по линиям связи

Значения типа <xref:System.DateTime> представляются строками JSON вида "/Date(700000+0500)/", где первое число (в данном случае 700000) - это число миллисекунд в часовом поясе GMT по обычному (не летнему) времени, прошедшее с 1 января 1970 г. Это число может быть отрицательным для представления более раннего времени. Часть строки "+0500" является необязательной и показывает, что это время в формате <xref:System.DateTimeKind.Local>, т. е. при десериализации оно должно быть преобразовано в местный часовой пояс. Если эта часть строки отсутствует, время десериализуется как <xref:System.DateTimeKind.Utc>. Собственно число (в данном случае "0500") и его знак (+ или -) игнорируются.

При сериализации времен формата <xref:System.DateTime>, <xref:System.DateTimeKind.Local> и <xref:System.DateTimeKind.Unspecified> времена записываются со смещением, а время формата <xref:System.DateTimeKind.Utc> записывается без смещения.

JavaScript-код клиента ASP.NET AJAX автоматически преобразует такие строки в экземпляры `DateTime` JavaScript. При наличии других строк аналогичного вида, не принадлежащих к типу <xref:System.DateTime> в .NET, они также преобразуются.

Преобразование происходит только в том случае, если "/" символы\\сбежали (т.е. JSON выглядит как\\" /Date (700000-0500) <xref:System.ServiceModel.WebHttpBinding>/"), и по этой причине кодер JSON WCF (включенный ) всегда избегает "/" символа.

### <a name="xml-in-json-strings"></a>XML-данные в строках JSON

#### <a name="xmlelement"></a>XmlElement

Тип <xref:System.Xml.XmlElement> сериализуется "как есть", без оболочки. Например, член данных "x" типа, <xref:System.Xml.XmlElement> содержащего \<abc/>, представлен следующим образом:

```json
{"x":"<abc/>"}
```

#### <a name="arrays-of-xmlnode"></a>Массивы типа XmlNode

Объекты <xref:System.Array> типа <xref:System.Xml.XmlNode> помещаются в элемент-оболочку ArrayOfXmlNode в стандартном пространстве имен контракта данных для данного типа. Если "x" - массив, содержащий узел атрибута "N" в пространстве имен "ns", который содержит "value", и пустой узел элемента "M", представление выглядит следующим образом.

```json
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}
```

 Атрибуты в пустом пространстве имен в начале массивов XmlNode (перед другими элементами) не поддерживаются.

#### <a name="ixmlserializable-types-including-xelement-and-dataset"></a>Типы IXmlSerializable, включая XElement и DataSet

Типы <xref:System.Runtime.Serialization.ISerializable> делятся на "типы содержимого", "типы DataSet" и "типы элементов". Для определений этих типов см. [XML и ADO.NET Типы в контрактах данных.](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md)

Типы содержимого и типы "DataSet" сериализуются аналогично объектам <xref:System.Array> типа <xref:System.Xml.XmlNode>, рассмотренным в предыдущем разделе. Они помещаются в элемент-оболочку, имя и пространство имен которого соответствует имени контракта данных и пространству имен сериализуемого типа.

Типы элементов, такие как <xref:System.Xml.Linq.XElement> сериализуются "как есть", аналогично рассмотренному выше типу <xref:System.Xml.XmlElement>.

### <a name="polymorphism"></a>Полиморфизм

#### <a name="preserving-type-information"></a>Сохранение информации типов

Как уже говорилось, полиморфизм поддерживается в JSON с некоторыми ограничениями. JavaScript - слабо типизированный язык, и идентификация типа обычно не представляет проблем. Однако при использовании JSON для передачи данных между строго типизированной системой (.NET) и слабо типизированной системой (JavaScript) желательно сохранять удостоверение типа. Например, типы с именами контрактов данных "Square" и "Circle" наследуют от типа с именем контракта данных "Shape". Если значение Circle передается из .NET в JavaScript и возвращается в метод .NET, ожидающий тип Shape, то в компоненте .NET желательно знать, что данный объект изначально принадлежал к типу Circle; в противном случае может быть потеряна информация, присутствующая только в производном типе (например, элемент данных radius в типе Circle).

Для сохранения удостоверения типа при сериализации в JSON сложных типов можно добавить "намек на тип", чтобы десериализатор распознавал этот намек и действовал соответствующим образом. "Подсказка типа" - это пара ключей/значений\_\_JSON с ключевым названием "тип" (два подчеркивания следуют слово "тип"). Значение представляет собой строку JSON вида "DataContractName:DataContractNamespace" (все до первого двоеточия является именем). Продолжая предыдущий пример, тип "Circle" можно сериализовать следующим образом.

```json
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}
```

Намек на тип очень похож на атрибут `xsi:type`, определенный в стандарте XML Schema Instance и используемый при сериализации/десериализации XML.

Члены данных под названием "тип"\_\_запрещены из-за потенциального конфликта с типом подсказки.

#### <a name="reducing-the-size-of-type-hints"></a>Уменьшение размера намеков на тип

Чтобы уменьшить размер сообщений JSON, префикс пространства`http://schemas.datacontract.org/2004/07/`имен по умолчанию () заменяется на символ «К». (Чтобы сделать эту замену обратимой, используется правило побега: если пространство имен\\начинается с символов «К»,\\они прилагаются с дополнительным символом «). Таким образом, если "Круг" является типом в пространстве имен .NET "MyApp.Shapes", то его пространство действия контракта по умолчанию является `http://schemas.datacontract.org/2004/07/MyApp`. Shapes, а его JSON-представление будет иметь следующий вид.

```json
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}
```

И усеченные (#MyApp.формы) иhttp://schemas.datacontract.org/2004/07/MyApp.Shapes) полные (имена понимаются на десериализации.

#### <a name="type-hint-position-in-json-objects"></a>Положение намека на тип в объектах JSON

Обратите внимание, что намек на тип в JSON-представлении должен стоять на первом месте. Это единственный случай, когда порядок пар "ключ/значение" в обработке JSON имеет значение. Например, следующий способ задания намека на тип допустимым не является.

```json
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}
```

Оба <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> используемых WCF и ASP.NET страницы клиента AJAX всегда излучают подсказку типа сперва.

#### <a name="type-hints-apply-only-to-complex-types"></a>Намеки на тип применяются только к сложным типам

Способа выдавать намек на тип для несложных типов не существует. Например, если операция имеет тип возвращаемого значения <xref:System.Object>, однако возвращает тип "Circle", JSON-представление может выглядеть так, как показано выше, и информация типа сохраняется. Однако если возвращается универсальный код ресурса (URI), JSON-представление будет строкой, и тот факт, что строка используется для представления URI, теряется. Это относится не только к примитивным типам, но также к коллекциям и массивам.

#### <a name="when-are-type-hints-emitted"></a>Когда выдается намеки на тип

Намеки на тип могут значительно увеличить размер сообщения (один из способов борьбы с этим - использовать более короткие пространства имен контрактов данных, если это возможно). По этой причине выдача намеков на тип подчиняется следующим правилам.

- При использовании ASP.NET AJAX намеки на тип выдаются всегда, когда это возможно, даже при отсутствии присвоения базовый/производный - например, даже если тип "Circle" присваивается типу "Circle". (Это необходимо, чтобы в полной мере обеспечить возможность вызова из слабо типизированной среды JSON методов строго типизированной среды .NET без неожиданных потерь информации.)

- При использовании служб AJAX без интеграции с ASP.NET намеки на тип выдаются только при наличии присвоения базовый/производный - т. е. когда тип "Circle" присваивается типу "Shape" или типу <xref:System.Object>, но не при присвоении типа "Circle" типу "Circle". Это минимум информации, необходимый для правильной реализации клиента JavaScript, что повышает производительность, но не защищает от потери информации о типах в неправильно спроектированных клиентах. Избегайте присвоений базовый/производный на сервере в принципе, чтобы избежать необходимости решения этой проблемы на клиенте.

- При использовании типа <xref:System.Runtime.Serialization.DataContractSerializer> параметр конструктора `alwaysEmitTypeInformation` позволяет выбрать один из двух упомянутых выше режимов; по умолчанию используется значение "`false`" (выдавать намеки на тип только тогда, когда это необходимо).

#### <a name="duplicate-data-member-names"></a>Повторяющиеся имена членов данных

Информация производного типа присутствует в одном объекте JSON вместе с информацией базового типа и может следовать в любом порядке. Например, `Shape` могут быть представлены следующим образом.

```json
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}
```

При этом тип "Circle" может быть представлен следующим образом.

```json
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}
```

Если `Shape` базовый тип также содержал`radius`элемент данных под названием ", это приводит к столкновению как на сериализации (потому что объекты JSON не могут иметь повторяющиеся ключевые имена) и десериализации (потому что неясно, означает ли "радиус" `Shape.radius` или `Circle.radius`). Следовательно, тогда как использовать принцип "сокрытия свойств" (члены данных с одинаковым именем в базовом и производном классах) в классах контрактов данных обычно не рекомендуется, в случае с JSON его использование прямо запрещено.

#### <a name="polymorphism-and-ixmlserializable-types"></a>Полиморфизм и типы IXmlSerializable

Типы <xref:System.Xml.Serialization.IXmlSerializable> можно полиморфно присваивать друг другу как обычно, при условии выполнения требований "известных типов" в соответствии с обычными правилами контракта данных. Однако сериализация типа <xref:System.Xml.Serialization.IXmlSerializable> вместо типа <xref:System.Object> приводит к потере информации типа, поскольку результатом сериализации является строка JSON.

#### <a name="polymorphism-and-certain-interface-types"></a>Полиморфизм и некоторые типы интерфейсов

Запрещается сериализовать тип коллекции или тип, реализующий интерфейс <xref:System.Xml.Serialization.IXmlSerializable>, там, где ожидается не являющийся коллекцией тип, который не сериализуется с использованием <xref:System.Xml.Serialization.IXmlSerializable> (за исключением <xref:System.Object>). Например, пользовательский `IMyInterface` интерфейс называется и `MyType` тип, который реализует <xref:System.Collections.Generic.IEnumerable%601> как тип `int` и `IMyInterface`. Запрещается возвращаться `MyType` из операции, тип `IMyInterface`возврата которой. Это связано с тем, что `MyType` он должен быть сериализован как массив JSON и требует подсказки типа, и, как указано ранее, не может включать подсказку типа с массивами, только со сложными типами.

#### <a name="known-types-and-configuration"></a>Известные типы и конфигурация

Все механизмы "известных типов", используемые сериализатором <xref:System.Runtime.Serialization.DataContractSerializer>, аналогичным образом поддерживаются сериализатором <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>. Оба serializers читать тот же элемент конфигурации, [ \<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) в [ \<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), чтобы обнаружить известные типы, добавленные через файл конфигурации.

#### <a name="collections-assigned-to-object"></a>Коллекции, присвоенные объекту

Коллекции, присвоенные объекту, сериализуются так, как будто они реализуют интерфейс <xref:System.Collections.Generic.IEnumerable%601>: в виде массива JSON, где каждая запись имеет намек на тип, если это сложный тип. Например, <xref:System.Collections.Generic.List%601> тип, `Shape` присваиваемый <xref:System.Object> следующему, выглядит следующим образом.

```json
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]
```

При десериализации обратно в <xref:System.Object>:

- `Shape`должны быть в списке известных типов. Наличие <xref:System.Collections.Generic.List%601> типа `Shape` в известных типах не имеет эффекта. Обратите внимание, что вам `Shape` не нужно добавлять к известным типам сериализации в этом случае - это делается автоматически.

- Коллекция десериализируется <xref:System.Array> как <xref:System.Object> тип, `Shape` содержащий экземпляры.

#### <a name="derived-collections-assigned-to-base-collections"></a>Производные коллекции, присвоенные базовым коллекциям

При присвоении производной коллекции базовой коллекции коллекция обычно сериализуется так, как если бы она была коллекцией базового типа. В то же время тип элемента производной коллекции нельзя присвоить типу элемента базовой коллекции: вызывается исключение.

#### <a name="type-hints-and-dictionaries"></a>Намеки на тип и словари

При присвоении словаря объекту <xref:System.Object> каждая запись "ключ" и "значение" в словаре рассматривается так, как если бы она была присвоена объекту <xref:System.Object>, и получает намек на тип.

При сериализации типов словарей на объект JSON, содержащий члены "Key" и "Value", не влияет значение параметра `alwaysEmitTypeInformation`: он содержит намек на тип только там, где этого требуют рассмотренные выше правила сериализации коллекций.

### <a name="valid-json-key-names"></a>Допустимые имена ключей JSON

Сериализатор кодирует в XML имена ключей, не являющиеся допустимыми XML-именами. Например, участник данных с именем "123" будет иметь закодированное имя, такое\_\_как "x0031\_\_\_x0032 x0033\_", потому что "123" является недействительным именем элемента XML (начинается с цифры). Аналогичная ситуация может возникнуть с некоторыми международными кодировками, которые не допускаются в XML-именах. Для объяснения этого влияния XML на обработку [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md)JSON см.

## <a name="see-also"></a>См. также раздел

- [Поддержка JSON и других форматов передачи данных](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)
