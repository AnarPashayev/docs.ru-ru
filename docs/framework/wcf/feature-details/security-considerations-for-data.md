---
title: Вопросы безопасности для данных
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: a7eb98da-4a93-4692-8b59-9d670c79ffb2
ms.openlocfilehash: b9b033f779b083be8bcec195caf8e55607f14d31
ms.sourcegitcommit: 7588b1f16b7608bc6833c05f91ae670c22ef56f8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/02/2020
ms.locfileid: "93188319"
---
# <a name="security-considerations-for-data"></a><span data-ttu-id="cd516-102">Вопросы безопасности для данных</span><span class="sxs-lookup"><span data-stu-id="cd516-102">Security Considerations for Data</span></span>

<span data-ttu-id="cd516-103">При работе с данными в Windows Communication Foundation (WCF) необходимо учитывать ряд категорий угроз.</span><span class="sxs-lookup"><span data-stu-id="cd516-103">When dealing with data in Windows Communication Foundation (WCF), you must consider a number of threat categories.</span></span> <span data-ttu-id="cd516-104">В следующем списке показаны наиболее важные классы угроз, связанные с обработкой данных.</span><span class="sxs-lookup"><span data-stu-id="cd516-104">The following list shows the most important threat classes that relate to data processing.</span></span> <span data-ttu-id="cd516-105">WCF предоставляет средства для устранения этих угроз.</span><span class="sxs-lookup"><span data-stu-id="cd516-105">WCF provides tools to mitigate these threats.</span></span>

* <span data-ttu-id="cd516-106">отказ в обслуживании;</span><span class="sxs-lookup"><span data-stu-id="cd516-106">Denial of service</span></span>

  <span data-ttu-id="cd516-107">При получении ненадежных данных они могут заставить получающую сторону задействовать неограниченное количество различных ресурсов, например памяти, потоков, доступных подключений или количества тактов процессора, что приведет к продолжительным расчетам.</span><span class="sxs-lookup"><span data-stu-id="cd516-107">When receiving untrusted data, the data may cause the receiving side to access a disproportionate amount of various resources, such as memory, threads, available connections, or processor cycles by causing lengthy computations.</span></span> <span data-ttu-id="cd516-108">Атака типа "отказ в обслуживании" в отношении сервера может стать причиной его сбоя и невозможности обработки сообщений от других, допустимых клиентов.</span><span class="sxs-lookup"><span data-stu-id="cd516-108">A denial-of-service attack against a server may cause it to crash and be unable to process messages from other, legitimate clients.</span></span>

* <span data-ttu-id="cd516-109">Выполнение вредоносного кода</span><span class="sxs-lookup"><span data-stu-id="cd516-109">Malicious code execution</span></span>

  <span data-ttu-id="cd516-110">Входящие ненадежные данные заставляют получающую сторону выполнить код сторонний код.</span><span class="sxs-lookup"><span data-stu-id="cd516-110">Incoming untrusted data causes the receiving side to run code it did not intend to.</span></span>

* <span data-ttu-id="cd516-111">раскрытие информации;</span><span class="sxs-lookup"><span data-stu-id="cd516-111">Information disclosure</span></span>

  <span data-ttu-id="cd516-112">Удаленный злоумышленник заставляет получающую сторону отвечать на его запросы таким образом, чтобы раскрыть больше информации, чем необходимо.</span><span class="sxs-lookup"><span data-stu-id="cd516-112">The remote attacker forces the receiving party to respond to its requests in such a way as to disclose more information than it intends to.</span></span>

## <a name="user-provided-code-and-code-access-security"></a><span data-ttu-id="cd516-113">Предоставляемый пользователем код и управление доступом для кода</span><span class="sxs-lookup"><span data-stu-id="cd516-113">User-Provided Code and Code Access Security</span></span>

<span data-ttu-id="cd516-114">Несколько мест в инфраструктуре Windows Communication Foundation (WCF) выполняют код, предоставленный пользователем.</span><span class="sxs-lookup"><span data-stu-id="cd516-114">A number of places in the Windows Communication Foundation (WCF) infrastructure run code that is provided by the user.</span></span> <span data-ttu-id="cd516-115">Например, ядро сериализации <xref:System.Runtime.Serialization.DataContractSerializer> может вызывать предоставляемые пользователем методы доступа к свойству `set` и `get` .</span><span class="sxs-lookup"><span data-stu-id="cd516-115">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> serialization engine may call user-provided property `set` accessors and `get` accessors.</span></span> <span data-ttu-id="cd516-116">Инфраструктура WCF Channel также может вызывать предоставляемые пользователем производные классы <xref:System.ServiceModel.Channels.Message> класса.</span><span class="sxs-lookup"><span data-stu-id="cd516-116">The WCF channel infrastructure may also call into user-provided derived classes of the <xref:System.ServiceModel.Channels.Message> class.</span></span>

<span data-ttu-id="cd516-117">Автор кода должен обеспечить отсутствие слабых мест в системе безопасности.</span><span class="sxs-lookup"><span data-stu-id="cd516-117">It is the responsibility of the code author to ensure that no security vulnerabilities exist.</span></span> <span data-ttu-id="cd516-118">Например, при создании типа контракта данных со свойством элемента данных целочисленного типа и при выделении памяти для массива, основанного на значении свойства, в реализации метода доступа `set` , вполне вероятна атака типа "отказ в обслуживании", если во вредоносном сообщении содержится крайне большое значение для этого элемента данных.</span><span class="sxs-lookup"><span data-stu-id="cd516-118">For example, if you create a data contract type with a data member property of type integer, and in the `set` accessor implementation allocate an array based on the property value, you expose the possibility of a denial-of-service attack if a malicious message contains an extremely large value for this data member.</span></span> <span data-ttu-id="cd516-119">В целом следует избегать любого выделения памяти, основанного на входящих данных, или продолжительной обработки в предоставленном пользователем коде (в особенности если причиной продолжительной обработки является небольшой объем входящих данных).</span><span class="sxs-lookup"><span data-stu-id="cd516-119">In general, avoid any allocations based on incoming data or lengthy processing in user-provided code (especially if lengthy processing can be caused by a small amount of incoming data).</span></span> <span data-ttu-id="cd516-120">При выполнении анализа безопасности предоставленного пользователем кода следует также изучить все случаи сбоев (т.е. все ветви кода, в которых вызываются исключения).</span><span class="sxs-lookup"><span data-stu-id="cd516-120">When performing security analysis of user-provided code, make sure to also consider all failure cases (that is, all code branches where exceptions are thrown).</span></span>

<span data-ttu-id="cd516-121">Простым примером кода, предоставленного пользователем, может служить код в реализации службы для каждой операции.</span><span class="sxs-lookup"><span data-stu-id="cd516-121">The ultimate example of user-provided code is the code inside your service implementation for each operation.</span></span> <span data-ttu-id="cd516-122">За безопасность реализации службы отвечает разработчик.</span><span class="sxs-lookup"><span data-stu-id="cd516-122">The security of your service implementation is your responsibility.</span></span> <span data-ttu-id="cd516-123">Существует вероятность случайного создания небезопасных реализаций операций, которые могут стать причиной уязвимости для атак типа "отказ в обслуживании".</span><span class="sxs-lookup"><span data-stu-id="cd516-123">It is easy to inadvertently create insecure operation implementations that may result in denial-of-service vulnerabilities.</span></span> <span data-ttu-id="cd516-124">Например операция, которая принимает строку и возвращает из базы данных список клиентов, чьи имена начинаются с этой строки.</span><span class="sxs-lookup"><span data-stu-id="cd516-124">For example, an operation that takes a string and returns the list of customers from a database whose name starts with that string.</span></span> <span data-ttu-id="cd516-125">Если осуществляется работа с большими базами данных и передаваемая строка представляет собой всего лишь одну букву, код может попытаться создать сообщение, чей размер больше размера всей доступной памяти, что приведет к сбою всей службы.</span><span class="sxs-lookup"><span data-stu-id="cd516-125">If you are working with a large database and the string being passed is just a single letter, your code may attempt to create a message larger than all available memory, causing the entire service to fail.</span></span> <span data-ttu-id="cd516-126">(Элемент <xref:System.OutOfMemoryException> не может быть восстановлен в .NET Framework и всегда приводит к завершению работы приложения.)</span><span class="sxs-lookup"><span data-stu-id="cd516-126">(An <xref:System.OutOfMemoryException> is not recoverable in the .NET Framework and always results in the termination of your application.)</span></span>

<span data-ttu-id="cd516-127">Следует гарантировать, что вредоносный код не попадет в систему в разных точках расширяемости.</span><span class="sxs-lookup"><span data-stu-id="cd516-127">You should ensure that no malicious code is plugged in to the various extensibility points.</span></span> <span data-ttu-id="cd516-128">Это особенно уместно в случае частичного доверия, когда ведется работа с частично доверенными сборками или создаются компоненты, используемые частично доверенным кодом.</span><span class="sxs-lookup"><span data-stu-id="cd516-128">This is especially relevant when running under partial trust, dealing with types from partially-trusted assemblies, or creating components usable by partially-trusted code.</span></span> <span data-ttu-id="cd516-129">Дополнительные сведения см. далее в разделе "Угрозы частично доверенных компонентов".</span><span class="sxs-lookup"><span data-stu-id="cd516-129">For more information, see "Partial Trust Threats" in a later section.</span></span>

<span data-ttu-id="cd516-130">Обратите внимание, что при частичном доверии инфраструктура сериализации контракта данных поддерживает только ограниченный набор модели программирования контрактов данных (например элементы закрытых данных или типы, использующие атрибуты <xref:System.SerializableAttribute> , не поддерживаются).</span><span class="sxs-lookup"><span data-stu-id="cd516-130">Note that when running in partial trust, the data contract serialization infrastructure supports only a limited subset of the data contract programming model - for example, private data members or types using the <xref:System.SerializableAttribute> attribute are not supported.</span></span> <span data-ttu-id="cd516-131">Дополнительные сведения см. в разделе [частичное доверие](partial-trust.md).</span><span class="sxs-lookup"><span data-stu-id="cd516-131">For more information, see [Partial Trust](partial-trust.md).</span></span>

## <a name="avoiding-unintentional-information-disclosure"></a><span data-ttu-id="cd516-132">Предупреждение ненамеренного раскрытия информации</span><span class="sxs-lookup"><span data-stu-id="cd516-132">Avoiding Unintentional Information Disclosure</span></span>

<span data-ttu-id="cd516-133">При разработке сериализуемых типов с учетом безопасности следует обратить внимание на проблему раскрытия информации.</span><span class="sxs-lookup"><span data-stu-id="cd516-133">When designing serializable types with security in mind, information disclosure is a possible concern.</span></span>

<span data-ttu-id="cd516-134">Учтите следующие моменты.</span><span class="sxs-lookup"><span data-stu-id="cd516-134">Consider the following points:</span></span>

- <span data-ttu-id="cd516-135">Модель программирования <xref:System.Runtime.Serialization.DataContractSerializer> допускает раскрытие во время сериализации закрытых и внутренних данных за пределы типа или сборки.</span><span class="sxs-lookup"><span data-stu-id="cd516-135">The <xref:System.Runtime.Serialization.DataContractSerializer> programming model allows the exposure of private and internal data outside of the type or assembly during serialization.</span></span> <span data-ttu-id="cd516-136">Кроме того, во время экспорта схемы возможно раскрытие формы типа.</span><span class="sxs-lookup"><span data-stu-id="cd516-136">Additionally, the shape of a type can be exposed during schema export.</span></span> <span data-ttu-id="cd516-137">Важно понимать проекцию сериализации типа.</span><span class="sxs-lookup"><span data-stu-id="cd516-137">Be sure to understand your type's serialization projection.</span></span> <span data-ttu-id="cd516-138">Чтобы предотвратить раскрытие любой информации, необходимо отключить сериализацию (например не применяя атрибут <xref:System.Runtime.Serialization.DataMemberAttribute> в случае контракта данных).</span><span class="sxs-lookup"><span data-stu-id="cd516-138">If you do not want anything exposed, disable serializing it (for example, by not applying the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute in the case of a data contract).</span></span>

- <span data-ttu-id="cd516-139">Помните, что один и тот же тип может иметь несколько проекций сериализации в зависимости от используемого сериализатора.</span><span class="sxs-lookup"><span data-stu-id="cd516-139">Be aware that the same type may have multiple serialization projections, depending on the serializer in use.</span></span> <span data-ttu-id="cd516-140">Один и тот же тип может раскрывать один набор данных при использовании с <xref:System.Runtime.Serialization.DataContractSerializer> и другой - при использовании с <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="cd516-140">The same type may expose one set of data when used with the <xref:System.Runtime.Serialization.DataContractSerializer> and another set of data when used with the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="cd516-141">Случайное использование неправильного сериализатора может стать причиной раскрытия информации.</span><span class="sxs-lookup"><span data-stu-id="cd516-141">Accidentally using the wrong serializer may lead to information disclosure.</span></span>

- <span data-ttu-id="cd516-142">Использование <xref:System.Xml.Serialization.XmlSerializer> в режиме вызова устаревших удаленных процедур (RPC)/encoded может случайно раскрыть форму графа объекта на отправляющей стороне в отношении получающей стороны.</span><span class="sxs-lookup"><span data-stu-id="cd516-142">Using the <xref:System.Xml.Serialization.XmlSerializer> in legacy remote procedure call (RPC)/encoded mode may unintentionally expose the shape of the object graph on the sending side to the receiving side.</span></span>

## <a name="preventing-denial-of-service-attacks"></a><span data-ttu-id="cd516-143">Предотвращение атак типа "отказ в обслуживании"</span><span class="sxs-lookup"><span data-stu-id="cd516-143">Preventing Denial-of-Service Attacks</span></span>

### <a name="quotas"></a><span data-ttu-id="cd516-144">Квоты</span><span class="sxs-lookup"><span data-stu-id="cd516-144">Quotas</span></span>

<span data-ttu-id="cd516-145">Если получающая сторона выделяет значительный объем памяти, это потенциальная атака типа "отказ в обслуживании".</span><span class="sxs-lookup"><span data-stu-id="cd516-145">Causing the receiving side to allocate a significant amount of memory is a potential denial-of-service attack.</span></span> <span data-ttu-id="cd516-146">Несмотря на то что в этом разделе особое внимание уделяется проблемам потребления памяти, возникающим в случае больших сообщений, также могут возникать и другие атаки.</span><span class="sxs-lookup"><span data-stu-id="cd516-146">While this section concentrates on memory consumption issues arising from large messages, other attacks may occur.</span></span> <span data-ttu-id="cd516-147">Например, сообщения могут требовать неограниченного времени на обработку.</span><span class="sxs-lookup"><span data-stu-id="cd516-147">For example, messages may use a disproportionate amount of processing time.</span></span>

<span data-ttu-id="cd516-148">Атаки типа "отказ в обслуживании" обычно предотвращаются путем использования квот.</span><span class="sxs-lookup"><span data-stu-id="cd516-148">Denial-of-service attacks are usually mitigated using quotas.</span></span> <span data-ttu-id="cd516-149">При превышении квоты, как правило, выдается исключение <xref:System.ServiceModel.QuotaExceededException> .</span><span class="sxs-lookup"><span data-stu-id="cd516-149">When a quota is exceeded, a <xref:System.ServiceModel.QuotaExceededException> exception is normally thrown.</span></span> <span data-ttu-id="cd516-150">Без использования квот вредоносное сообщение может задействовать всю доступную память (что приведет к исключению <xref:System.OutOfMemoryException> ) или все доступные стеки (как следствие - исключение <xref:System.StackOverflowException>).</span><span class="sxs-lookup"><span data-stu-id="cd516-150">Without the quota, a malicious message may cause all available memory to be accessed, resulting in an <xref:System.OutOfMemoryException> exception, or all available stacks to be accessed, resulting in a <xref:System.StackOverflowException>.</span></span>

<span data-ttu-id="cd516-151">В сценарии превышенных квот предусмотрено устранение ошибок. При возникновении ошибки в работающей службе, обрабатываемое в настоящий момент сообщение удаляется, и служба продолжает работать и обрабатывать последующие сообщения.</span><span class="sxs-lookup"><span data-stu-id="cd516-151">The quota exceeded scenario is recoverable; if encountered in a running service, the message currently being processed is discarded and the service keeps running and processes further messages.</span></span> <span data-ttu-id="cd516-152">Однако сценарии нехватки памяти и переполнения стека не могут быть восстановлены в любом месте .NET Framework; служба завершает работу, если она сталкивается с такими исключениями.</span><span class="sxs-lookup"><span data-stu-id="cd516-152">The out-of-memory and stack overflow scenarios, however, are not recoverable anywhere in the .NET Framework; the service terminates if it encounters such exceptions.</span></span>

<span data-ttu-id="cd516-153">Квоты в WCF не требуют предварительного выделения.</span><span class="sxs-lookup"><span data-stu-id="cd516-153">Quotas in WCF do not involve any pre-allocation.</span></span> <span data-ttu-id="cd516-154">Например, если квота <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> (в различных классах) задана как 128 КБ, это не означает, что для каждого сообщения автоматически выделяется 128 КБ.</span><span class="sxs-lookup"><span data-stu-id="cd516-154">For example, if the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota (found on various classes) is set to 128 KB, it does not mean that 128 KB is automatically allocated for each message.</span></span> <span data-ttu-id="cd516-155">Выделяемый объем зависит от фактического размера входящего сообщения.</span><span class="sxs-lookup"><span data-stu-id="cd516-155">The actual amount allocated depends on the actual incoming message size.</span></span>

<span data-ttu-id="cd516-156">На транспортном уровне предусмотрено большое количество квот.</span><span class="sxs-lookup"><span data-stu-id="cd516-156">Many quotas are available at the transport layer.</span></span> <span data-ttu-id="cd516-157">Эти квоты принудительно применяются в соответствии с используемым специальным каналом транспорта (HTTP, TCP и т. д.).</span><span class="sxs-lookup"><span data-stu-id="cd516-157">These are quotas enforced by the specific transport channel in use (HTTP, TCP, and so on).</span></span> <span data-ttu-id="cd516-158">В этом разделе представлено описание только некоторых из этих квот, подробную информацию по квотам см. в разделе [Transport Quotas](transport-quotas.md).</span><span class="sxs-lookup"><span data-stu-id="cd516-158">While this topic discusses some of these quotas, these quotas are described in detail in [Transport Quotas](transport-quotas.md).</span></span>

### <a name="hashtable-vulnerability"></a><span data-ttu-id="cd516-159">Уязвимость, связанная с использованием хэш-таблиц</span><span class="sxs-lookup"><span data-stu-id="cd516-159">Hashtable Vulnerability</span></span>

<span data-ttu-id="cd516-160">Если контракты данных содержат хэш-таблицы или коллекции, возникает потенциальная уязвимость.</span><span class="sxs-lookup"><span data-stu-id="cd516-160">A vulnerability exists when data contracts contain hashtables or collections.</span></span> <span data-ttu-id="cd516-161">Проблема обнаруживается при вставке большого количества значений в хэш-таблицу, если для значительной части этих значений создается одно и то же значение хэша.</span><span class="sxs-lookup"><span data-stu-id="cd516-161">The problem occurs if a large number of values are inserted into a hashtable where a large number of those values generate the same hash value.</span></span> <span data-ttu-id="cd516-162">Это можно использовать для DOS-атаки.</span><span class="sxs-lookup"><span data-stu-id="cd516-162">This can be used as a DOS attack.</span></span>  <span data-ttu-id="cd516-163">Эту уязвимость можно устранить, установив квоту привязки MaxReceivedMessageSize.</span><span class="sxs-lookup"><span data-stu-id="cd516-163">This vulnerability can be mitigated by setting the MaxReceivedMessageSize binding quota.</span></span> <span data-ttu-id="cd516-164">Следует задавать эту квоту с осторожностью, чтобы предотвратить атаки.</span><span class="sxs-lookup"><span data-stu-id="cd516-164">Care must be taken while setting this quota in order to prevent such attacks.</span></span> <span data-ttu-id="cd516-165">Эта квота устанавливает верхний предел на размер сообщения WCF.</span><span class="sxs-lookup"><span data-stu-id="cd516-165">This quota puts an upper limit on the size of WCF message.</span></span> <span data-ttu-id="cd516-166">Кроме того, избегайте использования хэш-таблиц или коллекций в контрактах данных.</span><span class="sxs-lookup"><span data-stu-id="cd516-166">Additionally, avoid using hashtables or collections in your data contracts.</span></span>

## <a name="limiting-memory-consumption-without-streaming"></a><span data-ttu-id="cd516-167">Ограничение потребления памяти без потоковой передачи</span><span class="sxs-lookup"><span data-stu-id="cd516-167">Limiting Memory Consumption Without Streaming</span></span>

<span data-ttu-id="cd516-168">Модель безопасности в отношении больших сообщений зависит от того, используется ли потоковая передача.</span><span class="sxs-lookup"><span data-stu-id="cd516-168">The security model around large messages depends on whether streaming is in use.</span></span> <span data-ttu-id="cd516-169">В основном, в непотоковом случае сообщения буферизуются в память.</span><span class="sxs-lookup"><span data-stu-id="cd516-169">In the basic, non-streamed case, messages are buffered into memory.</span></span> <span data-ttu-id="cd516-170">В этом случае следует использовать квоту <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> в <xref:System.ServiceModel.Channels.TransportBindingElement> или в предоставленных системой привязках, чтобы обеспечить защиту от больших сообщений, ограничив максимальный размер сообщения, для которого выделяется память.</span><span class="sxs-lookup"><span data-stu-id="cd516-170">In this case, use the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota on the <xref:System.ServiceModel.Channels.TransportBindingElement> or on the system-provided bindings to protect against large messages by limiting the maximum message size to access.</span></span> <span data-ttu-id="cd516-171">Обратите внимание, что служба может обрабатывать несколько сообщений одновременно, в таком случае все они находятся в памяти.</span><span class="sxs-lookup"><span data-stu-id="cd516-171">Note that a service may be processing multiple messages at the same time, in which case they are all in memory.</span></span> <span data-ttu-id="cd516-172">Чтобы устранить эту угрозу, необходимо воспользоваться функцией регулирования.</span><span class="sxs-lookup"><span data-stu-id="cd516-172">Use the throttling feature to mitigate this threat.</span></span>

<span data-ttu-id="cd516-173">Также учтите, что `MaxReceivedMessageSize` не задает верхнюю границу на выделение памяти для каждого сообщения, а ограничивает размер памяти постоянным значением.</span><span class="sxs-lookup"><span data-stu-id="cd516-173">Also note that `MaxReceivedMessageSize` does not place an upper bound on per-message memory consumption, but limits it to within a constant factor.</span></span> <span data-ttu-id="cd516-174">Например, если `MaxReceivedMessageSize` равно 1 МБ, и получено и затем десериализовано сообщение размером 1 МБ, для хранения десериализованного графа объекта требуется больший объем памяти, что приводит к общему потреблению памяти больше 1 МБ.</span><span class="sxs-lookup"><span data-stu-id="cd516-174">For example, if the `MaxReceivedMessageSize` is 1 MB and a 1-MB message is received and then deserialized, additional memory is required to contain the deserialized object graph, resulting in total memory consumption well over 1 MB.</span></span> <span data-ttu-id="cd516-175">По этой причине следует избегать создания сериализуемых типов, которые могут стать причиной значительного потребления памяти при небольшом объеме входящих данных.</span><span class="sxs-lookup"><span data-stu-id="cd516-175">For this reason, avoid creating serializable types that could result in significant memory consumption without much incoming data.</span></span> <span data-ttu-id="cd516-176">Например, контракт данных "Миконтракт" с 50 необязательными полями элементов данных и дополнительными закрытыми полями 100 можно создать с помощью конструкции XML " \<MyContract/> ".</span><span class="sxs-lookup"><span data-stu-id="cd516-176">For example, a data contract "MyContract" with 50 optional data member fields and an additional 100 private fields could be instantiated with the XML construction "\<MyContract/>".</span></span> <span data-ttu-id="cd516-177">Такой XML выделяет память для 150 полей.</span><span class="sxs-lookup"><span data-stu-id="cd516-177">This XML results in memory being accessed for 150 fields.</span></span> <span data-ttu-id="cd516-178">Обратите внимание, что по умолчанию элементы данных необязательны.</span><span class="sxs-lookup"><span data-stu-id="cd516-178">Note that data members are optional by default.</span></span> <span data-ttu-id="cd516-179">Проблема усложняется, если такой тип является частью массива.</span><span class="sxs-lookup"><span data-stu-id="cd516-179">The problem is compounded when such a type is part of an array.</span></span>

<span data-ttu-id="cd516-180">Самого по себе`MaxReceivedMessageSize` недостаточно, чтобы избежать всех атак типа "отказ в обслуживании".</span><span class="sxs-lookup"><span data-stu-id="cd516-180">`MaxReceivedMessageSize` alone is not enough to prevent all denial-of-service attacks.</span></span> <span data-ttu-id="cd516-181">Например, десериализатор может принудительно десериализовывать граф объекта с глубоким вложением (объект, содержащий другой объект, который в свою очередь содержит еще один объект, и т. д.) посредством входящего сообщения.</span><span class="sxs-lookup"><span data-stu-id="cd516-181">For example, the deserializer may be forced to deserialize a deeply-nested object graph (an object that contains another object that contains yet another one, and so on) by an incoming message.</span></span> <span data-ttu-id="cd516-182">Чтобы десериализовать такие графы, <xref:System.Runtime.Serialization.DataContractSerializer> и <xref:System.Xml.Serialization.XmlSerializer> вызывают методы вложенным образом.</span><span class="sxs-lookup"><span data-stu-id="cd516-182">Both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer> call methods in a nested way to deserialize such graphs.</span></span> <span data-ttu-id="cd516-183">Глубокое вложение вызовов методов может стать причиной невозможности восстановления <xref:System.StackOverflowException>.</span><span class="sxs-lookup"><span data-stu-id="cd516-183">Deep nesting of method calls may result in an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="cd516-184">Эта угроза устраняется путем настройки квоты <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> с целью ограничения уровня вложений XML, как описано в разделе "Безопасное использование XML" далее в этой теме.</span><span class="sxs-lookup"><span data-stu-id="cd516-184">This threat is mitigated by setting the <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> quota to limit the level of XML nesting, as discussed in the "Using XML Safely" section later in the topic.</span></span>

<span data-ttu-id="cd516-185">Настройка дополнительных квот для `MaxReceivedMessageSize` особенно важна при использовании двоичного кодирования XML.</span><span class="sxs-lookup"><span data-stu-id="cd516-185">Setting additional quotas to `MaxReceivedMessageSize` is especially important when using binary XML encoding.</span></span> <span data-ttu-id="cd516-186">Использование двоичного кодирования в некотором смысле аналогично сжатию: небольшая группа байтов во входящем сообщении может представлять большой объем данных.</span><span class="sxs-lookup"><span data-stu-id="cd516-186">Using binary encoding is somewhat equivalent to compression: a small group of bytes in the incoming message may represent a lot of data.</span></span> <span data-ttu-id="cd516-187">Поэтому даже если сообщение соответствует ограничению `MaxReceivedMessageSize` , для полностью расширенной формы может потребоваться намного больший объем памяти.</span><span class="sxs-lookup"><span data-stu-id="cd516-187">Thus, even a message fitting into the `MaxReceivedMessageSize` limit may take up much more memory in fully expanded form.</span></span> <span data-ttu-id="cd516-188">Чтобы устранить такие угрозы, относящиеся к XML, следует правильно задать все квоты средства чтения XML, как описано в разделе "Безопасное использование XML" далее в этой теме.</span><span class="sxs-lookup"><span data-stu-id="cd516-188">To mitigate such XML-specific threats, all of the XML reader quotas must be set correctly, as discussed in the "Using XML Safely" section later in this topic.</span></span>

## <a name="limiting-memory-consumption-with-streaming"></a><span data-ttu-id="cd516-189">Ограничение потребления памяти с потоковой передачей</span><span class="sxs-lookup"><span data-stu-id="cd516-189">Limiting Memory Consumption with Streaming</span></span>

<span data-ttu-id="cd516-190">При потоковой передаче можно использовать небольшое значение `MaxReceivedMessageSize` , чтобы обеспечить защиту от атак типа "отказ в обслуживании".</span><span class="sxs-lookup"><span data-stu-id="cd516-190">When streaming, you may use a small `MaxReceivedMessageSize` setting to protect against denial-of-service attacks.</span></span> <span data-ttu-id="cd516-191">Однако потоковая передача допускает и более сложные сценарии.</span><span class="sxs-lookup"><span data-stu-id="cd516-191">However, more complicated scenarios are possible with streaming.</span></span> <span data-ttu-id="cd516-192">Например, служба отправки файлов принимает файлы, чей размер большей всей доступной памяти.</span><span class="sxs-lookup"><span data-stu-id="cd516-192">For example, a file upload service accepts files larger than all available memory.</span></span> <span data-ttu-id="cd516-193">В этом случае задайте для `MaxReceivedMessageSize` крайне высокое значение, предполагая, что в память не буферизуется практически никаких данных, и сообщение отправляет потоком непосредственно на диск.</span><span class="sxs-lookup"><span data-stu-id="cd516-193">In this case, set the `MaxReceivedMessageSize` to an extremely large value, expecting that almost no data is buffered in memory and the message streams directly to disk.</span></span> <span data-ttu-id="cd516-194">Если вредоносное сообщение может каким-либо образом принудительно заставить WCF буферизацию данных вместо потоковой передачи в этом случае, `MaxReceivedMessageSize` больше не защищает сообщение, обращающееся к доступной памяти.</span><span class="sxs-lookup"><span data-stu-id="cd516-194">If a malicious message can somehow force WCF to buffer data instead of streaming it in this case, `MaxReceivedMessageSize` no longer protects against the message accessing all available memory.</span></span>

<span data-ttu-id="cd516-195">Чтобы устранить эту угрозу, в различных компонентах обработки данных WCF существуют определенные параметры квоты, ограничивающие буферизацию.</span><span class="sxs-lookup"><span data-stu-id="cd516-195">To mitigate this threat, specific quota settings exist on various WCF data-processing components that limit buffering.</span></span> <span data-ttu-id="cd516-196">Наибольшее значение имеет свойство `MaxBufferSize` для различных элементов привязки транспорта и стандартных привязок.</span><span class="sxs-lookup"><span data-stu-id="cd516-196">The most important of these is the `MaxBufferSize` property on various transport binding elements and standard bindings.</span></span> <span data-ttu-id="cd516-197">При потоковой передаче эта квота должна быть задана с учетом максимального объема памяти, который следует выделить для каждого сообщения.</span><span class="sxs-lookup"><span data-stu-id="cd516-197">When streaming, this quota should be set taking into account the maximum amount of memory you are willing to allocate per message.</span></span> <span data-ttu-id="cd516-198">Как и в случае `MaxReceivedMessageSize`параметр не задает абсолютный максимальный объем потребляемой памяти, а только ограничивает его в пределах определенного диапазона.</span><span class="sxs-lookup"><span data-stu-id="cd516-198">As with `MaxReceivedMessageSize`, the setting does not put an absolute maximum on memory consumption but only limits it to within a constant factor.</span></span> <span data-ttu-id="cd516-199">Кроме того, как и в случае `MaxReceivedMessageSize`помните о возможности одновременной обработки нескольких сообщений.</span><span class="sxs-lookup"><span data-stu-id="cd516-199">Also, as with `MaxReceivedMessageSize`, be aware of the possibility of multiple messages being processed simultaneously.</span></span>

### <a name="maxbuffersize-details"></a><span data-ttu-id="cd516-200">Подробные сведения о MaxBufferSize</span><span class="sxs-lookup"><span data-stu-id="cd516-200">MaxBufferSize Details</span></span>

<span data-ttu-id="cd516-201">`MaxBufferSize`Свойство ограничивает любую небольшую буферизацию WCF.</span><span class="sxs-lookup"><span data-stu-id="cd516-201">The `MaxBufferSize` property limits any bulk buffering WCF does.</span></span> <span data-ttu-id="cd516-202">Например, WCF всегда замещает заголовки SOAP и ошибки SOAP, а также любые части MIME, которые не находятся в естественном порядке чтения в сообщении о механизме оптимизации передачи сообщений (MTOM).</span><span class="sxs-lookup"><span data-stu-id="cd516-202">For example, WCF always buffers SOAP headers and SOAP faults, as well as any MIME parts found to be not in the natural reading order in an Message Transmission Optimization Mechanism (MTOM) message.</span></span> <span data-ttu-id="cd516-203">Этот параметр ограничивает объем буферизации во всех этих случаях.</span><span class="sxs-lookup"><span data-stu-id="cd516-203">This setting limits the amount of buffering in all these cases.</span></span>

<span data-ttu-id="cd516-204">WCF выполняет эту задачу, передавая `MaxBufferSize` значение различным компонентам, которые могут быть помещены в буфер.</span><span class="sxs-lookup"><span data-stu-id="cd516-204">WCF accomplishes this by passing the `MaxBufferSize` value to the various components that may buffer.</span></span> <span data-ttu-id="cd516-205">Например, некоторые перегрузки метода <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> класса <xref:System.ServiceModel.Channels.Message> принимают параметр `maxSizeOfHeaders` .</span><span class="sxs-lookup"><span data-stu-id="cd516-205">For example, some <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> overloads of the <xref:System.ServiceModel.Channels.Message> class take a `maxSizeOfHeaders` parameter.</span></span> <span data-ttu-id="cd516-206">WCF передает `MaxBufferSize` значение этому параметру, чтобы ограничить объем буферизации заголовков SOAP.</span><span class="sxs-lookup"><span data-stu-id="cd516-206">WCF passes the `MaxBufferSize` value to this parameter to limit the amount of SOAP header buffering.</span></span> <span data-ttu-id="cd516-207">Важно задать этот параметр при непосредственном использовании класса <xref:System.ServiceModel.Channels.Message> .</span><span class="sxs-lookup"><span data-stu-id="cd516-207">It is important to set this parameter when using the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="cd516-208">Как правило, при использовании компонента в WCF, который принимает параметры квоты, важно понимать влияние этих параметров на безопасность и правильно задавать их.</span><span class="sxs-lookup"><span data-stu-id="cd516-208">In general, when using a component in WCF that takes quota parameters, it is important to understand the security implications of these parameters and set them correctly.</span></span>

<span data-ttu-id="cd516-209">Кодировщик сообщения MTOM также имеет параметр `MaxBufferSize` .</span><span class="sxs-lookup"><span data-stu-id="cd516-209">The MTOM message encoder also has a `MaxBufferSize` setting.</span></span> <span data-ttu-id="cd516-210">При использовании стандартных привязок он задается автоматически как значение на транспортном уровне `MaxBufferSize` .</span><span class="sxs-lookup"><span data-stu-id="cd516-210">When using standard bindings, this is set automatically to the transport-level `MaxBufferSize` value.</span></span> <span data-ttu-id="cd516-211">Однако при использовании элемента привязки кодировщика сообщения MTOM для создания пользовательской привязки важно задать свойство `MaxBufferSize` как безопасное значение в случае потоковой передачи.</span><span class="sxs-lookup"><span data-stu-id="cd516-211">However, when using the MTOM message encoder binding element to construct a custom binding, it is important to set the `MaxBufferSize` property to a safe value when streaming is used.</span></span>

## <a name="xml-based-streaming-attacks"></a><span data-ttu-id="cd516-212">Атаки при потоковой передаче, основанной на XML</span><span class="sxs-lookup"><span data-stu-id="cd516-212">XML-Based Streaming Attacks</span></span>

<span data-ttu-id="cd516-213">`MaxBufferSize` не достаточно, чтобы обеспечить принудительную буферизацию WCF, когда ожидается потоковая передача.</span><span class="sxs-lookup"><span data-stu-id="cd516-213">`MaxBufferSize` alone is not enough to ensure that WCF cannot be forced into buffering when streaming is expected.</span></span> <span data-ttu-id="cd516-214">Например, средство чтения XML-кода WCF всегда замещает весь начальный тег XML-элемента во время начала чтения нового элемента.</span><span class="sxs-lookup"><span data-stu-id="cd516-214">For example, the WCF XML readers always buffer the entire XML element start tag when starting to read a new element.</span></span> <span data-ttu-id="cd516-215">Это осуществляется для правильной обработки пространств имен и атрибутов.</span><span class="sxs-lookup"><span data-stu-id="cd516-215">This is done so that namespaces and attributes are properly processed.</span></span> <span data-ttu-id="cd516-216">Если `MaxReceivedMessageSize` задан как большой (например, чтобы реализовать сценарий потоковой передачи большого диска непосредственно на диск), может быть создано вредоносное сообщение, в котором все тело сообщения представляет собой большой открывающий тег элемента XML.</span><span class="sxs-lookup"><span data-stu-id="cd516-216">If `MaxReceivedMessageSize` is configured to be large (for example, to enable a direct-to-disk large file streaming scenario), a malicious message may be constructed where the entire message body is a large XML element start tag.</span></span> <span data-ttu-id="cd516-217">Попытка чтения приводит к исключению <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="cd516-217">An attempt to read it results in an <xref:System.OutOfMemoryException>.</span></span> <span data-ttu-id="cd516-218">Это одна из многих возможных атак типа «отказ в обслуживании» на основе XML, которые могут быть устранены с помощью квот модуля чтения XML, как описано в разделе «безопасное использование XML» далее в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="cd516-218">This is one of many possible XML-based denial-of-service attacks that can all be mitigated using XML reader quotas, discussed in the "Using XML Safely" section later in this topic.</span></span> <span data-ttu-id="cd516-219">При потоковой передаче очень важно задать все такие квоты.</span><span class="sxs-lookup"><span data-stu-id="cd516-219">When streaming, it is especially important to set all of these quotas.</span></span>

### <a name="mixing-streaming-and-buffering-programming-models"></a><span data-ttu-id="cd516-220">Совместное использование моделей программирования потоковой передачи и буферизации</span><span class="sxs-lookup"><span data-stu-id="cd516-220">Mixing Streaming and Buffering Programming Models</span></span>

<span data-ttu-id="cd516-221">Причина многих потенциальных атак заключается в совместном использовании моделей программирования потоковой и непотоковой передачи в одной службе.</span><span class="sxs-lookup"><span data-stu-id="cd516-221">Many possible attacks arise from mixing streaming and non-streaming programming models in the same service.</span></span> <span data-ttu-id="cd516-222">Допустим, существует контракт службы с двумя операциями: одна принимает <xref:System.IO.Stream> , а другая - массив какого-либо пользовательского типа.</span><span class="sxs-lookup"><span data-stu-id="cd516-222">Suppose there is a service contract with two operations: one takes a <xref:System.IO.Stream> and another takes an array of some custom type.</span></span> <span data-ttu-id="cd516-223">Также предположим, что для `MaxReceivedMessageSize` задано большое значение, чтобы при первой операции обрабатывались большие потоки.</span><span class="sxs-lookup"><span data-stu-id="cd516-223">Suppose also that `MaxReceivedMessageSize` is set to a large value to enable the first operation to process large streams.</span></span> <span data-ttu-id="cd516-224">К сожалению, это означает, что большие сообщения могут быть отправлены и во вторую операцию, и десериализатор буферизует данные в память как массив до вызова операции.</span><span class="sxs-lookup"><span data-stu-id="cd516-224">Unfortunately, this means that large messages can now be sent to the second operation as well, and the deserializer buffers data in memory as an array before the operation is called.</span></span> <span data-ttu-id="cd516-225">Это потенциальная атака типа "отказ в обслуживании": квота `MaxBufferSize` не ограничивает размер тела сообщения, с которым работает десериализатор.</span><span class="sxs-lookup"><span data-stu-id="cd516-225">This is a potential denial-of-service attack: the `MaxBufferSize` quota does not limit the size of the message body, which is what the deserializer works with.</span></span>

<span data-ttu-id="cd516-226">По этой причине следует избегать совместного использования потоковых и непотоковых операций в одном и том же контракте.</span><span class="sxs-lookup"><span data-stu-id="cd516-226">For this reason, avoid mixing stream-based and non-streamed operations in the same contract.</span></span> <span data-ttu-id="cd516-227">В случае явной необходимости совместного использования обеих моделей программирования следует принять следующие меры предосторожности.</span><span class="sxs-lookup"><span data-stu-id="cd516-227">If you absolutely must mix the two programming models, use the following precautions:</span></span>

- <span data-ttu-id="cd516-228">Выключите функцию <xref:System.Runtime.Serialization.IExtensibleDataObject> , задав свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A><xref:System.ServiceModel.ServiceBehaviorAttribute> как `true`.</span><span class="sxs-lookup"><span data-stu-id="cd516-228">Turn off the <xref:System.Runtime.Serialization.IExtensibleDataObject> feature by setting the <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> property of the <xref:System.ServiceModel.ServiceBehaviorAttribute> to `true`.</span></span> <span data-ttu-id="cd516-229">Это обеспечит десериализацию только элементов, являющихся частью контракта.</span><span class="sxs-lookup"><span data-stu-id="cd516-229">This ensures that only members that are a part of the contract are deserialized.</span></span>

- <span data-ttu-id="cd516-230">Задайте для свойства <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A><xref:System.Runtime.Serialization.DataContractSerializer> безопасное значение.</span><span class="sxs-lookup"><span data-stu-id="cd516-230">Set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property of the <xref:System.Runtime.Serialization.DataContractSerializer> to a safe value.</span></span> <span data-ttu-id="cd516-231">Эта квота также доступна для атрибута <xref:System.ServiceModel.ServiceBehaviorAttribute> или через конфигурацию.</span><span class="sxs-lookup"><span data-stu-id="cd516-231">This quota is also available on the <xref:System.ServiceModel.ServiceBehaviorAttribute> attribute or through configuration.</span></span> <span data-ttu-id="cd516-232">Такая квота ограничивает число объектов, десериализуемых в одном эпизоде десериализации.</span><span class="sxs-lookup"><span data-stu-id="cd516-232">This quota limits the number of objects that are deserialized in one deserialization episode.</span></span> <span data-ttu-id="cd516-233">Как правило, каждый параметр операции или часть тела сообщения в контракте сообщения десериализуется в одном эпизоде.</span><span class="sxs-lookup"><span data-stu-id="cd516-233">Normally, each operation parameter or message body part in a message contract is deserialized in one episode.</span></span> <span data-ttu-id="cd516-234">При десериализации массивов каждая запись массива считается отдельным объектом.</span><span class="sxs-lookup"><span data-stu-id="cd516-234">When deserializing arrays, each array entry is counted as a separate object.</span></span>

- <span data-ttu-id="cd516-235">Задайте для всех квот средства чтения XML безопасные значения.</span><span class="sxs-lookup"><span data-stu-id="cd516-235">Set all of the XML reader quotas to safe values.</span></span> <span data-ttu-id="cd516-236">Обратите внимание на <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>, <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>и <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> и избегайте строк в непотоковых операциях.</span><span class="sxs-lookup"><span data-stu-id="cd516-236">Pay attention to <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>, <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, and <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> and avoid strings in non-streaming operations.</span></span>

- <span data-ttu-id="cd516-237">Просмотрите список известных типов, помня, что каждый из них можно создать в любой момент времени (см. раздел "Предотвращение загрузки непредусмотренных типов" далее в этой теме).</span><span class="sxs-lookup"><span data-stu-id="cd516-237">Review the list of known types, keeping in mind that any one of them can be instantiated at any time (see the "Preventing Unintended Types from Being Loaded" section later in this topic).</span></span>

- <span data-ttu-id="cd516-238">Не используйте какие-либо типы, реализующие интерфейс <xref:System.Xml.Serialization.IXmlSerializable> , который буферизует большой объем данных.</span><span class="sxs-lookup"><span data-stu-id="cd516-238">Do not use any types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface that buffer a lot of data.</span></span> <span data-ttu-id="cd516-239">Не добавляйте такие типы в список известных типов.</span><span class="sxs-lookup"><span data-stu-id="cd516-239">Do not add such types to the list of known types.</span></span>

- <span data-ttu-id="cd516-240">Не используйте массивы <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> , <xref:System.Byte> или типы, реализующие <xref:System.Runtime.Serialization.ISerializable> в контракте.</span><span class="sxs-lookup"><span data-stu-id="cd516-240">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in a contract.</span></span>

- <span data-ttu-id="cd516-241">Не используйте массивы <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> , <xref:System.Byte> или типы, реализующие <xref:System.Runtime.Serialization.ISerializable> в списке известных типов.</span><span class="sxs-lookup"><span data-stu-id="cd516-241">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in the list of known types.</span></span>

<span data-ttu-id="cd516-242">Указанные выше меры предосторожности принимаются, когда непотоковая операция использует <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="cd516-242">The preceding precautions apply when the non-streamed operation uses the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="cd516-243">Запрещается совместное использование потоковых и непотоковых моделей программирования в одной и той же службе, если используется <xref:System.Xml.Serialization.XmlSerializer>, поскольку для него не предусмотрена защита квотой <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> .</span><span class="sxs-lookup"><span data-stu-id="cd516-243">Never mix streaming and non-streaming programming models on the same service if you are using the <xref:System.Xml.Serialization.XmlSerializer>, because it does not have the protection of the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> quota.</span></span>

### <a name="slow-stream-attacks"></a><span data-ttu-id="cd516-244">Атаки типа "медленная потоковая передача"</span><span class="sxs-lookup"><span data-stu-id="cd516-244">Slow Stream Attacks</span></span>

<span data-ttu-id="cd516-245">Класс атак типа "отказ в обслуживании" при потоковой передаче не относится к потреблению памяти.</span><span class="sxs-lookup"><span data-stu-id="cd516-245">A class of streaming denial-of-service attacks does not involve memory consumption.</span></span> <span data-ttu-id="cd516-246">Вместо этого при такой атаке происходит замедление работы отправителя или получателя данных.</span><span class="sxs-lookup"><span data-stu-id="cd516-246">Instead, the attack involves a slow sender or receiver of data.</span></span> <span data-ttu-id="cd516-247">По мере ожидания отправки или получения данных истощаются такие ресурсы, как потоки и доступные подключения.</span><span class="sxs-lookup"><span data-stu-id="cd516-247">While waiting for the data to be sent or received, resources such as threads and available connections are exhausted.</span></span> <span data-ttu-id="cd516-248">Такая ситуация может возникнуть либо в результате вредоносной атаки, либо вследствие допустимого отправителя/получателя с медленным сетевым подключением.</span><span class="sxs-lookup"><span data-stu-id="cd516-248">This situation could arise either as a result of a malicious attack or from a legitimate sender/receiver on a slow network connection.</span></span>

<span data-ttu-id="cd516-249">Чтобы устранить такие атаки, следует правильно задать значения времени ожидания транспорта.</span><span class="sxs-lookup"><span data-stu-id="cd516-249">To mitigate these attacks, set the transport time-outs correctly.</span></span> <span data-ttu-id="cd516-250">Дополнительные сведения см. в разделе [квоты транспорта](transport-quotas.md).</span><span class="sxs-lookup"><span data-stu-id="cd516-250">For more information, see [Transport Quotas](transport-quotas.md).</span></span> <span data-ttu-id="cd516-251">Во вторых, никогда не используйте синхронные `Read` `Write` операции OR при работе с потоками в WCF.</span><span class="sxs-lookup"><span data-stu-id="cd516-251">Secondly, never use synchronous `Read` or `Write` operations when working with streams in WCF.</span></span>

## <a name="using-xml-safely"></a><span data-ttu-id="cd516-252">Безопасное использование XML</span><span class="sxs-lookup"><span data-stu-id="cd516-252">Using XML Safely</span></span>

> [!NOTE]
> <span data-ttu-id="cd516-253">Несмотря на то что этот раздел посвящен XML, информация также относится к документам JavaScript Object Notation (JSON).</span><span class="sxs-lookup"><span data-stu-id="cd516-253">Although this section is about XML, the information also applies to JavaScript Object Notation (JSON) documents.</span></span> <span data-ttu-id="cd516-254">При использовании [Mapping Between JSON and XML](mapping-between-json-and-xml.md)принципы действия квот аналогичны.</span><span class="sxs-lookup"><span data-stu-id="cd516-254">The quotas work similarly, using [Mapping Between JSON and XML](mapping-between-json-and-xml.md).</span></span>

### <a name="secure-xml-readers"></a><span data-ttu-id="cd516-255">Безопасные средства чтения XML</span><span class="sxs-lookup"><span data-stu-id="cd516-255">Secure XML Readers</span></span>

<span data-ttu-id="cd516-256">Информационный набор XML формирует базу обработки всех сообщений в WCF.</span><span class="sxs-lookup"><span data-stu-id="cd516-256">The XML Infoset forms the basis of all message processing in WCF.</span></span> <span data-ttu-id="cd516-257">Во время получения XML-данных из ненадежного источника существует вероятность применения ряда атак типа «отказ в обслуживании», которых следует избегать.</span><span class="sxs-lookup"><span data-stu-id="cd516-257">When accepting XML data from an untrusted source, a number of denial-of-service attack possibilities exist that must be mitigated.</span></span> <span data-ttu-id="cd516-258">WCF предоставляет специальные безопасные средства чтения XML.</span><span class="sxs-lookup"><span data-stu-id="cd516-258">WCF provides special, secure XML readers.</span></span> <span data-ttu-id="cd516-259">Эти модули чтения создаются автоматически при использовании одной из стандартных кодировок в WCF (Text, binary или MTOM).</span><span class="sxs-lookup"><span data-stu-id="cd516-259">These readers are created automatically when using one of the standard encodings in WCF (text, binary, or MTOM).</span></span>

<span data-ttu-id="cd516-260">Некоторые функции безопасности таких средств чтения включены постоянно.</span><span class="sxs-lookup"><span data-stu-id="cd516-260">Some of the security features on these readers are always active.</span></span> <span data-ttu-id="cd516-261">Например, средства чтения никогда не обрабатывают определения типов документа (DTD), которые являются потенциальным источником атак типа "отказ в обслуживании" и ни при каких условиях не должны появляться в допустимых сообщениях SOAP.</span><span class="sxs-lookup"><span data-stu-id="cd516-261">For example, the readers never process document type definitions (DTDs), which are a potential source of denial-of-service attacks and should never appear in legitimate SOAP messages.</span></span> <span data-ttu-id="cd516-262">Другие функции безопасности включают в себя квоты средства чтения, которые должны быть настроены (см. описание в следующем разделе).</span><span class="sxs-lookup"><span data-stu-id="cd516-262">Other security features include reader quotas that must be configured, which are described in the following section.</span></span>

<span data-ttu-id="cd516-263">При работе непосредственно с модулями чтения XML (например, при написании собственного пользовательского кодировщика или при работе непосредственно с <xref:System.ServiceModel.Channels.Message> классом) всегда используйте безопасные средства чтения WCF, если существует вероятность работы с ненадежными данными.</span><span class="sxs-lookup"><span data-stu-id="cd516-263">When working directly with XML readers (such as when writing your own custom encoder or when working directly with the <xref:System.ServiceModel.Channels.Message> class), always use the WCF secure readers when there is a chance of working with untrusted data.</span></span> <span data-ttu-id="cd516-264">Создайте безопасные средства чтения, вызвав одну из перегрузок статического фабричного метода <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>или <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> для класса <xref:System.Xml.XmlDictionaryReader> .</span><span class="sxs-lookup"><span data-stu-id="cd516-264">Create the secure readers by calling one of the static factory method overloads of <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> on the <xref:System.Xml.XmlDictionaryReader> class.</span></span> <span data-ttu-id="cd516-265">При создании средства чтения передайте безопасные значения квот.</span><span class="sxs-lookup"><span data-stu-id="cd516-265">When creating a reader, pass in secure quota values.</span></span> <span data-ttu-id="cd516-266">Не вызывайте перегрузки метода `Create` .</span><span class="sxs-lookup"><span data-stu-id="cd516-266">Do not call the `Create` method overloads.</span></span> <span data-ttu-id="cd516-267">Они не создают средство чтения WCF.</span><span class="sxs-lookup"><span data-stu-id="cd516-267">These do not create a WCF reader.</span></span> <span data-ttu-id="cd516-268">Вместо этого создается средство чтения, не защищенное функциями безопасности, описанными в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="cd516-268">Instead, a reader is created that is not protected by the security features described in this section.</span></span>

### <a name="reader-quotas"></a><span data-ttu-id="cd516-269">Квоты средства чтения</span><span class="sxs-lookup"><span data-stu-id="cd516-269">Reader Quotas</span></span>

<span data-ttu-id="cd516-270">Для безопасных средств чтения XML предусмотрено пять настраиваемых квот.</span><span class="sxs-lookup"><span data-stu-id="cd516-270">The secure XML readers have five configurable quotas.</span></span> <span data-ttu-id="cd516-271">Они, как правило, задаются свойством `ReaderQuotas` для элементов привязки кодирования или стандартных привязок или с помощью объекта <xref:System.Xml.XmlDictionaryReaderQuotas> , передаваемого при создании средства чтения.</span><span class="sxs-lookup"><span data-stu-id="cd516-271">These are normally configured using the `ReaderQuotas` property on the encoding binding elements or standard bindings, or by using an <xref:System.Xml.XmlDictionaryReaderQuotas> object passed when creating a reader.</span></span>

#### <a name="maxbytesperread"></a><span data-ttu-id="cd516-272">MaxBytesPerRead</span><span class="sxs-lookup"><span data-stu-id="cd516-272">MaxBytesPerRead</span></span>

<span data-ttu-id="cd516-273">Эта квота ограничивает число байтов, которые считываются за одну операцию `Read` при чтении открывающего тега элемента и его атрибутов.</span><span class="sxs-lookup"><span data-stu-id="cd516-273">This quota limits the number of bytes that are read in a single `Read` operation when reading the element start tag and its attributes.</span></span> <span data-ttu-id="cd516-274">(В случае непотоковой передачи данных само имя элемента не учитывается в квоте.) <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> важно по следующим причинам.</span><span class="sxs-lookup"><span data-stu-id="cd516-274">(In non-streamed cases, the element name itself is not counted against the quota.) <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> is important for the following reasons:</span></span>

- <span data-ttu-id="cd516-275">Во время чтения имя элемента и его атрибуты всегда буферизуются в память.</span><span class="sxs-lookup"><span data-stu-id="cd516-275">The element name and its attributes are always buffered in memory when they are being read.</span></span> <span data-ttu-id="cd516-276">Поэтому в режиме потоковой передачи важно правильно задать эту квоту, чтобы предотвратить чрезмерную буферизацию, если ожидается потоковая передача.</span><span class="sxs-lookup"><span data-stu-id="cd516-276">Therefore, it is important to set this quota correctly in streaming mode to prevent excessive buffering when streaming is expected.</span></span> <span data-ttu-id="cd516-277">Сведения о фактическом объеме буферизации см. в разделе квоты `MaxDepth` .</span><span class="sxs-lookup"><span data-stu-id="cd516-277">See the `MaxDepth` quota section for information about the actual amount of buffering that takes place.</span></span>

- <span data-ttu-id="cd516-278">Наличие слишком большого числа атрибутов XML может привести к неоправданно большому времени обработки, поскольку требуется проверка уникальности имен атрибутов.</span><span class="sxs-lookup"><span data-stu-id="cd516-278">Having too many XML attributes may use up disproportionate processing time because attribute names have to be checked for uniqueness.</span></span> <span data-ttu-id="cd516-279">`MaxBytesPerRead` устраняет эту возможную проблему.</span><span class="sxs-lookup"><span data-stu-id="cd516-279">`MaxBytesPerRead` mitigates this threat.</span></span>

#### <a name="maxdepth"></a><span data-ttu-id="cd516-280">MaxDepth</span><span class="sxs-lookup"><span data-stu-id="cd516-280">MaxDepth</span></span>

<span data-ttu-id="cd516-281">Эта квота ограничивает максимальную глубину вложенности XML-элементов.</span><span class="sxs-lookup"><span data-stu-id="cd516-281">This quota limits the maximum nesting depth of XML elements.</span></span> <span data-ttu-id="cd516-282">Например, документ " \<A> \<B> \<C/> \</B> \</A> " имеет глубину вложения, равную трем.</span><span class="sxs-lookup"><span data-stu-id="cd516-282">For example, the document "\<A>\<B>\<C/>\</B>\</A>" has a nesting depth of three.</span></span> <span data-ttu-id="cd516-283">Значение<xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> важно по следующим причинам.</span><span class="sxs-lookup"><span data-stu-id="cd516-283"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> is important for the following reasons:</span></span>

- <span data-ttu-id="cd516-284">`MaxDepth` взаимодействует с `MaxBytesPerRead`: средство чтения всегда сохраняет в памяти данные по текущему элементу и всем его предкам, поэтому максимальный потребляемый средством чтения объем памяти пропорционален произведению этих двух параметров.</span><span class="sxs-lookup"><span data-stu-id="cd516-284">`MaxDepth` interacts with `MaxBytesPerRead`: the reader always keeps data in memory for the current element and all of its ancestors, so the maximum memory consumption of the reader is proportional to the product of these two settings.</span></span>

- <span data-ttu-id="cd516-285">При десериализации графа объекта с глубоким вложением десериализатор принудительно получает доступ ко всему стеку, и выдается неисправимое исключение <xref:System.StackOverflowException>.</span><span class="sxs-lookup"><span data-stu-id="cd516-285">When deserializing a deeply-nested object graph, the deserializer is forced to access the entire stack and throw an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="cd516-286">Между вложением XML и вложением объекта существует прямая связь как для <xref:System.Runtime.Serialization.DataContractSerializer> , так и для <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="cd516-286">A direct correlation exists between XML nesting and object nesting for both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="cd516-287">Квота `MaxDepth` позволяет устранить эту угрозу.</span><span class="sxs-lookup"><span data-stu-id="cd516-287">Use `MaxDepth` to mitigate this threat.</span></span>

#### <a name="maxnametablecharcount"></a><span data-ttu-id="cd516-288">MaxNameTableCharCount</span><span class="sxs-lookup"><span data-stu-id="cd516-288">MaxNameTableCharCount</span></span>

<span data-ttu-id="cd516-289">Эта квота ограничивает размер *таблицы имен* средства чтения.</span><span class="sxs-lookup"><span data-stu-id="cd516-289">This quota limits the size of the reader’s *nametable* .</span></span> <span data-ttu-id="cd516-290">В таблице имен содержатся определенные строки (например пространства имен и префиксы), возникающие при обработке документа XML.</span><span class="sxs-lookup"><span data-stu-id="cd516-290">The nametable contains certain strings (such as namespaces and prefixes) that are encountered when processing an XML document.</span></span> <span data-ttu-id="cd516-291">Поскольку эти строки буферизуются в память, задайте эту квоту, чтобы предотвратить чрезмерную буферизацию, если ожидается потоковая передача.</span><span class="sxs-lookup"><span data-stu-id="cd516-291">As these strings are buffered in memory, set this quota to prevent excessive buffering when streaming is expected.</span></span>

#### <a name="maxstringcontentlength"></a><span data-ttu-id="cd516-292">MaxStringContentLength</span><span class="sxs-lookup"><span data-stu-id="cd516-292">MaxStringContentLength</span></span>

<span data-ttu-id="cd516-293">Эта квота ограничивает максимальный размер строки, возвращаемой средством чтения XML.</span><span class="sxs-lookup"><span data-stu-id="cd516-293">This quota limits the maximum string size that the XML reader returns.</span></span> <span data-ttu-id="cd516-294">Эта квота ограничивает потребление памяти не в самом средстве чтения XML, а в компоненте, использующем средство чтения.</span><span class="sxs-lookup"><span data-stu-id="cd516-294">This quota does not limit memory consumption in the XML reader itself, but in the component that is using the reader.</span></span> <span data-ttu-id="cd516-295">Например, когда <xref:System.Runtime.Serialization.DataContractSerializer> использует средство чтения, защищенное <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, он не десериализует строки, чей размер превышает указанное в этой квоте значение.</span><span class="sxs-lookup"><span data-stu-id="cd516-295">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, it does not deserialize strings larger than this quota.</span></span> <span data-ttu-id="cd516-296">При непосредственном использовании класса <xref:System.Xml.XmlDictionaryReader> не все методы учитывают эту квоту, а только те, которые специально созданы для чтения строк, например метод <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> .</span><span class="sxs-lookup"><span data-stu-id="cd516-296">When using the <xref:System.Xml.XmlDictionaryReader> class directly, not all methods respect this quota, but only the methods that are specifically designed to read strings, such as the <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> method.</span></span> <span data-ttu-id="cd516-297">Эта квота не влияет на свойство <xref:System.Xml.XmlReader.Value%2A> средства чтения, и поэтому оно не должно использоваться, если требуется защита, обеспечиваемая этой квотой.</span><span class="sxs-lookup"><span data-stu-id="cd516-297">The <xref:System.Xml.XmlReader.Value%2A> property on the reader is not affected by this quota, and thus should not be used when the protection this quota provides is necessary.</span></span>

#### <a name="maxarraylength"></a><span data-ttu-id="cd516-298">MaxArrayLength</span><span class="sxs-lookup"><span data-stu-id="cd516-298">MaxArrayLength</span></span>

<span data-ttu-id="cd516-299">Эта квота ограничивает максимальный размер массива примитивов, возвращаемых средством чтения XML, включая байтовые массивы.</span><span class="sxs-lookup"><span data-stu-id="cd516-299">This quota limits the maximum size of an array of primitives that the XML reader returns, including byte arrays.</span></span> <span data-ttu-id="cd516-300">Эта квота ограничивает потребление памяти не в самом средстве чтения XML, а в компоненте, использующем средство чтения.</span><span class="sxs-lookup"><span data-stu-id="cd516-300">This quota does not limit memory consumption in the XML reader itself, but in whatever component that is using the reader.</span></span> <span data-ttu-id="cd516-301">Например, когда <xref:System.Runtime.Serialization.DataContractSerializer> использует средство чтения, защищенное <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>, оно не десериализует байтовые массивы, чей размер превышает указанное в этой квоте значение.</span><span class="sxs-lookup"><span data-stu-id="cd516-301">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>, it does not deserialize byte arrays larger than this quota.</span></span> <span data-ttu-id="cd516-302">Важно задать эту квоту при попытке совместного использования моделей программирования потоковой передачи и буферизации в одном контракте.</span><span class="sxs-lookup"><span data-stu-id="cd516-302">It is important to set this quota when attempting to mix streaming and buffered programming models in a single contract.</span></span> <span data-ttu-id="cd516-303">Помните, что при непосредственном использовании класса <xref:System.Xml.XmlDictionaryReader> этой квоте соответствуют только методы, специально созданные для чтения массивов произвольного размера определенных примитивных типов, например <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>.</span><span class="sxs-lookup"><span data-stu-id="cd516-303">Keep in mind that when using the <xref:System.Xml.XmlDictionaryReader> class directly, only the methods that are specifically designed to read arrays of arbitrary size of certain primitive types, such as <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>, respect this quota.</span></span>

## <a name="threats-specific-to-the-binary-encoding"></a><span data-ttu-id="cd516-304">Угрозы, относящиеся к двоичному кодированию</span><span class="sxs-lookup"><span data-stu-id="cd516-304">Threats Specific to the Binary Encoding</span></span>

<span data-ttu-id="cd516-305">Двоичная кодировка XML, поддерживаемая WCF, включает функцию *строк словаря* .</span><span class="sxs-lookup"><span data-stu-id="cd516-305">The binary XML encoding WCF supports includes a *dictionary strings* feature.</span></span> <span data-ttu-id="cd516-306">Большую строку можно закодировать с помощью всего нескольких байтов.</span><span class="sxs-lookup"><span data-stu-id="cd516-306">A large string may be encoded using only a few bytes.</span></span> <span data-ttu-id="cd516-307">В результате значительно повышается производительность, но при этом возникают новые угрозы атак типа "отказ в обслуживании", которые следует устранить.</span><span class="sxs-lookup"><span data-stu-id="cd516-307">This enables significant performance gains, but introduces new denial-of-service threats that must be mitigated.</span></span>

<span data-ttu-id="cd516-308">Существует два вида словарей: *статический* и *динамический* .</span><span class="sxs-lookup"><span data-stu-id="cd516-308">There are two kinds of dictionaries: *static* and *dynamic* .</span></span> <span data-ttu-id="cd516-309">Статический словарь представляет собой встроенный список длинных строк, которые можно представить с помощью короткого кода в двоичном кодировании.</span><span class="sxs-lookup"><span data-stu-id="cd516-309">The static dictionary is a built-in list of long strings that may be represented using a short code in the binary encoding.</span></span> <span data-ttu-id="cd516-310">При создании средства чтения список строк становится постоянным и не подлежит изменению.</span><span class="sxs-lookup"><span data-stu-id="cd516-310">This list of strings is fixed when the reader is created and cannot be modified.</span></span> <span data-ttu-id="cd516-311">Ни одна из строк в статическом словаре, которую WCF использует по умолчанию, достаточно велика, чтобы стать серьезной угрозой отказа в обслуживании, хотя они по-прежнему могут использоваться в атаке расширения словаря.</span><span class="sxs-lookup"><span data-stu-id="cd516-311">None of the strings in the static dictionary that WCF uses by default are sufficiently large to pose a serious denial-of-service threat, although they may still be used in a dictionary expansion attack.</span></span> <span data-ttu-id="cd516-312">В сложных сценариях, в которых используется собственный статический словарь, при вводе больших строк словаря следует соблюдать осторожность.</span><span class="sxs-lookup"><span data-stu-id="cd516-312">In advanced scenarios where you supply your own static dictionary, be careful when introducing large dictionary strings.</span></span>

<span data-ttu-id="cd516-313">Динамические словари позволяют сообщениям определять собственные строки и связывать их с сокращенными кодами.</span><span class="sxs-lookup"><span data-stu-id="cd516-313">The dynamic dictionaries feature allows messages to define their own strings and associate them with short codes.</span></span> <span data-ttu-id="cd516-314">Эти сопоставления "строка-код" хранятся в памяти во время всего сеанса связи, поэтому последующие сообщения не должны повторно отправлять строки и могут использовать уже определенные коды.</span><span class="sxs-lookup"><span data-stu-id="cd516-314">These string-to-code mappings are kept in memory during the entire communication session, such that subsequent messages do not have to resend the strings and can utilize codes that are already defined.</span></span> <span data-ttu-id="cd516-315">Эти строки могут быть произвольной длины, и поэтому представляют более серьезную угрозу по сравнению со строками статического словаря.</span><span class="sxs-lookup"><span data-stu-id="cd516-315">These strings may be of arbitrary length and thus pose a more serious threat than those in the static dictionary.</span></span>

<span data-ttu-id="cd516-316">Первой угрозой, которую следует устранить, является вероятность чрезмерного увеличения размера динамического словаря (таблицы сопоставлений "строка-код").</span><span class="sxs-lookup"><span data-stu-id="cd516-316">The first threat that must be mitigated is the possibility of the dynamic dictionary (the string-to-code mapping table) becoming too large.</span></span> <span data-ttu-id="cd516-317">Такой словарь может расширяться по мере накопления сообщений, а квота `MaxReceivedMessageSize` не обеспечивает защиту, поскольку применяется только к каждому отдельному сообщению.</span><span class="sxs-lookup"><span data-stu-id="cd516-317">This dictionary may be expanded over the course of several messages, and so the `MaxReceivedMessageSize` quota offers no protection because it applies only to each message separately.</span></span> <span data-ttu-id="cd516-318">Поэтому в <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> существует отдельное свойство <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> , ограничивающее размер словаря.</span><span class="sxs-lookup"><span data-stu-id="cd516-318">Therefore, a separate <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> property exists on the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> that limits the size of the dictionary.</span></span>

<span data-ttu-id="cd516-319">В отличие от большинства других эта квота также применяется при записи сообщений.</span><span class="sxs-lookup"><span data-stu-id="cd516-319">Unlike most other quotas, this quota also applies when writing messages.</span></span> <span data-ttu-id="cd516-320">Если она превышается при чтении сообщения, как правило, выдается исключение `QuotaExceededException` .</span><span class="sxs-lookup"><span data-stu-id="cd516-320">If it is exceeded when reading a message, the `QuotaExceededException` is thrown as usual.</span></span> <span data-ttu-id="cd516-321">Если она превышается при записи сообщения, строки, ставшие причиной ее превышения, записываются "как есть", без использования функционала динамических словарей.</span><span class="sxs-lookup"><span data-stu-id="cd516-321">If it is exceeded when writing a message, any strings that cause the quota to be exceeded are written as-is, without using the dynamic dictionaries feature.</span></span>

### <a name="dictionary-expansion-threats"></a><span data-ttu-id="cd516-322">Угрозы типа "расширение словаря"</span><span class="sxs-lookup"><span data-stu-id="cd516-322">Dictionary Expansion Threats</span></span>

<span data-ttu-id="cd516-323">Значительное число атак, относящихся к двоичному формату, относятся к расширению словаря.</span><span class="sxs-lookup"><span data-stu-id="cd516-323">A significant class of binary-specific attacks arises from dictionary expansion.</span></span> <span data-ttu-id="cd516-324">Небольшое сообщение в двоичной форме может стать очень большим сообщением в полностью развернутой текстовой форме, если оно активно использует строковую функцию словарей.</span><span class="sxs-lookup"><span data-stu-id="cd516-324">A small message in binary form may turn into a very large message in fully expanded textual form if it makes extensive use of the string dictionaries feature.</span></span> <span data-ttu-id="cd516-325">Коэффициент расширения строк динамического словаря ограничивается квотой <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> , поскольку строка динамического словаря не превышает максимальный размер всего словаря.</span><span class="sxs-lookup"><span data-stu-id="cd516-325">The expansion factor for dynamic dictionary strings is limited by the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> quota, because no dynamic dictionary string exceeds the maximum size of the entire dictionary.</span></span>

<span data-ttu-id="cd516-326">Свойства <xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>, `MaxStringContentLength`и `MaxArrayLength` ограничивают только потребление памяти.</span><span class="sxs-lookup"><span data-stu-id="cd516-326">The <xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>, `MaxStringContentLength`, and `MaxArrayLength` properties only limit memory consumption.</span></span> <span data-ttu-id="cd516-327">Как правило, они не требуются для устранения каких-либо угроз непотокового использования, поскольку выделение памяти уже ограничено `MaxReceivedMessageSize`.</span><span class="sxs-lookup"><span data-stu-id="cd516-327">They are normally not required to mitigate any threats in the non-streamed usage because memory usage is already limited by `MaxReceivedMessageSize`.</span></span> <span data-ttu-id="cd516-328">Однако `MaxReceivedMessageSize` учитывает байты предварительного расширения.</span><span class="sxs-lookup"><span data-stu-id="cd516-328">However, `MaxReceivedMessageSize` counts pre-expansion bytes.</span></span> <span data-ttu-id="cd516-329">При использовании двоичного кодирования потребление памяти потенциально может выйти за рамки `MaxReceivedMessageSize`, ограничиваясь только <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>.</span><span class="sxs-lookup"><span data-stu-id="cd516-329">When binary encoding is in use, memory consumption could potentially go beyond `MaxReceivedMessageSize`, limited only by a factor of <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>.</span></span> <span data-ttu-id="cd516-330">По этой причине, если используется двоичное кодирование, важно всегда задавать все квоты средства чтения (особенно <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>).</span><span class="sxs-lookup"><span data-stu-id="cd516-330">For this reason, it is important to always set all of the reader quotas (especially <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>) when using the binary encoding.</span></span>

<span data-ttu-id="cd516-331">При использовании двоичного кодирования наряду с <xref:System.Runtime.Serialization.DataContractSerializer>возможно неправильное использование интерфейса `IExtensibleDataObject` , что может вызвать атаку типа "расширение словаря".</span><span class="sxs-lookup"><span data-stu-id="cd516-331">When using binary encoding together with the <xref:System.Runtime.Serialization.DataContractSerializer>, the `IExtensibleDataObject` interface can be misused to mount a dictionary expansion attack.</span></span> <span data-ttu-id="cd516-332">По существу этот интерфейс предоставляет неограниченное пространство для произвольных данных, не являющихся частью контракта.</span><span class="sxs-lookup"><span data-stu-id="cd516-332">This interface essentially provides unlimited storage for arbitrary data that is not a part of the contract.</span></span> <span data-ttu-id="cd516-333">Если невозможно задать достаточно низкие квоты, чтобы произведение `MaxSessionSize` и `MaxReceivedMessageSize` не представляло бы проблемы, при использовании двоичного кодирования отключите функцию `IExtensibleDataObject` .</span><span class="sxs-lookup"><span data-stu-id="cd516-333">If quotas cannot be set low enough such that `MaxSessionSize` multiplied by `MaxReceivedMessageSize` does not pose a problem, disable the `IExtensibleDataObject` feature when using the binary encoding.</span></span> <span data-ttu-id="cd516-334">Задайте для свойства `IgnoreExtensionDataObject` значение `true` для атрибута `ServiceBehaviorAttribute` .</span><span class="sxs-lookup"><span data-stu-id="cd516-334">Set the `IgnoreExtensionDataObject` property to `true` on the `ServiceBehaviorAttribute` attribute.</span></span> <span data-ttu-id="cd516-335">В качестве альтернативы можно не реализовывать интерфейс `IExtensibleDataObject` .</span><span class="sxs-lookup"><span data-stu-id="cd516-335">Alternatively, do not implement the `IExtensibleDataObject` interface.</span></span> <span data-ttu-id="cd516-336">Дополнительные сведения о создании контрактов данных, обладающих прямой совместимостью, см. в разделе [Контракты данных, совместимые с любыми будущими изменениями](forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="cd516-336">For more information, see [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md).</span></span>

### <a name="quotas-summary"></a><span data-ttu-id="cd516-337">Сводка по квотам</span><span class="sxs-lookup"><span data-stu-id="cd516-337">Quotas Summary</span></span>

<span data-ttu-id="cd516-338">В следующей таблице приводятся сводные правила использования квот.</span><span class="sxs-lookup"><span data-stu-id="cd516-338">The following table summarizes the guidance about quotas.</span></span>

|<span data-ttu-id="cd516-339">Условие</span><span class="sxs-lookup"><span data-stu-id="cd516-339">Condition</span></span>|<span data-ttu-id="cd516-340">Важные квоты, которые следует задать</span><span class="sxs-lookup"><span data-stu-id="cd516-340">Important quotas to set</span></span>|
|---------------|-----------------------------|
|<span data-ttu-id="cd516-341">Отсутствие потоковой передачи или потоковая передача небольших сообщений, кодирование text или MTOM</span><span class="sxs-lookup"><span data-stu-id="cd516-341">No streaming or streaming small messages, text, or MTOM encoding</span></span>|<span data-ttu-id="cd516-342">`MaxReceivedMessageSize`, `MaxBytesPerRead` и `MaxDepth`.</span><span class="sxs-lookup"><span data-stu-id="cd516-342">`MaxReceivedMessageSize`, `MaxBytesPerRead`, and `MaxDepth`</span></span>|
|<span data-ttu-id="cd516-343">Отсутствие потоковой передачи или потоковая передача небольших сообщений, двоичное кодирование</span><span class="sxs-lookup"><span data-stu-id="cd516-343">No streaming or streaming small messages, binary encoding</span></span>|<span data-ttu-id="cd516-344">`MaxReceivedMessageSize`, `MaxSessionSize`и все `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="cd516-344">`MaxReceivedMessageSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|
|<span data-ttu-id="cd516-345">Потоковая передача больших сообщений, текстовое кодирование или кодирование MTOM</span><span class="sxs-lookup"><span data-stu-id="cd516-345">Streaming large messages, text, or MTOM encoding</span></span>|<span data-ttu-id="cd516-346">`MaxBufferSize` и все `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="cd516-346">`MaxBufferSize` and all `ReaderQuotas`</span></span>|
|<span data-ttu-id="cd516-347">Потоковая передача больших сообщений, двоичное кодирование</span><span class="sxs-lookup"><span data-stu-id="cd516-347">Streaming large messages, binary encoding</span></span>|<span data-ttu-id="cd516-348">`MaxBufferSize`, `MaxSessionSize`и все `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="cd516-348">`MaxBufferSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|

- <span data-ttu-id="cd516-349">Всегда должны быть заданы значения времени ожидания на транспортном уровне, запрещается синхронное чтение/запись при использовании потоковой передачи независимо от того, какие сообщения передаются потоком: большие или малые.</span><span class="sxs-lookup"><span data-stu-id="cd516-349">Transport-level time-outs must always be set and never use synchronous reads/writes when streaming is in use, regardless of whether you are streaming large or small messages.</span></span>

- <span data-ttu-id="cd516-350">В случае возникновения сомнений в отношении квот задавайте безопасное значение, но не оставляйте их пустыми.</span><span class="sxs-lookup"><span data-stu-id="cd516-350">When in doubt about a quota, set it to a safe value rather than leaving it open.</span></span>

## <a name="preventing-malicious-code-execution"></a><span data-ttu-id="cd516-351">Предотвращение выполнения вредоносного кода</span><span class="sxs-lookup"><span data-stu-id="cd516-351">Preventing Malicious Code Execution</span></span>

<span data-ttu-id="cd516-352">Угрозы следующих общих классов могут выполнять код и приводить к незапланированным последствиям.</span><span class="sxs-lookup"><span data-stu-id="cd516-352">The following general classes of threats can execute code and have unintended effects:</span></span>

- <span data-ttu-id="cd516-353">Десериализатор загружает вредоносный, небезопасный тип или тип, относящийся к безопасности.</span><span class="sxs-lookup"><span data-stu-id="cd516-353">The deserializer loads a malicious, unsafe, or security-sensitive type.</span></span>

- <span data-ttu-id="cd516-354">Входящее сообщение заставляет десериализатор создавать экземпляр безопасного в нормальных условиях типа, который приведет к нежелательным последствиям.</span><span class="sxs-lookup"><span data-stu-id="cd516-354">An incoming message causes the deserializer to construct an instance of a normally safe type in such a way that it has unintended consequences.</span></span>

<span data-ttu-id="cd516-355">В следующих разделах приводится подробное описание таких классов угроз.</span><span class="sxs-lookup"><span data-stu-id="cd516-355">The following sections discuss these classes of threats further.</span></span>

## <a name="datacontractserializer"></a><span data-ttu-id="cd516-356">DataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="cd516-356">DataContractSerializer</span></span>

<span data-ttu-id="cd516-357">(Сведения о безопасности см <xref:System.Xml.Serialization.XmlSerializer> . в соответствующей документации.) Модель безопасности для элемента <xref:System.Xml.Serialization.XmlSerializer> аналогична модели <xref:System.Runtime.Serialization.DataContractSerializer> , и в основном отличается главными деталями.</span><span class="sxs-lookup"><span data-stu-id="cd516-357">(For security information on the <xref:System.Xml.Serialization.XmlSerializer>, see the relevant documentation.) The security model for the <xref:System.Xml.Serialization.XmlSerializer> is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>, and differs mostly in details.</span></span> <span data-ttu-id="cd516-358">Например, для включения типа используется атрибут <xref:System.Xml.Serialization.XmlIncludeAttribute> вместо атрибута <xref:System.Runtime.Serialization.KnownTypeAttribute> .</span><span class="sxs-lookup"><span data-stu-id="cd516-358">For example, the <xref:System.Xml.Serialization.XmlIncludeAttribute> attribute is used for type inclusion instead of the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute.</span></span> <span data-ttu-id="cd516-359">Однако далее в этой теме рассматриваются угрозы, уникальные для <xref:System.Xml.Serialization.XmlSerializer> .</span><span class="sxs-lookup"><span data-stu-id="cd516-359">However, some threats unique to the <xref:System.Xml.Serialization.XmlSerializer> are discussed later in this topic.</span></span>

### <a name="preventing-unintended-types-from-being-loaded"></a><span data-ttu-id="cd516-360">Предотвращение загрузки непредусмотренных типов</span><span class="sxs-lookup"><span data-stu-id="cd516-360">Preventing Unintended Types from Being Loaded</span></span>

<span data-ttu-id="cd516-361">Загрузка непредусмотренных типов может привести к серьезным последствиям, будь этот тип вредоносным или всего лишь косвенно влияющим на безопасность.</span><span class="sxs-lookup"><span data-stu-id="cd516-361">Loading unintended types may have significant consequences, whether the type is malicious or just has security-sensitive side effects.</span></span> <span data-ttu-id="cd516-362">Тип может содержать уязвимость системы безопасности, выполнять действия, относящиеся к безопасности, в конструкторе или конструкторе класса, занимать большой объем памяти, что способствует атакам типа "отказ в обслуживании", или выводить неустранимые исключения.</span><span class="sxs-lookup"><span data-stu-id="cd516-362">A type may contain exploitable security vulnerability, perform security-sensitive actions in its constructor or class constructor, have a large memory footprint that facilitates denial-of-service attacks, or may throw non-recoverable exceptions.</span></span> <span data-ttu-id="cd516-363">Типы могут содержать конструкторы классов, которые начинают работать сразу после загрузки типа и до создания каких-либо экземпляров.</span><span class="sxs-lookup"><span data-stu-id="cd516-363">Types may have class constructors that run as soon as the type is loaded and before any instances are created.</span></span> <span data-ttu-id="cd516-364">По этим причинам важно контролировать набор типов, которые может загружать десериализатор.</span><span class="sxs-lookup"><span data-stu-id="cd516-364">For these reasons, it is important to control the set of types that the deserializer may load.</span></span>

<span data-ttu-id="cd516-365"><xref:System.Runtime.Serialization.DataContractSerializer> выполняет десериализацию слабо связанным образом.</span><span class="sxs-lookup"><span data-stu-id="cd516-365">The <xref:System.Runtime.Serialization.DataContractSerializer> deserializes in a loosely coupled way.</span></span> <span data-ttu-id="cd516-366">Он никогда не считывает тип среды CLR и имена сборок из входящих данных.</span><span class="sxs-lookup"><span data-stu-id="cd516-366">It never reads common language runtime (CLR) type and assembly names from the incoming data.</span></span> <span data-ttu-id="cd516-367">Такое поведение аналогично поведению <xref:System.Xml.Serialization.XmlSerializer>, но отличается от поведения <xref:System.Runtime.Serialization.NetDataContractSerializer>, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>и <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span><span class="sxs-lookup"><span data-stu-id="cd516-367">This is similar to the behavior of the <xref:System.Xml.Serialization.XmlSerializer>, but differs from the behavior of the <xref:System.Runtime.Serialization.NetDataContractSerializer>, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>, and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="cd516-368">Слабое связывание предполагает некоторый уровень безопасности, поскольку удаленный злоумышленник не может указать произвольный тип, чтобы выполнить загрузку только путем именования этого типа в сообщении.</span><span class="sxs-lookup"><span data-stu-id="cd516-368">Loose coupling introduces a degree of safety, because the remote attacker cannot indicate an arbitrary type to load just by naming that type in the message.</span></span>

<span data-ttu-id="cd516-369">Для <xref:System.Runtime.Serialization.DataContractSerializer> всегда разрешено загружать тип, который в текущий момент ожидается в соответствии с контрактом.</span><span class="sxs-lookup"><span data-stu-id="cd516-369">The <xref:System.Runtime.Serialization.DataContractSerializer> is always allowed to load a type that is currently expected according to the contract.</span></span> <span data-ttu-id="cd516-370">Например, если контракт данных содержит элемент данных типа `Customer`, для <xref:System.Runtime.Serialization.DataContractSerializer> разрешено загрузить тип `Customer` , когда он выполняет десериализацию этого элемента данных.</span><span class="sxs-lookup"><span data-stu-id="cd516-370">For example, if a data contract has a data member of type `Customer`, the <xref:System.Runtime.Serialization.DataContractSerializer> is allowed to load the `Customer` type when it deserializes this data member.</span></span>

<span data-ttu-id="cd516-371">Кроме того, <xref:System.Runtime.Serialization.DataContractSerializer> поддерживает полиморфизм.</span><span class="sxs-lookup"><span data-stu-id="cd516-371">Additionally, the <xref:System.Runtime.Serialization.DataContractSerializer> supports polymorphism.</span></span> <span data-ttu-id="cd516-372">Элемент данных может быть объявлен как <xref:System.Object>, но входящие данные могут содержать экземпляр `Customer` .</span><span class="sxs-lookup"><span data-stu-id="cd516-372">A data member may be declared as <xref:System.Object>, but the incoming data may contain a `Customer` instance.</span></span> <span data-ttu-id="cd516-373">Такое возможно только, если тип `Customer` был отмечен для десериализатора как "известный" посредством одного из следующих механизмов:</span><span class="sxs-lookup"><span data-stu-id="cd516-373">This is possible only if the `Customer` type has been made "known" to the deserializer through one of these mechanisms:</span></span>

- <span data-ttu-id="cd516-374">атрибут<xref:System.Runtime.Serialization.KnownTypeAttribute> , примененный к типу;</span><span class="sxs-lookup"><span data-stu-id="cd516-374"><xref:System.Runtime.Serialization.KnownTypeAttribute> attribute applied to a type.</span></span>

- <span data-ttu-id="cd516-375">атрибут`KnownTypeAttribute` , указывающий метод, который возвращает список типов;</span><span class="sxs-lookup"><span data-stu-id="cd516-375">`KnownTypeAttribute` attribute specifying a method that returns a list of types.</span></span>

- <span data-ttu-id="cd516-376">атрибут`ServiceKnownTypeAttribute` .</span><span class="sxs-lookup"><span data-stu-id="cd516-376">`ServiceKnownTypeAttribute` attribute.</span></span>

- <span data-ttu-id="cd516-377">раздел конфигурации `KnownTypes` ;</span><span class="sxs-lookup"><span data-stu-id="cd516-377">The `KnownTypes` configuration section.</span></span>

- <span data-ttu-id="cd516-378">список известных типов, явно переданных в <xref:System.Runtime.Serialization.DataContractSerializer> во время создания при непосредственном использовании сериализатора.</span><span class="sxs-lookup"><span data-stu-id="cd516-378">A list of known types explicitly passed to the <xref:System.Runtime.Serialization.DataContractSerializer> during construction, if using the serializer directly.</span></span>

<span data-ttu-id="cd516-379">Каждый из этих механизмов увеличивает контактную зону, представляя большее число типов, которое может загрузить десериализатор.</span><span class="sxs-lookup"><span data-stu-id="cd516-379">Each of these mechanisms increases the surface area by introducing more types that the deserializer can load.</span></span> <span data-ttu-id="cd516-380">Каждый из этих механизмов требует контроля, чтобы предотвратить добавление вредоносных или непредусмотренных типов в список известных.</span><span class="sxs-lookup"><span data-stu-id="cd516-380">Control each of these mechanisms to ensure no malicious or unintended types are added to the known types list.</span></span>

<span data-ttu-id="cd516-381">Когда известный тип находится в области, его можно загрузить в любой момент времени, и можно создать экземпляры типа, даже если контракт запрещает его фактическое использование.</span><span class="sxs-lookup"><span data-stu-id="cd516-381">Once a known type is in scope, it can be loaded at any time, and instances of the type can be created, even if the contract forbids actually using it.</span></span> <span data-ttu-id="cd516-382">Например, допустим, что тип "MyDangerousType" добавлен в список известных типов с помощью одного из указанных выше механизмов.</span><span class="sxs-lookup"><span data-stu-id="cd516-382">For example, suppose the type "MyDangerousType" is added to the known types list using one of the mechanisms above.</span></span> <span data-ttu-id="cd516-383">Это означает следующее:</span><span class="sxs-lookup"><span data-stu-id="cd516-383">This means that:</span></span>

- <span data-ttu-id="cd516-384">Загружается`MyDangerousType` , и запускается его конструктор класса.</span><span class="sxs-lookup"><span data-stu-id="cd516-384">`MyDangerousType` is loaded and its class constructor runs.</span></span>

- <span data-ttu-id="cd516-385">Даже при десериализации контракта данных с элементом данных строки вредоносное сообщение все равно может создать экземпляр `MyDangerousType` .</span><span class="sxs-lookup"><span data-stu-id="cd516-385">Even when deserializing a data contract with a string data member, a malicious message may still cause an instance of `MyDangerousType` to create.</span></span> <span data-ttu-id="cd516-386">Возможно выполнение кода в `MyDangerousType`(например в методах задания свойств).</span><span class="sxs-lookup"><span data-stu-id="cd516-386">Code in `MyDangerousType`, such as property setters, may run.</span></span> <span data-ttu-id="cd516-387">По окончании десериализатор пытается назначить этот экземпляр для элемента данных строки и завершает работу с выводом исключения.</span><span class="sxs-lookup"><span data-stu-id="cd516-387">After this is done, the deserializer tries to assign this instance to the string data member and fail with an exception.</span></span>

<span data-ttu-id="cd516-388">При записи метода, возвращающего список известных типов, или при передаче списка непосредственно в конструктор <xref:System.Runtime.Serialization.DataContractSerializer> убедитесь, что подготавливающий список код безопасен и работает только с надежными данными.</span><span class="sxs-lookup"><span data-stu-id="cd516-388">When writing a method that returns a list of known types, or when passing a list directly to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor, ensure that the code that prepares the list is secure and operates only on trusted data.</span></span>

<span data-ttu-id="cd516-389">При указании известных типов в конфигурации убедитесь, что файл конфигурации защищен.</span><span class="sxs-lookup"><span data-stu-id="cd516-389">If specifying known types in configuration, ensure that the configuration file is secure.</span></span> <span data-ttu-id="cd516-390">В конфигурации всегда используйте строгие имена (указывая открытый ключ подписанной сборки, в которой расположен тип), но не указывайте версию загружаемого типа.</span><span class="sxs-lookup"><span data-stu-id="cd516-390">Always use strong names in configuration (by specifying the public key of the signed assembly where the type resides), but do not specify the version of the type to load.</span></span> <span data-ttu-id="cd516-391">Загрузчик типов автоматически выбирает последнюю версию, если это возможно.</span><span class="sxs-lookup"><span data-stu-id="cd516-391">The type loader automatically picks the latest version, if possible.</span></span> <span data-ttu-id="cd516-392">Если в конфигурации указана определенная версия, существует следующий риск: тип может иметь уязвимость системы безопасности, которая может быть устранена в следующей версии, но версия с уязвимостью все равно выполняет загрузку, поскольку она явно указана в конфигурации.</span><span class="sxs-lookup"><span data-stu-id="cd516-392">If you specify a particular version in configuration, you run the following risk: A type may have a security vulnerability that may be fixed in a future version, but the vulnerable version still loads because it is explicitly specified in configuration.</span></span>

<span data-ttu-id="cd516-393">При наличии слишком большого числа известных типов возникает другое следствие: <xref:System.Runtime.Serialization.DataContractSerializer> создает кэш кода сериализации/десериализации в домене приложения с записью для каждого типа, который требуется сериализовать или десериализовать.</span><span class="sxs-lookup"><span data-stu-id="cd516-393">Having too many known types has another consequence: The <xref:System.Runtime.Serialization.DataContractSerializer> creates a cache of serialization/deserialization code in the application domain, with an entry for each type it must serialize and deserialize.</span></span> <span data-ttu-id="cd516-394">Этот кэш никогда не очищается, пока работает домен приложения.</span><span class="sxs-lookup"><span data-stu-id="cd516-394">This cache is never cleared as long as the application domain is running.</span></span> <span data-ttu-id="cd516-395">Поэтому злоумышленник, знающий, что приложение использует большое число известных типов, может вызвать десериализацию всех этих типов, в результате чего кэш будет использовать неограниченный объем памяти.</span><span class="sxs-lookup"><span data-stu-id="cd516-395">Therefore, an attacker who is aware that an application uses many known types can cause the deserialization of all these types, causing the cache to consume a disproportionately large amount of memory.</span></span>

### <a name="preventing-types-from-being-in-an-unintended-state"></a><span data-ttu-id="cd516-396">Избежание непредусмотренного состояния типов</span><span class="sxs-lookup"><span data-stu-id="cd516-396">Preventing Types from Being in an Unintended State</span></span>

<span data-ttu-id="cd516-397">Тип может иметь внутренние ограничения согласованности, которые обязательны к соблюдению.</span><span class="sxs-lookup"><span data-stu-id="cd516-397">A type may have internal consistency constraints that must be enforced.</span></span> <span data-ttu-id="cd516-398">Следует соблюдать осторожность, чтобы не нарушить эти ограничения во время десериализации.</span><span class="sxs-lookup"><span data-stu-id="cd516-398">Care must be taken to avoid breaking these constraints during deserialization.</span></span>

<span data-ttu-id="cd516-399">В следующем примере типа представлено состояние шлюза космического корабля и соблюдение ограничения, при котором внутренняя и внешняя двери не могут быть открыты одновременно.</span><span class="sxs-lookup"><span data-stu-id="cd516-399">The following example of a type represents the state of an airlock on a spacecraft, and enforces the constraint that both the inner and the outer doors cannot be open at the same time.</span></span>

[!code-csharp[DataContractAttribute#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#3)]
[!code-vb[DataContractAttribute#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#3)]

<span data-ttu-id="cd516-400">Злоумышленник может отправить вредоносное сообщение наподобие этого, обойти ограничения и привести объект в недопустимое состояние, результатом чего будут непредусмотренные и непредсказуемые последствия.</span><span class="sxs-lookup"><span data-stu-id="cd516-400">An attacker may send a malicious message like this, getting around the constraints and getting the object into an invalid state, which may have unintended and unpredictable consequences.</span></span>

```xml
<SpaceStationAirlock>
    <innerDoorOpen>true</innerDoorOpen>
    <outerDoorOpen>true</outerDoorOpen>
</SpaceStationAirlock>
```

<span data-ttu-id="cd516-401">Такой ситуации можно избежать, если учитывать следующие моменты.</span><span class="sxs-lookup"><span data-stu-id="cd516-401">This situation can be avoided by being aware of the following points:</span></span>

- <span data-ttu-id="cd516-402">Когда <xref:System.Runtime.Serialization.DataContractSerializer> десериализует большинство классов, конструкторы не работают.</span><span class="sxs-lookup"><span data-stu-id="cd516-402">When the <xref:System.Runtime.Serialization.DataContractSerializer> deserializes most classes, constructors do not run.</span></span> <span data-ttu-id="cd516-403">Поэтому не следует полагаться на какое-либо управление состоянием, осуществленное в конструкторе.</span><span class="sxs-lookup"><span data-stu-id="cd516-403">Therefore, do not rely on any state management done in the constructor.</span></span>

- <span data-ttu-id="cd516-404">Чтобы убедиться в действительном состоянии объекта, используйте обратные вызовы.</span><span class="sxs-lookup"><span data-stu-id="cd516-404">Use callbacks to ensure that the object is in a valid state.</span></span> <span data-ttu-id="cd516-405">Обратный вызов, отмеченный атрибутом <xref:System.Runtime.Serialization.OnDeserializedAttribute> , особенно полезен, поскольку он запускается по завершении сериализации и позволяет изучить и исправить общее состояние.</span><span class="sxs-lookup"><span data-stu-id="cd516-405">The callback marked with the <xref:System.Runtime.Serialization.OnDeserializedAttribute> attribute is especially useful because it runs after deserialization is complete and has a chance to examine and correct the overall state.</span></span> <span data-ttu-id="cd516-406">Дополнительные сведения см. в разделе [обратные вызовы сериализации с поддержкой версий](version-tolerant-serialization-callbacks.md).</span><span class="sxs-lookup"><span data-stu-id="cd516-406">For more information, see [Version-Tolerant Serialization Callbacks](version-tolerant-serialization-callbacks.md).</span></span>

- <span data-ttu-id="cd516-407">Не создавайте типы контрактов данных, полагаясь на какой-либо определенный порядок, в котором требуется вызов методов задания свойств.</span><span class="sxs-lookup"><span data-stu-id="cd516-407">Do not design data contract types to rely on any particular order in which property setters must be called.</span></span>

- <span data-ttu-id="cd516-408">Соблюдайте осторожность при использовании устаревших типов, отмеченных атрибутом <xref:System.SerializableAttribute> .</span><span class="sxs-lookup"><span data-stu-id="cd516-408">Take care using legacy types marked with the <xref:System.SerializableAttribute> attribute.</span></span> <span data-ttu-id="cd516-409">Многие из них предназначены для работы с .NET Framework удаленным взаимодействием для использования только с доверенными данными.</span><span class="sxs-lookup"><span data-stu-id="cd516-409">Many of them were designed to work with .NET Framework remoting for use with trusted data only.</span></span> <span data-ttu-id="cd516-410">Существующие типы, отмеченные этим атрибутом, могут быть созданы и без учета обеспечения безопасности состояния.</span><span class="sxs-lookup"><span data-stu-id="cd516-410">Existing types marked with this attribute may not have been designed with state safety in mind.</span></span>

- <span data-ttu-id="cd516-411">Чтобы гарантировать наличие данных с учетом обеспечения безопасности состояния, не следует полагаться на свойство <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> атрибута <xref:System.Runtime.Serialization.DataMemberAttribute> .</span><span class="sxs-lookup"><span data-stu-id="cd516-411">Do not rely on the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to guarantee presence of data as far as state safety is concerned.</span></span> <span data-ttu-id="cd516-412">Данные всегда могут быть `null`, `zero`или `invalid`.</span><span class="sxs-lookup"><span data-stu-id="cd516-412">Data could always be `null`, `zero`, or `invalid`.</span></span>

- <span data-ttu-id="cd516-413">Никогда не доверяйте графу объекта, десериализованному из источника ненадежных данных, не определив сначала его действительность.</span><span class="sxs-lookup"><span data-stu-id="cd516-413">Never trust an object graph deserialized from an untrusted data source without validating it first.</span></span> <span data-ttu-id="cd516-414">Каждый отдельный объект может находиться в согласованном состоянии, однако весь граф объекта в таком состоянии может и не находиться.</span><span class="sxs-lookup"><span data-stu-id="cd516-414">Each individual object may be in a consistent state, but the object graph as a whole may not be.</span></span> <span data-ttu-id="cd516-415">Более того, даже если выключен режим сохранения графа объекта, десериализованный граф может содержать несколько ссылок на небольшой объект или содержать циклические ссылки.</span><span class="sxs-lookup"><span data-stu-id="cd516-415">Furthermore, even if the object graph preservation mode is disabled, the deserialized graph may have multiple references to the same object or have circular references.</span></span> <span data-ttu-id="cd516-416">Дополнительные сведения см. в разделе [сериализация и десериализация](serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="cd516-416">For more information, see [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

### <a name="using-the-netdatacontractserializer-securely"></a><span data-ttu-id="cd516-417">Безопасное использование NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="cd516-417">Using the NetDataContractSerializer Securely</span></span>

<span data-ttu-id="cd516-418"><xref:System.Runtime.Serialization.NetDataContractSerializer> представляет собой ядро сериализации, использующее тесное соединение с типами.</span><span class="sxs-lookup"><span data-stu-id="cd516-418">The <xref:System.Runtime.Serialization.NetDataContractSerializer> is a serialization engine that uses tight coupling to types.</span></span> <span data-ttu-id="cd516-419">Это аналогично <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> и <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span><span class="sxs-lookup"><span data-stu-id="cd516-419">This is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="cd516-420">То есть он определяет, какой тип следует создать, путем считывания .NET Framework сборки и имени типа из входящих данных.</span><span class="sxs-lookup"><span data-stu-id="cd516-420">That is, it determines which type to instantiate by reading the .NET Framework assembly and type name from the incoming data.</span></span> <span data-ttu-id="cd516-421">Хотя это и является частью WCF, не существует способа подключения этого механизма сериализации. необходимо написать пользовательский код.</span><span class="sxs-lookup"><span data-stu-id="cd516-421">Although it is a part of WCF, there is no supplied way of plugging in this serialization engine; custom code must be written.</span></span> <span data-ttu-id="cd516-422">`NetDataContractSerializer`Предоставляется в основном для упрощения миграции с .NET Framework удаленного взаимодействия в WCF.</span><span class="sxs-lookup"><span data-stu-id="cd516-422">The `NetDataContractSerializer` is provided primarily to ease migration from .NET Framework remoting to WCF.</span></span> <span data-ttu-id="cd516-423">Дополнительные сведения см. в соответствующем разделе, посвященном [сериализации и десериализации](serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="cd516-423">For more information, see the relevant section in [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

<span data-ttu-id="cd516-424">Поскольку само сообщение может указывать любой тип, который можно загрузить, механизм <xref:System.Runtime.Serialization.NetDataContractSerializer> по своей природе небезопасен и должен использоваться только с надежными данными.</span><span class="sxs-lookup"><span data-stu-id="cd516-424">Because the message itself may indicate any type can be loaded, the <xref:System.Runtime.Serialization.NetDataContractSerializer> mechanism is inherently insecure and should be used only with trusted data.</span></span> <span data-ttu-id="cd516-425">Дополнительные сведения см. в разделе [BinaryFormatter Security Guide](../../../standard/serialization/binaryformatter-security-guide.md).</span><span class="sxs-lookup"><span data-stu-id="cd516-425">For more information, see the [BinaryFormatter security guide](../../../standard/serialization/binaryformatter-security-guide.md).</span></span>

<span data-ttu-id="cd516-426">Даже при использовании с надежными данными входящие данные могут недостаточно точно указывать загружаемый тип, особенно если свойство <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> задано как <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>.</span><span class="sxs-lookup"><span data-stu-id="cd516-426">Even when used with trusted data, the incoming data may insufficiently specify the type to load, especially if the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property is set to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>.</span></span> <span data-ttu-id="cd516-427">Любой, у кого есть доступ к каталогу приложения или глобальному кэшу сборок, может заменить один из загружаемых типов вредоносным.</span><span class="sxs-lookup"><span data-stu-id="cd516-427">Anyone with access to the application’s directory or to the global assembly cache can substitute a malicious type in place of the one that is supposed to load.</span></span> <span data-ttu-id="cd516-428">Всегда защищайте каталог приложения и глобальный кэш сборок, правильно назначая разрешения.</span><span class="sxs-lookup"><span data-stu-id="cd516-428">Always ensure the security of your application’s directory and of the global assembly cache by correctly setting permissions.</span></span>

<span data-ttu-id="cd516-429">В общем, если открыть для частично доверенного кода доступ к своему экземпляру `NetDataContractSerializer` или иным образом разрешить ему управление суррогатным селектором (<xref:System.Runtime.Serialization.ISurrogateSelector>) или связывателем сериализации (<xref:System.Runtime.Serialization.SerializationBinder>), код может получить значительные возможности управления процессом сериализации/десериализации.</span><span class="sxs-lookup"><span data-stu-id="cd516-429">In general, if you allow partially trusted code access to your `NetDataContractSerializer` instance or otherwise control the surrogate selector (<xref:System.Runtime.Serialization.ISurrogateSelector>) or the serialization binder (<xref:System.Runtime.Serialization.SerializationBinder>), the code may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="cd516-430">Например, он может ввести произвольные типы, привести к раскрытию информации, подделать получаемый граф объекта или сериализованные данные или переполнить итоговый сериализованный поток.</span><span class="sxs-lookup"><span data-stu-id="cd516-430">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span>

<span data-ttu-id="cd516-431">Еще одним вопросом безопасности, связанным с `NetDataContractSerializer` , является отказ от обслуживания, не угроза выполнения вредоносного кода.</span><span class="sxs-lookup"><span data-stu-id="cd516-431">Another security concern with the `NetDataContractSerializer` is a denial of service, not a malicious code execution threat.</span></span> <span data-ttu-id="cd516-432">При использовании `NetDataContractSerializer`всегда задавайте для квоты <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> безопасное значение.</span><span class="sxs-lookup"><span data-stu-id="cd516-432">When using the `NetDataContractSerializer`, always set the <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> quota to a safe value.</span></span> <span data-ttu-id="cd516-433">Очень просто создать небольшое вредоносное сообщение, выделяющее массив объектов, чей размер ограничен только этой квотой.</span><span class="sxs-lookup"><span data-stu-id="cd516-433">It is easy to construct a small malicious message that allocates an array of objects whose size is limited only by this quota.</span></span>

### <a name="xmlserializer-specific-threats"></a><span data-ttu-id="cd516-434">Угрозы, связанные с XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="cd516-434">XmlSerializer-Specific Threats</span></span>

<span data-ttu-id="cd516-435">Модель безопасности <xref:System.Xml.Serialization.XmlSerializer> аналогична модели <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="cd516-435">The <xref:System.Xml.Serialization.XmlSerializer> security model is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="cd516-436">Однако существует несколько угроз, уникальных для <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="cd516-436">A few threats, however, are unique to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>

<span data-ttu-id="cd516-437"><xref:System.Xml.Serialization.XmlSerializer> во время выполнения создает *сборки сериализации* , содержащие код, который фактически выполняет сериализацию и десериализацию. Эти сборки создаются в каталоге временных файлов.</span><span class="sxs-lookup"><span data-stu-id="cd516-437">The <xref:System.Xml.Serialization.XmlSerializer> generates *serialization assemblies* at runtime that contain code that actually serializes and deserializes; these assemblies are created in a temporary files directory.</span></span> <span data-ttu-id="cd516-438">Если любой другой процесс или пользователь получают доступ к этому каталогу, он может перезаписать код сериализации/десериализации произвольным кодом.</span><span class="sxs-lookup"><span data-stu-id="cd516-438">If some other process or user has access rights to that directory, they may overwrite the serialization/deserialization code with arbitrary code.</span></span> <span data-ttu-id="cd516-439">Затем <xref:System.Xml.Serialization.XmlSerializer> выполняет этот код с использованием его контекста безопасности вместо кода сериализации/десериализации.</span><span class="sxs-lookup"><span data-stu-id="cd516-439">The <xref:System.Xml.Serialization.XmlSerializer> then runs this code using its security context, instead of the serialization/deserialization code.</span></span> <span data-ttu-id="cd516-440">Убедитесь, что для каталога временных файлов правильно заданы разрешения, чтобы избежать такой ситуации.</span><span class="sxs-lookup"><span data-stu-id="cd516-440">Make sure the permissions are set correctly on the temporary files directory to prevent this from happening.</span></span>

<span data-ttu-id="cd516-441">Для <xref:System.Xml.Serialization.XmlSerializer> также предусмотрен режим, в котором он использует заранее созданные сборки сериализации вместо того, чтобы создавать их в процессе выполнения.</span><span class="sxs-lookup"><span data-stu-id="cd516-441">The <xref:System.Xml.Serialization.XmlSerializer> also has a mode in which it uses pre-generated serialization assemblies instead of generating them at runtime.</span></span> <span data-ttu-id="cd516-442">Этот режим включается в каждом случае, когда <xref:System.Xml.Serialization.XmlSerializer> обнаруживает подходящую сборку сериализации.</span><span class="sxs-lookup"><span data-stu-id="cd516-442">This mode is triggered whenever the <xref:System.Xml.Serialization.XmlSerializer> can find a suitable serialization assembly.</span></span> <span data-ttu-id="cd516-443"><xref:System.Xml.Serialization.XmlSerializer> проверяет, была ли сборка сериализации подписана тем же ключом, который использовался для подписи сборки, содержащей сериализуемые типы.</span><span class="sxs-lookup"><span data-stu-id="cd516-443">The <xref:System.Xml.Serialization.XmlSerializer> checks whether or not the serialization assembly was signed by the same key that was used to sign the assembly that contains the types being serialized.</span></span> <span data-ttu-id="cd516-444">Это обеспечивает защиту от вредоносных сборок, маскирующихся под сборки сериализации.</span><span class="sxs-lookup"><span data-stu-id="cd516-444">This offers protection from malicious assemblies being disguised as serialization assemblies.</span></span> <span data-ttu-id="cd516-445">Однако если сборка, содержащая сериализуемые типы, не подписана, <xref:System.Xml.Serialization.XmlSerializer> не может это проверить и использует любую сборку с правильным именем.</span><span class="sxs-lookup"><span data-stu-id="cd516-445">However, if the assembly that contains your serializable types is not signed, the <xref:System.Xml.Serialization.XmlSerializer> cannot perform this check and uses any assembly with the correct name.</span></span> <span data-ttu-id="cd516-446">Это сделает возможным выполнение вредоносного кода.</span><span class="sxs-lookup"><span data-stu-id="cd516-446">This makes running malicious code possible.</span></span> <span data-ttu-id="cd516-447">Всегда подписывайте сборки, содержащие сериализуемые типы, или тщательно контролируйте доступ к каталогу приложения и глобальному кэшу сборок, чтобы предотвратить появление вредоносных сборок.</span><span class="sxs-lookup"><span data-stu-id="cd516-447">Always sign the assemblies that contain your serializable types, or tightly control access to your application’s directory and the global assembly cache to prevent the introduction of malicious assemblies.</span></span>

<span data-ttu-id="cd516-448"><xref:System.Xml.Serialization.XmlSerializer> может подвергаться атаке типа "отказ в обслуживании".</span><span class="sxs-lookup"><span data-stu-id="cd516-448">The <xref:System.Xml.Serialization.XmlSerializer> can be subject to a denial of service attack.</span></span> <span data-ttu-id="cd516-449">У <xref:System.Xml.Serialization.XmlSerializer> отсутствует квота `MaxItemsInObjectGraph` (которая предусмотрена для <xref:System.Runtime.Serialization.DataContractSerializer>).</span><span class="sxs-lookup"><span data-stu-id="cd516-449">The <xref:System.Xml.Serialization.XmlSerializer> does not have a `MaxItemsInObjectGraph` quota (as is available on the <xref:System.Runtime.Serialization.DataContractSerializer>).</span></span> <span data-ttu-id="cd516-450">Поэтому он десериализует произвольное число объектов, ограничиваясь только размером сообщения.</span><span class="sxs-lookup"><span data-stu-id="cd516-450">Thus, it deserializes an arbitrary amount of objects, limited only by the message size.</span></span>

### <a name="partial-trust-threats"></a><span data-ttu-id="cd516-451">Угрозы частичного доверия</span><span class="sxs-lookup"><span data-stu-id="cd516-451">Partial Trust Threats</span></span>

<span data-ttu-id="cd516-452">Обратите внимание на следующие проблемы, связанные с угрозами, которые относятся к коду, выполняемому с частичным доверием.</span><span class="sxs-lookup"><span data-stu-id="cd516-452">Note the following concerns regarding threats related to code running with partial trust.</span></span> <span data-ttu-id="cd516-453">Эти угрозы включают в себя вредоносный частично доверенный код, а также такой код в сочетании с другими сценариями атак (например частично доверенный код, создающий определенную строку, а затем ее десериализующий).</span><span class="sxs-lookup"><span data-stu-id="cd516-453">These threats include malicious partially-trusted code as well as malicious partially-trusted code in combination with other attack scenarios (for example, partially-trusted code that constructs a specific string and then deserializing it).</span></span>

- <span data-ttu-id="cd516-454">При использовании любых компонентов сериализации никогда не назначайте какие-либо разрешения до начала такого использования, даже если весь сценарий сериализации находится в рамках назначения, и используются только доверенные данные и объекты.</span><span class="sxs-lookup"><span data-stu-id="cd516-454">When using any serialization components, never assert any permissions before such usage, even if the entire serialization scenario is within the scope of your assert, and you are not dealing with any untrusted data or objects.</span></span> <span data-ttu-id="cd516-455">Такое использование может стать причиной уязвимостей системы безопасности.</span><span class="sxs-lookup"><span data-stu-id="cd516-455">Such usage may lead to security vulnerabilities.</span></span>

- <span data-ttu-id="cd516-456">В случаях, когда частично доверенный код управляет процессом сериализации посредством точек расширяемости (суррогатов), сериализуемых типов или иными способами, такой код может заставить сериализатор вывести большой объем данных в сериализованный поток, что может стать причиной отказа в обслуживании (DoS) получателя этого потока.</span><span class="sxs-lookup"><span data-stu-id="cd516-456">In cases where partially-trusted code has control over the serialization process, either through extensibility points (surrogates), types being serialized, or through other means, the partially-trusted code may cause the serializer to output a large amount of data into the serialized stream, which may cause Denial of Service (DoS) to the receiver of this stream.</span></span> <span data-ttu-id="cd516-457">При сериализации данных, предназначенных для целевого объекта, не защищенного от угроз DoS, не сериализуйте частично доверенные типы или не допускайте, чтобы частично доверенный код каким-либо образом управлял сериализацией.</span><span class="sxs-lookup"><span data-stu-id="cd516-457">If you are serializing data intended for a target that is sensitive to DoS threats, do not serialize partially-trusted types or otherwise let partially-trusted code control serialization.</span></span>

- <span data-ttu-id="cd516-458">Если вы разрешаете частично доверенный код доступ к вашему <xref:System.Runtime.Serialization.DataContractSerializer> экземпляру или иным образом контролируете [суррогаты контракта данных](../extending/data-contract-surrogates.md), это может привести к значительному управлению процессом сериализации и десериализации.</span><span class="sxs-lookup"><span data-stu-id="cd516-458">If you allow partially-trusted code access to your <xref:System.Runtime.Serialization.DataContractSerializer> instance or otherwise control the [Data Contract Surrogates](../extending/data-contract-surrogates.md), it may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="cd516-459">Например, он может ввести произвольные типы, привести к раскрытию информации, подделать получаемый граф объекта или сериализованные данные или переполнить итоговый сериализованный поток.</span><span class="sxs-lookup"><span data-stu-id="cd516-459">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span> <span data-ttu-id="cd516-460">Аналогичная угроза для <xref:System.Runtime.Serialization.NetDataContractSerializer> описана в разделе "Безопасное использование NetDataContractSerializer".</span><span class="sxs-lookup"><span data-stu-id="cd516-460">An equivalent <xref:System.Runtime.Serialization.NetDataContractSerializer> threat is described in the "Using the NetDataContractSerializer Securely" section.</span></span>

- <span data-ttu-id="cd516-461">Если атрибут <xref:System.Runtime.Serialization.DataContractAttribute> применяется к типу (или типу, отмеченному <xref:System.SerializableAttribute> , но не <xref:System.Runtime.Serialization.ISerializable>), десериализатор может создать экземпляр такого типа, даже если все конструкторы являются закрытыми или защищены требованиями.</span><span class="sxs-lookup"><span data-stu-id="cd516-461">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a type (or the type marked as <xref:System.SerializableAttribute> but is not <xref:System.Runtime.Serialization.ISerializable>), the deserializer can create an instance of such a type even if all constructors are non-public or protected by demands.</span></span>

- <span data-ttu-id="cd516-462">Ни при каких обстоятельствах не следует доверять результату десериализации, пока сериализуемые данные не будут надежными, и все известные типы не будут именно теми типами, которым можно доверять.</span><span class="sxs-lookup"><span data-stu-id="cd516-462">Never trust the result of deserialization unless the data to be deserialized is trusted and you are certain that all known types are types that you trust.</span></span> <span data-ttu-id="cd516-463">Обратите внимание, что известные типы не загружаются из файла конфигурации приложения (а загружаются из файла конфигурации компьютера) во время работы с частичным уровнем доверия.</span><span class="sxs-lookup"><span data-stu-id="cd516-463">Note that known types are not loaded from the application configuration file, (but are loaded from the computer configuration file) when running in partial trust.</span></span>

- <span data-ttu-id="cd516-464">Если передается экземпляр <xref:System.Runtime.Serialization.DataContractSerializer> с суррогатом, добавленным в частично доверенный код, код может изменить любые изменяемые параметры этого суррогата.</span><span class="sxs-lookup"><span data-stu-id="cd516-464">If you pass a <xref:System.Runtime.Serialization.DataContractSerializer> instance with a surrogate added to partially-trusted code, the code can change any modifiable settings on that surrogate.</span></span>

- <span data-ttu-id="cd516-465">Что касается десериализованного объекта, если средство чтения XML (или данных) используется с частично доверенным кодом, считайте полученный десериализованный объект ненадежным.</span><span class="sxs-lookup"><span data-stu-id="cd516-465">For a deserialized object, if the XML reader (or the data therein) comes from partially-trusted code, treat the resulting deserialized object as untrusted data.</span></span>

- <span data-ttu-id="cd516-466">Тот факт, что у типа <xref:System.Runtime.Serialization.ExtensionDataObject> отсутствуют открытые элементы, не означает, что его данные защищены.</span><span class="sxs-lookup"><span data-stu-id="cd516-466">The fact that the <xref:System.Runtime.Serialization.ExtensionDataObject> type has no public members does not mean that data within it is secure.</span></span> <span data-ttu-id="cd516-467">Например, если выполняется десериализация из источника привилегированных данных в объект, содержащий некоторое количество данных, а затем этот объект передается частично доверенному коду, этот код может считать данные в `ExtensionDataObject` путем сериализации объекта.</span><span class="sxs-lookup"><span data-stu-id="cd516-467">For example, if you deserialize from a privileged data source into an object in which some data resides, then hand that object to partially-trusted code, the partially-trusted code can read the data in the `ExtensionDataObject` by serializing the object.</span></span> <span data-ttu-id="cd516-468">Рассмотрите возможность задания параметра <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> как `true` при десериализации из источника привилегированных данных в объект, который затем передается частично доверенному коду.</span><span class="sxs-lookup"><span data-stu-id="cd516-468">Consider setting <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> to `true` when deserializing from a privileged data source into an object that is later passed to partially-trusted code.</span></span>

- <span data-ttu-id="cd516-469"><xref:System.Runtime.Serialization.DataContractSerializer> и <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> поддерживают сериализацию частных, защищенных, внутренних и открытых членов в условиях полного доверия.</span><span class="sxs-lookup"><span data-stu-id="cd516-469"><xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> support the serialization of private, protected, internal, and public members in full trust.</span></span> <span data-ttu-id="cd516-470">Однако в среде с частичным уровнем доверия возможна сериализация только открытых членов.</span><span class="sxs-lookup"><span data-stu-id="cd516-470">However, in partial trust, only public members can be serialized.</span></span> <span data-ttu-id="cd516-471">Если приложение пытается сериализировать член, отличный от открытого, вызывается <xref:System.Security.SecurityException> .</span><span class="sxs-lookup"><span data-stu-id="cd516-471">A <xref:System.Security.SecurityException> is thrown if an application attempts to serialize a non-public member.</span></span>

    <span data-ttu-id="cd516-472">Чтобы сериализировать внутренние или защищенные внутренние члены в условиях частичного уровня доверия, используйте атрибут сборки <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> .</span><span class="sxs-lookup"><span data-stu-id="cd516-472">To allow internal or protected internal members to be serialized in partial trust, use the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> assembly attribute.</span></span> <span data-ttu-id="cd516-473">Этот атрибут позволяет сборке объявлять, что ее внутренние элементы являются видимыми для некоторых других сборок.</span><span class="sxs-lookup"><span data-stu-id="cd516-473">This attribute allows an assembly to declare that its internal members are visible to some other assembly.</span></span> <span data-ttu-id="cd516-474">В этом случае сборка, внутренние члены которой нужно сериализировать, объявляет свои внутренние члены видимыми для System.Runtime.Serialization.dll.</span><span class="sxs-lookup"><span data-stu-id="cd516-474">In this case, an assembly that wants to have its internal members serialized declares that its internal members are visible to System.Runtime.Serialization.dll.</span></span>

    <span data-ttu-id="cd516-475">Преимущество такого подхода состоит в том, что не требуется путь создания кода с повышенными привилегиями.</span><span class="sxs-lookup"><span data-stu-id="cd516-475">The advantage of this approach is that it does not require an elevated code generation path.</span></span>

    <span data-ttu-id="cd516-476">Но есть у него и два существенных недостатка.</span><span class="sxs-lookup"><span data-stu-id="cd516-476">At the same time, there are two major disadvantages.</span></span>

    <span data-ttu-id="cd516-477">Первый заключается в том, что включаемое по требованию свойство атрибута <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> действует на уровне сборки.</span><span class="sxs-lookup"><span data-stu-id="cd516-477">The first disadvantage is that the opt-in property of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute is assembly-wide.</span></span> <span data-ttu-id="cd516-478">Следовательно, нельзя разрешить сериализацию внутренних членов только одного определенного класса.</span><span class="sxs-lookup"><span data-stu-id="cd516-478">That is, you cannot specify that only a certain class can have its internal members serialized.</span></span> <span data-ttu-id="cd516-479">Чтобы не сериализировать любой конкретный внутренний член, достаточно не добавлять к нему атрибут <xref:System.Runtime.Serialization.DataMemberAttribute> .</span><span class="sxs-lookup"><span data-stu-id="cd516-479">Of course, you can still choose not to serialize a specific internal member, by simply not adding a <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to that member.</span></span> <span data-ttu-id="cd516-480">Аналогично разработчик может сделать член внутренним, а не частным или защищенным, немного затруднив обеспечение видимости.</span><span class="sxs-lookup"><span data-stu-id="cd516-480">Similarly, a developer can also choose to make a member internal rather than private or protected, with slight visibility concerns.</span></span>

    <span data-ttu-id="cd516-481">Второй недостаток заключается в том, что частные и защищенные члены все еще не поддерживаются.</span><span class="sxs-lookup"><span data-stu-id="cd516-481">The second disadvantage is that it still does not support private or protected members.</span></span>

    <span data-ttu-id="cd516-482">В качестве иллюстрации использования атрибута <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> в условиях частичного уровня доверия может послужить следующая программа:</span><span class="sxs-lookup"><span data-stu-id="cd516-482">To illustrate the use of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute in partial trust, consider the following program:</span></span>

    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#1)]

    <span data-ttu-id="cd516-483">В предыдущем примере `PermissionsHelper.InternetZone` соответствует <xref:System.Security.PermissionSet> для частичного уровня доверия.</span><span class="sxs-lookup"><span data-stu-id="cd516-483">In the example above, `PermissionsHelper.InternetZone` corresponds to the <xref:System.Security.PermissionSet> for partial trust.</span></span> <span data-ttu-id="cd516-484">Теперь, без <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> атрибута, приложение завершится ошибкой, вызывая исключение, <xref:System.Security.SecurityException> указывающее, что не являющиеся открытыми члены не могут быть сериализованы при частичном доверии.</span><span class="sxs-lookup"><span data-stu-id="cd516-484">Now, without the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute, the application will fail, throwing a <xref:System.Security.SecurityException> indicating that non-public members cannot be serialized in partial trust.</span></span>

    <span data-ttu-id="cd516-485">Однако, если добавить в исходный код следующую строку, программа будет выполнена успешно.</span><span class="sxs-lookup"><span data-stu-id="cd516-485">However, if we add the following line to the source file, the program runs successfully.</span></span>

    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#2)]

## <a name="other-state-management-concerns"></a><span data-ttu-id="cd516-486">Другие вопросы управления состоянием</span><span class="sxs-lookup"><span data-stu-id="cd516-486">Other State Management Concerns</span></span>

<span data-ttu-id="cd516-487">Следует упомянуть еще ряд соображений касательно управления состоянием объекта.</span><span class="sxs-lookup"><span data-stu-id="cd516-487">A few other concerns regarding object state management are worth mentioning:</span></span>

- <span data-ttu-id="cd516-488">При использовании модели программирования, основанной на потоковой передаче, с потоковым каналом транспорта сообщение обрабатывается после его получения.</span><span class="sxs-lookup"><span data-stu-id="cd516-488">When using the stream-based programming model with a streaming transport, processing of the message occurs as the message arrives.</span></span> <span data-ttu-id="cd516-489">Отправитель сообщения может отменить операцию отправки посередине потока, оставив код в непредсказуемом состоянии, если планировалась передача большего содержимого.</span><span class="sxs-lookup"><span data-stu-id="cd516-489">The sender of the message may abort the send operation in the middle of the stream, leaving your code in an unpredictable state if more content was expected.</span></span> <span data-ttu-id="cd516-490">В целом не следует полагаться на завершаемый поток и выполнять какие-либо действия по операции, основанной на потоке, для которых невозможно выполнить откат в случае отмены потока.</span><span class="sxs-lookup"><span data-stu-id="cd516-490">In general, do not rely on the stream being complete, and do not perform any work in a stream-based operation that cannot be rolled back in case the stream is aborted.</span></span> <span data-ttu-id="cd516-491">Это также применимо к ситуации, когда сообщение может быть неправильно сформировано после потокового тела (например, в нем может отсутствовать закрывающий тег конверта SOAP или может присутствовать второе тело сообщения).</span><span class="sxs-lookup"><span data-stu-id="cd516-491">This also applies to the situation where a message may be malformed after the streaming body (for example, it may be missing an end tag for the SOAP envelope or may have a second message body).</span></span>

- <span data-ttu-id="cd516-492">Использование функции `IExtensibleDataObject` может привести к раскрытию конфиденциальных данных.</span><span class="sxs-lookup"><span data-stu-id="cd516-492">Using the `IExtensibleDataObject` feature may cause sensitive data to be emitted.</span></span> <span data-ttu-id="cd516-493">При принятии данных из недоверенного источника в контракты данных с `IExtensibleObjectData` и последующим повторным их раскрытием для безопасного канала, в котором подписываются сообщения, данные, о которых ничего не известно, потенциально подтверждаются.</span><span class="sxs-lookup"><span data-stu-id="cd516-493">If you are accepting data from an untrusted source into data contracts with `IExtensibleObjectData` and later re-emitting it on a secure channel where messages are signed, you are potentially vouching for data you know nothing about.</span></span> <span data-ttu-id="cd516-494">Более того, отправляемое общее состояние может быть недействительным, если в учетную запись передаются известные и неизвестные блоки данных.</span><span class="sxs-lookup"><span data-stu-id="cd516-494">Moreover, the overall state you are sending may be invalid if you take both the known and unknown pieces of data into account.</span></span> <span data-ttu-id="cd516-495">Такой ситуации можно избежать, выборочно задав свойство расширения данных как `null` или выборочно отключив функцию `IExtensibleObjectData` .</span><span class="sxs-lookup"><span data-stu-id="cd516-495">Avoid this situation by either selectively setting the extension data property to `null` or by selectively disabling the `IExtensibleObjectData` feature.</span></span>

## <a name="schema-import"></a><span data-ttu-id="cd516-496">Импорт схемы</span><span class="sxs-lookup"><span data-stu-id="cd516-496">Schema Import</span></span>

<span data-ttu-id="cd516-497">Как правило, процедура импорта схемы для создания типов выполняется только на этапе разработки, когда для создания класса клиента в веб-службе используется [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md) .</span><span class="sxs-lookup"><span data-stu-id="cd516-497">Normally, the process of importing schema to generate types happens only at design time, for example, when using the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md) on a Web service to generate a client class.</span></span> <span data-ttu-id="cd516-498">Однако в более сложных сценариях схему можно обработать во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="cd516-498">However, in more advanced scenarios, you may process schema at runtime.</span></span> <span data-ttu-id="cd516-499">Помните, что такая процедура может стать причиной атак типа "отказ в обслуживании".</span><span class="sxs-lookup"><span data-stu-id="cd516-499">Be aware that doing so can expose you to denial-of-service risks.</span></span> <span data-ttu-id="cd516-500">Импортирование некоторых схем может занять много времени.</span><span class="sxs-lookup"><span data-stu-id="cd516-500">Some schema may take a long time to be imported.</span></span> <span data-ttu-id="cd516-501">Никогда не используйте в таких сценариях компонент импорта схемы <xref:System.Xml.Serialization.XmlSerializer> , если схемы могут происходить из недоверенного источника.</span><span class="sxs-lookup"><span data-stu-id="cd516-501">Never use the <xref:System.Xml.Serialization.XmlSerializer> schema import component in such scenarios if schemas are possibly coming from an untrusted source.</span></span>

## <a name="threats-specific-to-aspnet-ajax-integration"></a><span data-ttu-id="cd516-502">Угрозы, относящиеся к интеграции ASP.NET AJAX</span><span class="sxs-lookup"><span data-stu-id="cd516-502">Threats Specific to ASP.NET AJAX Integration</span></span>

<span data-ttu-id="cd516-503">Когда пользователь реализует интерфейс <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> или <xref:System.ServiceModel.Description.WebHttpBehavior> , WCF предоставляет конечную точку, которая может принимать сообщения XML и JSON.</span><span class="sxs-lookup"><span data-stu-id="cd516-503">When the user implements <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> or <xref:System.ServiceModel.Description.WebHttpBehavior>, WCF exposes an endpoint that can accept both XML and JSON messages.</span></span> <span data-ttu-id="cd516-504">Однако существует только один набор квот средства чтения, используемых средствами чтения XML и JSON.</span><span class="sxs-lookup"><span data-stu-id="cd516-504">However, there is only one set of reader quotas, used both by the XML reader and the JSON reader.</span></span> <span data-ttu-id="cd516-505">Некоторые параметры квот могут подходить для одного средства чтения, но при этом быть слишком большими для другого.</span><span class="sxs-lookup"><span data-stu-id="cd516-505">Some quota settings may be appropriate for one reader but too large for the other.</span></span>

<span data-ttu-id="cd516-506">При реализации `WebScriptEnablingBehavior`пользователю предоставляется вариант раскрытия прокси JavaScript в конечной точке.</span><span class="sxs-lookup"><span data-stu-id="cd516-506">When implementing `WebScriptEnablingBehavior`, the user has the option to expose a JavaScript proxy at the endpoint.</span></span> <span data-ttu-id="cd516-507">Следует принимать во внимание следующие вопросы безопасности.</span><span class="sxs-lookup"><span data-stu-id="cd516-507">The following security issues must be considered:</span></span>

- <span data-ttu-id="cd516-508">Информацию о службе (имена операций, параметров и т. д.) можно получить, изучив прокси JavaScript.</span><span class="sxs-lookup"><span data-stu-id="cd516-508">Information about the service (operation names, parameter names, and so on) can be obtained by examining the JavaScript proxy.</span></span>

- <span data-ttu-id="cd516-509">При использовании конечной точки JavaScript конфиденциальная и важная информация может сохраняться в кэше веб-браузера клиента.</span><span class="sxs-lookup"><span data-stu-id="cd516-509">When using the JavaScript endpoint, sensitive and private information might be retained in the client Web browser cache.</span></span>

## <a name="a-note-on-components"></a><span data-ttu-id="cd516-510">Замечание по компонентам</span><span class="sxs-lookup"><span data-stu-id="cd516-510">A Note on Components</span></span>

<span data-ttu-id="cd516-511">WCF — это гибкая и настраиваемая система.</span><span class="sxs-lookup"><span data-stu-id="cd516-511">WCF is a flexible and customizable system.</span></span> <span data-ttu-id="cd516-512">Большая часть содержимого этого раздела сосредоточена на наиболее распространенных сценариях использования WCF.</span><span class="sxs-lookup"><span data-stu-id="cd516-512">Most of the contents of this topic focus on the most common WCF usage scenarios.</span></span> <span data-ttu-id="cd516-513">Однако компоненты, предоставляемые WCF, можно составить различными способами.</span><span class="sxs-lookup"><span data-stu-id="cd516-513">However, it is possible to compose components WCF provides in many different ways.</span></span> <span data-ttu-id="cd516-514">Важно понимать последствия нарушения безопасности при использовании каждого компонента.</span><span class="sxs-lookup"><span data-stu-id="cd516-514">It is important to understand the security implications of using each component.</span></span> <span data-ttu-id="cd516-515">В частности:</span><span class="sxs-lookup"><span data-stu-id="cd516-515">In particular:</span></span>

- <span data-ttu-id="cd516-516">Если требуется использование средств чтения XML, используйте средства чтения, обеспечиваемые классом <xref:System.Xml.XmlDictionaryReader> , а не любые другие средства чтения.</span><span class="sxs-lookup"><span data-stu-id="cd516-516">When you must use XML readers, use the readers the <xref:System.Xml.XmlDictionaryReader> class provides as opposed to any other readers.</span></span> <span data-ttu-id="cd516-517">Безопасные средства чтения создаются с помощью методов <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>или <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> .</span><span class="sxs-lookup"><span data-stu-id="cd516-517">Safe readers are created using <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> methods.</span></span> <span data-ttu-id="cd516-518">Не используйте метод <xref:System.Xml.XmlReader.Create%2A> .</span><span class="sxs-lookup"><span data-stu-id="cd516-518">Do not use the <xref:System.Xml.XmlReader.Create%2A> method.</span></span> <span data-ttu-id="cd516-519">Для средств чтения всегда задавайте безопасные квоты.</span><span class="sxs-lookup"><span data-stu-id="cd516-519">Always configure the readers with safe quotas.</span></span> <span data-ttu-id="cd516-520">Механизмы сериализации в WCF защищены только при использовании с защищенными модулями чтения XML из WCF.</span><span class="sxs-lookup"><span data-stu-id="cd516-520">The serialization engines in WCF are secure only when used with secure XML readers from WCF.</span></span>

- <span data-ttu-id="cd516-521">Если для десериализации потенциально ненадежных данных используется <xref:System.Runtime.Serialization.DataContractSerializer> , всегда задавайте свойство <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> .</span><span class="sxs-lookup"><span data-stu-id="cd516-521">When using the <xref:System.Runtime.Serialization.DataContractSerializer> to deserialize potentially untrusted data, always set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property.</span></span>

- <span data-ttu-id="cd516-522">При создании сообщения задавайте параметр `maxSizeOfHeaders` , если `MaxReceivedMessageSize` не обеспечивает достаточный уровень защиты.</span><span class="sxs-lookup"><span data-stu-id="cd516-522">When creating a message, set the `maxSizeOfHeaders` parameter if `MaxReceivedMessageSize` does not offer enough protection.</span></span>

- <span data-ttu-id="cd516-523">При создании кодировщика всегда настраивайте соответствующие квоты, например `MaxSessionSize` и `MaxBufferSize`.</span><span class="sxs-lookup"><span data-stu-id="cd516-523">When creating an encoder, always configure the relevant quotas, such as `MaxSessionSize` and `MaxBufferSize`.</span></span>

- <span data-ttu-id="cd516-524">Если используется фильтр сообщений XPath, задавайте <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> , чтобы ограничить число XML-узлов, посещаемых фильтром.</span><span class="sxs-lookup"><span data-stu-id="cd516-524">When using an XPath message filter, set the <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> to limit the amount of XML nodes the filter visits.</span></span> <span data-ttu-id="cd516-525">Не используйте выражения XPath, которые могут потребовать длительного времени для вычисления без посещения большого числа узлов.</span><span class="sxs-lookup"><span data-stu-id="cd516-525">Do not use XPath expressions that could take a long time to compute without visiting many nodes.</span></span>

- <span data-ttu-id="cd516-526">В целом при создании любого компонента, принимающего квоту, следует понимать последствия нарушения безопасности и задавать для него безопасное значение.</span><span class="sxs-lookup"><span data-stu-id="cd516-526">In general, when using any component that accepts a quota, understand its security implications and set it to a safe value.</span></span>

## <a name="see-also"></a><span data-ttu-id="cd516-527">См. также</span><span class="sxs-lookup"><span data-stu-id="cd516-527">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.XmlDictionaryReader>
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="cd516-528">Известные типы контрактов данных</span><span class="sxs-lookup"><span data-stu-id="cd516-528">Data Contract Known Types</span></span>](data-contract-known-types.md)
