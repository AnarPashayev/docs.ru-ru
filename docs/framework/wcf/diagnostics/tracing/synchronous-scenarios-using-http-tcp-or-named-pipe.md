---
title: Синхронные сценарии с использованием HTTP, TCP или именованного канала
ms.date: 03/30/2017
ms.assetid: 7e90af1b-f8f6-41b9-a63a-8490ada502b1
ms.openlocfilehash: 28e612b190f4993e1ce7da0d1083c4e55f827d4a
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61784871"
---
# <a name="synchronous-scenarios-using-http-tcp-or-named-pipe"></a>Синхронные сценарии с использованием HTTP, TCP или именованного канала
В этом разделе описываются действия и перенаправления для различных сценариев синхронных запросов/ответов (с однопотоковым клиентом, с использованием HTTP, TCP или именованного канала). См. в разделе [асинхронные сценарии с использованием HTTP, TCP или именованного канала](../../../../../docs/framework/wcf/diagnostics/tracing/asynchronous-scenarios-using-http-tcp-or-named-pipe.md) Дополнительные сведения о многопотоковых запросах.  
  
## <a name="synchronous-requestreply-without-errors"></a>Синхронный запрос/ответ без ошибок  
 В этом разделе описываются действия и перенаправления для реального сценария синхронных запросов/ответов (с однопотоковым клиентом).  
  
### <a name="client"></a>"Клиент";  
  
#### <a name="establishing-communication-with-service-endpoint"></a>Установка связи с конечной точкой службы  
 Создается и открывается клиент. Для каждого из этих действий, внешнее действие (A) перенаправляется действию «Создать клиент» (B) и «Открыть клиент» (C) соответственно. Для каждого действия, которому оно перенаправляется, внешнее действие приостанавливается до момента обратного перенаправления (т. е. до выполнения кода ServiceModel).  
  
#### <a name="making-a-request-to-service-endpoint"></a>Создание запроса для конечной точки службы  
 Внешнее действие перенаправляется действию «ProcessAction» (D). В рамках этого действия отправляется сообщение запроса и принимается сообщение ответа. Действие прекращается, когда управление возвращается пользовательскому коду. Поскольку этот запрос является синхронным, внешнее действие приостанавливается до возврата управления.  
  
#### <a name="closing-communication-with-service-endpoint"></a>Закрытие связи с конечной точкой службы  
 Действие «закрыть» (I) клиента создается из внешнего действия. Оно идентично действиям "создать" и "открыть".  
  
### <a name="server"></a>Сервер  
  
#### <a name="setting-up-a-service-host"></a>Настройка узла службы  
 Действия «создать» и «открыть» (N и O) узла ServiceHost создаются из внешнего действия (M).  
  
 Действие прослушивания (P) создается при открывании узла ServiceHost для каждого прослушивателя. Действие прослушивания ожидает получения и обработки данных.  
  
#### <a name="receiving-data-on-the-wire"></a>Получение данных по сети  
 При получении данных по сети, действие «ReceiveBytes» создается в том случае, если он еще не существует (Q) для обработки полученных данных. Это действие можно использовать повторно для нескольких сообщений в пределах одного соединения или очереди.  
  
 Действие ReceiveBytes запускает действие ProcessMessage (R) при наличии достаточной информации для формирования сообщения действия SOAP.  
  
 При действии R обрабатываются заголовки сообщений и проверяется заголовок activityID. Если этот заголовок имеется, идентификатору действия присваивается значение ProcessAction. В противном случае создается новый идентификатор.  
  
 При обработке вызова создается действие ProcessAction (S), и выполняется перенаправление на это действие. Данное действие завершается при полном завершении обработки, связанной с входящим сообщением, включая выполнение пользовательского кода (T) и отправку ответного сообщения (если она предусмотрена).  
  
#### <a name="closing-a-service-host"></a>Закрытие узла службы  
 Действие "закрыть" (Z) узла ServiceHost создается из внешнего действия.  
  
 ![Схема, показывающая синхронные сценарии: HTTP, TCP или именованных каналов.](./media/synchronous-scenarios-using-http-tcp-or-named-pipe/synchronous-scenario-http-tcp-named-pipes.gif)  
  
 В \<A: name >, `A` — ссылочный символ, описывающий действие в приведенном выше тексте и в таблице 3. `Name` представляет собой сокращенное имя действия.  
  
 Если `propagateActivity` = `true`, Process Action на клиент и служба имеют тот же идентификатор действия.  
  
## <a name="synchronous-requestreply-with-errors"></a>Синхронный запрос/ответ с ошибками  
 Единственное отличие от предыдущего сценария заключается в том, что в качестве ответного сообщения возвращается сообщение об ошибке SOAP. Если `propagateActivity` = `true`, идентификатор действия сообщения запроса добавляется сообщение об ошибке SOAP.  
  
## <a name="synchronous-one-way-without-errors"></a>Синхронная односторонняя связь без ошибок  
 Единственное отличие от первого сценария заключается в том, что на сервер не возвращается сообщение. Для протоколов, основанных на HTTP, на клиент все же возвращается состояние (допустимое или ошибка). Это обусловлено HTTP — единственный протокол с семантикой запроса ответа, который является частью стека протокола WCF. Поскольку обработка TCP скрыта от WCF, не отправляется подтверждение клиенту.  
  
## <a name="synchronous-one-way-with-errors"></a>Синхронная односторонняя связь с ошибками  
 Если произошла ошибка при обработке сообщения (Q или далее), клиенту не возвращается уведомление. Эта логика идентична сценарию «Синхронная односторонняя связь без ошибок». Если требуется получить сообщение об ошибке, использовать сценарий с односторонней связью не рекомендуется.  
  
## <a name="duplex"></a>Дуплекс  
 Отличие от предыдущих сценариев заключается в том, что клиент выполняет роль службы, создавая действия ReceiveBytes и ProcessMessage, подобно сценариям для асинхронной связи.
