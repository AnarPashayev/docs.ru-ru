---
title: Создание трассировки пользовательского кода
ms.date: 03/30/2017
ms.assetid: fa54186a-8ffa-4332-b0e7-63867126fd49
ms.openlocfilehash: 93da2eb74705a0581923d0317315e628f374be3e
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61998137"
---
# <a name="emitting-user-code-traces"></a>Создание трассировки пользовательского кода

Помимо возможности включения трассировки в конфигурации для сбора данных инструментирования, созданный Windows Communication Foundation (WCF), вы также существует возможность создавать трассировки программно в пользовательском коде. Таким образом можно заранее создавать данные инструментирования для их последующего использования в диагностических целях. В этом разделе описывается, как это сделать.

Кроме того [расширение трассировки](../../../../../docs/framework/wcf/samples/extending-tracing.md) пример включает все сегменты кода, в следующих разделах.

## <a name="creating-a-trace-source"></a>Создание источника трассировки

Можно использовать следующий код для создания пользовательского источника трассировки.

```csharp
TraceSource ts = new TraceSource("myUserTraceSource");
```

## <a name="creating-activities"></a>Создание действий

Действия являются логическим блоком обработки. Для каждого основного блока обработки, в котором требуется сгруппировать трассировки, можно создать одно действие. Например, для каждого запроса к службе можно создать одно действие. Для этого выполните следующие действия.

1. Сохраните идентификатор действия в области.

2. Создайте новый идентификатор действия.

3. Выполните перенаправление от действия в области к новому действию, настройте новое действие в области и создайте трассировку запуска действий для данного действия.

В следующем коде показано, как это сделать.

```csharp
Guid oldID = Trace.CorrelationManager.ActivityId;
Guid traceID = Guid.NewGuid();
ts.TraceTransfer(0, "transfer", traceID);
Trace.CorrelationManager.ActivityId = traceID; // Trace is static
ts.TraceEvent(TraceEventType.Start, 0, "Add request");
```

## <a name="emitting-traces-within-a-user-activity"></a>Создание трассировок в действии пользователя

В следующем коде показано создание трассировок в действии пользователя.

```csharp
double value1 = 100.00D;
double value2 = 15.99D;
ts.TraceInformation("Client sends message to Add " + value1 + ", " + value2);
double result = client.Add(value1, value2);
ts.TraceInformation("Client receives Add response '" + result + "'");
```

## <a name="stopping-the-activities"></a>Остановка действий

Чтобы остановить действия, выполните перенаправление к прежнему действию, остановите текущее действие и сбросьте идентификатор прежнего действия в области.

В следующем коде показано, как это сделать.

```csharp
ts.TraceTransfer(0, "transfer", oldID);
ts.TraceEvent(TraceEventType.Stop, 0, "Add request");
Trace.CorrelationManager.ActivityId = oldID;
```

## <a name="propagating-the-activity-id-to-a-service"></a>Распространение идентификатора действия на службу

Если задать атрибуту `propagateActivity` значение `true` для источника трассировки `System.ServiceModel` и в файле конфигурации клиента, и в файле конфигурации службы, служба обработки запроса на добавление будет присутствовать в том же действии, что и определено в клиенте. Если служба определяет собственные действия и перенаправления, трассировки службы не содержатся в распространенном клиентом действии. Вместо этого они содержатся в действии, связанном трассировками перенаправления с действием, идентификатор которого распространяется клиентом.

> [!NOTE]
> Если `propagateActivity` атрибуту присваивается `true` на клиента и службы, внешнее действие в области операции службы задается с WCF.

Чтобы проверить, задано ли в области действия с WCF можно использовать следующий код.

```csharp
// Check if an activity was set in scope by WCF, if it was
// propagated from the client. If not, ( ambient activity is
// equal to Guid.Empty), create a new one.
if(Trace.CorrelationManager.ActivityId == Guid.Empty)
{
    Guid newGuid = Guid.NewGuid();
    Trace.CorrelationManager.ActivityId = newGuid;
}
// Emit your Start trace.
ts.TraceEvent(TraceEventType.Start, 0, "Add Activity");

// Emit the processing traces for that request.
serviceTs.TraceInformation("Service receives Add "
                            + n1 + ", " + n2);
// double result = n1 + n2;
serviceTs.TraceInformation("Service sends Add result" + result);

// Emit the Stop trace and exit the method scope.
ts.TraceEvent(TraceEventType.Stop, 0, "Add Activity");
// return result;
```

## <a name="tracing-exceptions-thrown-in-code"></a>Трассировка вызванных в коде исключений

При вызове исключения в коде можно также выполнить трассировку исключения на пороге предупреждений или следующем уровне посредством следующего кода.

```csharp
ts.TraceEvent(TraceEventType.Warning, 0, "Throwing exception " + "exceptionMessage");
```

## <a name="viewing-user-traces-in-the-service-trace-viewer-tool"></a>Просмотр пользовательских трассировок в программе Service Trace Viewer

В этом разделе содержатся снимки экранов трассировок, при выполнении [расширение трассировки](../../../../../docs/framework/wcf/samples/extending-tracing.md) пример, при просмотре с помощью [программа Service Trace Viewer (SvcTraceViewer.exe)](../../../../../docs/framework/wcf/service-trace-viewer-tool-svctraceviewer-exe.md).

На следующей схеме созданное ранее действие «Добавить запрос» выбрано на левой панели. Это действие входит в список с тремя другими математическими действиями ("Вычесть", "Умножить" и "Разделить"), образующими клиентское приложение. Во избежание потенциального появления ошибок в разных запросах в пользовательском коде для каждой операции определяется одно новое действие.

Чтобы продемонстрировать использование перенаправлений, в [расширение трассировки](../../../../../docs/framework/wcf/samples/extending-tracing.md) образец, также создается действие калькулятора, который инкапсулирует запросы с четырьмя операциями. Для каждого запроса существует перенаправление в прямом и обратном направлениях от действия "Калькулятор" к действию запроса (на рисунке трассировка выделена на верхней правой панели).

Когда на левой панели выбирается действие, на верхней правой панели отображаются трассировки, включаемые этим действием. Если `propagateActivity` — `true` во всех конечных точках пути запроса, трассировки в действии запроса, из всех процессов, участвующих в запросе. В этом примере в четвертом столбце панели представлены и трассировки, происходящие из клиента, и трассировки, происходящие из службы.

В этом действии следующий порядок обработки.

1. Клиент отправляет сообщение, которое требуется "Добавить".

2. Служба получает сообщение запроса "Добавить".

3. Служба отправляет ответ "Добавить".

4. Клиент получает ответ "Добавить".

Все эти шаги выполнены на уровне "Данные". При выборе трассировки в верхней правой панели в нижней правой панели отображаются сведения об этой трассировке.

На следующей схеме представлены трассировки перенаправлений из и в действие "Калькулятор", а также две пары трассировок "Запуск" и "Остановка" для действий запроса - одна для клиента и одна для службы (по одной для каждого источника трассировки).

![Средство просмотра трассировки: Выпуск пользователя&#45;кода трассировки](../../../../../docs/framework/wcf/diagnostics/tracing/media/242c9358-475a-4baf-83f3-4227aa942fcd.gif "242c9358-475a-4baf-83f3-4227aa942fcd") список действий по дате создания (левая панель) и их вложенных действий (в верхней правой панели)

Если код службы создает исключение, по причине которого клиент также создает исключение (например, когда клиент не получает ответ на запрос), для непосредственной корреляции предупреждения службы и клиента или сообщения об ошибке появляются в одном и том же действии. На следующем рисунке служба вызывает исключение с сообщением «служба отказывается обрабатывать этот запрос в пользовательском коде». Клиент также создает исключение с сообщением «серверу не удалось обработать запрос из-за внутренней ошибки.»

Ниже представлены ошибки между конечными точками для данного запроса отображаются в одном действии, если идентификатор действия запроса был распространен:

![Снимок экрана, показывающий ошибок между конечными точками для данного запроса.](./media/emitting-user-code-traces/trace-viewer-endpoint-errors.gif)

При двойном нажатии на действии "Умножить" на левой панели отображается следующий граф, содержащий трассировки действия "Умножить" для каждого задействованного процесса. Видно, что сперва предупреждение возникло в службе (создано исключение), затем последовали предупреждения и ошибки в клиенте вызванные тем, что запрос не может быть обработан. Таким образом можно сделать вывод о причинной взаимосвязи ошибок между конечными точками и выявить основную причину ошибки.

На следующем рисунке показано графическое представление корреляции ошибок:

![Снимок экрана, показывающий графическое представление корреляции ошибок.](./media/emitting-user-code-traces/trace-viewer-error-correlation.gif)

Для получения предыдущих трассировок мы задаем значение `ActivityTracing` пользовательским источникам трассировки и значение `propagateActivity=true` источнику трассировки `System.ServiceModel`. Мы не задали значение `ActivityTracing` источнику трассировки `System.ServiceModel`, чтобы включить пользовательский код в распространение действий пользовательского кода. (Если включена трассировка действий ServiceModel, идентификатор действия, определенный в клиенте не распространяется вплоть до пользовательский код службы; Передача, тем не менее, корреляции действий кода пользователя клиента и службы промежуточного действиям WCF.)

Определение действий и распространение идентификатора действия позволяет осуществить непосредственную корреляцию ошибок в конечных точках. Это ускоряет выявление основной причины ошибки.

## <a name="see-also"></a>См. также

- [Расширение трассировки](../../../../../docs/framework/wcf/samples/extending-tracing.md)
