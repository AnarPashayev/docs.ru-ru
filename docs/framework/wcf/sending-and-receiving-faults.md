---
title: Сбои при отправке и получении
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- handling faults [WCF], sending
ms.assetid: 7be6fb96-ce2a-450b-aebe-f932c6a4bc5d
ms.openlocfilehash: 447928ec3e6c0eaab997f839ab1aab49c677ad44
ms.sourcegitcommit: 581ab03291e91983459e56e40ea8d97b5189227e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/27/2019
ms.locfileid: "70044473"
---
# <a name="sending-and-receiving-faults"></a><span data-ttu-id="6aa61-102">Сбои при отправке и получении</span><span class="sxs-lookup"><span data-stu-id="6aa61-102">Sending and Receiving Faults</span></span>

<span data-ttu-id="6aa61-103">Ошибки SOAP передают сведения об ошибке от службы клиенту и, в дуплексном случае, от клиента службе совместимым способом.</span><span class="sxs-lookup"><span data-stu-id="6aa61-103">SOAP faults convey error condition information from a service to a client and in the duplex case from a client to a service in an interoperable way.</span></span> <span data-ttu-id="6aa61-104">Как правило, служба определяет пользовательское содержимое ошибки и указывает операции, которые могут возвращать такие ошибки.</span><span class="sxs-lookup"><span data-stu-id="6aa61-104">Typically a service defines custom fault content and specifies which operations can return them.</span></span> <span data-ttu-id="6aa61-105">(Дополнительные сведения см. в разделе [Определение и указание ошибок](../../../docs/framework/wcf/defining-and-specifying-faults.md).) В этом разделе описывается, как служба или дуплексный клиент могут отправлять такие ошибки в случае возникновения соответствующих условий и как клиентское приложение или приложение службы обрабатывает эти ошибки.</span><span class="sxs-lookup"><span data-stu-id="6aa61-105">(For more information, see [Defining and Specifying Faults](../../../docs/framework/wcf/defining-and-specifying-faults.md).) This topic discusses how a service or duplex client can send those faults when the corresponding error condition has occurred and how a client or service application handles these faults.</span></span> <span data-ttu-id="6aa61-106">Общие сведения об обработке ошибок в приложениях Windows Communication Foundation (WCF) см. в разделе [Указание и обработка ошибок в контрактах и службах](../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md).</span><span class="sxs-lookup"><span data-stu-id="6aa61-106">For an overview of error handling in Windows Communication Foundation (WCF) applications, see [Specifying and Handling Faults in Contracts and Services](../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md).</span></span>

## <a name="sending-soap-faults"></a><span data-ttu-id="6aa61-107">Отправка ошибок SOAP</span><span class="sxs-lookup"><span data-stu-id="6aa61-107">Sending SOAP Faults</span></span>

<span data-ttu-id="6aa61-108">Объявленные ошибки SOAP - это ошибки, в которых в операции имеется атрибут <xref:System.ServiceModel.FaultContractAttribute?displayProperty=nameWithType>, указывающий пользовательский тип ошибки SOAP.</span><span class="sxs-lookup"><span data-stu-id="6aa61-108">Declared SOAP faults are those in which an operation has a <xref:System.ServiceModel.FaultContractAttribute?displayProperty=nameWithType> that specifies a custom SOAP fault type.</span></span> <span data-ttu-id="6aa61-109">Необъявленные ошибки SOAP - это ошибки, не указанные в контракте операции.</span><span class="sxs-lookup"><span data-stu-id="6aa61-109">Undeclared SOAP faults are those that are not specified in the contract for an operation.</span></span>

### <a name="sending-declared-faults"></a><span data-ttu-id="6aa61-110">Отправка объявленных ошибок</span><span class="sxs-lookup"><span data-stu-id="6aa61-110">Sending Declared Faults</span></span>

<span data-ttu-id="6aa61-111">Чтобы отправить объявленную ошибку SOAP, необходимо обнаружить условия ошибки, в которых возникает ошибка SOAP, и создать новое исключение <xref:System.ServiceModel.FaultException%601?displayProperty=nameWithType>, в котором параметр типа является новым объектом типа, указанным в атрибуте <xref:System.ServiceModel.FaultContractAttribute> для этой операции.</span><span class="sxs-lookup"><span data-stu-id="6aa61-111">To send a declared SOAP fault, detect the error condition for which the SOAP fault is appropriate and throw a new <xref:System.ServiceModel.FaultException%601?displayProperty=nameWithType> where the type parameter is a new object of the type specified in the <xref:System.ServiceModel.FaultContractAttribute> for that operation.</span></span> <span data-ttu-id="6aa61-112">В следующем примере кода показано, как с помощью атрибута <xref:System.ServiceModel.FaultContractAttribute> указать, что операция `SampleMethod` может возвращать ошибку SOAP с типом по умолчанию `GreetingFault`.</span><span class="sxs-lookup"><span data-stu-id="6aa61-112">The following code example shows the use of <xref:System.ServiceModel.FaultContractAttribute> to specify that the `SampleMethod` operation can return a SOAP fault with the detail type of `GreetingFault`.</span></span>

[!code-csharp[FaultContractAttribute#4](../../../samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/services.cs#4)]
[!code-vb[FaultContractAttribute#4](../../../samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/services.vb#4)]

<span data-ttu-id="6aa61-113">Для передачи клиенту сведений об ошибке `GreetingFault` необходимо перехватить ошибку и создать новое исключение <xref:System.ServiceModel.FaultException%601?displayProperty=nameWithType> типа `GreetingFault` с новым объектом `GreetingFault` в качестве аргумента; см. пример кода ниже.</span><span class="sxs-lookup"><span data-stu-id="6aa61-113">To convey the `GreetingFault` error information to the client, catch the appropriate error condition and throw a new <xref:System.ServiceModel.FaultException%601?displayProperty=nameWithType> of type `GreetingFault` with a new `GreetingFault` object as the argument, as in the following code example.</span></span> <span data-ttu-id="6aa61-114">Если клиент является клиентским приложением WCF, он работает как управляемое исключение, в котором тип имеет <xref:System.ServiceModel.FaultException%601?displayProperty=nameWithType> тип. `GreetingFault`</span><span class="sxs-lookup"><span data-stu-id="6aa61-114">If the client is an WCF client application, it experiences this as a managed exception where the type is <xref:System.ServiceModel.FaultException%601?displayProperty=nameWithType> of type `GreetingFault`.</span></span>

[!code-csharp[FaultContractAttribute#5](../../../samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/services.cs#5)]
[!code-vb[FaultContractAttribute#5](../../../samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/services.vb#5)]

### <a name="sending-undeclared-faults"></a><span data-ttu-id="6aa61-115">Отправка необъявленных ошибок</span><span class="sxs-lookup"><span data-stu-id="6aa61-115">Sending Undeclared Faults</span></span>

<span data-ttu-id="6aa61-116">Отправка необъявленных сбоев может оказаться очень полезной для быстрой диагностики и отладки проблем в приложениях WCF, но ее полезность в том, что это средство отладки ограничено.</span><span class="sxs-lookup"><span data-stu-id="6aa61-116">Sending undeclared faults can be very useful to quickly diagnose and debug problems in WCF applications, but its usefulness as a debugging tool is limited.</span></span> <span data-ttu-id="6aa61-117">В общем случае при отладке рекомендуется использовать свойство <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6aa61-117">More generally, when debugging it is recommended that you use the <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="6aa61-118">Если свойству присвоено значение true, клиенты получают такие ошибки в виде исключений <xref:System.ServiceModel.FaultException%601> типа <xref:System.ServiceModel.ExceptionDetail>.</span><span class="sxs-lookup"><span data-stu-id="6aa61-118">When you set this value to true, clients experience such faults as <xref:System.ServiceModel.FaultException%601> exceptions of type <xref:System.ServiceModel.ExceptionDetail>.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="6aa61-119">Так как управляемые исключения могут предоставлять внутренние сведения о приложении <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> , <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> устанавливать `true` или разрешать клиентам WCF получать сведения о внутренних исключениях операций службы, включая личные идентифицируемые или другие конфиденциальные сведения.</span><span class="sxs-lookup"><span data-stu-id="6aa61-119">Because managed exceptions can expose internal application information, setting <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> to `true` can permit WCF clients to obtain information about internal service operation exceptions, including personally identifiable or other sensitive information.</span></span>
>
> <span data-ttu-id="6aa61-120">Поэтому задавать для свойства <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> или <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> значение `true` рекомендуется только для временной отладки приложения службы.</span><span class="sxs-lookup"><span data-stu-id="6aa61-120">Therefore, setting <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> to `true` is only recommended as a way of temporarily debugging a service application.</span></span> <span data-ttu-id="6aa61-121">Кроме того, WSDL для метода, который возвращает такие необработанные управляемые исключения, не содержит контракт для исключения <xref:System.ServiceModel.FaultException%601> типа <xref:System.ServiceModel.ExceptionDetail>.</span><span class="sxs-lookup"><span data-stu-id="6aa61-121">In addition, the WSDL for a method that returns unhandled managed exceptions in this way does not contain the contract for the <xref:System.ServiceModel.FaultException%601> of type <xref:System.ServiceModel.ExceptionDetail>.</span></span> <span data-ttu-id="6aa61-122">Клиенты должны рассчитывать на возможность неизвестной ошибки SOAP (возвращается клиентам WCF как <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> объекты) для правильного получения отладочной информации.</span><span class="sxs-lookup"><span data-stu-id="6aa61-122">Clients must expect the possibility of an unknown SOAP fault (returned to WCF clients as <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> objects) to obtain the debugging information properly.</span></span>

<span data-ttu-id="6aa61-123">Чтобы отправить необъявленную ошибку SOAP, необходимо создать объект <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> (не универсального типа <xref:System.ServiceModel.FaultException%601>) и передать строку конструктору.</span><span class="sxs-lookup"><span data-stu-id="6aa61-123">To send an undeclared SOAP fault, throw a <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> object (that is, not the generic type <xref:System.ServiceModel.FaultException%601>) and pass the string to the constructor.</span></span> <span data-ttu-id="6aa61-124">Это значение предоставляется клиентским приложениям WCF в виде вызванного <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> исключения, когда строка доступна путем <xref:System.ServiceModel.FaultException%601.ToString%2A?displayProperty=nameWithType> вызова метода.</span><span class="sxs-lookup"><span data-stu-id="6aa61-124">This is exposed to the WCF client applications as a thrown <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> exception where the string is available by calling the <xref:System.ServiceModel.FaultException%601.ToString%2A?displayProperty=nameWithType> method.</span></span>

> [!NOTE]
> <span data-ttu-id="6aa61-125">Если объявлена ошибка SOAP строкового типа, а затем она выдана службе в виде объекта <xref:System.ServiceModel.FaultException%601> с параметром типа <xref:System.String?displayProperty=nameWithType>, значение строки присваивается свойству <xref:System.ServiceModel.FaultException%601.Detail%2A?displayProperty=nameWithType> и недоступно в свойстве <xref:System.ServiceModel.FaultException%601.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6aa61-125">If you declare a SOAP fault of type string, and then throw this in your service as a <xref:System.ServiceModel.FaultException%601> where the type parameter is a <xref:System.String?displayProperty=nameWithType> the string value is assigned to the <xref:System.ServiceModel.FaultException%601.Detail%2A?displayProperty=nameWithType> property, and is not available from <xref:System.ServiceModel.FaultException%601.ToString%2A?displayProperty=nameWithType>.</span></span>

## <a name="handling-faults"></a><span data-ttu-id="6aa61-126">Обработка ошибок</span><span class="sxs-lookup"><span data-stu-id="6aa61-126">Handling Faults</span></span>

<span data-ttu-id="6aa61-127">В клиентах WCF ошибки SOAP, происходящие при обмене данными, которые представляют интерес для клиентских приложений, вызываются как управляемые исключения.</span><span class="sxs-lookup"><span data-stu-id="6aa61-127">In WCF clients, SOAP faults that occur during communication that are of interest to client applications are raised as managed exceptions.</span></span> <span data-ttu-id="6aa61-128">Хотя существует множество исключений, которые могут возникнуть во время выполнения любой программы, приложения, использующие клиентскую модель программирования WCF, могут рассчитывать исключения следующих двух типов в результате обмена данными.</span><span class="sxs-lookup"><span data-stu-id="6aa61-128">While there are many exceptions that can occur during the execution of any program, applications using the WCF client programming model can expect to handle exceptions of the following two types as a result of communication.</span></span>

- <xref:System.TimeoutException>

- <xref:System.ServiceModel.CommunicationException>

<span data-ttu-id="6aa61-129">Объекты <xref:System.TimeoutException> выдаются по истечении заданного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="6aa61-129"><xref:System.TimeoutException> objects are thrown when an operation exceeds the specified timeout period.</span></span>

<span data-ttu-id="6aa61-130">Объекты <xref:System.ServiceModel.CommunicationException> выдаются в случае возникновения устранимой ошибки передачи данных в службе или клиенте.</span><span class="sxs-lookup"><span data-stu-id="6aa61-130"><xref:System.ServiceModel.CommunicationException> objects are thrown when there is some recoverable communication error condition on either the service or the client.</span></span>

<span data-ttu-id="6aa61-131">Класс <xref:System.ServiceModel.CommunicationException> имеет два важных производных типа, <xref:System.ServiceModel.FaultException> и универсальный тип <xref:System.ServiceModel.FaultException%601>.</span><span class="sxs-lookup"><span data-stu-id="6aa61-131">The <xref:System.ServiceModel.CommunicationException> class has two important derived types, <xref:System.ServiceModel.FaultException> and the generic <xref:System.ServiceModel.FaultException%601> type.</span></span>

<span data-ttu-id="6aa61-132">Исключения <xref:System.ServiceModel.FaultException> выдаются, когда прослушиватель получает неожиданную или не указанную в контракте операции ошибку. Обычно это происходит во время отладки приложения, когда свойству <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> службы присвоено значение `true`.</span><span class="sxs-lookup"><span data-stu-id="6aa61-132"><xref:System.ServiceModel.FaultException> exceptions are thrown when a listener receives a fault that is not expected or specified in the operation contract; usually this occurs when the application is being debugged and the service has the <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> property set to `true`.</span></span>

<span data-ttu-id="6aa61-133">Исключения <xref:System.ServiceModel.FaultException%601> выдаются в клиенте при получении ошибки, указанной в контракте операции, в ответ на двустороннюю операцию (т.е. метод с атрибутом <xref:System.ServiceModel.OperationContractAttribute>, у которого свойству <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> присвоено значение `false`).</span><span class="sxs-lookup"><span data-stu-id="6aa61-133"><xref:System.ServiceModel.FaultException%601> exceptions are thrown on the client when a fault that is specified in the operation contract is received in response to a two-way operation (that is, a method with an <xref:System.ServiceModel.OperationContractAttribute> attribute with <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> set to `false`).</span></span>

> [!NOTE]
> <span data-ttu-id="6aa61-134"><xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> Если в службе WCF свойство или `true` <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> задано для клиента как необъявленное <xref:System.ServiceModel.FaultException%601> значение типа <xref:System.ServiceModel.ExceptionDetail>.</span><span class="sxs-lookup"><span data-stu-id="6aa61-134">When an WCF service has the <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> property set to `true` the client experiences this as an undeclared <xref:System.ServiceModel.FaultException%601> of type <xref:System.ServiceModel.ExceptionDetail>.</span></span> <span data-ttu-id="6aa61-135">Клиенты могут либо перехватить эту определенную ошибку, либо обработать ее в блоке catch для <xref:System.ServiceModel.FaultException>.</span><span class="sxs-lookup"><span data-stu-id="6aa61-135">Clients can either catch this specific fault or handle the fault in a catch block for <xref:System.ServiceModel.FaultException>.</span></span>

<span data-ttu-id="6aa61-136">Как правило, только исключения <xref:System.ServiceModel.FaultException%601>, <xref:System.TimeoutException> и <xref:System.ServiceModel.CommunicationException> представляют интерес для клиентов и служб.</span><span class="sxs-lookup"><span data-stu-id="6aa61-136">Typically, only <xref:System.ServiceModel.FaultException%601>, <xref:System.TimeoutException>, and <xref:System.ServiceModel.CommunicationException> exceptions are of interest to clients and services.</span></span>

> [!NOTE]
> <span data-ttu-id="6aa61-137">Конечно, возникают и другие исключения.</span><span class="sxs-lookup"><span data-stu-id="6aa61-137">Other exceptions, of course, do occur.</span></span> <span data-ttu-id="6aa61-138">К неожиданным исключениям относятся неустранимые ошибки, например <xref:System.OutOfMemoryException?displayProperty=nameWithType>. Как правило, приложения не должны перехватывать такие методы.</span><span class="sxs-lookup"><span data-stu-id="6aa61-138">Unexpected exceptions include catastrophic failures like <xref:System.OutOfMemoryException?displayProperty=nameWithType>; typically applications should not catch such methods.</span></span>

### <a name="catch-fault-exceptions-in-the-correct-order"></a><span data-ttu-id="6aa61-139">Перехват исключений ошибок в правильном порядке</span><span class="sxs-lookup"><span data-stu-id="6aa61-139">Catch Fault Exceptions in the Correct Order</span></span>

<span data-ttu-id="6aa61-140">Поскольку класс <xref:System.ServiceModel.FaultException%601> является производным класса <xref:System.ServiceModel.FaultException>, а класс <xref:System.ServiceModel.FaultException> является производным класса <xref:System.ServiceModel.CommunicationException>, важно перехватывать эти исключения в нужном порядке.</span><span class="sxs-lookup"><span data-stu-id="6aa61-140">Because <xref:System.ServiceModel.FaultException%601> derives from <xref:System.ServiceModel.FaultException>, and <xref:System.ServiceModel.FaultException> derives from <xref:System.ServiceModel.CommunicationException>, it is important to catch these exceptions in the proper order.</span></span> <span data-ttu-id="6aa61-141">Например, если в блоке try/catch сначала перехватывается исключение <xref:System.ServiceModel.CommunicationException>, обработка всех объявленных и необъявленных ошибок SOAP будет выполняться в этом блоке. Все последующие блоки catch, предназначенные для обработки пользовательского исключения <xref:System.ServiceModel.FaultException%601>, не вызываются никогда.</span><span class="sxs-lookup"><span data-stu-id="6aa61-141">If, for example, you have a try/catch block in which you first catch <xref:System.ServiceModel.CommunicationException>, all specified and unspecified SOAP faults are handled there; any subsequent catch blocks to handle a custom <xref:System.ServiceModel.FaultException%601> exception are never invoked.</span></span>

<span data-ttu-id="6aa61-142">Помните, что одна операция может возвращать любое количество объявленных ошибок.</span><span class="sxs-lookup"><span data-stu-id="6aa61-142">Remember that one operation can return any number of specified faults.</span></span> <span data-ttu-id="6aa61-143">Каждая ошибка имеет уникальный тип и должна обрабатываться отдельно.</span><span class="sxs-lookup"><span data-stu-id="6aa61-143">Each fault is a unique type and must be handled separately.</span></span>

### <a name="handle-exceptions-when-closing-the-channel"></a><span data-ttu-id="6aa61-144">Обработка исключений при закрытии канала</span><span class="sxs-lookup"><span data-stu-id="6aa61-144">Handle Exceptions When Closing the Channel</span></span>

<span data-ttu-id="6aa61-145">Большая часть предыдущего обсуждения связана с ошибками, отправленными в процессе обработки сообщений приложения, то есть сообщения, явно отправленные клиентом, когда клиентское приложение вызывает операции в клиентском объекте WCF.</span><span class="sxs-lookup"><span data-stu-id="6aa61-145">Most of the preceding discussion has to do with faults sent in the course of processing application messages, that is, messages explicitly sent by the client when the client application calls operations on the WCF client object.</span></span>

<span data-ttu-id="6aa61-146">Даже при удалении локального объекта могут быть созданы или скрыты исключения, возникающие в процессе перезапуска.</span><span class="sxs-lookup"><span data-stu-id="6aa61-146">Even with local objects disposing the object can either raise or mask exceptions that occur during the recycling process.</span></span> <span data-ttu-id="6aa61-147">Что-то подобное может произойти при использовании объектов клиента WCF.</span><span class="sxs-lookup"><span data-stu-id="6aa61-147">Something similar can occur when you use WCF client objects.</span></span> <span data-ttu-id="6aa61-148">При вызове операций сообщения передаются по установленному подключению.</span><span class="sxs-lookup"><span data-stu-id="6aa61-148">When you call operations you are sending messages over an established connection.</span></span> <span data-ttu-id="6aa61-149">Закрытие канала может приводить к исключениям, если не удается аккуратно закрыть подключение или если оно уже закрыто, даже при надлежащем возврате всех операций.</span><span class="sxs-lookup"><span data-stu-id="6aa61-149">Closing the channel can throw exceptions if the connection cannot be cleanly closed or is already closed, even if all the operations returned properly.</span></span>

<span data-ttu-id="6aa61-150">Как правило, каналы объекта клиента закрываются одним из следующих способов.</span><span class="sxs-lookup"><span data-stu-id="6aa61-150">Typically, client object channels are closed in one of the following ways:</span></span>

- <span data-ttu-id="6aa61-151">При повторном запуске клиентского объекта WCF.</span><span class="sxs-lookup"><span data-stu-id="6aa61-151">When the WCF client object is recycled.</span></span>

- <span data-ttu-id="6aa61-152">При вызове метода <xref:System.ServiceModel.ClientBase%601.Close%2A?displayProperty=nameWithType> клиентским приложением.</span><span class="sxs-lookup"><span data-stu-id="6aa61-152">When the client application calls <xref:System.ServiceModel.ClientBase%601.Close%2A?displayProperty=nameWithType>.</span></span>

- <span data-ttu-id="6aa61-153">При вызове метода <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> клиентским приложением.</span><span class="sxs-lookup"><span data-stu-id="6aa61-153">When the client application calls <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType>.</span></span>

- <span data-ttu-id="6aa61-154">При вызове клиентским приложением операции, которая является завершающей операцией сеанса.</span><span class="sxs-lookup"><span data-stu-id="6aa61-154">When the client application calls an operation that is a terminating operation for a session.</span></span>

<span data-ttu-id="6aa61-155">Во всех случаях при закрытии канал получает указания начать закрытие всех базовых каналов, которые могут отправлять сообщения для поддержки сложных функций на уровне приложения.</span><span class="sxs-lookup"><span data-stu-id="6aa61-155">In all cases, closing the channel instructs the channel to begin closing any underlying channels that may be sending messages to support complex functionality at the application level.</span></span> <span data-ttu-id="6aa61-156">Например, если контракту требуются сеансы, привязка предпринимает попытки установить сеанс путем обмена сообщениями с каналом службы до тех пор, пока сеанс не будет установлен.</span><span class="sxs-lookup"><span data-stu-id="6aa61-156">For example, when a contract requires sessions a binding attempts to establish a session by exchanging messages with the service channel until a session is established.</span></span> <span data-ttu-id="6aa61-157">После закрытия канала базовый канал сеанса уведомляет службу о прерывании сеанса.</span><span class="sxs-lookup"><span data-stu-id="6aa61-157">When the channel is closed, the underlying session channel notifies the service that the session is terminated.</span></span> <span data-ttu-id="6aa61-158">Если канал уже был прерван, закрыт или иным образом стал непригодным (например, при отключении сетевого кабеля), канал клиента не может уведомить канал службы о прекращении сеанса и возможном исключении.</span><span class="sxs-lookup"><span data-stu-id="6aa61-158">In this case, if the channel has already aborted, closed, or is otherwise unusable (for example, when a network cable is unplugged), the client channel cannot inform the service channel that the session is terminated and an exception can result.</span></span>

### <a name="abort-the-channel-if-necessary"></a><span data-ttu-id="6aa61-159">Прерывание работы канала при необходимости</span><span class="sxs-lookup"><span data-stu-id="6aa61-159">Abort the Channel If Necessary</span></span>

<span data-ttu-id="6aa61-160">Поскольку при закрытии канала также могут создаваться исключения, рекомендуется в дополнение к перехвату исключений ошибок в правильном порядке прерывать канал, использованный в вызове, в блоке catch.</span><span class="sxs-lookup"><span data-stu-id="6aa61-160">Because closing the channel can also throw exceptions, then, it is recommended that in addition to catching fault exceptions in the correct order, it is important to abort the channel that was used in making the call in the catch block.</span></span>

<span data-ttu-id="6aa61-161">Если ошибка содержит сведения об ошибке, касающиеся операции, и существует возможность использования ее другими объектами, прерывать канал не требуется (такие случаи являются редкими).</span><span class="sxs-lookup"><span data-stu-id="6aa61-161">If the fault conveys error information specific to an operation and it remains possible that others can use it, there is no need to abort the channel (although these cases are rare).</span></span> <span data-ttu-id="6aa61-162">Во всех остальных случаях рекомендуется прерывать канал.</span><span class="sxs-lookup"><span data-stu-id="6aa61-162">In all other cases, it is recommended that you abort the channel.</span></span> <span data-ttu-id="6aa61-163">Пример, демонстрирующий все эти моменты, см. в разделе [ожидаемые исключения](../../../docs/framework/wcf/samples/expected-exceptions.md).</span><span class="sxs-lookup"><span data-stu-id="6aa61-163">For a sample that demonstrates all of these points, see [Expected Exceptions](../../../docs/framework/wcf/samples/expected-exceptions.md).</span></span>

<span data-ttu-id="6aa61-164">В следующем примере кода демонстрируется обработка исключений ошибок SOAP в простом клиентском приложении, в том числе объявленных и необъявленных ошибок.</span><span class="sxs-lookup"><span data-stu-id="6aa61-164">The following code example shows how to handle SOAP fault exceptions in a basic client application, including a declared fault and an undeclared fault.</span></span>

> [!NOTE]
> <span data-ttu-id="6aa61-165">В этом примере кода не используется конструкция `using`.</span><span class="sxs-lookup"><span data-stu-id="6aa61-165">This sample code does not use the `using` construct.</span></span> <span data-ttu-id="6aa61-166">Поскольку закрытие каналов может вызывать исключения, рекомендуется сначала создать клиент WCF, а затем открыть, использовать и закрыть клиент WCF в том же блоке try.</span><span class="sxs-lookup"><span data-stu-id="6aa61-166">Because closing channels can throw exceptions, it is recommended that applications create a WCF client first, and then open, use, and close the WCF client in the same try block.</span></span> <span data-ttu-id="6aa61-167">Дополнительные сведения см. в статье [Общие сведения о клиенте WCF](../../../docs/framework/wcf/wcf-client-overview.md) и [Использование Close и Abort для освобождения ресурсов клиента WCF](../../../docs/framework/wcf/samples/use-close-abort-release-wcf-client-resources.md).</span><span class="sxs-lookup"><span data-stu-id="6aa61-167">For details, see [WCF Client Overview](../../../docs/framework/wcf/wcf-client-overview.md) and [Use Close and Abort to release WCF client resources](../../../docs/framework/wcf/samples/use-close-abort-release-wcf-client-resources.md).</span></span>

[!code-csharp[FaultContractAttribute#3](../../../samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/client.cs#3)]
[!code-vb[FaultContractAttribute#3](../../../samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/client.vb#3)]

## <a name="see-also"></a><span data-ttu-id="6aa61-168">См. также</span><span class="sxs-lookup"><span data-stu-id="6aa61-168">See also</span></span>

- <xref:System.ServiceModel.FaultException>
- <xref:System.ServiceModel.FaultException%601>
- <xref:System.ServiceModel.CommunicationException?displayProperty=nameWithType>
- [<span data-ttu-id="6aa61-169">Ожидаемые исключения</span><span class="sxs-lookup"><span data-stu-id="6aa61-169">Expected Exceptions</span></span>](../../../docs/framework/wcf/samples/expected-exceptions.md)
- [<span data-ttu-id="6aa61-170">Использование закрытия и прерывания для освобождения ресурсов клиента WCF</span><span class="sxs-lookup"><span data-stu-id="6aa61-170">Use Close and Abort to release WCF client resources</span></span>](../../../docs/framework/wcf/samples/use-close-abort-release-wcf-client-resources.md)
