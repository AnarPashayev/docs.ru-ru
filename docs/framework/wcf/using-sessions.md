---
title: Использование сеансов
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- sessions [WCF]
ms.assetid: 864ba12f-3331-4359-a359-6d6d387f1035
ms.openlocfilehash: a879e90aeab7b40529df1f1a60cd1f879c39720a
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79143178"
---
# <a name="using-sessions"></a>Использование сеансов
В приложениях Windows Communication Foundation (WCF) *сеанс* соотносит группу сообщений в разговор. Сеансы WCF отличаются от объектов сеанса, доступных в ASP.NET приложениях, поддерживают различные модели поведения и контролируются по-разному. Эта тема описывает функции, которые сеансы позволяют в приложениях WCF и как их использовать.  
  
## <a name="sessions-in-windows-communication-foundation-applications"></a>Сеансы в приложениях Windows Communication Foundation  
 Если в контракте службы указано, что для него требуется сеанс, это означает, что все вызовы (т. е. обмен сообщениями, на котором он основан) должны быть частью одного диалога. Если в контракте указано, что сеансы для него разрешены, но не требуются, клиенты могут подключаться, создавая сеанс или не создавая его. Если сеанс завершен и по его каналу отправляется сообщение, выдается исключение.  
  
 Сессии WCF имеют следующие основные концептуальные особенности:  
  
- Они явным образом инициируются и завершаются вызвавшим приложением (клиентом WCF).  
  
- Сообщения, доставленные в ходе сеанса, обрабатываются в порядке их получения.  
  
- Сеанс коррелирует группу сообщений в диалог. Возможны различные типы корреляций. Например, один основанный на сеансах канал может коррелировать сообщения, основываясь на общем сетевом подключении, а другой - основываясь на общем теге в тексте сообщения. Функции, получаемые в результате сеанса, зависят от характера корреляции.  
  
- Общего хранилища данных, связанного с сеансом WCF, не существует.  
  
 Если вы знакомы <xref:System.Web.SessionState.HttpSessionState?displayProperty=nameWithType> с классом в ASP.NET приложений и функциональностью, которую он предоставляет, вы можете заметить следующие различия между такого рода сессиями и сессиями WCF:  
  
- ASP.NET сеансы всегда инициированы сервером.  
  
- ASP.NET сеансы неявно неупорядочены.  
  
- ASP.NET сеансы обеспечивают общий механизм хранения данных в разных запросах.  
  
 Содержание этого раздела:  
  
- Поведение выполнения по умолчанию при использовании привязок, основанных на сеансе, в уровне модели службы.  
  
- Типы функций, которые обеспечивают сярприги на основе сессии WCF, системные привязки.  
  
- Создание контракта, объявляющего требование сеанса.  
  
- Управление созданием и прекращением сеанса и его связью с экземпляром службы.  
  
## <a name="default-execution-behavior-using-sessions"></a>Поведение выполнения по умолчанию с использованием сеансов  
 Привязка, пытающаяся инициировать сеанс, называется *основанной на сеансе* . Контракты служб указывают о том, что для них требуются, допускаются или не допускаются привязки, основанные на сеансе. Для этого свойству <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> интерфейса (или класса) контракта службы присваивается одно из значений перечисления <xref:System.ServiceModel.SessionMode?displayProperty=nameWithType> . По умолчанию значение этого <xref:System.ServiceModel.SessionMode.Allowed>свойства составляется, что означает, что если клиент использует привязку на основе сеанса с реализацией службы WCF, служба устанавливает и использует предоставленную сессию.  
  
 Когда служба WCF принимает сеанс клиента, по умолчанию включены следующие функции:  
  
1. Все вызовы между объектом клиента WCF обрабатываются в одном экземпляре службы.  
  
2. Различные привязки на основе сеанса предоставляют дополнительные возможности.  
  
## <a name="system-provided-session-types"></a>Типы сеансов, предоставляемые системой  
 Привязка, основанная на сеансе, поддерживает ассоциацию по умолчанию экземпляра службы с определенным сеансом. Впрочем, различные привязки, основанные на сеансе, поддерживают и другие различные функции, помимо описанного выше управления созданием экземпляров на основе сеанса.  
  
 WCF предоставляет следующие типы поведения приложений на основе сеансов:  
  
- Элемент <xref:System.ServiceModel.Channels.SecurityBindingElement?displayProperty=nameWithType> поддерживает основанные на безопасности сеансы, в которых обе стороны, обменивающиеся информацией, согласовали определенный безопасный диалог. Для получения дополнительной [информации см.](securing-services.md) Например, привязка <xref:System.ServiceModel.WSHttpBinding?displayProperty=nameWithType> , содержащая поддержку как безопасных, так и надежных сеансов, по умолчанию использует только безопасный сеанс, шифрующий сообщения и защищающий их цифровой подписью.  
  
- Привязка <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> поддерживает сеансы, основанные на TCP/IP, что обеспечивает корреляцию всех сообщений по подключению на уровне сокетов.  
  
- Элемент <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType> , реализующий спецификацию WS-ReliableMessaging, обеспечивает поддержку надежных сеансов, в которых можно настроить отправку сообщений в определенном порядке и только один раз, что гарантирует получение сообщений, даже когда при диалоге они проходят через несколько узлов. Для получения дополнительной [информации см.](./feature-details/reliable-sessions.md)  
  
- Привязка <xref:System.ServiceModel.NetMsmqBinding?displayProperty=nameWithType> обеспечивает сеансы датаграммы MSMQ. Для получения дополнительной [информации, см.](./feature-details/queues-in-wcf.md)  
  
 Установка свойства <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> указывает о том, что для контракта требуется сеанс, но не задает тип этого сеанса.  
  
## <a name="creating-a-contract-that-requires-a-session"></a>Создание контракта, требующего сеанс  
 Создание контракта, требующего сеанс, означает, что группа операций, объявляемых контрактом службы, должна выполняться в пределах одного сеанса и сообщения должны быть доставлены в определенном порядке. Чтобы назначить уровень поддержки сеансов, требуемый контрактом, задайте в качестве значения свойства <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> класса или интерфейса контракта службы перечисление <xref:System.ServiceModel.SessionMode?displayProperty=nameWithType> . При этом указывается одно из следующих условий контракта:  
  
- Требуется сеанс.  
  
- Клиенту допускается создавать сеанс.  
  
- Сеансы запрещены.  
  
 Впрочем, установка свойства <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> не указывает требуемый контрактом тип поведения, основанного на сеансе. Он поручает WCF подтвердить во время выполнения, что настроенная связка (которая создает канал связи) для службы не делает, не делает или может установить сеанс при реализации службы. Опять же, привязка может выполнить это требование с любым типом поведения, основанного на сеансе: безопасность, транспорт, надежность или некоторая комбинация этих типов. Конкретное поведение зависит от выбранного значения <xref:System.ServiceModel.SessionMode?displayProperty=nameWithType> . Если настроенная для службы привязка не соответствует значению <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A>, выдается исключение. Привязки и создаваемые ими каналы, поддерживающие сеансы, называются основанными на сеансах.  
  
 Следующий контракт службы указывает, что все операции в `ICalculatorSession` необходимо выполнить в пределах одного сеанса. Ни одна операция не возвращает значение вызвавшему объекту, за исключением метода `Equals` . Впрочем, метод `Equals` не принимает параметры, а потому может возвращать только ненулевое значение в пределах сеанса, в котором данные уже переданы другим операциям. Для правильной работы этого контракта требуется сеанс. При отсутствии сеанса, связанного с определенным клиентом, экземпляр службы не может определить, какие именно данные отправил клиент.  
  
 [!code-csharp[S_Service_Session#1](../../../samples/snippets/csharp/VS_Snippets_CFX/s_service_session/cs/service.cs#1)]
 [!code-vb[S_Service_Session#1](../../../samples/snippets/visualbasic/VS_Snippets_CFX/s_service_session/vb/service.vb#1)]  
  
 Если сеанс разрешен службой, он создается и используется, если он инициирован клиентом. В противном случае сеанс не создается.  
  
## <a name="sessions-and-service-instances"></a>Сеансы и экземпляры служб  
 При использовании поведения по умолчанию в WCF все вызовы между клиентом WCF обрабатываются одним и тем же экземпляром службы. Таким образом, на уровне приложения можно считать, что сеанс обеспечивает поведение приложений, аналогичное поведению местных вызовов. Например, при создании локального объекта происходит следующее:  
  
- Вызывается конструктор.  
  
- Все последующие вызовы, сделанные в ссылку на объект клиента WCF, обрабатываются одной и той же инстанцией объекта.  
  
- Деструктор вызывается при уничтожении ссылки на объект.  
  
 Сеансы обеспечивают аналогичное поведение при взаимодействии между клиентами и службами, если используется поведение создания экземпляров службы по умолчанию. Если контракт службы требует или поддерживает сеансы, можно отметить операцию (или несколько операций) как инициирующую или завершающую сеанс. Для этого необходимо задать свойства <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> и <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A> .  
  
 *Инициирующие операции* - это операции, вызываемые в качестве первых операций новых сеансов. Неинициирующие операции могут вызываться только после вызова по крайней мере одной инициирующей операции. Поэтому можно создать некоторое подобие конструктора сеансов для службы, объявив инициирующие операции, которые принимают от клиентов входные данные, как подходящие для создания экземпляра службы. (Впрочем, состояние ассоциируется с сеансом, а не с объектом службы.)  
  
 *Завершающие операции*- это, соответственно, операции, вызываемые как последние сообщения существующих сеансов. В случае по умолчанию WCF повторно использует объект службы и его контекст после закрытия сеанса, с которым была связана эта служба. Поэтому можно создать некоторое подобие деструктора, объявив завершающие операции, которые выполняют функции по завершению действия экземпляра службы.  
  
> [!NOTE]
> Поведение по умолчанию имеет сходство с локальными конструкторами и деструкторами, но это не более чем сходство. Любая операция wCF может быть инагитированием или прекращением операции, или и то и другое одновременно. Кроме того, в случае по умолчанию инициирующие операции можно вызывать сколько угодно раз и в любом порядке. После того как сеанс установлен и связан с экземпляром, дополнительные сеансы могут быть созданы только в случае осуществления явным образом управления временем существования экземпляра службы (путем обработки объекта <xref:System.ServiceModel.InstanceContext?displayProperty=nameWithType> ). И наконец, состояние связывается с сеансом, а не с объектом службы.  
  
 Например, `ICalculatorSession` контракт, используемый в предыдущем примере, требует, `Clear` чтобы клиентский объект WCF сначала вызвал операцию до любой `Equals` другой операции и чтобы сеанс с этим клиентом WCF был прекращен при вызове операции. В следующем примере кода приведен контракт, обеспечивающий выполнение этих требований. Для инициации сеанса сначала необходимо вызвать операцию`Clear` , а завершится сеанс при вызове операции `Equals` .  
  
 [!code-csharp[SCA.IsInitiatingIsTerminating#1](../../../samples/snippets/csharp/VS_Snippets_CFX/sca.isinitiatingisterminating/cs/service.cs#1)]
 [!code-vb[SCA.IsInitiatingIsTerminating#1](../../../samples/snippets/visualbasic/VS_Snippets_CFX/sca.isinitiatingisterminating/vb/service.vb#1)]  
  
 Службы не начинают сеансы с клиентами. В клиентских приложениях WCF существует прямая связь между сроком службы канала на основе сеанса и сроком службы самой сессии. Таким образом, клиенты создают новые сеансы путем создания новых каналов, основанных на сеансах, и прерывают существующие сеансы путем правильного закрытия этих каналов. Клиент начинает сеанс с конечной точкой службы путем вызова одной из следующих операций:  
  
- <xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType> для канала, возвращенного при вызове <xref:System.ServiceModel.ChannelFactory%601.CreateChannel%2A?displayProperty=nameWithType>.  
  
- <xref:System.ServiceModel.ClientBase%601.Open%2A?displayProperty=nameWithType>на объекте клиента WCF, генерируемом [инструментом ServiceModel Metadata Utility Tool (Svcutil.exe).](servicemodel-metadata-utility-tool-svcutil-exe.md)  
  
- Инагивание операции на любом типе объекта клиента WCF (по умолчанию все операции инацируются). При вызове первой операции клиентский объект WCF автоматически открывает канал и инициирует сеанс.  
  
 Обычно клиент завершает сеанс с конечной точкой службы путем вызова одной из следующих операций:  
  
- <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> для канала, возвращенного при вызове <xref:System.ServiceModel.ChannelFactory%601.CreateChannel%2A?displayProperty=nameWithType>.  
  
- <xref:System.ServiceModel.ClientBase%601.Close%2A?displayProperty=nameWithType>на объекте клиента WCF, генерируемом Svcutil.exe.  
  
- Прекращение операции на любом типе объекта клиента WCF (по умолчанию никакие операции не прекращаются; в контракте должно быть четко указано прекращение операции). При вызове первой операции клиентский объект WCF автоматически открывает канал и инициирует сеанс.  
  
 Примеры см. в разделе [How to: Create a Service That Requires Sessions](./feature-details/how-to-create-a-service-that-requires-sessions.md) , а также в примерах из разделов [Default Service Behavior](./samples/default-service-behavior.md) и [Instancing](./samples/instancing.md) .  
  
 Для получения дополнительной информации о [Accessing Services Using a WCF Client](./feature-details/accessing-services-using-a-client.md)клиентах и сессиях см.  
  
## <a name="sessions-interact-with-instancecontext-settings"></a>Сеансы взаимодействуют с параметрами InstanceContext  
 Перечисление <xref:System.ServiceModel.SessionMode> контракта взаимодействует со свойством <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> , управляющим связью между каналами и определенными объектами службы. Для получения дополнительной [информации, см.](./feature-details/sessions-instancing-and-concurrency.md)  
  
### <a name="sharing-instancecontext-objects"></a>Совместное использование объектов InstanceContext  
 Также можно задать для каждого вызова или канала, основанного на сеансе, с каким именно объектом <xref:System.ServiceModel.InstanceContext> он будет ассоциирован, самостоятельно назначив ассоциацию.
  
## <a name="sessions-and-streaming"></a>Сеансы и потоковая передача  
 Если у вас есть большой объем данных для передачи, режим потоковой передачи в WCF является возможной альтернативой поведению по умолчанию буферизации и обработки сообщений в памяти в полном объеме. При потоковой передаче вызовов с привязкой, основанной на сеансе, может возникнуть непредвиденное поведение. Все потоковые вызовы выполняются через один канал (канал датаграммы), который не поддерживает сеансы, даже если используемая привязка настроена так, чтобы она использовала сеансы. Если несколько клиентов выполняют потоковые вызовы одного объекта службы через привязку, основанную на сеансе, и задан "одиночный" режим параллелизма объекта службы и задан режим контекста его экземпляра `PerSession`, все вызовы должны проходить через канал датаграммы, а потому может обрабатываться не более одного вызова одновременно. Один или несколько клиентов могут затем тайм-аут. Вы можете обойти эту проблему, установив объект `InstanceContextMode` `PerCall` службы на несколько или на несколько.  
  
> [!NOTE]
> Свойство MaxConcurrentSessions в данном случае ни на что не влияет, поскольку имеется всего один сеанс.  
  
## <a name="see-also"></a>См. также раздел

- <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A>
- <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A>
