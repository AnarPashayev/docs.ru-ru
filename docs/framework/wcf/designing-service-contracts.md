---
title: Создание контрактов служб
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- service contracts [WCF]
ms.assetid: 8e89cbb9-ac84-4f0d-85ef-0eb6be0022fd
ms.openlocfilehash: 68ea866b736350b8a393d1f4788e4b08754e5ab4
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/08/2019
ms.locfileid: "59102743"
---
# <a name="designing-service-contracts"></a>Создание контрактов служб
Этот раздел описывает, что такое контракты служб, как они определяются, какие операции доступны (также описаны последствия обмена сообщениями, на которых они основаны), какие типы данных используются; кроме того, он содержит ответы на другие вопросы, которые помогут при разработке операций, удовлетворяющих требованиям вашего сценария.  
  
## <a name="creating-a-service-contract"></a>Создание контракта службы  
 Службы предоставляют несколько операций. В приложениях Windows Communication Foundation (WCF), определяют операции, создав метод и пометив его <xref:System.ServiceModel.OperationContractAttribute> атрибута. Затем, для создания контракта службы, необходимо сгруппировать операции либо объявив их в интерфейсе, отмеченном атрибутом <xref:System.ServiceModel.ServiceContractAttribute>, либо определив их в классе с таким же атрибутом. (Простой пример, см. в разделе [как: Определите контракт службы](../../../docs/framework/wcf/how-to-define-a-wcf-service-contract.md).)  
  
 Методы, которые не имеют <xref:System.ServiceModel.OperationContractAttribute> атрибут, не являются операциями служб и не предоставляется службами WCF.  
  
 Этот раздел рассказывает о принятии решений по следующим вопросам при создании контракта службы:  
  
-   использовать ли классы или интерфейсы;  
  
-   как задать типы данных, которыми нужно обмениваться;  
  
-   какие типы шаблонов обмена можно использовать;  
  
-   можно ли сделать явные требования безопасности частью контракта;  
  
-   каковы ограничения для входных и выходных данных операций.  
  
## <a name="classes-or-interfaces"></a>Классы или интерфейсы  
 Классы и интерфейсы представляют собой группировку функциональности, и, таким образом, как можно использовать для определения контракта службы WCF. Однако рекомендуется использовать интерфейсы, так как они напрямую моделируют контракты служб. Не имея реализации, интерфейсы всего лишь определяют группу методов с определенными сигнатурами. Реализуйте интерфейс контракта службы и реализации службы WCF.  
  
 Все преимущества управляемых интерфейсов относятся также к интерфейсам контрактов служб:  
  
-   интерфейсы контрактов служб могут расширять любое число других интерфейсов контрактов служб;  
  
-   отдельный класс может реализовывать любое число контрактов служб, реализуя интерфейсы этих контрактов служб;  
  
-   можно изменить реализацию контракта службы, изменив реализацию интерфейса и не изменяя сам контракт;  
  
-   можно создать несколько версий службы, реализуя старый и новый интерфейсы. Старые клиенты могут подключаться к исходной версии, а более новые клиенты - к более новой версии.  
  
> [!NOTE]
>  При наследовании от других интерфейсов контрактов служб нельзя переопределять свойства операций, например имя или пространство имен. Если попытаться сделать это, будет создана новая операция в текущем контракте службы.  
  
 Пример использования интерфейса для создания контракта службы, см. в разделе [как: Создание службы с помощью интерфейса контракта](../../../docs/framework/wcf/feature-details/how-to-create-a-service-with-a-contract-interface.md).  
  
 Однако можно использовать класс для определения контракта службы и одновременной реализации этого контракта. Преимущество создания службы путем применения атрибутов <xref:System.ServiceModel.ServiceContractAttribute> и <xref:System.ServiceModel.OperationContractAttribute> напрямую к классу и методам класса, соответственно, - это скорость и простота. Недостаток состоит в том, что управляемые классы не поддерживают множественное наследование, и в результате могут реализовывать только один контракт службы за раз. Кроме того, любое изменение сигнатуры класса или метода изменяет открытый контракт для этой службы, что может предотвратить использование службы неизмененными клиентами. Дополнительные сведения см. в разделе [Implementing Service Contracts](../../../docs/framework/wcf/implementing-service-contracts.md).  
  
 Пример использования класса для создания контракта службы и реализует его в то же время, см. в разделе [как: Создание службы с помощью класса контракта](../../../docs/framework/wcf/feature-details/how-to-create-a-wcf-contract-with-a-class.md).  
  
 К этому моменту у вас должно было сложиться представление о том, в чем заключается разница между определением контракта службы через интерфейс и через класс. Следующий шаг - определить, какие данные могут передаваться между службой и клиентами.  
  
## <a name="parameters-and-return-values"></a>Параметры и возвращаемые значения  
 Каждая операция имеет возвращаемое значение и параметр, даже в случае `void`. Однако, в отличие от локального метода, в котором можно передавать ссылки на объекты от одного объекта к другому, операции служб не передают ссылки на объекты. Вместо этого они передают копии объектов.  
  
 Это важно, потому что каждый тип, используемый для параметра или возвращаемого значения, должен быть сериализуем. Это значит, должно быть возможно преобразование объекта этого типа в поток байтов и обратно из потока байтов в объект.  
  
 Примитивные типы сериализуемы по умолчанию, как и многие типы в .NET Framework.  
  
> [!NOTE]
>  Значения имен параметров в сигнатуре операции являются частью контракта и чувствительны к регистру. Если требуется использовать одно имя параметра локально, но изменить имя опубликованных метаданных, см. раздел <xref:System.ServiceModel.MessageParameterAttribute?displayProperty=nameWithType>.  
  
#### <a name="data-contracts"></a>Контракты данных  
 Приложений, ориентированных на службы, например приложений Windows Communication Foundation (WCF) предназначены для взаимодействия с максимально возможным количеством клиентских приложений Майкрософт и других платформ. Для наиболее широких возможностей взаимодействия рекомендуется помечать типы атрибутами <xref:System.Runtime.Serialization.DataContractAttribute> и <xref:System.Runtime.Serialization.DataMemberAttribute> для создания контракта данных - части контракта службы, описывающей данные, которыми могут обмениваться операции службы.  
  
 Контракты данных представляют собой opt-контракты стилей: Нет тип или член данных сериализуется в том случае, если не применен явным образом атрибут контракта данных. Контракты данных не связаны с областью доступа управляемого кода: Закрытые данные-члены можно сериализовать и отправлены куда-либо для открытого доступа. (Простой пример контракта данных, см. в разделе [как: Создание базового контракта данных для класса или структуры](../../../docs/framework/wcf/feature-details/how-to-create-a-basic-data-contract-for-a-class-or-structure.md).) WCF обеспечивает определение базовых сообщений SOAP, которые позволяют функциональных возможностей операции, а также сериализацию типов данных в и из тела сообщения. Если типы данных сериализуемы, нет необходимости думать об инфраструктуре обмена базовыми сообщениями при создании операций.  
  
 Несмотря на то, что в обычном приложении WCF использует <xref:System.Runtime.Serialization.DataContractAttribute> и <xref:System.Runtime.Serialization.DataMemberAttribute> атрибутов для создания контрактов данных для операций, вы можете использовать другие механизмы сериализации. Стандартные механизмы <xref:System.Runtime.Serialization.ISerializable>, <xref:System.SerializableAttribute> и <xref:System.Xml.Serialization.IXmlSerializable> все обеспечивают сериализацию типов данных в базовые сообщения SOAP, которые переносят данные от одного приложения к другому. Можно применить дополнительные стратегии сериализации, если типы данных требуют специальной поддержки. Дополнительные сведения о вариантах механизмов сериализации типов данных в приложениях WCF, см. в разделе [Specifying Data Transfer in Service Contracts](../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).  
  
#### <a name="mapping-parameters-and-return-values-to-message-exchanges"></a>Сопоставление параметров и возвращаемых значений с обменом сообщениями  
 Операции службы поддерживаются при помощи базового обмена сообщениями SOAP, в которых передаются данные приложения в двух направлениях, а также данные, необходимые приложению для поддержки стандартной безопасности, транзакций и возможностей, связанных с сеансами. Так как это делается с помощью сигнатура операции службы диктует определенный базовый *обмена сообщениями* (сообщениями MEP), может поддерживать передачу данных и функции, любой операции, требующей. Можно задать три шаблона в модели программирования WCF: запрос/ответ, односторонний и дуплексный шаблон.  
  
##### <a name="requestreply"></a>Запрос-ответ  
 Шаблон запрос-ответ означает, что отправитель запроса (клиентское приложение) получает ответ, который соответствует запросу. Это шаблон обмена сообщениями по умолчанию, так как он поддерживает операцию, в которую передается один или больше параметров и из которой происходит возврат результирующего значения вызывавшей стороне. Например, следующий пример кода на языке C# показывает основную операцию службы, которая получает и возвращает строку.  
  
```csharp  
[OperationContractAttribute]  
string Hello(string greeting);  
```  
  
 Ниже приведен эквивалентный код Visual Basic.  
  
```vb  
<OperationContractAttribute()>  
Function Hello (ByVal greeting As String) As String  
```  
  
 Сигнатура этой операции диктует вид базового обмена сообщениями. Если нет никакой корреляции, WCF не удается определить, для какой операции предназначается возвращаемое значение.  
  
 Обратите внимание, что если не указать другой базовый шаблон сообщений, даже операции службы, которые возвращают `void` (`Nothing` в Visual Basic), обмен сообщениями запрос ответ. Результат для операции такой: если клиент не вызывает операцию асинхронно, клиент приостанавливает обработку до получения возвращаемого сообщения, даже несмотря на то, что в нормальном случае это сообщение пустое. Следующий пример кода на C# показывает операцию, которая не отвечает, пока клиент не получит пустое сообщение в ответ.  
  
```csharp  
[OperationContractAttribute]  
void Hello(string greeting);  
```  
  
 Ниже приведен эквивалентный код Visual Basic.  
  
```vb  
<OperationContractAttribute()>  
Sub Hello (ByVal greeting As String)  
```  
  
 Приведенный пример кода может понизить производительность и скорость ответа клиента, если выполнение операции требует длительного времени, но у операций типа запрос-ответ есть преимущества, даже если они возвращают `void`. Наиболее очевидное состоит в том, что сообщения о неисправностях SOAP могут возвращаться в сообщении ответа, что будет указывать на возникновение какой-либо связанной со службой ошибки либо при подключении, либо при обработке. Неисправности SOAP, заданные в контракте службы, передаются клиентскому приложению в виде объекта <xref:System.ServiceModel.FaultException%601>, где параметр типа - это тип, заданный в контракте службы. Это упрощает оповещение клиентов об ошибочных ситуациях в службах WCF. Дополнительные сведения об исключениях, сообщения об ошибках SOAP и обработке ошибок см. в разделе [задание и обработка сбоев в контрактах и службах](../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md). Пример запроса или ответа службы и клиента, см. в разделе [как: Создание контракта типа запрос ответ](../../../docs/framework/wcf/feature-details/how-to-create-a-request-reply-contract.md). Дополнительные сведения о работе с шаблоном запрос ответ, см. в разделе [службы типа запрос-ответ](../../../docs/framework/wcf/feature-details/request-reply-services.md).  
  
##### <a name="one-way"></a>Односторонний  
 Если клиент приложения службы WCF не должен ждать завершения операции и не обрабатывает неисправности SOAP, можно задать односторонний шаблон обмена сообщениями. Одностороннюю операцию, в котором клиент вызывает операцию и продолжает обработку после WCF записывает сообщение в сеть. Обычно это означает, что клиент продолжает работу почти без перерыва, если объем данных, передаваемых в исходящем сообщение не очень велик, и если не возникает ошибка при передаче данных. Этот шаблон обмена сообщениями поддерживает событийное взаимодействие между клиентом и приложением службы.  
  
 Обмен сообщениями, при котором одно сообщение отправляется и ни одного не принимается не поддерживает операции службы, для которых задано возвращаемое значение, отличное от `void`; в таком случае возникает исключение <xref:System.InvalidOperationException>.  
  
 Отсутствие обратного сообщения также означает, что не может быть возвращено сообщение о неисправностях SOAP, указывающее на ошибки при обработке или подключении. (Передача сведений об ошибках подключения для односторонних операций требует дуплексного шаблона обмена сообщениями.)  
  
 Чтобы задать односторонний обмен сообщениями для операции, возвращающей `void`, присвойте свойству <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> значение `true`, как в следующем примере кода C#.  
  
```csharp  
[OperationContractAttribute(IsOneWay=true)]  
void Hello(string greeting);  
```  
  
 Ниже приведен эквивалентный код Visual Basic.  
  
```vb  
<OperationContractAttribute(IsOneWay := True)>  
Sub Hello (ByVal greeting As String)  
```  
  
 Метод тот же, что и в предшествующем примере типа запрос-ответ, но значение <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> свойства `true` означает, что несмотря на то, что метод тот же, операция службы не посылает ответное сообщение и клиенты продолжают работу немедленно после передачи исходящего сообщения на уровень канала. Пример см. в статье [Практическое руководство. Создание одностороннего контракта](../../../docs/framework/wcf/feature-details/how-to-create-a-one-way-contract.md). Дополнительные сведения о одностороннем шаблоне см. в разделе [служб односторонняя](../../../docs/framework/wcf/feature-details/one-way-services.md).  
  
##### <a name="duplex"></a>Дуплекс  
 Дуплексный шаблон характеризуется способностью и службы, и клиента отправлять сообщения друг другу, независимо от того, используется ли односторонний обмен сообщениями или запрос-ответ. Такая форма двустороннего общения полезна для служб, которым требуется напрямую обращаться к клиенту, или для асинхронного взаимодействия обеих сторон обмена сообщениями, в том числе для событийного поведения.  
  
 Дуплексный шаблон несколько более сложен, чем односторонний шаблон и шаблон запрос-ответ, так как имеет дополнительный механизм для взаимодействия с клиентом.  
  
 Для создания дуплексного контракта необходимо также создать контракт обратного вызова и присвоить тип этого контракта обратного вызова свойству <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> атрибута <xref:System.ServiceModel.ServiceContractAttribute> контракта службы.  
  
 Для реализации дуплексного шаблона необходимо создать второй интерфейс, содержащий объявления методов, вызываемых на клиенте.  
  
 Пример создания службы и клиента, который обращается к этой службе, см. в разделе [как: Создание дуплексного контракта](../../../docs/framework/wcf/feature-details/how-to-create-a-duplex-contract.md) и [как: Доступ к службам с дуплексным контрактом](../../../docs/framework/wcf/feature-details/how-to-access-services-with-a-duplex-contract.md). Работающий пример см. в разделе [дуплексного](../../../docs/framework/wcf/samples/duplex.md). Дополнительные сведения об использовании дуплексных контрактов см. в разделе [дуплексные службы](../../../docs/framework/wcf/feature-details/duplex-services.md).  
  
> [!CAUTION]
>  Когда служба получает дуплексное сообщение, она проверяет элемент `ReplyTo` входящего сообщения, чтобы определить, куда отправлять ответ. Если сообщение принимается по небезопасному каналу, ненадежный клиент может послать вредоносное сообщение с указанием компьютера для атаки в элементе `ReplyTo`, что приведет к отказу в обслуживании (DOS) этого компьютера.  
  
##### <a name="out-and-ref-parameters"></a>Параметры Out и Ref  
 В большинстве случаев можно использовать `in` параметров (`ByVal` в Visual Basic) и `out` и `ref` параметров (`ByRef` в Visual Basic). Так как параметры `out` и `ref` оба указывают на то, что операция возвращает данные, сигнатура операции, такая, как показана далее, задает необходимость операции запрос-ответ, несмотря на то что сигнатура операции возвращает `void`.  
  
```csharp  
[ServiceContractAttribute]  
public interface IMyContract  
{  
  [OperationContractAttribute]  
  public void PopulateData(ref CustomDataType data);  
}  
```  
  
 Ниже приведен эквивалентный код Visual Basic.  
  
```vb  
<ServiceContractAttribute()> _  
Public Interface IMyContract  
  <OperationContractAttribute()> _  
  Public Sub PopulateData(ByRef data As CustomDataType)  
End Interface  
```  
  
 Исключение составляют только те случаи, когда сигнатура имеет определенную структуру. Например, можно использовать привязку <xref:System.ServiceModel.NetMsmqBinding> для взаимодействия с клиентами, только если метод, использованный для объявления операции, возвращает `void`; может не быть выходного значения, является ли оно возвращаемым значением, параметром `ref` или `out`.  
  
 Помимо этого, использование параметров `out` или `ref` требует, чтобы у операции было базовое ответное сообщение для передачи обратно измененного объекта. Если операция является односторонней, во время выполнения создается исключение <xref:System.InvalidOperationException>.  
  
### <a name="specify-message-protection-level-on-the-contract"></a>Определение уровня защиты сообщений для контракта  
 При создании контракта необходимо также определить уровень защиты сообщений служб, реализующих этот контракт. Это необходимо, только если к привязке применена безопасность сообщений в конечной точке контракта. Если для привязки безопасность отключена (то есть, если привязка, предоставляемая системой, присваивает объекту <xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType> значение <xref:System.ServiceModel.SecurityMode.None?displayProperty=nameWithType>), то не нужно определять уровень безопасности сообщений для контракта. В большинстве случаев привязки, предоставляемые системой, с безопасностью на уровне сообщений предоставляют достаточный уровень защиты и нет необходимости рассматривать уровень защиты для каждой операции или для каждого сообщения.  
  
 Уровень защиты - это значение, которое определяет для сообщений (или частей сообщений), поддерживающих службу, подписываются ли они, подписываются и шифруются или отправляются без подписи и шифровки. Уровень защиты можно установить в различных областях: На уровне службы, для конкретной операции, для сообщения в рамках этой операции или для части сообщения. Значения, заданные для более широкой области, становятся значениями по умолчанию для более узких областей, если не переопределить их явным образом. Если конфигурация привязки не может обеспечить минимальный необходимый уровень защиты для контракта, создается исключение. Если для контракта явно не задано значений уровня защиты, и если привязка имеет безопасность сообщений, уровнем защиты всех сообщений управляет конфигурация привязки. Это поведение установлено по умолчанию.  
  
> [!IMPORTANT]
>  Решение явно задать для различных областей контракта уровень защиты меньше максимального <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> обычно является компромиссом между степенью защиты и улучшением производительности. В таких случаях решения должны опираться на вид операций и ценность передаваемых данных. Дополнительные сведения см. в разделе [Защита служб](../../../docs/framework/wcf/securing-services.md).  
  
 Например, в следующем примере кода не задается ни свойство<xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A>, ни свойство <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> контракта.  
  
```csharp  
[ServiceContract]  
public interface ISampleService  
{  
  [OperationContractAttribute]  
  public string GetString();  
  
  [OperationContractAttribute]  
  public int GetInt();    
}  
```  
  
 Ниже приведен эквивалентный код Visual Basic.  
  
```vb  
<ServiceContractAttribute()> _  
Public Interface ISampleService  
  
  <OperationContractAttribute()> _  
  Public Function GetString()As String  
  
  <OperationContractAttribute()> _  
  Public Function GetData() As Integer  
  
End Interface  
```  
  
 При взаимодействии с реализацией `ISampleService` в конечной точке с привязкой <xref:System.ServiceModel.WSHttpBinding> по умолчанию (<xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType> по умолчанию, то есть значение <xref:System.ServiceModel.SecurityMode.Message>), все сообщения зашифровываются и подписываются, так как это является уровнем защиты по умолчанию. Однако при использовании службы `ISampleService` с привязкой <xref:System.ServiceModel.BasicHttpBinding> по умолчанию (<xref:System.ServiceModel.SecurityMode> по умолчанию, то есть значение <xref:System.ServiceModel.SecurityMode.None>), все сообщения отправляются в текстовом виде, так как эта привязка не имеет безопасности и, следовательно, уровень защиты игнорируется (то есть сообщения не шифруются и не подписываются). Если изменить значение свойства <xref:System.ServiceModel.SecurityMode> на <xref:System.ServiceModel.SecurityMode.Message>, то сообщения будут зашифровываться и подписываться, так как теперь таков будет уровень защиты по умолчанию для привязки.  
  
 Если требуется явным образом задать или настроить требования по безопасности для контракта, задайте для свойства <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> (или для любого из свойств `ProtectionLevel` более узкой области) уровень, требуемый для контракта службы. В данном случае явная настройка требует, чтобы привязка поддерживала эту настройку по крайней мере для указанной области. Например, в следующем примере кода явно задается одно значение <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> для операции `GetGuid`.  
  
```csharp  
[ServiceContract]  
public interface IExplicitProtectionLevelSampleService  
{  
  [OperationContractAttribute]  
  public string GetString();  
  
  [OperationContractAttribute(ProtectionLevel=ProtectionLevel.None)]  
  public int GetInt();    
  [OperationContractAttribute(ProtectionLevel=ProtectionLevel.EncryptAndSign)]  
  public int GetGuid();    
}  
```  
  
 Ниже приведен эквивалентный код Visual Basic.  
  
```vb  
<ServiceContract()> _   
Public Interface IExplicitProtectionLevelSampleService   
    <OperationContract()> _   
    Public Function GetString() As String   
    End Function   
  
    <OperationContract(ProtectionLevel := ProtectionLevel.None)> _   
    Public Function GetInt() As Integer   
    End Function   
  
    <OperationContractAttribute(ProtectionLevel := ProtectionLevel.EncryptAndSign)> _   
    Public Function GetGuid() As Integer   
    End Function   
  
End Interface  
```  
  
 Служба, реализующая этот контракт `IExplicitProtectionLevelSampleService` и имеющая конечную точку, где используется привязка <xref:System.ServiceModel.WSHttpBinding> по умолчанию (<xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType> по умолчанию, то есть значение <xref:System.ServiceModel.SecurityMode.Message>) ведет себя следующим образом:  
  
-   Для операции `GetString` сообщения шифруются и подписываются.  
  
-   Для операции `GetInt` сообщения не шифруются и не подписываются, то есть отправляются как простой текст.  
  
-   `GetGuid` операции <xref:System.Guid?displayProperty=nameWithType> возвращается в зашифрованном подписанном сообщении.  
  
 Дополнительные сведения об уровнях защиты и их использовании см. в разделе [уровень защиты понимание](../../../docs/framework/wcf/understanding-protection-level.md). Дополнительные сведения о безопасности см. в разделе [Защита служб](../../../docs/framework/wcf/securing-services.md).  
  
##### <a name="other-operation-signature-requirements"></a>Другие требования к сигнатуре операции  
 Некоторые возможности приложения требуют определенного вида сигнатуры операции. Например, привязка <xref:System.ServiceModel.NetMsmqBinding> поддерживает устойчивые службы и клиенты, позволяющие перезапуск приложения при установленном подключении, при этом приложение продолжит работу с того места, где остановилось, и ни одно сообщение не будет потеряно. (Дополнительные сведения см. в разделе [очереди в WCF](../../../docs/framework/wcf/feature-details/queues-in-wcf.md).) Однако устойчивые операции должны принимать только один параметр `in` и не должны иметь возвращаемого значения.  
  
 Другой пример - использование типов <xref:System.IO.Stream> в операциях. Так как параметр <xref:System.IO.Stream> включает в себя тело сообщения целиком, если входные или выходные данные (то есть параметр `ref`, параметр `out` или возвращаемое значение) принадлежат типу <xref:System.IO.Stream>, это должны быть единственные входные и выходные данные, заданные для операции. Кроме того, параметр или тип возвращаемого значения должны являться объектами <xref:System.IO.Stream>, <xref:System.ServiceModel.Channels.Message?displayProperty=nameWithType> или <xref:System.Xml.Serialization.IXmlSerializable?displayProperty=nameWithType>. Дополнительные сведения о потоках см. в разделе [большие наборы данных и потоковая передача](../../../docs/framework/wcf/feature-details/large-data-and-streaming.md).  
  
##### <a name="names-namespaces-and-obfuscation"></a>Имена, пространства имен и запутывание  
 Имена и пространства имен типов .NET в определениях контрактов и операций важны при преобразовании контрактов в WSDL и при создании и отправке сообщений контрактов. Поэтому рекомендуется явно задавать имена и пространства имен контракта службы с помощью свойств `Name` и `Namespace` всех поддерживающих атрибутов контракта, например <xref:System.ServiceModel.ServiceContractAttribute>, <xref:System.ServiceModel.OperationContractAttribute>, <xref:System.Runtime.Serialization.DataContractAttribute>, <xref:System.Runtime.Serialization.DataMemberAttribute> и других атрибутов контракта.  
  
 Одним из следствий этого является то, что если имена и пространства имен не заданы явно, применение обфускации IL для сборки изменяет имена типов и пространства имен контракта, что приводит к измененному коду WSDL и обмену сообщениями, который обычно завершается ошибкой. Если вы не задаете явно имена и пространства имен контракта, но планируете использовать обфускацию, используйте атрибуты <xref:System.Reflection.ObfuscationAttribute> и <xref:System.Reflection.ObfuscateAssemblyAttribute>, чтобы предотвратить изменение имен и пространств имен контракта.  
  
## <a name="see-also"></a>См. также

- [Практическое руководство. Создание контракта типа "запрос — ответ"](../../../docs/framework/wcf/feature-details/how-to-create-a-request-reply-contract.md)
- [Практическое руководство. Создание одностороннего контракта](../../../docs/framework/wcf/feature-details/how-to-create-a-one-way-contract.md)
- [Практическое руководство. Создание двухстороннего контракта](../../../docs/framework/wcf/feature-details/how-to-create-a-duplex-contract.md)
- [Задание передачи данных в контрактах служб](../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)
- [Задание и обработка сбоев в контрактах и службах](../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md)
- [Использование сеансов](../../../docs/framework/wcf/using-sessions.md)
- [Синхронные и асинхронные операции](../../../docs/framework/wcf/synchronous-and-asynchronous-operations.md)
- [Надежные службы](../../../docs/framework/wcf/reliable-services.md)
- [Службы и транзакции](../../../docs/framework/wcf/services-and-transactions.md)
