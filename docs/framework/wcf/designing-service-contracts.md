---
title: Создание контрактов служб
description: Сведения о контрактах служб, в том числе о создании, доступных операциях и типах данных, а также о других аспектах контрактов служб в программировании WCF.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- service contracts [WCF]
ms.assetid: 8e89cbb9-ac84-4f0d-85ef-0eb6be0022fd
ms.openlocfilehash: 11d2019023c7389d27607c93b920946837b5c365
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/26/2020
ms.locfileid: "96294835"
---
# <a name="designing-service-contracts"></a><span data-ttu-id="e604e-103">Создание контрактов служб</span><span class="sxs-lookup"><span data-stu-id="e604e-103">Designing Service Contracts</span></span>

<span data-ttu-id="e604e-104">Этот раздел описывает, что такое контракты служб, как они определяются, какие операции доступны (также описаны последствия обмена сообщениями, на которых они основаны), какие типы данных используются; кроме того, он содержит ответы на другие вопросы, которые помогут при разработке операций, удовлетворяющих требованиям вашего сценария.</span><span class="sxs-lookup"><span data-stu-id="e604e-104">This topic describes what service contracts are, how they are defined, what operations are available (and the implications for the underlying message exchanges), what data types are used, and other issues that help you design operations that satisfy the requirements of your scenario.</span></span>  
  
## <a name="creating-a-service-contract"></a><span data-ttu-id="e604e-105">Создание контракта службы</span><span class="sxs-lookup"><span data-stu-id="e604e-105">Creating a Service Contract</span></span>  

 <span data-ttu-id="e604e-106">Службы предоставляют несколько операций.</span><span class="sxs-lookup"><span data-stu-id="e604e-106">Services expose a number of operations.</span></span> <span data-ttu-id="e604e-107">В приложениях Windows Communication Foundation (WCF) определите операции, создав метод и пометив его <xref:System.ServiceModel.OperationContractAttribute> атрибутом.</span><span class="sxs-lookup"><span data-stu-id="e604e-107">In Windows Communication Foundation (WCF) applications, define the operations by creating a method and marking it with the <xref:System.ServiceModel.OperationContractAttribute> attribute.</span></span> <span data-ttu-id="e604e-108">Затем, для создания контракта службы, необходимо сгруппировать операции либо объявив их в интерфейсе, отмеченном атрибутом <xref:System.ServiceModel.ServiceContractAttribute>, либо определив их в классе с таким же атрибутом.</span><span class="sxs-lookup"><span data-stu-id="e604e-108">Then, to create a service contract, group together your operations, either by declaring them within an interface marked with the <xref:System.ServiceModel.ServiceContractAttribute> attribute, or by defining them in a class marked with the same attribute.</span></span> <span data-ttu-id="e604e-109">(Базовый пример см. в разделе [как определить контракт службы](how-to-define-a-wcf-service-contract.md).)</span><span class="sxs-lookup"><span data-stu-id="e604e-109">(For a basic example, see [How to: Define a Service Contract](how-to-define-a-wcf-service-contract.md).)</span></span>  
  
 <span data-ttu-id="e604e-110">Все методы, не имеющие атрибута, <xref:System.ServiceModel.OperationContractAttribute> не являются операциями службы и не предоставляются СЛУЖБАМИ WCF.</span><span class="sxs-lookup"><span data-stu-id="e604e-110">Any methods that do not have a <xref:System.ServiceModel.OperationContractAttribute> attribute are not service operations and are not exposed by WCF services.</span></span>  
  
 <span data-ttu-id="e604e-111">Этот раздел рассказывает о принятии решений по следующим вопросам при создании контракта службы:</span><span class="sxs-lookup"><span data-stu-id="e604e-111">This topic describes the following decision points when designing a service contract:</span></span>  
  
- <span data-ttu-id="e604e-112">использовать ли классы или интерфейсы;</span><span class="sxs-lookup"><span data-stu-id="e604e-112">Whether to use classes or interfaces.</span></span>  
  
- <span data-ttu-id="e604e-113">как задать типы данных, которыми нужно обмениваться;</span><span class="sxs-lookup"><span data-stu-id="e604e-113">How to specify the data types you want to exchange.</span></span>  
  
- <span data-ttu-id="e604e-114">какие типы шаблонов обмена можно использовать;</span><span class="sxs-lookup"><span data-stu-id="e604e-114">The types of exchange patterns you can use.</span></span>  
  
- <span data-ttu-id="e604e-115">можно ли сделать явные требования безопасности частью контракта;</span><span class="sxs-lookup"><span data-stu-id="e604e-115">Whether you can make explicit security requirements part of the contract.</span></span>  
  
- <span data-ttu-id="e604e-116">каковы ограничения для входных и выходных данных операций.</span><span class="sxs-lookup"><span data-stu-id="e604e-116">The restrictions for operation inputs and outputs.</span></span>  
  
## <a name="classes-or-interfaces"></a><span data-ttu-id="e604e-117">Классы или интерфейсы</span><span class="sxs-lookup"><span data-stu-id="e604e-117">Classes or Interfaces</span></span>  

 <span data-ttu-id="e604e-118">Классы и интерфейсы представляют собой группирование функциональных возможностей и, следовательно, могут использоваться для определения контракта службы WCF.</span><span class="sxs-lookup"><span data-stu-id="e604e-118">Both classes and interfaces represent a grouping of functionality and, therefore, both can be used to define a WCF service contract.</span></span> <span data-ttu-id="e604e-119">Однако рекомендуется использовать интерфейсы, так как они напрямую моделируют контракты служб.</span><span class="sxs-lookup"><span data-stu-id="e604e-119">However, it is recommended that you use interfaces because they directly model service contracts.</span></span> <span data-ttu-id="e604e-120">Не имея реализации, интерфейсы всего лишь определяют группу методов с определенными сигнатурами.</span><span class="sxs-lookup"><span data-stu-id="e604e-120">Without an implementation, interfaces do no more than define a grouping of methods with certain signatures.</span></span> <span data-ttu-id="e604e-121">Реализуйте интерфейс контракта службы, и вы реализовали службу WCF.</span><span class="sxs-lookup"><span data-stu-id="e604e-121">Implement a service contract interface and you have implemented a WCF service.</span></span>  
  
 <span data-ttu-id="e604e-122">Все преимущества управляемых интерфейсов относятся также к интерфейсам контрактов служб:</span><span class="sxs-lookup"><span data-stu-id="e604e-122">All the benefits of managed interfaces apply to service contract interfaces:</span></span>  
  
- <span data-ttu-id="e604e-123">интерфейсы контрактов служб могут расширять любое число других интерфейсов контрактов служб;</span><span class="sxs-lookup"><span data-stu-id="e604e-123">Service contract interfaces can extend any number of other service contract interfaces.</span></span>  
  
- <span data-ttu-id="e604e-124">отдельный класс может реализовывать любое число контрактов служб, реализуя интерфейсы этих контрактов служб;</span><span class="sxs-lookup"><span data-stu-id="e604e-124">A single class can implement any number of service contracts by implementing those service contract interfaces.</span></span>  
  
- <span data-ttu-id="e604e-125">можно изменить реализацию контракта службы, изменив реализацию интерфейса и не изменяя сам контракт;</span><span class="sxs-lookup"><span data-stu-id="e604e-125">You can modify the implementation of a service contract by changing the interface implementation, while the service contract remains the same.</span></span>  
  
- <span data-ttu-id="e604e-126">можно создать несколько версий службы, реализуя старый и новый интерфейсы.</span><span class="sxs-lookup"><span data-stu-id="e604e-126">You can version your service by implementing the old interface and the new one.</span></span> <span data-ttu-id="e604e-127">Старые клиенты могут подключаться к исходной версии, а более новые клиенты - к более новой версии.</span><span class="sxs-lookup"><span data-stu-id="e604e-127">Old clients connect to the original version, while newer clients can connect to the newer version.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e604e-128">При наследовании от других интерфейсов контрактов служб нельзя переопределять свойства операций, например имя или пространство имен.</span><span class="sxs-lookup"><span data-stu-id="e604e-128">When inheriting from other service contract interfaces, you cannot override operation properties, such as the name or namespace.</span></span> <span data-ttu-id="e604e-129">Если попытаться сделать это, будет создана новая операция в текущем контракте службы.</span><span class="sxs-lookup"><span data-stu-id="e604e-129">If you attempt to do so, you create a new operation in the current service contract.</span></span>  
  
 <span data-ttu-id="e604e-130">Пример использования интерфейса для создания контракта службы см. [в разделе инструкции. Создание службы с интерфейсом контракта](./feature-details/how-to-create-a-service-with-a-contract-interface.md).</span><span class="sxs-lookup"><span data-stu-id="e604e-130">For an example of using an interface to create a service contract, see [How to: Create a Service with a Contract Interface](./feature-details/how-to-create-a-service-with-a-contract-interface.md).</span></span>  
  
 <span data-ttu-id="e604e-131">Однако можно использовать класс для определения контракта службы и одновременной реализации этого контракта.</span><span class="sxs-lookup"><span data-stu-id="e604e-131">You can, however, use a class to define a service contract and implement that contract at the same time.</span></span> <span data-ttu-id="e604e-132">Преимущество создания службы путем применения атрибутов <xref:System.ServiceModel.ServiceContractAttribute> и <xref:System.ServiceModel.OperationContractAttribute> напрямую к классу и методам класса, соответственно, - это скорость и простота.</span><span class="sxs-lookup"><span data-stu-id="e604e-132">The advantage of creating your services by applying <xref:System.ServiceModel.ServiceContractAttribute> and <xref:System.ServiceModel.OperationContractAttribute> directly to the class and the methods on the class, respectively, is speed and simplicity.</span></span> <span data-ttu-id="e604e-133">Недостаток состоит в том, что управляемые классы не поддерживают множественное наследование, и в результате могут реализовывать только один контракт службы за раз.</span><span class="sxs-lookup"><span data-stu-id="e604e-133">The disadvantages are that managed classes do not support multiple inheritance, and as a result they can only implement one service contract at a time.</span></span> <span data-ttu-id="e604e-134">Кроме того, любое изменение сигнатуры класса или метода изменяет открытый контракт для этой службы, что может предотвратить использование службы неизмененными клиентами.</span><span class="sxs-lookup"><span data-stu-id="e604e-134">In addition, any modification to the class or method signatures modifies the public contract for that service, which can prevent unmodified clients from using your service.</span></span> <span data-ttu-id="e604e-135">Дополнительные сведения см. в разделе [реализация контрактов служб](implementing-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="e604e-135">For more information, see [Implementing Service Contracts](implementing-service-contracts.md).</span></span>  
  
 <span data-ttu-id="e604e-136">Пример использования класса для создания контракта службы и его реализации в то же время см. в разделе [как создать службу с помощью класса контракта](./feature-details/how-to-create-a-wcf-contract-with-a-class.md).</span><span class="sxs-lookup"><span data-stu-id="e604e-136">For an example that uses a class to create a service contract and implements it at the same time, see [How to: Create a Service with a Contract Class](./feature-details/how-to-create-a-wcf-contract-with-a-class.md).</span></span>  
  
 <span data-ttu-id="e604e-137">К этому моменту у вас должно было сложиться представление о том, в чем заключается разница между определением контракта службы через интерфейс и через класс.</span><span class="sxs-lookup"><span data-stu-id="e604e-137">At this point, you should understand the difference between defining your service contract by using an interface and by using a class.</span></span> <span data-ttu-id="e604e-138">Следующий шаг - определить, какие данные могут передаваться между службой и клиентами.</span><span class="sxs-lookup"><span data-stu-id="e604e-138">The next step is deciding what data can be passed back and forth between a service and its clients.</span></span>  
  
## <a name="parameters-and-return-values"></a><span data-ttu-id="e604e-139">Параметры и возвращаемые значения</span><span class="sxs-lookup"><span data-stu-id="e604e-139">Parameters and Return Values</span></span>  

 <span data-ttu-id="e604e-140">Каждая операция имеет возвращаемое значение и параметр, даже в случае `void`.</span><span class="sxs-lookup"><span data-stu-id="e604e-140">Each operation has a return value and a parameter, even if these are `void`.</span></span> <span data-ttu-id="e604e-141">Однако, в отличие от локального метода, в котором можно передавать ссылки на объекты от одного объекта к другому, операции служб не передают ссылки на объекты.</span><span class="sxs-lookup"><span data-stu-id="e604e-141">However, unlike a local method, in which you can pass references to objects from one object to another, service operations do not pass references to objects.</span></span> <span data-ttu-id="e604e-142">Вместо этого они передают копии объектов.</span><span class="sxs-lookup"><span data-stu-id="e604e-142">Instead, they pass copies of the objects.</span></span>  
  
 <span data-ttu-id="e604e-143">Это важно, потому что каждый тип, используемый для параметра или возвращаемого значения, должен быть сериализуем. Это значит, должно быть возможно преобразование объекта этого типа в поток байтов и обратно из потока байтов в объект.</span><span class="sxs-lookup"><span data-stu-id="e604e-143">This is significant because each type used in a parameter or return value must be serializable; that is, it must be possible to convert an object of that type into a stream of bytes and from a stream of bytes into an object.</span></span>  
  
 <span data-ttu-id="e604e-144">Примитивные типы сериализуемы по умолчанию, как и многие типы в .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="e604e-144">Primitive types are serializable by default, as are many types in the .NET Framework.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e604e-145">Значения имен параметров в сигнатуре операции являются частью контракта и чувствительны к регистру.</span><span class="sxs-lookup"><span data-stu-id="e604e-145">The value of the parameter names in the operation signature are part of the contract and are case sensitive.</span></span> <span data-ttu-id="e604e-146">Если требуется использовать одно имя параметра локально, но изменить имя опубликованных метаданных, см. раздел <xref:System.ServiceModel.MessageParameterAttribute?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e604e-146">If you want to use the same parameter name locally but modify the name in the published metadata, see the <xref:System.ServiceModel.MessageParameterAttribute?displayProperty=nameWithType>.</span></span>  
  
#### <a name="data-contracts"></a><span data-ttu-id="e604e-147">Контракты данных</span><span class="sxs-lookup"><span data-stu-id="e604e-147">Data Contracts</span></span>  

 <span data-ttu-id="e604e-148">Приложения, ориентированные на службы, такие как Windows Communication Foundation (WCF), предназначены для взаимодействия с самым широким количеством клиентских приложений на платформах Майкрософт и сторонних производителей.</span><span class="sxs-lookup"><span data-stu-id="e604e-148">Service-oriented applications like Windows Communication Foundation (WCF) applications are designed to interoperate with the widest possible number of client applications on both Microsoft and non-Microsoft platforms.</span></span> <span data-ttu-id="e604e-149">Для наиболее широких возможностей взаимодействия рекомендуется помечать типы атрибутами <xref:System.Runtime.Serialization.DataContractAttribute> и <xref:System.Runtime.Serialization.DataMemberAttribute> для создания контракта данных - части контракта службы, описывающей данные, которыми могут обмениваться операции службы.</span><span class="sxs-lookup"><span data-stu-id="e604e-149">For the widest possible interoperability, it is recommended that you mark your types with the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute> attributes to create a data contract, which is the portion of the service contract that describes the data that your service operations exchange.</span></span>  
  
 <span data-ttu-id="e604e-150">Контракты данных - включаемые по требованию контракты стилей: тип или элемент данных не сериализуются, если не применен явным образом атрибут контракта данных.</span><span class="sxs-lookup"><span data-stu-id="e604e-150">Data contracts are opt-in style contracts: No type or data member is serialized unless you explicitly apply the data contract attribute.</span></span> <span data-ttu-id="e604e-151">Контракты данных не связаны с областью доступа управляемого кода: закрытые элементы данных могут быть сериализованы и отправлены куда-либо для открытого доступа.</span><span class="sxs-lookup"><span data-stu-id="e604e-151">Data contracts are unrelated to the access scope of the managed code: Private data members can be serialized and sent elsewhere to be accessed publicly.</span></span> <span data-ttu-id="e604e-152">(Простой пример контракта данных см. [в разделе как создать базовый контракт данных для класса или структуры](./feature-details/how-to-create-a-basic-data-contract-for-a-class-or-structure.md).) WCF обрабатывает определение базовых сообщений SOAP, которые обеспечивают функциональность операции, а также сериализацию типов данных в текст сообщений и из него.</span><span class="sxs-lookup"><span data-stu-id="e604e-152">(For a basic example of a data contract, see [How to: Create a Basic Data Contract for a Class or Structure](./feature-details/how-to-create-a-basic-data-contract-for-a-class-or-structure.md).) WCF handles the definition of the underlying SOAP messages that enable the operation's functionality as well as the serialization of your data types into and out of the body of the messages.</span></span> <span data-ttu-id="e604e-153">Если типы данных сериализуемы, нет необходимости думать об инфраструктуре обмена базовыми сообщениями при создании операций.</span><span class="sxs-lookup"><span data-stu-id="e604e-153">As long as your data types are serializable, you do not need to think about the underlying message exchange infrastructure when designing your operations.</span></span>  
  
 <span data-ttu-id="e604e-154">Хотя типичное приложение WCF использует <xref:System.Runtime.Serialization.DataContractAttribute> атрибуты и <xref:System.Runtime.Serialization.DataMemberAttribute> для создания контрактов данных для операций, можно использовать другие механизмы сериализации.</span><span class="sxs-lookup"><span data-stu-id="e604e-154">Although the typical WCF application uses the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute> attributes to create data contracts for operations, you can use other serialization mechanisms.</span></span> <span data-ttu-id="e604e-155">Стандартные механизмы <xref:System.Runtime.Serialization.ISerializable>, <xref:System.SerializableAttribute> и <xref:System.Xml.Serialization.IXmlSerializable> все обеспечивают сериализацию типов данных в базовые сообщения SOAP, которые переносят данные от одного приложения к другому.</span><span class="sxs-lookup"><span data-stu-id="e604e-155">The standard <xref:System.Runtime.Serialization.ISerializable>, <xref:System.SerializableAttribute> and <xref:System.Xml.Serialization.IXmlSerializable> mechanisms all work to handle the serialization of your data types into the underlying SOAP messages that carry them from one application to another.</span></span> <span data-ttu-id="e604e-156">Можно применить дополнительные стратегии сериализации, если типы данных требуют специальной поддержки.</span><span class="sxs-lookup"><span data-stu-id="e604e-156">You can employ more serialization strategies if your data types require special support.</span></span> <span data-ttu-id="e604e-157">Дополнительные сведения о выборе сериализации типов данных в приложениях WCF см. [в разделе указание передача данных в контрактах служб](./feature-details/specifying-data-transfer-in-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="e604e-157">For more information about the choices for serialization of data types in WCF applications, see [Specifying Data Transfer in Service Contracts](./feature-details/specifying-data-transfer-in-service-contracts.md).</span></span>  
  
#### <a name="mapping-parameters-and-return-values-to-message-exchanges"></a><span data-ttu-id="e604e-158">Сопоставление параметров и возвращаемых значений с обменом сообщениями</span><span class="sxs-lookup"><span data-stu-id="e604e-158">Mapping Parameters and Return Values to Message Exchanges</span></span>  

 <span data-ttu-id="e604e-159">Операции службы поддерживаются при помощи базового обмена сообщениями SOAP, в которых передаются данные приложения в двух направлениях, а также данные, необходимые приложению для поддержки стандартной безопасности, транзакций и возможностей, связанных с сеансами.</span><span class="sxs-lookup"><span data-stu-id="e604e-159">Service operations are supported by an underlying exchange of SOAP messages that transfer application data back and forth, in addition to the data required by the application to support certain standard security, transaction, and session-related features.</span></span> <span data-ttu-id="e604e-160">Так как это так, сигнатура операции службы определяет определенный *шаблон обмена сообщениями* (MEP), который поддерживает перенос данных и функции, необходимые для операции.</span><span class="sxs-lookup"><span data-stu-id="e604e-160">Because this is the case, the signature of a service operation dictates a certain underlying *message exchange pattern* (MEP) that can support the data transfer and the features an operation requires.</span></span> <span data-ttu-id="e604e-161">В модели программирования WCF можно указать три шаблона: запрос-ответ, односторонний и дуплексные шаблоны сообщений.</span><span class="sxs-lookup"><span data-stu-id="e604e-161">You can specify three patterns in the WCF programming model: request/reply, one-way, and duplex message patterns.</span></span>  
  
##### <a name="requestreply"></a><span data-ttu-id="e604e-162">Запрос-ответ</span><span class="sxs-lookup"><span data-stu-id="e604e-162">Request/Reply</span></span>  

 <span data-ttu-id="e604e-163">Шаблон запрос-ответ означает, что отправитель запроса (клиентское приложение) получает ответ, который соответствует запросу.</span><span class="sxs-lookup"><span data-stu-id="e604e-163">A request/reply pattern is one in which a request sender (a client application) receives a reply with which the request is correlated.</span></span> <span data-ttu-id="e604e-164">Это шаблон обмена сообщениями по умолчанию, так как он поддерживает операцию, в которую передается один или больше параметров и из которой происходит возврат результирующего значения вызывавшей стороне.</span><span class="sxs-lookup"><span data-stu-id="e604e-164">This is the default MEP because it supports an operation in which one or more parameters are passed to the operation and a return value is passed back to the caller.</span></span> <span data-ttu-id="e604e-165">Например, следующий пример кода на языке C# показывает основную операцию службы, которая получает и возвращает строку.</span><span class="sxs-lookup"><span data-stu-id="e604e-165">For example, the following C# code example shows a basic service operation that takes one string and returns a string.</span></span>  
  
```csharp  
[OperationContractAttribute]  
string Hello(string greeting);  
```  
  
 <span data-ttu-id="e604e-166">Ниже приведен эквивалентный код Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="e604e-166">The following is the equivalent Visual Basic code.</span></span>  
  
```vb  
<OperationContractAttribute()>  
Function Hello (ByVal greeting As String) As String  
```  
  
 <span data-ttu-id="e604e-167">Сигнатура этой операции диктует вид базового обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="e604e-167">This operation signature dictates the form of underlying message exchange.</span></span> <span data-ttu-id="e604e-168">Если корреляция не существовала, WCF не может определить, для какой операции предназначено возвращаемое значение.</span><span class="sxs-lookup"><span data-stu-id="e604e-168">If no correlation existed, WCF cannot determine for which operation the return value is intended.</span></span>  
  
 <span data-ttu-id="e604e-169">Обратите внимание, что если не указан другой шаблон сообщения, даже операции службы, которые возвращают `void` ( `Nothing` в Visual Basic), обмениваются сообщениями с запросами и ответами.</span><span class="sxs-lookup"><span data-stu-id="e604e-169">Note that unless you specify a different underlying message pattern, even service operations that return `void` (`Nothing` in Visual Basic) are request/reply message exchanges.</span></span> <span data-ttu-id="e604e-170">Результат для операции такой: если клиент не вызывает операцию асинхронно, клиент приостанавливает обработку до получения возвращаемого сообщения, даже несмотря на то, что в нормальном случае это сообщение пустое.</span><span class="sxs-lookup"><span data-stu-id="e604e-170">The result for your operation is that unless a client invokes the operation asynchronously, the client stops processing until the return message is received, even though that message is empty in the normal case.</span></span> <span data-ttu-id="e604e-171">Следующий пример кода на C# показывает операцию, которая не отвечает, пока клиент не получит пустое сообщение в ответ.</span><span class="sxs-lookup"><span data-stu-id="e604e-171">The following C# code example shows an operation that does not return until the client has received an empty message in response.</span></span>  
  
```csharp  
[OperationContractAttribute]  
void Hello(string greeting);  
```  
  
 <span data-ttu-id="e604e-172">Ниже приведен эквивалентный код Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="e604e-172">The following is the equivalent Visual Basic code.</span></span>  
  
```vb  
<OperationContractAttribute()>  
Sub Hello (ByVal greeting As String)  
```  
  
 <span data-ttu-id="e604e-173">Приведенный пример кода может понизить производительность и скорость ответа клиента, если выполнение операции требует длительного времени, но у операций типа запрос-ответ есть преимущества, даже если они возвращают `void`.</span><span class="sxs-lookup"><span data-stu-id="e604e-173">The preceding example can slow client performance and responsiveness if the operation takes a long time to perform, but there are advantages to request/reply operations even when they return `void`.</span></span> <span data-ttu-id="e604e-174">Наиболее очевидное состоит в том, что сообщения о неисправностях SOAP могут возвращаться в сообщении ответа, что будет указывать на возникновение какой-либо связанной со службой ошибки либо при подключении, либо при обработке.</span><span class="sxs-lookup"><span data-stu-id="e604e-174">The most obvious one is that SOAP faults can be returned in the response message, which indicates that some service-related error condition has occurred, whether in communication or processing.</span></span> <span data-ttu-id="e604e-175">Неисправности SOAP, заданные в контракте службы, передаются клиентскому приложению в виде объекта <xref:System.ServiceModel.FaultException%601>, где параметр типа - это тип, заданный в контракте службы.</span><span class="sxs-lookup"><span data-stu-id="e604e-175">SOAP faults that are specified in a service contract are passed to the client application as a <xref:System.ServiceModel.FaultException%601> object, where the type parameter is the type specified in the service contract.</span></span> <span data-ttu-id="e604e-176">Это позволяет легко уведомлять клиентов об условиях ошибок в службах WCF.</span><span class="sxs-lookup"><span data-stu-id="e604e-176">This makes notifying clients about error conditions in WCF services easy.</span></span> <span data-ttu-id="e604e-177">Дополнительные сведения об исключениях, ошибках SOAP и обработке ошибок см. [в разделе Указание и обработка ошибок в контрактах и службах](specifying-and-handling-faults-in-contracts-and-services.md).</span><span class="sxs-lookup"><span data-stu-id="e604e-177">For more information about exceptions, SOAP faults, and error handling, see [Specifying and Handling Faults in Contracts and Services](specifying-and-handling-faults-in-contracts-and-services.md).</span></span> <span data-ttu-id="e604e-178">Пример службы "запрос-ответ" и "клиент" см. в разделе [как создать Request-Replyный контракт](./feature-details/how-to-create-a-request-reply-contract.md).</span><span class="sxs-lookup"><span data-stu-id="e604e-178">To see an example of a request/reply service and client, see [How to: Create a Request-Reply Contract](./feature-details/how-to-create-a-request-reply-contract.md).</span></span> <span data-ttu-id="e604e-179">Дополнительные сведения о проблемах с шаблоном "запрос-ответ" см. в разделе [службы "запрос-ответ](./feature-details/request-reply-services.md)".</span><span class="sxs-lookup"><span data-stu-id="e604e-179">For more information about issues with the request-reply pattern, see [Request-Reply Services](./feature-details/request-reply-services.md).</span></span>  
  
##### <a name="one-way"></a><span data-ttu-id="e604e-180">Односторонний</span><span class="sxs-lookup"><span data-stu-id="e604e-180">One-way</span></span>  

 <span data-ttu-id="e604e-181">Если клиент приложения службы WCF не должен ждать завершения операции и не обрабатывает ошибки SOAP, операция может указать односторонний шаблон сообщения.</span><span class="sxs-lookup"><span data-stu-id="e604e-181">If the client of a WCF service application should not wait for the operation to complete and does not process SOAP faults, the operation can specify a one-way message pattern.</span></span> <span data-ttu-id="e604e-182">Односторонняя операция — это одна, в которой клиент вызывает операцию и продолжит обработку после того, как WCF запишет сообщение в сеть.</span><span class="sxs-lookup"><span data-stu-id="e604e-182">A one-way operation is one in which a client invokes an operation and continues processing after WCF writes the message to the network.</span></span> <span data-ttu-id="e604e-183">Обычно это означает, что клиент продолжает работу почти без перерыва, если объем данных, передаваемых в исходящем сообщение не очень велик, и если не возникает ошибка при передаче данных.</span><span class="sxs-lookup"><span data-stu-id="e604e-183">Typically this means that unless the data being sent in the outbound message is extremely large the client continues running almost immediately (unless there is an error sending the data).</span></span> <span data-ttu-id="e604e-184">Этот шаблон обмена сообщениями поддерживает событийное взаимодействие между клиентом и приложением службы.</span><span class="sxs-lookup"><span data-stu-id="e604e-184">This type of message exchange pattern supports event-like behavior from a client to a service application.</span></span>  
  
 <span data-ttu-id="e604e-185">Обмен сообщениями, при котором одно сообщение отправляется и ни одного не принимается не поддерживает операции службы, для которых задано возвращаемое значение, отличное от `void`; в таком случае возникает исключение <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="e604e-185">A message exchange in which one message is sent and none are received cannot support a service operation that specifies a return value other than `void`; in this case an <xref:System.InvalidOperationException> exception is thrown.</span></span>  
  
 <span data-ttu-id="e604e-186">Отсутствие обратного сообщения также означает, что не может быть возвращено сообщение о неисправностях SOAP, указывающее на ошибки при обработке или подключении.</span><span class="sxs-lookup"><span data-stu-id="e604e-186">No return message also means that there can be no SOAP fault returned to indicate any errors in processing or communication.</span></span> <span data-ttu-id="e604e-187">(Передача сведений об ошибках подключения для односторонних операций требует дуплексного шаблона обмена сообщениями.)</span><span class="sxs-lookup"><span data-stu-id="e604e-187">(Communicating error information when operations are one-way operations requires a duplex message exchange pattern.)</span></span>  
  
 <span data-ttu-id="e604e-188">Чтобы задать односторонний обмен сообщениями для операции, возвращающей `void`, присвойте свойству <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> значение `true`, как в следующем примере кода C#.</span><span class="sxs-lookup"><span data-stu-id="e604e-188">To specify a one-way message exchange for an operation that returns `void`, set the <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> property to `true`, as in the following C# code example.</span></span>  
  
```csharp  
[OperationContractAttribute(IsOneWay=true)]  
void Hello(string greeting);  
```  
  
 <span data-ttu-id="e604e-189">Ниже приведен эквивалентный код Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="e604e-189">The following is the equivalent Visual Basic code.</span></span>  
  
```vb  
<OperationContractAttribute(IsOneWay := True)>  
Sub Hello (ByVal greeting As String)  
```  
  
 <span data-ttu-id="e604e-190">Метод тот же, что и в предшествующем примере типа запрос-ответ, но значение <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> свойства `true` означает, что несмотря на то, что метод тот же, операция службы не посылает ответное сообщение и клиенты продолжают работу немедленно после передачи исходящего сообщения на уровень канала.</span><span class="sxs-lookup"><span data-stu-id="e604e-190">This method is identical to the preceding request/reply example, but setting the <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> property to `true` means that although the method is identical, the service operation does not send a return message and clients return immediately once the outbound message has been handed to the channel layer.</span></span> <span data-ttu-id="e604e-191">Пример см. в разделе [как создать One-Wayный контракт](./feature-details/how-to-create-a-one-way-contract.md).</span><span class="sxs-lookup"><span data-stu-id="e604e-191">For an example, see [How to: Create a One-Way Contract](./feature-details/how-to-create-a-one-way-contract.md).</span></span> <span data-ttu-id="e604e-192">Дополнительные сведения о одностороннем шаблоне см. в разделе [односторонние службы](./feature-details/one-way-services.md).</span><span class="sxs-lookup"><span data-stu-id="e604e-192">For more information about the one-way pattern, see [One-Way Services](./feature-details/one-way-services.md).</span></span>  
  
##### <a name="duplex"></a><span data-ttu-id="e604e-193">Дуплекс</span><span class="sxs-lookup"><span data-stu-id="e604e-193">Duplex</span></span>  

 <span data-ttu-id="e604e-194">Дуплексный шаблон характеризуется способностью и службы, и клиента отправлять сообщения друг другу, независимо от того, используется ли односторонний обмен сообщениями или запрос-ответ.</span><span class="sxs-lookup"><span data-stu-id="e604e-194">A duplex pattern is characterized by the ability of both the service and the client to send messages to each other independently whether using one-way or request/reply messaging.</span></span> <span data-ttu-id="e604e-195">Такая форма двустороннего общения полезна для служб, которым требуется напрямую обращаться к клиенту, или для асинхронного взаимодействия обеих сторон обмена сообщениями, в том числе для событийного поведения.</span><span class="sxs-lookup"><span data-stu-id="e604e-195">This form of two-way communication is useful for services that must communicate directly to the client or for providing an asynchronous experience to either side of a message exchange, including event-like behavior.</span></span>  
  
 <span data-ttu-id="e604e-196">Дуплексный шаблон несколько более сложен, чем односторонний шаблон и шаблон запрос-ответ, так как имеет дополнительный механизм для взаимодействия с клиентом.</span><span class="sxs-lookup"><span data-stu-id="e604e-196">The duplex pattern is slightly more complex than the request/reply or one-way patterns because of the additional mechanism for communicating with the client.</span></span>  
  
 <span data-ttu-id="e604e-197">Для создания дуплексного контракта необходимо также создать контракт обратного вызова и присвоить тип этого контракта обратного вызова свойству <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> атрибута <xref:System.ServiceModel.ServiceContractAttribute> контракта службы.</span><span class="sxs-lookup"><span data-stu-id="e604e-197">To design a duplex contract, you must also design a callback contract and assign the type of that callback contract to the <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> property of the <xref:System.ServiceModel.ServiceContractAttribute> attribute that marks your service contract.</span></span>  
  
 <span data-ttu-id="e604e-198">Для реализации дуплексного шаблона необходимо создать второй интерфейс, содержащий объявления методов, вызываемых на клиенте.</span><span class="sxs-lookup"><span data-stu-id="e604e-198">To implement a duplex pattern, you must create a second interface that contains the method declarations that are called on the client.</span></span>  
  
 <span data-ttu-id="e604e-199">Пример создания службы и клиента, обращающегося к этой службе, см. [в разделе как создать дуплексный контракт](./feature-details/how-to-create-a-duplex-contract.md) и [как получить доступ к службам с помощью дуплексного контракта](./feature-details/how-to-access-services-with-a-duplex-contract.md).</span><span class="sxs-lookup"><span data-stu-id="e604e-199">For an example of creating a service, and a client that accesses that service, see [How to: Create a Duplex Contract](./feature-details/how-to-create-a-duplex-contract.md) and [How to: Access Services with a Duplex Contract](./feature-details/how-to-access-services-with-a-duplex-contract.md).</span></span> <span data-ttu-id="e604e-200">Рабочий пример см. в разделе [дуплекс](./samples/duplex.md).</span><span class="sxs-lookup"><span data-stu-id="e604e-200">For a working sample, see [Duplex](./samples/duplex.md).</span></span> <span data-ttu-id="e604e-201">Дополнительные сведения о проблемах с дуплексными контрактами см. в разделе [Дуплексные службы](./feature-details/duplex-services.md).</span><span class="sxs-lookup"><span data-stu-id="e604e-201">For more information about issues using duplex contracts, see [Duplex Services](./feature-details/duplex-services.md).</span></span>  
  
> [!CAUTION]
> <span data-ttu-id="e604e-202">Когда служба получает дуплексное сообщение, она проверяет элемент `ReplyTo` входящего сообщения, чтобы определить, куда отправлять ответ.</span><span class="sxs-lookup"><span data-stu-id="e604e-202">When a service receives a duplex message, it looks at the `ReplyTo` element in that incoming message to determine where to send the reply.</span></span> <span data-ttu-id="e604e-203">Если сообщение принимается по небезопасному каналу, ненадежный клиент может послать вредоносное сообщение с указанием компьютера для атаки в элементе `ReplyTo`, что приведет к отказу в обслуживании (DOS) этого компьютера.</span><span class="sxs-lookup"><span data-stu-id="e604e-203">If the channel that is used to receive the message is not secured, then an untrusted client could send a malicious message with a target machine's `ReplyTo`, leading to a denial of service (DOS) of that target machine.</span></span>  
  
##### <a name="out-and-ref-parameters"></a><span data-ttu-id="e604e-204">Параметры Out и Ref</span><span class="sxs-lookup"><span data-stu-id="e604e-204">Out and Ref Parameters</span></span>  

 <span data-ttu-id="e604e-205">В большинстве случаев можно использовать `in` Параметры ( `ByVal` в Visual Basic) и `out` `ref` Параметры ( `ByRef` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="e604e-205">In most cases, you can use `in` parameters (`ByVal` in Visual Basic) and `out` and `ref` parameters (`ByRef` in Visual Basic).</span></span> <span data-ttu-id="e604e-206">Так как параметры `out` и `ref` оба указывают на то, что операция возвращает данные, сигнатура операции, такая, как показана далее, задает необходимость операции запрос-ответ, несмотря на то что сигнатура операции возвращает `void`.</span><span class="sxs-lookup"><span data-stu-id="e604e-206">Because both `out` and `ref` parameters indicate that data is returned from an operation, an operation signature such as the following specifies that a request/reply operation is required even though the operation signature returns `void`.</span></span>  
  
```csharp  
[ServiceContractAttribute]  
public interface IMyContract  
{  
  [OperationContractAttribute]  
  public void PopulateData(ref CustomDataType data);  
}  
```  
  
 <span data-ttu-id="e604e-207">Ниже приведен эквивалентный код Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="e604e-207">The following is the equivalent Visual Basic code.</span></span>  
  
```vb  
<ServiceContractAttribute()> _  
Public Interface IMyContract  
  <OperationContractAttribute()> _  
  Public Sub PopulateData(ByRef data As CustomDataType)  
End Interface  
```  
  
 <span data-ttu-id="e604e-208">Исключение составляют только те случаи, когда сигнатура имеет определенную структуру.</span><span class="sxs-lookup"><span data-stu-id="e604e-208">The only exceptions are those cases in which your signature has a particular structure.</span></span> <span data-ttu-id="e604e-209">Например, можно использовать привязку <xref:System.ServiceModel.NetMsmqBinding> для взаимодействия с клиентами, только если метод, использованный для объявления операции, возвращает `void`; может не быть выходного значения, является ли оно возвращаемым значением, параметром `ref` или `out`.</span><span class="sxs-lookup"><span data-stu-id="e604e-209">For example, you can use the <xref:System.ServiceModel.NetMsmqBinding> binding to communicate with clients only if the method used to declare an operation returns `void`; there can be no output value, whether it is a return value, `ref`, or `out` parameter.</span></span>  
  
 <span data-ttu-id="e604e-210">Помимо этого, использование параметров `out` или `ref` требует, чтобы у операции было базовое ответное сообщение для передачи обратно измененного объекта.</span><span class="sxs-lookup"><span data-stu-id="e604e-210">In addition, using `out` or `ref` parameters requires that the operation have an underlying response message to carry back the modified object.</span></span> <span data-ttu-id="e604e-211">Если операция является односторонней, во время выполнения создается исключение <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="e604e-211">If your operation is a one-way operation, an <xref:System.InvalidOperationException> exception is thrown at runtime.</span></span>  
  
### <a name="specify-message-protection-level-on-the-contract"></a><span data-ttu-id="e604e-212">Определение уровня защиты сообщений для контракта</span><span class="sxs-lookup"><span data-stu-id="e604e-212">Specify Message Protection Level on the Contract</span></span>  

 <span data-ttu-id="e604e-213">При создании контракта необходимо также определить уровень защиты сообщений служб, реализующих этот контракт.</span><span class="sxs-lookup"><span data-stu-id="e604e-213">When designing your contract, you must also decide the message protection level of services that implement your contract.</span></span> <span data-ttu-id="e604e-214">Это необходимо, только если к привязке применена безопасность сообщений в конечной точке контракта.</span><span class="sxs-lookup"><span data-stu-id="e604e-214">This is necessary only if message security is applied to the binding in the contract's endpoint.</span></span> <span data-ttu-id="e604e-215">Если для привязки безопасность отключена (то есть, если привязка, предоставляемая системой, присваивает объекту <xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType> значение <xref:System.ServiceModel.SecurityMode.None?displayProperty=nameWithType>), то не нужно определять уровень безопасности сообщений для контракта.</span><span class="sxs-lookup"><span data-stu-id="e604e-215">If the binding has security turned off (that is, if the system-provided binding sets the <xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType> to the value <xref:System.ServiceModel.SecurityMode.None?displayProperty=nameWithType>) then you do not have to decide on the message protection level for the contract.</span></span> <span data-ttu-id="e604e-216">В большинстве случаев привязки, предоставляемые системой, с безопасностью на уровне сообщений предоставляют достаточный уровень защиты и нет необходимости рассматривать уровень защиты для каждой операции или для каждого сообщения.</span><span class="sxs-lookup"><span data-stu-id="e604e-216">In most cases, system-provided bindings with message-level security applied provide a sufficient protection level and you do not have to consider the protection level for each operation or for each message.</span></span>  
  
 <span data-ttu-id="e604e-217">Уровень защиты - это значение, которое определяет для сообщений (или частей сообщений), поддерживающих службу, подписываются ли они, подписываются и шифруются или отправляются без подписи и шифровки.</span><span class="sxs-lookup"><span data-stu-id="e604e-217">The protection level is a value that specifies whether the messages (or message parts) that support a service are signed, signed and encrypted, or sent without signatures or encryption.</span></span> <span data-ttu-id="e604e-218">Уровень защиты может быть задан в различных областях: на уровне службы, для конкретной операции, для сообщения операции или для части сообщения.</span><span class="sxs-lookup"><span data-stu-id="e604e-218">The protection level can be set at various scopes: At the service level, for a particular operation, for a message within that operation, or a message part.</span></span> <span data-ttu-id="e604e-219">Значения, заданные для более широкой области, становятся значениями по умолчанию для более узких областей, если не переопределить их явным образом.</span><span class="sxs-lookup"><span data-stu-id="e604e-219">Values set at one scope become the default value for smaller scopes unless explicitly overridden.</span></span> <span data-ttu-id="e604e-220">Если конфигурация привязки не может обеспечить минимальный необходимый уровень защиты для контракта, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="e604e-220">If a binding configuration cannot provide the required minimum protection level for the contract, an exception is thrown.</span></span> <span data-ttu-id="e604e-221">Если для контракта явно не задано значений уровня защиты, и если привязка имеет безопасность сообщений, уровнем защиты всех сообщений управляет конфигурация привязки.</span><span class="sxs-lookup"><span data-stu-id="e604e-221">And when no protection level values are explicitly set on the contract, the binding configuration controls the protection level for all messages if the binding has message security.</span></span> <span data-ttu-id="e604e-222">Это поведение установлено по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="e604e-222">This is the default behavior.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="e604e-223">Решение явно задать для различных областей контракта уровень защиты меньше максимального <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> обычно является компромиссом между степенью защиты и улучшением производительности.</span><span class="sxs-lookup"><span data-stu-id="e604e-223">Deciding whether to explicitly set various scopes of a contract to less than the full protection level of <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> is generally a decision that trades some degree of security for increased performance.</span></span> <span data-ttu-id="e604e-224">В таких случаях решения должны опираться на вид операций и ценность передаваемых данных.</span><span class="sxs-lookup"><span data-stu-id="e604e-224">In these cases, your decisions must revolve around your operations and the value of the data they exchange.</span></span> <span data-ttu-id="e604e-225">Дополнительные сведения см. в разделе [Защита служб](securing-services.md).</span><span class="sxs-lookup"><span data-stu-id="e604e-225">For more information, see [Securing Services](securing-services.md).</span></span>  
  
 <span data-ttu-id="e604e-226">Например, в следующем примере кода не задается ни свойство<xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A>, ни свойство <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> контракта.</span><span class="sxs-lookup"><span data-stu-id="e604e-226">For example, the following code example does not set either the <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> or the <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> property on the contract.</span></span>  
  
```csharp  
[ServiceContract]  
public interface ISampleService  
{  
  [OperationContractAttribute]  
  public string GetString();  
  
  [OperationContractAttribute]  
  public int GetInt();
}  
```  
  
 <span data-ttu-id="e604e-227">Ниже приведен эквивалентный код Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="e604e-227">The following is the equivalent Visual Basic code.</span></span>  
  
```vb  
<ServiceContractAttribute()> _  
Public Interface ISampleService  
  
  <OperationContractAttribute()> _  
  Public Function GetString()As String  
  
  <OperationContractAttribute()> _  
  Public Function GetData() As Integer  
  
End Interface  
```  
  
 <span data-ttu-id="e604e-228">При взаимодействии с реализацией `ISampleService` в конечной точке с привязкой <xref:System.ServiceModel.WSHttpBinding> по умолчанию (<xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType> по умолчанию, то есть значение <xref:System.ServiceModel.SecurityMode.Message>), все сообщения зашифровываются и подписываются, так как это является уровнем защиты по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="e604e-228">When interacting with an `ISampleService` implementation in an endpoint with a default <xref:System.ServiceModel.WSHttpBinding> (the default <xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType>, which is <xref:System.ServiceModel.SecurityMode.Message>), all messages are encrypted and signed because this is the default protection level.</span></span> <span data-ttu-id="e604e-229">Однако при использовании службы `ISampleService` с привязкой <xref:System.ServiceModel.BasicHttpBinding> по умолчанию (<xref:System.ServiceModel.SecurityMode> по умолчанию, то есть значение <xref:System.ServiceModel.SecurityMode.None>), все сообщения отправляются в текстовом виде, так как эта привязка не имеет безопасности и, следовательно, уровень защиты игнорируется (то есть сообщения не шифруются и не подписываются).</span><span class="sxs-lookup"><span data-stu-id="e604e-229">However, when an `ISampleService` service is used with a default <xref:System.ServiceModel.BasicHttpBinding> (the default <xref:System.ServiceModel.SecurityMode>, which is <xref:System.ServiceModel.SecurityMode.None>), all messages are sent as text because there is no security for this binding and so the protection level is ignored (that is, the messages are neither encrypted nor signed).</span></span> <span data-ttu-id="e604e-230">Если изменить значение свойства <xref:System.ServiceModel.SecurityMode> на <xref:System.ServiceModel.SecurityMode.Message>, то сообщения будут зашифровываться и подписываться, так как теперь таков будет уровень защиты по умолчанию для привязки.</span><span class="sxs-lookup"><span data-stu-id="e604e-230">If the <xref:System.ServiceModel.SecurityMode> was changed to <xref:System.ServiceModel.SecurityMode.Message>, then these messages would be encrypted and signed (because that would now be the binding's default protection level).</span></span>  
  
 <span data-ttu-id="e604e-231">Если требуется явным образом задать или настроить требования по безопасности для контракта, задайте для свойства <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> (или для любого из свойств `ProtectionLevel` более узкой области) уровень, требуемый для контракта службы.</span><span class="sxs-lookup"><span data-stu-id="e604e-231">If you want to explicitly specify or adjust the protection requirements for your contract, set the <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> property (or any of the `ProtectionLevel` properties at a smaller scope) to the level your service contract requires.</span></span> <span data-ttu-id="e604e-232">В данном случае явная настройка требует, чтобы привязка поддерживала эту настройку по крайней мере для указанной области.</span><span class="sxs-lookup"><span data-stu-id="e604e-232">In this case, using an explicit setting requires the binding to support that setting at a minimum for the scope used.</span></span> <span data-ttu-id="e604e-233">Например, в следующем примере кода явно задается одно значение <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> для операции `GetGuid`.</span><span class="sxs-lookup"><span data-stu-id="e604e-233">For example, the following code example specifies one <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> value explicitly, for the `GetGuid` operation.</span></span>  
  
```csharp  
[ServiceContract]  
public interface IExplicitProtectionLevelSampleService  
{  
  [OperationContractAttribute]  
  public string GetString();  
  
  [OperationContractAttribute(ProtectionLevel=ProtectionLevel.None)]  
  public int GetInt();
  [OperationContractAttribute(ProtectionLevel=ProtectionLevel.EncryptAndSign)]  
  public int GetGuid();
}  
```  
  
 <span data-ttu-id="e604e-234">Ниже приведен эквивалентный код Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="e604e-234">The following is the equivalent Visual Basic code.</span></span>  
  
```vb  
<ServiceContract()> _
Public Interface IExplicitProtectionLevelSampleService
    <OperationContract()> _
    Public Function GetString() As String
    End Function
  
    <OperationContract(ProtectionLevel := ProtectionLevel.None)> _
    Public Function GetInt() As Integer
    End Function
  
    <OperationContractAttribute(ProtectionLevel := ProtectionLevel.EncryptAndSign)> _
    Public Function GetGuid() As Integer
    End Function
  
End Interface  
```  
  
 <span data-ttu-id="e604e-235">Служба, реализующая этот контракт `IExplicitProtectionLevelSampleService` и имеющая конечную точку, где используется привязка <xref:System.ServiceModel.WSHttpBinding> по умолчанию (<xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType> по умолчанию, то есть значение <xref:System.ServiceModel.SecurityMode.Message>) ведет себя следующим образом:</span><span class="sxs-lookup"><span data-stu-id="e604e-235">A service that implements this `IExplicitProtectionLevelSampleService` contract and has an endpoint that uses the default <xref:System.ServiceModel.WSHttpBinding> (the default <xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType>, which is <xref:System.ServiceModel.SecurityMode.Message>) has the following behavior:</span></span>  
  
- <span data-ttu-id="e604e-236">Для операции `GetString` сообщения шифруются и подписываются.</span><span class="sxs-lookup"><span data-stu-id="e604e-236">The `GetString` operation messages are encrypted and signed.</span></span>  
  
- <span data-ttu-id="e604e-237">Для операции `GetInt` сообщения не шифруются и не подписываются, то есть отправляются как простой текст.</span><span class="sxs-lookup"><span data-stu-id="e604e-237">The `GetInt` operation messages are sent as unencrypted and unsigned (that is, plain) text.</span></span>  
  
- <span data-ttu-id="e604e-238">`GetGuid` операции <xref:System.Guid?displayProperty=nameWithType> возвращается в зашифрованном подписанном сообщении.</span><span class="sxs-lookup"><span data-stu-id="e604e-238">The `GetGuid` operation <xref:System.Guid?displayProperty=nameWithType> is returned in a message that is encrypted and signed.</span></span>  
  
 <span data-ttu-id="e604e-239">Дополнительные сведения об уровнях защиты и их использовании см. в разделе [Основные сведения о уровне защиты](understanding-protection-level.md).</span><span class="sxs-lookup"><span data-stu-id="e604e-239">For more information about protection levels and how to use them, see [Understanding Protection Level](understanding-protection-level.md).</span></span> <span data-ttu-id="e604e-240">Дополнительные сведения о безопасности см. в разделе [Защита служб](securing-services.md).</span><span class="sxs-lookup"><span data-stu-id="e604e-240">For more information about security, see [Securing Services](securing-services.md).</span></span>  
  
##### <a name="other-operation-signature-requirements"></a><span data-ttu-id="e604e-241">Другие требования к сигнатуре операции</span><span class="sxs-lookup"><span data-stu-id="e604e-241">Other Operation Signature Requirements</span></span>  

 <span data-ttu-id="e604e-242">Некоторые возможности приложения требуют определенного вида сигнатуры операции.</span><span class="sxs-lookup"><span data-stu-id="e604e-242">Some application features require a particular kind of operation signature.</span></span> <span data-ttu-id="e604e-243">Например, привязка <xref:System.ServiceModel.NetMsmqBinding> поддерживает устойчивые службы и клиенты, позволяющие перезапуск приложения при установленном подключении, при этом приложение продолжит работу с того места, где остановилось, и ни одно сообщение не будет потеряно.</span><span class="sxs-lookup"><span data-stu-id="e604e-243">For example, the <xref:System.ServiceModel.NetMsmqBinding> binding supports durable services and clients, in which an application can restart in the middle of communication and pick up where it left off without missing any messages.</span></span> <span data-ttu-id="e604e-244">(Дополнительные сведения см. [в разделе очереди в WCF](./feature-details/queues-in-wcf.md).) Однако устойчивые операции должны принимать только один `in` параметр и не иметь возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="e604e-244">(For more information, see [Queues in WCF](./feature-details/queues-in-wcf.md).) However, durable operations must take only one `in` parameter and have no return value.</span></span>  
  
 <span data-ttu-id="e604e-245">Другой пример - использование типов <xref:System.IO.Stream> в операциях.</span><span class="sxs-lookup"><span data-stu-id="e604e-245">Another example is the use of <xref:System.IO.Stream> types in operations.</span></span> <span data-ttu-id="e604e-246">Так как параметр <xref:System.IO.Stream> включает в себя тело сообщения целиком, если входные или выходные данные (то есть параметр `ref`, параметр `out` или возвращаемое значение) принадлежат типу <xref:System.IO.Stream>, это должны быть единственные входные и выходные данные, заданные для операции.</span><span class="sxs-lookup"><span data-stu-id="e604e-246">Because the <xref:System.IO.Stream> parameter includes the entire message body, if an input or an output (that is, `ref` parameter, `out` parameter, or return value) is of type <xref:System.IO.Stream>, then it must be the only input or output specified in your operation.</span></span> <span data-ttu-id="e604e-247">Кроме того, параметр или тип возвращаемого значения должны являться объектами <xref:System.IO.Stream>, <xref:System.ServiceModel.Channels.Message?displayProperty=nameWithType> или <xref:System.Xml.Serialization.IXmlSerializable?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e604e-247">In addition, the parameter or return type must be either <xref:System.IO.Stream>, <xref:System.ServiceModel.Channels.Message?displayProperty=nameWithType>, or <xref:System.Xml.Serialization.IXmlSerializable?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e604e-248">Дополнительные сведения о потоках см. в разделе [большие данные и потоковая передача](./feature-details/large-data-and-streaming.md).</span><span class="sxs-lookup"><span data-stu-id="e604e-248">For more information about streams, see [Large Data and Streaming](./feature-details/large-data-and-streaming.md).</span></span>  
  
##### <a name="names-namespaces-and-obfuscation"></a><span data-ttu-id="e604e-249">Имена, пространства имен и запутывание</span><span class="sxs-lookup"><span data-stu-id="e604e-249">Names, Namespaces, and Obfuscation</span></span>  

 <span data-ttu-id="e604e-250">Имена и пространства имен типов .NET в определениях контрактов и операций важны при преобразовании контрактов в WSDL и при создании и отправке сообщений контрактов.</span><span class="sxs-lookup"><span data-stu-id="e604e-250">The names and namespaces of the .NET types in the definition of contracts and operations are significant when contracts are converted into WSDL and when contract messages are created and sent.</span></span> <span data-ttu-id="e604e-251">Поэтому рекомендуется явно задавать имена и пространства имен контракта службы с помощью свойств `Name` и `Namespace` всех поддерживающих атрибутов контракта, например <xref:System.ServiceModel.ServiceContractAttribute>, <xref:System.ServiceModel.OperationContractAttribute>, <xref:System.Runtime.Serialization.DataContractAttribute>, <xref:System.Runtime.Serialization.DataMemberAttribute> и других атрибутов контракта.</span><span class="sxs-lookup"><span data-stu-id="e604e-251">Therefore, it is strongly recommended that service contract names and namespaces are explicitly set using the `Name` and `Namespace` properties of all supporting contract attributes such as the <xref:System.ServiceModel.ServiceContractAttribute>, <xref:System.ServiceModel.OperationContractAttribute>, <xref:System.Runtime.Serialization.DataContractAttribute>,  <xref:System.Runtime.Serialization.DataMemberAttribute>, and other contract attributes.</span></span>  
  
 <span data-ttu-id="e604e-252">Одним из следствий этого является то, что если имена и пространства имен не заданы явно, применение обфускации IL для сборки изменяет имена типов и пространства имен контракта, что приводит к измененному коду WSDL и обмену сообщениями, который обычно завершается ошибкой.</span><span class="sxs-lookup"><span data-stu-id="e604e-252">One result of this is that if the names and namespaces are not explicitly set, the use of IL obfuscation on the assembly alters the contract type names and namespaces and results in modified WSDL and wire exchanges that typically fail.</span></span> <span data-ttu-id="e604e-253">Если вы не задаете явно имена и пространства имен контракта, но планируете использовать обфускацию, используйте атрибуты <xref:System.Reflection.ObfuscationAttribute> и <xref:System.Reflection.ObfuscateAssemblyAttribute>, чтобы предотвратить изменение имен и пространств имен контракта.</span><span class="sxs-lookup"><span data-stu-id="e604e-253">If you do not set the contract names and namespaces explicitly but do intend to use obfuscation, use the <xref:System.Reflection.ObfuscationAttribute> and <xref:System.Reflection.ObfuscateAssemblyAttribute> attributes to prevent the modification of the contract type names and namespaces.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e604e-254">См. также</span><span class="sxs-lookup"><span data-stu-id="e604e-254">See also</span></span>

- [<span data-ttu-id="e604e-255">Практическое руководство. Создание контракта типа "запрос — ответ"</span><span class="sxs-lookup"><span data-stu-id="e604e-255">How to: Create a Request-Reply Contract</span></span>](./feature-details/how-to-create-a-request-reply-contract.md)
- [<span data-ttu-id="e604e-256">Практическое руководство. Создание одностороннего контракта</span><span class="sxs-lookup"><span data-stu-id="e604e-256">How to: Create a One-Way Contract</span></span>](./feature-details/how-to-create-a-one-way-contract.md)
- [<span data-ttu-id="e604e-257">Практическое руководство. Создание двухстороннего контракта</span><span class="sxs-lookup"><span data-stu-id="e604e-257">How to: Create a Duplex Contract</span></span>](./feature-details/how-to-create-a-duplex-contract.md)
- [<span data-ttu-id="e604e-258">Задание передачи данных в контрактах служб</span><span class="sxs-lookup"><span data-stu-id="e604e-258">Specifying Data Transfer in Service Contracts</span></span>](./feature-details/specifying-data-transfer-in-service-contracts.md)
- [<span data-ttu-id="e604e-259">Задание и обработка сбоев в контрактах и службах</span><span class="sxs-lookup"><span data-stu-id="e604e-259">Specifying and Handling Faults in Contracts and Services</span></span>](specifying-and-handling-faults-in-contracts-and-services.md)
- [<span data-ttu-id="e604e-260">Использование сеансов</span><span class="sxs-lookup"><span data-stu-id="e604e-260">Using Sessions</span></span>](using-sessions.md)
- [<span data-ttu-id="e604e-261">Синхронные и асинхронные операции</span><span class="sxs-lookup"><span data-stu-id="e604e-261">Synchronous and Asynchronous Operations</span></span>](synchronous-and-asynchronous-operations.md)
- [<span data-ttu-id="e604e-262">Надежные службы</span><span class="sxs-lookup"><span data-stu-id="e604e-262">Reliable Services</span></span>](reliable-services.md)
- [<span data-ttu-id="e604e-263">Службы и транзакции</span><span class="sxs-lookup"><span data-stu-id="e604e-263">Services and Transactions</span></span>](services-and-transactions.md)
