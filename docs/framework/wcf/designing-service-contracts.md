---
title: Создание контрактов служб
description: Сведения о контрактах служб, в том числе о создании, доступных операциях и типах данных, а также о других аспектах контрактов служб в программировании WCF.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- service contracts [WCF]
ms.assetid: 8e89cbb9-ac84-4f0d-85ef-0eb6be0022fd
ms.openlocfilehash: 366157b86ed7c420aed9a3a70838b4d6cd1e451f
ms.sourcegitcommit: 358a28048f36a8dca39a9fe6e6ac1f1913acadd5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/23/2020
ms.locfileid: "85245392"
---
# <a name="designing-service-contracts"></a>Создание контрактов служб
Этот раздел описывает, что такое контракты служб, как они определяются, какие операции доступны (также описаны последствия обмена сообщениями, на которых они основаны), какие типы данных используются; кроме того, он содержит ответы на другие вопросы, которые помогут при разработке операций, удовлетворяющих требованиям вашего сценария.  
  
## <a name="creating-a-service-contract"></a>Создание контракта службы  
 Службы предоставляют несколько операций. В приложениях Windows Communication Foundation (WCF) определите операции, создав метод и пометив его <xref:System.ServiceModel.OperationContractAttribute> атрибутом. Затем, для создания контракта службы, необходимо сгруппировать операции либо объявив их в интерфейсе, отмеченном атрибутом <xref:System.ServiceModel.ServiceContractAttribute>, либо определив их в классе с таким же атрибутом. (Базовый пример см. в разделе [как определить контракт службы](how-to-define-a-wcf-service-contract.md).)  
  
 Все методы, не имеющие атрибута, <xref:System.ServiceModel.OperationContractAttribute> не являются операциями службы и не предоставляются СЛУЖБАМИ WCF.  
  
 Этот раздел рассказывает о принятии решений по следующим вопросам при создании контракта службы:  
  
- использовать ли классы или интерфейсы;  
  
- как задать типы данных, которыми нужно обмениваться;  
  
- какие типы шаблонов обмена можно использовать;  
  
- можно ли сделать явные требования безопасности частью контракта;  
  
- каковы ограничения для входных и выходных данных операций.  
  
## <a name="classes-or-interfaces"></a>Классы или интерфейсы  
 Классы и интерфейсы представляют собой группирование функциональных возможностей и, следовательно, могут использоваться для определения контракта службы WCF. Однако рекомендуется использовать интерфейсы, так как они напрямую моделируют контракты служб. Не имея реализации, интерфейсы всего лишь определяют группу методов с определенными сигнатурами. Реализуйте интерфейс контракта службы, и вы реализовали службу WCF.  
  
 Все преимущества управляемых интерфейсов относятся также к интерфейсам контрактов служб:  
  
- интерфейсы контрактов служб могут расширять любое число других интерфейсов контрактов служб;  
  
- отдельный класс может реализовывать любое число контрактов служб, реализуя интерфейсы этих контрактов служб;  
  
- можно изменить реализацию контракта службы, изменив реализацию интерфейса и не изменяя сам контракт;  
  
- можно создать несколько версий службы, реализуя старый и новый интерфейсы. Старые клиенты могут подключаться к исходной версии, а более новые клиенты - к более новой версии.  
  
> [!NOTE]
> При наследовании от других интерфейсов контрактов служб нельзя переопределять свойства операций, например имя или пространство имен. Если попытаться сделать это, будет создана новая операция в текущем контракте службы.  
  
 Пример использования интерфейса для создания контракта службы см. [в разделе инструкции. Создание службы с интерфейсом контракта](./feature-details/how-to-create-a-service-with-a-contract-interface.md).  
  
 Однако можно использовать класс для определения контракта службы и одновременной реализации этого контракта. Преимущество создания службы путем применения атрибутов <xref:System.ServiceModel.ServiceContractAttribute> и <xref:System.ServiceModel.OperationContractAttribute> напрямую к классу и методам класса, соответственно, - это скорость и простота. Недостаток состоит в том, что управляемые классы не поддерживают множественное наследование, и в результате могут реализовывать только один контракт службы за раз. Кроме того, любое изменение сигнатуры класса или метода изменяет открытый контракт для этой службы, что может предотвратить использование службы неизмененными клиентами. Дополнительные сведения см. в разделе [реализация контрактов служб](implementing-service-contracts.md).  
  
 Пример использования класса для создания контракта службы и его реализации в то же время см. в разделе [как создать службу с помощью класса контракта](./feature-details/how-to-create-a-wcf-contract-with-a-class.md).  
  
 К этому моменту у вас должно было сложиться представление о том, в чем заключается разница между определением контракта службы через интерфейс и через класс. Следующий шаг - определить, какие данные могут передаваться между службой и клиентами.  
  
## <a name="parameters-and-return-values"></a>Параметры и возвращаемые значения  
 Каждая операция имеет возвращаемое значение и параметр, даже в случае `void`. Однако, в отличие от локального метода, в котором можно передавать ссылки на объекты от одного объекта к другому, операции служб не передают ссылки на объекты. Вместо этого они передают копии объектов.  
  
 Это важно, потому что каждый тип, используемый для параметра или возвращаемого значения, должен быть сериализуем. Это значит, должно быть возможно преобразование объекта этого типа в поток байтов и обратно из потока байтов в объект.  
  
 Примитивные типы сериализуемы по умолчанию, как и многие типы в .NET Framework.  
  
> [!NOTE]
> Значения имен параметров в сигнатуре операции являются частью контракта и чувствительны к регистру. Если требуется использовать одно имя параметра локально, но изменить имя опубликованных метаданных, см. раздел <xref:System.ServiceModel.MessageParameterAttribute?displayProperty=nameWithType>.  
  
#### <a name="data-contracts"></a>Контракты данных  
 Приложения, ориентированные на службы, такие как Windows Communication Foundation (WCF), предназначены для взаимодействия с самым широким количеством клиентских приложений на платформах Майкрософт и сторонних производителей. Для наиболее широких возможностей взаимодействия рекомендуется помечать типы атрибутами <xref:System.Runtime.Serialization.DataContractAttribute> и <xref:System.Runtime.Serialization.DataMemberAttribute> для создания контракта данных - части контракта службы, описывающей данные, которыми могут обмениваться операции службы.  
  
 Контракты данных - включаемые по требованию контракты стилей: тип или элемент данных не сериализуются, если не применен явным образом атрибут контракта данных. Контракты данных не связаны с областью доступа управляемого кода: закрытые элементы данных могут быть сериализованы и отправлены куда-либо для открытого доступа. (Простой пример контракта данных см. [в разделе как создать базовый контракт данных для класса или структуры](./feature-details/how-to-create-a-basic-data-contract-for-a-class-or-structure.md).) WCF обрабатывает определение базовых сообщений SOAP, которые обеспечивают функциональность операции, а также сериализацию типов данных в текст сообщений и из него. Если типы данных сериализуемы, нет необходимости думать об инфраструктуре обмена базовыми сообщениями при создании операций.  
  
 Хотя типичное приложение WCF использует <xref:System.Runtime.Serialization.DataContractAttribute> атрибуты и <xref:System.Runtime.Serialization.DataMemberAttribute> для создания контрактов данных для операций, можно использовать другие механизмы сериализации. Стандартные механизмы <xref:System.Runtime.Serialization.ISerializable>, <xref:System.SerializableAttribute> и <xref:System.Xml.Serialization.IXmlSerializable> все обеспечивают сериализацию типов данных в базовые сообщения SOAP, которые переносят данные от одного приложения к другому. Можно применить дополнительные стратегии сериализации, если типы данных требуют специальной поддержки. Дополнительные сведения о выборе сериализации типов данных в приложениях WCF см. [в разделе указание передача данных в контрактах служб](./feature-details/specifying-data-transfer-in-service-contracts.md).  
  
#### <a name="mapping-parameters-and-return-values-to-message-exchanges"></a>Сопоставление параметров и возвращаемых значений с обменом сообщениями  
 Операции службы поддерживаются при помощи базового обмена сообщениями SOAP, в которых передаются данные приложения в двух направлениях, а также данные, необходимые приложению для поддержки стандартной безопасности, транзакций и возможностей, связанных с сеансами. Так как это так, сигнатура операции службы определяет определенный *шаблон обмена сообщениями* (MEP), который поддерживает перенос данных и функции, необходимые для операции. В модели программирования WCF можно указать три шаблона: запрос-ответ, односторонний и дуплексные шаблоны сообщений.  
  
##### <a name="requestreply"></a>Запрос-ответ  
 Шаблон запрос-ответ означает, что отправитель запроса (клиентское приложение) получает ответ, который соответствует запросу. Это шаблон обмена сообщениями по умолчанию, так как он поддерживает операцию, в которую передается один или больше параметров и из которой происходит возврат результирующего значения вызывавшей стороне. Например, следующий пример кода на языке C# показывает основную операцию службы, которая получает и возвращает строку.  
  
```csharp  
[OperationContractAttribute]  
string Hello(string greeting);  
```  
  
 Ниже приведен эквивалентный код Visual Basic.  
  
```vb  
<OperationContractAttribute()>  
Function Hello (ByVal greeting As String) As String  
```  
  
 Сигнатура этой операции диктует вид базового обмена сообщениями. Если корреляция не существовала, WCF не может определить, для какой операции предназначено возвращаемое значение.  
  
 Обратите внимание, что если не указан другой шаблон сообщения, даже операции службы, которые возвращают `void` ( `Nothing` в Visual Basic), обмениваются сообщениями с запросами и ответами. Результат для операции такой: если клиент не вызывает операцию асинхронно, клиент приостанавливает обработку до получения возвращаемого сообщения, даже несмотря на то, что в нормальном случае это сообщение пустое. Следующий пример кода на C# показывает операцию, которая не отвечает, пока клиент не получит пустое сообщение в ответ.  
  
```csharp  
[OperationContractAttribute]  
void Hello(string greeting);  
```  
  
 Ниже приведен эквивалентный код Visual Basic.  
  
```vb  
<OperationContractAttribute()>  
Sub Hello (ByVal greeting As String)  
```  
  
 Приведенный пример кода может понизить производительность и скорость ответа клиента, если выполнение операции требует длительного времени, но у операций типа запрос-ответ есть преимущества, даже если они возвращают `void`. Наиболее очевидное состоит в том, что сообщения о неисправностях SOAP могут возвращаться в сообщении ответа, что будет указывать на возникновение какой-либо связанной со службой ошибки либо при подключении, либо при обработке. Неисправности SOAP, заданные в контракте службы, передаются клиентскому приложению в виде объекта <xref:System.ServiceModel.FaultException%601>, где параметр типа - это тип, заданный в контракте службы. Это позволяет легко уведомлять клиентов об условиях ошибок в службах WCF. Дополнительные сведения об исключениях, ошибках SOAP и обработке ошибок см. [в разделе Указание и обработка ошибок в контрактах и службах](specifying-and-handling-faults-in-contracts-and-services.md). Пример службы "запрос-ответ" и "клиент" см. в разделе [как создать контракт с запросом и ответом](./feature-details/how-to-create-a-request-reply-contract.md). Дополнительные сведения о проблемах с шаблоном "запрос-ответ" см. в разделе [службы "запрос-ответ](./feature-details/request-reply-services.md)".  
  
##### <a name="one-way"></a>Односторонний  
 Если клиент приложения службы WCF не должен ждать завершения операции и не обрабатывает ошибки SOAP, операция может указать односторонний шаблон сообщения. Односторонняя операция — это одна, в которой клиент вызывает операцию и продолжит обработку после того, как WCF запишет сообщение в сеть. Обычно это означает, что клиент продолжает работу почти без перерыва, если объем данных, передаваемых в исходящем сообщение не очень велик, и если не возникает ошибка при передаче данных. Этот шаблон обмена сообщениями поддерживает событийное взаимодействие между клиентом и приложением службы.  
  
 Обмен сообщениями, при котором одно сообщение отправляется и ни одного не принимается не поддерживает операции службы, для которых задано возвращаемое значение, отличное от `void`; в таком случае возникает исключение <xref:System.InvalidOperationException>.  
  
 Отсутствие обратного сообщения также означает, что не может быть возвращено сообщение о неисправностях SOAP, указывающее на ошибки при обработке или подключении. (Передача сведений об ошибках подключения для односторонних операций требует дуплексного шаблона обмена сообщениями.)  
  
 Чтобы задать односторонний обмен сообщениями для операции, возвращающей `void`, присвойте свойству <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> значение `true`, как в следующем примере кода C#.  
  
```csharp  
[OperationContractAttribute(IsOneWay=true)]  
void Hello(string greeting);  
```  
  
 Ниже приведен эквивалентный код Visual Basic.  
  
```vb  
<OperationContractAttribute(IsOneWay := True)>  
Sub Hello (ByVal greeting As String)  
```  
  
 Метод тот же, что и в предшествующем примере типа запрос-ответ, но значение <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> свойства `true` означает, что несмотря на то, что метод тот же, операция службы не посылает ответное сообщение и клиенты продолжают работу немедленно после передачи исходящего сообщения на уровень канала. Пример см. в разделе [как создать односторонний контракт](./feature-details/how-to-create-a-one-way-contract.md). Дополнительные сведения о одностороннем шаблоне см. в разделе [односторонние службы](./feature-details/one-way-services.md).  
  
##### <a name="duplex"></a>Дуплекс  
 Дуплексный шаблон характеризуется способностью и службы, и клиента отправлять сообщения друг другу, независимо от того, используется ли односторонний обмен сообщениями или запрос-ответ. Такая форма двустороннего общения полезна для служб, которым требуется напрямую обращаться к клиенту, или для асинхронного взаимодействия обеих сторон обмена сообщениями, в том числе для событийного поведения.  
  
 Дуплексный шаблон несколько более сложен, чем односторонний шаблон и шаблон запрос-ответ, так как имеет дополнительный механизм для взаимодействия с клиентом.  
  
 Для создания дуплексного контракта необходимо также создать контракт обратного вызова и присвоить тип этого контракта обратного вызова свойству <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> атрибута <xref:System.ServiceModel.ServiceContractAttribute> контракта службы.  
  
 Для реализации дуплексного шаблона необходимо создать второй интерфейс, содержащий объявления методов, вызываемых на клиенте.  
  
 Пример создания службы и клиента, обращающегося к этой службе, см. [в разделе как создать дуплексный контракт](./feature-details/how-to-create-a-duplex-contract.md) и [как получить доступ к службам с помощью дуплексного контракта](./feature-details/how-to-access-services-with-a-duplex-contract.md). Рабочий пример см. в разделе [дуплекс](./samples/duplex.md). Дополнительные сведения о проблемах с дуплексными контрактами см. в разделе [Дуплексные службы](./feature-details/duplex-services.md).  
  
> [!CAUTION]
> Когда служба получает дуплексное сообщение, она проверяет элемент `ReplyTo` входящего сообщения, чтобы определить, куда отправлять ответ. Если сообщение принимается по небезопасному каналу, ненадежный клиент может послать вредоносное сообщение с указанием компьютера для атаки в элементе `ReplyTo`, что приведет к отказу в обслуживании (DOS) этого компьютера.  
  
##### <a name="out-and-ref-parameters"></a>Параметры Out и Ref  
 В большинстве случаев можно использовать `in` Параметры ( `ByVal` в Visual Basic) и `out` `ref` Параметры ( `ByRef` в Visual Basic). Так как параметры `out` и `ref` оба указывают на то, что операция возвращает данные, сигнатура операции, такая, как показана далее, задает необходимость операции запрос-ответ, несмотря на то что сигнатура операции возвращает `void`.  
  
```csharp  
[ServiceContractAttribute]  
public interface IMyContract  
{  
  [OperationContractAttribute]  
  public void PopulateData(ref CustomDataType data);  
}  
```  
  
 Ниже приведен эквивалентный код Visual Basic.  
  
```vb  
<ServiceContractAttribute()> _  
Public Interface IMyContract  
  <OperationContractAttribute()> _  
  Public Sub PopulateData(ByRef data As CustomDataType)  
End Interface  
```  
  
 Исключение составляют только те случаи, когда сигнатура имеет определенную структуру. Например, можно использовать привязку <xref:System.ServiceModel.NetMsmqBinding> для взаимодействия с клиентами, только если метод, использованный для объявления операции, возвращает `void`; может не быть выходного значения, является ли оно возвращаемым значением, параметром `ref` или `out`.  
  
 Помимо этого, использование параметров `out` или `ref` требует, чтобы у операции было базовое ответное сообщение для передачи обратно измененного объекта. Если операция является односторонней, во время выполнения создается исключение <xref:System.InvalidOperationException>.  
  
### <a name="specify-message-protection-level-on-the-contract"></a>Определение уровня защиты сообщений для контракта  
 При создании контракта необходимо также определить уровень защиты сообщений служб, реализующих этот контракт. Это необходимо, только если к привязке применена безопасность сообщений в конечной точке контракта. Если для привязки безопасность отключена (то есть, если привязка, предоставляемая системой, присваивает объекту <xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType> значение <xref:System.ServiceModel.SecurityMode.None?displayProperty=nameWithType>), то не нужно определять уровень безопасности сообщений для контракта. В большинстве случаев привязки, предоставляемые системой, с безопасностью на уровне сообщений предоставляют достаточный уровень защиты и нет необходимости рассматривать уровень защиты для каждой операции или для каждого сообщения.  
  
 Уровень защиты - это значение, которое определяет для сообщений (или частей сообщений), поддерживающих службу, подписываются ли они, подписываются и шифруются или отправляются без подписи и шифровки. Уровень защиты может быть задан в различных областях: на уровне службы, для конкретной операции, для сообщения операции или для части сообщения. Значения, заданные для более широкой области, становятся значениями по умолчанию для более узких областей, если не переопределить их явным образом. Если конфигурация привязки не может обеспечить минимальный необходимый уровень защиты для контракта, создается исключение. Если для контракта явно не задано значений уровня защиты, и если привязка имеет безопасность сообщений, уровнем защиты всех сообщений управляет конфигурация привязки. Это поведение установлено по умолчанию.  
  
> [!IMPORTANT]
> Решение явно задать для различных областей контракта уровень защиты меньше максимального <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> обычно является компромиссом между степенью защиты и улучшением производительности. В таких случаях решения должны опираться на вид операций и ценность передаваемых данных. Дополнительные сведения см. в разделе [Защита служб](securing-services.md).  
  
 Например, в следующем примере кода не задается ни свойство<xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A>, ни свойство <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> контракта.  
  
```csharp  
[ServiceContract]  
public interface ISampleService  
{  
  [OperationContractAttribute]  
  public string GetString();  
  
  [OperationContractAttribute]  
  public int GetInt();
}  
```  
  
 Ниже приведен эквивалентный код Visual Basic.  
  
```vb  
<ServiceContractAttribute()> _  
Public Interface ISampleService  
  
  <OperationContractAttribute()> _  
  Public Function GetString()As String  
  
  <OperationContractAttribute()> _  
  Public Function GetData() As Integer  
  
End Interface  
```  
  
 При взаимодействии с реализацией `ISampleService` в конечной точке с привязкой <xref:System.ServiceModel.WSHttpBinding> по умолчанию (<xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType> по умолчанию, то есть значение <xref:System.ServiceModel.SecurityMode.Message>), все сообщения зашифровываются и подписываются, так как это является уровнем защиты по умолчанию. Однако при использовании службы `ISampleService` с привязкой <xref:System.ServiceModel.BasicHttpBinding> по умолчанию (<xref:System.ServiceModel.SecurityMode> по умолчанию, то есть значение <xref:System.ServiceModel.SecurityMode.None>), все сообщения отправляются в текстовом виде, так как эта привязка не имеет безопасности и, следовательно, уровень защиты игнорируется (то есть сообщения не шифруются и не подписываются). Если изменить значение свойства <xref:System.ServiceModel.SecurityMode> на <xref:System.ServiceModel.SecurityMode.Message>, то сообщения будут зашифровываться и подписываться, так как теперь таков будет уровень защиты по умолчанию для привязки.  
  
 Если требуется явным образом задать или настроить требования по безопасности для контракта, задайте для свойства <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> (или для любого из свойств `ProtectionLevel` более узкой области) уровень, требуемый для контракта службы. В данном случае явная настройка требует, чтобы привязка поддерживала эту настройку по крайней мере для указанной области. Например, в следующем примере кода явно задается одно значение <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> для операции `GetGuid`.  
  
```csharp  
[ServiceContract]  
public interface IExplicitProtectionLevelSampleService  
{  
  [OperationContractAttribute]  
  public string GetString();  
  
  [OperationContractAttribute(ProtectionLevel=ProtectionLevel.None)]  
  public int GetInt();
  [OperationContractAttribute(ProtectionLevel=ProtectionLevel.EncryptAndSign)]  
  public int GetGuid();
}  
```  
  
 Ниже приведен эквивалентный код Visual Basic.  
  
```vb  
<ServiceContract()> _
Public Interface IExplicitProtectionLevelSampleService
    <OperationContract()> _
    Public Function GetString() As String
    End Function
  
    <OperationContract(ProtectionLevel := ProtectionLevel.None)> _
    Public Function GetInt() As Integer
    End Function
  
    <OperationContractAttribute(ProtectionLevel := ProtectionLevel.EncryptAndSign)> _
    Public Function GetGuid() As Integer
    End Function
  
End Interface  
```  
  
 Служба, реализующая этот контракт `IExplicitProtectionLevelSampleService` и имеющая конечную точку, где используется привязка <xref:System.ServiceModel.WSHttpBinding> по умолчанию (<xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType> по умолчанию, то есть значение <xref:System.ServiceModel.SecurityMode.Message>) ведет себя следующим образом:  
  
- Для операции `GetString` сообщения шифруются и подписываются.  
  
- Для операции `GetInt` сообщения не шифруются и не подписываются, то есть отправляются как простой текст.  
  
- `GetGuid` операции <xref:System.Guid?displayProperty=nameWithType> возвращается в зашифрованном подписанном сообщении.  
  
 Дополнительные сведения об уровнях защиты и их использовании см. в разделе [Основные сведения о уровне защиты](understanding-protection-level.md). Дополнительные сведения о безопасности см. в разделе [Защита служб](securing-services.md).  
  
##### <a name="other-operation-signature-requirements"></a>Другие требования к сигнатуре операции  
 Некоторые возможности приложения требуют определенного вида сигнатуры операции. Например, привязка <xref:System.ServiceModel.NetMsmqBinding> поддерживает устойчивые службы и клиенты, позволяющие перезапуск приложения при установленном подключении, при этом приложение продолжит работу с того места, где остановилось, и ни одно сообщение не будет потеряно. (Дополнительные сведения см. [в разделе очереди в WCF](./feature-details/queues-in-wcf.md).) Однако устойчивые операции должны принимать только один `in` параметр и не иметь возвращаемого значения.  
  
 Другой пример - использование типов <xref:System.IO.Stream> в операциях. Так как параметр <xref:System.IO.Stream> включает в себя тело сообщения целиком, если входные или выходные данные (то есть параметр `ref`, параметр `out` или возвращаемое значение) принадлежат типу <xref:System.IO.Stream>, это должны быть единственные входные и выходные данные, заданные для операции. Кроме того, параметр или тип возвращаемого значения должны являться объектами <xref:System.IO.Stream>, <xref:System.ServiceModel.Channels.Message?displayProperty=nameWithType> или <xref:System.Xml.Serialization.IXmlSerializable?displayProperty=nameWithType>. Дополнительные сведения о потоках см. в разделе [большие данные и потоковая передача](./feature-details/large-data-and-streaming.md).  
  
##### <a name="names-namespaces-and-obfuscation"></a>Имена, пространства имен и запутывание  
 Имена и пространства имен типов .NET в определениях контрактов и операций важны при преобразовании контрактов в WSDL и при создании и отправке сообщений контрактов. Поэтому рекомендуется явно задавать имена и пространства имен контракта службы с помощью свойств `Name` и `Namespace` всех поддерживающих атрибутов контракта, например <xref:System.ServiceModel.ServiceContractAttribute>, <xref:System.ServiceModel.OperationContractAttribute>, <xref:System.Runtime.Serialization.DataContractAttribute>, <xref:System.Runtime.Serialization.DataMemberAttribute> и других атрибутов контракта.  
  
 Одним из следствий этого является то, что если имена и пространства имен не заданы явно, применение обфускации IL для сборки изменяет имена типов и пространства имен контракта, что приводит к измененному коду WSDL и обмену сообщениями, который обычно завершается ошибкой. Если вы не задаете явно имена и пространства имен контракта, но планируете использовать обфускацию, используйте атрибуты <xref:System.Reflection.ObfuscationAttribute> и <xref:System.Reflection.ObfuscateAssemblyAttribute>, чтобы предотвратить изменение имен и пространств имен контракта.  
  
## <a name="see-also"></a>См. также

- [Практическое руководство. Создание контракта типа "запрос — ответ"](./feature-details/how-to-create-a-request-reply-contract.md)
- [Практическое руководство. Создание одностороннего контракта](./feature-details/how-to-create-a-one-way-contract.md)
- [Практическое руководство. Создание двухстороннего контракта](./feature-details/how-to-create-a-duplex-contract.md)
- [Задание передачи данных в контрактах служб](./feature-details/specifying-data-transfer-in-service-contracts.md)
- [Задание и обработка сбоев в контрактах и службах](specifying-and-handling-faults-in-contracts-and-services.md)
- [Использование сеансов](using-sessions.md)
- [Синхронные и асинхронные операции](synchronous-and-asynchronous-operations.md)
- [Надежные службы](reliable-services.md)
- [Службы и транзакции](services-and-transactions.md)
