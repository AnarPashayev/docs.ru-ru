---
title: Управление версиями службы
ms.date: 03/30/2017
ms.assetid: 37575ead-d820-4a67-8059-da11a2ab48e2
ms.openlocfilehash: 3f9fd87eacf67a1b23568dcf87df086e935879ba
ms.sourcegitcommit: 14ad34f7c4564ee0f009acb8bfc0ea7af3bc9541
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/01/2019
ms.locfileid: "73423685"
---
# <a name="service-versioning"></a><span data-ttu-id="55d61-102">Управление версиями службы</span><span class="sxs-lookup"><span data-stu-id="55d61-102">Service Versioning</span></span>
<span data-ttu-id="55d61-103">После первоначального развертывания служб и, возможно, несколько раз на протяжении времени их существования возникает потребность в изменении этих служб (и предоставляемых ими конечных точек). Причин тому немало: изменяющиеся потребности бизнеса, требования информационных технологий или необходимость решить какие-либо другие проблемы.</span><span class="sxs-lookup"><span data-stu-id="55d61-103">After initial deployment, and potentially several times during their lifetime, services (and the endpoints they expose) may need to be changed for a variety of reasons, such as changing business needs, information technology requirements, or to address other issues.</span></span> <span data-ttu-id="55d61-104">В результате каждого изменения создается новая версия службы.</span><span class="sxs-lookup"><span data-stu-id="55d61-104">Each change introduces a new version of the service.</span></span> <span data-ttu-id="55d61-105">В этом разделе объясняется, как рассмотреть управление версиями в Windows Communication Foundation (WCF).</span><span class="sxs-lookup"><span data-stu-id="55d61-105">This topic explains how to consider versioning in Windows Communication Foundation (WCF).</span></span>  
  
## <a name="four-categories-of-service-changes"></a><span data-ttu-id="55d61-106">Четыре категории изменений службы</span><span class="sxs-lookup"><span data-stu-id="55d61-106">Four Categories of Service Changes</span></span>  
 <span data-ttu-id="55d61-107">Все изменения, которые может потребоваться внести в службы, можно разделить на четыре категории:</span><span class="sxs-lookup"><span data-stu-id="55d61-107">The changes to services that may be required can be classified into four categories:</span></span>  
  
- <span data-ttu-id="55d61-108">Изменения контракта: например, можно добавить операцию, добавить или изменить элемент данных в сообщении.</span><span class="sxs-lookup"><span data-stu-id="55d61-108">Contract changes: For example, an operation might be added, or a data element in a message might be added or changed.</span></span>  
  
- <span data-ttu-id="55d61-109">Изменения адреса: например, служба меняет местоположение так, что конечные точки получают новые адреса.</span><span class="sxs-lookup"><span data-stu-id="55d61-109">Address changes: For example, a service moves to a different location where endpoints have new addresses.</span></span>  
  
- <span data-ttu-id="55d61-110">Изменения привязки: например, изменяется механизм безопасности или его параметры.</span><span class="sxs-lookup"><span data-stu-id="55d61-110">Binding changes: For example, a security mechanism changes or its settings change.</span></span>  
  
- <span data-ttu-id="55d61-111">Изменения реализации: например, изменяется внутренняя реализация метода.</span><span class="sxs-lookup"><span data-stu-id="55d61-111">Implementation changes: For example, when an internal method implementation changes.</span></span>  
  
 <span data-ttu-id="55d61-112">Некоторые из этих изменений называются критическими, другие - некритическими.</span><span class="sxs-lookup"><span data-stu-id="55d61-112">Some of these changes are called "breaking" and others are "nonbreaking."</span></span> <span data-ttu-id="55d61-113">Изменение не *нарушается* , если все сообщения, которые были успешно обработаны в предыдущей версии, успешно обработаны в новой версии.</span><span class="sxs-lookup"><span data-stu-id="55d61-113">A change is *nonbreaking* if all messages that would have been processed successfully in the previous version are processed successfully in the new version.</span></span> <span data-ttu-id="55d61-114">Любое изменение, которое не соответствует этому критерию, является *критическим* изменением.</span><span class="sxs-lookup"><span data-stu-id="55d61-114">Any change that does not meet that criterion is a *breaking* change.</span></span>  
  
## <a name="service-orientation-and-versioning"></a><span data-ttu-id="55d61-115">Ориентация службы и управление версиями</span><span class="sxs-lookup"><span data-stu-id="55d61-115">Service Orientation and Versioning</span></span>  
 <span data-ttu-id="55d61-116">Одним из принципов ориентации службы является автономность (или независимость) служб и клиентов.</span><span class="sxs-lookup"><span data-stu-id="55d61-116">One of the tenets of service orientation is that services and clients are autonomous (or independent).</span></span> <span data-ttu-id="55d61-117">Кроме всего прочего, из-за этого разработчики службы не имеют оснований предполагать, что они управляют всеми клиентами службы или хотя бы знают о существовании всех клиентов.</span><span class="sxs-lookup"><span data-stu-id="55d61-117">Among other things, this implies that service developers cannot assume that they control or even know about all service clients.</span></span> <span data-ttu-id="55d61-118">Это делает невозможным повторное создание и развертывание всех клиентов при изменении версии службы.</span><span class="sxs-lookup"><span data-stu-id="55d61-118">This eliminates the option of rebuilding and redeploying all clients when a service changes versions.</span></span> <span data-ttu-id="55d61-119">Материал данного раздела предполагает, что служба соответствует этому принципу и, следовательно, должна быть изменена (или создана новая версия) независимо от клиентов.</span><span class="sxs-lookup"><span data-stu-id="55d61-119">This topic assumes the service adheres to this tenet and therefore must be changed or "versioned" independent of its clients.</span></span>  
  
 <span data-ttu-id="55d61-120">Если потребность в критическом изменении возникает неожиданно и ее невозможно устранить, может быть принято решение о пропуске этого принципа приложением, которое, кроме того, потребует повторного создания и развертывания клиентов вместе с новой версией службы.</span><span class="sxs-lookup"><span data-stu-id="55d61-120">In cases where a breaking change is unexpected and cannot be avoided, an application may choose to ignore this tenet and require that clients be rebuilt and redeployed with a new version of the service.</span></span>  
  
## <a name="contract-versioning"></a><span data-ttu-id="55d61-121">Управление версиями контракта</span><span class="sxs-lookup"><span data-stu-id="55d61-121">Contract Versioning</span></span>  
 <span data-ttu-id="55d61-122">Клиент и служба не обязательно должны использовать один и тот же контракт; достаточно, чтобы контракты были совместимы.</span><span class="sxs-lookup"><span data-stu-id="55d61-122">Contracts used by a client do not need to be the same as the contract used by the service; they need only to be compatible.</span></span>  
  
 <span data-ttu-id="55d61-123">Для контрактов службы совместимость предполагает возможность добавления новых операций, предоставленных службой, и невозможность удаления или семантического изменения существующих операций.</span><span class="sxs-lookup"><span data-stu-id="55d61-123">For service contracts, compatibility means new operations exposed by the service can be added but existing operations cannot be removed or changed semantically.</span></span>  
  
 <span data-ttu-id="55d61-124">Для контрактов данных совместимость предполагает возможность добавления новых определений типов схем и невозможность внесения критических изменений в существующие определения типов схем.</span><span class="sxs-lookup"><span data-stu-id="55d61-124">For data contracts, compatibility means new schema type definitions can be added but existing schema type definitions cannot be changed in breaking ways.</span></span> <span data-ttu-id="55d61-125">К критическим изменениям может относиться удаление членов данных или несовместимое изменение типов данных этих членов.</span><span class="sxs-lookup"><span data-stu-id="55d61-125">Breaking changes might include removing data members or changing their data type incompatibly.</span></span> <span data-ttu-id="55d61-126">Эта возможность предоставляет службе определенную свободу при изменении версии контрактов, позволяя не нарушать работу клиентов.</span><span class="sxs-lookup"><span data-stu-id="55d61-126">This feature allows the service some latitude in changing the version of its contracts without breaking clients.</span></span> <span data-ttu-id="55d61-127">В следующих двух разделах объясняются неразрывы и критические изменения, которые можно внести в контракты данных и служб WCF.</span><span class="sxs-lookup"><span data-stu-id="55d61-127">The next two sections explain nonbreaking and breaking changes that can be made to WCF data and service contracts.</span></span>  
  
## <a name="data-contract-versioning"></a><span data-ttu-id="55d61-128">Управление версиями контракта данных</span><span class="sxs-lookup"><span data-stu-id="55d61-128">Data Contract Versioning</span></span>  
 <span data-ttu-id="55d61-129">В этом разделе описывается управление версиями данных при использовании классов <xref:System.Runtime.Serialization.DataContractSerializer> и <xref:System.Runtime.Serialization.DataContractAttribute>.</span><span class="sxs-lookup"><span data-stu-id="55d61-129">This section deals with data versioning when using the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.DataContractAttribute> classes.</span></span>  
  
### <a name="strict-versioning"></a><span data-ttu-id="55d61-130">Строгое управление версиями</span><span class="sxs-lookup"><span data-stu-id="55d61-130">Strict Versioning</span></span>  
 <span data-ttu-id="55d61-131">Во многих сценариях, если изменение версий сопряжено с какими-либо проблемами, разработчик службы не имеет возможности управлять клиентами и поэтому не может делать предположения о том, как они отреагируют на изменения в сообщении XML или схеме.</span><span class="sxs-lookup"><span data-stu-id="55d61-131">In many scenarios when changing versions is an issue, the service developer does not have control over the clients and therefore cannot make assumptions about how they would react to changes in the message XML or schema.</span></span> <span data-ttu-id="55d61-132">В этих случаях необходимо гарантировать прохождение новыми сообщениями проверки на соответствие старой схеме по двум причинам.</span><span class="sxs-lookup"><span data-stu-id="55d61-132">In these cases, you must guarantee that the new messages will validate against the old schema, for two reasons:</span></span>  
  
- <span data-ttu-id="55d61-133">Старые клиенты разработаны в предположении, что схема не изменится.</span><span class="sxs-lookup"><span data-stu-id="55d61-133">The old clients were developed with the assumption that the schema will not change.</span></span> <span data-ttu-id="55d61-134">Поэтому возможно, эти клиенты не смогут обработать сообщения, для работы с которыми они не были предназначены.</span><span class="sxs-lookup"><span data-stu-id="55d61-134">They may fail to process messages that they were never designed for.</span></span>  
  
- <span data-ttu-id="55d61-135">В действительности, старые клиенты могут выполнить проверку схемы на соответствие старой схеме еще до того, как будет предпринята попытка обработать сообщения.</span><span class="sxs-lookup"><span data-stu-id="55d61-135">The old clients may perform actual schema validation against the old schema before even attempting to process the messages.</span></span>  
  
 <span data-ttu-id="55d61-136">В таких случаях рекомендуется обрабатывать существующие контракты данных как неизменяемые и создавать новые контракты с уникальными полными именами XML.</span><span class="sxs-lookup"><span data-stu-id="55d61-136">The recommended approach in such scenarios is to treat existing data contracts as immutable and create new ones with unique XML qualified names.</span></span> <span data-ttu-id="55d61-137">Затем разработчик службы либо добавляет в существующий контракт службы новые методы, либо создает новый контракт службы с методами, которые используют новый контракт данных.</span><span class="sxs-lookup"><span data-stu-id="55d61-137">The service developer would then either add new methods to an existing service contract or create a new service contract with methods that use the new data contract.</span></span>  
  
 <span data-ttu-id="55d61-138">Очень часто разработчику службы необходимо создать определенную бизнес-логику, которая должна выполняться во всех версиях контракта данных, а также индивидуальный бизнес-код для каждой версии контракта данных.</span><span class="sxs-lookup"><span data-stu-id="55d61-138">It will often be the case that a service developer needs to write some business logic that should run within all versions of a data contract plus version-specific business code for each version of the data contract.</span></span> <span data-ttu-id="55d61-139">В приложении в конце этого раздела объясняется, как с этой целью можно использовать интерфейсы.</span><span class="sxs-lookup"><span data-stu-id="55d61-139">The appendix at the end of this topic explains how interfaces can be used to satisfy this need.</span></span>  
  
### <a name="lax-versioning"></a><span data-ttu-id="55d61-140">Нестрогое управление версиями</span><span class="sxs-lookup"><span data-stu-id="55d61-140">Lax Versioning</span></span>  
 <span data-ttu-id="55d61-141">Во многих других сценариях разработчик службы может предположить, что добавление в контракт данных нового дополнительного члена не нарушит работу существующих клиентов.</span><span class="sxs-lookup"><span data-stu-id="55d61-141">In many other scenarios, the service developer can make the assumption that adding a new, optional member to the data contract will not break existing clients.</span></span> <span data-ttu-id="55d61-142">В этом случае разработчику службы необходимо выяснить, проходят ли существующие клиенты проверку схемы и игнорируют ли они неизвестные члены данных.</span><span class="sxs-lookup"><span data-stu-id="55d61-142">This requires the service developer to investigate whether existing clients are not performing schema validation and that they ignore unknown data members.</span></span> <span data-ttu-id="55d61-143">В таких сценариях во избежание внесения критических изменений для добавления новых членов можно воспользоваться функциями контракта данных.</span><span class="sxs-lookup"><span data-stu-id="55d61-143">In these scenarios, it is possible to take advantage of data contract features for adding new members in a nonbreaking way.</span></span> <span data-ttu-id="55d61-144">Если возможности контракта данных для управления версиями уже использовались для создания первой версии службы, разработчик службы не может с уверенностью делать подобные предположения.</span><span class="sxs-lookup"><span data-stu-id="55d61-144">The service developer can make this assumption with confidence if the data contract features for versioning were already used for the first version of the service.</span></span>  
  
 <span data-ttu-id="55d61-145">WCF, веб-службы ASP.NET и многие другие стеки веб-служб поддерживают *слабое управление версиями*: то есть они не создают исключения для новых неизвестных элементов данных в полученных данных.</span><span class="sxs-lookup"><span data-stu-id="55d61-145">WCF, ASP.NET Web Services, and many other Web service stacks support *lax versioning*: that is, they do not throw exceptions for new unknown data members in received data.</span></span>  
  
 <span data-ttu-id="55d61-146">Очень легко может возникнуть ошибочное предположение, что добавление нового члена не нарушит работу существующих клиентов.</span><span class="sxs-lookup"><span data-stu-id="55d61-146">It is easy to mistakenly believe that adding a new member will not break existing clients.</span></span> <span data-ttu-id="55d61-147">Если есть сомнения, могут ли все клиенты бесперебойно функционировать в условиях нестрогого управления версиями, рекомендуется руководствоваться принципами строгого управления версиями и обрабатывать контракты данных как неизменяемые.</span><span class="sxs-lookup"><span data-stu-id="55d61-147">If you are unsure that all clients can handle lax versioning, the recommendation is to use the strict versioning guidelines and treat data contracts as immutable.</span></span>  
  
 <span data-ttu-id="55d61-148">Подробные инструкции по обеспечению слабых и строгих версий контрактов данных см. в разделе рекомендации по [управлению версиями контракта данных](best-practices-data-contract-versioning.md).</span><span class="sxs-lookup"><span data-stu-id="55d61-148">For detailed guidelines for both lax and strict versioning of data contracts, see [Best Practices: Data Contract Versioning](best-practices-data-contract-versioning.md).</span></span>  
  
### <a name="distinguishing-between-data-contract-and-net-types"></a><span data-ttu-id="55d61-149">Отличия контракта данных от типов .Net.</span><span class="sxs-lookup"><span data-stu-id="55d61-149">Distinguishing Between Data Contract and .NET Types</span></span>  
 <span data-ttu-id="55d61-150">Структура или класс .Net может проецироваться как контракт данных применением атрибута <xref:System.Runtime.Serialization.DataContractAttribute> к классу.</span><span class="sxs-lookup"><span data-stu-id="55d61-150">A .NET class or structure can be projected as a data contract by applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to the class.</span></span> <span data-ttu-id="55d61-151">Не следует путать тип .NET и проекции его контракта данных.</span><span class="sxs-lookup"><span data-stu-id="55d61-151">The .NET type and its data contract projections are two distinct matters.</span></span> <span data-ttu-id="55d61-152">Несколько типов .NET могут иметь одну и ту же проекцию контракта данных.</span><span class="sxs-lookup"><span data-stu-id="55d61-152">It is possible to have multiple .NET types with the same data contract projection.</span></span> <span data-ttu-id="55d61-153">Это различие особенно полезно, так как позволяет изменять тип .NET и при этом сохранять проецированный контракт данных, тем самым обеспечивая совместимость с существующими клиентами даже в строгом смысле слова.</span><span class="sxs-lookup"><span data-stu-id="55d61-153">This distinction is especially useful in allowing you to change the .NET type while maintaining the projected data contract, thereby maintaining compatibility with existing clients even in the strict sense of the word.</span></span> <span data-ttu-id="55d61-154">Поддержание вышеупомянутого различия между типом .NET и контрактом данных обеспечивается выполнением следующих действий.</span><span class="sxs-lookup"><span data-stu-id="55d61-154">There are two things you should always do to maintain this distinction between .NET type and data contract:</span></span>  
  
- <span data-ttu-id="55d61-155">Задайте имя <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> и пространство имен <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>.</span><span class="sxs-lookup"><span data-stu-id="55d61-155">Specify a <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> and <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>.</span></span> <span data-ttu-id="55d61-156">Следует всегда задавать имя и пространство имен контракта данных во избежание непреднамеренного раскрытия имени и пространства имен типа .NET в контракте.</span><span class="sxs-lookup"><span data-stu-id="55d61-156">You should always specify the name and namespace of your data contract to prevent your .NET type’s name and namespace from being exposed in the contract.</span></span> <span data-ttu-id="55d61-157">В этом случае даже если впоследствии будет принято решение об изменении пространства имен .NET или имени типа, контракт данных останется неизменным.</span><span class="sxs-lookup"><span data-stu-id="55d61-157">This way, if you decide later to change the .NET namespace or type name, your data contract remains the same.</span></span>  
  
- <span data-ttu-id="55d61-158">Задайте имя <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>.</span><span class="sxs-lookup"><span data-stu-id="55d61-158">Specify <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>.</span></span> <span data-ttu-id="55d61-159">Следует всегда задавать имена членов данных во избежание непреднамеренного раскрытия имени члена .NET в контракте.</span><span class="sxs-lookup"><span data-stu-id="55d61-159">You should always specify the name of your data members to prevent your .NET member name from being exposed in the contract.</span></span> <span data-ttu-id="55d61-160">В этом случае даже если впоследствии будет принято решение об изменении имени члена .NET, контракт данных останется неизменным.</span><span class="sxs-lookup"><span data-stu-id="55d61-160">This way, if you decide later to change the .NET name of the member, your data contract remains the same.</span></span>  
  
### <a name="changing-or-removing-members"></a><span data-ttu-id="55d61-161">Изменение или удаление членов</span><span class="sxs-lookup"><span data-stu-id="55d61-161">Changing or Removing Members</span></span>  
 <span data-ttu-id="55d61-162">Изменение имени или типа элемента данных или удаление элементов данных является критичным изменением, даже если разрешено нестрогое управление версиями.</span><span class="sxs-lookup"><span data-stu-id="55d61-162">Changing the name or data type of a member, or removing data members is a breaking change even if lax versioning is allowed.</span></span> <span data-ttu-id="55d61-163">Если в этом есть необходимость, создайте новый контракт данных.</span><span class="sxs-lookup"><span data-stu-id="55d61-163">If this is necessary, create a new data contract.</span></span>  
  
 <span data-ttu-id="55d61-164">Если совместимость со службой чрезвычайно важна, следует рассмотреть возможность игнорирования неиспользованных членов данных в коде и оставить их на месте.</span><span class="sxs-lookup"><span data-stu-id="55d61-164">If service compatibility is of high importance, you might consider ignoring unused data members in your code and leave them in place.</span></span> <span data-ttu-id="55d61-165">При разделении члена данных на несколько членов можно оставить на месте существующий член и использовать его в качестве свойства, которое может выполнить необходимое разделение и повторное агрегирование для клиентов предыдущих версий (не обновленных до последней версии).</span><span class="sxs-lookup"><span data-stu-id="55d61-165">If you are splitting up a data member into multiple members, you might consider leaving the existing member in place as a property that can perform the required splitting and re-aggregation for down-level clients (clients that are not upgraded to the latest version).</span></span>  
  
 <span data-ttu-id="55d61-166">Аналогично, изменение имени или пространства имен контракта данных считается критическим изменением.</span><span class="sxs-lookup"><span data-stu-id="55d61-166">Similarly, changes to the data contract’s name or namespace are breaking changes.</span></span>  
  
### <a name="round-trips-of-unknown-data"></a><span data-ttu-id="55d61-167">Полная совместимость версий неизвестных данных</span><span class="sxs-lookup"><span data-stu-id="55d61-167">Round-Trips of Unknown Data</span></span>  
 <span data-ttu-id="55d61-168">В некоторых сценариях возникает необходимость в обеспечении полной совместимости версий неизвестных данных, которые поступают от добавленных в новую версию членов.</span><span class="sxs-lookup"><span data-stu-id="55d61-168">In some scenarios, there is a need to "round-trip" unknown data that comes from members added in a new version.</span></span> <span data-ttu-id="55d61-169">Например, служба новой версии отправляет клиенту старой версии данные с несколькими добавленными членами.</span><span class="sxs-lookup"><span data-stu-id="55d61-169">For example, a "versionNew" service sends data with some newly added members to a "versionOld" client.</span></span> <span data-ttu-id="55d61-170">При обработке сообщения клиент игнорирует добавленные члены, но при этом повторно отправляет службе новой версии те же данные, включая добавленные члены.</span><span class="sxs-lookup"><span data-stu-id="55d61-170">The client ignores the newly added members when processing the message, but it resends that same data, including the newly added members, back to the versionNew service.</span></span> <span data-ttu-id="55d61-171">В таких сценариях, как правило, обновление данных происходит при извлечении данных из службы, их изменении и возвращении.</span><span class="sxs-lookup"><span data-stu-id="55d61-171">The typical scenario for this is data updates where data is retrieved from the service, changed, and returned.</span></span>  
  
 <span data-ttu-id="55d61-172">Полная совместимость версий для определенного типа возможна только в том случае, если этот тип реализует интерфейс <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span><span class="sxs-lookup"><span data-stu-id="55d61-172">To enable round-tripping for a particular type, the type must implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="55d61-173">Интерфейс имеет одно свойство <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A>, которое возвращает тип <xref:System.Runtime.Serialization.ExtensionDataObject>.</span><span class="sxs-lookup"><span data-stu-id="55d61-173">The interface contains one property, <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> that returns the <xref:System.Runtime.Serialization.ExtensionDataObject> type.</span></span> <span data-ttu-id="55d61-174">Это свойство используется для сохранения любых данных из будущих версий контракта данных, не известных текущей версии.</span><span class="sxs-lookup"><span data-stu-id="55d61-174">The property is used to store any data from future versions of the data contract that is unknown to the current version.</span></span> <span data-ttu-id="55d61-175">Эти данные непрозрачны для клиента, но при сериализации экземпляра содержимое свойства <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> записывается вместе с другими данными членов контракта данных.</span><span class="sxs-lookup"><span data-stu-id="55d61-175">This data is opaque to the client, but when the instance is serialized, the content of the <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> property is written with the rest of the data contract members' data.</span></span>  
  
 <span data-ttu-id="55d61-176">Для обеспечения поддержки новых и неизвестных будущих членов необходимо, чтобы все типы реализовывали этот интерфейс.</span><span class="sxs-lookup"><span data-stu-id="55d61-176">It is recommended that all your types implement this interface to accommodate new and unknown future members.</span></span>  
  
### <a name="data-contract-libraries"></a><span data-ttu-id="55d61-177">Библиотеки контрактов данных</span><span class="sxs-lookup"><span data-stu-id="55d61-177">Data Contract Libraries</span></span>  
 <span data-ttu-id="55d61-178">Могут существовать библиотеки контрактов данных, в которых контракт публикуется в центральном репозитории, а средства реализации службы и типа реализуют и предоставляют контракты данных из этого репозитория.</span><span class="sxs-lookup"><span data-stu-id="55d61-178">There may be libraries of data contracts where a contract is published to a central repository, and service and type implementers implement and expose data contracts from that repository.</span></span> <span data-ttu-id="55d61-179">В этом случае при публикации контракта данных в репозитории невозможно управлять создателями типов, которые реализуют контракт.</span><span class="sxs-lookup"><span data-stu-id="55d61-179">In that case, when you publish a data contract to the repository, you have no control over who creates types that implement it.</span></span> <span data-ttu-id="55d61-180">Следовательно, отсутствует возможность изменения контракта после его публикации, что делает контракт фактически неизменяемым.</span><span class="sxs-lookup"><span data-stu-id="55d61-180">Thus, you cannot modify the contract once it is published, rendering it effectively immutable.</span></span>  
  
### <a name="when-using-the-xmlserializer"></a><span data-ttu-id="55d61-181">При использовании класса XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="55d61-181">When Using the XmlSerializer</span></span>  
 <span data-ttu-id="55d61-182">При использовании класса <xref:System.Xml.Serialization.XmlSerializer> действуют те же принципы управления версиями.</span><span class="sxs-lookup"><span data-stu-id="55d61-182">The same versioning principles apply when using the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="55d61-183">Если существует потребность в строгом управлении версиями, контракты данных рекомендуется обрабатывать как неизменяемые и создавать для новых версий новые контракты данных с уникальными полными именами.</span><span class="sxs-lookup"><span data-stu-id="55d61-183">When strict versioning is required, treat data contracts as immutable and create new data contracts with unique, qualified names for the new versions.</span></span> <span data-ttu-id="55d61-184">Если есть уверенность, что можно использовать нестрогое управление версиями, можно добавлять в новые версии новые сериализуемые члены, однако изменять или удалять существующие члены нельзя.</span><span class="sxs-lookup"><span data-stu-id="55d61-184">When you are sure that lax versioning can be used, you can add new serializable members in new versions but not change or remove existing members.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="55d61-185">Для поддержки полной совместимости версий неизвестных данных класс <xref:System.Xml.Serialization.XmlSerializer> использует атрибуты <xref:System.Xml.Serialization.XmlAnyElementAttribute> и <xref:System.Xml.Serialization.XmlAnyAttributeAttribute></span><span class="sxs-lookup"><span data-stu-id="55d61-185">The <xref:System.Xml.Serialization.XmlSerializer> uses the <xref:System.Xml.Serialization.XmlAnyElementAttribute> and <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> attributes to support round-tripping of unknown data.</span></span>  
  
## <a name="message-contract-versioning"></a><span data-ttu-id="55d61-186">Управление версиями контракта сообщения</span><span class="sxs-lookup"><span data-stu-id="55d61-186">Message Contract Versioning</span></span>  
 <span data-ttu-id="55d61-187">Управление версиями контракта сообщения весьма подобно управлению версиями контрактов данных.</span><span class="sxs-lookup"><span data-stu-id="55d61-187">The guidelines for message contract versioning are very similar to versioning data contracts.</span></span> <span data-ttu-id="55d61-188">При необходимости строгого управления версиями вместо изменения тела сообщения следует создать новый контракт сообщения с уникальным полным именем.</span><span class="sxs-lookup"><span data-stu-id="55d61-188">If strict versioning is required, you should not change your message body but instead create a new message contract with a unique qualified name.</span></span> <span data-ttu-id="55d61-189">Если известно, что возможно нестрогое управление версиями, можно добавить в тело сообщения новые части, но при этом нельзя изменить или удалить существующие.</span><span class="sxs-lookup"><span data-stu-id="55d61-189">If you know that you can use lax versioning, you can add new message body parts but not change or remove existing ones.</span></span> <span data-ttu-id="55d61-190">Это правило справедливо и для контрактов сообщения в режиме "bare", и для контрактов в программе-оболочке.</span><span class="sxs-lookup"><span data-stu-id="55d61-190">This guidance applies both to bare and wrapped message contracts.</span></span>  
  
 <span data-ttu-id="55d61-191">Всегда (даже при строгом управлении версиями) можно добавлять заголовки сообщения.</span><span class="sxs-lookup"><span data-stu-id="55d61-191">Message headers can always be added, even if strict versioning is in use.</span></span> <span data-ttu-id="55d61-192">Флаг MustUnderstand может повлиять на управление версиями.</span><span class="sxs-lookup"><span data-stu-id="55d61-192">The MustUnderstand flag may affect versioning.</span></span> <span data-ttu-id="55d61-193">Как правило, модель управления версиями для заголовков в WCF описана в спецификации SOAP.</span><span class="sxs-lookup"><span data-stu-id="55d61-193">In general, the versioning model for headers in WCF is as described in the SOAP specification.</span></span>  
  
## <a name="service-contract-versioning"></a><span data-ttu-id="55d61-194">Управление версиями контракта службы</span><span class="sxs-lookup"><span data-stu-id="55d61-194">Service Contract Versioning</span></span>  
 <span data-ttu-id="55d61-195">Так же, как и управление версиями контракта данных, управление версиями контракта службы предполагает добавление, изменение и удаление операций.</span><span class="sxs-lookup"><span data-stu-id="55d61-195">Similar to data contract versioning, service contract versioning also involves adding, changing, and removing operations.</span></span>  
  
### <a name="specifying-name-namespace-and-action"></a><span data-ttu-id="55d61-196">Задание имени, пространства имен и макрокоманды</span><span class="sxs-lookup"><span data-stu-id="55d61-196">Specifying Name, Namespace, and Action</span></span>  
 <span data-ttu-id="55d61-197">По умолчанию именем контракта службы является имя интерфейса.</span><span class="sxs-lookup"><span data-stu-id="55d61-197">By default, the name of a service contract is the name of the interface.</span></span> <span data-ttu-id="55d61-198">Его пространство имен по умолчанию — "http://tempuri.org", а действие каждой операции — "http://tempuri.org/contractname/methodname".</span><span class="sxs-lookup"><span data-stu-id="55d61-198">Its default namespace is "http://tempuri.org", and each operation’s action is "http://tempuri.org/contractname/methodname".</span></span> <span data-ttu-id="55d61-199">Рекомендуется явно указывать имя и пространство имен для контракта службы и действие для каждой операции, чтобы избежать использования "http://tempuri.org" и предотвращения предоставления имен интерфейсов и методов в контракте службы.</span><span class="sxs-lookup"><span data-stu-id="55d61-199">It is recommended that you explicitly specify a name and namespace for the service contract, and an action for each operation to avoid using "http://tempuri.org" and to prevent interface and method names from being exposed in the service’s contract.</span></span>  
  
### <a name="adding-parameters-and-operations"></a><span data-ttu-id="55d61-200">Добавление параметров и операций</span><span class="sxs-lookup"><span data-stu-id="55d61-200">Adding Parameters and Operations</span></span>  
 <span data-ttu-id="55d61-201">Добавление предоставленных службой операций является некритическим изменением, так как эти новые операции никак не влияют на работу существующих каналов.</span><span class="sxs-lookup"><span data-stu-id="55d61-201">Adding service operations exposed by the service is a nonbreaking change because existing clients need not be concerned about those new operations.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="55d61-202">Добавление операций в дуплексный контракт обратного вызова является критическим изменением.</span><span class="sxs-lookup"><span data-stu-id="55d61-202">Adding operations to a duplex callback contract is a breaking change.</span></span>  
  
### <a name="changing-operation-parameter-or-return-types"></a><span data-ttu-id="55d61-203">Изменение параметра операции или возвращаемых типов</span><span class="sxs-lookup"><span data-stu-id="55d61-203">Changing Operation Parameter or Return Types</span></span>  
 <span data-ttu-id="55d61-204">Как правило, изменение параметра или возвращаемых типов является критическим изменением, если новый тип не реализует тот же контракт данных, что и старый тип.</span><span class="sxs-lookup"><span data-stu-id="55d61-204">Changing parameter or return types generally is a breaking change unless the new type implements the same data contract implemented by the old type.</span></span> <span data-ttu-id="55d61-205">Для внесения этого изменения необходимо добавить в контракт службы новую операцию или определить новый контракт службы.</span><span class="sxs-lookup"><span data-stu-id="55d61-205">To make such a change, add a new operation to the service contract or define a new service contract.</span></span>  
  
### <a name="removing-operations"></a><span data-ttu-id="55d61-206">Удаление операций</span><span class="sxs-lookup"><span data-stu-id="55d61-206">Removing Operations</span></span>  
 <span data-ttu-id="55d61-207">Удаление операций также является критическим изменением.</span><span class="sxs-lookup"><span data-stu-id="55d61-207">Removing operations is also a breaking change.</span></span> <span data-ttu-id="55d61-208">Для внесения этого изменения необходимо определить новый контракт службы и отобразить его в новой конечной точке.</span><span class="sxs-lookup"><span data-stu-id="55d61-208">To make such a change, define a new service contract and expose it on a new endpoint.</span></span>  
  
### <a name="fault-contracts"></a><span data-ttu-id="55d61-209">Контракты сбоя</span><span class="sxs-lookup"><span data-stu-id="55d61-209">Fault Contracts</span></span>  
 <span data-ttu-id="55d61-210">Атрибут <xref:System.ServiceModel.FaultContractAttribute> позволяет разработчику контракта службы указывать сведения о сбоях, которые могут быть возвращены из операций контракта.</span><span class="sxs-lookup"><span data-stu-id="55d61-210">The <xref:System.ServiceModel.FaultContractAttribute> attribute enables a service contract developer to specify information about faults that can be returned from the contract's operations.</span></span>  
  
 <span data-ttu-id="55d61-211">Список сбоев, описанных в контракте службы, не является исчерпывающим.</span><span class="sxs-lookup"><span data-stu-id="55d61-211">The list of faults described in a service's contract is not considered exhaustive.</span></span> <span data-ttu-id="55d61-212">В любой момент операция может вернуть сбои, не описанные в ее контракте.</span><span class="sxs-lookup"><span data-stu-id="55d61-212">At any time, an operation may return faults that are not described in its contract.</span></span> <span data-ttu-id="55d61-213">Поэтому изменение набора сбоев, описанных в контракте, не считается критическим изменением.</span><span class="sxs-lookup"><span data-stu-id="55d61-213">Therefore changing the set of faults described in the contract is not considered breaking.</span></span> <span data-ttu-id="55d61-214">В качестве примера можно привести добавление в контракт нового сбоя с помощью атрибута <xref:System.ServiceModel.FaultContractAttribute> или удаление из контракта существующего сбоя.</span><span class="sxs-lookup"><span data-stu-id="55d61-214">For example, adding a new fault to the contract using the <xref:System.ServiceModel.FaultContractAttribute> or removing an existing fault from the contract.</span></span>  
  
### <a name="service-contract-libraries"></a><span data-ttu-id="55d61-215">Библиотеки контрактов службы</span><span class="sxs-lookup"><span data-stu-id="55d61-215">Service Contract Libraries</span></span>  
 <span data-ttu-id="55d61-216">Организации могут иметь библиотеки контрактов, в которых контракт публикуется в центральном репозитории, а средства реализации службы реализуют контракты из этого репозитория.</span><span class="sxs-lookup"><span data-stu-id="55d61-216">Organizations may have libraries of contracts where a contract is published to a central repository and service implementers implement contracts from that repository.</span></span> <span data-ttu-id="55d61-217">В этом случае при публикации контракта службы в репозитории невозможно управлять создателями служб, которые реализуют контракт.</span><span class="sxs-lookup"><span data-stu-id="55d61-217">In this case, when you publish a service contract to the repository you have no control over who creates services that implement it.</span></span> <span data-ttu-id="55d61-218">Следовательно, невозможно изменить контракт службы после его публикации, что делает его фактически неизменяемым.</span><span class="sxs-lookup"><span data-stu-id="55d61-218">Therefore, you cannot modify the service contract once published, rendering it effectively immutable.</span></span> <span data-ttu-id="55d61-219">WCF поддерживает наследование контрактов, которое можно использовать для создания нового контракта, расширяющего существующие контракты.</span><span class="sxs-lookup"><span data-stu-id="55d61-219">WCF supports contract inheritance, which can be used to create a new contract that extends existing contracts.</span></span> <span data-ttu-id="55d61-220">Чтобы воспользоваться этой функцией, необходимо определить новый интерфейс контракта службы, наследуемый от старого интерфейса контракта службы, а затем добавить методы в новый интерфейс.</span><span class="sxs-lookup"><span data-stu-id="55d61-220">To use this feature, define a new service contract interface that inherits from the old service contract interface, then add methods to the new interface.</span></span> <span data-ttu-id="55d61-221">После этого требуется изменить службу, реализующую старый контракт, так, чтобы она реализовывала новый контракт, и изменить определение конечной точки старой версии так, чтобы в нем также использовался новый контракт.</span><span class="sxs-lookup"><span data-stu-id="55d61-221">You then change the service that implements the old contract to implement the new contract and change the "versionOld" endpoint definition to use the new contract.</span></span> <span data-ttu-id="55d61-222">Для клиентов старой версии эта конечная точка будет по-прежнему отображать контракт старой версии; для клиентов новой версии - контракт новой версии.</span><span class="sxs-lookup"><span data-stu-id="55d61-222">To "versionOld" clients, the endpoint will continue to appear as exposing the "versionOld" contract; to "versionNew" clients, the endpoint will appear to expose the "versionNew" contract.</span></span>  
  
## <a name="address-and-binding-versioning"></a><span data-ttu-id="55d61-223">Управление версиями адреса и привязки</span><span class="sxs-lookup"><span data-stu-id="55d61-223">Address and Binding Versioning</span></span>  
 <span data-ttu-id="55d61-224">Изменения адреса конечной точки и привязки являются критическими, если клиенты не в состоянии динамически обнаруживать новый адрес конечной точки или привязки.</span><span class="sxs-lookup"><span data-stu-id="55d61-224">Changes to endpoint address and binding are breaking changes unless clients are capable of dynamically discovering the new endpoint address or binding.</span></span> <span data-ttu-id="55d61-225">Одним из механизмов реализации этой возможности является использование реестра и шаблона вызова UDDI (Universal Discovery Description and Integration), когда клиент пытается связаться с конечной точкой и после сбоя запрашивает метаданные текущей конечной точки из хорошо известного реестра UDDI.</span><span class="sxs-lookup"><span data-stu-id="55d61-225">One mechanism for implementing this capability is by using a Universal Discovery Description and Integration (UDDI) registry and the UDDI Invocation Pattern where a client attempts to communicate with an endpoint and, upon failure, queries a well-known UDDI registry for the current endpoint metadata.</span></span> <span data-ttu-id="55d61-226">Затем клиент использует адрес и привязку из этих метаданных для связи с конечной точкой.</span><span class="sxs-lookup"><span data-stu-id="55d61-226">The client then uses the address and binding from this metadata to communicate with the endpoint.</span></span> <span data-ttu-id="55d61-227">Если связь успешна, клиент кэширует информацию об адресе и привязке для дальнейшего использования.</span><span class="sxs-lookup"><span data-stu-id="55d61-227">If this communication succeeds, the client caches the address and binding information for future use.</span></span>  
  
## <a name="routing-service-and-versioning"></a><span data-ttu-id="55d61-228">Служба маршрутизации и управление версиями</span><span class="sxs-lookup"><span data-stu-id="55d61-228">Routing Service and Versioning</span></span>  
 <span data-ttu-id="55d61-229">Если внесенные в службу изменения являются критическими и необходимо наличие двух или нескольких версий службы, запущенных одновременно, можно воспользоваться службой маршрутизации WCF для направления сообщений соответствующему экземпляру службы.</span><span class="sxs-lookup"><span data-stu-id="55d61-229">If the changes made to a service are breaking changes and you need to have two or more different versions of a service running simultaneously you can use the WCF Routing Service to route messages to the appropriate service instance.</span></span> <span data-ttu-id="55d61-230">Служба маршрутизации WCF использует маршрутизацию на основе содержимого, то есть на основе информации в самом сообщении, чтобы определить, куда направить это сообщение.</span><span class="sxs-lookup"><span data-stu-id="55d61-230">The WCF Routing Service uses content-based routing, in other words, it uses information within the message to determine where to route the message.</span></span> <span data-ttu-id="55d61-231">Дополнительные сведения о службе маршрутизации WCF см. в разделе [Служба маршрутизации](./feature-details/routing-service.md).</span><span class="sxs-lookup"><span data-stu-id="55d61-231">For more information about the WCF Routing Service see [Routing Service](./feature-details/routing-service.md).</span></span> <span data-ttu-id="55d61-232">Пример использования службы маршрутизации WCF для управления версиями службы см. [в разделе как выполнять управление версиями](./feature-details/how-to-service-versioning.md)служб.</span><span class="sxs-lookup"><span data-stu-id="55d61-232">For an example of how to use the WCF Routing Service for service versioning see [How To: Service Versioning](./feature-details/how-to-service-versioning.md).</span></span>  
  
## <a name="appendix"></a><span data-ttu-id="55d61-233">Приложение</span><span class="sxs-lookup"><span data-stu-id="55d61-233">Appendix</span></span>  
 <span data-ttu-id="55d61-234">Общий принцип управления версиями контракта данных при строгом управлении заключается в том, что контракты данных необходимо обрабатывать как неизменяемые и создавать новые, если нужно внести изменения.</span><span class="sxs-lookup"><span data-stu-id="55d61-234">The general data contract versioning guidance when strict versioning is needed is to treat data contracts as immutable and create new ones when changes are required.</span></span> <span data-ttu-id="55d61-235">Так как для каждого нового контракта данных требуется создать новый класс, необходим механизм, благодаря которому удастся избежать использования существующего кода, созданного в терминах старого класса контракта данных, и переписывания этого кода в терминах нового класса контракта данных.</span><span class="sxs-lookup"><span data-stu-id="55d61-235">A new class needs to be created for each new data contract, so a mechanism is needed to avoid having to take existing code that was written in terms of the old data contract class and rewrite it in terms of the new data contract class.</span></span>  
  
 <span data-ttu-id="55d61-236">Суть одного из таких механизмов заключается в использовании интерфейсов для определения членов каждого контракта данных и записи внутреннего кода реализации в терминах интерфейсов, а не классов контракта данных, которые реализуют интерфейсы.</span><span class="sxs-lookup"><span data-stu-id="55d61-236">One such mechanism is to use interfaces to define the members of each data contract and write internal implementation code in terms of the interfaces rather than the data contract classes that implement the interfaces.</span></span> <span data-ttu-id="55d61-237">В следующем примере кода для версии 1 службы показан интерфейс `IPurchaseOrderV1` и `PurchaseOrderV1`.</span><span class="sxs-lookup"><span data-stu-id="55d61-237">The following code for version 1 of a service shows an `IPurchaseOrderV1` interface and a `PurchaseOrderV1`:</span></span>  
  
```csharp  
public interface IPurchaseOrderV1  
{  
    string OrderId { get; set; }  
    string CustomerId { get; set; }  
}  
  
[DataContract(  
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2005/10/PurchaseOrder")]  
public class PurchaseOrderV1 : IPurchaseOrderV1  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
}  
```  
  
 <span data-ttu-id="55d61-238">Хотя операции контракта службы записываются в терминах `PurchaseOrderV1`, фактическая бизнес-логика создается в терминах `IPurchaseOrderV1`.</span><span class="sxs-lookup"><span data-stu-id="55d61-238">While the service contract’s operations would be written in terms of `PurchaseOrderV1`, the actual business logic would be in terms of `IPurchaseOrderV1`.</span></span> <span data-ttu-id="55d61-239">Затем в версии 2 используется новый интерфейс `IPurchaseOrderV2` и новый класс `PurchaseOrderV2`, как показано в следующем примере кода.</span><span class="sxs-lookup"><span data-stu-id="55d61-239">Then, in version 2, there would be a new `IPurchaseOrderV2` interface and a new `PurchaseOrderV2` class as shown in the following code:</span></span>  
  
```csharp
public interface IPurchaseOrderV2  
{  
    DateTime OrderDate { get; set; }  
}

[DataContract(   
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2006/02/PurchaseOrder")]  
public class PurchaseOrderV2 : IPurchaseOrderV1, IPurchaseOrderV2  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
    [DataMember(...)]  
    public DateTime OrderDate { ... }  
}  
```  
  
 <span data-ttu-id="55d61-240">Контракт службы обновляется с включением новых операций, созданных в терминах `PurchaseOrderV2`.</span><span class="sxs-lookup"><span data-stu-id="55d61-240">The service contract would be updated to include new operations that are written in terms of `PurchaseOrderV2`.</span></span> <span data-ttu-id="55d61-241">Существующая бизнес-логика, созданная в терминах `IPurchaseOrderV1`, продолжает работать для `PurchaseOrderV2`, а новая бизнес-логика, требующая свойство `OrderDate`, создается в терминах `IPurchaseOrderV2`.</span><span class="sxs-lookup"><span data-stu-id="55d61-241">Existing business logic written in terms of `IPurchaseOrderV1` would continue to work for `PurchaseOrderV2` and new business logic that needs the `OrderDate` property would be written in terms of `IPurchaseOrderV2`.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="55d61-242">См. также</span><span class="sxs-lookup"><span data-stu-id="55d61-242">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Runtime.Serialization.DataContractAttribute>
- <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A>
- <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A>
- <xref:System.Runtime.Serialization.IExtensibleDataObject>
- <xref:System.Runtime.Serialization.ExtensionDataObject>
- <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A>
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="55d61-243">Эквивалентность контрактов данных</span><span class="sxs-lookup"><span data-stu-id="55d61-243">Data Contract Equivalence</span></span>](./feature-details/data-contract-equivalence.md)
- [<span data-ttu-id="55d61-244">Обратные вызовы сериализации, независимые от версий</span><span class="sxs-lookup"><span data-stu-id="55d61-244">Version-Tolerant Serialization Callbacks</span></span>](./feature-details/version-tolerant-serialization-callbacks.md)
