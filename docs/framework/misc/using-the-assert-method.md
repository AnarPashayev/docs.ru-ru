---
title: Использование метода Assert
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- granting permissions, overriding security checks
- code access security, overriding security checks
- overriding security checks
- security [.NET Framework], overriding security checks
- security [.NET Framework], assertions
- asserted permissions
- Assert method
- caller security checks
- permissions [.NET Framework], overriding security checks
- permissions [.NET Framework], assertions
ms.assetid: 1e40f4d3-fb7d-4f19-b334-b6076d469ea9
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 08b46d96f9fb950602766639559a375a25747010
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/08/2019
ms.locfileid: "59073732"
---
# <a name="using-the-assert-method"></a>Использование метода Assert
[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]  
  
 <xref:System.Security.CodeAccessPermission.Assert%2A> — Это метод, который может вызываться для классов разрешений доступа к коду и на <xref:System.Security.PermissionSet> класса. Можно использовать **Assert** для реализации кода (и подчиненным вызывающим объектам) для выполнения действий, которые коде есть соответствующие разрешения, но его вызывающих отсутствует разрешение для выполнения. Утверждение безопасности изменяет нормальный ход процесса, которому следует среда выполнения при проверке безопасности. Когда вы утверждаете разрешение, система безопасности не проверяет вызывающие объекты кода на наличие утвержденного разрешения.  
  
> [!CAUTION]
>  Используйте утверждения осторожно, так как они могут открывать бреши в системе безопасности и подорвать работу механизма применения ограничений безопасности в среде выполнения.  
  
 Утверждения удобны в ситуациях, когда библиотека вызывает неуправляемый код или совершает вызов, требующий разрешение, связь которого с назначением библиотеки не очевидна. Например, весь управляемый код, который выполняет вызовы неуправляемого кода должен иметь **SecurityPermission** с **UnmanagedCode** значений флагов stateful. Код, источником которого не является локальный компьютер, например код, скачанный из локальной интрасети, не получает это разрешение по умолчанию. Таким образом, чтобы код, загруженный из локальной интрасети, мог вызывать библиотеку, использующую неуправляемый код, он должен иметь утвержденное библиотекой разрешение. Кроме того, некоторые библиотеки могут выполнять вызовы, которые не видны вызывающим объектам и требуют специальных разрешений.  
  
 Утверждения также можно использовать в ситуациях, когда код обращается к ресурсу способом, полностью скрытым от вызывающих объектов. Предположим, например, что ваша библиотека получает сведения из базы данных, но в процессе также считывает информацию из реестра компьютера. Так как разработчики, использующие вашу библиотеку нет доступа к источнику, они не имеют возможности узнать, что их код должен иметь **RegistryPermission** для использования вашего кода. Если в такой ситуации вы решите, что неразумно или нерационально требовать наличия разрешения на доступ к реестру у вызывающих ваш код объектов, можно утвердить разрешение на чтение из реестра. В этом случае он подходит для библиотеки, чтобы подтвердить это разрешение, вызывающие объекты без **RegistryPermission** можно использовать библиотеку.  
  
 Утверждение влияет на обход стека только в том случае, если утвержденное разрешение и разрешение, затребованное подчиненным вызывающим объектом, имеют один и тот же тип, а запрошенное разрешение является подмножеством утвержденного разрешения. Например, если вы утверждаете **FileIOPermission** для чтения всех файлов на диске C, а подчиненный выполняется **FileIOPermission** читать C:\Temp, утверждение может повлиять на обход стека; Тем не менее если было для **FileIOPermission** для записи на диск C, утверждение не окажет никакого влияния.  
  
 Для выполнения утверждений коду должно быть назначено как разрешение, которое вы утверждаете, так и разрешение <xref:System.Security.Permissions.SecurityPermission>, представляющее право на выполнение утверждений. Хотя вы и можете утвердить разрешение, которое не было предоставлено коду, такое утверждение будет бессмысленным, так как проверка безопасности завершится со сбоем до того, как такое утверждение могло бы поспособствовать ее успешному завершению.  
  
 На следующем рисунке показано, что происходит при использовании **Assert**. Предположим, что справедливы следующие утверждения о сборках A, B, C, E и F, а также разрешениях P1 и P1A:  
  
-   P1A предоставляет право чтения TXT-файлов на диске C.  
  
-   P1 предоставляет право чтения всех файлов на диске C.  
  
-   P1A и P1 **FileIOPermission** , а P1A является подмножеством P1.  
  
-   Сборкам E и F назначено разрешение P1A.  
  
-   Сборке C назначено разрешение P1.  
  
-   Сборкам A и B не назначено ни разрешение P1, ни разрешение P1A.  
  
-   Метод A содержится в сборке A, метод B содержится в сборке B и т. д.  
  
 ![Схема, показывающая сборки метода Assert.](./media/using-the-assert-method/assert-method-assemblies.gif)    
  
 В этом сценарии, метод A вызывает B, B вызывает C, C вызывает E и E вызывает F. метод C утверждает разрешение на чтение файлов на диске C (разрешение P1), а метод E запрашивает разрешения на чтение TXT-файлов на диске C (разрешение P1A). Когда требование из F обнаруживается во время выполнения, обход стека для проверки разрешений всех вызывающих объектов F, начиная с E. E разрешение P1A, поэтому обход стека продолжается для проверки разрешений у C, где обнаруживается утверждение для. Так как запрошенное разрешение (P1A) является подмножеством утвержденного разрешения (P1), обход стека останавливается, а проверка безопасности завершается успешно. То, что разрешение P1A не было назначено сборкам A и B, не имеет никакого значения. Утверждая P1, метод C позволяет вызывающим объектам обращаться к ресурсу, защищенному при помощи P1, даже если вызывающие объекты не имеют разрешения на доступ к этому ресурсу.  
  
 Если вы разрабатываете библиотеку классов и класс обращается к защищенному ресурсу, в большинстве случаев следует реализовать требование безопасности относительно наличия у вызывающих объектов этого класса соответствующего разрешения. Если класс выполняет операцию, для которой у большинства вызывающих не будет разрешения, и вы готовы принять ответственность за предоставление этим вызывающим объектам вызывать ваш код, можно утвердить разрешение, вызвав **Assert** метода для объекта разрешения, представляющий операцию выполняет код. С помощью **Assert** таким образом, вы позволяете вызывающим объектам, которые обычно не удалось вызвать ваш код. Таким образом, если вы утверждаете разрешение, следует обязательно заранее выполнить соответствующие проверки безопасности, чтобы предотвратить неправильное использование вашего компонента.  
  
 Например, предположим, что ваш в высшей степени доверенный класс библиотеки содержит метод, удаляющий файлы. Он обращается к файлу путем вызова неуправляемой функции Win32. Вызывающий объект вызывает кода **удалить** метод, передавая имя файла для удаления, C:\Test.txt. В рамках **удалить** метод, код создает <xref:System.Security.Permissions.FileIOPermission> объект, представляющий доступ на запись к C:\Test.txt. (Для удаления файла требуется доступ на запись.) Код запускает принудительную проверку безопасности путем вызова **FileIOPermission** объекта **запросу** метод. Если один из вызывающих объектов в стеке вызовов не имеет этого разрешения, возникает исключение <xref:System.Security.SecurityException>. Если исключение не выдается, вы можете быть уверены в том, что все вызывающие объекты имеют право доступа к C:\Test.txt. Так как вы считаете, что большинство вызывающих объектов не будет разрешения на доступ к неуправляемому коду, код создает <xref:System.Security.Permissions.SecurityPermission> объект, представляющий право вызова неуправляемого кода и вызывает объект **Assert** метод. Наконец он вызывает неуправляемую функцию Win32 для удаления файла C:\Text.txt и возвращает управление вызывающему объекту.  
  
> [!CAUTION]
>  Необходимо убедиться, что код не использует утверждения в ситуациях, когда ваш код может использоваться другим кодом для доступа к ресурсу, защищенному утверждаемым вами разрешением. Например, в коде, который записывает в файл, имя которого указывается вызывающим объектом как параметр, не следует утверждать **FileIOPermission** на запись в файлы, так как ваш код будет открыт для неправильного использования третьей стороной.  
  
 При использовании принудительного синтаксиса безопасности вызов **Assert** метод для нескольких разрешений в одном методе приводит к возникновению исключения безопасности. Вместо этого следует создать **PermissionSet** , передать ему отдельные разрешения, которые вы хотите вызвать, а затем вызвать **Assert** метод **PermissionSet** объект. Можно вызвать **Assert** более чем один раз при использовании декларативного синтаксиса безопасности метод.  
  
 В следующем примере показано декларативный синтаксис для переопределения проверок безопасности с помощью **Assert** метод. Обратите внимание, что **FileIOPermissionAttribute** синтаксис принимает два значения: <xref:System.Security.Permissions.SecurityAction> перечисления и расположение файла или каталога, к которому предоставляется разрешение. Вызов **Assert** требования для доступа к `C:\Log.txt` для успешного выполнения, несмотря на то, что вызывающие объекты не проверяются на разрешение доступа к файлу.  
  
```vb  
Option Explicit  
Option Strict  
  
Imports System  
Imports System.IO  
Imports System.Security.Permissions  
  
Namespace LogUtil  
   Public Class Log  
      Public Sub New()  
  
      End Sub  
  
     <FileIOPermission(SecurityAction.Assert, All := "C:\Log.txt")> Public Sub   
      MakeLog()  
         Dim TextStream As New StreamWriter("C:\Log.txt")  
         TextStream.WriteLine("This  Log was created on {0}", DateTime.Now) '  
         TextStream.Close()  
      End Sub  
   End Class  
End Namespace  
```  
  
```csharp  
namespace LogUtil  
{  
   using System;  
   using System.IO;  
   using System.Security.Permissions;  
  
   public class Log  
   {  
      public Log()  
      {      
      }     
      [FileIOPermission(SecurityAction.Assert, All = @"C:\Log.txt")]  
      public void MakeLog()  
      {     
         StreamWriter TextStream = new StreamWriter(@"C:\Log.txt");  
         TextStream.WriteLine("This  Log was created on {0}", DateTime.Now);  
         TextStream.Close();  
      }  
   }  
}   
```  
  
 В следующих фрагментах кода показан принудительный синтаксис для переопределения проверок безопасности с помощью **Assert** метод. В этом примере экземпляр **FileIOPermission** объявлен объект. Его конструктору передается **FileIOPermissionAccess.AllAccess** для определения типа разрешенного доступа, а затем строка, описывающая расположение файла. Один раз **FileIOPermission** определения объектов, необходимо вызвать его **Assert** метод для переопределения проверки безопасности.  
  
```vb  
Option Explicit  
Option Strict  
Imports System  
Imports System.IO  
Imports System.Security.Permissions  
Namespace LogUtil  
   Public Class Log  
      Public Sub New()  
      End Sub 'New  
  
      Public Sub MakeLog()  
         Dim FilePermission As New FileIOPermission(FileIOPermissionAccess.AllAccess, "C:\Log.txt")  
         FilePermission.Assert()  
         Dim TextStream As New StreamWriter("C:\Log.txt")  
         TextStream.WriteLine("This  Log was created on {0}", DateTime.Now)  
         TextStream.Close()  
      End Sub  
   End Class  
End Namespace  
```  
  
```csharp  
namespace LogUtil  
{  
   using System;  
   using System.IO;  
   using System.Security.Permissions;  
  
   public class Log  
   {  
      public Log()  
      {      
      }     
      public void MakeLog()  
      {  
         FileIOPermission FilePermission = new FileIOPermission(FileIOPermissionAccess.AllAccess,@"C:\Log.txt");   
         FilePermission.Assert();  
         StreamWriter TextStream = new StreamWriter(@"C:\Log.txt");  
         TextStream.WriteLine("This  Log was created on {0}", DateTime.Now);  
         TextStream.Close();  
      }  
   }  
}  
```  
  
## <a name="see-also"></a>См. также

- <xref:System.Security.PermissionSet>
- <xref:System.Security.Permissions.SecurityPermission>
- <xref:System.Security.Permissions.FileIOPermission>
- <xref:System.Security.Permissions.SecurityAction>
- [Атрибуты](../../../docs/standard/attributes/index.md)
- [Управление доступом для кода](../../../docs/framework/misc/code-access-security.md)
