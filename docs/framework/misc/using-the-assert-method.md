---
title: Использование метода Assert
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- granting permissions, overriding security checks
- code access security, overriding security checks
- overriding security checks
- security [.NET Framework], overriding security checks
- security [.NET Framework], assertions
- asserted permissions
- Assert method
- caller security checks
- permissions [.NET Framework], overriding security checks
- permissions [.NET Framework], assertions
ms.assetid: 1e40f4d3-fb7d-4f19-b334-b6076d469ea9
ms.openlocfilehash: 92e49af78d42f360d5798a72d4e7b981295947e9
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79181103"
---
# <a name="using-the-assert-method"></a>Использование метода Assert
[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]  
  
 <xref:System.Security.CodeAccessPermission.Assert%2A> представляет собой метод, который может вызываться для классов разрешений доступа к коду и для класса <xref:System.Security.PermissionSet>. Можно использовать **Assert** для включения вашего кода (и абонентов вниз по течению) для выполнения действий, на которые у вашего кода есть разрешение, но у его абонентов может не быть разрешения. Утверждение безопасности изменяет нормальный ход процесса, которому следует среда выполнения при проверке безопасности. Когда вы утверждаете разрешение, система безопасности не проверяет вызывающие объекты кода на наличие утвержденного разрешения.  
  
> [!CAUTION]
> Используйте утверждения осторожно, так как они могут открывать бреши в системе безопасности и подорвать работу механизма применения ограничений безопасности в среде выполнения.  
  
 Утверждения удобны в ситуациях, когда библиотека вызывает неуправляемый код или совершает вызов, требующий разрешение, связь которого с назначением библиотеки не очевидна. Например, все управляемые коды, которые вызовуются в неуправляемый код, должны иметь **разрешение безопасности** с указанным флагом **неуправляемого кода.** Код, источником которого не является локальный компьютер, например код, скачанный из локальной интрасети, не получает это разрешение по умолчанию. Таким образом, чтобы код, загруженный из локальной интрасети, мог вызывать библиотеку, использующую неуправляемый код, он должен иметь утвержденное библиотекой разрешение. Кроме того, некоторые библиотеки могут выполнять вызовы, которые не видны вызывающим объектам и требуют специальных разрешений.  
  
 Утверждения также можно использовать в ситуациях, когда код обращается к ресурсу способом, полностью скрытым от вызывающих объектов. Предположим, например, что ваша библиотека получает сведения из базы данных, но в процессе также считывает информацию из реестра компьютера. Поскольку разработчики, использующие вашу библиотеку, не имеют доступа к вашему источнику, они не могут знать, что их код требует **разрешения на регистрацию,** чтобы использовать ваш код. Если в такой ситуации вы решите, что неразумно или нерационально требовать наличия разрешения на доступ к реестру у вызывающих ваш код объектов, можно утвердить разрешение на чтение из реестра. В этой ситуации библиотеке уместно утвердить разрешение, чтобы абоненты без **регистрацииМогли** использовать библиотеку.  
  
 Утверждение влияет на обход стека только в том случае, если утвержденное разрешение и разрешение, затребованное подчиненным вызывающим объектом, имеют один и тот же тип, а запрошенное разрешение является подмножеством утвержденного разрешения. Например, если вы утверждаете **FileIOPermission** для чтения всех файлов на диске C, и ниже по течению требуется **FileIOPermission** для чтения файлов в C: «Темп, утверждение может повлиять на ход стека; однако, если бы требование было для **FileIOPermission** написать на диск C, утверждение не будет иметь никакого эффекта.  
  
 Для выполнения утверждений коду должно быть назначено как разрешение, которое вы утверждаете, так и разрешение <xref:System.Security.Permissions.SecurityPermission>, представляющее право на выполнение утверждений. Хотя вы и можете утвердить разрешение, которое не было предоставлено коду, такое утверждение будет бессмысленным, так как проверка безопасности завершится со сбоем до того, как такое утверждение могло бы поспособствовать ее успешному завершению.  
  
 Следующая иллюстрация показывает, что происходит при использовании **Assert**. Предположим, что справедливы следующие утверждения о сборках A, B, C, E и F, а также разрешениях P1 и P1A:  
  
- P1A предоставляет право чтения TXT-файлов на диске C.  
  
- P1 предоставляет право чтения всех файлов на диске C.  
  
- P1A и P1 являются типами **FileIOPermission,** а P1A является подмножеством P1.  
  
- Сборкам E и F назначено разрешение P1A.  
  
- Сборке C назначено разрешение P1.  
  
- Сборкам A и B не назначено ни разрешение P1, ни разрешение P1A.  
  
- Метод A содержится в сборке A, метод B содержится в сборке B и т. д.  
  
 ![Диаграмма, отображая сборки метода Assert.](./media/using-the-assert-method/assert-method-assemblies.gif)
  
 В этом сценарии метод A вызывает B, B вызывает C, C вызывает E, и E вызывает F. Метод C утверждает разрешение на чтение файлов на диске C (разрешение P1), а метод E требует разрешения на чтение файлов .txt на диске C (разрешение P1A). Когда спрос в F возникает во время выполнения, стек ходить выполняется для проверки разрешений всех абонентов F, начиная с E. E было предоставлено разрешение P1A, так что стек ходить продолжает изучать разрешения C, где утверждение C обнаружен. Так как запрошенное разрешение (P1A) является подмножеством утвержденного разрешения (P1), обход стека останавливается, а проверка безопасности завершается успешно. То, что разрешение P1A не было назначено сборкам A и B, не имеет никакого значения. Утверждая P1, метод C позволяет вызывающим объектам обращаться к ресурсу, защищенному при помощи P1, даже если вызывающие объекты не имеют разрешения на доступ к этому ресурсу.  
  
 Если вы разрабатываете библиотеку классов и класс обращается к защищенному ресурсу, в большинстве случаев следует реализовать требование безопасности относительно наличия у вызывающих объектов этого класса соответствующего разрешения. Если класс выполняет операцию, для которой вы знаете, что большинство абонентов не будет иметь разрешения, и если вы готовы взять на себя ответственность за то, чтобы эти абоненты позвонили в ваш код, вы можете утвердить разрешение, позвонив **методу Assert** на объекте разрешения, который представляет операцию, которую выполняет код. Использование **Assert** таким образом позволяет абонентам, которые обычно не могли этого сделать, позвонить по вашему коду. Таким образом, если вы утверждаете разрешение, следует обязательно заранее выполнить соответствующие проверки безопасности, чтобы предотвратить неправильное использование вашего компонента.  
  
 Например, предположим, что ваш в высшей степени доверенный класс библиотеки содержит метод, удаляющий файлы. Он обращается к файлу путем вызова неуправляемой функции Win32. Звонящее вызывает метод **удаления** вашего кода, передавая имя файла для удаления, C:'Test.txt. В методе **Удаления** код <xref:System.Security.Permissions.FileIOPermission> создает объект, представляющий доступ к записи к C:'Test.txt. (Запись доступа требуется для удаления файла.) Затем код вызывает императивную проверку безопасности, позвонив в метод **demand** объекта **FileIOPermission.** Если один из вызывающих объектов в стеке вызовов не имеет этого разрешения, возникает исключение <xref:System.Security.SecurityException>. Если исключение не выдается, вы можете быть уверены в том, что все вызывающие объекты имеют право доступа к C:\Test.txt. Поскольку вы считаете, что у большинства абонентов не будет разрешения <xref:System.Security.Permissions.SecurityPermission> на доступ к неуправляемому коду, код создает объект, который представляет право вызывать неуправляемый код и вызывает метод **Assert** объекта. Наконец он вызывает неуправляемую функцию Win32 для удаления файла C:\Text.txt и возвращает управление вызывающему объекту.  
  
> [!CAUTION]
> Необходимо убедиться, что код не использует утверждения в ситуациях, когда ваш код может использоваться другим кодом для доступа к ресурсу, защищенному утверждаемым вами разрешением. Например, в коде, который записывает сяробую в файл, имя которого указывает сяркер как параметр, вы не будете утверждать **FileIOPermission** для записи файлов, потому что ваш код будет открыт для неправильного использования третьей стороной.  
  
 При использовании императивного синтаксиса безопасности вызов метода **Assert** на нескольких разрешениях в одном и том же методе приводит к тому, что следует отбросить исключение безопасности. Вместо этого следует создать объект **PermissionSet,** передать ему отдельные разрешения, на которые вы хотите вызвать, а затем вызвать метод **Assert** на **объекте PermissionSet.** Вы можете вызвать метод **Assert** более одного раза при использовании декларативного синтаксиса безопасности.  
  
 В следующем примере показан декларативный синтаксис для переопределения проверок безопасности с помощью метода **Assert.** Обратите внимание, что синтаксис **FileIOPermissionAttribute** занимает два значения: <xref:System.Security.Permissions.SecurityAction> перечисление и расположение файла или каталога, разрешение на который должно быть предоставлено. Вызов **в Assert** вызывает требования `C:\Log.txt` к доступу к успеху, даже если абоненты не проверяются на наличие разрешения на доступ к файлу.  
  
```vb  
Option Explicit  
Option Strict  
  
Imports System  
Imports System.IO  
Imports System.Security.Permissions  
  
Namespace LogUtil  
   Public Class Log  
      Public Sub New()  
  
      End Sub  
  
     <FileIOPermission(SecurityAction.Assert, All := "C:\Log.txt")> Public Sub
      MakeLog()  
         Dim TextStream As New StreamWriter("C:\Log.txt")  
         TextStream.WriteLine("This  Log was created on {0}", DateTime.Now) '  
         TextStream.Close()  
      End Sub  
   End Class  
End Namespace  
```  
  
```csharp  
namespace LogUtil  
{  
   using System;  
   using System.IO;  
   using System.Security.Permissions;  
  
   public class Log  
   {  
      public Log()  
      {
      }
      [FileIOPermission(SecurityAction.Assert, All = @"C:\Log.txt")]  
      public void MakeLog()  
      {
         StreamWriter TextStream = new StreamWriter(@"C:\Log.txt");  
         TextStream.WriteLine("This  Log was created on {0}", DateTime.Now);  
         TextStream.Close();  
      }  
   }  
}
```  
  
 Следующие фрагменты кода показывают императив ный синтаксис для переопределения проверок безопасности с помощью метода **Assert.** В этом примере объявляется экземпляр объекта **FileIOPermission.** Его конструктор передается **FileIOPermissionAccess.AllAccess** для определения типа разрешенного доступа, а затем строки, описывающей местоположение файла. После определения объекта **FileIOPermission** достаточно вызвать его метод **Assert,** чтобы переопределить проверку безопасности.  
  
```vb  
Option Explicit  
Option Strict  
Imports System  
Imports System.IO  
Imports System.Security.Permissions  
Namespace LogUtil  
   Public Class Log  
      Public Sub New()  
      End Sub 'New  
  
      Public Sub MakeLog()  
         Dim FilePermission As New FileIOPermission(FileIOPermissionAccess.AllAccess, "C:\Log.txt")  
         FilePermission.Assert()  
         Dim TextStream As New StreamWriter("C:\Log.txt")  
         TextStream.WriteLine("This  Log was created on {0}", DateTime.Now)  
         TextStream.Close()  
      End Sub  
   End Class  
End Namespace  
```  
  
```csharp  
namespace LogUtil  
{  
   using System;  
   using System.IO;  
   using System.Security.Permissions;  
  
   public class Log  
   {  
      public Log()  
      {
      }
      public void MakeLog()  
      {  
         FileIOPermission FilePermission = new FileIOPermission(FileIOPermissionAccess.AllAccess,@"C:\Log.txt");
         FilePermission.Assert();  
         StreamWriter TextStream = new StreamWriter(@"C:\Log.txt");  
         TextStream.WriteLine("This  Log was created on {0}", DateTime.Now);  
         TextStream.Close();  
      }  
   }  
}  
```  
  
## <a name="see-also"></a>См. также раздел

- <xref:System.Security.PermissionSet>
- <xref:System.Security.Permissions.SecurityPermission>
- <xref:System.Security.Permissions.FileIOPermission>
- <xref:System.Security.Permissions.SecurityAction>
- [Атрибуты](../../standard/attributes/index.md)
- [Безопасность доступа к коду](code-access-security.md)
