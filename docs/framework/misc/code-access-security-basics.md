---
title: Основы управления доступом для кода
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- security [.NET Framework], code access security
ms.assetid: 4eaa6535-d9fe-41a1-91d8-b437cfc16921
ms.openlocfilehash: 352fa41cb9d3136f853b068d0101a6dcab5dfd7c
ms.sourcegitcommit: 62285ec11fa8e8424bab00511a90760c60e63c95
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/20/2020
ms.locfileid: "81645771"
---
# <a name="code-access-security-basics"></a>Основы управления доступом для кода

[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]

Каждое приложение, ориентированное на среду CLR (то есть каждое управляемое приложение), должно взаимодействовать с ее системой безопасности. Когда управляемое приложение загружается, его узел автоматически предоставляет ему набор разрешений. Эти разрешения определяются параметрами локальной безопасности узла или изоляцией приложения. В зависимости от этих разрешений приложение либо запускается, либо вызывает исключение безопасности.

Узел по умолчанию для классических приложений позволяет коду выполняться в режиме полного доверия. По этой причине, если приложение предназначено для настольных компьютеров, оно имеет неограниченный набор разрешений. Другие узлы или "песочницы" предоставляют ограниченный набор разрешений для приложений. Набор разрешений может меняться от узла к узлу, поэтому приложение должно быть разработано для использования только тех разрешений, которые допускаются целевым узлом.

Чтобы писать эффективные приложения, нацеленные на среду CLR, нужно быть знакомым с приведенными ниже принципами управления доступом для кода.

- **Код, безопасный**для типов: Код типа-безопасный — это код, который получает доступ к типам только четко определенными, допустимыми способами. Например, имея действительную ссылку на объект, типобезопасный код может осуществлять доступ к памяти по фиксированным смещениям, соответствующим реальным членам-полям. Если код производит доступ к памяти по произвольным смещениям за пределами диапазона памяти, принадлежащего открытым полям этого объекта, он не является типобезопасным. Чтобы иметь возможность пользоваться преимуществами управления доступом для кода, необходимо использовать компилятор, создающий проверяемый типобезопасный код. Для получения дополнительной информации смотрите раздел [«Написать проверяемо тип-безопасный код»](#typesafe_code) позже в этой теме.

- **Императивный и декларативный синтаксис**: Код, нацеленный на общее время выполнения языка, может взаимодействовать с системой безопасности, запрашивая разрешения, требуя, чтобы абоненты указали разрешения, и переопределяет определенные параметры безопасности (с учетом достаточного количества привилегий). Можно использовать две различные формы синтаксиса для программного взаимодействия с системой безопасности .NET Framework: декларативный синтаксис и принудительный синтаксис. Декларативные вызовы выполняются с использованием атрибутов; принудительные вызовы выполняются с использованием новых экземпляров классов в вашем коде. Некоторые вызовы могут выполняться только принудительно, другие — только декларативно, а некоторые — любым способом.

- **Безопасные библиотеки классов:** Безопасная библиотека класса использует требования безопасности для обеспечения того, чтобы абоненты библиотеки имели разрешение на доступ к ресурсам, которые предоставляет библиотека. Например, безопасная библиотека классов может содержать метод для создания файлов, который будет требовать, чтобы вызывающие его объекты обладали разрешениями на создание файлов. Платформа .NET Framework включает в себя безопасные библиотеки классов. Вам необходимо учитывать разрешения, требуемые для доступа к любой библиотеке, используемой кодом. Для получения дополнительной информации смотрите раздел [«Использование безопасных библиотек класса»](#secure_library) позже в этой теме.

- **Прозрачный код**: Начиная с .NET Framework 4, в дополнение к идентификации конкретных разрешений, необходимо также определить, должен ли код работать как прозрачный для безопасности. Прозрачный с точки зрения безопасности код не может вызывать типы или члены, которые определены как критические с точки зрения безопасности. Это правило относится к приложениям как с полным, так и с частичным доверием. Для получения дополнительной информации [см.](security-transparent-code.md)

<a name="typesafe_code"></a>

## <a name="writing-verifiably-type-safe-code"></a>Написание проверяемого типобезопасного кода

JIT-компиляция выполняет процесс проверки, который анализирует код и пытается определить, является ли он типобезопасным. Код, который доказан во время проверки как безопасный для типов, называется *проверяемым кодом типа.* Код может быть типобезопасным, но не проверяемым типобезопасным из-за ограничений процесса проверки его компилятором. Не все языки являются типобезопасными, и компиляторы некоторых языков, таких как Microsoft Visual C++, не могут создавать проверяемый типобезопасный код. Чтобы определить, создает ли компилятор языка, который вы используете, проверяемый типобезопасный код, нужно свериться с документацией по компилятору. Если вы используете компилятор языка, который генерирует проверяемо типовый код только при избегании определенных языковых конструкций, вы можете использовать [инструмент PEVerify,](../tools/peverify-exe-peverify-tool.md) чтобы определить, является ли ваш код проверяемо безопасным для типов.

Код, не являющийся проверяемым типобезопасным, может осуществить попытку выполнения, если политика безопасности позволяет коду обойти проверку. Однако, так как строгая типизация является неотъемлемой частью механизма среды выполнения для изоляции сборок, безопасность не может уверенно соблюдаться, если код нарушает правила типобезопасности. По умолчанию код, не являющийся типобезопасным, допускается к выполнению, только если его источником является локальный компьютер. Поэтому мобильный код должен быть типобезопасным.

<a name="secure_library"></a>

## <a name="using-secure-class-libraries"></a>Использование безопасных библиотек классов

Если код запрашивает и получает разрешения, требуемые библиотекой классов, ему будет разрешен доступ к библиотеке и ресурс будет защищен от несанкционированного доступа. Если же код не будет обладать соответствующими разрешениями, он не сможет получить доступ к библиотеке и вредоносный код не сможет воспользоваться вашим кодом для непрямого доступа к защищенным ресурсам. Даже если ваш код получит разрешение на доступ к библиотеке, его запуск не будет разрешен, если код, вызвавший его, также не обладает разрешением на доступ к этой библиотеке.

Управление доступом для кода не исключает вероятности человеческой ошибки при написании кода. Но если приложение использует безопасные библиотеки классов для доступа к защищенным ресурсам, риск для безопасности кода приложения снижается, так как библиотеки классов тщательно изучаются на предмет потенциальных проблем безопасности.

## <a name="declarative-security"></a>Декларативная безопасность

Декларативный синтаксис безопасности использует [атрибуты](../../standard/attributes/index.md) для размещения информации о безопасности в [метаданных](../../standard/metadata-and-self-describing-components.md) вашего кода. Атрибуты могут быть указаны на уровне сборки, класса или члена для указания типа запроса, требования или переопределения, которые необходимо использовать. Запросы используются в приложениях, нацеленных на среду CLR, для информирования системы безопасности среды выполнения о разрешениях, которые нужны или не нужны вашему приложению. Требования и переопределения используются в библиотеках для защиты ресурсов от вызывающих объектов или переопределения поведения системы безопасности по умолчанию.

> [!NOTE]
> В рамках .NET Framework 4 произошли важные изменения в модели безопасности и терминологии .NET Framework. Для получения дополнительной информации об этих изменениях [см.](https://docs.microsoft.com/previous-versions/dotnet/framework/security/security-changes)

Чтобы использовать декларативные вызовы безопасности, необходимо инициализировать данные состояния объекта разрешения таким образом, чтобы они представляли определенную форму необходимого разрешения. Каждое встроенное разрешение имеет атрибут, которому передается перечисление <xref:System.Security.Permissions.SecurityAction> для описания типа операции безопасности, которую нужно выполнить. Однако разрешения также принимают собственные параметры, являющиеся для них исключительными.

В приведенном ниже фрагменте кода показано использование декларативного синтаксиса для запроса наличия у вызывающих объектов кода пользовательского разрешения `MyPermission`. Это гипотетическое разрешение, которого не существует в .NET Framework. В этом примере декларативный вызов помещен непосредственно перед определением класса, указывая, что разрешение применяется на уровне класса. Атрибут передается в структуру **SecurityAction.Demand,** чтобы указать, что для запуска абоненты должны иметь это разрешение.

```vb
<MyPermission(SecurityAction.Demand, Unrestricted = True)> Public Class MyClass1

   Public Sub New()
      'The constructor is protected by the security call.
   End Sub

   Public Sub MyMethod()
      'This method is protected by the security call.
   End Sub

   Public Sub YourMethod()
      'This method is protected by the security call.
   End Sub
End Class
```

```csharp
[MyPermission(SecurityAction.Demand, Unrestricted = true)]
public class MyClass
{
   public MyClass()
   {
      //The constructor is protected by the security call.
   }

   public void MyMethod()
   {
      //This method is protected by the security call.
   }

   public void YourMethod()
   {
      //This method is protected by the security call.
   }
}
```

## <a name="imperative-security"></a>Принудительная безопасность

Принудительный синтаксис безопасности производит вызов безопасности, создавая экземпляр объекта разрешения, который нужно вызвать. Принудительный синтаксис можно использовать для выполнения требований и переопределений, но не запросов.

Прежде чем осуществить вызов безопасности, необходимо инициализировать данные состояния объекта разрешения, чтобы они представляли определенную форму необходимого разрешения. Например, при <xref:System.Security.Permissions.FileIOPermission> создании объекта можно использовать конструктор для инициализации объекта **FileIOPermission** таким образом, чтобы он был либо неограниченным доступом ко всем файлам, либо отсутствием доступа к файлам. Или можно использовать другой объект **FileIOPermission,** передавая параметры, указывающие тип доступа, который вы хотите, чтобы объект представлял (т.е. прочитайте, приготовив или напишите) и какие файлы вы хотите защитить.

Помимо вызова отдельного объекта безопасности, принудительный синтаксис безопасности можно использовать для инициализации группы разрешений, называемой набором разрешений. Например, этот метод является единственным способом [надежного](using-the-assert-method.md) выполнения утверждений вызовов на нескольких разрешениях в одном методе. Используйте классы <xref:System.Security.PermissionSet> и <xref:System.Security.NamedPermissionSet> для создания группы разрешений, после чего вызовите соответствующий метод для выполнения желаемого вызова безопасности.

Принудительный синтаксис можно использовать для выполнения требований и переопределений, но не запросов. Вы можете использовать принудительный синтаксис для требований и переопределений вместо декларативного синтаксиса, когда информация, необходимая для инициализации состояния разрешения, становится известна только во время выполнения. Например, если нужно обеспечить наличие у вызывающих объектов разрешений на чтение определенного файла, но его имя неизвестно до запуска, используйте принудительное требование. Вы также можете выбрать использование принудительных проверок вместо декларативных, когда нужно во время выполнения определить, имеет ли место некоторое условие, и на основании результата проверки предъявить (или же не предъявлять) требование безопасности.

В приведенном ниже фрагменте кода показано использование принудительного синтаксиса для запроса наличия у вызывающих объектов кода пользовательского разрешения `MyPermission`. Это гипотетическое разрешение, которого не существует в .NET Framework. Экземпляр `MyPermission` создается в методе `MyMethod`, защищая вызовом безопасности только этот метод.

```vb
Public Class MyClass1

   Public Sub New()

   End Sub

   Public Sub MyMethod()
      'MyPermission is demanded using imperative syntax.
      Dim Perm As New MyPermission()
      Perm.Demand()
      'This method is protected by the security call.
   End Sub

   Public Sub YourMethod()
      'YourMethod 'This method is not protected by the security call.
   End Sub
End Class
```

```csharp
public class MyClass {
   public MyClass(){

   }

   public void MyMethod() {
       //MyPermission is demanded using imperative syntax.
       MyPermission Perm = new MyPermission();
       Perm.Demand();
       //This method is protected by the security call.
   }

   public void YourMethod() {
       //This method is not protected by the security call.
   }
}
```

## <a name="using-managed-wrapper-classes"></a>Использование управляемых классов-оболочек

Большинство приложений и компонентов (кроме безопасных библиотек) не должны напрямую вызывать неуправляемый код. Для этого есть несколько причин. Если код вызывает неуправляемый код напрямую, во многих ситуациях ему не будет разрешено выполняться, потому что он должен обладать высоким уровнем доверия, чтобы вызывать машинный код. Если политика будет изменена с целью разрешить запуск подобного приложения, это может заметно ослабить безопасность системы, так как приложение сможет выполнять практически любые операции.

Кроме того, код, имеющий разрешение на доступ к неуправляемому коду, может выполнить почти любую операцию, вызвав неуправляемый интерфейс API. Например, код, который имеет разрешение на <xref:System.Security.Permissions.FileIOPermission> вызов неуправляемого кода, не нуждается в доступе к файлу; он может просто вызвать неуправляемый (Win32) файл API напрямую, минуя управляемый API файлов, который требует **FileIOPermission.** Если управляемый код имеет разрешение на вызов неуправляемого кода и производит его прямой вызов, система безопасности не может уверенно обеспечивать ограничения безопасности, так как среда выполнения не может применять эти ограничения к неуправляемому коду.

Если необходимо, чтобы приложение выполняло операции, требующие доступа к неуправляемому коду, оно должно делать это через доверенный управляемый класс, предоставляющий оболочку для требуемой функциональности (если такой класс существует). Не создавайте класс-оболочку самостоятельно, если он уже имеется в безопасной библиотеке классов. Класс-оболочка, которому нужно предоставить высокий уровень доверия, чтобы он мог вызывать неуправляемый код, отвечает за обеспечение наличия у вызывающих объектов соответствующих разрешений. Если вы используете класс-оболочку, коду необходимо запросить и получить только те разрешения, которые требуются этому классу.

## <a name="see-also"></a>См. также раздел

- <xref:System.Security.PermissionSet>
- <xref:System.Security.Permissions.FileIOPermission>
- <xref:System.Security.NamedPermissionSet>
- <xref:System.Security.Permissions.SecurityAction>
- [Assert](using-the-assert-method.md)
- [Безопасность доступа к коду](code-access-security.md)
- [Основы управления доступом для кода](code-access-security-basics.md)
- [Атрибуты](../../standard/attributes/index.md)
- [Метаданные и самоописывающие компоненты](../../standard/metadata-and-self-describing-components.md)
