---
title: Основы управления доступом для кода
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- security [.NET Framework], code access security
ms.assetid: 4eaa6535-d9fe-41a1-91d8-b437cfc16921
ms.openlocfilehash: 08d708e8f98bd2fe06757df3033a512e2fe1f3c2
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "79400995"
---
# <a name="code-access-security-basics"></a><span data-ttu-id="1da3c-102">Основы управления доступом для кода</span><span class="sxs-lookup"><span data-stu-id="1da3c-102">Code Access Security Basics</span></span>

[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]

<span data-ttu-id="1da3c-103">Каждое приложение, ориентированное на среду CLR (то есть каждое управляемое приложение), должно взаимодействовать с ее системой безопасности.</span><span class="sxs-lookup"><span data-stu-id="1da3c-103">Every application that targets the common language runtime (that is, every managed application) must interact with the runtime's security system.</span></span> <span data-ttu-id="1da3c-104">Когда управляемое приложение загружается, его узел автоматически предоставляет ему набор разрешений.</span><span class="sxs-lookup"><span data-stu-id="1da3c-104">When a managed application is loaded, its host automatically grants it a set of permissions.</span></span> <span data-ttu-id="1da3c-105">Эти разрешения определяются параметрами локальной безопасности узла или изоляцией приложения.</span><span class="sxs-lookup"><span data-stu-id="1da3c-105">These permissions are determined by the host's local security settings or by the sandbox the application is in.</span></span> <span data-ttu-id="1da3c-106">В зависимости от этих разрешений приложение либо запускается, либо вызывает исключение безопасности.</span><span class="sxs-lookup"><span data-stu-id="1da3c-106">Depending on these permissions, the application either runs properly or generates a security exception.</span></span>

<span data-ttu-id="1da3c-107">Узел по умолчанию для классических приложений позволяет коду выполняться в режиме полного доверия.</span><span class="sxs-lookup"><span data-stu-id="1da3c-107">The default host for desktop applications allows code to run in full trust.</span></span> <span data-ttu-id="1da3c-108">По этой причине, если приложение предназначено для настольных компьютеров, оно имеет неограниченный набор разрешений.</span><span class="sxs-lookup"><span data-stu-id="1da3c-108">Therefore, if your application targets the desktop, it has an unrestricted permission set.</span></span> <span data-ttu-id="1da3c-109">Другие узлы или "песочницы" предоставляют ограниченный набор разрешений для приложений.</span><span class="sxs-lookup"><span data-stu-id="1da3c-109">Other hosts or sandboxes provide a limited permission set for applications.</span></span> <span data-ttu-id="1da3c-110">Набор разрешений может меняться от узла к узлу, поэтому приложение должно быть разработано для использования только тех разрешений, которые допускаются целевым узлом.</span><span class="sxs-lookup"><span data-stu-id="1da3c-110">Because the permission set can change from host to host, you must design your application to use only the permissions that your target host allows.</span></span>

<span data-ttu-id="1da3c-111">Чтобы писать эффективные приложения, нацеленные на среду CLR, нужно быть знакомым с приведенными ниже принципами управления доступом для кода.</span><span class="sxs-lookup"><span data-stu-id="1da3c-111">You must be familiar with the following code access security concepts in order to write effective applications that target the common language runtime:</span></span>

- <span data-ttu-id="1da3c-112">**Код, безопасный**для типов: Код типа-безопасный — это код, который получает доступ к типам только четко определенными, допустимыми способами.</span><span class="sxs-lookup"><span data-stu-id="1da3c-112">**Type-safe code**: Type-safe code is code that accesses types only in well-defined, allowable ways.</span></span> <span data-ttu-id="1da3c-113">Например, имея действительную ссылку на объект, типобезопасный код может осуществлять доступ к памяти по фиксированным смещениям, соответствующим реальным членам-полям.</span><span class="sxs-lookup"><span data-stu-id="1da3c-113">For example, given a valid object reference, type-safe code can access memory at fixed offsets that correspond to actual field members.</span></span> <span data-ttu-id="1da3c-114">Если код производит доступ к памяти по произвольным смещениям за пределами диапазона памяти, принадлежащего открытым полям этого объекта, он не является типобезопасным.</span><span class="sxs-lookup"><span data-stu-id="1da3c-114">If the code accesses memory at arbitrary offsets outside the range of memory that belongs to that object's publicly exposed fields, it is not type-safe.</span></span> <span data-ttu-id="1da3c-115">Чтобы иметь возможность пользоваться преимуществами управления доступом для кода, необходимо использовать компилятор, создающий проверяемый типобезопасный код.</span><span class="sxs-lookup"><span data-stu-id="1da3c-115">To enable code to benefit from code access security, you must use a compiler that generates verifiably type-safe code.</span></span> <span data-ttu-id="1da3c-116">Для получения дополнительной информации смотрите раздел [«Написать проверяемо тип-безопасный код»](#typesafe_code) позже в этой теме.</span><span class="sxs-lookup"><span data-stu-id="1da3c-116">For more information, see the [Writing Verifiably Type-Safe Code](#typesafe_code) section later in this topic.</span></span>

- <span data-ttu-id="1da3c-117">**Императивный и декларативный синтаксис**: Код, нацеленный на общее время выполнения языка, может взаимодействовать с системой безопасности, запрашивая разрешения, требуя, чтобы абоненты указали разрешения, и переопределяет определенные параметры безопасности (с учетом достаточного количества привилегий).</span><span class="sxs-lookup"><span data-stu-id="1da3c-117">**Imperative and declarative syntax**: Code that targets the common language runtime can interact with the security system by requesting permissions, demanding that callers have specified permissions, and overriding certain security settings (given enough privileges).</span></span> <span data-ttu-id="1da3c-118">Можно использовать две различные формы синтаксиса для программного взаимодействия с системой безопасности .NET Framework: декларативный синтаксис и принудительный синтаксис.</span><span class="sxs-lookup"><span data-stu-id="1da3c-118">You use two forms of syntax to programmatically interact with the .NET Framework security system: declarative syntax and imperative syntax.</span></span> <span data-ttu-id="1da3c-119">Декларативные вызовы выполняются с использованием атрибутов; принудительные вызовы выполняются с использованием новых экземпляров классов в вашем коде.</span><span class="sxs-lookup"><span data-stu-id="1da3c-119">Declarative calls are performed using attributes; imperative calls are performed using new instances of classes within your code.</span></span> <span data-ttu-id="1da3c-120">Некоторые вызовы могут выполняться только принудительно, другие — только декларативно, а некоторые — любым способом.</span><span class="sxs-lookup"><span data-stu-id="1da3c-120">Some calls can be performed only imperatively, others can be performed only declaratively, and some calls can be performed in either manner.</span></span>

- <span data-ttu-id="1da3c-121">**Безопасные библиотеки классов:** Безопасная библиотека класса использует требования безопасности для обеспечения того, чтобы абоненты библиотеки имели разрешение на доступ к ресурсам, которые предоставляет библиотека.</span><span class="sxs-lookup"><span data-stu-id="1da3c-121">**Secure class libraries**: A secure class library uses security demands to ensure that the library's callers have permission to access the resources that the library exposes.</span></span> <span data-ttu-id="1da3c-122">Например, безопасная библиотека классов может содержать метод для создания файлов, который будет требовать, чтобы вызывающие его объекты обладали разрешениями на создание файлов.</span><span class="sxs-lookup"><span data-stu-id="1da3c-122">For example, a secure class library might have a method for creating files that would demand that its callers have permissions to create files.</span></span> <span data-ttu-id="1da3c-123">Платформа .NET Framework включает в себя безопасные библиотеки классов.</span><span class="sxs-lookup"><span data-stu-id="1da3c-123">The .NET Framework consists of secure class libraries.</span></span> <span data-ttu-id="1da3c-124">Вам необходимо учитывать разрешения, требуемые для доступа к любой библиотеке, используемой кодом.</span><span class="sxs-lookup"><span data-stu-id="1da3c-124">You should be aware of the permissions required to access any library that your code uses.</span></span> <span data-ttu-id="1da3c-125">Для получения дополнительной информации смотрите раздел [«Использование безопасных библиотек класса»](#secure_library) позже в этой теме.</span><span class="sxs-lookup"><span data-stu-id="1da3c-125">For more information, see the [Using Secure Class Libraries](#secure_library) section later in this topic.</span></span>

- <span data-ttu-id="1da3c-126">**Прозрачный код**: Начиная с .NET Framework 4, в дополнение к идентификации конкретных разрешений, необходимо также определить, должен ли код работать как прозрачный для безопасности.</span><span class="sxs-lookup"><span data-stu-id="1da3c-126">**Transparent code**: Starting with the .NET Framework 4, in addition to identifying specific permissions, you must also determine whether your code should run as security-transparent.</span></span> <span data-ttu-id="1da3c-127">Прозрачный с точки зрения безопасности код не может вызывать типы или члены, которые определены как критические с точки зрения безопасности.</span><span class="sxs-lookup"><span data-stu-id="1da3c-127">Security-transparent code cannot call types or members that are identified as security-critical.</span></span> <span data-ttu-id="1da3c-128">Это правило относится к приложениям как с полным, так и с частичным доверием.</span><span class="sxs-lookup"><span data-stu-id="1da3c-128">This rule applies to full-trust applications as well as partially trusted applications.</span></span> <span data-ttu-id="1da3c-129">Для получения дополнительной информации [см.](security-transparent-code.md)</span><span class="sxs-lookup"><span data-stu-id="1da3c-129">For more information, see [Security-Transparent Code](security-transparent-code.md).</span></span>

<a name="typesafe_code"></a>

## <a name="writing-verifiably-type-safe-code"></a><span data-ttu-id="1da3c-130">Написание проверяемого типобезопасного кода</span><span class="sxs-lookup"><span data-stu-id="1da3c-130">Writing Verifiably Type-Safe Code</span></span>

<span data-ttu-id="1da3c-131">JIT-компиляция выполняет процесс проверки, который анализирует код и пытается определить, является ли он типобезопасным.</span><span class="sxs-lookup"><span data-stu-id="1da3c-131">Just-in-time (JIT) compilation performs a verification process that examines code and tries to determine whether the code is type-safe.</span></span> <span data-ttu-id="1da3c-132">Код, который доказан во время проверки как безопасный для типов, называется *проверяемым кодом типа.*</span><span class="sxs-lookup"><span data-stu-id="1da3c-132">Code that is proven during verification to be type-safe is called *verifiably type-safe code*.</span></span> <span data-ttu-id="1da3c-133">Код может быть типобезопасным, но не проверяемым типобезопасным из-за ограничений процесса проверки его компилятором.</span><span class="sxs-lookup"><span data-stu-id="1da3c-133">Code can be type-safe, yet might not be verifiably type-safe because of the limitations of the verification process or of the compiler.</span></span> <span data-ttu-id="1da3c-134">Не все языки являются типобезопасными, и компиляторы некоторых языков, таких как Microsoft Visual C++, не могут создавать проверяемый типобезопасный код.</span><span class="sxs-lookup"><span data-stu-id="1da3c-134">Not all languages are type-safe, and some language compilers, such as Microsoft Visual C++, cannot generate verifiably type-safe managed code.</span></span> <span data-ttu-id="1da3c-135">Чтобы определить, создает ли компилятор языка, который вы используете, проверяемый типобезопасный код, нужно свериться с документацией по компилятору.</span><span class="sxs-lookup"><span data-stu-id="1da3c-135">To determine whether the language compiler you use generates verifiably type-safe code, consult the compiler's documentation.</span></span> <span data-ttu-id="1da3c-136">Если вы используете компилятор языка, который генерирует проверяемо типовый код только при избегании определенных языковых конструкций, вы можете использовать [инструмент PEVerify,](../tools/peverify-exe-peverify-tool.md) чтобы определить, является ли ваш код проверяемо безопасным для типов.</span><span class="sxs-lookup"><span data-stu-id="1da3c-136">If you use a language compiler that generates verifiably type-safe code only when you avoid certain language constructs, you might want to use the [PEVerify tool](../tools/peverify-exe-peverify-tool.md) to determine whether your code is verifiably type-safe.</span></span>

<span data-ttu-id="1da3c-137">Код, не являющийся проверяемым типобезопасным, может осуществить попытку выполнения, если политика безопасности позволяет коду обойти проверку.</span><span class="sxs-lookup"><span data-stu-id="1da3c-137">Code that is not verifiably type-safe can attempt to execute if security policy allows the code to bypass verification.</span></span> <span data-ttu-id="1da3c-138">Однако, так как строгая типизация является неотъемлемой частью механизма среды выполнения для изоляции сборок, безопасность не может уверенно соблюдаться, если код нарушает правила типобезопасности.</span><span class="sxs-lookup"><span data-stu-id="1da3c-138">However, because type safety is an essential part of the runtime's mechanism for isolating assemblies, security cannot be reliably enforced if code violates the rules of type safety.</span></span> <span data-ttu-id="1da3c-139">По умолчанию код, не являющийся типобезопасным, допускается к выполнению, только если его источником является локальный компьютер.</span><span class="sxs-lookup"><span data-stu-id="1da3c-139">By default, code that is not type-safe is allowed to run only if it originates from the local computer.</span></span> <span data-ttu-id="1da3c-140">Поэтому мобильный код должен быть типобезопасным.</span><span class="sxs-lookup"><span data-stu-id="1da3c-140">Therefore, mobile code should be type-safe.</span></span>

<a name="secure_library"></a>

## <a name="using-secure-class-libraries"></a><span data-ttu-id="1da3c-141">Использование безопасных библиотек классов</span><span class="sxs-lookup"><span data-stu-id="1da3c-141">Using Secure Class Libraries</span></span>

<span data-ttu-id="1da3c-142">Если код запрашивает и получает разрешения, требуемые библиотекой классов, ему будет разрешен доступ к библиотеке и ресурс будет защищен от несанкционированного доступа.</span><span class="sxs-lookup"><span data-stu-id="1da3c-142">If your code requests and is granted the permissions required by the class library, it will be allowed to access the library and the resources that the library exposes will be protected from unauthorized access.</span></span> <span data-ttu-id="1da3c-143">Если же код не будет обладать соответствующими разрешениями, он не сможет получить доступ к библиотеке и вредоносный код не сможет воспользоваться вашим кодом для непрямого доступа к защищенным ресурсам.</span><span class="sxs-lookup"><span data-stu-id="1da3c-143">If your code does not have the appropriate permissions, it will not be allowed to access the class library, and malicious code will not be able to use your code to indirectly access protected resources.</span></span> <span data-ttu-id="1da3c-144">Даже если ваш код получит разрешение на доступ к библиотеке, его запуск не будет разрешен,</span><span class="sxs-lookup"><span data-stu-id="1da3c-144">Other code that calls your code must also have permission to access the library.</span></span> <span data-ttu-id="1da3c-145">если код, вызвавший его, также не обладает разрешением на доступ к этой библиотеке.</span><span class="sxs-lookup"><span data-stu-id="1da3c-145">If it does not, your code will be restricted from running as well.</span></span>

<span data-ttu-id="1da3c-146">Управление доступом для кода не исключает вероятности человеческой ошибки при написании кода.</span><span class="sxs-lookup"><span data-stu-id="1da3c-146">Code access security does not eliminate the possibility of human error in writing code.</span></span> <span data-ttu-id="1da3c-147">Но если приложение использует безопасные библиотеки классов для доступа к защищенным ресурсам, риск для безопасности кода приложения снижается, так как библиотеки классов тщательно изучаются на предмет потенциальных проблем безопасности.</span><span class="sxs-lookup"><span data-stu-id="1da3c-147">However, if your application uses secure class libraries to access protected resources, the security risk for application code is decreased, because class libraries are closely scrutinized for potential security problems.</span></span>

## <a name="declarative-security"></a><span data-ttu-id="1da3c-148">Декларативная безопасность</span><span class="sxs-lookup"><span data-stu-id="1da3c-148">Declarative Security</span></span>

<span data-ttu-id="1da3c-149">Декларативный синтаксис безопасности использует [атрибуты](../../standard/attributes/index.md) для размещения информации о безопасности в [метаданных](../../standard/metadata-and-self-describing-components.md) вашего кода.</span><span class="sxs-lookup"><span data-stu-id="1da3c-149">Declarative security syntax uses [attributes](../../standard/attributes/index.md) to place security information into the [metadata](../../standard/metadata-and-self-describing-components.md) of your code.</span></span> <span data-ttu-id="1da3c-150">Атрибуты могут быть указаны на уровне сборки, класса или члена для указания типа запроса, требования или переопределения, которые необходимо использовать.</span><span class="sxs-lookup"><span data-stu-id="1da3c-150">Attributes can be placed at the assembly, class, or member level, to indicate the type of request, demand, or override you want to use.</span></span> <span data-ttu-id="1da3c-151">Запросы используются в приложениях, нацеленных на среду CLR, для информирования системы безопасности среды выполнения о разрешениях, которые нужны или не нужны вашему приложению.</span><span class="sxs-lookup"><span data-stu-id="1da3c-151">Requests are used in applications that target the common language runtime to inform the runtime security system about the permissions that your application needs or does not want.</span></span> <span data-ttu-id="1da3c-152">Требования и переопределения используются в библиотеках для защиты ресурсов от вызывающих объектов или переопределения поведения системы безопасности по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="1da3c-152">Demands and overrides are used in libraries to help protect resources from callers or to override default security behavior.</span></span>

> [!NOTE]
> <span data-ttu-id="1da3c-153">В рамках .NET Framework 4 произошли важные изменения в модели безопасности и терминологии .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="1da3c-153">In the .NET Framework 4, there have been important changes to the .NET Framework security model and terminology.</span></span> <span data-ttu-id="1da3c-154">Для получения дополнительной информации об этих изменениях [см.](../security/security-changes.md)</span><span class="sxs-lookup"><span data-stu-id="1da3c-154">For more information about these changes, see [Security Changes](../security/security-changes.md).</span></span>

<span data-ttu-id="1da3c-155">Чтобы использовать декларативные вызовы безопасности, необходимо инициализировать данные состояния объекта разрешения таким образом, чтобы они представляли определенную форму необходимого разрешения.</span><span class="sxs-lookup"><span data-stu-id="1da3c-155">In order to use declarative security calls, you must initialize the state data of the permission object so that it represents the particular form of permission you need.</span></span> <span data-ttu-id="1da3c-156">Каждое встроенное разрешение имеет атрибут, которому передается перечисление <xref:System.Security.Permissions.SecurityAction> для описания типа операции безопасности, которую нужно выполнить.</span><span class="sxs-lookup"><span data-stu-id="1da3c-156">Every built-in permission has an attribute that is passed a <xref:System.Security.Permissions.SecurityAction> enumeration to describe the type of security operation you want to perform.</span></span> <span data-ttu-id="1da3c-157">Однако разрешения также принимают собственные параметры, являющиеся для них исключительными.</span><span class="sxs-lookup"><span data-stu-id="1da3c-157">However, permissions also accept their own parameters that are exclusive to them.</span></span>

<span data-ttu-id="1da3c-158">В приведенном ниже фрагменте кода показано использование декларативного синтаксиса для запроса наличия у вызывающих объектов кода пользовательского разрешения `MyPermission`.</span><span class="sxs-lookup"><span data-stu-id="1da3c-158">The following code fragment shows declarative syntax for requesting that your code's callers have a custom permission called `MyPermission`.</span></span> <span data-ttu-id="1da3c-159">Это гипотетическое разрешение, которого не существует в .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="1da3c-159">This permission is a hypothetical custom permission and does not exist in the .NET Framework.</span></span> <span data-ttu-id="1da3c-160">В этом примере декларативный вызов помещен непосредственно перед определением класса, указывая, что разрешение применяется на уровне класса.</span><span class="sxs-lookup"><span data-stu-id="1da3c-160">In this example, the declarative call is placed directly before the class definition, specifying that this permission be applied to the class level.</span></span> <span data-ttu-id="1da3c-161">Атрибут передается в структуру **SecurityAction.Demand,** чтобы указать, что для запуска абоненты должны иметь это разрешение.</span><span class="sxs-lookup"><span data-stu-id="1da3c-161">The attribute is passed a **SecurityAction.Demand** structure to specify that callers must have this permission in order to run.</span></span>

```vb
<MyPermission(SecurityAction.Demand, Unrestricted = True)> Public Class MyClass1

   Public Sub New()
      'The constructor is protected by the security call.
   End Sub

   Public Sub MyMethod()
      'This method is protected by the security call.
   End Sub

   Public Sub YourMethod()
      'This method is protected by the security call.
   End Sub
End Class
```

```csharp
[MyPermission(SecurityAction.Demand, Unrestricted = true)]
public class MyClass
{
   public MyClass()
   {
      //The constructor is protected by the security call.
   }

   public void MyMethod()
   {
      //This method is protected by the security call.
   }

   public void YourMethod()
   {
      //This method is protected by the security call.
   }
}
```

## <a name="imperative-security"></a><span data-ttu-id="1da3c-162">Принудительная безопасность</span><span class="sxs-lookup"><span data-stu-id="1da3c-162">Imperative Security</span></span>

<span data-ttu-id="1da3c-163">Принудительный синтаксис безопасности производит вызов безопасности, создавая экземпляр объекта разрешения, который нужно вызвать.</span><span class="sxs-lookup"><span data-stu-id="1da3c-163">Imperative security syntax issues a security call by creating a new instance of the permission object you want to invoke.</span></span> <span data-ttu-id="1da3c-164">Принудительный синтаксис можно использовать для выполнения требований и переопределений, но не запросов.</span><span class="sxs-lookup"><span data-stu-id="1da3c-164">You can use imperative syntax to perform demands and overrides, but not requests.</span></span>

<span data-ttu-id="1da3c-165">Прежде чем осуществить вызов безопасности, необходимо инициализировать данные состояния объекта разрешения, чтобы они представляли определенную форму необходимого разрешения.</span><span class="sxs-lookup"><span data-stu-id="1da3c-165">Before you make the security call, you must initialize the state data of the permission object so that it represents the particular form of the permission you need.</span></span> <span data-ttu-id="1da3c-166">Например, при <xref:System.Security.Permissions.FileIOPermission> создании объекта можно использовать конструктор для инициализации объекта **FileIOPermission** таким образом, чтобы он был либо неограниченным доступом ко всем файлам, либо отсутствием доступа к файлам.</span><span class="sxs-lookup"><span data-stu-id="1da3c-166">For example, when creating a <xref:System.Security.Permissions.FileIOPermission> object, you can use the constructor to initialize the **FileIOPermission** object so that it represents either unrestricted access to all files or no access to files.</span></span> <span data-ttu-id="1da3c-167">Или можно использовать другой объект **FileIOPermission,** передавая параметры, указывающие тип доступа, который вы хотите, чтобы объект представлял (т.е. прочитайте, приготовив или напишите) и какие файлы вы хотите защитить.</span><span class="sxs-lookup"><span data-stu-id="1da3c-167">Or, you can use a different **FileIOPermission** object, passing parameters that indicate the type of access you want the object to represent (that is, read, append, or write) and what files you want the object to protect.</span></span>

<span data-ttu-id="1da3c-168">Помимо вызова отдельного объекта безопасности, принудительный синтаксис безопасности можно использовать для инициализации группы разрешений, называемой набором разрешений.</span><span class="sxs-lookup"><span data-stu-id="1da3c-168">In addition to using imperative security syntax to invoke a single security object, you can use it to initialize a group of permissions in a permission set.</span></span> <span data-ttu-id="1da3c-169">Например, этот метод является единственным способом [надежного](using-the-assert-method.md) выполнения утверждений вызовов на нескольких разрешениях в одном методе.</span><span class="sxs-lookup"><span data-stu-id="1da3c-169">For example, this technique is the only way to reliably perform [assert](using-the-assert-method.md) calls on multiple permissions in one method.</span></span> <span data-ttu-id="1da3c-170">Используйте классы <xref:System.Security.PermissionSet> и <xref:System.Security.NamedPermissionSet> для создания группы разрешений, после чего вызовите соответствующий метод для выполнения желаемого вызова безопасности.</span><span class="sxs-lookup"><span data-stu-id="1da3c-170">Use the <xref:System.Security.PermissionSet> and <xref:System.Security.NamedPermissionSet> classes to create a group of permissions and then call the appropriate method to invoke the desired security call.</span></span>

<span data-ttu-id="1da3c-171">Принудительный синтаксис можно использовать для выполнения требований и переопределений, но не запросов.</span><span class="sxs-lookup"><span data-stu-id="1da3c-171">You can use imperative syntax to perform demands and overrides, but not requests.</span></span> <span data-ttu-id="1da3c-172">Вы можете использовать принудительный синтаксис для требований и переопределений вместо декларативного синтаксиса, когда информация, необходимая для инициализации состояния разрешения, становится известна только во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="1da3c-172">You might use imperative syntax for demands and overrides instead of declarative syntax when information that you need in order to initialize the permission state becomes known only at run time.</span></span> <span data-ttu-id="1da3c-173">Например, если нужно обеспечить наличие у вызывающих объектов разрешений на чтение определенного файла, но его имя неизвестно до запуска, используйте принудительное требование.</span><span class="sxs-lookup"><span data-stu-id="1da3c-173">For example, if you want to ensure that callers have permission to read a certain file, but you do not know the name of that file until run time, use an imperative demand.</span></span> <span data-ttu-id="1da3c-174">Вы также можете выбрать использование принудительных проверок вместо декларативных, когда нужно во время выполнения определить, имеет ли место некоторое условие, и на основании результата проверки предъявить (или же не предъявлять) требование безопасности.</span><span class="sxs-lookup"><span data-stu-id="1da3c-174">You might also choose to use imperative checks instead of declarative checks when you need to determine at run time whether a condition holds and, based on the result of the test, make a security demand (or not).</span></span>

<span data-ttu-id="1da3c-175">В приведенном ниже фрагменте кода показано использование принудительного синтаксиса для запроса наличия у вызывающих объектов кода пользовательского разрешения `MyPermission`.</span><span class="sxs-lookup"><span data-stu-id="1da3c-175">The following code fragment shows imperative syntax for requesting that your code's callers have a custom permission called `MyPermission`.</span></span> <span data-ttu-id="1da3c-176">Это гипотетическое разрешение, которого не существует в .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="1da3c-176">This permission is a hypothetical custom permission and does not exist in the .NET Framework.</span></span> <span data-ttu-id="1da3c-177">Экземпляр `MyPermission` создается в методе `MyMethod`, защищая вызовом безопасности только этот метод.</span><span class="sxs-lookup"><span data-stu-id="1da3c-177">A new instance of `MyPermission` is created in `MyMethod`, guarding only this method with the security call.</span></span>

```vb
Public Class MyClass1

   Public Sub New()

   End Sub

   Public Sub MyMethod()
      'MyPermission is demanded using imperative syntax.
      Dim Perm As New MyPermission()
      Perm.Demand()
      'This method is protected by the security call.
   End Sub

   Public Sub YourMethod()
      'YourMethod 'This method is not protected by the security call.
   End Sub
End Class
```

```csharp
public class MyClass {
   public MyClass(){

   }

   public void MyMethod() {
       //MyPermission is demanded using imperative syntax.
       MyPermission Perm = new MyPermission();
       Perm.Demand();
       //This method is protected by the security call.
   }

   public void YourMethod() {
       //This method is not protected by the security call.
   }
}
```

## <a name="using-managed-wrapper-classes"></a><span data-ttu-id="1da3c-178">Использование управляемых классов-оболочек</span><span class="sxs-lookup"><span data-stu-id="1da3c-178">Using Managed Wrapper Classes</span></span>

<span data-ttu-id="1da3c-179">Большинство приложений и компонентов (кроме безопасных библиотек) не должны напрямую вызывать неуправляемый код.</span><span class="sxs-lookup"><span data-stu-id="1da3c-179">Most applications and components (except secure libraries) should not directly call unmanaged code.</span></span> <span data-ttu-id="1da3c-180">Для этого есть несколько причин.</span><span class="sxs-lookup"><span data-stu-id="1da3c-180">There are several reasons for this.</span></span> <span data-ttu-id="1da3c-181">Если код вызывает неуправляемый код напрямую, во многих ситуациях ему не будет разрешено выполняться, потому что он должен обладать высоким уровнем доверия, чтобы вызывать машинный код.</span><span class="sxs-lookup"><span data-stu-id="1da3c-181">If code calls unmanaged code directly, it will not be allowed to run in many circumstances because code must be granted a high level of trust to call native code.</span></span> <span data-ttu-id="1da3c-182">Если политика будет изменена с целью разрешить запуск подобного приложения, это может заметно ослабить безопасность системы, так как приложение сможет выполнять практически любые операции.</span><span class="sxs-lookup"><span data-stu-id="1da3c-182">If policy is modified to allow such an application to run, it can significantly weaken the security of the system, leaving the application free to perform almost any operation.</span></span>

<span data-ttu-id="1da3c-183">Кроме того, код, имеющий разрешение на доступ к неуправляемому коду, может выполнить почти любую операцию, вызвав неуправляемый интерфейс API.</span><span class="sxs-lookup"><span data-stu-id="1da3c-183">Additionally, code that has permission to access unmanaged code can probably perform almost any operation by calling into an unmanaged API.</span></span> <span data-ttu-id="1da3c-184">Например, код, который имеет разрешение на <xref:System.Security.Permissions.FileIOPermission> вызов неуправляемого кода, не нуждается в доступе к файлу; он может просто вызвать неуправляемый (Win32) файл API напрямую, минуя управляемый API файлов, который требует **FileIOPermission.**</span><span class="sxs-lookup"><span data-stu-id="1da3c-184">For example, code that has permission to call unmanaged code does not need <xref:System.Security.Permissions.FileIOPermission> to access a file; it can just call an unmanaged (Win32) file API directly, bypassing the managed file API that requires **FileIOPermission**.</span></span> <span data-ttu-id="1da3c-185">Если управляемый код имеет разрешение на вызов неуправляемого кода и производит его прямой вызов, система безопасности не может уверенно обеспечивать ограничения безопасности, так как среда выполнения не может применять эти ограничения к неуправляемому коду.</span><span class="sxs-lookup"><span data-stu-id="1da3c-185">If managed code has permission to call into unmanaged code and does call directly into unmanaged code, the security system will be unable to reliably enforce security restrictions, since the runtime cannot enforce such restrictions on unmanaged code.</span></span>

<span data-ttu-id="1da3c-186">Если необходимо, чтобы приложение выполняло операции, требующие доступа к неуправляемому коду, оно должно делать это через доверенный управляемый класс, предоставляющий оболочку для требуемой функциональности (если такой класс существует).</span><span class="sxs-lookup"><span data-stu-id="1da3c-186">If you want your application to perform an operation that requires accessing unmanaged code, it should do so through a trusted managed class that wraps the required functionality (if such a class exists).</span></span> <span data-ttu-id="1da3c-187">Не создавайте класс-оболочку самостоятельно, если он уже имеется в безопасной библиотеке классов.</span><span class="sxs-lookup"><span data-stu-id="1da3c-187">Do not create a wrapper class yourself if one already exists in a secure class library.</span></span> <span data-ttu-id="1da3c-188">Класс-оболочка, которому нужно предоставить высокий уровень доверия, чтобы он мог вызывать неуправляемый код, отвечает за обеспечение наличия у вызывающих объектов соответствующих разрешений.</span><span class="sxs-lookup"><span data-stu-id="1da3c-188">The wrapper class, which must be granted a high degree of trust to be allowed to make the call into unmanaged code, is responsible for demanding that its callers have the appropriate permissions.</span></span> <span data-ttu-id="1da3c-189">Если вы используете класс-оболочку, коду необходимо запросить и получить только те разрешения, которые требуются этому классу.</span><span class="sxs-lookup"><span data-stu-id="1da3c-189">If you use the wrapper class, your code only needs to request and be granted the permissions that the wrapper class demands.</span></span>

## <a name="see-also"></a><span data-ttu-id="1da3c-190">См. также раздел</span><span class="sxs-lookup"><span data-stu-id="1da3c-190">See also</span></span>

- <xref:System.Security.PermissionSet>
- <xref:System.Security.Permissions.FileIOPermission>
- <xref:System.Security.NamedPermissionSet>
- <xref:System.Security.Permissions.SecurityAction>
- [<span data-ttu-id="1da3c-191">Assert</span><span class="sxs-lookup"><span data-stu-id="1da3c-191">Assert</span></span>](using-the-assert-method.md)
- [<span data-ttu-id="1da3c-192">Безопасность доступа к коду</span><span class="sxs-lookup"><span data-stu-id="1da3c-192">Code Access Security</span></span>](code-access-security.md)
- [<span data-ttu-id="1da3c-193">Основы управления доступом для кода</span><span class="sxs-lookup"><span data-stu-id="1da3c-193">Code Access Security Basics</span></span>](code-access-security-basics.md)
- [<span data-ttu-id="1da3c-194">Атрибуты</span><span class="sxs-lookup"><span data-stu-id="1da3c-194">Attributes</span></span>](../../standard/attributes/index.md)
- [<span data-ttu-id="1da3c-195">Метаданные и компоненты с самоописанием</span><span class="sxs-lookup"><span data-stu-id="1da3c-195">Metadata and Self-Describing Components</span></span>](../../standard/metadata-and-self-describing-components.md)
