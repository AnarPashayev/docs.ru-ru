---
title: Основы управления доступом для кода
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- security [.NET Framework], code access security
ms.assetid: 4eaa6535-d9fe-41a1-91d8-b437cfc16921
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 3c41becaa149b933d46a01f6ada0ea4b29b68fe8
ms.sourcegitcommit: 155012a8a826ee8ab6aa49b1b3a3b532e7b7d9bd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/04/2019
ms.locfileid: "66488035"
---
# <a name="code-access-security-basics"></a>Основы управления доступом для кода

[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]

Каждое приложение, ориентированное на среду CLR (то есть каждое управляемое приложение), должно взаимодействовать с ее системой безопасности. Когда управляемое приложение загружается, его узел автоматически предоставляет ему набор разрешений. Эти разрешения определяются параметрами локальной безопасности узла или изоляцией приложения. В зависимости от этих разрешений приложение либо запускается, либо вызывает исключение безопасности.

Узел по умолчанию для классических приложений позволяет коду выполняться в режиме полного доверия. По этой причине, если приложение предназначено для настольных компьютеров, оно имеет неограниченный набор разрешений. Другие узлы или "песочницы" предоставляют ограниченный набор разрешений для приложений. Набор разрешений может меняться от узла к узлу, поэтому приложение должно быть разработано для использования только тех разрешений, которые допускаются целевым узлом.

Чтобы писать эффективные приложения, нацеленные на среду CLR, нужно быть знакомым с приведенными ниже принципами управления доступом для кода.

- **Типобезопасный код**: Типобезопасный код приведен код, который обращается к типам только строго определенными, допустимыми способами. Например, имея действительную ссылку на объект, типобезопасный код может осуществлять доступ к памяти по фиксированным смещениям, соответствующим реальным членам-полям. Если код производит доступ к памяти по произвольным смещениям за пределами диапазона памяти, принадлежащего открытым полям этого объекта, он не является типобезопасным. Чтобы иметь возможность пользоваться преимуществами управления доступом для кода, необходимо использовать компилятор, создающий проверяемый типобезопасный код. Дополнительные сведения см. в разделе [Написание проверяемого строго типизированным кода](#typesafe_code) подразделе данного раздела.

- **Принудительный и декларативный синтаксис**: Код, нацеленный среда CLR может взаимодействовать с системой безопасности путем запроса разрешений, требования определенных разрешений от вызывающих объектов, а также путем переопределения некоторых параметров безопасности (при наличии достаточных полномочий). Можно использовать две различные формы синтаксиса для программного взаимодействия с системой безопасности .NET Framework: декларативный синтаксис и принудительный синтаксис. Декларативные вызовы выполняются с использованием атрибутов; принудительные вызовы выполняются с использованием новых экземпляров классов в вашем коде. Некоторые вызовы могут выполняться только принудительно, другие — только декларативно, а некоторые — любым способом.

- **Безопасные библиотеки классов**: Безопасная библиотека классов использует требования безопасности, чтобы убедиться, что вызывающие объекты библиотеки имеют разрешение на доступ к ресурсам, предоставляемым библиотекой. Например, безопасная библиотека классов может содержать метод для создания файлов, который будет требовать, чтобы вызывающие его объекты обладали разрешениями на создание файлов. Платформа .NET Framework включает в себя безопасные библиотеки классов. Вам необходимо учитывать разрешения, требуемые для доступа к любой библиотеке, используемой кодом. Дополнительные сведения см. в разделе [использование безопасных библиотек классов](#secure_library) подразделе данного раздела.

- **Прозрачный код**: Начиная с .NET Framework 4, в дополнение к определению соответствующих разрешений, необходимо также определить, должен ли код выполняться как прозрачный для системы безопасности. Прозрачный с точки зрения безопасности код не может вызывать типы или члены, которые определены как критические с точки зрения безопасности. Это правило относится к приложениям как с полным, так и с частичным доверием. Дополнительные сведения см. в разделе [прозрачный с точки зрения безопасности код](../../../docs/framework/misc/security-transparent-code.md).

<a name="typesafe_code"></a>

## <a name="writing-verifiably-type-safe-code"></a>Написание проверяемого типобезопасного кода

JIT-компиляция выполняет процесс проверки, который анализирует код и пытается определить, является ли он типобезопасным. Код, который в процессе проверки признается типобезопасным, называется *проверяемый типобезопасный код*. Код может быть типобезопасным, но не проверяемым типобезопасным из-за ограничений процесса проверки его компилятором. Не все языки являются типобезопасными, и компиляторы некоторых языков, таких как Microsoft Visual C++, не могут создавать проверяемый типобезопасный код. Чтобы определить, создает ли компилятор языка, который вы используете, проверяемый типобезопасный код, нужно свериться с документацией по компилятору. Если вы используете компилятор языка, создающий проверяемый типобезопасный код только в том случае, если вы избегаете определенных конструкций языка, вы можете использовать [средство PEVerify](../../../docs/framework/tools/peverify-exe-peverify-tool.md) для определения, является ли ваш код проверяемым типобезопасным.

Код, не являющийся проверяемым типобезопасным, может осуществить попытку выполнения, если политика безопасности позволяет коду обойти проверку. Однако, так как строгая типизация является неотъемлемой частью механизма среды выполнения для изоляции сборок, безопасность не может уверенно соблюдаться, если код нарушает правила типобезопасности. По умолчанию код, не являющийся типобезопасным, допускается к выполнению, только если его источником является локальный компьютер. Поэтому мобильный код должен быть типобезопасным.

<a name="secure_library"></a>

## <a name="using-secure-class-libraries"></a>Использование безопасных библиотек классов

Если код запрашивает и получает разрешения, требуемые библиотекой классов, ему будет разрешен доступ к библиотеке и ресурс будет защищен от несанкционированного доступа. Если же код не будет обладать соответствующими разрешениями, он не сможет получить доступ к библиотеке и вредоносный код не сможет воспользоваться вашим кодом для непрямого доступа к защищенным ресурсам. Даже если ваш код получит разрешение на доступ к библиотеке, его запуск не будет разрешен, если код, вызвавший его, также не обладает разрешением на доступ к этой библиотеке.

Управление доступом для кода не исключает вероятности человеческой ошибки при написании кода. Но если приложение использует безопасные библиотеки классов для доступа к защищенным ресурсам, риск для безопасности кода приложения снижается, так как библиотеки классов тщательно изучаются на предмет потенциальных проблем безопасности.

## <a name="declarative-security"></a>Декларативная безопасность

Декларативный синтаксис безопасности использует [атрибуты](../../../docs/standard/attributes/index.md) для размещения информации о безопасности в [метаданных](../../../docs/standard/metadata-and-self-describing-components.md) кода. Атрибуты могут быть указаны на уровне сборки, класса или члена для указания типа запроса, требования или переопределения, которые необходимо использовать. Запросы используются в приложениях, нацеленных на среду CLR, для информирования системы безопасности среды выполнения о разрешениях, которые нужны или не нужны вашему приложению. Требования и переопределения используются в библиотеках для защиты ресурсов от вызывающих объектов или переопределения поведения системы безопасности по умолчанию.

> [!NOTE]
> В .NET Framework 4 были внесены важные изменения в терминологии и модели безопасности .NET Framework. Дополнительные сведения об этих изменениях см. в разделе [изменения системы безопасности](../../../docs/framework/security/security-changes.md).

Чтобы использовать декларативные вызовы безопасности, необходимо инициализировать данные состояния объекта разрешения таким образом, чтобы они представляли определенную форму необходимого разрешения. Каждое встроенное разрешение имеет атрибут, которому передается перечисление <xref:System.Security.Permissions.SecurityAction> для описания типа операции безопасности, которую нужно выполнить. Однако разрешения также принимают собственные параметры, являющиеся для них исключительными.

В приведенном ниже фрагменте кода показано использование декларативного синтаксиса для запроса наличия у вызывающих объектов кода пользовательского разрешения `MyPermission`. Это гипотетическое разрешение, которого не существует в .NET Framework. В этом примере декларативный вызов помещен непосредственно перед определением класса, указывая, что разрешение применяется на уровне класса. Атрибуту передается **SecurityAction.Demand** структуры, чтобы указать, что вызывающие объекты должны иметь это разрешение для запуска.

```vb
<MyPermission(SecurityAction.Demand, Unrestricted = True)> Public Class MyClass1

   Public Sub New()
      'The constructor is protected by the security call.
   End Sub

   Public Sub MyMethod()
      'This method is protected by the security call.
   End Sub

   Public Sub YourMethod()
      'This method is protected by the security call.
   End Sub
End Class
```

```csharp
[MyPermission(SecurityAction.Demand, Unrestricted = true)]
public class MyClass
{
   public MyClass()
   {
      //The constructor is protected by the security call.
   }

   public void MyMethod()
   {
      //This method is protected by the security call.
   }

   public void YourMethod()
   {
      //This method is protected by the security call.
   }
}
```

## <a name="imperative-security"></a>Принудительная безопасность

Принудительный синтаксис безопасности производит вызов безопасности, создавая экземпляр объекта разрешения, который нужно вызвать. Принудительный синтаксис можно использовать для выполнения требований и переопределений, но не запросов.

Прежде чем осуществить вызов безопасности, необходимо инициализировать данные состояния объекта разрешения, чтобы они представляли определенную форму необходимого разрешения. Например, при создании <xref:System.Security.Permissions.FileIOPermission> объекта, можно использовать конструктор для инициализации **FileIOPermission** таким образом, чтобы он предоставлял неограниченный доступ ко всем файлам или нет доступа к файлам. Или можно использовать другой **FileIOPermission** объекта, передавая параметры, указывающие тип доступа, который объект для представления, (то есть, чтение, добавление или запись) и какие файлы нужно должен защищать объект.

Помимо вызова отдельного объекта безопасности, принудительный синтаксис безопасности можно использовать для инициализации группы разрешений, называемой набором разрешений. Например, этот метод является единственным способом для надежного выполнения [assert](../../../docs/framework/misc/using-the-assert-method.md) вызывает для нескольких разрешений в одном методе. Используйте классы <xref:System.Security.PermissionSet> и <xref:System.Security.NamedPermissionSet> для создания группы разрешений, после чего вызовите соответствующий метод для выполнения желаемого вызова безопасности.

Принудительный синтаксис можно использовать для выполнения требований и переопределений, но не запросов. Вы можете использовать принудительный синтаксис для требований и переопределений вместо декларативного синтаксиса, когда информация, необходимая для инициализации состояния разрешения, становится известна только во время выполнения. Например, если нужно обеспечить наличие у вызывающих объектов разрешений на чтение определенного файла, но его имя неизвестно до запуска, используйте принудительное требование. Вы также можете выбрать использование принудительных проверок вместо декларативных, когда нужно во время выполнения определить, имеет ли место некоторое условие, и на основании результата проверки предъявить (или же не предъявлять) требование безопасности.

В приведенном ниже фрагменте кода показано использование принудительного синтаксиса для запроса наличия у вызывающих объектов кода пользовательского разрешения `MyPermission`. Это гипотетическое разрешение, которого не существует в .NET Framework. Экземпляр `MyPermission` создается в методе `MyMethod`, защищая вызовом безопасности только этот метод.

```vb
Public Class MyClass1

   Public Sub New()

   End Sub

   Public Sub MyMethod()
      'MyPermission is demanded using imperative syntax.
      Dim Perm As New MyPermission()
      Perm.Demand()
      'This method is protected by the security call.
   End Sub

   Public Sub YourMethod()
      'YourMethod 'This method is not protected by the security call.
   End Sub
End Class
```

```csharp
public class MyClass {
   public MyClass(){

   }

   public void MyMethod() {
       //MyPermission is demanded using imperative syntax.
       MyPermission Perm = new MyPermission();
       Perm.Demand();
       //This method is protected by the security call.
   }

   public void YourMethod() {
       //This method is not protected by the security call.
   }
}
```

## <a name="using-managed-wrapper-classes"></a>Использование управляемых классов-оболочек

Большинство приложений и компонентов (кроме безопасных библиотек) не должны напрямую вызывать неуправляемый код. Для этого есть несколько причин. Если код вызывает неуправляемый код напрямую, во многих ситуациях ему не будет разрешено выполняться, потому что он должен обладать высоким уровнем доверия, чтобы вызывать машинный код. Если политика будет изменена с целью разрешить запуск подобного приложения, это может заметно ослабить безопасность системы, так как приложение сможет выполнять практически любые операции.

Кроме того, код, имеющий разрешение на доступ к неуправляемому коду, может выполнить почти любую операцию, вызвав неуправляемый интерфейс API. Например, код, который имеет разрешение на вызов неуправляемого кода не требуется <xref:System.Security.Permissions.FileIOPermission> для доступа к файлу; он может просто вызвать неуправляемый API напрямую, минуя управляемых файловых API, который требуется файлов (Win32) **FileIOPermission**. Если управляемый код имеет разрешение на вызов неуправляемого кода и производит его прямой вызов, система безопасности не может уверенно обеспечивать ограничения безопасности, так как среда выполнения не может применять эти ограничения к неуправляемому коду.

Если необходимо, чтобы приложение выполняло операции, требующие доступа к неуправляемому коду, оно должно делать это через доверенный управляемый класс, предоставляющий оболочку для требуемой функциональности (если такой класс существует). Не создавайте класс-оболочку самостоятельно, если он уже имеется в безопасной библиотеке классов. Класс-оболочка, которому нужно предоставить высокий уровень доверия, чтобы он мог вызывать неуправляемый код, отвечает за обеспечение наличия у вызывающих объектов соответствующих разрешений. Если вы используете класс-оболочку, коду необходимо запросить и получить только те разрешения, которые требуются этому классу.

## <a name="see-also"></a>См. также

- <xref:System.Security.PermissionSet>
- <xref:System.Security.Permissions.FileIOPermission>
- <xref:System.Security.NamedPermissionSet>
- <xref:System.Security.Permissions.SecurityAction>
- [Assert](../../../docs/framework/misc/using-the-assert-method.md)
- [Управление доступом для кода](../../../docs/framework/misc/code-access-security.md)
- [Основы управления доступом для кода](../../../docs/framework/misc/code-access-security-basics.md)
- [Атрибуты](../../../docs/standard/attributes/index.md)
- [Метаданные и компоненты с самоописанием](../../../docs/standard/metadata-and-self-describing-components.md)
