---
title: Прозрачный с точки зрения безопасности код, уровень 2
ms.date: 03/30/2017
helpviewer_keywords:
- transparency
- level 2 transparency
- security-transparent code
- security-critical code
ms.assetid: 4d05610a-0da6-4f08-acea-d54c9d6143c0
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 62c25b14fa7b3867bbdbcb2f1e08cc16ce349e72
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/08/2019
ms.locfileid: "59156082"
---
# <a name="security-transparent-code-level-2"></a>Прозрачный с точки зрения безопасности код, уровень 2
<a name="top"></a>
[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]  
  
 Прозрачность уровня 2 появилась в версии [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]. Ключевыми элементами этой модели являются следующие компоненты: прозрачный код, надежный с точки зрения безопасности код и критический с точки зрения безопасности код.  
  
-   Прозрачный код (в том числе код с полным доверием) может вызывать только другой прозрачный или надежный с точки зрения безопасности код. Прозрачный код может выполнять только действия, разрешенные набором разрешений частичного доверия домена (если он существует). Прозрачный код не может выполнять следующие действия:  
  
    -   выполнять метод <xref:System.Security.CodeAccessPermission.Assert%2A> или повышение привилегий;  
  
    -   содержать небезопасный или непроверяемый код;  
  
    -   напрямую вызывать критический код;  
  
    -   вызывать машинный код или код с атрибутом <xref:System.Security.SuppressUnmanagedCodeSecurityAttribute>;  
  
    -   вызывать член, защищенный с помощью <xref:System.Security.Permissions.SecurityAction.LinkDemand>;  
  
    -   наследовать от критических типов.  
  
     Кроме того, прозрачные методы не могут переопределять критические виртуальные методы или реализовывать критические методы интерфейсов.  
  
-   Надежный с точки зрения безопасности код имеет полное доверие, но может вызываться прозрачным кодом. Он предоставляет ограниченный объем кода с полным доверием. В надежном с точки зрения безопасности коде выполняются проверки на правильность и безопасность.  
  
-   Критический с точки зрения безопасности код может вызывать любой код, но не может вызываться из прозрачного кода.  
  
 В этом разделе содержатся следующие подразделы.  
  
-   [Примеры использования и поведение](#examples)  
  
-   [Схемы переопределения](#override)  
  
-   [Правила наследования](#inheritance)  
  
-   [Дополнительные сведения и правила](#additional)  
  
<a name="examples"></a>   
## <a name="usage-examples-and-behaviors"></a>Примеры использования и поведение  
 Чтобы указать правила [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)] (прозрачность уровня 2), используйте для сборки следующую заметку:  
  
```  
[assembly: SecurityRules(SecurityRuleSet.Level2)]  
```  
  
 Чтобы зафиксировать правила платформы .NET Framework 2.0 (прозрачность уровня 1), используйте следующую заметку:  
  
```  
[assembly: SecurityRules(SecurityRuleSet.Level1)]  
```  
  
 Если сборка не содержит заметок, то по умолчанию используются правила [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)]. Тем не менее, рекомендуется использовать <xref:System.Security.SecurityRulesAttribute> вместо атрибута зависимостей по умолчанию.  
  
### <a name="assembly-wide-annotation"></a>Заметка на уровне сборки  
 Ниже перечислены правила, которые применяются к использованию атрибутов на уровне сборки.  
  
-   Без атрибутов: Если атрибуты не указаны, то среда выполнения рассматривает код как с точки зрения безопасности, за исключением случаев, когда с точки зрения безопасности это нарушает правило наследования (например, в том случае, при переопределении или при реализации прозрачного виртуального метода или метода интерфейса). В таких случаях методы являются надежными с точки зрения безопасности. Если атрибут не указан, то определение правил прозрачности выполняется средой CLR.  
  
-   `SecurityTransparent`: Весь код является прозрачным; Вся сборка не будет ничего делать привилегированных или unsafe.  
  
-   `SecurityCritical`: Код всех типов в этой сборке является критическим, а остальной код — прозрачным. Этот случай аналогичен отсутствию атрибутов, но среда CLR не определяет правила прозрачности автоматически. Например, если переопределить виртуальный или абстрактный метод или реализовать метод интерфейса, то такой метод по умолчанию будет прозрачным. Следует явным образом пометить метод как `SecurityCritical` или `SecuritySafeCritical`. В противном случае при загрузке возникнет исключение <xref:System.TypeLoadException>. Это правило также применяется в том случае, если базовый и производный классы находятся в одной сборке.  
  
-   `AllowPartiallyTrustedCallers` (уровень 2 только): Весь код по умолчанию является прозрачным. Однако отдельные типы и члены могут иметь другие атрибуты.  
  
 В следующей таблице сравнивается поведение сборки уровня 2 и уровня 1.  
  
|Assembly - атрибут|Уровень 2|Уровень 1|  
|------------------------|-------------|-------------|  
|Частично доверенная сборка без атрибутов|Типы и члены по умолчанию являются прозрачными, но могут быть критическими или надежными с точки зрения безопасности.|Все типы и члены являются прозрачными.|  
|Атрибут не указан|Если атрибут не указан, то определение правил прозрачности выполняется средой CLR. Все типы и члены являются критическими с точки зрения безопасности за исключением тех случаев, когда это нарушает правило наследования.|В сборке с полным доверием (в глобальном кэше сборок или в сборке, для которой полное доверие указано в домене `AppDomain`) все типы являются прозрачными, а члены — надежными с точки зрения безопасности.|  
|`SecurityTransparent`|Все типы и члены являются прозрачными.|Все типы и члены являются прозрачными.|  
|`SecurityCritical(SecurityCriticalScope.Everything)`|Неприменимо.|Все типы и члены являются прозрачными.|  
|`SecurityCritical`|Код всех типов в этой сборке является критическим, а остальной код — прозрачным. При переопределении виртуального или абстрактного метода или при реализации метода интерфейса следует явным образом пометить этот метод как `SecurityCritical` или `SecuritySafeCritical`.|Весь код по умолчанию является прозрачным. Однако отдельные типы и члены могут иметь другие атрибуты.|  
  
### <a name="type-and-member-annotation"></a>Заметки для типов и членов  
 Атрибуты безопасности, которые применяются к типу, также применяются и к членам, которые представлены этим типом. Однако они не применяются к виртуальным или абстрактным переопределениям базового класса, а также к реализациям интерфейса. Ниже перечислены правила, которые применяются к использованию атрибутов на уровне типов и членов.  
  
-   `SecurityCritical`: Тип или член является критически важным и может вызываться только полностью доверенный код. Методы, представленные в критическом с точки зрения безопасности коде, также являются критическими.  
  
    > [!IMPORTANT]
    >  Виртуальные и абстрактные методы, представленные в базовых классах или интерфейсах и переопределяемые или реализуемые в критическом с точки зрения безопасности классе, по умолчанию являются прозрачными. Их следует пометить как `SecuritySafeCritical` или `SecurityCritical`.  
  
-   `SecuritySafeCritical`: Тип или член является надежным с точки зрения. В то же время этот тип или член может вызываться из прозрачного кода (с частичным доверием) и имеет те же возможности, что и любой другой критический код. Код необходимо проверить на безопасность.  
  
 [К началу](#top)  
  
<a name="override"></a>   
## <a name="override-patterns"></a>Схемы переопределения  
 В таблице ниже представлены разрешенные переопределения метода для прозрачности уровня 2.  
  
|Базовый виртуальный член или член интерфейса|Переопределение или интерфейс|  
|------------------------------------|-------------------------|  
|`Transparent`|`Transparent`|  
|`Transparent`|`SafeCritical`|  
|`SafeCritical`|`Transparent`|  
|`SafeCritical`|`SafeCritical`|  
|`Critical`|`Critical`|  
  
 [К началу](#top)  
  
<a name="inheritance"></a>   
## <a name="inheritance-rules"></a>Правила наследования  
 В этом разделе коду `Transparent`, `Critical` и `SafeCritical` в зависимости от доступа и возможностей присваивается следующий порядок:  
  
 `Transparent` < `SafeCritical` < `Critical`  
  
-   Правила для типов: Движения слева направо, доступ становится более ограниченным. Производные типы должны иметь как минимум те же ограничения, что и базовый тип.  
  
-   Правила для методов: Производные методы не могут изменять доступность из базового метода. По умолчанию все производные методы без заметок являются методами `Transparent`. Типы, производные от критических, вызывают возникновение исключения, если переопределенный метод явным образом не помечен как `SecurityCritical`.  
  
 В таблице ниже показаны разрешенные схемы наследования типов.  
  
|Базовый класс|Производный класс может быть|  
|----------------|--------------------------|  
|`Transparent`|`Transparent`|  
|`Transparent`|`SafeCritical`|  
|`Transparent`|`Critical`|  
|`SafeCritical`|`SafeCritical`|  
|`SafeCritical`|`Critical`|  
|`Critical`|`Critical`|  
  
 В таблице ниже показаны запрещенные схемы наследования типов.  
  
|Базовый класс|Производный класс не может быть|  
|----------------|-----------------------------|  
|`SafeCritical`|`Transparent`|  
|`Critical`|`Transparent`|  
|`Critical`|`SafeCritical`|  
  
 В таблице ниже показаны разрешенные схемы наследования методов.  
  
|Базовый метод|Производный метод может быть|  
|-----------------|---------------------------|  
|`Transparent`|`Transparent`|  
|`Transparent`|`SafeCritical`|  
|`SafeCritical`|`Transparent`|  
|`SafeCritical`|`SafeCritical`|  
|`Critical`|`Critical`|  
  
 В таблице ниже показаны запрещенные схемы наследования методов.  
  
|Базовый метод|Производный метод не может быть|  
|-----------------|------------------------------|  
|`Transparent`|`Critical`|  
|`SafeCritical`|`Critical`|  
|`Critical`|`Transparent`|  
|`Critical`|`SafeCritical`|  
  
> [!NOTE]
>  Эти правила наследования применяются к типам и членам уровня 2. Типы в сборках уровня 1 могут наследоваться от критических с точки зрения безопасности типов и членов уровня 2. Таким образом, типы и члены уровня 2 должны иметь различные требования к наследованию для наследуемых типов и членов уровня 1.  
  
 [К началу](#top)  
  
<a name="additional"></a>   
## <a name="additional-information-and-rules"></a>Дополнительные сведения и правила  
  
### <a name="linkdemand-support"></a>Поддержка LinkDemand  
 Модель прозрачности уровня 2 заменяет <xref:System.Security.Permissions.SecurityAction.LinkDemand> атрибутом <xref:System.Security.SecurityCriticalAttribute>. В устаревшем коде (уровень 1) <xref:System.Security.Permissions.SecurityAction.LinkDemand> автоматически рассматривается как <xref:System.Security.Permissions.SecurityAction.Demand>.  
  
### <a name="reflection"></a>Отражение  
 Вызов критического метода или чтение критического поля вызывает требование полного доверия (как при вызове закрытого метода или поля). Таким образом, критический метод может вызываться только в коде с полным доверием, а не в коде с частичным доверием.  
  
 В пространство имен <xref:System.Reflection> добавлены следующие свойства, позволяющие определить, является ли тип, метод или поле `SecurityCritical`, `SecuritySafeCritical` или `SecurityTransparent`: <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> и <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A>. Используйте эти свойства, чтобы определить прозрачность с помощью отражения, вместо проверки присутствия атрибута. Правила прозрачности достаточно сложны, и проверки существования атрибута может быть недостаточно.  
  
> [!NOTE]
>  Объект `SafeCritical` возвращает `true` для обоих <xref:System.Type.IsSecurityCritical%2A> и <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, так как `SafeCritical` действительно является критическим (имеет те же возможности, что и критический код, но может вызываться из прозрачного кода).  
  
 Динамические методы наследуют прозрачность модулей, к которым они присоединены. Они не наследуют прозрачность типа (если они присоединены к типу).  
  
### <a name="skip-verification-in-full-trust"></a>Пропуск проверки при полном доверии  
 Для прозрачных сборок с полным доверием проверку можно пропустить, установив свойство <xref:System.Security.SecurityRulesAttribute.SkipVerificationInFullTrust%2A> равным `true` в атрибуте <xref:System.Security.SecurityRulesAttribute>:  
  
 `[assembly: SecurityRules(SecurityRuleSet.Level2, SkipVerificationInFullTrust = true)]`  
  
 Свойство <xref:System.Security.SecurityRulesAttribute.SkipVerificationInFullTrust%2A> по умолчанию равно `false`, поэтому для пропуска проверки его нужно установить равным `true`. Это следует делать только в целях оптимизации. Следует убедиться, что прозрачный код в сборке проверяемые с помощью `transparent` в диалоговом окне [средство PEVerify](../../../docs/framework/tools/peverify-exe-peverify-tool.md).  
  
## <a name="see-also"></a>См. также

- [Прозрачный с точки зрения безопасности код, уровень 1](../../../docs/framework/misc/security-transparent-code-level-1.md)
- [Изменения системы безопасности](../../../docs/framework/security/security-changes.md)
