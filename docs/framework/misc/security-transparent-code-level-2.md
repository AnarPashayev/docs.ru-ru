---
title: Прозрачный с точки зрения безопасности код, уровень 2
ms.date: 03/30/2017
helpviewer_keywords:
- transparency
- level 2 transparency
- security-transparent code
- security-critical code
ms.assetid: 4d05610a-0da6-4f08-acea-d54c9d6143c0
ms.openlocfilehash: 12e991e4977b0866343158c05681ddf4bd0c869b
ms.sourcegitcommit: 62285ec11fa8e8424bab00511a90760c60e63c95
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/20/2020
ms.locfileid: "81645735"
---
# <a name="security-transparent-code-level-2"></a>Прозрачный с точки зрения безопасности код, уровень 2

[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]

Прозрачность уровня 2 была введена в рамках .NET 4. Ключевыми элементами этой модели являются следующие компоненты: прозрачный код, надежный с точки зрения безопасности код и критический с точки зрения безопасности код.

- Прозрачный код (в том числе код с полным доверием) может вызывать только другой прозрачный или надежный с точки зрения безопасности код. Прозрачный код может выполнять только действия, разрешенные набором разрешений частичного доверия домена (если он существует). Прозрачный код не может выполнять следующие действия:

  - выполнять метод <xref:System.Security.CodeAccessPermission.Assert%2A> или повышение привилегий;

  - содержать небезопасный или непроверяемый код;

  - напрямую вызывать критический код;

  - вызывать машинный код или код с атрибутом <xref:System.Security.SuppressUnmanagedCodeSecurityAttribute>;

  - вызывать член, защищенный с помощью <xref:System.Security.Permissions.SecurityAction.LinkDemand>;

  - наследовать от критических типов.

  Кроме того, прозрачные методы не могут переопределять критические виртуальные методы или реализовывать критические методы интерфейсов.

- Надежный с точки зрения безопасности код имеет полное доверие, но может вызываться прозрачным кодом. Он предоставляет ограниченный объем кода с полным доверием. В надежном с точки зрения безопасности коде выполняются проверки на правильность и безопасность.

- Критический с точки зрения безопасности код может вызывать любой код, но не может вызываться из прозрачного кода.

## <a name="usage-examples-and-behaviors"></a>Примеры использования и поведение

Чтобы указать правила .NET Framework 4 (прозрачность уровня 2), используйте следующую аннотацию для сборки:

```csharp
[assembly: SecurityRules(SecurityRuleSet.Level2)]
```

Чтобы зафиксировать правила платформы .NET Framework 2.0 (прозрачность уровня 1), используйте следующую заметку:

```csharp
[assembly: SecurityRules(SecurityRuleSet.Level1)]
```

Если вы не аннотируете сборку, правила .NET Framework 4 используются по умолчанию. Тем не менее, рекомендуемая наилучшая практика заключается в использовании атрибута <xref:System.Security.SecurityRulesAttribute> вместо зависимости от по умолчанию.

### <a name="assembly-wide-annotation"></a>Заметка на уровне сборки

Ниже перечислены правила, которые применяются к использованию атрибутов на уровне сборки.

- Без атрибутов: если атрибуты не указаны, то среда выполнения рассматривает код как критический с точки зрения безопасности за исключением случаев, когда это нарушает правило наследования (например, при переопределении или при реализации прозрачного виртуального метода или метода интерфейса). В таких случаях методы являются надежными с точки зрения безопасности. Если атрибут не указан, то определение правил прозрачности выполняется средой CLR.

- `SecurityTransparent`: весь код является прозрачным, а сборка не будет выполнять небезопасных действий или действий, требующих наличия особых привилегий.

- `SecurityCritical`: весь код типов в этой сборке является критическим, а остальной код — прозрачным. Этот случай аналогичен отсутствию атрибутов, но среда CLR не определяет правила прозрачности автоматически. Например, если переопределить виртуальный или абстрактный метод или реализовать метод интерфейса, то такой метод по умолчанию будет прозрачным. Следует явным образом пометить метод как `SecurityCritical` или `SecuritySafeCritical`. В противном случае при загрузке возникнет исключение <xref:System.TypeLoadException>. Это правило также применяется в том случае, если базовый и производный классы находятся в одной сборке.

- `AllowPartiallyTrustedCallers` (только уровень 2): весь код по умолчанию является прозрачным. Однако отдельные типы и члены могут иметь другие атрибуты.

В следующей таблице сравнивается поведение уровня сборки для уровня 2 с уровнем 1.

|Атрибут сборки|Уровень 2|уровне 1|
|------------------------|-------------|-------------|
|Частично доверенная сборка без атрибутов|Типы и члены по умолчанию являются прозрачными, но могут быть критическими или надежными с точки зрения безопасности.|Все типы и члены являются прозрачными.|
|Атрибут не указан|Если атрибут не указан, то определение правил прозрачности выполняется средой CLR. Все типы и члены являются критическими с точки зрения безопасности за исключением тех случаев, когда это нарушает правило наследования.|В сборке с полным доверием (в глобальном кэше сборок или в сборке, для которой полное доверие указано в домене `AppDomain`) все типы являются прозрачными, а члены — надежными с точки зрения безопасности.|
|`SecurityTransparent`|Все типы и члены являются прозрачными.|Все типы и члены являются прозрачными.|
|`SecurityCritical(SecurityCriticalScope.Everything)`|Не применяется|Все типы и члены являются прозрачными.|
|`SecurityCritical`|Код всех типов в этой сборке является критическим, а остальной код — прозрачным. При переопределении виртуального или абстрактного метода или при реализации метода интерфейса следует явным образом пометить этот метод как `SecurityCritical` или `SecuritySafeCritical`.|Весь код по умолчанию является прозрачным. Однако отдельные типы и члены могут иметь другие атрибуты.|

### <a name="type-and-member-annotation"></a>Заметки для типов и членов

Атрибуты безопасности, которые применяются к типу, также применяются и к членам, которые представлены этим типом. Однако они не применяются к виртуальным или абстрактным переопределениям базового класса, а также к реализациям интерфейса. Ниже перечислены правила, которые применяются к использованию атрибутов на уровне типов и членов.

- `SecurityCritical`: тип или член является критическим и может быть вызван только кодом с полным доверием. Методы, представленные в критическом с точки зрения безопасности коде, также являются критическими.

    > [!IMPORTANT]
    > Виртуальные и абстрактные методы, представленные в базовых классах или интерфейсах и переопределяемые или реализуемые в критическом с точки зрения безопасности классе, по умолчанию являются прозрачными. Их следует пометить как `SecuritySafeCritical` или `SecurityCritical`.

- `SecuritySafeCritical`: тип или член является надежным с точки зрения безопасности. В то же время этот тип или член может вызываться из прозрачного кода (с частичным доверием) и имеет те же возможности, что и любой другой критический код. Код необходимо проверить на безопасность.

## <a name="override-patterns"></a>Схемы переопределения

В таблице ниже представлены разрешенные переопределения метода для прозрачности уровня 2.

|Базовый виртуальный член или член интерфейса|Переопределение или интерфейс|
|------------------------------------|-------------------------|
|`Transparent`|`Transparent`|
|`Transparent`|`SafeCritical`|
|`SafeCritical`|`Transparent`|
|`SafeCritical`|`SafeCritical`|
|`Critical`|`Critical`|

## <a name="inheritance-rules"></a>Правила наследования

В этом разделе коду `Transparent`, `Critical` и `SafeCritical` в зависимости от доступа и возможностей присваивается следующий порядок:

`Transparent` < `SafeCritical` < `Critical`

- Правила для типов: по мере движения слева направо доступ становится более ограниченным. Производные типы должны иметь как минимум те же ограничения, что и базовый тип.

- Правила для методов: производные методы не могут изменять доступность из базового метода. По умолчанию все производные методы без заметок являются методами `Transparent`. Типы, производные от критических, вызывают возникновение исключения, если переопределенный метод явным образом не помечен как `SecurityCritical`.

В таблице ниже показаны разрешенные схемы наследования типов.

|Базовый класс|Производный класс может быть|
|----------------|--------------------------|
|`Transparent`|`Transparent`|
|`Transparent`|`SafeCritical`|
|`Transparent`|`Critical`|
|`SafeCritical`|`SafeCritical`|
|`SafeCritical`|`Critical`|
|`Critical`|`Critical`|

В таблице ниже показаны запрещенные схемы наследования типов.

|Базовый класс|Производный класс не может быть|
|----------------|-----------------------------|
|`SafeCritical`|`Transparent`|
|`Critical`|`Transparent`|
|`Critical`|`SafeCritical`|

В таблице ниже показаны разрешенные схемы наследования методов.

|Базовый метод|Производный метод может быть|
|-----------------|---------------------------|
|`Transparent`|`Transparent`|
|`Transparent`|`SafeCritical`|
|`SafeCritical`|`Transparent`|
|`SafeCritical`|`SafeCritical`|
|`Critical`|`Critical`|

В таблице ниже показаны запрещенные схемы наследования методов.

|Базовый метод|Производный метод не может быть|
|-----------------|------------------------------|
|`Transparent`|`Critical`|
|`SafeCritical`|`Critical`|
|`Critical`|`Transparent`|
|`Critical`|`SafeCritical`|

> [!NOTE]
> Эти правила наследования применяются к типам и членам уровня 2. Типы в сборках уровня 1 могут наследоваться от критических с точки зрения безопасности типов и членов уровня 2. Таким образом, типы и члены уровня 2 должны иметь различные требования к наследованию для наследуемых типов и членов уровня 1.

## <a name="additional-information-and-rules"></a>Дополнительные сведения и правила

### <a name="linkdemand-support"></a>Поддержка LinkDemand

Модель прозрачности уровня 2 заменяет <xref:System.Security.Permissions.SecurityAction.LinkDemand> атрибутом <xref:System.Security.SecurityCriticalAttribute>. В устаревшем коде (уровень 1) <xref:System.Security.Permissions.SecurityAction.LinkDemand> автоматически рассматривается как <xref:System.Security.Permissions.SecurityAction.Demand>.

### <a name="reflection"></a>Отражение

Вызов критического метода или чтение критического поля вызывает требование полного доверия (как при вызове закрытого метода или поля). Таким образом, критический метод может вызываться только в коде с полным доверием, а не в коде с частичным доверием.

В пространство имен <xref:System.Reflection> добавлены следующие свойства, позволяющие определить, является ли тип, метод или поле `SecurityCritical`, `SecuritySafeCritical` или `SecurityTransparent`: <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> и <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A>. Используйте эти свойства, чтобы определить прозрачность с помощью отражения, вместо проверки присутствия атрибута. Правила прозрачности достаточно сложны, и проверки существования атрибута может быть недостаточно.

> [!NOTE]
> Метод `SafeCritical` возвращается `true` <xref:System.Type.IsSecurityCritical%2A> для <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>обоих и, потому что `SafeCritical` это действительно важно (он имеет те же возможности, что и критический код, но его можно назвать из прозрачного кода).

Динамические методы наследуют прозрачность модулей, к которым они присоединены. Они не наследуют прозрачность типа (если они присоединены к типу).

### <a name="skip-verification-in-full-trust"></a>Пропуск проверки при полном доверии

Для прозрачных сборок с полным доверием проверку можно пропустить, установив свойство <xref:System.Security.SecurityRulesAttribute.SkipVerificationInFullTrust%2A> равным `true` в атрибуте <xref:System.Security.SecurityRulesAttribute>:

`[assembly: SecurityRules(SecurityRuleSet.Level2, SkipVerificationInFullTrust = true)]`

Свойство <xref:System.Security.SecurityRulesAttribute.SkipVerificationInFullTrust%2A> по умолчанию равно `false`, поэтому для пропуска проверки его нужно установить равным `true`. Это следует делать только в целях оптимизации. Необходимо убедиться, что прозрачный код в сборке `transparent` поддается проверке, используя опцию в [инструменте PEVerify.](../tools/peverify-exe-peverify-tool.md)

## <a name="see-also"></a>См. также раздел

- [Прозрачный код безопасности, уровень 1](security-transparent-code-level-1.md)
- [Изменения безопасности](https://docs.microsoft.com/previous-versions/dotnet/framework/security/security-changes)
