---
title: Вопросы безопасности при удаленном взаимодействии
ms.date: 03/30/2017
helpviewer_keywords:
- code security, remoting
- remoting, security
- security [.NET Framework], remoting
- secure coding, remoting
ms.assetid: 125d2ab8-55a4-4e5f-af36-a7d401a37ab0
ms.openlocfilehash: 7a56c9894da88382f40dcd475e89776a83a59322
ms.sourcegitcommit: 9c54866bcbdc49dbb981dd55be9bbd0443837aa2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/14/2020
ms.locfileid: "77215772"
---
# <a name="security-and-remoting-considerations"></a>Вопросы безопасности при удаленном взаимодействии
Удаленное взаимодействие позволяет установить прозрачные вызовы между доменами приложений, процессами или компьютерами. Однако обход стека управления доступом для кода не может выходить за границы процесса или компьютера (применяется между доменами приложения того же процесса).  
  
 Любой класс, поддерживающий удаленное взаимодействие (производный от класса <xref:System.MarshalByRefObject>), должен отвечать за обеспечение безопасности. Код должен использоваться только в закрытых средах, где вызывающий код имеет полное доверие, либо удаленные вызовы должны разрабатываться таким образом, чтобы они не подвергали защищенный код опасности при вводе внешних данных, которые могут быть использованы злоумышленниками.  
  
 Как правило, никогда не следует предоставлять методы, свойства или события, защищенные декларативными [LinkDemand](link-demands.md) и <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> проверками безопасности. При удаленном взаимодействии эти проверки не применяются в обязательном порядке. Другие проверки безопасности, такие как <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](using-the-assert-method.md)и т. д., работают между доменами приложений внутри процесса, но не работают в сценариях между процессами или между компьютерами.  
  
## <a name="protected-objects"></a>Защищенные объекты  
 Некоторые объекты сохраняют в себе состояние безопасности. Эти объекты не должны передаваться в ненадежный код, который при этом смог бы получить авторизацию, выходящую за рамки собственных разрешений.  
  
 Примером является создание объекта <xref:System.IO.FileStream>. Во время создания запрашивается <xref:System.Security.Permissions.FileIOPermission>, и, если он завершается успешно, то возвращается файловый объект. Тем не менее, если ссылка на этот объект передается в коде без разрешения для файлов, то объект будет иметь возможность чтения и записи в этот конкретный файл.  
  
 Простейшая защита такого объекта заключается в необходимости получения такого же **FileIOPermission** для любого кода, который ищет ссылку на объект через открытый интерфейс API.  
  
## <a name="application-domain-crossing-issues"></a>Проблемы пересечения доменов приложений  
 Для изоляции кода в управляемых средах размещения обычно создают несколько дочерних доменов приложения с явно определенной политикой, ограничивающей уровни разрешений для различных сборок. Однако в домене приложения по умолчанию политика для этих сборок остается неизменной. Если один из дочерних доменов приложения может заставить домен приложения по умолчанию загрузить сборку, то эффект от изоляции кода теряется и типы в принудительно загруженной сборке смогут запустить код с высоким уровнем доверия.  
  
 Домен приложения может заставить другой домен приложения загрузить сборку и выполнить код, содержащийся в ней вызовом прокси-объекта, находящегося в другом домене приложения. Чтобы получить прокси-объект между доменами приложений, домен приложения, содержащий объект, должен передать ему параметр метода вызова или возвращаемого значения. Либо, если домен приложения был только что создан, его создатель получает прокси-объект для объекта <xref:System.AppDomain> по умолчанию. Таким образом, чтобы избежать нарушения изоляции кода, домен приложения с высоким уровнем доверия не должен передавать ссылки на маршалируемые по ссылке объекты (экземпляры классов, производные от <xref:System.MarshalByRefObject>) в своем домене для доменов приложений с более низкими уровнями доверия.  
  
 Как правило, домен приложения по умолчанию создает дочерние домены приложения с управляющим объектом в каждом из них. Объект управления управляет новым доменом приложения и иногда принимает указания от домена приложения по умолчанию, но он не может взаимодействовать с доменом напрямую. В некоторых случаях домен приложения по умолчанию обращается через свой прокси-объект к объекту управления. Однако могут быть случаи, когда домену приложения по умолчанию необходимо осуществить обратный вызов объекта управления. В этих случаях домен приложения по умолчанию передает объект обратного вызова, маршалируемый по ссылке, конструктору объекта элемента управления. Он отвечает за защиту прокси-объекта управления. Если объект управления разместит прокси-объект в поле public static общего класса или иным способом предоставит прокси-объект, то внешнему коду будет открыт небезопасный механизм для выполнения обратного вызова домена приложения по умолчанию. По этой причине объекты управления всегда должны оставлять прокси-объекты частными.  
  
## <a name="see-also"></a>См. также:

- [Правила написания безопасного кода](../../standard/security/secure-coding-guidelines.md)
