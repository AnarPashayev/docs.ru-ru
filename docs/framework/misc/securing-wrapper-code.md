---
title: Безопасность кода программы-оболочки
description: Узнайте, как защитить код оболочки, который может открыть уникальный набор слабых мест безопасности, особенно в том случае, если оболочка имеет более высокий уровень доверия, чем код, использующий его.
ms.date: 03/30/2017
helpviewer_keywords:
- security [.NET Framework], wrapper code
- wrapper code, securing
- secure coding, wrapper code
- code security, wrapper code
ms.assetid: 1df6c516-5bba-48bd-b450-1070e04b7389
ms.openlocfilehash: b4c158f8b42618a3659a7d5cf3375b872f19f48b
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/26/2020
ms.locfileid: "96288220"
---
# <a name="securing-wrapper-code"></a><span data-ttu-id="f9994-103">Безопасность кода программы-оболочки</span><span class="sxs-lookup"><span data-stu-id="f9994-103">Securing Wrapper Code</span></span>

[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]  
  
 <span data-ttu-id="f9994-104">Код программы-оболочки, особенно когда она имеет более высокий уровень доверия, чем код, который ее использует, может открыть уникальный набор уязвимостей системы безопасности.</span><span class="sxs-lookup"><span data-stu-id="f9994-104">Wrapper code, especially where the wrapper has higher trust than code that uses it, can open a unique set of security weaknesses.</span></span> <span data-ttu-id="f9994-105">Все, что делается от имени вызывающего объекта, когда его ограниченные разрешения не включаются в соответствующую проверку безопасности, является потенциальной уязвимостью и может быть использовано злоумышленником.</span><span class="sxs-lookup"><span data-stu-id="f9994-105">Anything done on behalf of a caller, where the caller's limited permissions are not included in the appropriate security check, is a potential weakness to be exploited.</span></span>  
  
 <span data-ttu-id="f9994-106">Никогда не позволяйте осуществлять с помощью программы-оболочки действия, которые вызывающий объект не может выполнить самостоятельно.</span><span class="sxs-lookup"><span data-stu-id="f9994-106">Never enable something through the wrapper that the caller could not do itself.</span></span> <span data-ttu-id="f9994-107">Особую опасность представляют действия, подразумевающие ограниченную проверку безопасности, в отличие от требования полного обхода стека.</span><span class="sxs-lookup"><span data-stu-id="f9994-107">This is a special danger when doing something that involves a limited security check, as opposed to a full stack walk demand.</span></span> <span data-ttu-id="f9994-108">При использовании одноуровневых проверок внедрение кода программы-оболочки между настоящим вызывающим объектом и элементом API может легко привести к успешному прохождению проверки безопасности, когда это не должно было произойти, что ослабляет защиту.</span><span class="sxs-lookup"><span data-stu-id="f9994-108">When single-level checks are involved, interposing the wrapper code between the real caller and the API element in question can easily cause the security check to succeed when it should not, thereby weakening security.</span></span>  
  
## <a name="delegates"></a><span data-ttu-id="f9994-109">Делегаты</span><span class="sxs-lookup"><span data-stu-id="f9994-109">Delegates</span></span>  

 <span data-ttu-id="f9994-110">Защита делегатов различается в разных версиях .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="f9994-110">Delegate security differs between versions of the .NET Framework.</span></span>  <span data-ttu-id="f9994-111">В этом разделе описывается различное поведение делегатов и соответствующие вопросы безопасности.</span><span class="sxs-lookup"><span data-stu-id="f9994-111">This section describes the different delegate behaviors and associated security considerations.</span></span>  
  
### <a name="in-version-10-and-11-of-the-net-framework"></a><span data-ttu-id="f9994-112">В .NET Framework версий 1.0 и 1.1</span><span class="sxs-lookup"><span data-stu-id="f9994-112">In version 1.0 and 1.1 of the .NET Framework</span></span>  

 <span data-ttu-id="f9994-113">В .NET Framework версий 1.0 и 1.1 с создателем делегата и вызывающим делегат объектом выполняются следующие действия по обеспечению безопасности.</span><span class="sxs-lookup"><span data-stu-id="f9994-113">Version 1.0 and 1.1 of the .NET Framework perform the following security actions against a delegate creator and a delegate caller.</span></span>  
  
- <span data-ttu-id="f9994-114">При создании делегата требования связывания безопасности в целевом методе делегата выполняются по отношению к набору привилегий создателя делегата.</span><span class="sxs-lookup"><span data-stu-id="f9994-114">When a delegate is created, security link demands on the delegate target method are performed against the grant set of the delegate creator.</span></span>  <span data-ttu-id="f9994-115">В результате сбоя при выполнении действия по обеспечению безопасности возникает исключение <xref:System.Security.SecurityException>.</span><span class="sxs-lookup"><span data-stu-id="f9994-115">Failure to satisfy the security action results in a <xref:System.Security.SecurityException>.</span></span>  
  
- <span data-ttu-id="f9994-116">При вызове делегата выполняются все существующие требования безопасности в вызывающем делегат объекте.</span><span class="sxs-lookup"><span data-stu-id="f9994-116">When the delegate is invoked, any existing security demands on the delegate caller are performed.</span></span>  
  
 <span data-ttu-id="f9994-117">Каждый раз, когда код принимает <xref:System.Delegate> из менее доверенного кода, который может вызывать его, убедитесь, что менее доверенному коду не разрешено повышать уровень своих разрешений.</span><span class="sxs-lookup"><span data-stu-id="f9994-117">Whenever your code takes a <xref:System.Delegate> from less-trusted code that might call it, make sure that you are not enabling the less-trusted code to escalate its permissions.</span></span> <span data-ttu-id="f9994-118">Если делегат принимается, но используется позже, то код, создавший делегат, не находится в стеке вызовов, и его разрешения не будут проверяться, если код на уровне делегата или ниже попытается выполнить защищенную операцию.</span><span class="sxs-lookup"><span data-stu-id="f9994-118">If you take a delegate and use it later, the code that created the delegate is not on the call stack and its permissions will not be tested if code in or under the delegate attempts a protected operation.</span></span> <span data-ttu-id="f9994-119">Если ваш код и код вызывающего объекта обладают более высокими привилегиями, чем создатель, то создатель может управлять путем вызова, не являясь частью стека вызовов.</span><span class="sxs-lookup"><span data-stu-id="f9994-119">If your code and the caller code have higher privileges than the creator, the creator can orchestrate the call path without being part of the call stack.</span></span>  
  
### <a name="in-version-20-and-later-versions-of-the-net-framework"></a><span data-ttu-id="f9994-120">В версии 2,0 и более поздних версиях .NET Framework</span><span class="sxs-lookup"><span data-stu-id="f9994-120">In version 2.0 and later versions of the .NET Framework</span></span>  

 <span data-ttu-id="f9994-121">В отличие от предыдущих версий, версия 2,0 и более поздние версии .NET Framework выполняет действия по обеспечению безопасности для создателя делегата при создании и вызове делегата.</span><span class="sxs-lookup"><span data-stu-id="f9994-121">Unlike previous versions, version 2.0 and later versions of the .NET Framework performs security action against the delegate creator when the delegate is created and called.</span></span>  
  
- <span data-ttu-id="f9994-122">При создании делегата требования связывания безопасности в целевом методе делегата выполняются по отношению к набору привилегий создателя делегата.</span><span class="sxs-lookup"><span data-stu-id="f9994-122">When a delegate is created, security link demands on the delegate target method are performed against the grant set of the delegate creator.</span></span>  <span data-ttu-id="f9994-123">В результате сбоя при выполнении действия по обеспечению безопасности возникает исключение <xref:System.Security.SecurityException>.</span><span class="sxs-lookup"><span data-stu-id="f9994-123">Failure to satisfy the security action results in a <xref:System.Security.SecurityException>.</span></span>  
  
- <span data-ttu-id="f9994-124">Набор прав создателя делегата также собирается при создании делегата и сохраняется с делегатом.</span><span class="sxs-lookup"><span data-stu-id="f9994-124">The delegate creator's grant set is also captured during delegate creation and stored with the delegate.</span></span>  
  
- <span data-ttu-id="f9994-125">При вызове делегата сохраненный набор прав создателя делегата сначала оценивается по отношению ко всем требованиям в текущем контексте, если создатель делегата и вызывающий делегат объект принадлежат разным сборкам.</span><span class="sxs-lookup"><span data-stu-id="f9994-125">When the delegate is invoked, the delegate creator's captured grant set is first evaluated against any demands in the current context if the delegate creator and caller belong to different assemblies.</span></span>  <span data-ttu-id="f9994-126">Затем выполняются все существующие требования безопасности в вызывающем делегат объекте.</span><span class="sxs-lookup"><span data-stu-id="f9994-126">Next, any existing security demands on the delegate caller are performed.</span></span>  
  
## <a name="link-demands-and-wrappers"></a><span data-ttu-id="f9994-127">Требования связывания и программы-оболочки</span><span class="sxs-lookup"><span data-stu-id="f9994-127">Link demands and wrappers</span></span>  

 <span data-ttu-id="f9994-128">В инфраструктуре безопасности особая защита была усилена с помощью требований связывания, но она по-прежнему является источником уязвимости в коде.</span><span class="sxs-lookup"><span data-stu-id="f9994-128">A special protection case with link demands has been strengthened in the security infrastructure, but it is still a source of possible weakness in your code.</span></span>  
  
 <span data-ttu-id="f9994-129">Если полностью доверенный код вызывает свойство, событие или метод, защищенные [LinkDemand](link-demands.md), вызов выполняется успешно, если проверка разрешений **LinkDemand** для вызывающего объекта удовлетворена.</span><span class="sxs-lookup"><span data-stu-id="f9994-129">If fully trusted code calls a property, event, or method protected by a [LinkDemand](link-demands.md), the call succeeds if the **LinkDemand** permission check for the caller is satisfied.</span></span> <span data-ttu-id="f9994-130">Кроме того, если полностью доверенный код предоставляет класс, который принимает имя свойства и вызывает метод доступа **Get** с помощью отражения, этот вызов метода доступа **Get** выполняется успешно, даже если пользовательский код не имеет прав доступа к этому свойству.</span><span class="sxs-lookup"><span data-stu-id="f9994-130">Additionally, if the fully trusted code exposes a class that takes the name of a property and calls its **get** accessor using reflection, that call to the **get** accessor succeeds even though the user code does not have the right to access this property.</span></span> <span data-ttu-id="f9994-131">Это обусловлено тем, что **LinkDemand** проверяет только непосредственный вызывающий объект, который является полностью доверенным кодом.</span><span class="sxs-lookup"><span data-stu-id="f9994-131">This is because the **LinkDemand** checks only the immediate caller, which is the fully trusted code.</span></span> <span data-ttu-id="f9994-132">По существу полностью доверенный код выполняет привилегированный вызов от имени пользовательского кода, не убедившись в том, что пользовательский код имеет права для выполнения такого вызова.</span><span class="sxs-lookup"><span data-stu-id="f9994-132">In essence, the fully trusted code is making a privileged call on behalf of user code without making sure that the user code has the right to make that call.</span></span>  
  
 <span data-ttu-id="f9994-133">Чтобы помочь предотвратить такие бреши в системе безопасности, среда CLR расширяет проверку на полный спрос на стек при любом непрямом вызове метода, конструктора, свойства или события, защищенных **LinkDemand**.</span><span class="sxs-lookup"><span data-stu-id="f9994-133">To help prevent such security holes, the common language runtime extends the check into a full stack-walking demand on any indirect call to a method, constructor, property, or event protected by a **LinkDemand**.</span></span> <span data-ttu-id="f9994-134">Такая защита влечет за собой некоторое снижение производительности, а также меняет семантику проверки безопасности; требование полного обхода стека может завершиться ошибкой там, где была бы пройдена более быстрая одноуровневая проверка.</span><span class="sxs-lookup"><span data-stu-id="f9994-134">This protection incurs some performance costs and changes the semantics of the security check; the full stack-walk demand might fail where the faster, one-level check would have passed.</span></span>  
  
## <a name="assembly-loading-wrappers"></a><span data-ttu-id="f9994-135">Программы-оболочки, загружающие сборки</span><span class="sxs-lookup"><span data-stu-id="f9994-135">Assembly loading wrappers</span></span>  

 <span data-ttu-id="f9994-136">Некоторые методы, используемые для загрузки управляемого кода, включая <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>, загружают сборки со свидетельством вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="f9994-136">Several methods used to load managed code, including <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>, load assemblies with the evidence of the caller.</span></span> <span data-ttu-id="f9994-137">Если включить в программу-оболочку любой из этих методов, система безопасности может использовать для загрузки сборки предоставленные вашему коду разрешения вместо разрешений объекта, вызывающего вашу программу-оболочку.</span><span class="sxs-lookup"><span data-stu-id="f9994-137">If you wrap any of these methods, the security system could use your code's permission grant, instead of the permissions of the caller to your wrapper, to load the assemblies.</span></span> <span data-ttu-id="f9994-138">Не разрешайте коду с меньшим доверием загружать код, которому предоставлены более высокие разрешения, чем у вызывающей оболочки.</span><span class="sxs-lookup"><span data-stu-id="f9994-138">Don't allow less-trusted code to load code that is granted higher permissions than those of the caller to your wrapper.</span></span>  
  
 <span data-ttu-id="f9994-139">Таким образом может быть ослаблена безопасность любого кода с полным уровнем доверия или значительно более высоким уровнем доверия, чем у потенциального вызывающего объекта (включая вызывающий объект уровня Интернет-разрешений).</span><span class="sxs-lookup"><span data-stu-id="f9994-139">Any code that has full trust or significantly higher trust than a potential caller (including an Internet-permissions-level caller) could weaken security in this way.</span></span> <span data-ttu-id="f9994-140">Если код имеет открытый метод, который принимает массив байтов и передает его в **сборку. Load**, тем самым создавая сборку от имени вызывающего объекта, это может привести к нарушению безопасности.</span><span class="sxs-lookup"><span data-stu-id="f9994-140">If your code has a public method that takes a byte array and passes it to **Assembly.Load**, thereby creating an assembly on the caller's behalf, it might break security.</span></span>  
  
 <span data-ttu-id="f9994-141">Эта проблема относится к следующим элементам API:</span><span class="sxs-lookup"><span data-stu-id="f9994-141">This issue applies to the following API elements:</span></span>  
  
- <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=nameWithType>  
  
- <xref:System.AppDomain.Load%2A?displayProperty=nameWithType>  
  
- <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>  
  
- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>  
  
## <a name="demand-vs-linkdemand"></a><span data-ttu-id="f9994-142">Demand и LinkDemand</span><span class="sxs-lookup"><span data-stu-id="f9994-142">Demand vs. LinkDemand</span></span>  

 <span data-ttu-id="f9994-143">Декларативная безопасность предлагает два вида проверок безопасности, которые похожи, но выполняют различные проверки.</span><span class="sxs-lookup"><span data-stu-id="f9994-143">Declarative security offers two kinds of security checks that are similar but perform different checks.</span></span> <span data-ttu-id="f9994-144">Хорошо понимать обе формы, так как неверный вариант может привести к ухудшению безопасности или снижению производительности.</span><span class="sxs-lookup"><span data-stu-id="f9994-144">It's good to understand both forms, because the wrong choice can result in weak security or performance loss.</span></span>  
  
 <span data-ttu-id="f9994-145">Декларативная безопасность предлагает следующие проверки безопасности.</span><span class="sxs-lookup"><span data-stu-id="f9994-145">Declarative security offers the following security checks:</span></span>  
  
- <span data-ttu-id="f9994-146">Проверка <xref:System.Security.Permissions.SecurityAction.Demand> указывает обход стека управления доступом для кода.</span><span class="sxs-lookup"><span data-stu-id="f9994-146"><xref:System.Security.Permissions.SecurityAction.Demand> specifies the code access security stack walk.</span></span> <span data-ttu-id="f9994-147">Для прохождения этой проверки все вызывающие объекты в стеке должны иметь указанное разрешение или удостоверение.</span><span class="sxs-lookup"><span data-stu-id="f9994-147">All callers on the stack must have the specified permission or identity to pass.</span></span> <span data-ttu-id="f9994-148">**Запрос** происходит при каждом вызове, так как стек может содержать различные вызывающие объекты.</span><span class="sxs-lookup"><span data-stu-id="f9994-148">**Demand** occurs on every call because the stack might contain different callers.</span></span> <span data-ttu-id="f9994-149">Если метод вызывается многократно, данная проверка безопасности происходит каждый раз.</span><span class="sxs-lookup"><span data-stu-id="f9994-149">If you call a method repeatedly, this security check occurs each time.</span></span> <span data-ttu-id="f9994-150">**Требование** является хорошей защитой от отвлекающих атак; обнаружен несанкционированный код, который пытается получить его.</span><span class="sxs-lookup"><span data-stu-id="f9994-150">**Demand** is good protection against luring attacks; unauthorized code trying to get through it will be detected.</span></span>  
  
- <span data-ttu-id="f9994-151">[LinkDemand](link-demands.md) происходит во время JIT-компиляции и проверяет только непосредственный вызывающий объект.</span><span class="sxs-lookup"><span data-stu-id="f9994-151">[LinkDemand](link-demands.md) happens at just-in-time (JIT) compilation time and checks only the immediate caller.</span></span> <span data-ttu-id="f9994-152">Эта проверка безопасности не проверяет вызывающий объект вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="f9994-152">This security check does not check the caller's caller.</span></span> <span data-ttu-id="f9994-153">После того как эта проверка пройдена, никакие дополнительные проверки не выполняются, независимо от того, сколько раз вызывающий объект может выполнять вызов.</span><span class="sxs-lookup"><span data-stu-id="f9994-153">Once this check passes, there is no additional security overhead no matter how many times the caller might call.</span></span> <span data-ttu-id="f9994-154">Однако эта проверка не обеспечивает защиту от атак с заманиванием.</span><span class="sxs-lookup"><span data-stu-id="f9994-154">However, there is also no protection from luring attacks.</span></span> <span data-ttu-id="f9994-155">При использовании **LinkDemand** любой код, прошедший проверку и ссылающийся на код, может привести к нарушению безопасности, позволяя вредоносному коду вызывать код с помощью полномочного кода.</span><span class="sxs-lookup"><span data-stu-id="f9994-155">With **LinkDemand**, any code that passes the test and can reference your code can potentially break security by allowing malicious code to call using the authorized code.</span></span> <span data-ttu-id="f9994-156">Поэтому не используйте **LinkDemand** , если не все возможные недостатки могут быть тщательно исключены.</span><span class="sxs-lookup"><span data-stu-id="f9994-156">Therefore, do not use **LinkDemand** unless all the possible weaknesses can be thoroughly avoided.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="f9994-157">В .NET Framework 4 требования к компоновке были заменены <xref:System.Security.SecurityCriticalAttribute> атрибутом в <xref:System.Security.SecurityRuleSet.Level2> сборках.</span><span class="sxs-lookup"><span data-stu-id="f9994-157">In the .NET Framework 4, link demands have been replaced by the <xref:System.Security.SecurityCriticalAttribute> attribute in <xref:System.Security.SecurityRuleSet.Level2> assemblies.</span></span> <span data-ttu-id="f9994-158">Параметр <xref:System.Security.SecurityCriticalAttribute> эквивалентен запросу компоновки для полного доверия, однако он также влияет на правила наследования.</span><span class="sxs-lookup"><span data-stu-id="f9994-158">The <xref:System.Security.SecurityCriticalAttribute> is equivalent to a link demand for full trust; however, it also affects inheritance rules.</span></span> <span data-ttu-id="f9994-159">Дополнительные сведения об этом изменении см. в разделе [прозрачный для системы безопасности код, уровень 2](security-transparent-code-level-2.md).</span><span class="sxs-lookup"><span data-stu-id="f9994-159">For more information about this change, see [Security-Transparent Code, Level 2](security-transparent-code-level-2.md).</span></span>  
  
 <span data-ttu-id="f9994-160">Дополнительные меры предосторожности, необходимые при использовании **LinkDemand** , должны программироваться по отдельности. система безопасности может помочь в обеспечении принудительного применения.</span><span class="sxs-lookup"><span data-stu-id="f9994-160">The extra precautions required when using **LinkDemand** must be programmed individually; the security system can help with enforcement.</span></span> <span data-ttu-id="f9994-161">Любая ошибка приводит к возникновению уязвимости в системе безопасности.</span><span class="sxs-lookup"><span data-stu-id="f9994-161">Any mistake opens a security weakness.</span></span> <span data-ttu-id="f9994-162">Любой авторизованный код, использующий ваш код, должен отвечать за реализацию дополнительных мер защиты, выполняя следующие действия.</span><span class="sxs-lookup"><span data-stu-id="f9994-162">All authorized code that uses your code must be responsible for implementing additional security by doing the following:</span></span>  
  
- <span data-ttu-id="f9994-163">Ограничение доступа вызывающего кода к классу или сборке.</span><span class="sxs-lookup"><span data-stu-id="f9994-163">Restricting the calling code's access to the class or assembly.</span></span>  
  
- <span data-ttu-id="f9994-164">Размещение тех же проверок безопасности в вызывающем коде, который появляется в вызываемом коде, и принуждение вызывающих его объектов делать это.</span><span class="sxs-lookup"><span data-stu-id="f9994-164">Placing the same security checks on the calling code that appear on the code being called and obligating its callers to do so.</span></span> <span data-ttu-id="f9994-165">Например, при написании кода, который вызывает метод, защищенный с помощью **LinkDemand** для <xref:System.Security.Permissions.SecurityPermission> с <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> указанным флагом, метод должен также выполнить **LinkDemand** (или **Demand**, который является более надежным) для этого разрешения.</span><span class="sxs-lookup"><span data-stu-id="f9994-165">For example, if you write code that calls a method that is protected with a **LinkDemand** for the <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> flag specified, your method should also make a **LinkDemand** (or **Demand**, which is stronger) for this permission.</span></span> <span data-ttu-id="f9994-166">Исключением является то, что в коде используется метод, защищенный с помощью **LinkDemand**, ограниченным способом, который можно выбрать в качестве безопасного, учитывая другие механизмы защиты (например, требования) в коде.</span><span class="sxs-lookup"><span data-stu-id="f9994-166">The exception is if your code uses the **LinkDemand**-protected method in a limited way that you decide is safe, given other security protection mechanisms (such as demands) in your code.</span></span> <span data-ttu-id="f9994-167">В этом исключительном случае вызывающий объект несет ответственность за понижение степени защиты в базовом коде.</span><span class="sxs-lookup"><span data-stu-id="f9994-167">In this exceptional case, the caller takes responsibility in weakening the security protection on the underlying code.</span></span>  
  
- <span data-ttu-id="f9994-168">Обеспечение, чтобы вызывающие ваш код объекты не могли заставить его вызывать защищенный код от их имени.</span><span class="sxs-lookup"><span data-stu-id="f9994-168">Ensuring that your code's callers cannot trick your code into calling the protected code on their behalf.</span></span> <span data-ttu-id="f9994-169">Другими словами, вызывающие объекты не должны иметь возможность заставить авторизованный код передавать определенные параметры в защищенный код или получить результаты из него.</span><span class="sxs-lookup"><span data-stu-id="f9994-169">In other words, callers cannot force the authorized code to pass specific parameters to the protected code, or to get results back from it.</span></span>  
  
### <a name="interfaces-and-link-demands"></a><span data-ttu-id="f9994-170">Интерфейсы и требования связывания</span><span class="sxs-lookup"><span data-stu-id="f9994-170">Interfaces and Link Demands</span></span>  

 <span data-ttu-id="f9994-171">Если виртуальный метод, свойство или событие с **LinkDemand** переопределяет метод базового класса, метод базового класса также должен иметь такую же проверку **LinkDemand** для переопределенного метода, чтобы быть эффективным.</span><span class="sxs-lookup"><span data-stu-id="f9994-171">If a virtual method, property, or event with **LinkDemand** overrides a base class method, the base class method must also have the same **LinkDemand** for the overridden method in order to be effective.</span></span> <span data-ttu-id="f9994-172">Вредоносный код может выполнить обратное приведение к базовому типу и вызвать метод базового класса.</span><span class="sxs-lookup"><span data-stu-id="f9994-172">It is possible for malicious code to cast back to the base type and call the base class method.</span></span> <span data-ttu-id="f9994-173">Также обратите внимание, что требования связывания могут добавляться неявно в сборки, в которых отсутствует атрибут <xref:System.Security.AllowPartiallyTrustedCallersAttribute> уровня сборки.</span><span class="sxs-lookup"><span data-stu-id="f9994-173">Also note that link demands can be added implicitly to assemblies that do not have the <xref:System.Security.AllowPartiallyTrustedCallersAttribute> assembly-level attribute.</span></span>  
  
 <span data-ttu-id="f9994-174">Рекомендуется защищать реализации методов с помощью требований связывания, когда методы интерфейса также имеют требования связывания.</span><span class="sxs-lookup"><span data-stu-id="f9994-174">It is a good practice to protect method implementations with link demands when interface methods also have link demands.</span></span> <span data-ttu-id="f9994-175">Обратите внимание на следующие аспекты использования требований связывания с интерфейсами.</span><span class="sxs-lookup"><span data-stu-id="f9994-175">Note the following about using link demands with interfaces:</span></span>  
  
- <span data-ttu-id="f9994-176">При помещении **LinkDemand** в открытый метод класса, который реализует метод интерфейса, **LinkDemand** не будет принудительно применен, если затем выполнить приведение к интерфейсу и вызвать метод.</span><span class="sxs-lookup"><span data-stu-id="f9994-176">If you place a **LinkDemand** on a public method of a class that implements an interface method, the **LinkDemand** will not be enforced if you then cast to the interface and call the method.</span></span> <span data-ttu-id="f9994-177">В этом случае, поскольку вы связались с интерфейсом, учитываются только **требования LinkDemand** в интерфейсе.</span><span class="sxs-lookup"><span data-stu-id="f9994-177">In this case, because you linked against the interface, only the **LinkDemand** on the interface is honored.</span></span>  
  
 <span data-ttu-id="f9994-178">Изучите следующие элементы проблем безопасности.</span><span class="sxs-lookup"><span data-stu-id="f9994-178">Review the following items for security issues:</span></span>  
  
- <span data-ttu-id="f9994-179">Явные требования связывания в методах интерфейса.</span><span class="sxs-lookup"><span data-stu-id="f9994-179">Explicit link demands on interface methods.</span></span> <span data-ttu-id="f9994-180">Убедитесь, что эти требования связывания обеспечивают ожидаемую защиту.</span><span class="sxs-lookup"><span data-stu-id="f9994-180">Make sure these link demands offer the expected protection.</span></span> <span data-ttu-id="f9994-181">Определите, может ли вредоносный код использовать приведение, чтобы обойти требования связывания, как описано выше.</span><span class="sxs-lookup"><span data-stu-id="f9994-181">Determine whether malicious code can use a cast to get around the link demands as described previously.</span></span>  
  
- <span data-ttu-id="f9994-182">Виртуальные методы с примененными требованиями связывания.</span><span class="sxs-lookup"><span data-stu-id="f9994-182">Virtual methods with link demands applied.</span></span>  
  
- <span data-ttu-id="f9994-183">Типы и интерфейсы, которые они реализуют.</span><span class="sxs-lookup"><span data-stu-id="f9994-183">Types and the interfaces they implement.</span></span> <span data-ttu-id="f9994-184">Они должны согласованно использовать требования связывания.</span><span class="sxs-lookup"><span data-stu-id="f9994-184">These should use link demands consistently.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f9994-185">См. также</span><span class="sxs-lookup"><span data-stu-id="f9994-185">See also</span></span>

- [<span data-ttu-id="f9994-186">Правила написания безопасного кода</span><span class="sxs-lookup"><span data-stu-id="f9994-186">Secure Coding Guidelines</span></span>](../../standard/security/secure-coding-guidelines.md)
