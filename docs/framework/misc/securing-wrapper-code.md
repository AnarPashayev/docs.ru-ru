---
title: Безопасность кода программы-оболочки
description: Узнайте, как защитить код оболочки, который может открыть уникальный набор слабых мест безопасности, особенно в том случае, если оболочка имеет более высокий уровень доверия, чем код, использующий его.
ms.date: 03/30/2017
helpviewer_keywords:
- security [.NET Framework], wrapper code
- wrapper code, securing
- secure coding, wrapper code
- code security, wrapper code
ms.assetid: 1df6c516-5bba-48bd-b450-1070e04b7389
ms.openlocfilehash: b4c158f8b42618a3659a7d5cf3375b872f19f48b
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/26/2020
ms.locfileid: "96288220"
---
# <a name="securing-wrapper-code"></a>Безопасность кода программы-оболочки

[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]  
  
 Код программы-оболочки, особенно когда она имеет более высокий уровень доверия, чем код, который ее использует, может открыть уникальный набор уязвимостей системы безопасности. Все, что делается от имени вызывающего объекта, когда его ограниченные разрешения не включаются в соответствующую проверку безопасности, является потенциальной уязвимостью и может быть использовано злоумышленником.  
  
 Никогда не позволяйте осуществлять с помощью программы-оболочки действия, которые вызывающий объект не может выполнить самостоятельно. Особую опасность представляют действия, подразумевающие ограниченную проверку безопасности, в отличие от требования полного обхода стека. При использовании одноуровневых проверок внедрение кода программы-оболочки между настоящим вызывающим объектом и элементом API может легко привести к успешному прохождению проверки безопасности, когда это не должно было произойти, что ослабляет защиту.  
  
## <a name="delegates"></a>Делегаты  

 Защита делегатов различается в разных версиях .NET Framework.  В этом разделе описывается различное поведение делегатов и соответствующие вопросы безопасности.  
  
### <a name="in-version-10-and-11-of-the-net-framework"></a>В .NET Framework версий 1.0 и 1.1  

 В .NET Framework версий 1.0 и 1.1 с создателем делегата и вызывающим делегат объектом выполняются следующие действия по обеспечению безопасности.  
  
- При создании делегата требования связывания безопасности в целевом методе делегата выполняются по отношению к набору привилегий создателя делегата.  В результате сбоя при выполнении действия по обеспечению безопасности возникает исключение <xref:System.Security.SecurityException>.  
  
- При вызове делегата выполняются все существующие требования безопасности в вызывающем делегат объекте.  
  
 Каждый раз, когда код принимает <xref:System.Delegate> из менее доверенного кода, который может вызывать его, убедитесь, что менее доверенному коду не разрешено повышать уровень своих разрешений. Если делегат принимается, но используется позже, то код, создавший делегат, не находится в стеке вызовов, и его разрешения не будут проверяться, если код на уровне делегата или ниже попытается выполнить защищенную операцию. Если ваш код и код вызывающего объекта обладают более высокими привилегиями, чем создатель, то создатель может управлять путем вызова, не являясь частью стека вызовов.  
  
### <a name="in-version-20-and-later-versions-of-the-net-framework"></a>В версии 2,0 и более поздних версиях .NET Framework  

 В отличие от предыдущих версий, версия 2,0 и более поздние версии .NET Framework выполняет действия по обеспечению безопасности для создателя делегата при создании и вызове делегата.  
  
- При создании делегата требования связывания безопасности в целевом методе делегата выполняются по отношению к набору привилегий создателя делегата.  В результате сбоя при выполнении действия по обеспечению безопасности возникает исключение <xref:System.Security.SecurityException>.  
  
- Набор прав создателя делегата также собирается при создании делегата и сохраняется с делегатом.  
  
- При вызове делегата сохраненный набор прав создателя делегата сначала оценивается по отношению ко всем требованиям в текущем контексте, если создатель делегата и вызывающий делегат объект принадлежат разным сборкам.  Затем выполняются все существующие требования безопасности в вызывающем делегат объекте.  
  
## <a name="link-demands-and-wrappers"></a>Требования связывания и программы-оболочки  

 В инфраструктуре безопасности особая защита была усилена с помощью требований связывания, но она по-прежнему является источником уязвимости в коде.  
  
 Если полностью доверенный код вызывает свойство, событие или метод, защищенные [LinkDemand](link-demands.md), вызов выполняется успешно, если проверка разрешений **LinkDemand** для вызывающего объекта удовлетворена. Кроме того, если полностью доверенный код предоставляет класс, который принимает имя свойства и вызывает метод доступа **Get** с помощью отражения, этот вызов метода доступа **Get** выполняется успешно, даже если пользовательский код не имеет прав доступа к этому свойству. Это обусловлено тем, что **LinkDemand** проверяет только непосредственный вызывающий объект, который является полностью доверенным кодом. По существу полностью доверенный код выполняет привилегированный вызов от имени пользовательского кода, не убедившись в том, что пользовательский код имеет права для выполнения такого вызова.  
  
 Чтобы помочь предотвратить такие бреши в системе безопасности, среда CLR расширяет проверку на полный спрос на стек при любом непрямом вызове метода, конструктора, свойства или события, защищенных **LinkDemand**. Такая защита влечет за собой некоторое снижение производительности, а также меняет семантику проверки безопасности; требование полного обхода стека может завершиться ошибкой там, где была бы пройдена более быстрая одноуровневая проверка.  
  
## <a name="assembly-loading-wrappers"></a>Программы-оболочки, загружающие сборки  

 Некоторые методы, используемые для загрузки управляемого кода, включая <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>, загружают сборки со свидетельством вызывающего объекта. Если включить в программу-оболочку любой из этих методов, система безопасности может использовать для загрузки сборки предоставленные вашему коду разрешения вместо разрешений объекта, вызывающего вашу программу-оболочку. Не разрешайте коду с меньшим доверием загружать код, которому предоставлены более высокие разрешения, чем у вызывающей оболочки.  
  
 Таким образом может быть ослаблена безопасность любого кода с полным уровнем доверия или значительно более высоким уровнем доверия, чем у потенциального вызывающего объекта (включая вызывающий объект уровня Интернет-разрешений). Если код имеет открытый метод, который принимает массив байтов и передает его в **сборку. Load**, тем самым создавая сборку от имени вызывающего объекта, это может привести к нарушению безопасности.  
  
 Эта проблема относится к следующим элементам API:  
  
- <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=nameWithType>  
  
- <xref:System.AppDomain.Load%2A?displayProperty=nameWithType>  
  
- <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>  
  
- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>  
  
## <a name="demand-vs-linkdemand"></a>Demand и LinkDemand  

 Декларативная безопасность предлагает два вида проверок безопасности, которые похожи, но выполняют различные проверки. Хорошо понимать обе формы, так как неверный вариант может привести к ухудшению безопасности или снижению производительности.  
  
 Декларативная безопасность предлагает следующие проверки безопасности.  
  
- Проверка <xref:System.Security.Permissions.SecurityAction.Demand> указывает обход стека управления доступом для кода. Для прохождения этой проверки все вызывающие объекты в стеке должны иметь указанное разрешение или удостоверение. **Запрос** происходит при каждом вызове, так как стек может содержать различные вызывающие объекты. Если метод вызывается многократно, данная проверка безопасности происходит каждый раз. **Требование** является хорошей защитой от отвлекающих атак; обнаружен несанкционированный код, который пытается получить его.  
  
- [LinkDemand](link-demands.md) происходит во время JIT-компиляции и проверяет только непосредственный вызывающий объект. Эта проверка безопасности не проверяет вызывающий объект вызывающего объекта. После того как эта проверка пройдена, никакие дополнительные проверки не выполняются, независимо от того, сколько раз вызывающий объект может выполнять вызов. Однако эта проверка не обеспечивает защиту от атак с заманиванием. При использовании **LinkDemand** любой код, прошедший проверку и ссылающийся на код, может привести к нарушению безопасности, позволяя вредоносному коду вызывать код с помощью полномочного кода. Поэтому не используйте **LinkDemand** , если не все возможные недостатки могут быть тщательно исключены.  
  
    > [!NOTE]
    > В .NET Framework 4 требования к компоновке были заменены <xref:System.Security.SecurityCriticalAttribute> атрибутом в <xref:System.Security.SecurityRuleSet.Level2> сборках. Параметр <xref:System.Security.SecurityCriticalAttribute> эквивалентен запросу компоновки для полного доверия, однако он также влияет на правила наследования. Дополнительные сведения об этом изменении см. в разделе [прозрачный для системы безопасности код, уровень 2](security-transparent-code-level-2.md).  
  
 Дополнительные меры предосторожности, необходимые при использовании **LinkDemand** , должны программироваться по отдельности. система безопасности может помочь в обеспечении принудительного применения. Любая ошибка приводит к возникновению уязвимости в системе безопасности. Любой авторизованный код, использующий ваш код, должен отвечать за реализацию дополнительных мер защиты, выполняя следующие действия.  
  
- Ограничение доступа вызывающего кода к классу или сборке.  
  
- Размещение тех же проверок безопасности в вызывающем коде, который появляется в вызываемом коде, и принуждение вызывающих его объектов делать это. Например, при написании кода, который вызывает метод, защищенный с помощью **LinkDemand** для <xref:System.Security.Permissions.SecurityPermission> с <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> указанным флагом, метод должен также выполнить **LinkDemand** (или **Demand**, который является более надежным) для этого разрешения. Исключением является то, что в коде используется метод, защищенный с помощью **LinkDemand**, ограниченным способом, который можно выбрать в качестве безопасного, учитывая другие механизмы защиты (например, требования) в коде. В этом исключительном случае вызывающий объект несет ответственность за понижение степени защиты в базовом коде.  
  
- Обеспечение, чтобы вызывающие ваш код объекты не могли заставить его вызывать защищенный код от их имени. Другими словами, вызывающие объекты не должны иметь возможность заставить авторизованный код передавать определенные параметры в защищенный код или получить результаты из него.  
  
### <a name="interfaces-and-link-demands"></a>Интерфейсы и требования связывания  

 Если виртуальный метод, свойство или событие с **LinkDemand** переопределяет метод базового класса, метод базового класса также должен иметь такую же проверку **LinkDemand** для переопределенного метода, чтобы быть эффективным. Вредоносный код может выполнить обратное приведение к базовому типу и вызвать метод базового класса. Также обратите внимание, что требования связывания могут добавляться неявно в сборки, в которых отсутствует атрибут <xref:System.Security.AllowPartiallyTrustedCallersAttribute> уровня сборки.  
  
 Рекомендуется защищать реализации методов с помощью требований связывания, когда методы интерфейса также имеют требования связывания. Обратите внимание на следующие аспекты использования требований связывания с интерфейсами.  
  
- При помещении **LinkDemand** в открытый метод класса, который реализует метод интерфейса, **LinkDemand** не будет принудительно применен, если затем выполнить приведение к интерфейсу и вызвать метод. В этом случае, поскольку вы связались с интерфейсом, учитываются только **требования LinkDemand** в интерфейсе.  
  
 Изучите следующие элементы проблем безопасности.  
  
- Явные требования связывания в методах интерфейса. Убедитесь, что эти требования связывания обеспечивают ожидаемую защиту. Определите, может ли вредоносный код использовать приведение, чтобы обойти требования связывания, как описано выше.  
  
- Виртуальные методы с примененными требованиями связывания.  
  
- Типы и интерфейсы, которые они реализуют. Они должны согласованно использовать требования связывания.  
  
## <a name="see-also"></a>См. также

- [Правила написания безопасного кода](../../standard/security/secure-coding-guidelines.md)
