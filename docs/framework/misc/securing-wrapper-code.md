---
title: Безопасность кода программы-оболочки
ms.date: 03/30/2017
helpviewer_keywords:
- security [.NET Framework], wrapper code
- wrapper code, securing
- secure coding, wrapper code
- code security, wrapper code
ms.assetid: 1df6c516-5bba-48bd-b450-1070e04b7389
author: mairaw
ms.author: mairaw
ms.openlocfilehash: d4adfa5d592514c9a91c93095e7199f4b425b712
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2019
ms.locfileid: "64596639"
---
# <a name="securing-wrapper-code"></a>Безопасность кода программы-оболочки
[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]  
  
 Код программы-оболочки, особенно когда она имеет более высокий уровень доверия, чем код, который ее использует, может открыть уникальный набор уязвимостей системы безопасности. Все, что делается от имени вызывающего объекта, когда его ограниченные разрешения не включаются в соответствующую проверку безопасности, является потенциальной уязвимостью и может быть использовано злоумышленником.  
  
 Никогда не позволяйте осуществлять с помощью программы-оболочки действия, которые вызывающий объект не может выполнить самостоятельно. Особую опасность представляют действия, подразумевающие ограниченную проверку безопасности, в отличие от требования полного обхода стека. При использовании одноуровневых проверок внедрение кода программы-оболочки между настоящим вызывающим объектом и элементом API может легко привести к успешному прохождению проверки безопасности, когда это не должно было произойти, что ослабляет защиту.  
  
## <a name="delegates"></a>Делегаты  
 Защита делегатов различается в разных версиях .NET Framework.  В этом разделе описывается различное поведение делегатов и соответствующие вопросы безопасности.  
  
### <a name="in-version-10-and-11-of-the-net-framework"></a>В .NET Framework версий 1.0 и 1.1  
 В .NET Framework версий 1.0 и 1.1 с создателем делегата и вызывающим делегат объектом выполняются следующие действия по обеспечению безопасности.  
  
- При создании делегата требования связывания безопасности в целевом методе делегата выполняются по отношению к набору привилегий создателя делегата.  В результате сбоя при выполнении действия по обеспечению безопасности возникает исключение <xref:System.Security.SecurityException>.  
  
- При вызове делегата выполняются все существующие требования безопасности в вызывающем делегат объекте.  
  
 Каждый раз, когда код принимает <xref:System.Delegate> из менее доверенного кода, который может вызывать его, убедитесь, что менее доверенному коду не разрешено повышать уровень своих разрешений. Если делегат принимается, но используется позже, то код, создавший делегат, не находится в стеке вызовов, и его разрешения не будут проверяться, если код на уровне делегата или ниже попытается выполнить защищенную операцию. Если ваш код и код вызывающего объекта обладают более высокими привилегиями, чем создатель, то создатель может управлять путем вызова, не являясь частью стека вызовов.  
  
### <a name="in-version-20-and-later-versions-of-the-net-framework"></a>В версии 2.0 и более поздних версиях платформы .NET Framework  
 В отличие от предыдущих версий версии 2.0 и более поздних версиях платформы .NET Framework выполняет действие по обеспечению безопасности применяются к создателю делегата при создании и вызове делегата.  
  
- При создании делегата требования связывания безопасности в целевом методе делегата выполняются по отношению к набору привилегий создателя делегата.  В результате сбоя при выполнении действия по обеспечению безопасности возникает исключение <xref:System.Security.SecurityException>.  
  
- Набор прав создателя делегата также собирается при создании делегата и сохраняется с делегатом.  
  
- При вызове делегата сохраненный набор прав создателя делегата сначала оценивается по отношению ко всем требованиям в текущем контексте, если создатель делегата и вызывающий делегат объект принадлежат разным сборкам.  Затем выполняются все существующие требования безопасности в вызывающем делегат объекте.  
  
## <a name="link-demands-and-wrappers"></a>Требования связывания и программы-оболочки  
 В инфраструктуре безопасности особая защита была усилена с помощью требований связывания, но она по-прежнему является источником уязвимости в коде.  
  
 Если полностью доверенный код вызывает свойство, событие или метод, защищенный с [LinkDemand](../../../docs/framework/misc/link-demands.md), вызов завершается успешно, если **LinkDemand** выполняется проверка разрешений для вызывающего объекта. Кроме того, если полностью доверенный код предоставляет доступ к классу, который принимает имя свойства и вызывает его **получить** с помощью отражения, вызов метода доступа **получить** осуществляется, несмотря на то, что делает код пользователя имеет право на доступ к этому свойству. Это обусловлено **LinkDemand** проверяет только непосредственно вызывающего, который является полностью доверенным кодом. По существу полностью доверенный код выполняет привилегированный вызов от имени пользовательского кода, не убедившись в том, что пользовательский код имеет права для выполнения такого вызова.  
  
 Для предотвращения таких уязвимостей, среда CLR расширяет проверку до требования полного обхода стека при любом непрямом вызове метода, конструктора, свойства или события, защищенного с **LinkDemand**. Такая защита влечет за собой некоторое снижение производительности, а также меняет семантику проверки безопасности; требование полного обхода стека может завершиться ошибкой там, где была бы пройдена более быстрая одноуровневая проверка.  
  
## <a name="assembly-loading-wrappers"></a>Программы-оболочки, загружающие сборки  
 Некоторые методы, используемые для загрузки управляемого кода, включая <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>, загружают сборки со свидетельством вызывающего объекта. Если включить в программу-оболочку любой из этих методов, система безопасности может использовать для загрузки сборки предоставленные вашему коду разрешения вместо разрешений объекта, вызывающего вашу программу-оболочку. Не следует разрешать менее доверенному коду загружать код, который имеет более высокий уровень разрешений, чем объект, вызывающий вашу программу-оболочку.  
  
 Таким образом может быть ослаблена безопасность любого кода с полным уровнем доверия или значительно более высоким уровнем доверия, чем у потенциального вызывающего объекта (включая вызывающий объект уровня Интернет-разрешений). Если код содержит открытый метод, который принимает массив байтов и передает его **Assembly.Load**, тем самым создавая сборку от вызывающего объекта, он может нарушить безопасность.  
  
 Эта проблема относится к следующим элементам API:  
  
- <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=nameWithType>  
  
- <xref:System.AppDomain.Load%2A?displayProperty=nameWithType>  
  
- <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>  
  
- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>  
  
## <a name="demand-vs-linkdemand"></a>Demand и  LinkDemand  
 Декларативная безопасность предлагает два вида проверки безопасности, которые похожи, но выполняют совершенно разные проверки. Проанализируйте обе формы, так как неправильный выбор может привести к ослаблению безопасности или потере производительности.  
  
 Декларативная безопасность предлагает следующие проверки безопасности.  
  
- Проверка <xref:System.Security.Permissions.SecurityAction.Demand> указывает обход стека управления доступом для кода. Для прохождения этой проверки все вызывающие объекты в стеке должны иметь указанное разрешение или удостоверение. **Запросу** возникает при каждом вызове, так как стек может содержать различные вызывающие объекты. Если метод вызывается многократно, данная проверка безопасности происходит каждый раз. **Запросу** является хорошей защитой от атак с заманиванием; неавторизованный код, пытающийся пройти через эту будут обнаружены.  
  
- [LinkDemand](../../../docs/framework/misc/link-demands.md) происходит во время компиляции just-in-time (JIT) и проверяет только непосредственный вызывающий объект. Эта проверка безопасности не проверяет вызывающий объект вызывающего объекта. После того как эта проверка пройдена, никакие дополнительные проверки не выполняются, независимо от того, сколько раз вызывающий объект может выполнять вызов. Однако эта проверка не обеспечивает защиту от атак с заманиванием. С помощью **LinkDemand**, любой код, прошедший проверку и может ссылаться на ваш код может нарушить безопасность, позволив вредоносному коду осуществлять вызовы с использованием доверенного кода. Таким образом, не используйте **LinkDemand** Если не все возможные слабые места могут быть полностью защищены.  
  
    > [!NOTE]
    >  В [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], требования связывания были заменены <xref:System.Security.SecurityCriticalAttribute> атрибут в <xref:System.Security.SecurityRuleSet.Level2> сборок. <xref:System.Security.SecurityCriticalAttribute> Эквивалентен требованию связывания для полного доверия; Однако оно также влияет на правила наследования. Дополнительные сведения об этом изменении см. в разделе [прозрачный с точки зрения безопасности код, уровень 2](../../../docs/framework/misc/security-transparent-code-level-2.md).  
  
 Дополнительные меры предосторожности, необходимые при использовании **LinkDemand** должны программироваться в индивидуальном порядке; система безопасности, может помочь с их применением. Любая ошибка приводит к возникновению уязвимости в системе безопасности. Любой авторизованный код, использующий ваш код, должен отвечать за реализацию дополнительных мер защиты, выполняя следующие действия.  
  
- Ограничение доступа вызывающего кода к классу или сборке.  
  
- Размещение тех же проверок безопасности в вызывающем коде, который появляется в вызываемом коде, и принуждение вызывающих его объектов делать это. Например, если вы пишете код, вызывающий метод, который защищен с помощью **LinkDemand** для <xref:System.Security.Permissions.SecurityPermission> с <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> флаг задан, ваш метод также должен выполнять **LinkDemand** (или **Запросу**, которая надежнее) для данного разрешения. Исключение, если код использует **LinkDemand**-защищенный метод способом, который вы безопасным с учетом других механизмов обеспечения безопасности (например, требований) в коде. В этом исключительном случае вызывающий объект несет ответственность за понижение степени защиты в базовом коде.  
  
- Обеспечение, чтобы вызывающие ваш код объекты не могли заставить его вызывать защищенный код от их имени. Другими словами, вызывающие объекты не должны иметь возможность заставить авторизованный код передавать определенные параметры в защищенный код или получить результаты из него.  
  
### <a name="interfaces-and-link-demands"></a>Интерфейсы и требования связывания  
 Если виртуальный метод, свойство или событие с **LinkDemand** переопределяет метод базового класса, метод базового класса также должен иметь же **LinkDemand** чтобы обеспечить эффективность переопределенного метода. Вредоносный код может выполнить обратное приведение к базовому типу и вызвать метод базового класса. Также обратите внимание, что требования связывания могут добавляться неявно в сборки, в которых отсутствует атрибут <xref:System.Security.AllowPartiallyTrustedCallersAttribute> уровня сборки.  
  
 Рекомендуется защищать реализации методов с помощью требований связывания, когда методы интерфейса также имеют требования связывания. Обратите внимание на следующие аспекты использования требований связывания с интерфейсами.  
  
- Если поместить **LinkDemand** в открытый метод класса, реализующего метод интерфейса **LinkDemand** не будет применяться, если приведение к интерфейсу и вызвать метод. В этом случае поскольку выполнялось связывание с интерфейсом, только **LinkDemand** в интерфейсе будет учитываться.  
  
 Изучите следующие элементы проблем безопасности.  
  
- Явные требования связывания в методах интерфейса. Убедитесь, что эти требования связывания обеспечивают ожидаемую защиту. Определите, может ли вредоносный код использовать приведение, чтобы обойти требования связывания, как описано выше.  
  
- Виртуальные методы с примененными требованиями связывания.  
  
- Типы и интерфейсы, которые они реализуют. Они должны согласованно использовать требования связывания.  
  
## <a name="see-also"></a>См. также

- [Правила написания безопасного кода](../../../docs/standard/security/secure-coding-guidelines.md)
