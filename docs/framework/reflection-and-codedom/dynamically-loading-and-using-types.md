---
title: Динамическая загрузка и использование типов
description: Динамически загружайте и используйте типы в .NET. Используйте отражение, которое предоставляет инфраструктуру, с помощью которой компиляторы различных языков реализуют неявное позднее связывание.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
- cpp
helpviewer_keywords:
- late binding, about late binding
- early binding
- dynamically loading and using types
- implicit late binding
- reflection, dynamically using types
ms.assetid: db985bec-5942-40ec-b13a-771ae98623dc
ms.openlocfilehash: be9991a4df866f65aabe063be3cc2b374f4d124d
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/26/2020
ms.locfileid: "96266796"
---
# <a name="dynamically-loading-and-using-types"></a><span data-ttu-id="f93ae-104">Динамическая загрузка и использование типов</span><span class="sxs-lookup"><span data-stu-id="f93ae-104">Dynamically Loading and Using Types</span></span>

<span data-ttu-id="f93ae-105">Отражение предоставляет инфраструктуру, с помощью которой компиляторы различных языков реализуют неявное позднее связывание.</span><span class="sxs-lookup"><span data-stu-id="f93ae-105">Reflection provides infrastructure used by language compilers to implement implicit late binding.</span></span> <span data-ttu-id="f93ae-106">Привязка — это процесс поиска объявления (то есть реализации), которое соответствует уникально определенному типу.</span><span class="sxs-lookup"><span data-stu-id="f93ae-106">Binding is the process of locating the declaration (that is, the implementation) that corresponds to a uniquely specified type.</span></span> <span data-ttu-id="f93ae-107">Если этот процесс происходит во время выполнения, а не во время компиляции, он называется поздним связыванием.</span><span class="sxs-lookup"><span data-stu-id="f93ae-107">When this process occurs at run time rather than at compile time, it is called late binding.</span></span> <span data-ttu-id="f93ae-108">Visual Basic позволяет применять неявное позднее связывание в коде. Компилятор Visual Basic вызывает вспомогательный метод, который использует отражение для получения типа объекта.</span><span class="sxs-lookup"><span data-stu-id="f93ae-108">Visual Basic allows you to use implicit late binding in your code; the Visual Basic compiler calls a helper method that uses reflection to obtain the object type.</span></span> <span data-ttu-id="f93ae-109">Аргументы, передаваемые вспомогательному методу, приводят к вызову соответствующего метода во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="f93ae-109">The arguments passed to the helper method cause the appropriate method to be invoked at run time.</span></span> <span data-ttu-id="f93ae-110">Эти аргументы определяют экземпляр (объект), для которого вызывается метод, имя вызываемого метода (строка) и аргументы, передаваемые в вызываемый метод (массив объектов).</span><span class="sxs-lookup"><span data-stu-id="f93ae-110">These arguments are the instance (an object) on which to invoke the method, the name of the invoked method (a string), and the arguments passed to the invoked method (an array of objects).</span></span>  
  
 <span data-ttu-id="f93ae-111">В следующем примере компилятор Visual Basic неявно использует отражение для вызова метода объекта, тип которого неизвестен во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="f93ae-111">In the following example, the Visual Basic compiler uses reflection implicitly to call a method on an object whose type is not known at compile time.</span></span> <span data-ttu-id="f93ae-112">Класс **HelloWorld** содержит метод **PrintHello**, который выводит строку "Hello World" с некоторым текстом, который передается в метод **PrintHello**.</span><span class="sxs-lookup"><span data-stu-id="f93ae-112">A **HelloWorld** class has a **PrintHello** method that prints out "Hello World" concatenated with some text that is passed to the **PrintHello** method.</span></span> <span data-ttu-id="f93ae-113">Метод **PrintHello**, вызываемый в этом примере, на самом деле представляет собой <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>; код Visual Basic позволяет вызывать метод **PrintHello** так, как если бы тип объекта (helloObj) был известен уже во время компиляции (ранняя привязка), а не только во время выполнения (позднее связывание).</span><span class="sxs-lookup"><span data-stu-id="f93ae-113">The **PrintHello** method called in this example is actually a <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>; the Visual Basic code allows the **PrintHello** method to be invoked as if the type of the object (helloObj) were known at compile time (early binding) rather than at run time (late binding).</span></span>  
  
```vb
Module Hello  
    Sub Main()  
        ' Sets up the variable.  
        Dim helloObj As Object  
        ' Creates the object.  
        helloObj = new HelloWorld()  
        ' Invokes the print method as if it was early bound  
        ' even though it is really late bound.  
        helloObj.PrintHello("Visual Basic Late Bound")  
    End Sub  
End Module  
```  
  
## <a name="custom-binding"></a><span data-ttu-id="f93ae-114">Пользовательская привязка</span><span class="sxs-lookup"><span data-stu-id="f93ae-114">Custom Binding</span></span>  

 <span data-ttu-id="f93ae-115">Наряду с использованием в компиляторах для позднего связывания отражение можно явно использовать в коде для полного связывания.</span><span class="sxs-lookup"><span data-stu-id="f93ae-115">In addition to being used implicitly by compilers for late binding, reflection can be used explicitly in code to accomplish late binding.</span></span>  
  
 <span data-ttu-id="f93ae-116">[Общеязыковая среда выполнения](../../standard/clr.md) поддерживает несколько языков программирования, и правила связывания в этих языках различаются.</span><span class="sxs-lookup"><span data-stu-id="f93ae-116">The [common language runtime](../../standard/clr.md) supports multiple programming languages, and the binding rules of these languages differ.</span></span> <span data-ttu-id="f93ae-117">В случае раннего связывания генераторы кода могут полностью управлять этим связыванием.</span><span class="sxs-lookup"><span data-stu-id="f93ae-117">In the early-bound case, code generators can completely control this binding.</span></span> <span data-ttu-id="f93ae-118">Однако в случае позднего связывания через отражение связыванием необходимо управлять с помощью пользовательского связывания.</span><span class="sxs-lookup"><span data-stu-id="f93ae-118">However, in late binding through reflection, binding must be controlled by customized binding.</span></span> <span data-ttu-id="f93ae-119">Класс <xref:System.Reflection.Binder> предоставляет пользовательский элемент управления для выбора и вызова элемента.</span><span class="sxs-lookup"><span data-stu-id="f93ae-119">The <xref:System.Reflection.Binder> class provides custom control of member selection and invocation.</span></span>  
  
 <span data-ttu-id="f93ae-120">С помощью пользовательского связывания можно загрузить сборку во время выполнения, получить сведения о типах в этой сборке, определить нужный тип, а затем вызывать методы или обращаться к полям или свойствам этого типа.</span><span class="sxs-lookup"><span data-stu-id="f93ae-120">Using custom binding, you can load an assembly at run time, obtain information about types in that assembly, specify the type that you want, and then invoke methods or access fields or properties on that type.</span></span> <span data-ttu-id="f93ae-121">Этот способ полезен, если тип объекта во время компиляции неизвестен, например, если тип объекта зависит от входных данных пользователя.</span><span class="sxs-lookup"><span data-stu-id="f93ae-121">This technique is useful if you do not know an object's type at compile time, such as when the object type is dependent on user input.</span></span>  
  
 <span data-ttu-id="f93ae-122">Ниже приведен простой пользовательский класс привязки без преобразования типов аргументов.</span><span class="sxs-lookup"><span data-stu-id="f93ae-122">The following example demonstrates a simple custom binder that provides no argument type conversion.</span></span> <span data-ttu-id="f93ae-123">Код `Simple_Type.dll` приведен перед основным примером.</span><span class="sxs-lookup"><span data-stu-id="f93ae-123">Code for `Simple_Type.dll` precedes the main example.</span></span> <span data-ttu-id="f93ae-124">Соберите `Simple_Type.dll`, а затем включите в проект ссылку на него во время сборки.</span><span class="sxs-lookup"><span data-stu-id="f93ae-124">Be sure to build `Simple_Type.dll` and then include a reference to it in the project at build time.</span></span>  
  
 [!code-cpp[Conceptual.Types.Dynamic#1](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source1.cpp#1)]
 [!code-csharp[Conceptual.Types.Dynamic#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source1.cs#1)]
 [!code-vb[Conceptual.Types.Dynamic#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source1.vb#1)]  
  
### <a name="invokemember-and-createinstance"></a><span data-ttu-id="f93ae-125">InvokeMember и CreateInstance</span><span class="sxs-lookup"><span data-stu-id="f93ae-125">InvokeMember and CreateInstance</span></span>  

 <span data-ttu-id="f93ae-126">Используйте <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> для вызова члена типа.</span><span class="sxs-lookup"><span data-stu-id="f93ae-126">Use <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> to invoke a member of a type.</span></span> <span data-ttu-id="f93ae-127">Методы **CreateInstance** различных классов, таких как <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> и <xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=nameWithType>, представляют собой специализированные варианты метода **InvokeMember**, которые создают новые экземпляры указанного типа.</span><span class="sxs-lookup"><span data-stu-id="f93ae-127">The **CreateInstance** methods of various classes, such as <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> and <xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=nameWithType>, are specialized forms of **InvokeMember** that create new instances of the specified type.</span></span> <span data-ttu-id="f93ae-128">Класс **Binder** используется для разрешения перегрузки и приведения аргументов в этих методах.</span><span class="sxs-lookup"><span data-stu-id="f93ae-128">The **Binder** class is used for overload resolution and argument coercion in these methods.</span></span>  
  
 <span data-ttu-id="f93ae-129">В следующем примере показаны три возможных сочетания приведения аргументов (преобразования типов) и выбора членов.</span><span class="sxs-lookup"><span data-stu-id="f93ae-129">The following example shows the three possible combinations of argument coercion (type conversion) and member selection.</span></span> <span data-ttu-id="f93ae-130">В первом случае ни приведение аргументов, ни выбор членов не требуются.</span><span class="sxs-lookup"><span data-stu-id="f93ae-130">In Case 1, no argument coercion or member selection is needed.</span></span> <span data-ttu-id="f93ae-131">Во втором случае требуется только выбор членов.</span><span class="sxs-lookup"><span data-stu-id="f93ae-131">In Case 2, only member selection is needed.</span></span> <span data-ttu-id="f93ae-132">В третьем случае требуется только приведение аргументов.</span><span class="sxs-lookup"><span data-stu-id="f93ae-132">In Case 3, only argument coercion is needed.</span></span>  
  
 [!code-cpp[Conceptual.Types.Dynamic#2](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source2.cpp#2)]
 [!code-csharp[Conceptual.Types.Dynamic#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source2.cs#2)]
 [!code-vb[Conceptual.Types.Dynamic#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source2.vb#2)]  
  
 <span data-ttu-id="f93ae-133">Разрешение перегрузки необходимо, если существует несколько членов с одинаковыми именами.</span><span class="sxs-lookup"><span data-stu-id="f93ae-133">Overload resolution is needed when more than one member with the same name is available.</span></span> <span data-ttu-id="f93ae-134">Методы <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> и <xref:System.Reflection.Binder.BindToField%2A?displayProperty=nameWithType> используются для разрешения привязки к одному члену.</span><span class="sxs-lookup"><span data-stu-id="f93ae-134">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.Binder.BindToField%2A?displayProperty=nameWithType> methods are used to resolve binding to a single member.</span></span> <span data-ttu-id="f93ae-135">Метод **Binder.BindToMethod** также обеспечивает разрешение свойств с помощью методов доступа к свойствам **get** и **set**.</span><span class="sxs-lookup"><span data-stu-id="f93ae-135">**Binder.BindToMethod** also provides property resolution through the **get** and **set** property accessors.</span></span>  
  
 <span data-ttu-id="f93ae-136">Метод **BindToMethod** возвращает вызывающему объекту <xref:System.Reflection.MethodBase> или пустую ссылку (в Visual Basic **не возвращает ничего**), если такой вызов невозможен.</span><span class="sxs-lookup"><span data-stu-id="f93ae-136">**BindToMethod** returns the <xref:System.Reflection.MethodBase> to invoke, or a null reference (**Nothing** in Visual Basic) if no such invocation is possible.</span></span> <span data-ttu-id="f93ae-137">Возвращаемое значение метода **MethodBase** не обязательно должно содержаться в параметре *match*, хотя обычно это имеет место.</span><span class="sxs-lookup"><span data-stu-id="f93ae-137">The **MethodBase** return value need not be one of those contained in the *match* parameter, although that is the usual case.</span></span>  
  
 <span data-ttu-id="f93ae-138">При наличии аргументов ByRef может потребоваться вернуть их для вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="f93ae-138">When ByRef arguments are present, the caller might want to get them back.</span></span> <span data-ttu-id="f93ae-139">Таким образом, класс **Binder** позволяет клиенту вернуть массив аргументов в исходную форму, если метод **BindToMethod** изменил массив аргументов.</span><span class="sxs-lookup"><span data-stu-id="f93ae-139">Therefore, **Binder** allows a client to map the array of arguments back to its original form if **BindToMethod** has manipulated the argument array.</span></span> <span data-ttu-id="f93ae-140">Для этого необходимо гарантировать вызывающему объекту, что порядок аргументов не изменяется.</span><span class="sxs-lookup"><span data-stu-id="f93ae-140">In order to do this, the caller must be guaranteed that the order of the arguments is unchanged.</span></span> <span data-ttu-id="f93ae-141">Если аргументы передаются по имени, класс **Binder** изменяет порядок аргументов в массиве, и это видит вызывающий объект.</span><span class="sxs-lookup"><span data-stu-id="f93ae-141">When arguments are passed by name, **Binder** reorders the argument array, and that is what the caller sees.</span></span> <span data-ttu-id="f93ae-142">Для получения дополнительной информации см. <xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f93ae-142">For more information, see <xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f93ae-143">В набор доступных членов входят члены, которые определены в типе или любом базовом типе.</span><span class="sxs-lookup"><span data-stu-id="f93ae-143">The set of available members are those members defined in the type or any base type.</span></span> <span data-ttu-id="f93ae-144">Если указан параметр <xref:System.Reflection.BindingFlags>, в наборе будут возвращены члены с любым уровнем доступности.</span><span class="sxs-lookup"><span data-stu-id="f93ae-144">If <xref:System.Reflection.BindingFlags> is specified, members of any accessibility will be returned in the set.</span></span> <span data-ttu-id="f93ae-145">Если параметр **BindingFlags.NonPublic** не указан, модуль привязки должен применить правила доступа.</span><span class="sxs-lookup"><span data-stu-id="f93ae-145">If **BindingFlags.NonPublic** is not specified, the binder must enforce accessibility rules.</span></span> <span data-ttu-id="f93ae-146">Если указан флаг привязки **Public** или **NonPublic**, необходимо также указать флаг привязки **Instance** или **Static**, в противном случае ни одного члена не будет возвращено.</span><span class="sxs-lookup"><span data-stu-id="f93ae-146">When specifying the **Public** or **NonPublic** binding flag, you must also specify the **Instance** or **Static** binding flag, or no members will be returned.</span></span>  
  
 <span data-ttu-id="f93ae-147">Если имеется только один член с заданным именем, обратный вызов не требуется и привязка для этого метода считается выполненной.</span><span class="sxs-lookup"><span data-stu-id="f93ae-147">If there is only one member of the given name, no callback is necessary, and binding is done on that method.</span></span> <span data-ttu-id="f93ae-148">Этот аспект иллюстрируется в первом примере. Доступен только метод **PrintBob**, поэтому обратный вызов не требуется.</span><span class="sxs-lookup"><span data-stu-id="f93ae-148">Case 1 of the code example illustrates this point: Only one **PrintBob** method is available, and therefore no callback is needed.</span></span>  
  
 <span data-ttu-id="f93ae-149">Если в доступном наборе содержится несколько членов, все эти методы передаются методу **BindToMethod**, который выбирает нужный метод и возвращает его.</span><span class="sxs-lookup"><span data-stu-id="f93ae-149">If there is more than one member in the available set, all these methods are passed to **BindToMethod**, which selects the appropriate method and returns it.</span></span> <span data-ttu-id="f93ae-150">Во втором примере кода есть два метода с именем **PrintValue**.</span><span class="sxs-lookup"><span data-stu-id="f93ae-150">In Case 2 of the code example, there are two methods named **PrintValue**.</span></span> <span data-ttu-id="f93ae-151">Нужный метод выбирается с помощью вызова метода **BindToMethod**.</span><span class="sxs-lookup"><span data-stu-id="f93ae-151">The appropriate method is selected by the call to **BindToMethod**.</span></span>  
  
 <span data-ttu-id="f93ae-152"><xref:System.Reflection.Binder.ChangeType%2A> выполняет приведение аргументов (преобразование типов), при котором фактические аргументы преобразуются к типу формальных аргументов выбранного метода.</span><span class="sxs-lookup"><span data-stu-id="f93ae-152"><xref:System.Reflection.Binder.ChangeType%2A> performs argument coercion (type conversion), which converts the actual arguments to the type of the formal arguments of the selected method.</span></span> <span data-ttu-id="f93ae-153">Метод **ChangeType** вызывается для каждого аргумента, даже если типы полностью совпадают.</span><span class="sxs-lookup"><span data-stu-id="f93ae-153">**ChangeType** is called for every argument even if the types match exactly.</span></span>  
  
 <span data-ttu-id="f93ae-154">В третьем примере фактический аргумент типа **String** со значением "5.5" передается в метод с помощью формального аргумента типа **Double**.</span><span class="sxs-lookup"><span data-stu-id="f93ae-154">In Case 3 of the code example, an actual argument of type **String** with a value of "5.5" is passed to a method with a formal argument of type **Double**.</span></span> <span data-ttu-id="f93ae-155">Чтобы вызов был успешным строковое значение "5.5" необходимо преобразовать в тип Double.</span><span class="sxs-lookup"><span data-stu-id="f93ae-155">For the invocation to succeed, the string value "5.5" must be converted to a double value.</span></span> <span data-ttu-id="f93ae-156">Метод **ChangeType** выполняет это преобразование.</span><span class="sxs-lookup"><span data-stu-id="f93ae-156">**ChangeType** performs this conversion.</span></span>  
  
 <span data-ttu-id="f93ae-157">Метод **ChangeType** выполняет только приведение без потерь, или [расширяющее приведение](../../standard/base-types/type-conversion.md), как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="f93ae-157">**ChangeType** performs only lossless or [widening coercions](../../standard/base-types/type-conversion.md), as shown in the following table.</span></span>  
  
|<span data-ttu-id="f93ae-158">Тип исходного значения</span><span class="sxs-lookup"><span data-stu-id="f93ae-158">Source type</span></span>|<span data-ttu-id="f93ae-159">Тип результирующего значения</span><span class="sxs-lookup"><span data-stu-id="f93ae-159">Target type</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="f93ae-160">Любой тип</span><span class="sxs-lookup"><span data-stu-id="f93ae-160">Any type</span></span>|<span data-ttu-id="f93ae-161">Его базовый тип</span><span class="sxs-lookup"><span data-stu-id="f93ae-161">Its base type</span></span>|  
|<span data-ttu-id="f93ae-162">Любой тип</span><span class="sxs-lookup"><span data-stu-id="f93ae-162">Any type</span></span>|<span data-ttu-id="f93ae-163">Интерфейс, который он реализует</span><span class="sxs-lookup"><span data-stu-id="f93ae-163">Interface it implements</span></span>|  
|<span data-ttu-id="f93ae-164">Char</span><span class="sxs-lookup"><span data-stu-id="f93ae-164">Char</span></span>|<span data-ttu-id="f93ae-165">UInt16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="f93ae-165">UInt16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="f93ae-166">Byte</span><span class="sxs-lookup"><span data-stu-id="f93ae-166">Byte</span></span>|<span data-ttu-id="f93ae-167">Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="f93ae-167">Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="f93ae-168">SByte</span><span class="sxs-lookup"><span data-stu-id="f93ae-168">SByte</span></span>|<span data-ttu-id="f93ae-169">Int16, Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="f93ae-169">Int16, Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="f93ae-170">UInt16</span><span class="sxs-lookup"><span data-stu-id="f93ae-170">UInt16</span></span>|<span data-ttu-id="f93ae-171">UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="f93ae-171">UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="f93ae-172">Int16</span><span class="sxs-lookup"><span data-stu-id="f93ae-172">Int16</span></span>|<span data-ttu-id="f93ae-173">Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="f93ae-173">Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="f93ae-174">UInt32</span><span class="sxs-lookup"><span data-stu-id="f93ae-174">UInt32</span></span>|<span data-ttu-id="f93ae-175">UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="f93ae-175">UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="f93ae-176">Int32</span><span class="sxs-lookup"><span data-stu-id="f93ae-176">Int32</span></span>|<span data-ttu-id="f93ae-177">Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="f93ae-177">Int64, Single, Double</span></span>|  
|<span data-ttu-id="f93ae-178">UInt64</span><span class="sxs-lookup"><span data-stu-id="f93ae-178">UInt64</span></span>|<span data-ttu-id="f93ae-179">Single, Double</span><span class="sxs-lookup"><span data-stu-id="f93ae-179">Single, Double</span></span>|  
|<span data-ttu-id="f93ae-180">Int64</span><span class="sxs-lookup"><span data-stu-id="f93ae-180">Int64</span></span>|<span data-ttu-id="f93ae-181">Single, Double</span><span class="sxs-lookup"><span data-stu-id="f93ae-181">Single, Double</span></span>|  
|<span data-ttu-id="f93ae-182">Single</span><span class="sxs-lookup"><span data-stu-id="f93ae-182">Single</span></span>|<span data-ttu-id="f93ae-183">Double</span><span class="sxs-lookup"><span data-stu-id="f93ae-183">Double</span></span>|  
|<span data-ttu-id="f93ae-184">Нессылочный тип</span><span class="sxs-lookup"><span data-stu-id="f93ae-184">Nonreference type</span></span>|<span data-ttu-id="f93ae-185">Ссылочный тип</span><span class="sxs-lookup"><span data-stu-id="f93ae-185">Reference type</span></span>|  
  
 <span data-ttu-id="f93ae-186">Класс <xref:System.Type> содержит методы **Get**, которые используют параметры типа **Binder**, чтобы разрешить ссылки на конкретный член.</span><span class="sxs-lookup"><span data-stu-id="f93ae-186">The <xref:System.Type> class has **Get** methods that use parameters of type **Binder** to resolve references to a particular member.</span></span> <span data-ttu-id="f93ae-187">Методы <xref:System.Type.GetConstructor%2A?displayProperty=nameWithType>, <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> и <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> выполняют поиск определенного члена текущего типа по сведениям о подписи для этого члена.</span><span class="sxs-lookup"><span data-stu-id="f93ae-187"><xref:System.Type.GetConstructor%2A?displayProperty=nameWithType>, <xref:System.Type.GetMethod%2A?displayProperty=nameWithType>, and <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> search for a particular member of the current type by providing signature information for that member.</span></span> <span data-ttu-id="f93ae-188">Методы <xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=nameWithType> и <xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=nameWithType> используются в качестве методов обратного вызова для выбора заданных сведений о подписи для соответствующих методов.</span><span class="sxs-lookup"><span data-stu-id="f93ae-188"><xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=nameWithType> are called back on to select the given signature information of the appropriate methods.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f93ae-189">См. также</span><span class="sxs-lookup"><span data-stu-id="f93ae-189">See also</span></span>

- <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>
- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>
- [<span data-ttu-id="f93ae-190">Просмотр сведений о типах</span><span class="sxs-lookup"><span data-stu-id="f93ae-190">Viewing Type Information</span></span>](viewing-type-information.md)
- [<span data-ttu-id="f93ae-191">Преобразование типов в .NET Framework</span><span class="sxs-lookup"><span data-stu-id="f93ae-191">Type Conversion in the .NET Framework</span></span>](../../standard/base-types/type-conversion.md)
