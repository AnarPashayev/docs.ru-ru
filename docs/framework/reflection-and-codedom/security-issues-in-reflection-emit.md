---
title: Вопросы безопасности в порождаемом отражении
description: Изучите вопросы безопасности в порождаемом отражении, которое осуществляется через динамические сборки или динамические методы, подключенные к существующим сборкам или анонимно размещенные.
ms.date: 03/30/2017
helpviewer_keywords:
- partially trusted code
- emitting dynamic assemblies, security
- reflection emit, security
- reflection emit, partial trust scenarios
- partial trust,emitting dynamic methods
- anonymously hosted dynamic methods [.NET Framework]
- emitting dynamic assemblies,partial trust scenarios
- dynamic assemblies, security
ms.assetid: 0f8bf8fa-b993-478f-87ab-1a1a7976d298
ms.openlocfilehash: 62bce7435887855f799d320736e6bce8f39e5999
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/15/2020
ms.locfileid: "90558801"
---
# <a name="security-issues-in-reflection-emit"></a><span data-ttu-id="53cc0-103">Вопросы безопасности в порождаемом отражении</span><span class="sxs-lookup"><span data-stu-id="53cc0-103">Security Issues in Reflection Emit</span></span>
<span data-ttu-id="53cc0-104">Платформа .NET Framework предоставляет три способа создания промежуточного языка Майкрософт (MSIL), каждый из которых имеет собственные вопросы безопасности:</span><span class="sxs-lookup"><span data-stu-id="53cc0-104">The .NET Framework provides three ways to emit Microsoft intermediate language (MSIL), each with its own security issues:</span></span>  
  
- [<span data-ttu-id="53cc0-105">Динамические сборки</span><span class="sxs-lookup"><span data-stu-id="53cc0-105">Dynamic assemblies</span></span>](#Dynamic_Assemblies)  
  
- [<span data-ttu-id="53cc0-106">Анонимно размещенные динамические методы</span><span class="sxs-lookup"><span data-stu-id="53cc0-106">Anonymously hosted dynamic methods</span></span>](#Anonymously_Hosted_Dynamic_Methods)  
  
- [<span data-ttu-id="53cc0-107">Динамические методы, связанные с существующими сборками</span><span class="sxs-lookup"><span data-stu-id="53cc0-107">Dynamic methods associated with existing assemblies</span></span>](#Dynamic_Methods_Associated_with_Existing_Assemblies)  
  
 <span data-ttu-id="53cc0-108">Независимо от способа создания динамического кода для его выполнения необходимы все разрешения, которые требуются типам и методам, используемым этим кодом.</span><span class="sxs-lookup"><span data-stu-id="53cc0-108">Regardless of the way you generate dynamic code, executing the generated code requires all the permissions that are required by the types and methods the generated code uses.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="53cc0-109">Разрешения, необходимые для отражения и порождения кода, были изменены в последующих выпусках .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="53cc0-109">The permissions that are required for reflecting on code and emitting code have changed with succeeding releases of the .NET Framework.</span></span> <span data-ttu-id="53cc0-110">Подробнее см. в подразделе [Сведения о версиях](#Version_Information) далее в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="53cc0-110">See [Version Information](#Version_Information), later in this topic.</span></span>  
  
<a name="Dynamic_Assemblies"></a>
## <a name="dynamic-assemblies"></a><span data-ttu-id="53cc0-111">Динамические сборки</span><span class="sxs-lookup"><span data-stu-id="53cc0-111">Dynamic Assemblies</span></span>  
 <span data-ttu-id="53cc0-112">Динамические сборки создаются с помощью перегрузок метода <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53cc0-112">Dynamic assemblies are created by using overloads of the <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="53cc0-113">Большинство способов перегрузки этого метода не рекомендуется использовать в .NET Framework 4, так как политика безопасности на уровне компьютера больше не используется.</span><span class="sxs-lookup"><span data-stu-id="53cc0-113">Most overloads of this method are deprecated in the .NET Framework 4, because of the elimination of machine-wide security policy.</span></span> <span data-ttu-id="53cc0-114">(См. раздел [Изменения системы безопасности](/previous-versions/dotnet/framework/security/security-changes).) Остальные перегрузки могут выполняться из любого кода независимо от уровня доверия.</span><span class="sxs-lookup"><span data-stu-id="53cc0-114">(See [Security Changes](/previous-versions/dotnet/framework/security/security-changes).) The remaining overloads can be executed by any code, regardless of trust level.</span></span> <span data-ttu-id="53cc0-115">Эти перегрузки делятся на две группы: те, которые определяют список атрибутов, применяемых к динамической сборке при ее создании, и те, которые этого не делают.</span><span class="sxs-lookup"><span data-stu-id="53cc0-115">These overloads fall into two groups: those that specify a list of attributes to apply to the dynamic assembly when it is created, and those that do not.</span></span> <span data-ttu-id="53cc0-116">Если не указать модель прозрачности для сборки, применив атрибут <xref:System.Security.SecurityRulesAttribute> при ее создании, эта модель наследуется от порождающей сборки.</span><span class="sxs-lookup"><span data-stu-id="53cc0-116">If you do not specify the transparency model for the assembly, by applying the <xref:System.Security.SecurityRulesAttribute> attribute when you create it, the transparency model is inherited from the emitting assembly.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="53cc0-117">Атрибуты, применяемые к динамической сборке после ее создания с помощью метода <xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A>, не действуют, пока сборка не будет сохранена на диск и повторно загружена в память.</span><span class="sxs-lookup"><span data-stu-id="53cc0-117">Attributes that you apply to the dynamic assembly after it is created, by using the <xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A> method, do not take effect until the assembly has been saved to disk and loaded into memory again.</span></span>  
  
 <span data-ttu-id="53cc0-118">Код в динамической сборке может получать доступ к видимым типам и членам в других сборках.</span><span class="sxs-lookup"><span data-stu-id="53cc0-118">Code in a dynamic assembly can access visible types and members in other assemblies.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="53cc0-119">Динамические сборки не используют флаги <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> и <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>, разрешающие динамическим методам получать доступ к закрытым типам и членам.</span><span class="sxs-lookup"><span data-stu-id="53cc0-119">Dynamic assemblies do not use the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> and <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flags that allow dynamic methods to access nonpublic types and members.</span></span>  
  
 <span data-ttu-id="53cc0-120">Временные динамические сборки создаются в памяти и никогда не сохраняются на диск, поэтому им не требуются разрешения на доступ к файлам.</span><span class="sxs-lookup"><span data-stu-id="53cc0-120">Transient dynamic assemblies are created in memory and never saved to disk, so they require no file access permissions.</span></span> <span data-ttu-id="53cc0-121">Для сохранения динамической сборки на диск требуется разрешение <xref:System.Security.Permissions.FileIOPermission> с соответствующими флагами.</span><span class="sxs-lookup"><span data-stu-id="53cc0-121">Saving a dynamic assembly to disk requires <xref:System.Security.Permissions.FileIOPermission> with the appropriate flags.</span></span>  
  
### <a name="generating-dynamic-assemblies-from-partially-trusted-code"></a><span data-ttu-id="53cc0-122">Создание динамических сборок из частично доверенного кода</span><span class="sxs-lookup"><span data-stu-id="53cc0-122">Generating Dynamic Assemblies from Partially Trusted Code</span></span>  
 <span data-ttu-id="53cc0-123">Рассмотрим условия, в которых сборка с разрешениями на доступ к Интернету может создавать временную динамическую сборку и выполнять ее код.</span><span class="sxs-lookup"><span data-stu-id="53cc0-123">Consider the conditions in which an assembly with Internet permissions can generate a transient dynamic assembly and execute its code:</span></span>  
  
- <span data-ttu-id="53cc0-124">Динамическая сборка использует только открытые типы и члены других сборок.</span><span class="sxs-lookup"><span data-stu-id="53cc0-124">The dynamic assembly uses only public types and members of other assemblies.</span></span>  
  
- <span data-ttu-id="53cc0-125">Разрешения, необходимые для этих типов и членов, включаются в набор прав сборки с частичным доверием.</span><span class="sxs-lookup"><span data-stu-id="53cc0-125">The permissions demanded by those types and members are included in the grant set of the partially trusted assembly.</span></span>  
  
- <span data-ttu-id="53cc0-126">Сборка не сохраняется на диск.</span><span class="sxs-lookup"><span data-stu-id="53cc0-126">The assembly is not saved to disk.</span></span>  
  
- <span data-ttu-id="53cc0-127">Отладочные символы не создаются</span><span class="sxs-lookup"><span data-stu-id="53cc0-127">Debug symbols are not generated.</span></span> <span data-ttu-id="53cc0-128">(наборы разрешений `Internet` и `LocalIntranet` не включают необходимые разрешения).</span><span class="sxs-lookup"><span data-stu-id="53cc0-128">(`Internet` and `LocalIntranet` permission sets do not include the necessary permissions.)</span></span>  
  
<a name="Anonymously_Hosted_Dynamic_Methods"></a>
## <a name="anonymously-hosted-dynamic-methods"></a><span data-ttu-id="53cc0-129">Анонимно размещенные динамические методы</span><span class="sxs-lookup"><span data-stu-id="53cc0-129">Anonymously Hosted Dynamic Methods</span></span>  
 <span data-ttu-id="53cc0-130">Анонимно размещенные динамические методы создаются с помощью двух конструкторов <xref:System.Reflection.Emit.DynamicMethod>, которые не указывают связанный тип или модуль, <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%29> и <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29>.</span><span class="sxs-lookup"><span data-stu-id="53cc0-130">Anonymously hosted dynamic methods are created by using the two <xref:System.Reflection.Emit.DynamicMethod> constructors that do not specify an associated type or module, <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%29> and <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29>.</span></span> <span data-ttu-id="53cc0-131">Эти конструкторы размещают динамические методы в предоставляемой системой сборке, которая является полностью доверенной и прозрачный для системы безопасности.</span><span class="sxs-lookup"><span data-stu-id="53cc0-131">These constructors place the dynamic methods in a system-provided, fully trusted, security-transparent assembly.</span></span> <span data-ttu-id="53cc0-132">Для использования этих конструкторов или порождения кода для динамических методов разрешения не требуются.</span><span class="sxs-lookup"><span data-stu-id="53cc0-132">No permissions are required to use these constructors or to emit code for the dynamic methods.</span></span>  
  
 <span data-ttu-id="53cc0-133">Вместо этого при создании анонимно размещаемых динамических методов записывается стек вызовов.</span><span class="sxs-lookup"><span data-stu-id="53cc0-133">Instead, when an anonymously hosted dynamic method is created, the call stack is captured.</span></span> <span data-ttu-id="53cc0-134">При создании метода требования безопасности предъявляются к записанному стеку вызовов.</span><span class="sxs-lookup"><span data-stu-id="53cc0-134">When the method is constructed, security demands are made against the captured call stack.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="53cc0-135">Концептуально требования предъявляются во время создания метода.</span><span class="sxs-lookup"><span data-stu-id="53cc0-135">Conceptually, demands are made during the construction of the method.</span></span> <span data-ttu-id="53cc0-136">То есть требования могут предъявляться при порождении каждой инструкции MSIL.</span><span class="sxs-lookup"><span data-stu-id="53cc0-136">That is, demands could be made as each MSIL instruction is emitted.</span></span> <span data-ttu-id="53cc0-137">В текущей реализации все требования предъявляются при вызове метода <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A?displayProperty=nameWithType> или JIT-компилятора, если метод вызывается без вызова <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>.</span><span class="sxs-lookup"><span data-stu-id="53cc0-137">In the current implementation, all demands are made when the <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A?displayProperty=nameWithType> method is called or when the just-in-time (JIT) compiler is invoked, if the method is invoked without calling <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>.</span></span>  
  
 <span data-ttu-id="53cc0-138">Если домен приложения допускает такое поведение, анонимно размещенные динамические методы могут пропускать проверки видимости JIT-компилятора, однако действует следующее ограничение: закрытые типы и члены, к которым получает доступ анонимно размещенный динамический метод, должны находиться в сборках, наборы прав которых идентичны набору прав порождающего стека вызовов или являются его подмножествами.</span><span class="sxs-lookup"><span data-stu-id="53cc0-138">If the application domain permits it, anonymously hosted dynamic methods can skip JIT visibility checks, subject to the following restriction: The nonpublic types and members accessed by an anonymously hosted dynamic method must be in assemblies whose grant sets are equal to, or subsets of, the grant set of the emitting call stack.</span></span> <span data-ttu-id="53cc0-139">Эта ограниченная возможность пропускать проверки видимости JIT доступна, если домен приложения предоставляет разрешение <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53cc0-139">This restricted ability to skip JIT visibility checks is enabled if the application domain grants <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag.</span></span>  
  
- <span data-ttu-id="53cc0-140">Если метод использует только открытые типы и члены, во время его создания никакие разрешения не требуются.</span><span class="sxs-lookup"><span data-stu-id="53cc0-140">If your method uses only public types and members, no permissions are required during construction.</span></span>  
  
- <span data-ttu-id="53cc0-141">Если вы указываете, что проверки видимости JIT следует пропустить, требование, предъявляемое при создании метода, включает разрешение <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и набор прав сборки, содержащей закрытый член, к которому осуществляется доступ.</span><span class="sxs-lookup"><span data-stu-id="53cc0-141">If you specify that JIT visibility checks should be skipped, the demand that is made when the method is constructed includes <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and the grant set of the assembly that contains the nonpublic member that is being accessed.</span></span>  
  
 <span data-ttu-id="53cc0-142">Так как учитывается набор прав закрытого члена, частично доверенный код, которому предоставлено разрешение <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>, не может повысить свои привилегии путем выполнения закрытых членов доверенных сборок.</span><span class="sxs-lookup"><span data-stu-id="53cc0-142">Because the grant set of the nonpublic member is taken into consideration, partially trusted code that has been granted <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> cannot elevate its privileges by executing nonpublic members of trusted assemblies.</span></span>  
  
 <span data-ttu-id="53cc0-143">Как и для любого другого порожденного кода, для выполнения этого динамического метода необходимы те же разрешения, которые требуются методам, используемым этим динамическим методом.</span><span class="sxs-lookup"><span data-stu-id="53cc0-143">As with any other emitted code, executing the dynamic method requires whatever permissions are demanded by the methods the dynamic method uses.</span></span>  
  
 <span data-ttu-id="53cc0-144">Системная сборка, в которой размещаются анонимно размещенные динамические методы, использует модель прозрачности <xref:System.Security.SecurityRuleSet.Level1?displayProperty=nameWithType>, то есть модель, которая применялась в .NET Framework до версии .NET Framework 4.</span><span class="sxs-lookup"><span data-stu-id="53cc0-144">The system assembly that hosts anonymously-hosted dynamic methods uses the <xref:System.Security.SecurityRuleSet.Level1?displayProperty=nameWithType> transparency model, which is the transparency model that was used in the .NET Framework before the .NET Framework 4.</span></span>  
  
 <span data-ttu-id="53cc0-145">Дополнительные сведения см. в описании класса <xref:System.Reflection.Emit.DynamicMethod>.</span><span class="sxs-lookup"><span data-stu-id="53cc0-145">For more information, see the <xref:System.Reflection.Emit.DynamicMethod> class.</span></span>  
  
### <a name="generating-anonymously-hosted-dynamic-methods-from-partially-trusted-code"></a><span data-ttu-id="53cc0-146">Создание анонимно размещенных динамических методов из частично доверенного кода</span><span class="sxs-lookup"><span data-stu-id="53cc0-146">Generating Anonymously Hosted Dynamic Methods from Partially Trusted Code</span></span>  
 <span data-ttu-id="53cc0-147">Рассмотрим условия, в которых сборка с разрешениями на доступ к Интернету может создавать анонимно размещенный динамический метод и выполнять его.</span><span class="sxs-lookup"><span data-stu-id="53cc0-147">Consider the conditions in which an assembly with Internet permissions can generate an anonymously hosted dynamic method and execute it:</span></span>  
  
- <span data-ttu-id="53cc0-148">Динамический метод использует только открытые типы и члены.</span><span class="sxs-lookup"><span data-stu-id="53cc0-148">The dynamic method uses only public types and members.</span></span> <span data-ttu-id="53cc0-149">Если его набор прав включает <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>, он может использовать закрытые типы и члены любой сборки, набор прав которой идентичен набору прав порождающей сборки или является его подмножеством.</span><span class="sxs-lookup"><span data-stu-id="53cc0-149">If its grant set includes <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>, it can use nonpublic types and members of any assembly whose grant set is equal to, or a subset of, the grant set of the emitting assembly.</span></span>  
  
- <span data-ttu-id="53cc0-150">Разрешения, необходимые всем типам и членам, используемым динамическим методом, включены в набор прав сборки с частичным доверием.</span><span class="sxs-lookup"><span data-stu-id="53cc0-150">The permissions that are required by all the types and members used by the dynamic method are included in the grant set of the partially trusted assembly.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="53cc0-151">Динамические методы не поддерживают отладочные символы.</span><span class="sxs-lookup"><span data-stu-id="53cc0-151">Dynamic methods do not support debug symbols.</span></span>  
  
<a name="Dynamic_Methods_Associated_with_Existing_Assemblies"></a>
## <a name="dynamic-methods-associated-with-existing-assemblies"></a><span data-ttu-id="53cc0-152">Динамические методы, связанные с существующими сборками</span><span class="sxs-lookup"><span data-stu-id="53cc0-152">Dynamic Methods Associated with Existing Assemblies</span></span>  
 <span data-ttu-id="53cc0-153">Чтобы связать динамический метод с типом или модулем в существующей сборке, используйте любой из конструкторов <xref:System.Reflection.Emit.DynamicMethod>, который указывает связанный тип или модуль.</span><span class="sxs-lookup"><span data-stu-id="53cc0-153">To associate a dynamic method with a type or module in an existing assembly, use any of the <xref:System.Reflection.Emit.DynamicMethod> constructors that specify the associated type or module.</span></span> <span data-ttu-id="53cc0-154">Разрешения, необходимые для вызова этих конструкторов, могут быть разными, так как при связывании динамического метода с существующим типом или модулем он получает доступ к закрытым типам и членам.</span><span class="sxs-lookup"><span data-stu-id="53cc0-154">The permissions that are required to call these constructors vary, because associating a dynamic method with an existing type or module gives the dynamic method access to nonpublic types and members:</span></span>  
  
- <span data-ttu-id="53cc0-155">Динамический метод, связанный с типом, имеет доступ ко всем членам этого типа, даже к закрытым, а также ко всем внутренним типам и членам в сборке, содержащей связанный тип.</span><span class="sxs-lookup"><span data-stu-id="53cc0-155">A dynamic method that is associated with a type has access to all members of that type, even private members, and to all internal types and members in the assembly that contains the associated type.</span></span>  
  
- <span data-ttu-id="53cc0-156">Динамический метод, связанный с модулем, имеет доступ ко всем типам и членам `internal` (`Friend` в Visual Basic, `assembly` в метаданных среды CLR) в модуле.</span><span class="sxs-lookup"><span data-stu-id="53cc0-156">A dynamic method that is associated with a module has access to all the `internal` types and members (`Friend` in Visual Basic, `assembly` in common language runtime metadata) in the module.</span></span>  
  
 <span data-ttu-id="53cc0-157">Кроме того, можно использовать конструктор, который задает возможность пропускать проверки видимости JIT-компилятора.</span><span class="sxs-lookup"><span data-stu-id="53cc0-157">In addition, you can use a constructor that specifies the ability to skip the visibility checks of the JIT compiler.</span></span> <span data-ttu-id="53cc0-158">Это позволяет динамическому методу получать доступ ко всем типам и членам во всех сборках независимо от уровня доступа.</span><span class="sxs-lookup"><span data-stu-id="53cc0-158">Doing so gives your dynamic method access to all types and members in all assemblies, regardless of access level.</span></span>  
  
 <span data-ttu-id="53cc0-159">Разрешения, необходимые конструктору, зависят от уровня доступа, который вы намерены предоставить динамическому методу.</span><span class="sxs-lookup"><span data-stu-id="53cc0-159">The permissions demanded by the constructor depend on how much access you decide to give your dynamic method:</span></span>  
  
- <span data-ttu-id="53cc0-160">Если метод использует только открытые типы и члены и вы связываете его со своим собственным типом или модулем, никакие разрешения не требуются.</span><span class="sxs-lookup"><span data-stu-id="53cc0-160">If your method uses only public types and members, and you associate it with your own type or your own module, no permissions are required.</span></span>  
  
- <span data-ttu-id="53cc0-161">Если вы указываете, что проверки видимости JIT-компилятора следует пропустить, конструктору требуется разрешение <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53cc0-161">If you specify that JIT visibility checks should be skipped, the constructor demands <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.</span></span>  
  
- <span data-ttu-id="53cc0-162">Если динамический метод связывается с другим типом, даже с типом из вашей собственной сборки, конструктору требуется разрешение <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> и разрешение <xref:System.Security.Permissions.SecurityPermission> с флагом <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53cc0-162">If you associate the dynamic method with another type, even another type in your own assembly, the constructor demands <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag and <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag.</span></span>  
  
- <span data-ttu-id="53cc0-163">Если динамический метод связывается с типом или модулем в другой сборке, конструктору требуется разрешение <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и набор прав сборки, содержащей этот модуль.</span><span class="sxs-lookup"><span data-stu-id="53cc0-163">If you associate the dynamic method with a type or module in another assembly, the constructor demands two things: <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, and the grant set of the assembly that contains the other module.</span></span> <span data-ttu-id="53cc0-164">Таким образом, стек вызовов должен включать все разрешения из набора прав целевого модуля, а также разрешение <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53cc0-164">That is, your call stack must include all the permissions in the grant set of the target module, plus <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="53cc0-165">В целях обратной совместимости, если не удается удовлетворить потребность в целевом наборе прав и разрешении <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>, конструктору требуется разрешение <xref:System.Security.Permissions.SecurityPermission> с флагом <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53cc0-165">For backward compatibility, if the demand for the target grant set plus <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> fails, the constructor demands <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="53cc0-166">Несмотря на то что элементы в этом списке описываются в терминах набора прав порождающей сборки, помните, что требования предъявляются к полному стеку вызовов, включая границы домена приложения.</span><span class="sxs-lookup"><span data-stu-id="53cc0-166">Although the items in this list are described in terms of the grant set of the emitting assembly, remember that the demands are made against the full call stack, including the application domain boundary.</span></span>  
  
 <span data-ttu-id="53cc0-167">Дополнительные сведения см. в описании класса <xref:System.Reflection.Emit.DynamicMethod>.</span><span class="sxs-lookup"><span data-stu-id="53cc0-167">For more information, see the <xref:System.Reflection.Emit.DynamicMethod> class.</span></span>  
  
### <a name="generating-dynamic-methods-from-partially-trusted-code"></a><span data-ttu-id="53cc0-168">Создание динамических методов из частично доверенного кода</span><span class="sxs-lookup"><span data-stu-id="53cc0-168">Generating Dynamic Methods from Partially Trusted Code</span></span>  
  
> [!NOTE]
> <span data-ttu-id="53cc0-169">Для создания динамических методов из частично доверенного кода рекомендуется использовать [анонимно размещенные динамические методы](#Anonymously_Hosted_Dynamic_Methods).</span><span class="sxs-lookup"><span data-stu-id="53cc0-169">The recommended way to generate dynamic methods from partially trusted code is to use [anonymously hosted dynamic methods](#Anonymously_Hosted_Dynamic_Methods).</span></span>  
  
 <span data-ttu-id="53cc0-170">Рассмотрим условия, в которых сборка с разрешениями на доступ к Интернету может создавать динамический метод и выполнять его.</span><span class="sxs-lookup"><span data-stu-id="53cc0-170">Consider the conditions in which an assembly with Internet permissions can generate a dynamic method and execute it:</span></span>  
  
- <span data-ttu-id="53cc0-171">Либо динамический метод связан с порождающим его модулем или типом, либо его набор прав включает <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и он связан с модулем в сборке, набор прав которой идентичен набору прав порождающей сборки или является его подмножеством.</span><span class="sxs-lookup"><span data-stu-id="53cc0-171">Either the dynamic method is associated with the module or type that emits it, or its grant set includes <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> and it is associated with a module in an assembly whose grant set is equal to, or a subset of, the grant set of the emitting assembly.</span></span>  
  
- <span data-ttu-id="53cc0-172">Динамический метод использует только открытые типы и члены.</span><span class="sxs-lookup"><span data-stu-id="53cc0-172">The dynamic method uses only public types and members.</span></span> <span data-ttu-id="53cc0-173">Если его набор прав включает <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и он связан с модулем в сборке, набор прав которой идентичен набору прав порождающей сборки или является его подмножеством, он может использовать типы и члены, помеченные как `internal` (`Friend` в Visual Basic, `assembly` в метаданных среды CLR) в связанном модуле.</span><span class="sxs-lookup"><span data-stu-id="53cc0-173">If its grant set includes <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> and it is associated with a module in an assembly whose grant set is equal to, or a subset of, the grant set of the emitting assembly, it can use types and members marked `internal` (`Friend` in Visual Basic, `assembly` in common language runtime metadata) in the associated module.</span></span>  
  
- <span data-ttu-id="53cc0-174">Разрешения, необходимые всем типам и членам, используемым динамическим методом, включены в набор прав сборки с частичным доверием.</span><span class="sxs-lookup"><span data-stu-id="53cc0-174">The permissions demanded by all the types and members used by the dynamic method are included in the grant set of the partially trusted assembly.</span></span>  
  
- <span data-ttu-id="53cc0-175">Динамический метод не пропускает проверки видимости JIT-компилятора.</span><span class="sxs-lookup"><span data-stu-id="53cc0-175">The dynamic method does not skip JIT visibility checks.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="53cc0-176">Динамические методы не поддерживают отладочные символы.</span><span class="sxs-lookup"><span data-stu-id="53cc0-176">Dynamic methods do not support debug symbols.</span></span>  
  
<a name="Version_Information"></a>
## <a name="version-information"></a><span data-ttu-id="53cc0-177">Сведения о версии</span><span class="sxs-lookup"><span data-stu-id="53cc0-177">Version Information</span></span>  
 <span data-ttu-id="53cc0-178">Начиная с .NET Framework 4 политика безопасности на уровне компьютера больше не используется, и механизмом обеспечения безопасности по умолчанию становится прозрачность безопасности.</span><span class="sxs-lookup"><span data-stu-id="53cc0-178">Starting with the .NET Framework 4, machine-wide security policy is eliminated and security transparency becomes the default enforcement mechanism.</span></span> <span data-ttu-id="53cc0-179">См. раздел [Изменения системы безопасности](/previous-versions/dotnet/framework/security/security-changes).</span><span class="sxs-lookup"><span data-stu-id="53cc0-179">See [Security Changes](/previous-versions/dotnet/framework/security/security-changes).</span></span>  
  
 <span data-ttu-id="53cc0-180">Начиная с .NET Framework 2.0 с пакетом обновления 1 (SP1), разрешение <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> больше не требуется при порождении динамических сборок и динамических методов.</span><span class="sxs-lookup"><span data-stu-id="53cc0-180">Starting with the .NET Framework 2.0 Service Pack 1, <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag is no longer required when emitting dynamic assemblies and dynamic methods.</span></span> <span data-ttu-id="53cc0-181">Этот флаг необходим во всех более ранних версиях платформы .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="53cc0-181">This flag is required in all earlier versions of the .NET Framework.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="53cc0-182">Разрешение <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> включается по умолчанию в именованные наборы разрешений `FullTrust` и `LocalIntranet`, но не в набор разрешений `Internet`.</span><span class="sxs-lookup"><span data-stu-id="53cc0-182"><xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag is included by default in the `FullTrust` and `LocalIntranet` named permission sets, but not in the `Internet` permission set.</span></span> <span data-ttu-id="53cc0-183">Таким образом, в более ранних версиях платформы .NET Framework библиотеку можно использовать с разрешениями на доступ к Интернету только в том случае, если она выполняет <xref:System.Security.PermissionSet.Assert%2A> для <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>.</span><span class="sxs-lookup"><span data-stu-id="53cc0-183">Therefore, in earlier versions of the .NET Framework, a library can be used with Internet permissions only if it executes an <xref:System.Security.PermissionSet.Assert%2A> for <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>.</span></span> <span data-ttu-id="53cc0-184">Такие библиотеки требуют тщательной проверки безопасности, так как ошибки в коде могут стать причиной уязвимости.</span><span class="sxs-lookup"><span data-stu-id="53cc0-184">Such libraries require careful security review because coding errors could result in security holes.</span></span> <span data-ttu-id="53cc0-185">Платформа .NET Framework 2.0 с пакетом обновления 1 (SP1) позволяет создавать код в сценариях частичного доверия без предъявления каких-либо требований к безопасности, так как создание кода по сути не является привилегированной операцией.</span><span class="sxs-lookup"><span data-stu-id="53cc0-185">The .NET Framework 2.0 SP1 allows code to be emitted in partial trust scenarios without issuing any security demands, because generating code is not inherently a privileged operation.</span></span> <span data-ttu-id="53cc0-186">То есть созданный код имеет не больше разрешений, чем породившая его сборка.</span><span class="sxs-lookup"><span data-stu-id="53cc0-186">That is, the generated code has no more permissions than the assembly that emits it.</span></span> <span data-ttu-id="53cc0-187">Это позволяет библиотекам, порождающим код, сохранять прозрачность для системы безопасности, что устраняет необходимость в утверждении перечисления <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit> и упрощает задачу написания безопасной библиотеки.</span><span class="sxs-lookup"><span data-stu-id="53cc0-187">This allows libraries that emit code to be security transparent and removes the need to assert <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>, which simplifies the task of writing a secure library.</span></span>  
  
 <span data-ttu-id="53cc0-188">Кроме того, в .NET Framework 2.0 с пакетом обновления 1 (SP1) появился флаг <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> для доступа к закрытым типам и членам из частично доверенных динамических методов.</span><span class="sxs-lookup"><span data-stu-id="53cc0-188">In addition, the .NET Framework 2.0 SP1 introduces the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag for accessing nonpublic types and members from partially trusted dynamic methods.</span></span> <span data-ttu-id="53cc0-189">Более ранние версии платформы .NET Framework требуют флаг <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> для динамических методов, которые обращаются к закрытым типам и членам; это разрешение, которое никогда не должно предоставляться частично доверенному коду.</span><span class="sxs-lookup"><span data-stu-id="53cc0-189">Earlier versions of the .NET Framework require the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag for dynamic methods that access nonpublic types and members; this is a permission that should never be granted to partially trusted code.</span></span>  
  
 <span data-ttu-id="53cc0-190">Наконец, в .NET Framework 2.0 с пакетом обновления 1 (SP1) реализованы анонимно размещенные методы.</span><span class="sxs-lookup"><span data-stu-id="53cc0-190">Finally, the .NET Framework 2.0 SP1 introduces anonymously hosted methods.</span></span>  
  
### <a name="obtaining-information-on-types-and-members"></a><span data-ttu-id="53cc0-191">Получение сведений о типах и членах</span><span class="sxs-lookup"><span data-stu-id="53cc0-191">Obtaining Information on Types and Members</span></span>  
 <span data-ttu-id="53cc0-192">Начиная с .NET Framework 2.0 для получения сведений о закрытых типах и членах никакие разрешения не требуются.</span><span class="sxs-lookup"><span data-stu-id="53cc0-192">Starting with the .NET Framework 2.0, no permissions are required to obtain information about nonpublic types and members.</span></span> <span data-ttu-id="53cc0-193">Для получения сведений, необходимых для порождения динамических методов, используется отражение.</span><span class="sxs-lookup"><span data-stu-id="53cc0-193">Reflection is used to obtain information needed to emit dynamic methods.</span></span> <span data-ttu-id="53cc0-194">Например, объекты <xref:System.Reflection.MethodInfo> используются для порождения вызовов метода.</span><span class="sxs-lookup"><span data-stu-id="53cc0-194">For example, <xref:System.Reflection.MethodInfo> objects are used to emit method calls.</span></span> <span data-ttu-id="53cc0-195">Более ранние версии платформы .NET Framework требуют <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53cc0-195">Earlier versions of the .NET Framework require <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="53cc0-196">Дополнительные сведения см. в разделе [Соображения о безопасности для отражения](security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="53cc0-196">For more information, see [Security Considerations for Reflection](security-considerations-for-reflection.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="53cc0-197">См. также</span><span class="sxs-lookup"><span data-stu-id="53cc0-197">See also</span></span>

- [<span data-ttu-id="53cc0-198">Соображения о безопасности для отражения</span><span class="sxs-lookup"><span data-stu-id="53cc0-198">Security Considerations for Reflection</span></span>](security-considerations-for-reflection.md)
- [<span data-ttu-id="53cc0-199">Предоставление динамических методов и сборок</span><span class="sxs-lookup"><span data-stu-id="53cc0-199">Emitting Dynamic Methods and Assemblies</span></span>](emitting-dynamic-methods-and-assemblies.md)
