---
title: Оценка критических изменений (.NET Core)
description: Узнайте, какими методами в .NET Core обеспечивается совместимость между версиями .NET. для разработчиков.
ms.date: 06/10/2019
ms.openlocfilehash: 3ad3cbe36ee09d371e26dc7da36a31207a6c1b25
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/12/2019
ms.locfileid: "73973648"
---
# <a name="evaluate-breaking-changes-in-net-core"></a>Оценка критических изменений в .NET Core

На протяжении всей истории своего развития в .NET по возможности поддерживался высокий уровень совместимости между версиями и вариантами этой платформы. Этот подход сохраняется и для .NET Core. Хотя .NET Core можно считать новой технологией, которая не зависит от .NET Framework, возможность независимого от .NET Framework развития .NET Core ограничивается следующими двумя факторами:

- Большое количество разработчиков разрабатывали ранее и продолжают разрабатывать приложения для .NET Framework. Все они рассчитывают на согласованное поведение разных реализаций .NET.

- Проекты библиотек .NET Standard позволяют разработчикам создавать библиотеки для распространенных API, которые совместно используются в .NET Core и .NET Framework. Разработчики ожидают, что библиотеки из приложения .NET Core будут вести себя точно так же, как аналогичные библиотеки в приложении .NET Framework.

Кроме совместимости разных реализаций .NET, разработчики также ожидают высокий уровень совместимости между версиями .NET Core. В частности, код, написанный для более ранней версии .NET Core, должен без проблем работать в любой последующей версии .NET Core. Более того, многие разработчики ожидают, что новые API в свежих версиях .NET Core будут также совместимы с предварительными версиями, в которых впервые появились эти API.

В этой статье описаны категории изменений, влияющих на совместимость (критических изменений), и методы оценки, которые использует команда .NET для каждой из этих категорий. Понимать подход, который команда разработчиков .NET использует для оценки возможных критических изменений, особенно важно для тех специалистов, которые создают в репозитории GitHub [dotnet/corefx](https://github.com/dotnet/corefx) запросы на вытягивание с изменением поведения существующих API.

> [!NOTE]
> См. [определения категорий совместимости, таких как совместимость на уровне двоичного кода и обратная совместимость](categories.md).

В следующих разделах описываются категории изменений, внесенных в API .NET Core, и их влияние на совместимость приложений. Значок ✔️ указывает, что изменение разрешено; значок ❌ означает, что изменение запрещено; а значок ❓ обозначает изменение, которое может быть разрешено или запрещено. Для изменений в этой последней категории требуется оценочное суждение о предсказуемости и очевидности, а также согласованности таких изменений с прежним поведением.

> [!NOTE]
> Эти критерии для разработчиков библиотек служат не только руководством по оценке изменений в библиотеках .NET Core, но и помогают оценить изменения в собственных библиотеках, которые предназначены для разных реализаций и версий .NET.

## <a name="modifications-to-the-public-contract"></a>Изменения в открытом контракте

Изменения в этой категории *изменяют* общую контактную зону для типа. Большинство изменений в этой категории запрещены, так как они нарушают *обратную совместимость* (возможность выполнять приложения, разработанные для предыдущих версий API, без повторной компиляции для более поздней версии).

### <a name="types"></a>Типы

- **✔️ Удаление реализации интерфейса из типа, если этот интерфейс уже реализован в базовом типе**

- **❓Добавление новой реализации интерфейса в тип**

  Это допустимое изменение, так как оно не сказывается отрицательно на существующих клиентах. Чтобы новая реализация оставалась допустимой, любые изменения типа должны выполняться в пределах допустимых изменений, которые определены здесь. Следует соблюдать предельную осторожность при добавлении интерфейсов, которые напрямую влияют на способность конструктора или сериализатора создавать код или данные, которые нельзя использовать на нижнем уровне. Пример — интерфейс <xref:System.Runtime.Serialization.ISerializable>.

- **❓ Добавление нового базового класса**

  Тип можно включать в иерархию между двумя существующими типами, если он не включает новые [абстрактные](../../csharp/language-reference/keywords/abstract.md) элементы и не изменяет семантику или поведение существующих типов. Например, в .NET Framework 2.0 класс <xref:System.Data.Common.DbConnection> стал новым базовым классом для <xref:System.Data.SqlClient.SqlConnection> с наследованием напрямую от <xref:System.ComponentModel.Component>.

- **✔️ Перемещение типа из одной сборки в другую**

  Обратите внимание, что *старой* сборке следует присвоить метку <xref:System.Runtime.CompilerServices.TypeForwardedToAttribute>, указывающую на новую сборку.

- **✔️ Изменение типа [struct](../../csharp/language-reference/keywords/struct.md) на тип `readonly struct`**

  Обратите внимание, что изменение типа `readonly struct` на тип `struct` запрещено.

- **✔️ Добавление ключевых слов [sealed](../../csharp/language-reference/keywords/sealed.md) или [abstract](../../csharp/language-reference/keywords/abstract.md) к типу, в котором нет *доступных* конструкторов (открытых или защищенных)**

- **✔️ Расширение видимости типа**

- **❌ Изменение пространства имен или имени типа**

- **❌ Переименование или удаление открытого типа**

   Это изменение нарушает весь код, в котором использовался переименованный или удаленный тип.

- **❌ Изменение базового типа для перечисления**

   Это критическое изменение нарушает процесс компиляции и поведение приложения, а также совместимость на двоичном уровне вплоть до невозможности анализировать аргументы атрибутов.

- **❌ Запечатывание типа, который ранее был незапечатанным**

- **❌ Добавление интерфейса в набор базовых типов интерфейса**

   Если интерфейс реализует другой интерфейс, который ранее не был в нем реализован, нарушаются все типы, которые реализовали исходную версию этого интерфейса.

- **❓Удаление класса из набора базовых классов или интерфейса из набора реализованных интерфейсов**

  Есть одно исключение из правила удаления интерфейса: вы можете добавить реализацию интерфейса, наследуемую от удаленного интерфейса. Например, можно удалить <xref:System.IDisposable>, если тип или интерфейс теперь реализуют <xref:System.ComponentModel.IComponent> с реализацией <xref:System.IDisposable>.

- **❌ Изменение типа `readonly struct` на тип [struct](../../csharp/language-reference/keywords/struct.md)**

  Обратите внимание, что изменение типа `struct` на тип `readonly struct` разрешено.

- **❌ Изменение типа [struct](../../csharp/language-reference/keywords/struct.md) на тип `ref struct` и наоборот**

- **❌ Снижение видимости типа**

   При этом увеличение видимости типа разрешено.

### <a name="members"></a>Участники

- **✔️ Расширение видимости для элемента, который не является [виртуальным](../../csharp/language-reference/keywords/sealed.md)**

- **✔️ Добавление абстрактного элемента в открытый тип без *доступных* конструкторов (открытых или защищенных) или в [запечатанный тип](../../csharp/language-reference/keywords/sealed.md)**

  При этом добавление абстрактного элемента в тип с доступными конструкторами (открытыми или защищенными) и в незапечатанный тип (`sealed`) разрешено.

- **✔️ Ограничение видимости [защищенного](../../csharp/language-reference/keywords/protected.md) элемента, если у типа нет доступных (открытых или защищенных) конструкторов или этот тип [запечатан](../../csharp/language-reference/keywords/sealed.md)**

- **✔️ Перемещение элемента в класс, расположенный в иерархии выше тип, из которого он был удален**

- **✔️ Добавление или удаление переопределения**

  Обратите внимание, что добавление переопределения может привести к тому, что прежние пользователи не будут его использовать при вызове [базового](../../csharp/language-reference/keywords/base.md) типа.

- **✔️ Добавление в класс конструктора одновременно с конструктором без параметров, если ранее у этого класса не было конструкторов**

   При этом добавление конструктора в класс, ранее не имевший конструкторов, *без* добавления конструктора без параметров, не разрешено.

- **✔️ Изменение [абстрактного](../../csharp/language-reference/keywords/abstract.md) элемента на [виртуальный](../../csharp/language-reference/keywords/virtual.md)**

- **✔️ Изменение возвращаемого значения с `ref readonly` на `ref` (за исключением виртуальных методов или интерфейсов)**

- **✔️ Удаление из поля метки [readonly](../../csharp/language-reference/keywords/readonly.md), за исключением полей со статическим типом изменяемого значения**

- **✔️ Вызов нового события, которое не было определено ранее**

- **❓ Добавление нового поля экземпляра к типу**

   Это изменение влияет на сериализацию.

- **❌ Переименование или удаление открытого типа или параметра**

   Это изменение нарушает весь код, в котором использовался переименованный или удаленный элемент либо параметр.

   Обратите внимание, что сюда относятся удаление и переименование методов получения и определения свойств, а также элементов перечисления.

- **❌ Добавление элемента к интерфейсу**

- **❌ Изменение значения общедоступной константы или элемента перечисления**

- **❌ Изменение типа для свойства, поля, параметра или возвращаемого значения**

- **❌ Добавление, удаление параметров или изменение их порядка**

- **❌ Добавление или удаление ключевого слова [in](../../csharp/language-reference/keywords/in.md), [out](../../csharp/language-reference/keywords/out.md) или [ref](../../csharp/language-reference/keywords/ref.md) для параметра**

- **❌ Переименование параметра (в том числе изменение регистра символов)**

  Такое изменение считается критическим по двум причинам:

  - Оно нарушает сценарии с поздним связыванием, например функцию поздней привязки в Visual Basic и функцию [dynamic](../../csharp/language-reference/builtin-types/reference-types.md#the-dynamic-type) в C#.

  - Оно нарушает [совместимость на уровне кода](categories.md#source-compatibility), если разработчик использует [именованные аргументы](../../csharp/programming-guide/classes-and-structs/named-and-optional-arguments.md#named-arguments).

- **❌ Изменение возвращаемого значения с `ref` на `ref readonly`**

- **❌ Изменение возвращаемого значения с `ref readonly` на `ref` для виртуальных методов или интерфейсов**

- **❌ Добавление или удаление ключевого слова [abstract](../../csharp/language-reference/keywords/abstract.md) для элемента**

- **❌ Удаление ключевого слова [virtual](../../csharp/language-reference/keywords/virtual.md) для элемента**

  Такое изменение часто не является критическим, так как компилятор C# обычно выдает инструкции [callvirt](<xref:System.Reflection.Emit.OpCodes.Callvirt>) на промежуточном языке (IL) для вызова невиртуальных методов (`callvirt`, в отличие об обычного кода, выполняет проверку значений null). При этом такое поведение не может считаться стабильным по следующим причинам:
  - .NET используется не только с C#, но и с другими языками.

  - Компилятор C# продолжает попытки оптимизировать `callvirt` в обычный вызов, если целевой метод не является виртуальным и с высокой вероятностью не имеет значения null (например, метод с доступом с использованием [оператора распространения значений null ?.](../../csharp/language-reference/operators/member-access-operators.md#null-conditional-operators--and-)).

  Преобразование метода в виртуальный означает, что код объекта-получателя будет часто вызывать его не виртуально.

- **❌ Добавление ключевого слова [virtual](../../csharp/language-reference/keywords/virtual.md) к элементу**

- **❌ Преобразование виртуального элемента в абстрактный**

  [Виртуальный элемент](../../csharp/language-reference/keywords/virtual.md) предоставляет реализацию метода, которую *можно* переопределить производным классом. [Абстрактный элемент](../../csharp/language-reference/keywords/abstract.md) не предоставляет реализацию и *должен быть* переопределен.

- **❌ Добавление абстрактного элемента в общедоступный тип с доступными конструкторами (открытыми или защищенными) и [незапечатанный тип](../../csharp/language-reference/keywords/sealed.md)**

- **❌ Добавление в элемент ключевого слова [static](../../csharp/language-reference/keywords/static.md) или его удаление**

- **❌ Добавление перегрузки, которая исключает существующую перегрузку и определяет другое поведение**

  Такое изменение нарушает логику существующих клиентов, которые зависели от предыдущей перегрузки. Например, если у класса есть одна версия метода, которая принимает <xref:System.UInt32>, существующий получатель будет успешно привязан к этой перегрузке при отправке значения <xref:System.Int32>. Но если вы добавите перегрузку, которая принимает <xref:System.Int32>, при повторной компиляции или при использовании позднего связывания компилятор будет выполнять привязку к новой перегрузке. Любые изменения, приводящие к разным реакциям на события, считаются критическими.

- **❌ Добавление конструктора в класс, ранее не имевший конструкторов, без добавления конструктора без параметров**

- **❌ Добавление ключевого слова [readonly](../../csharp/language-reference/keywords/readonly.md) в поле**

- **❌ Снижение видимости элемента**

   Сюда входит ограничение видимости [защищенного](../../csharp/language-reference/keywords/protected.md) элемента, если у типа нет *доступных* (открытых или защищенных) конструкторов или этот тип *не является* [запечатанным](../../csharp/language-reference/keywords/sealed.md). Если это не так, снижение видимости защищенного элемента разрешено.

   Обратите внимание, что увеличение видимости типа разрешено.

- **❌ Изменение типа элемента**

   Возвращаемое значение метода или типа свойства или поля изменить нельзя. Например, сигнатуру метода, который возвращает <xref:System.Object>, нельзя изменить так, чтобы он возвращал <xref:System.String>, или наоборот.

- **❌ Добавление поля к структуре, у которой ранее не было состояний**

  Правила определенного назначения допускают использование неинициализированных переменных, если переменная имеет тип структуры без отслеживания состояния. Если этой структуре добавить отслеживание состояния, код может получить неинициализированные данные. Такое изменение может быть критическим на уровне источника и двоичного кода.

- **❌ Вызов существующего события, которое ранее никогда не срабатывало**

## <a name="behavioral-changes"></a>Изменения в поведении

### <a name="assemblies"></a>Сборки

- **✔️ Преобразование сборки в переносимую при сохранении поддержки тех же платформ**

- **❌ Изменение имени сборки**
- **❌ Изменение открытого ключа сборки**

### <a name="properties-fields-parameters-and-return-values"></a>Свойства, поля, параметры и возвращаемые значения

- **✔️ Изменение значения для свойства, поля, возвращаемого значения или параметра [out](../../csharp/language-reference/keywords/out-parameter-modifier.md) на более производный тип**

  Например, метод, возвращающий тип <xref:System.Object>, может возвращать экземпляр <xref:System.String>. (Но при этом сигнатура метода не должна изменяться.)

- **✔️ Увеличение диапазона допустимых значений для свойства или параметра, если элемент не является [виртуальным](../../csharp/language-reference/keywords/virtual.md)**

  Обратите внимание, что можно расширять диапазон значений, которые передаются методу или возвращаются из него, но нельзя расширять тип параметра или элемента. Например, диапазон передаваемых методу значений можно расширить с 0–124 до 0–255, но нельзя изменить тип параметра с <xref:System.Byte> на <xref:System.Int32>.

- **❌ Увеличение диапазона допустимых значений для свойства или параметра, если элемент является [виртуальным](../../csharp/language-reference/keywords/virtual.md)**

   Такое изменение нарушает существующие переопределенные элементы, которые не будут правильно работать с расширенным диапазоном значений.

- **❌ Уменьшение диапазона допустимых значений для свойства или параметра**

- **❌ Увеличение диапазона допустимых значений для свойства, поля, возвращаемого значения или параметра [out](../../csharp/language-reference/keywords/out-parameter-modifier.md)**

- **❌ Изменение возвращаемых значений для свойства, поля, возвращаемого значения метода или параметра [out](../../csharp/language-reference/keywords/out-parameter-modifier.md)**

- **❌ Изменение значения по умолчанию для свойства, поля или параметра**

- **❌ Изменение точности числового возвращаемого значения**

- **❓ Изменение логики синтаксического анализ входных данных и создание новых исключений (даже если поведение синтаксического анализа не указано в документации**

### <a name="exceptions"></a>Исключения

- **✔️ Вызов более производного исключения, чем существующие исключения**

  Так как новое исключение является подклассом существующего исключения, существующий код обработки исключений будет обрабатывать это исключение. Например, в .NET Framework 4 методы создания и получения языка и региональных параметров теперь вызывают исключение <xref:System.Globalization.CultureNotFoundException> вместо <xref:System.ArgumentException>, если не могут найти язык и региональные параметры. Так как <xref:System.Globalization.CultureNotFoundException> является производным от <xref:System.ArgumentException>, это изменение считается допустимым.

- **✔️ Вызов конкретного исключения, чем <xref:System.NotSupportedException>, <xref:System.NotImplementedException>, <xref:System.NullReferenceException>**

- **✔️ Вызов исключения, которое считается неустранимым**

  Неустранимые исключения не нужно перехватывать, они попадают в обработчик catch-all на верхнем уровне. Это означает, что у пользователей нет кода, который перехватывает эти явные исключения. Неустранимыми считаются следующие исключения:

  - <xref:System.AccessViolationException>
  - <xref:System.ExecutionEngineException>
  - <xref:System.Runtime.InteropServices.SEHException>
  - <xref:System.StackOverflowException>

- **✔️ Вызов нового исключения в новом пути кода**

  Исключения должны применяться только к новому пути кода, который выполняется с новыми значениями параметров или состоянием, и который невозможно выполнить в существующем коде, ориентированном на предыдущую версию.

- **✔️ Удаление исключения для более надежной работы или для нового сценария**

  Например, метод `Divide`, который ранее обрабатывал только положительные значения и вызвал исключение <xref:System.ArgumentOutOfRangeException>, можно изменить так, чтобы он поддерживал положительные и отрицательные значения без вызова исключения.

- **✔️ Изменение текста сообщения об ошибке**

  Разработчикам не следует полагаться на текст сообщения об ошибках, который изменяется еще и в зависимости от языка и региональных параметров пользователя.

- **❌ Вызов исключения в любом случае, кроме перечисленных выше**

- **❌ Удаление исключения в любом случае, кроме перечисленных выше**

### <a name="attributes"></a>Атрибуты

- **✔️ Изменение значения атрибута, который *не* является наблюдаемым**

- **❌ Изменение значения атрибута, который *является* наблюдаемым**

- **❓ Удаление атрибута**

  В большинстве случаев удаление атрибута (например, <xref:System.NonSerializedAttribute>) является критическим изменением.

## <a name="platform-support"></a>Поддержка платформ

- **✔️ Поддержка операции для платформы, которая ранее не поддерживалась**

- **❌ Прекращение поддержки или требование конкретного пакета обновления для операции, которая ранее поддерживалась для платформы**

## <a name="internal-implementation-changes"></a>Изменения внутренней реализации

- **❓ Изменение контактной зоны внутреннего типа**

   Такие изменения обычно разрешены, хотя они изменяют закрытое отражение. Эти изменения могут быть не разрешены в некоторых случаях, если популярные сторонние библиотеки или большое количество разработчиков полагаются на внутренние API.

- **❓ Изменение внутренней реализации элемента**

  Такие изменения обычно разрешены, хотя они изменяют закрытое отражение. Эти изменения могут быть не разрешены в некоторых случаях, если код клиента часто зависит от закрытого отражения или если изменения связаны с нежелательными побочными эффектами.

- **✔️ Повышение производительности операции**

   Возможность изменять производительность операции очень важна, но такие изменения могут нарушить код, который зависит от текущей скорости операции. Это особенно важно для кода, который зависит от скорости выполнения асинхронных операций. Обратите внимание, что изменение производительности не должно влиять на другие аспекты поведения API, в противном случае изменение будет считаться критическим.

- **✔️ Косвенное (и обычно отрицательное) изменение производительности операции**

  Если изменение не относится к категории критических по другим причинам, оно считается допустимым. Зачастую требуются дополнительные действия, включая дополнительные операции или операции, которые добавляют новые функции. Это почти всегда влияет на производительность, но может требоваться для правильной работы API.

- **❌ Преобразование синхронного API в асинхронный (и наоборот)**

## <a name="code-changes"></a>Изменения в коде

- **✔️ Добавление [params](../../csharp/language-reference/keywords/params.md) в параметр**

- **❌ Замена [структуры](../../csharp/language-reference/keywords/struct.md) на [класс](../../csharp/language-reference/keywords/class.md) и наоборот**

- **❌ Добавление ключевого слова [checked](../../csharp/language-reference/keywords/virtual.md) в блок кода**

   Такое изменение может привести к тому, что ранее правильно выполнявшийся код будет вызывать исключение <xref:System.OverflowException>, что является недопустимым.

- **❌ Удаление [params](../../csharp/language-reference/keywords/params.md) из параметра**

- **❌ Изменение порядка возникновения событий**

  Разработчики могут рассчитывать на то, что события будут срабатывать в определенном порядке, и создаваемый ими код часто зависит от этого порядка.

- **❌ Удаление вызова события для конкретного действия**

- **❌ Изменение количества вызовов определенных событий**

- **❌ Добавление <xref:System.FlagsAttribute> к типу перечисления**
