---
title: Рекомендации по написанию модульных тестов
description: Ознакомьтесь с рекомендациями по написанию модульных тестов, которые повысят качество и устойчивость кода, для проектов NET Core и .NET Standard.
author: jpreese
ms.author: wiwagn
ms.date: 07/28/2018
ms.openlocfilehash: 6c1e9a665ad541bf6109634a6df857880ee47042
ms.sourcegitcommit: 74d05613d6c57106f83f82ce8ee71176874ea3f0
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/03/2020
ms.locfileid: "93281653"
---
# <a name="unit-testing-best-practices-with-net-core-and-net-standard"></a>Рекомендации по модульному тестированию для .NET Core и .NET Standard

Существует множество преимуществ написания модульных тестов: они помогают с регрессией, предоставляют документацию и способствуют хорошей структуре кода. Но трудночитаемые и ненадежные модульные тесты могут негативно отразиться на базе кода. В этой статье приведены некоторые рекомендации, касающиеся разработки модульных тестов для проектов .NET Core и .NET Standard.

В этом руководстве вы получите некоторые практические рекомендации по написанию модульных тестов, чтобы создавать устойчивые и понятные тесты.

Автор: [Джон Риз (John Reese)](https://reese.dev) с особой благодарностью [Рою Ошерову (Roy Osherove)](https://osherove.com/)

## <a name="why-unit-test"></a>Почему именно модульные тесты?

### <a name="less-time-performing-functional-tests"></a>Меньше времени на выполнение функциональных тестов

Функциональные тесты требуют большого количества ресурсов. Как правило, приходится открывать приложение и выполнять ряд действий, чтобы проверить ожидаемое поведение. Тест-инженеры не всегда знают, что это за действия, и им приходится обращаться к специалистам в этой области. Само тестирование может занимать несколько секунд, если это обычные изменения, или несколько минут для более масштабных изменений. Наконец, этот процесс необходимо повторять для каждого изменения, внесенного в систему.

Модульные тесты, с другой стороны, занимают миллисекунды, выполняются простым нажатием кнопки и не обязательно требуют знаний о всей системе в целом. Успешность прохождения теста зависит от средства выполнения теста, а не от пользователя.

### <a name="protection-against-regression"></a>Защита от регрессии

Дефекты регрессии вводятся при внесении изменений в приложение. Довольно часто тест-инженеры тестируют не только новую функцию, но и функции, существовавшие до этого, чтобы проверить, что эти функции по-прежнему работают должным образом.

С модульным тестированием можно повторно запускать весь набор тестов после каждой сборки или даже после изменения строки кода. Это дает вам уверенность, что ваш новый код не нарушил существующие функциональные возможности.

### <a name="executable-documentation"></a>Исполняемая документация

Не всегда очевидно, что делает конкретный метод или как он себя ведет при определенных входных данных. Вы можете спросить себя: как поведет себя метод, если я передам ему пустую строку? А значение NULL?

Если у вас есть набор модульных тестов с понятными именами, каждый тест сможет четко объяснить, какими будут выходные данные для определенных входных данных. Кроме того, он сможет проверить, что это действительно работает.

### <a name="less-coupled-code"></a>Менее связанный код

Если код тесно связан, он плохо подходит для модульного тестирования. Без создания модульных тестов для кода это связывание может быть менее очевидным.

Когда вы пишете тесты для кода, вы естественным образом разделяете его, иначе его будет сложнее тестировать.

## <a name="characteristics-of-a-good-unit-test"></a>Характеристики хорошего модульного теста

- **Быстрый**. В хорошо разработанных проектах могут быть тысячи модульных тестов. Модульные тесты должны выполняться очень быстро. За миллисекунды.
- **Изолированный**. Модульные тесты являются автономными, могут выполняться изолированно и не имеют зависимостей от внешних факторов, таких как файловая система или база данных.
- **Повторяемый**. Запуски модульного теста должны иметь согласованные результаты, то есть всегда возвращать одинаковый результат, если вы не вносите никаких изменений между запусками.
- **Самопроверяющий**. Тест должен автоматически определять, пройден он или нет, без участия пользователя.
- **Уместный**. Время на написание модульного теста не должно значительно превышать время написания тестируемого кода. Если вам кажется, что тестирование кода занимает слишком много времени по сравнению с написанием кода, продумайте структуру, более подходящую для тестирования.

## <a name="code-coverage"></a>Покрытие кода

Высокий процент покрытия кода зачастую связан с более высоким качеством кода. Однако само по себе измерение *не может* определить качество кода. Задание чрезмерно большого процента объема протестированного кода может снизить производительность. Представьте себе сложный проект с тысячами условных ветвей и представьте, что объем протестированного кода составляет 95 %. В настоящее время проект поддерживает объем протестированного кода в 90 %. Время, затрачиваемое на принятие всех пограничных вариантов в оставшихся 5 %, может оказаться очень значительным, а ценность предложения быстро сокращается.

Высокий процент объема протестированного кода не является индикатором успеха и не подразумевает высокое качество кода. Он представляет собой лишь объем кода, охваченного модульными тестами. Дополнительные сведения см. в статье [Модульное тестирование объема протестированного кода](unit-testing-code-coverage.md).

## <a name="lets-speak-the-same-language"></a>Определимся с терминами

К сожалению, термин *макет* по отношению к тестированию часто употребляется неправильно. Следующие пункты определяют самые распространенные типы *заполнителей* при написании модульных тестов:

*Заполнитель*  — это общий термин, который можно использовать для описания заглушки или макета объекта. Использование заглушки или макета зависит от контекста. Иными словами, заполнитель может быть заглушкой или макетом.

*Макет*. Макет объекта — это объект-заполнитель в системе, который решает, пройден ли модульный тест. Макет начинает существование как заполнитель, пока по нему не будет проведена проверка.

*Заглушка*  — это управляемая замена существующей зависимости (или участника) в системе. С помощью заглушки можно протестировать код, не задействовав зависимость напрямую. По умолчанию заполнитель выступает как заглушка.

Рассмотрим следующий фрагмент кода:

```csharp
var mockOrder = new MockOrder();
var purchase = new Purchase(mockOrder);

purchase.ValidateOrders();

Assert.True(purchase.CanBeShipped);
```

Это будет пример заглушки, которая будет называться макетом. В данном случае это заглушка. Вы передаете Order, чтобы создать экземпляр `Purchase` (тестируемая система). Имя `MockOrder` также вводит в заблуждение, поскольку Order не является макетом.

Лучше было бы так:

```csharp
var stubOrder = new FakeOrder();
var purchase = new Purchase(stubOrder);

purchase.ValidateOrders();

Assert.True(purchase.CanBeShipped);
```

Если переименовать класс в `FakeOrder`, он будет более универсальным и его можно будет использовать как макет или как заглушку. Это зависит от тестового случая. В приведенном выше примере `FakeOrder` используется в качестве заглушки. Вы никак не используете `FakeOrder` во время проверки. `FakeOrder` передается в класс `Purchase`, чтобы удовлетворить требованиям конструктора.

Чтобы использовать его как макет, можно сделать нечто подобное:

```csharp
var mockOrder = new FakeOrder();
var purchase = new Purchase(mockOrder);

purchase.ValidateOrders();

Assert.True(mockOrder.Validated);
```

В этом случае проверяется свойство заполнителя (выполняется проверка по нему), поэтому в приведенном выше фрагменте кода `mockOrder` является макетом.

> [!IMPORTANT]
> Очень важно правильно разобраться в терминологии. Если вы будете называть заглушки макетами, другие разработчики не поймут ваших намерений.

В первую очередь следует помнить, что макеты отличаются от заглушек тем, что вы выполняете проверку по макету объекта, но не выполняете проверку по заглушке.

## <a name="best-practices"></a>Рекомендации

Попробуйте не создавать зависимости в инфраструктуре при написании модульных тестов. Из-за этого тесты выполняются медленно и нестабильно. Зависимости следует использовать в интеграционных тестах. Чтобы избежать появления зависимостей в коде приложения, следуйте [принципу явных зависимостей](https://deviq.com/explicit-dependencies-principle) и используйте [внедрение зависимостей](../extensions/dependency-injection.md). Вы также можете разместить модульные тесты в отдельном проекте, не содержащем интеграционных тестов. Это гарантирует отсутствие в проекте модульного теста ссылок на пакеты инфраструктуры или зависимостей от них.

### <a name="naming-your-tests"></a>Выбор имен для тестов

Имя теста должно состоять из трех частей:

- имя тестируемого метода;
- сценарий, в котором выполняется тестирование;
- ожидаемое поведение при вызове сценария.

#### <a name="why"></a>Почему?

- Стандарты именования важны, так как они выражают намерение теста.

Тесты не просто проверяют работоспособность кода — они также предоставляют документацию. Просто посмотрев на набор модульных тестов, вы должны определить поведение кода, не глядя на сам код. Кроме того, если тест не пройден, вы сразу увидите, какие сценарии не соответствуют вашим ожиданиям.

#### <a name="bad"></a>Плохо:

[!code-csharp[BeforeNaming](../../../samples/snippets/core/testing/unit-testing-best-practices/csharp/before/StringCalculatorTests.cs#BeforeNaming)]

#### <a name="better"></a>Лучше:

[!code-csharp[AfterNamingAndMinimallyPassing](../../../samples/snippets/core/testing/unit-testing-best-practices/csharp/after/StringCalculatorTests.cs#AfterNamingAndMinimallyPassing)]

### <a name="arranging-your-tests"></a>Упорядочивание тестов

**Упорядочивайте, действуйте, проверяйте**  — это общий шаблон для модульного тестирования. Как и предполагает название, он состоит из трех элементов.

- *Упорядочивайте* объекты, создавая и настраивая их по необходимости.
- *Действуйте* , работая с объектами.
- *Проверяйте* , что все выполняется, как ожидалось.

#### <a name="why"></a>Почему?

- Объект тестирования четко отделяется от этапов *упорядочивания* и *проверки*.
- Меньше вероятности перепутать проверочные утверждения с кодом действия.

Удобочитаемость является одним из наиболее важных аспектов при написании тестов. Четкое разделение каждого из этих действий в тесте подчеркивает зависимости, необходимые для вызова кода, указывает, как вызывается ваш код и что вы пытаетесь проверить. Хотя некоторые шаги можно объединить и уменьшить размер теста, основной целью является удобочитаемость теста.

#### <a name="bad"></a>Плохо:

[!code-csharp[BeforeArranging](../../../samples/snippets/core/testing/unit-testing-best-practices/csharp/before/StringCalculatorTests.cs#BeforeArranging)]

#### <a name="better"></a>Лучше:

[!code-csharp[AfterArranging](../../../samples/snippets/core/testing/unit-testing-best-practices/csharp/after/StringCalculatorTests.cs#AfterArranging)]

### <a name="write-minimally-passing-tests"></a>Пишите минималистичные тесты

Входные данные для модульного теста должны быть как можно проще, чтобы проверить поведение, которое вы тестируете в данный момент.

#### <a name="why"></a>Почему?

- Тесты становятся более устойчивыми к будущим изменениям в базе кода.
- Ближе к тестированию поведения по сравнению с реализацией.

Тесты, которые включают больше информации, чем требуется для прохождения, могут содержать больше ошибок и затруднять понимание намерения. При написании тестов необходимо сосредоточиться на поведении. Установка дополнительных свойств для моделей или использование ненулевых значений, когда это не требуется, только затрудняет проверку.

#### <a name="bad"></a>Плохо:

[!code-csharp[BeforeMinimallyPassing](../../../samples/snippets/core/testing/unit-testing-best-practices/csharp/before/StringCalculatorTests.cs#BeforeMinimallyPassing)]

#### <a name="better"></a>Лучше:

[!code-csharp[AfterNamingAndMinimallyPassing](../../../samples/snippets/core/testing/unit-testing-best-practices/csharp/after/StringCalculatorTests.cs#AfterNamingAndMinimallyPassing)]

### <a name="avoid-magic-strings"></a>Избегайте "магических" строк

Именование переменных в модульных тестах так же важно, как именование переменных в рабочем коде, если не важнее. Модульные тесты не должны содержать "магических" строк.

#### <a name="why"></a>Почему?

- Избавит читателя теста от необходимости проверять рабочий код, чтобы выяснить, что делает значение особенным.
- Явно показывает, что вы пытаетесь *проверить* , а не *выполнить*.

"Магические" строки могут запутать читателя тестов. Если строка выглядит необычно, у него может возникнуть вопрос, почему было выбрано определенное значение для параметра или возвращаемого значения. И ему придется рассматривать детали реализации, вместо того чтобы сосредоточиться на тесте.

> [!TIP]
> При написании тестов старайтесь как можно яснее выразить свое намерение. В случае "магических" строк рекомендуется присваивать эти значения константам.

#### <a name="bad"></a>Плохо:

[!code-csharp[BeforeMagicString](../../../samples/snippets/core/testing/unit-testing-best-practices/csharp/before/StringCalculatorTests.cs#BeforeMagicString)]

#### <a name="better"></a>Лучше:

[!code-csharp[AfterMagicString](../../../samples/snippets/core/testing/unit-testing-best-practices/csharp/after/StringCalculatorTests.cs#AfterMagicString)]

### <a name="avoid-logic-in-tests"></a>Избегайте логики в тестах

При написании модульных тестов избегайте объединения строк вручную и логических условий, таких как `if`, `while`, `for`, `switch` и т. д.

#### <a name="why"></a>Почему?

- Меньше шансов внедрить ошибку в тесты.
- Направленность на конечный результат, а не на детали реализации.

При введении логики в набор тестов вероятность появления ошибок значительно возрастает. Меньше всего вам нужна ошибка в наборе тестов. Вы должны быть уверены, что тесты работают. Иначе вы не сможете им доверять. Если вы не доверяете тесту, он бесполезен. Если тест не пройден, вы должны знать, что с кодом действительно что-то не так и это нельзя игнорировать.

> [!TIP]
> Если логика в тесте неизбежна, рекомендуется разбить тест на несколько тестов.

#### <a name="bad"></a>Плохо:

[!code-csharp[LogicInTests](../../../samples/snippets/core/testing/unit-testing-best-practices/csharp/before/StringCalculatorTests.cs#LogicInTests)]

#### <a name="better"></a>Лучше:

[!code-csharp[AfterTestLogic](../../../samples/snippets/core/testing/unit-testing-best-practices/csharp/after/StringCalculatorTests.cs#AfterTestLogic)]

### <a name="prefer-helper-methods-to-setup-and-teardown"></a>Выбирайте вспомогательные методы вместо установки и удаления

Если вам требуется аналогичный объект или состояние для тестов, лучше используйте вспомогательный метод, чем атрибуты `Setup` и `Teardown`, если они существуют.

#### <a name="why"></a>Почему?

- Меньше путаницы при чтении тестов, так как весь код виден в каждом тесте.
- Меньше шансов настроить слишком много или слишком мало для определенного теста.
- Меньше шансов совместного использования состояния несколькими тестами, что приводит к нежелательным зависимостям между ними.

В модульном тестировании `Setup` вызывается до всех модульных тестов в наборе. Хотя некоторые считают это полезным инструментом, в конечном итоге тесты сложно воспринимать. Каждый тест обычно имеет различные требования для запуска. К сожалению, `Setup` заставляет вас использовать одинаковые требования для всех тестов.

> [!NOTE]
> В xUnit удалены SetUp и TearDown в версии 2.x.

#### <a name="bad"></a>Плохо:

[!code-csharp[BeforeSetup](../../../samples/snippets/core/testing/unit-testing-best-practices/csharp/before/StringCalculatorTests.cs#BeforeSetup)]

```csharp
// more tests...
```

[!code-csharp[BeforeHelperMethod](../../../samples/snippets/core/testing/unit-testing-best-practices/csharp/before/StringCalculatorTests.cs#BeforeHelperMethod)]

#### <a name="better"></a>Лучше:

[!code-csharp[AfterHelperMethod](../../../samples/snippets/core/testing/unit-testing-best-practices/csharp/after/StringCalculatorTests.cs#AfterHelperMethod)]

```csharp
// more tests...
```

[!code-csharp[AfterSetup](../../../samples/snippets/core/testing/unit-testing-best-practices/csharp/after/StringCalculatorTests.cs#AfterSetup)]

### <a name="avoid-multiple-asserts"></a>Избегайте нескольких проверочных утверждений

При написании тестов попробуйте включить только одно проверочное утверждение в каждый тест. Общие подходы к использованию только одного проверочного утверждения включают следующее.

- Создание отдельного теста для каждого проверочного утверждения.
- Использование параметризованных тестов.

#### <a name="why"></a>Почему?

- Если одно проверочное утверждение завершится неудачей, последующие не будут вычисляться.
- Гарантирует, что вы не будете проверять несколько случаев в тестах.
- Предоставляет полную картину о том, почему тесты завершаются неудачей.

При использовании нескольких проверочных утверждений в тестовом случае у вас нет гарантии, что все утверждения будут выполняться. В большинстве платформ модульного тестирования, когда одно утверждение в модульном тесте завершается неудачей, все последующие тесты считаются непройденными. Это может вызывать путаницу, так как действующие функции будут казаться неработоспособными.

> [!NOTE]
> Общее исключение из этого правила — проверка объекта. В этом случае обычно допустимо иметь несколько утверждений для каждого свойства, чтобы убедиться, что объект находится в ожидаемом состоянии.

#### <a name="bad"></a>Плохо:

[!code-csharp[BeforeMultipleAsserts](../../../samples/snippets/core/testing/unit-testing-best-practices/csharp/before/StringCalculatorTests.cs#BeforeMultipleAsserts)]

#### <a name="better"></a>Лучше:

[!code-csharp[AfterMultipleAsserts](../../../samples/snippets/core/testing/unit-testing-best-practices/csharp/after/StringCalculatorTests.cs#AfterMultipleAsserts)]

### <a name="validate-private-methods-by-unit-testing-public-methods"></a>Проверяйте закрытые методы путем модульного тестирования открытых методов

В большинстве случаев вам не понадобится тестировать закрытые методы. Закрытые методы относятся к тонкостям реализации. Подумайте об этом так: закрытые методы никогда не существуют в изоляции. Рано или поздно у вас будет открытый метод, вызывающий закрытый метод в рамках его реализации. Вам следует думать о конечном результате открытого метода, который вызывает закрытый метод.

Рассмотрим следующий случай.

```csharp
public string ParseLogLine(string input)
{
    var sanitizedInput = TrimInput(input);
    return sanitizedInput;
}

private string TrimInput(string input)
{
    return input.Trim();
}
```

Возможно, в первую очередь вам захочется написать тест для `TrimInput`, поскольку вы хотите убедиться, что метод работает должным образом. Но вполне возможно, что `ParseLogLine` манипулирует `sanitizedInput` неожиданным для вас образом и тестирование `TrimInput` окажется бесполезным.

Настоящий тест нужно провести для открытого метода `ParseLogLine`, потому что в конечном итоге для вас важен именно он.

```csharp
public void ParseLogLine_StartsAndEndsWithSpace_ReturnsTrimmedResult()
{
    var parser = new Parser();

    var result = parser.ParseLogLine(" a ");

    Assert.Equals("a", result);
}
```

С этой точки зрения, если вы видите закрытый метод, найдите открытый метод и напишите тесты для него. Тот факт, что закрытый метод возвращает ожидаемый результат, вовсе не означает, что система, которая вызывает закрытый метод, использует этот результат правильно.

### <a name="stub-static-references"></a>Используйте заглушки для статических ссылок

Один из принципов модульного тестирования — его полный контроль над тестируемой системой. Это может быть проблематичным, когда рабочий код вызывает статические ссылки (например, `DateTime.Now`). Рассмотрим следующий код.

```csharp
public int GetDiscountedPrice(int price)
{
    if (DateTime.Now.DayOfWeek == DayOfWeek.Tuesday)
    {
        return price / 2;
    }
    else
    {
        return price;
    }
}
```

Как можно провести модульное тестирование этого кода? Вы можете попробовать следующий подход.

```csharp
public void GetDiscountedPrice_NotTuesday_ReturnsFullPrice()
{
    var priceCalculator = new PriceCalculator();

    var actual = priceCalculator.GetDiscountedPrice(2);

    Assert.Equals(2, actual)
}

public void GetDiscountedPrice_OnTuesday_ReturnsHalfPrice()
{
    var priceCalculator = new PriceCalculator();

    var actual = priceCalculator.GetDiscountedPrice(2);

    Assert.Equals(1, actual);
}
```

К сожалению, вы быстро поймете, что в тестах есть несколько проблем.

- Если набор тестов выполняется во вторник, второй тест будет пройден, а первый — нет.
- Если набор тестов выполняется в другой день, первый тест будет пройден, а второй — нет.

Для решения этих проблем вам потребуется ввести *шов* в рабочий код. Например, можно заключить код, который необходимо контролировать, в интерфейс, чтобы рабочий код зависел от этого интерфейса.

```csharp
public interface IDateTimeProvider
{
    DayOfWeek DayOfWeek();
}

public int GetDiscountedPrice(int price, IDateTimeProvider dateTimeProvider)
{
    if (dateTimeProvider.DayOfWeek() == DayOfWeek.Tuesday)
    {
        return price / 2;
    }
    else
    {
        return price;
    }
}
```

Набор тестов теперь выглядит так.

```csharp
public void GetDiscountedPrice_NotTuesday_ReturnsFullPrice()
{
    var priceCalculator = new PriceCalculator();
    var dateTimeProviderStub = new Mock<IDateTimeProvider>();
    dateTimeProviderStub.Setup(dtp => dtp.DayOfWeek()).Returns(DayOfWeek.Monday);

    var actual = priceCalculator.GetDiscountedPrice(2, dateTimeProviderStub);

    Assert.Equals(2, actual);
}

public void GetDiscountedPrice_OnTuesday_ReturnsHalfPrice()
{
    var priceCalculator = new PriceCalculator();
    var dateTimeProviderStub = new Mock<IDateTimeProvider>();
    dateTimeProviderStub.Setup(dtp => dtp.DayOfWeek()).Returns(DayOfWeek.Tuesday);

    var actual = priceCalculator.GetDiscountedPrice(2, dateTimeProviderStub);

    Assert.Equals(1, actual);
}
```

Теперь набор тестов имеет полный контроль над `DateTime.Now` и может использовать заглушку для любого значения при вызове метода.
