---
title: Модель расширяемости CLI .NET Core
description: Узнайте, как можно расширить .NET Core CLI.
ms.date: 04/12/2017
ms.openlocfilehash: 74da895fb3a3f6c77640a2b9a64acdb2894a954b
ms.sourcegitcommit: cdf5084648bf5e77970cbfeaa23f1cab3e6e234e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/01/2020
ms.locfileid: "76920517"
---
# <a name="net-core-cli-extensibility-model"></a>Модель расширяемости CLI .NET Core

В этой статье показано, как можно разными способами расширить .NET Core CLI, и описаны сценарии для каждого из способов.
Вы увидите, как пользоваться средствами и создавать различные типы средств.

## <a name="how-to-extend-the-cli"></a>Расширение CLI
CLI можно расширить тремя способами:

1. [С помощью пакетов NuGet для каждого отдельного проекта](#per-project-based-extensibility)

   Средства для отдельных проектов включены в контекст проекта, но их легко установить с помощью восстановления.

2. [С помощью пакетов NuGet и пользовательских целевых объектов](#custom-targets)

   Пользовательские целевые объекты позволяют с легкостью расширить процедуру сборки с помощью настраиваемых задач.

3. [С помощью системной переменной PATH](#path-based-extensibility)

   Подход на основе пути подходит для общих межпроектных средств, которые могут использоваться на одном компьютере.

Три указанных выше механизма расширяемости не являются взаимоисключающими. Вы можете использовать один механизм, все механизмы или любое их сочетание. Выбор механизма зависит в первую очередь от цели, которой вы стремитесь достичь за счет расширения.

## <a name="per-project-based-extensibility"></a>Расширяемость на основе отдельных проектов
Средства для отдельных проектов — это [развертывания, зависимые от платформы](../deploying/index.md#framework-dependent-deployments-fdd), которые распространяются как пакеты NuGet. Средства доступны только в контексте проекта, который ссылается на них и для которого они восстанавливаются. Вызов вне контекста проекта (например, вне каталога, содержащего проект) завершится с ошибкой из-за того, что не удается найти команду.

Эти средства идеально подходят для создания серверов, так как для них не требуется ничего, кроме файла проекта. Процесс сборки выполняет восстановление для соответствующего проекта, и средства становятся доступны. К этой категории также относятся проекты на таких языках, как F#, так как каждый проект может быть написан только на одном языке.

Наконец, эта модель расширяемости обеспечивает поддержку создания средств, которым требуется доступ к выходным данным сборки проекта. Например, различные средства просмотра Razor в приложениях MVC [ASP.NET](https://www.asp.net/) попадают в эту категорию.

### <a name="consuming-per-project-tools"></a>Использование средств для отдельных проектов
Для каждого средства, который нужно использовать, необходимо добавить элемент `<DotNetCliToolReference>` в файл проекта. В элементе `<DotNetCliToolReference>` нужно сослаться на пакет, в котором находится средство, и указать необходимую версию. После выполнения команды [`dotnet restore`](dotnet-restore.md) средство и его зависимости восстанавливаются.

[!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]

Для средств, выполнение которых требует загрузки выходных данных сборки проекта, обычно имеется еще одна зависимость, которая указывается в списке стандартных зависимостей в файле проекта. Так как интерфейс командной строки использует MSBuild в качестве подсистемы сборки, рекомендуется записать эти части средства в виде пользовательских [целевых объектов](/visualstudio/msbuild/msbuild-targets) и [задач](/visualstudio/msbuild/msbuild-tasks) MSBuild: так они смогут участвовать в общем процессе сборки. Кроме того, они легко могут получить любые данные, генерируемые во время сборки, например расположение выходных файлов, текущую создаваемую конфигурацию и т. д. Все эти данные превращаются в набор свойств MSBuild, которые могут быть считаны из любого целевого объекта. Далее в этом документе вы узнаете, как добавить пользовательский целевой объект с помощью NuGet.

Рассмотрим пример добавления простого средства на основе узла tools в простой проект. Предположим, что есть команда `dotnet-api-search`, которая позволяет искать указанный интерфейс API в пакетах NuGet. Вот файл проекта консольного приложения, которое использует это средство:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>netcoreapp2.1</TargetFramework>
  </PropertyGroup>

  <!-- The tools reference -->
  <ItemGroup>
    <DotNetCliToolReference Include="dotnet-api-search" Version="1.0.0" />
  </ItemGroup>
</Project>
```

Элемент `<DotNetCliToolReference>` имеет структуру, подобную структуре элемента `<PackageReference>`. Для восстановления потребуются идентификатор пакета, содержащего средство, и его версия.

### <a name="building-tools"></a>Создание средств
Как было сказано ранее, средства — это просто переносимые консольные приложения. Сборка средств выполняется так же, как и сборка других консольных приложений.
После сборки используйте команду [`dotnet pack`](dotnet-pack.md), чтобы создать пакет NuGet (NUPKG-файл), содержащий код, сведения о зависимостях и т. д. Имя пакета может быть любым, но содержащееся в нем приложение, то есть двоичный файл средства, должно соответствовать соглашению `dotnet-<command>`, чтобы среда `dotnet` могла вызывать его.

> [!NOTE]
> В версиях-кандидатах до 3 средств командной строки .NET Core при работе команды `dotnet pack` возникала ошибка, из-за которой файл *.runtimeconfig.json* не упаковывался вместе со средством. Из-за отсутствия файла происходили ошибки в среде выполнения. При возникновении такой ситуации установите последнюю версию средства и повторите `dotnet pack`.

Так как средства — это переносимые приложения, то для запуска средства у пользователя должна быть установлена та версия библиотек .NET Core, которая использовалась для сборки средства. Зависимости, которые использует средство и которые не содержатся в библиотеках .NET Core, восстанавливаются и помещаются в кэш NuGet. Таким образом, средство в целом выполняется с помощью сборок из библиотек .NET Core, а также сборок из кэша NuGet.

Подобные средства имеют схему зависимостей, которая никак не связана со схемой зависимостей проекта, использующего эти средства. В ходе восстановления сначала восстанавливаются зависимости проекта, а затем каждое из средств и их зависимости.

Вы можете найти более подробные примеры и различные сочетания в [репозитории CLI .NET Core](https://github.com/dotnet/cli/tree/release/2.1/TestAssets/TestProjects).
Вы также можете найти [реализацию используемых средств](https://github.com/dotnet/cli/tree/release/2.1/TestAssets/TestPackages) в том же репозитории.

## <a name="custom-targets"></a>Пользовательские целевые объекты

NuGet позволяет [упаковывать пользовательские целевые объекты MSBuild и файлы свойств](/nuget/create-packages/creating-a-package#include-msbuild-props-and-targets-in-a-package). В связи с переключением .NET Core на использование MSBuild к проектам .NET Core теперь применяется тот же механизм расширяемости. Этот тип расширяемости можно использовать для оптимизации процедуры сборки, получения доступа к любым артефактам в процессе сборки (например, к созданным файлам), проверки конфигурации, с помощью которой вызывается сборка, и т. д.

В следующем примере показан целевой файл проекта, в котором используется синтаксис `csproj`. С помощью этого синтаксиса определяются объекты, которые будут упакованы командой [`dotnet pack`](dotnet-pack.md): целевые файлы, а также сборки помещаются в каталог *build* внутри пакета. Обратите внимание, что свойство `Label` для элемента `<ItemGroup>` установлено в значение `dotnet pack instructions`, и под ним определен целевой объект.

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <Description>Sample Packer</Description>
    <VersionPrefix>0.1.0-preview</VersionPrefix>
    <TargetFramework>netstandard1.3</TargetFramework>
    <DebugType>portable</DebugType>
    <AssemblyName>SampleTargets.PackerTarget</AssemblyName>
  </PropertyGroup>
  <ItemGroup>
    <EmbeddedResource Include="Resources\Pkg\dist-template.xml;compiler\resources\**\*" Exclude="bin\**;obj\**;**\*.xproj;packages\**" />
    <None Include="build\SampleTargets.PackerTarget.targets" />
  </ItemGroup>
  <ItemGroup Label="dotnet pack instructions">
    <Content Include="build\*.targets">
      <Pack>true</Pack>
      <PackagePath>build\</PackagePath>
    </Content>
  </ItemGroup>
  <Target Name="CollectRuntimeOutputs" BeforeTargets="_GetPackageFiles">
    <!-- Collect these items inside a target that runs after build but before packaging. -->
    <ItemGroup>
      <Content Include="$(OutputPath)\*.dll;$(OutputPath)\*.json">
        <Pack>true</Pack>
        <PackagePath>build\</PackagePath>
      </Content>
    </ItemGroup>
  </Target>
  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.DependencyModel" Version="1.0.1-beta-000933"/>
    <PackageReference Include="Microsoft.Build.Framework" Version="0.1.0-preview-00028-160627" />
    <PackageReference Include="Microsoft.Build.Utilities.Core" Version="0.1.0-preview-00028-160627" />
    <PackageReference Include="Newtonsoft.Json" Version="9.0.1" />
  </ItemGroup>
  <ItemGroup />
  <PropertyGroup Label="Globals">
    <ProjectGuid>463c66f0-921d-4d34-8bde-7c9d0bffaf7b</ProjectGuid>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(TargetFramework)' == 'netstandard1.3' ">
    <DefineConstants>$(DefineConstants);NETSTANDARD1_3</DefineConstants>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
    <DefineConstants>$(DefineConstants);RELEASE</DefineConstants>
  </PropertyGroup>
</Project>
```

Для использования пользовательских целевых объектов задается элемент `<PackageReference>`, указывающий на пакет и его версию внутри проекта, который расширяется. В отличие от средств пакет пользовательских целевых объектов входит в замыкание зависимостей исходного проекта.

Использование пользовательского целевого объекта зависит только от способа настройки. Так как это целевой объект MSBuild, он может зависеть от заданного целевого объекта, запускаться после другого целевого объекта, а также быть вызван вручную с помощью команды `dotnet msbuild -t:<target-name>`.

Однако для удобства пользователей можно объединить средства для отдельных проектов и пользовательские целевые объекты. В этом случае средство для отдельного проекта будет принимать все необходимые параметры и преобразовывать их в необходимый вызов [`dotnet msbuild`](dotnet-msbuild.md) для целевого объекта. Пример подобного типа синергии можно увидеть в репозитории [примеров хакатона MVP Summit 2016](https://github.com/dotnet/MVPSummitHackathon2016) в проекте [`dotnet-packer`](https://github.com/dotnet/MVPSummitHackathon2016/tree/master/dotnet-packer).

## <a name="path-based-extensibility"></a>Расширяемость на основе пути
Расширяемость на основе пути обычно используется на компьютерах разработки, на которых требуется средство, которое охватывает более одного проекта. Основным недостатком такого механизма расширения является его привязка к компьютеру, на котором размещается средство. Если средство требуется на другом компьютере, его необходимо развернуть.

Такая схема расширяемости набора средств CLI очень проста. Как указано в [обзоре CLI .NET Core](index.md), драйвер `dotnet` может выполнять любую команду, имя которой соответствует соглашению `dotnet-<command>`. Логика разрешения по умолчанию сначала проверяет несколько расположений и в конечном итоге переключается на системный путь. Если запрошенная команда существует по системному пути и является двоичным файлом, который можно вызвать, драйвер `dotnet` вызовет ее.

Файл должен быть исполняемым. В системах Unix это означает любой файл с битом выполнения, заданным посредством `chmod +x`. В Windows можно использовать файлы *cmd*.

В качестве примера рассмотрим очень простую реализацию программы "Hello World". В Windows мы будем использовать как `bash`, так и `cmd`.
Следующая команда просто выводит текст "Hello World" в консоль.

```bash
#!/bin/bash

echo "Hello World!"
```

```cmd
echo "Hello World"
```

В Mac OS можно сохранить этот скрипт как `dotnet-hello` и задать его бит выполнения с помощью `chmod +x dotnet-hello`. Затем можно создать символьную ссылку на него в `/usr/local/bin` с помощью команды `ln -s <full_path>/dotnet-hello /usr/local/bin/`. Это позволит вызывать команду с использованием синтаксиса `dotnet hello`.

В Windows можно сохранить этот сценарий как `dotnet-hello.cmd` и поместить его в расположение, которое находится в системном пути (или добавить в папку, которая уже находится в системном пути). После этого для запуска этого примера достаточно использовать команду `dotnet hello`.
