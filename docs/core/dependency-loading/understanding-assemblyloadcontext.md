---
title: Основные сведения об AssemblyLoadContext (.NET Core)
description: Основные концепции, позволяющие понять назначение и поведение AssemblyLoadContext в .NET Core.
ms.date: 08/09/2019
author: sdmaclea
ms.author: stmaclea
ms.openlocfilehash: 4d3f0e50e7c336469bd9af4d1589427388684434
ms.sourcegitcommit: dfcbc096ad7908cd58a5f0aeabd2256f05266bac
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/21/2020
ms.locfileid: "92332826"
---
# <a name="understanding-systemruntimeloaderassemblyloadcontext"></a><span data-ttu-id="915c8-103">Основные сведения о System.Runtime.Loader.AssemblyLoadContext</span><span class="sxs-lookup"><span data-stu-id="915c8-103">Understanding System.Runtime.Loader.AssemblyLoadContext</span></span>

<span data-ttu-id="915c8-104">Класс <xref:System.Runtime.Loader.AssemblyLoadContext> применяется только в .NET Core.</span><span class="sxs-lookup"><span data-stu-id="915c8-104">The <xref:System.Runtime.Loader.AssemblyLoadContext> class is unique to .NET Core.</span></span> <span data-ttu-id="915c8-105">Эта статья служит дополнением к документации по API <xref:System.Runtime.Loader.AssemblyLoadContext>, предоставляя сведения об используемых концепциях.</span><span class="sxs-lookup"><span data-stu-id="915c8-105">This article attempts to supplement the <xref:System.Runtime.Loader.AssemblyLoadContext> API documentation with conceptual information.</span></span>

<span data-ttu-id="915c8-106">Эта статья важна для разработчиков, которые реализуют динамическую загрузку, особенно для разработчиков платформ динамической загрузки.</span><span class="sxs-lookup"><span data-stu-id="915c8-106">This article is relevant to developers implementing dynamic loading, especially dynamic loading framework developers.</span></span>

## <a name="what-is-the-assemblyloadcontext"></a><span data-ttu-id="915c8-107">Что такое AssemblyLoadContext?</span><span class="sxs-lookup"><span data-stu-id="915c8-107">What is the AssemblyLoadContext?</span></span>

<span data-ttu-id="915c8-108">Каждое приложение .NET Core неявным образом использует <xref:System.Runtime.Loader.AssemblyLoadContext>.</span><span class="sxs-lookup"><span data-stu-id="915c8-108">Every .NET Core application implicitly uses the <xref:System.Runtime.Loader.AssemblyLoadContext>.</span></span>
<span data-ttu-id="915c8-109">Это поставщик среды выполнения для поиска и загрузки зависимостей.</span><span class="sxs-lookup"><span data-stu-id="915c8-109">It's the runtime's provider for locating and loading dependencies.</span></span> <span data-ttu-id="915c8-110">При каждой загрузке зависимости вызывается экземпляр <xref:System.Runtime.Loader.AssemblyLoadContext> для ее поиска.</span><span class="sxs-lookup"><span data-stu-id="915c8-110">Whenever a dependency is loaded, an <xref:System.Runtime.Loader.AssemblyLoadContext> instance is invoked to locate it.</span></span>

- <span data-ttu-id="915c8-111">Он предоставляет службу поиска, загрузки и кэширования управляемых сборок и других зависимостей.</span><span class="sxs-lookup"><span data-stu-id="915c8-111">It provides a service of locating, loading, and caching managed assemblies and other dependencies.</span></span>

- <span data-ttu-id="915c8-112">Для поддержки динамической загрузки и выгрузки кода он создает изолированный контекст для загрузки кода и всех зависимостей в собственном экземпляре <xref:System.Runtime.Loader.AssemblyLoadContext>.</span><span class="sxs-lookup"><span data-stu-id="915c8-112">To support dynamic code loading and unloading, it creates an isolated context for loading code and its dependencies in their own <xref:System.Runtime.Loader.AssemblyLoadContext> instance.</span></span>

## <a name="when-do-you-need-multiple-assemblyloadcontext-instances"></a><span data-ttu-id="915c8-113">Зачем может потребоваться несколько экземпляров AssemblyLoadContext?</span><span class="sxs-lookup"><span data-stu-id="915c8-113">When do you need multiple AssemblyLoadContext instances?</span></span>

<span data-ttu-id="915c8-114">Один экземпляр <xref:System.Runtime.Loader.AssemblyLoadContext> может загружать ровно одну версию <xref:System.Reflection.Assembly> для каждого простого имени сборки (<xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="915c8-114">A single <xref:System.Runtime.Loader.AssemblyLoadContext> instance is limited to loading exactly one version of an <xref:System.Reflection.Assembly> per simple assembly name, <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="915c8-115">Это ограничение может стать проблемой при динамической загрузке модулей кода.</span><span class="sxs-lookup"><span data-stu-id="915c8-115">This restriction can become a problem when loading code modules dynamically.</span></span> <span data-ttu-id="915c8-116">Каждый модуль компилируется независимо от других и они могут зависеть от разных версий <xref:System.Reflection.Assembly>.</span><span class="sxs-lookup"><span data-stu-id="915c8-116">Each module is independently compiled and may depend on different versions of an <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="915c8-117">Такая проблема часто возникает, когда разные модули зависят от разных версий широко используемой библиотеки.</span><span class="sxs-lookup"><span data-stu-id="915c8-117">This problem commonly occurs when different modules depend on different versions of a commonly used library.</span></span>

<span data-ttu-id="915c8-118">Для поддержки динамической загрузки кода API <xref:System.Runtime.Loader.AssemblyLoadContext> предоставляет возможность загружать конфликтующие версии <xref:System.Reflection.Assembly> в одном приложении.</span><span class="sxs-lookup"><span data-stu-id="915c8-118">To support dynamically loading code, the <xref:System.Runtime.Loader.AssemblyLoadContext> API provides for loading conflicting versions of an <xref:System.Reflection.Assembly> in the same application.</span></span> <span data-ttu-id="915c8-119">Каждый экземпляр <xref:System.Runtime.Loader.AssemblyLoadContext> предоставляет уникальный словарь, который сопоставляет все <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> с конкретными экземплярами <xref:System.Reflection.Assembly>.</span><span class="sxs-lookup"><span data-stu-id="915c8-119">Each <xref:System.Runtime.Loader.AssemblyLoadContext> instance provides a unique dictionary mapping each <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> to a specific <xref:System.Reflection.Assembly> instance.</span></span>

<span data-ttu-id="915c8-120">Он также поддерживает удобный механизм группирования зависимостей, связанных с модулем кода, для последующей выгрузки.</span><span class="sxs-lookup"><span data-stu-id="915c8-120">It also provides a convenient mechanism for grouping dependencies related to a code module for later unload.</span></span>

## <a name="what-is-special-about-the-assemblyloadcontextdefault-instance"></a><span data-ttu-id="915c8-121">Что отличает экземпляр AssemblyLoadContext.Default?</span><span class="sxs-lookup"><span data-stu-id="915c8-121">What is special about the AssemblyLoadContext.Default instance?</span></span>

<span data-ttu-id="915c8-122">Среда выполнения автоматически заполняет экземпляр <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> при запуске.</span><span class="sxs-lookup"><span data-stu-id="915c8-122">The <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> instance is automatically populated by the runtime at startup.</span></span>  <span data-ttu-id="915c8-123">Он использует [стандартное зондирование](default-probing.md) для поиска и определения всех статических зависимостей.</span><span class="sxs-lookup"><span data-stu-id="915c8-123">It uses [default probing](default-probing.md) to locate and find all static dependencies.</span></span>

<span data-ttu-id="915c8-124">Он реализует все самые распространенные сценарии загрузки зависимостей.</span><span class="sxs-lookup"><span data-stu-id="915c8-124">It solves the most common dependency loading scenarios.</span></span>

## <a name="how-does-assemblyloadcontext-support-dynamic-dependencies"></a><span data-ttu-id="915c8-125">Как AssemblyLoadContext поддерживает динамические зависимости?</span><span class="sxs-lookup"><span data-stu-id="915c8-125">How does AssemblyLoadContext support dynamic dependencies?</span></span>

<span data-ttu-id="915c8-126"><xref:System.Runtime.Loader.AssemblyLoadContext> определяет несколько событий и виртуальных функций, которые можно переопределить.</span><span class="sxs-lookup"><span data-stu-id="915c8-126"><xref:System.Runtime.Loader.AssemblyLoadContext> has various events and virtual functions that can be overridden.</span></span>

<span data-ttu-id="915c8-127">Экземпляр <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> поддерживает переопределение только для событий.</span><span class="sxs-lookup"><span data-stu-id="915c8-127">The <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> instance only supports overriding the events.</span></span>

<span data-ttu-id="915c8-128">Все доступные события и виртуальные функции описаны в статьях [ Алгоритм загрузки управляемых сборок](loading-managed.md), [Алгоритм загрузки вспомогательных сборок](loading-resources.md) и [Алгоритм загрузки неуправляемых (собственных) библиотек](loading-unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="915c8-128">The articles [Managed assembly loading algorithm](loading-managed.md), [Satellite assembly loading algorithm](loading-resources.md), and [Unmanaged (native) library loading algorithm](loading-unmanaged.md) refer to all the available events and virtual functions.</span></span>  <span data-ttu-id="915c8-129">В тех статьях указаны относительные положения всех событий и функций в алгоритмах загрузки.</span><span class="sxs-lookup"><span data-stu-id="915c8-129">The articles show each event and function's relative position in the loading algorithms.</span></span> <span data-ttu-id="915c8-130">Мы не будем дублировать эту информацию в этой статье.</span><span class="sxs-lookup"><span data-stu-id="915c8-130">This article doesn't reproduce that information.</span></span>

<span data-ttu-id="915c8-131">В этом разделе описаны общие принципы работы с соответствующими событиями и функциями.</span><span class="sxs-lookup"><span data-stu-id="915c8-131">This section covers the general principles for the relevant events and functions.</span></span>

- <span data-ttu-id="915c8-132">**Сохраняйте повторяемость** .</span><span class="sxs-lookup"><span data-stu-id="915c8-132">**Be repeatable** .</span></span> <span data-ttu-id="915c8-133">Запрос к определенной зависимости должен всегда возвращать одинаковый ответ.</span><span class="sxs-lookup"><span data-stu-id="915c8-133">A query for a specific dependency must always result in the same response.</span></span> <span data-ttu-id="915c8-134">Должен возвращаться один и тот же экземпляр загруженной зависимости.</span><span class="sxs-lookup"><span data-stu-id="915c8-134">The same loaded dependency instance must be returned.</span></span> <span data-ttu-id="915c8-135">Это требование крайне важно для согласованности кэша.</span><span class="sxs-lookup"><span data-stu-id="915c8-135">This requirement is fundamental  for cache consistency.</span></span> <span data-ttu-id="915c8-136">В частности, для управляемых сборок мы создаем кэш <xref:System.Reflection.Assembly>.</span><span class="sxs-lookup"><span data-stu-id="915c8-136">For managed assemblies in particular, we're creating an <xref:System.Reflection.Assembly> cache.</span></span> <span data-ttu-id="915c8-137">Ключом этого кэша служит простое имя сборки (<xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="915c8-137">The cache key is a simple assembly name, <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="915c8-138">**Старайтесь не создавать исключений** .</span><span class="sxs-lookup"><span data-stu-id="915c8-138">**Typically don't throw** .</span></span>  <span data-ttu-id="915c8-139">Ожидается, что эти функции будут возвращать `null`, а не создавать исключения при отсутствии запрошенной зависимости.</span><span class="sxs-lookup"><span data-stu-id="915c8-139">It's expected that these functions return `null` rather than throw when unable to find the requested dependency.</span></span> <span data-ttu-id="915c8-140">Исключения приводят к преждевременному завершению поиска и могут передаваться вызывающему объекту.</span><span class="sxs-lookup"><span data-stu-id="915c8-140">Throwing will prematurely end the search and be propagate an exception to the caller.</span></span> <span data-ttu-id="915c8-141">Исключения следует применять только для непредвиденных ошибок, например при повреждении сборки или нехватке памяти.</span><span class="sxs-lookup"><span data-stu-id="915c8-141">Throwing should be restricted to unexpected errors like a corrupted assembly or an out of memory condition.</span></span>
- <span data-ttu-id="915c8-142">**Избегайте рекурсии** .</span><span class="sxs-lookup"><span data-stu-id="915c8-142">**Avoid recursion** .</span></span> <span data-ttu-id="915c8-143">Имейте в виду, что эти функции и обработчики реализуют правила загрузки для поиска зависимостей.</span><span class="sxs-lookup"><span data-stu-id="915c8-143">Be aware that these functions and handlers implement the loading rules for locating dependencies.</span></span> <span data-ttu-id="915c8-144">Ваша реализация не должна вызывать API, так как это может привести к рекурсивному поиску.</span><span class="sxs-lookup"><span data-stu-id="915c8-144">Your implementation shouldn't call APIs that trigger recursion.</span></span> <span data-ttu-id="915c8-145">Обычно в этом коде следует вызывать функции загрузки из **AssemblyLoadContext** , которые ожидают аргумент с определенным путем или ссылкой на память.</span><span class="sxs-lookup"><span data-stu-id="915c8-145">Your code should typically call **AssemblyLoadContext** load functions that require a specific path or memory reference argument.</span></span>
- <span data-ttu-id="915c8-146">**Загружайте в правильный экземпляр AssemblyLoadContext** .</span><span class="sxs-lookup"><span data-stu-id="915c8-146">**Load into the correct AssemblyLoadContext** .</span></span> <span data-ttu-id="915c8-147">Выбор мест для загрузки зависимостей зависит от конкретного приложения.</span><span class="sxs-lookup"><span data-stu-id="915c8-147">The choice of where to load dependencies is application-specific.</span></span>  <span data-ttu-id="915c8-148">Такой выбор определяется именно этими событиями и функциями.</span><span class="sxs-lookup"><span data-stu-id="915c8-148">The choice is implemented by these events and functions.</span></span> <span data-ttu-id="915c8-149">Когда ваш код вызывает функции загрузки по пути из **AssemblyLoadContext** , их нужно вызывать именно из того экземпляра, в который вы намерены загрузить код.</span><span class="sxs-lookup"><span data-stu-id="915c8-149">When your code calls **AssemblyLoadContext** load-by-path functions call them on the instance where you want the code loaded.</span></span> <span data-ttu-id="915c8-150">Иногда проще всего будет вернуть значение `null` и оставить обработку загрузки на усмотрение <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="915c8-150">Sometime returning `null` and letting the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> handle the load may be the simplest option.</span></span>
- <span data-ttu-id="915c8-151">**Помните о проблемах состязания потоков.**</span><span class="sxs-lookup"><span data-stu-id="915c8-151">**Be aware of thread races** .</span></span> <span data-ttu-id="915c8-152">Загрузка может инициироваться в нескольких потоках.</span><span class="sxs-lookup"><span data-stu-id="915c8-152">Loading can be triggered by multiple threads.</span></span> <span data-ttu-id="915c8-153">AssemblyLoadContext избегает состязания потоков, атомарно добавляя сборку в свой кэш.</span><span class="sxs-lookup"><span data-stu-id="915c8-153">The AssemblyLoadContext handles thread races by atomically adding assemblies to its cache.</span></span> <span data-ttu-id="915c8-154">Экземпляр проигравшего процесса просто отклоняется.</span><span class="sxs-lookup"><span data-stu-id="915c8-154">The race loser's instance is discarded.</span></span> <span data-ttu-id="915c8-155">Не добавляйте в вашу реализацию дополнительную логику, которая не поддерживает правильную работу с несколькими потоками.</span><span class="sxs-lookup"><span data-stu-id="915c8-155">In your implementation logic, don't add extra logic that doesn't handle multiple threads properly.</span></span>

## <a name="how-are-dynamic-dependencies-isolated"></a><span data-ttu-id="915c8-156">Как изолируются динамические зависимости?</span><span class="sxs-lookup"><span data-stu-id="915c8-156">How are dynamic dependencies isolated?</span></span>

<span data-ttu-id="915c8-157">Каждый экземпляр <xref:System.Runtime.Loader.AssemblyLoadContext> представляет уникальную область для экземпляров <xref:System.Reflection.Assembly> и определений <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="915c8-157">Each <xref:System.Runtime.Loader.AssemblyLoadContext> instance represents a unique scope for <xref:System.Reflection.Assembly> instances and <xref:System.Type> definitions.</span></span>

<span data-ttu-id="915c8-158">Между этими зависимостями отсутствует двоичная изоляция.</span><span class="sxs-lookup"><span data-stu-id="915c8-158">There's no binary isolation between these dependencies.</span></span> <span data-ttu-id="915c8-159">Они изолируются только тем, что не могут найти друга по имени.</span><span class="sxs-lookup"><span data-stu-id="915c8-159">They're only isolated by not finding each other by name.</span></span>

<span data-ttu-id="915c8-160">Соответственно, в каждом <xref:System.Runtime.Loader.AssemblyLoadContext>:</span><span class="sxs-lookup"><span data-stu-id="915c8-160">In each <xref:System.Runtime.Loader.AssemblyLoadContext>:</span></span>

- <span data-ttu-id="915c8-161"><xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> может ссылаться на другой экземпляр <xref:System.Reflection.Assembly>;</span><span class="sxs-lookup"><span data-stu-id="915c8-161"><xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> may refer to a different <xref:System.Reflection.Assembly> instance.</span></span>
- <span data-ttu-id="915c8-162"><xref:System.Type.GetType%2A?displayProperty=nameWithType> может возвращать другой экземпляр типа для того же типа `name`.</span><span class="sxs-lookup"><span data-stu-id="915c8-162"><xref:System.Type.GetType%2A?displayProperty=nameWithType> may return a different type instance for the same type `name`.</span></span>

## <a name="how-are-dependencies-shared"></a><span data-ttu-id="915c8-163">Как реализовано совместное использование зависимостей?</span><span class="sxs-lookup"><span data-stu-id="915c8-163">How are dependencies shared?</span></span>

<span data-ttu-id="915c8-164">Зависимости можно совместно использовать в нескольких экземплярах <xref:System.Runtime.Loader.AssemblyLoadContext>.</span><span class="sxs-lookup"><span data-stu-id="915c8-164">Dependencies can easily be shared between <xref:System.Runtime.Loader.AssemblyLoadContext> instances.</span></span> <span data-ttu-id="915c8-165">В общем случае зависимость загружает только один <xref:System.Runtime.Loader.AssemblyLoadContext>.</span><span class="sxs-lookup"><span data-stu-id="915c8-165">The general model is for one <xref:System.Runtime.Loader.AssemblyLoadContext> to load a dependency.</span></span>  <span data-ttu-id="915c8-166">Другой использует ту же зависимость через ссылку на загруженную сборку.</span><span class="sxs-lookup"><span data-stu-id="915c8-166">The other shares the dependency by using a reference to the loaded assembly.</span></span>

<span data-ttu-id="915c8-167">Такой режим совместного использования обязателен для сборок среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="915c8-167">This sharing is required of the runtime assemblies.</span></span> <span data-ttu-id="915c8-168">Такие сборки можно загружать только в <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="915c8-168">These assemblies can only be loaded into the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span></span> <span data-ttu-id="915c8-169">Это же требование применимо к таким платформам, как `ASP.NET`, `WPF` или `WinForms`.</span><span class="sxs-lookup"><span data-stu-id="915c8-169">The same is required for frameworks like `ASP.NET`, `WPF`, or `WinForms`.</span></span>

<span data-ttu-id="915c8-170">Мы рекомендуем всегда загружать общие зависимости в <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="915c8-170">It's recommended that shared dependencies should be loaded into <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span></span> <span data-ttu-id="915c8-171">Совместное использование — широко распространенный конструктивный шаблон.</span><span class="sxs-lookup"><span data-stu-id="915c8-171">This sharing is the common design pattern.</span></span>

<span data-ttu-id="915c8-172">Совместное использование реализуется в коде пользовательского экземпляра <xref:System.Runtime.Loader.AssemblyLoadContext>.</span><span class="sxs-lookup"><span data-stu-id="915c8-172">Sharing is implemented in the coding of the custom <xref:System.Runtime.Loader.AssemblyLoadContext> instance.</span></span> <span data-ttu-id="915c8-173"><xref:System.Runtime.Loader.AssemblyLoadContext> определяет несколько событий и виртуальных функций, которые можно переопределить.</span><span class="sxs-lookup"><span data-stu-id="915c8-173"><xref:System.Runtime.Loader.AssemblyLoadContext> has various events and virtual functions that can be overridden.</span></span> <span data-ttu-id="915c8-174">Когда любая из этих функций возвращает ссылку на экземпляр <xref:System.Reflection.Assembly>, который был загружен в другом экземпляре <xref:System.Runtime.Loader.AssemblyLoadContext>, такой экземпляр <xref:System.Reflection.Assembly> становится общим.</span><span class="sxs-lookup"><span data-stu-id="915c8-174">When any of these functions return a reference to an <xref:System.Reflection.Assembly> instance that was loaded in another <xref:System.Runtime.Loader.AssemblyLoadContext> instance, the <xref:System.Reflection.Assembly> instance is shared.</span></span> <span data-ttu-id="915c8-175">Стандартный алгоритм загрузки оставляет загрузку на усмотрение <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>, чтобы упростить шаблон совместного доступа.</span><span class="sxs-lookup"><span data-stu-id="915c8-175">The standard load algorithm defers to <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> for loading to simplify the common sharing pattern.</span></span>  <span data-ttu-id="915c8-176">См. статью [Managed assembly loading algorithm](loading-managed.md) (Алгоритм загрузки управляемых сборок).</span><span class="sxs-lookup"><span data-stu-id="915c8-176">See [Managed assembly loading algorithm](loading-managed.md).</span></span>

## <a name="complications"></a><span data-ttu-id="915c8-177">Усложнения</span><span class="sxs-lookup"><span data-stu-id="915c8-177">Complications</span></span>

### <a name="type-conversion-issues"></a><span data-ttu-id="915c8-178">Проблемы с преобразованием типов</span><span class="sxs-lookup"><span data-stu-id="915c8-178">Type conversion issues</span></span>

<span data-ttu-id="915c8-179">Если два экземпляра <xref:System.Runtime.Loader.AssemblyLoadContext> содержат определения типов с одинаковыми `name`, они считаются разными типами.</span><span class="sxs-lookup"><span data-stu-id="915c8-179">When two <xref:System.Runtime.Loader.AssemblyLoadContext> instances contain type definitions with the same `name`, they're not the same type.</span></span> <span data-ttu-id="915c8-180">Тип будет считаться одним и тем же только в том случае, если определения поступают из одного экземпляра <xref:System.Reflection.Assembly>.</span><span class="sxs-lookup"><span data-stu-id="915c8-180">They're the same type if and only if they come from the same <xref:System.Reflection.Assembly> instance.</span></span>

<span data-ttu-id="915c8-181">Дополнительно ситуация осложняется непонятными сообщениями об исключениях, связанных с таким несовпадением типов.</span><span class="sxs-lookup"><span data-stu-id="915c8-181">To complicate matters, exception messages about these mismatched types can be confusing.</span></span> <span data-ttu-id="915c8-182">Эти типы упоминаются в сообщениях об исключениях только по простым именам.</span><span class="sxs-lookup"><span data-stu-id="915c8-182">The types are referred to in the exception messages by their simple type names.</span></span> <span data-ttu-id="915c8-183">Типичное сообщение об исключении будет иметь такой вид:</span><span class="sxs-lookup"><span data-stu-id="915c8-183">The common exception message in this case would be of the form:</span></span>

> <span data-ttu-id="915c8-184">Невозможно преобразовать объект типа "IsolatedType" в тип "IsolatedType".</span><span class="sxs-lookup"><span data-stu-id="915c8-184">Object of type 'IsolatedType' cannot be converted to type 'IsolatedType'.</span></span>

### <a name="debugging-type-conversion-issues"></a><span data-ttu-id="915c8-185">Отладка проблем с преобразованием типов</span><span class="sxs-lookup"><span data-stu-id="915c8-185">Debugging type conversion issues</span></span>

<span data-ttu-id="915c8-186">При несовпадении двух типов важно получить следующие сведения:</span><span class="sxs-lookup"><span data-stu-id="915c8-186">Given a pair of mismatched types it's important to also know:</span></span>

- <span data-ttu-id="915c8-187"><xref:System.Type.Assembly?displayProperty=nameWithType> для каждого типа;</span><span class="sxs-lookup"><span data-stu-id="915c8-187">Each type's <xref:System.Type.Assembly?displayProperty=nameWithType></span></span>
- <span data-ttu-id="915c8-188"><xref:System.Runtime.Loader.AssemblyLoadContext> для каждого типа, который можно получить через <xref:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="915c8-188">Each type's <xref:System.Runtime.Loader.AssemblyLoadContext>, which can be obtained via the <xref:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)?displayProperty=nameWithType> function.</span></span>

<span data-ttu-id="915c8-189">При наличии двух объектов `a` и `b` будет полезно оценить в отладчике следующие данные:</span><span class="sxs-lookup"><span data-stu-id="915c8-189">Given two objects `a` and `b`, evaluating the following in the debugger will be helpful:</span></span>

```csharp
// In debugger look at each assembly's instance, Location, and FullName
a.GetType().Assembly
b.GetType().Assembly
// In debugger look at each AssemblyLoadContext's instance and name
System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(a.GetType().Assembly)
System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(b.GetType().Assembly)
```

### <a name="resolving-type-conversion-issues"></a><span data-ttu-id="915c8-190">Устранение проблем с преобразованием типов</span><span class="sxs-lookup"><span data-stu-id="915c8-190">Resolving type conversion issues</span></span>

<span data-ttu-id="915c8-191">Для решения таких проблем с преобразованием типов существует два конструктивных шаблона.</span><span class="sxs-lookup"><span data-stu-id="915c8-191">There are two design patterns for solving these type conversion issues.</span></span>

1. <span data-ttu-id="915c8-192">Используйте общие стандартные типы.</span><span class="sxs-lookup"><span data-stu-id="915c8-192">Use common shared types.</span></span> <span data-ttu-id="915c8-193">Такой общий тип может быть примитивным типом среды выполнения или включать создание нового общего типа в общей сборке.</span><span class="sxs-lookup"><span data-stu-id="915c8-193">This shared type can either be a primitive runtime type, or it can involve creating a new shared type in a shared assembly.</span></span>  <span data-ttu-id="915c8-194">Часто общий тип является [интерфейсом](../../csharp/language-reference/keywords/interface.md), определенным в сборке приложения.</span><span class="sxs-lookup"><span data-stu-id="915c8-194">Often the shared type is an [interface](../../csharp/language-reference/keywords/interface.md) defined in an application assembly.</span></span> <span data-ttu-id="915c8-195">См. также: [Как реализовано совместное использование зависимостей?](#how-are-dependencies-shared)</span><span class="sxs-lookup"><span data-stu-id="915c8-195">See also: [How are dependencies shared?](#how-are-dependencies-shared).</span></span>

2. <span data-ttu-id="915c8-196">Используйте технологию маршалинга для преобразования одного типа в другой.</span><span class="sxs-lookup"><span data-stu-id="915c8-196">Use marshaling techniques to convert from one type to another.</span></span>
