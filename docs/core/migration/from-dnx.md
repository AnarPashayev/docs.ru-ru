---
title: Переход с DNX на интерфейс CLI .NET Core
description: Переход от средств DNX к средствам CLI .NET Core.
ms.date: 06/20/2016
ms.openlocfilehash: 31317f110ae1e8586b78becd757d0a8ff07f1459
ms.sourcegitcommit: f38e527623883b92010cf4760246203073e12898
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/20/2020
ms.locfileid: "77503819"
---
# <a name="migrating-from-dnx-to-net-core-cli-projectjson"></a>Переход с DNX на интерфейс CLI .NET Core (project.json)

## <a name="overview"></a>Обзор
В версии-кандидате 1 .NET Core и ASP.NET Core 1.0 были представлены инструменты DNX. С выпуском версии-кандидата 2 .NET Core и ASP.NET Core 1.0 был осуществлен переход на интерфейс командной строки (CLI) .NET Core с DNX.

Давайте в общих чертах вспомним, что такое DNX. DNX — это среда выполнения и набор инструментов, которые использовались для создания приложений .NET Core, и в частности приложений ASP.NET Core 1.0. Это решение состояло из трех основных компонентов:

1. DNVM — скрипт установки для получения DNX;
2. DNX (среда выполнения Dotnet) — среда выполнения вашего кода;
3. DNU (служебная программа для разработки Dotnet) — средство для управления зависимостями, сборки и публикации приложений.

С появлением интерфейса CLI все перечисленные выше компоненты входят в одни набор инструментов. Однако, поскольку среда DNX была доступна в версии-кандидате 1, у вас могут быть созданные с ее помощью проекты, которые может потребоваться перенести в новый инструментарий CLI.

В этом руководстве рассматриваются основные действия по переносу проектов из DNX в интерфейс CLI .NET Core. Если вы создаете проект в .NET Core с нуля, то этот документ вам не нужен.

## <a name="main-changes-in-the-tooling"></a>Основные изменения в инструментарии
В инструментарии реализован ряд важных изменений, с которыми необходимо предварительно ознакомиться.

### <a name="no-more-dnvm"></a>Отсутствие DNVM
DNVM (сокращение от *DotNet Version Manager*, диспетчер версий DotNet) — это bash-скрипт или скрипт PowerShell, который использовался для установки DNX на компьютере. Он помогал пользователям получить DNX из указанного канала (или канала по умолчанию), а также пометить определенную среду DNX как активную, в результате чего она помещалась в переменную $PATH для данного сеанса. Это позволяло использовать различные средства.

Поддержка набора функций DNVM прекращена с учетом изменений, реализованных в CLI .NET Core.

CLI упаковывается двумя способами:

1. собственные установщики для конкретной платформы;
2. скрипт установки для других ситуаций (например, серверов CI).

С учетом этого возможности установки DNVM больше не нужны. Но как насчет возможностей выбора среды выполнения?

Вы ссылаетесь на среду выполнения в файле `project.json`, добавляя пакет определенной версии в список зависимостей. После внесения этого изменения ваше приложение сможет использовать двоичные файлы новой среды выполнения. Получение этих двоичных файлов на компьютере производится так же, как и при использовании CLI: вы устанавливаете среду выполнения с помощью одного из поддерживаемых собственных установщиков или посредством скрипта установки.

### <a name="different-commands"></a>Разные команды
Если вы использовали среду DNX, то применяли некоторые команды из трех ее компонентов (DNX, DNU и DNVM). В CLI некоторые из этих команд изменились, некоторые стали недоступны, а другие сохранились, но имеют немного другую семантику.

В таблице ниже приведены команды DNX и DNU и их аналоги в CLI.

| Команда DNX                    | Команда CLI    | Описание                                                                                                     |
|--------------------------------|----------------|-----------------------------------------------------------------------------------------------------------------|
| dnx run                        | `dotnet run`     | Выполнение кода из источника.                                                                                           |
| dnu build                      | `dotnet build`   | Сборка двоичного файла с кодом на языке IL.                                                                                |
| dnu pack                       | `dotnet pack`    | Упаковка кода в пакет NuGet.                                                                        |
| dnx \[команда] (например, dnx web) | Н/Д \*          | Выполнение команды в среде DNX в соответствии с определением в файле project.json.                                                     |
| dnu install                    | Н/Д \*          | В среде DNX установка пакета в качестве зависимости.                                                            |
| dnu restore                    | `dotnet restore` | Восстановление зависимостей, указанных в файле project.json. ([см. примечание](#dotnet-restore-note))                                                            |
| dnu publish                    | `dotnet publish` | Публикация приложения для развертывания в одной из трех форм (переносимое, переносимое с машинным кодом или автономное). |
| dnu wrap                       | Н/Д \*          | В среде DNX упаковка файла project.json в файл CSPROJ.                                                                    |
| dnu commands                   | Н/Д \*          | В среде DNX управление глобально установленными командами.                                                           |

(\*) — поддержка этих возможностей в CLI не предусмотрена.

## <a name="dnx-features-that-are-not-supported"></a>Неподдерживаемые возможности DNX
Как видно в приведенной выше таблице, в среде DNX имелись возможности, которые мы решили не поддерживать в CLI, по крайней мере на данный момент. В этом разделе будут рассмотрены наиболее важные из них, а также приведено обоснование прекращению их поддержки и обходные решения для их реализации.

### <a name="global-commands"></a>Глобальные команды
В DNU появилось такое понятие, как "глобальные команды". По существу, это консольные приложения, упакованные в виде пакетов NuGet со скриптом оболочки, который вызывает указанную среду DNX для запуска приложения.

В интерфейсе CLI такого понятия нет. Однако он поддерживает добавление команд для отдельных проектов, которые можно вызывать с помощью привычного синтаксиса `dotnet <command>`.

### <a name="installing-dependencies"></a>Установка зависимостей
Начиная с версии 1, в CLI .NET Core отсутствует команда `install` для установки зависимостей. Чтобы установить пакет из NuGet, его нужно добавить как зависимость в файл `project.json`, а затем выполнить команду `dotnet restore` ([см. примечание](#dotnet-restore-note)).

### <a name="running-your-code"></a>Выполнение кода
Выполнять код можно двумя основными способами. Один из них — выполнение из источника с помощью команды `dotnet run`. В отличие от команды `dnx run`, компиляция в памяти при этом не производится. Эта команда вызывает `dotnet build` для сборки кода, а затем запускает собранный двоичный файл.

Другой способ — использовать сам драйвер `dotnet` для выполнения кода. Для этого нужно указать путь к сборке: `dotnet path/to/an/assembly.dll`.

## <a name="migrating-your-dnx-project-to-net-core-cli"></a>Перенос проекта DNX в CLI .NET Core
Помимо использования новых команд для работы с кодом, переход с DNX также требует выполнения еще трех важных действий:

1. перенос файла `global.json`, если он должен использовать CLI;
2. перенос самого файла проекта (`project.json`) в инструментарий CLI;
3. переход с интерфейсов API среды DNX на их аналоги в BCL.

### <a name="changing-the-globaljson-file"></a>Изменение файла global.json
Файл `global.json` выступает в роли файла решения как для проектов версии-кандидата 1, так и для проектов версии-кандидата 2 (или более поздней версии). Чтобы настроить для .NET Core CLI (а также Visual Studio) возможность различать проекты версии-кандидата 1 и проекты более поздних версий, используется свойство `"sdk": { "version" }`. Если в файле `global.json` вообще нет этого узла, предполагается, что проект относится к последней версии.

Чтобы обновить файл `global.json`, удалите это свойство или задайте в качестве его значения точную версию средств, которую необходимо использовать. В данном случае это версия **1.0.0-preview2-003121**:

```json
{
    "sdk": {
        "version": "1.0.0-preview2-003121"
    }
}
```

### <a name="migrating-the-project-file"></a>Перенос файл проекта

Интерфейс CLI и среда DNX используют одну и ту же базовую систему проектов, основанную на файле `project.json`. Синтаксис и семантика файла проекта в целом совпадают, за небольшими исключениями в некоторых ситуациях. В схеме есть небольшие изменения. С ними можно ознакомиться в [файле схемы](http://json.schemastore.org/project).

Если вы создаете консольное приложение, в файл проекта нужно добавить следующий фрагмент кода:

```json
"buildOptions": {
    "emitEntryPoint": true
}
```

Он предписывает команде `dotnet build` создать точку входа для приложения, что делает код готовым к выполнению. Если вы создаете библиотеку классов, просто опустите приведенный выше раздел. Само собой, после добавления приведенного выше фрагмента в файл `project.json` необходимо добавить статическую точку входа. После перехода с DNX предоставляемые этой средой службы DI становятся недоступны, поэтому это должна быть базовая точка входа .NET: `static void Main()`.

Если в файле `project.json` есть раздел commands, его можно удалить. Некоторые команды, которые существовали как команды DNU, например команды интерфейса CLI для Entity Framework, переносятся в CLI как расширения на уровне отдельных проектов. Если вы создали собственные команды, которые используете в проектах, то их надо заменить на расширения CLI. В этом случае узел `commands` в файле `project.json` нужно заменить на узел `tools`, в котором должны быть перечислены зависимости средств.

После выполнения этих действий необходимо решить, какой тип переносимости требуется для приложения. В .NET Core мы реализовали целый спектр вариантов переносимости. Например, приложение может быть полностью *переносимым* или *автономным*. Переносимое приложение работает примерно так же, как приложение .NET Framework: ему требуется общий компонент для выполнения на целевом компьютере (.NET Core). Автономное приложение не требует установки среды .NET Core на целевом компьютере, но для каждой поддерживаемой ОС необходимо создать отдельное приложение. Эти и другие типы переносимости рассматриваются в документе, посвященном [типам переносимости приложений](../deploying/index.md).

Выбрав нужный тип переносимости, необходимо изменить целевые платформы. Если вы создавали приложения для .NET Core, то, скорее всего, использовали `dnxcore50` в качестве целевой платформы. В контексте CLI и изменений, связанных с библиотекой [.NET Standard](../../standard/net-standard.md), необходимо использовать одну из следующих платформ:

1. `netcoreapp1.0` — если вы создаете приложения в .NET (включая приложения ASP.NET Core);
2. `netstandard1.6` — если вы создаете библиотеки классов для .NET Core.

При использовании других целевых платформ `dnx`, например `dnx451`, их также необходимо изменить. `dnx451` следует изменить на `net451`.
Дополнительные сведения см. в разделе о [.NET Standard](../../standard/net-standard.md).

Ваш файл `project.json` в основном готов. Теперь нужно проверить список зависимостей и обновить их до более новых версий, особенно если вы используете зависимости ASP.NET Core. Если вы применяли отдельные пакеты для интерфейсов API BCL, то можете использовать пакет среды выполнения, как описано в документе, посвященном [типам переносимости приложений](../deploying/index.md).

Когда вы будете готовы, можно попробовать выполнить восстановление с помощью команды `dotnet restore` ([см. примечание](#dotnet-restore-note)). В зависимости от версии зависимостей могут возникнуть ошибки, если системе NuGet не удастся разрешить зависимости для одной из перечисленных выше целевых платформ. Это временная проблема: со временем все большее число пакетов будет поддерживать эти платформы. Пока же вы можете использовать оператор `imports` в узле `framework`, чтобы сообщить системе NuGet, что она может восстановить указанные в этом операторе пакеты, предназначенные для соответствующей платформы.
В этом случае при возникновении ошибок восстановления вы должны получить достаточно информации, чтобы понять, какие платформы следует импортировать. Если вы немного запутались в этом, то просто помните, что, как правило, указание платформ `dnxcore50` и `portable-net45+win8` в операторе `imports` позволяет добиться желаемого результата. В приведенном ниже фрагменте кода в формате JSON показано, как это должно выглядеть.

```json
    "frameworks": {
        "netcoreapp1.0": {
            "imports": ["dnxcore50", "portable-net45+win8"]
        }
    }
```

При выполнении `dotnet build` будут выведены все итоговые ошибки сборки, хотя их не должно быть много. После того как код будет собран и будет правильно выполняться, вы можете протестировать его с помощью средства запуска. Выполните команду `dotnet <path-to-your-assembly>` и понаблюдайте за выполнением.

<a name="dotnet-restore-note"></a>

[!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]
