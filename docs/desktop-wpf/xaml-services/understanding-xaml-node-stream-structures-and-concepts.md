---
title: Общее представление о понятиях и структурах потока узлов XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML node streams [XAML Services]
- nodes [XAML Services], XAML node stream
- XAML [XAML Services], XAML node streams
ms.assetid: 7c11abec-1075-474c-9d9b-778e5dab21c3
ms.openlocfilehash: b3de3dca029c5e676fc7cdebc7735cfdade0228a
ms.sourcegitcommit: c2d9718996402993cf31541f11e95531bc68bad0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/27/2020
ms.locfileid: "81432860"
---
# <a name="xaml-node-stream-structures-and-concepts"></a>Структуры и концепции потока узлов XAML

Читатели XAML и писатели XAML, реализованные в службах .NET XAML, основаны на концепции проектирования потока узлов XAML. Поток узлов XAML — это концептуальное представление набора узлов XAML. В этом концептуальном представлении обработчик XAML проходит по структуре связей узлов в XAML поочередно. В каждый момент времени в открытом потоке узлов XAML существует только одна текущая запись или текущая позиция, и многие аспекты API сообщают только информацию, доступную из этой позиции. Текущий узел в потоке узлов XAML можно описать как объект, член или значение. Рассматривая XAML как поток узлов XAML, средства чтения XAML могут взаимодействовать со средствами записи XAML и позволять программе просматривать содержимое потока узлов XAML, взаимодействовать с ним или изменять его во время функционирования пути загрузки или пути сохранения, использующего XAML. XAML читателя и писателя API дизайн и XAML узла поток концепции аналогичны предыдущим связанных читателей и писателей <xref:System.Xml.XmlReader> конструкций и концепций, таких как XML Документ объектная модель (DOM) и и <xref:System.Xml.XmlWriter> классов. В этом разделе рассматриваются концепции потока узлов XAML и описывается, как можно создавать подпрограммы, взаимодействующие с представлениями XAML на уровне узлов XAML.

## <a name="loading-xaml-into-a-xaml-reader"></a>Загрузка XAML в средство чтения XAML

Базовый класс <xref:System.Xaml.XamlReader> не объявляет конкретный метод загрузки исходного XAML в средство чтения XAML. Вместо этого метод загрузки, включая общие характеристики и ограничения его источника входных данных для XAML, объявляет и реализует производный класс. Например, класс <xref:System.Xaml.XamlObjectReader> читает граф объектов, начиная с источника входных данных одного объекта, который представляет корень или базу. Затем класс <xref:System.Xaml.XamlObjectReader> создает поток узлов XAML из этого графа объектов.

Наиболее известным подклассом <xref:System.Xaml.XamlReader> <xref:System.Xaml.XamlXmlReader>. Подкласс<xref:System.Xaml.XamlXmlReader> загружает исходный XAML либо непосредственно, путем загрузки текстового файла через поток или путь к файлу, либо косвенно — через связанный класс средства чтения, такой как <xref:System.IO.TextReader>. Класс <xref:System.Xaml.XamlReader> можно рассматривать как содержащий весь источник входных данных XAML после его загрузки. Однако базовый API <xref:System.Xaml.XamlReader> разработан таким образом, чтобы средство чтения взаимодействовало с одним узлом XAML. После первой загрузки первый обнаруженный узел является корнем XAML и его начальным объектом.

### <a name="the-xaml-node-stream-concept"></a>Концепция потока узлов XAML

Если вы больше знакомы с DOM, метафорой дерева или подходом на основе запросов к доступу к технологиям на основе XML, то полезный способ концептуализировать поток узлов XAML заключается в следующем. Представьте себе загруженный XAML в виде модели DOM или дерева, где каждый возможный узел полностью развернут, а затем представлен в линейной форме. При переходе по узлам вы можете проходить «в» уровни или «из» уровней, которые относятся к модели DOM, но поток узлов XAML явно не отслеживается, так как эти понятия уровней не относятся к потоку узлов. Поток узлов имеет «текущую» позицию, но пока вы самостоятельно не сохраните другие части потока как ссылки, любой аспект потока узлов, кроме текущего положения узла, находится вне поля зрения за пределами окна просмотра.

Существенное преимущество концепции потока узлов XAML заключается в том, что при проходе по всему потоку узла будет гарантированно обработано все представление XAML; не нужно беспокоиться, что запрос, операция DOM или какой-либо другой нелинейный способ обработки информации пропустит часть представления XAML. По этой причине представление потока узлов XAML идеально подходит как для соединения средств чтения и записи XAML, так и для построения системы, в которой можно вставить собственный процесс, выполняемый между этапами чтения и записи операции обработки XAML. Во многих случаях порядок узлов в потоке узлов XAML намеренно оптимизируется или изменяется средствами чтения XAML по сравнению с тем порядком, который может отображаться в исходном тексте, двоичном объекте или графе объекта. Это поведение предусмотрено для обеспечения архитектуры обработки XAML, в которой средства записи XAML никогда не оказываются в позиции, где они должны переходить «назад» в потоке узлов. В идеале все операции записи XAML должны быть способны выполняться на основе контекста схемы и текущей позиции в потоке узлов.

## <a name="a-basic-reading-node-loop"></a>Основной цикл узлов чтения

Основной цикл узлов чтения для анализа потока узлов XAML включает следующие концепции. Применительно к циклам узлов, рассматриваемым в этом разделе, предположим, что вы читаете понятный для пользователя текстовый файл XAML с помощью <xref:System.Xaml.XamlXmlReader>. Ссылки в этом разделе относятся к конкретному API цикла узлов XAML, реализуемому <xref:System.Xaml.XamlXmlReader>.

- Убедитесь, что вы не находитесь в конце потока узлов XAML (проверьте <xref:System.Xaml.XamlXmlReader.IsEof%2A>, или используйте возвращаемое значение <xref:System.Xaml.XamlXmlReader.Read%2A> ). Если вы находитесь в конце потока, то текущий узел отсутствует и следует выйти.

- Проверьте, какой тип узла предоставляет в настоящий момент поток узлов XAML, путем вызова <xref:System.Xaml.XamlXmlReader.NodeType%2A>.

- Если имеется связанное средство записи объектов XAML, которое подключено напрямую, то на этом этапе обычно вызывается метод <xref:System.Xaml.XamlWriter.WriteNode%2A> .

- В зависимости от типа <xref:System.Xaml.XamlNodeType> , возвращенного для текущего узла или текущей записи, вызовите один из следующих объектов, чтобы получить сведения о содержимом узла.

  - Для типа <xref:System.Xaml.XamlXmlReader.NodeType%2A> объекта <xref:System.Xaml.XamlNodeType.StartMember> или <xref:System.Xaml.XamlNodeType.EndMember>вызовите <xref:System.Xaml.XamlXmlReader.Member%2A> , чтобы получить сведения <xref:System.Xaml.XamlMember> о члене. Член может <xref:System.Xaml.XamlDirective>быть, и, таким образом, не обязательно может быть обычным типоопределенным членом предыдущего объекта. Например, примененная к объекту директива `x:Name` отображается как член XAML, свойство <xref:System.Xaml.XamlMember.IsDirective%2A> которого имеет значение true, свойство <xref:System.Xaml.XamlMember.Name%2A> этого члена имеет значение `Name`, а другие свойства указывают, что эта директива находится в пространстве имен XAML языка XAML.

  - Для типа <xref:System.Xaml.XamlXmlReader.NodeType%2A> объекта <xref:System.Xaml.XamlNodeType.StartObject> или <xref:System.Xaml.XamlNodeType.EndObject>вызовите <xref:System.Xaml.XamlXmlReader.Type%2A> , чтобы получить сведения <xref:System.Xaml.XamlType> об объекте.

  - Для типа <xref:System.Xaml.XamlXmlReader.NodeType%2A> объекта <xref:System.Xaml.XamlNodeType.Value>вызовите <xref:System.Xaml.XamlXmlReader.Value%2A>. Узел имеет значение только в том случае, если он является простейшим выражением значения для члена или текстом инициализации объекта (однако следует иметь в виду поведение преобразования типов, как описано в следующем разделе этой статьи).

  - Для типа <xref:System.Xaml.XamlXmlReader.NodeType%2A> объекта <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>вызовите <xref:System.Xaml.XamlXmlReader.Namespace%2A> , чтобы получить сведения о пространстве имен для узла пространства имен.

- Вызовите метод <xref:System.Xaml.XamlXmlReader.Read%2A> , чтобы средство чтения XAML перешло к следующему узлу в потоке узлов XAML, и повторите эти действия.

Поток узлов XAML, предоставляемый читателями .NET XAML Services XAML, всегда обеспечивает полный, глубокий обход всех возможных узлов. Типичные методы управления потоком для цикла узлов XAML включают определение текста в цикле `while (reader.Read())`и переключение на <xref:System.Xaml.XamlXmlReader.NodeType%2A> в каждой точке узла в цикле узлов.

Если поток узлов находится в конце файла, текущий узел имеет значение null.

В следующем примере показан простейший цикл, использующий средства чтения и записи.

```csharp
XamlXmlReader xxr = new XamlXmlReader(new StringReader(xamlStringToLoad));
//where xamlStringToLoad is a string of well formed XAML
XamlObjectWriter xow = new XamlObjectWriter(xxr.SchemaContext);
while (xxr.Read()) {
  xow.WriteNode(xxr);
}
```

Этот простой пример цикла узлов XAML пути загрузки прозрачно связывает средство чтения XAML и средство записи XAML, выполняя то же самое, что выполняется при использовании метода <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>. Но затем эта базовая структура расширяется для применения в сценарии чтения или записи. Далее приведены некоторые возможные сценарии.

- Переключиться в <xref:System.Xaml.XamlXmlReader.NodeType%2A>. Выполнять разные действия в зависимости от того, какой узел читается.

- Не вызывать метод <xref:System.Xaml.XamlWriter.WriteNode%2A> во всех случаях. Вызывать метод <xref:System.Xaml.XamlWriter.WriteNode%2A> только в некоторых случаях <xref:System.Xaml.XamlXmlReader.NodeType%2A> .

- В пределах логики для конкретного типа узла анализировать особенности этого узла и работать с ними. Например, можно только писать объекты, которые приходят из определенного пространства имен XAML, а затем отсутывать или откладывать любые объекты, не из этого пространства имен XAML. Вы также можете удалить или иным образом повторно обработать все директивы XAML, которые не поддерживаются вашей системой XAML, в рамках обработки элементов.

- Определить пользовательский объект <xref:System.Xaml.XamlObjectWriter> , который переопределяет методы `Write*` , возможно, выполняя сопоставление типов, обходящее контекст схемы XAML.

- Создать объект <xref:System.Xaml.XamlXmlReader> для использования контекста схемы XAML не по умолчанию, чтобы настроенные различия в поведении XAML использовались как средством чтения, так и средством записи.

### <a name="accessing-xaml-beyond-the-node-loop-concept"></a>Доступ к XAML за рамками концепции цикла узлов

Помимо цикла узлов XAML существуют и другие способы работы с представлением XAML. Например, может существовать  средство чтения XAML, которое может читать индексированный узел, в частности обращаться к узлам напрямую с помощью директивы `x:Name`, `x:Uid`или используя другие идентификаторы. .NET XAML Services не обеспечивает полную реализацию, но предоставляет предлагаемый шаблон через службы и типы поддержки. Дополнительные сведения см. в разделе <xref:System.Xaml.IXamlIndexingReader> и <xref:System.Xaml.XamlNodeList>.

## <a name="working-with-the-current-node"></a>Работа с текущим узлом

В большинстве сценариев, использующих цикл узлов XAML, выполняется не только чтение узлов. В большинстве сценариев обрабатывается текущий узел, а затем каждый узел по одному передается в реализацию <xref:System.Xaml.XamlWriter>.

В типичном сценарии пути загрузки <xref:System.Xaml.XamlXmlReader> создает поток узлов XAML; узлы XAML обрабатываются в соответствии с заданной логикой и контекстом схемы XAML; затем узлы передаются в <xref:System.Xaml.XamlObjectWriter>. Затем вы интегрируете полученный граф объектов в свое приложение или структуру.

В типичном сценарии пути сохранения <xref:System.Xaml.XamlObjectReader> читает граф объектов; отдельные узлы XAML обрабатываются; затем <xref:System.Xaml.XamlXmlWriter> выдает сериализованный результат в виде текстового файла XAML. Ключевым моментом является то, что оба пути и сценарии включают работу с точно одним узлом XAML одновременно, а узлы XAML доступны для обработки стандартизированным способом, который определяется системой типа XAML и the.NET AAML Services AIS.

### <a name="frames-and-scope"></a>Фреймы и область

Цикл узлов XAML проходит по потоку узлов XAML линейным образом. Поток узлов углубляется в объекты, в члены, которые содержат другие объекты, и т. д. Часто бывает удобно отслеживать область в потоке узлов XAML путем реализации концепции фрейма и стека. В частности, это справедливо для случая активной настройки потока узла при нахождении в нем. Поддержка кадра и стека, реализуемая в рамках логики цикла узлов, может учитывать области `StartObject` (или `GetObject`) и `EndObject` по мере углубления в структуру узлов XAML, если рассматривать структуру с точки зрения модели DOM.

## <a name="traversing-and-entering-object-nodes"></a>Обход узлов объекта и вход в них

Первым узлом в потоке узлов при его открытии средством чтения XAML является узел начального объекта корневого объекта. По определению этот объект всегда является узлом одного объекта и не имеет одноранговых узлов. В любом реальном примере XAML корневой объект определяется с одним или несколькими свойствами, содержащими дополнительные объекты, и эти свойства имеют узлы-члены. В свою очередь, узлы-члены могут иметь один или несколько узлов-объектов или вместо этого заканчиваться в узле значения. Корневой объект обычно определяет области имен XAML, которые синтаксически назначаются как атрибуты в текстовой разметке XAML, но соответствуют типу узла `Namescope` в представлении потока узлов XAML.

Рассмотрим следующий пример XAML (это произвольный XAML, не подкрепленный существующими типами в .NET). Предполагается, что в этой объектной модели `FavorCollection` является `List<T>` объектов `Favor`, `Balloon` и `NoiseMaker` , которые могут быть присвоены `Favor`, свойство `Balloon.Color` поддерживается объектом `Color` аналогично тому, как в WPF цвета задаются при помощи известных названий цветов, а объект `Color` поддерживает преобразователь типов для синтаксиса атрибутов.

|Разметка XAML|Итоговый поток узлов XAML|
|-----------------|--------------------------------|
|`<Party`|`Namespace` для `Party`|
|`xmlns="PartyXamlNamespace">`|`StartObject` для `Party`|
|`<Party.Favors>`|`StartMember` для `Party.Favors`|
||`StartObject` для неявного объекта `FavorCollection`|
||Узел`StartMember` для свойства неявных элементов `FavorCollection` .|
|`<Balloon`|`StartObject` для `Balloon`|
|`Color="Red"`|`StartMember` для `Color`<br /><br /> `Value` для строки значения атрибута `"Red"`<br /><br /> `EndMember` для `Color`;|
|`HasHelium="True"`|`StartMember` для `HasHelium`<br /><br /> `Value` для строки значения атрибута `"True"`<br /><br /> `EndMember` для `HasHelium`;|
|`>`|`EndObject` для `Balloon`;|
|`<NoiseMaker>Loudest</NoiseMaker>`|`StartObject` для `NoiseMaker`<br /><br /> `StartMember` для `_Initialization`<br /><br /> `Value` для строки значения инициализации `"Loudest"`<br /><br /> `EndMember` для `_Initialization`<br /><br /> `EndObject` для `NoiseMaker`;|
||Узел`EndMember` для свойства неявных элементов `FavorCollection` .|
||`EndObject` для неявного объекта `FavorCollection`|
|`</Party.Favors>`|`EndMember` для `Favors`;|
|`</Party>`|`EndObject` для `Party`;|

В потоке узлов XAML можно рассчитывать на следующее поведение.

- Если узел `Namespace` существует, он добавляется в поток непосредственно перед объектом `StartObject` , который объявил пространство имен XAML с помощью `xmlns`. Давайте снова взглянем на предыдущую таблицу с XAML и примером потока узлов. Обратите внимание, как, по всей видимости, будут перемещены узлы `StartObject` и `Namespace` по сравнению с их объявленными позициями в разметке текста. Это типичное представление поведения, в котором узлы пространства имен всегда отображаются перед узлом, к которому они имеют отношение в потоке узлов. Смысл этой конструкции заключается в том, что сведения о пространстве имен, необходимые для средств записи объектов, должны быть известны до того, как средство записи объекта попытается выполнить сопоставление типов или другую обработку объекта. Помещение сведений о пространстве имен XAML перед его областью применения в потоке облегчает обработку потока узлов в представленном порядке.

- По этой причине в большинстве случаев реального использования разметки существует один или несколько узлов `Namespace` , которые читаются первыми при обходе узлов с начала, а не с объекта `StartObject` корня.

- За узлом `StartObject` может следовать `StartMember`, `Value`или непосредственно `EndObject`. За ним никогда не следует сразу же другой `StartObject`.

- За `StartMember` может следовать `StartObject`, `Value`или непосредственно `EndMember`. За ним может следовать `GetObject`, для членов, в которых значение должно быть получено из существующего значения родительского объекта, а не из `StartObject` , который может создавать экземпляр нового значения. За ним также может следовать узел `Namespace` , который относится к следующему `StartObject`. За ним никогда не следует сразу же другой `StartMember`.

- Узел `Value` представляет само значение; это не EndValue. За ним может следовать только `EndMember`.

  - Текст инициализации XAML объекта, который может использоваться конструкцией, не приводит к структуре «Объект-значение». Вместо этого создается выделенный узел для члена с именем `_Initialization` , и этот узел члена содержит строку значения инициализации. Если он существует, то `_Initialization` всегда является первым `StartMember`. Член`_Initialization` может быть определен в некоторых представлениях служб XAML при помощи области имен XAML языка XAML, чтобы уточнить, что `_Initialization` не является заданным свойством в резервных типах.

  - Комбинация «Член-значение» представляет настройку атрибута значения. В конечном итоге возможно включение преобразователя значений в обработку этого значения, и значение представляет собой простую строку. Однако это не вычисляется до тех пор, пока средство записи объектов XAML не обработает этот поток узлов. Средство записи объектов XAML обрабатывает необходимый контекст схемы XAML, сопоставление системы типов и другую поддержку, необходимую для преобразований значений.

- За узлом `EndMember` может следовать узел `StartMember` для последующего члена или узел `EndObject` для владельца этого члена.

- За узлом `EndObject` может следовать узел `EndMember` . За ним может также следовать узел `StartObject` для случаев, когда эти объекты являются одноранговыми узлами в элементах коллекции. Кроме того, за ним может следовать узел `Namespace` , который относится к следующему `StartObject`.

  - В исключительном случае закрытия всего потока узлов за объектом `EndObject` корня не следует ничего; средство чтения достигает конца файла, и метод <xref:System.Xaml.XamlReader.Read%2A> возвращает значение `false`.

## <a name="value-converters-and-the-xaml-node-stream"></a>Преобразователи значений и поток узлов XAML

Преобразователь значений — это общий термин для расширения разметки, преобразователя типов (включая сериализаторы значений) или другого выделенного класса, указанного как преобразователь значений в системе типов XAML. В потоке узлов XAML использование преобразователя типов и использование расширения разметки имеют совершенно разные представления.

### <a name="type-converters-in-the-xaml-node-stream"></a>Преобразователи значений в потоке узлов XAML

Набор атрибутов, который в конечном итоге приводит к использованию преобразователя типов, сообщается в поток узлов XAML как значение члена. Поток узлов XAML не пытается создать экземпляр объекта преобразователя типов и передать ему значение. Использование реализации преобразования преобразователя типов требует вызова контекста схемы XAML и использования его для сопоставления типов. Даже для определения того, какой класс преобразователя типов следует использовать для обработки значения, косвенно требуется контекст схемы языка XAML. При использовании контекста схемы XAML по умолчанию эти сведения можно получить из системы типов XAML. Если сведения класса преобразователя типов на уровне потока узлов XAML требуются до подключения к средству записи XAML, их можно получить из сведений <xref:System.Xaml.XamlMember> устанавливаемого члена. Но в противном случае ввод преобразователя типа должен быть сохранен в потоке узлов XAML в виде простого значения до тех пор, пока не будут выполнены оставшиеся операции, требующие системы отображения шрифта и контекста схемы XAML, например создание объекта автором объектов XAML.

Например, рассмотрим следующую структуру определения класса и использования для него XAML.

```csharp
public class BoardSizeConverter : TypeConverter {
  //converts from string to an int[2] by splitting on an "x" char
}
public class GameBoard {
  [TypeConverter(typeof(BoardSizeConverter))]
  public int[] BoardSize; //2x2 array, initialization not shown
}
```

```xaml
<GameBoard BoardSize="8x8"/>
```

Текстовое представление потока узлов XAML для данного использования можно выразить следующим образом:

`StartObject` с <xref:System.Xaml.XamlType> , представляющий `GameBoard`

`StartMember` с <xref:System.Xaml.XamlMember> , представляющий `BoardSize`

Узел`Value` с текстовой строкой "`8x8`"

`EndMember` , соответствующий `BoardSize`

`EndObject` , соответствующий `GameBoard`

Обратите внимание, что в этом потоке узлов отсутствует экземпляр преобразователя типов. Однако вы можете получить сведения о преобразователе типов, вызвав <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> в <xref:System.Xaml.XamlMember> для `BoardSize`. При наличии допустимого контекста схемы XAML можно также вызвать методы преобразователя, получив экземпляр из <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>.

### <a name="markup-extensions-in-the-xaml-node-stream"></a>Расширения разметки в потоке узлов XAML

Об использовании расширения разметки сообщается в поток узлов XAML как об узле объекта в члене, где объект представляет экземпляр расширения разметки. Таким образом, использование расширения разметки более явно представлено в представлении потока узлов, чем использование преобразователя типов, и содержит больше сведений. Сведения<xref:System.Xaml.XamlMember> могут ничего не сообщать о расширении разметки, поскольку его использование зависит от ситуации и меняется в каждом возможном случае разметки; оно не является выделенным и неявным согласно типу или члену, как в случае с преобразователями типов.

Представление потока узлов расширений разметки как узлов объектов происходит даже в случае, когда использование расширения разметки было сделано в форме атрибута в текстовой разметке XAML (что происходит часто). Использование расширения разметки с применением явных форм элементов объектов интерпретируется таким же образом.

Внутри узла объекта расширения разметки могут находиться члены этого расширения разметки. Представление потока узлов XAML сохраняет использование этого расширения разметки, будь это использование позиционного параметра или использование с помощью явно указанных параметров.

При использовании позиционного параметра поток узлов XAML содержит заданное на уровне языка XAML свойство `_PositionalParameters` , регистрирующее это использование. Это свойство является универсальным <xref:System.Collections.Generic.List%601> с ограничением <xref:System.Object> . Это ограничение является объектом, а не строкой, поскольку предположительно использование позиционного параметра может содержать в себе вложенные использования расширения разметки. Для доступа к позиционным параметрам из использования можно выполнить итерацию по списку и применять индексаторы для отдельных значений списка.

При использовании именованных параметров каждый именованный параметр представляется как узел члена с этим именем в потоке узлов. Значения членов не обязательно являются строками, поскольку может использоваться вложенное расширение разметки.

`ProvideValue` из расширения разметки еще не вызывался. Однако он вызывается при подключении средства чтения XAML и средства записи XAML, чтобы вызывался `WriteEndObject` в узле расширения разметки при его исследовании в потоке узлов. По этой причине обычно требуется доступ к тому же контексту схемы XAML, который использовался бы для формирования графа объектов в пути загрузки. В противном случае `ProvideValue` из любого расширения разметки может вызывать здесь исключения, поскольку не имеет доступа к ожидаемым службам.

## <a name="xaml-and-xml-language-defined-members-in-the-xaml-node-stream"></a>Члены, заданные на уровне XAML и XML, в потоке узлов XAML

Определенные члены введены в поток узлов XAML из-за определений и соглашений средства чтения XAML, вместо того чтобы использовать явный поиск или построение <xref:System.Xaml.XamlMember> . Часто эти члены являются директивами XAML. В некоторых случаях это действие чтения XAML, вводящее директиву в поток узлов XAML. Другими словами, в исходном тексте XAML явно не указана директива участника, но читатель XAML вставляет директиву, чтобы удовлетворить структурную конвенцию XAML и сообщить информацию в потоке узлов XAML до того, как эта информация будет утеряна.

В следующем списке отмечаются все случаи, когда читатель XAML должен представить узло участника директивы XAML, и как этот узло-члена идентифицируется в реализациях .NET XAML Services.

- **Текст инициализации для узла объекта.** Имя этого узла члена — `_Initialization`, он представляет собой директиву XAML и определен в пространстве имен XAML языка XAML. Вы можете получить для него статическую сущность из <xref:System.Xaml.XamlLanguage.Initialization%2A>.

- **Позиционные параметры для расширения разметки.** Имя этого узла члена — `_PositionalParameters`, и он определен в пространстве имен XAML языка XAML. Он всегда содержит универсальный список объектов, каждый из которых является позиционным параметром, предварительно отделенным по символу-разделителю `,` , как представлено во входных данных XAML. Вы можете получить статическую сущность для директивы позиционных параметров из <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>.

- **Неизвестное содержимое.** Имя этого узла члена — `_UnknownContent`. Строго говоря, это директива <xref:System.Xaml.XamlDirective>, которая определяется в пространстве имен XAML языка XAML. Эта директива используется как сигнальная метка в случаях, когда в элементе объекта XAML имеется содержимое в исходном XAML, но никакое свойство содержимого невозможно определить в рамках текущего доступного контекста схемы XAML. Такой случай можно обнаружить в потоке узлов XAML, проверив члены с именем `_UnknownContent`. Если в потоке узлов XAML пути загрузки никакие другие действия не выполняются, вызывается <xref:System.Xaml.XamlObjectWriter> по умолчанию при попытке `WriteEndObject` , когда в каком-либо объекте обнаруживается член `_UnknownContent` . Объект <xref:System.Xaml.XamlXmlWriter> по умолчанию не вызывается и рассматривает этот член как неявный. Вы можете получить статическую сущность для `_UnknownContent` из <xref:System.Xaml.XamlLanguage.UnknownContent%2A>.

- **Коллекционное свойство коллекции:** Хотя резервный тип CLR класса коллекции, используемый для XAML, обычно имеет специальное свойство, вмещает элементы коллекции, это свойство не известно системе типа XAML до разрешения типа поддержки. Вместо этого поток узлов XAML вводит заполнитель `Items` в качестве члена типа коллекции XAML. В реализации .NET XAML Services имя этой директивы или `_Items`участника потока узлов — это имя. Константу для этой директивы можно получить из <xref:System.Xaml.XamlLanguage.Items%2A>.

    Обратите внимание, что поток узлов XAML может содержать свойство элементов с элементами, которые, как оказалось, не могут быть разборчивыми на основе разрешения типа поддержки и контекста схемы XAML. Например,

- **XML-определенные члены:** XML-определенные `xml:base` `xml:lang` , `xml:space` и члены сообщаются как `base` `lang`XAML директивы имени , , и `space` в .NET XAML Услуги реализаций. Их пространство имен — это пространство имен XML `http://www.w3.org/XML/1998/namespace`. Константы для каждого из них можно получить из <xref:System.Xaml.XamlLanguage>.

## <a name="node-order"></a>Порядок узлов

В некоторых случаях <xref:System.Xaml.XamlXmlReader> изменяет порядок узлов XAML в потоке узлов XAML по сравнению с порядком, в котором эти узлы отображаются при просмотре в разметке или при обработке в виде XML. Это делается для упорядочения узлов таким образом, чтобы средство записи <xref:System.Xaml.XamlObjectWriter> могло обрабатывать этот поток узлов в режиме только вперед.  В службах .NET XAML читатель XAML перевыполняет узлы вместо того, чтобы оставлять эту задачу писателю XAML, как оптимизация производительности для потребителей авторов узлов XAML.

Некоторые директивы предназначены специально в целях предоставления дополнительных сведений для создания объекта из элемента объекта. Это директивы `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`. Читатели .NET XAML Services XAML пытаются поместить эти директивы в качестве `StartObject`первых участников в поток узла после объекта по причинам, которые объясняются в следующем разделе.

### <a name="xamlobjectwriter-behavior-and-node-order"></a>Поведение XamlObjectWriter и порядок узлов

`StartObject` в <xref:System.Xaml.XamlObjectWriter> не обязательно сигнализирует средству записи объектов XAML немедленно создать экземпляр объекта. XAML включает в себя несколько языковых функций, которые позволяют инициализировать объект с дополнительным входной связью, и не полагаться полностью на использование беспараметрыного конструктора для создания первоначального объекта, и только затем настройки свойств. Эти возможности включают <xref:System.Windows.Markup.XamlDeferLoadAttribute>; текст инициализации; [x: TypeArguments](xtypearguments-directive.md); позиционные параметры расширения разметки; фабричные методы и связанные узлы [x: Arguments](xarguments-directive.md) (XAML 2009 г.). Каждый из этих случаев задерживает фактическое строительство объекта, и из-за того, что поток узлов перестраивается, автор объекта XAML может полагаться на поведение фактического построения экземпляра всякий раз, когда находится участник запуска, что не является специально директивой о строительстве для этого типа объекта.

### <a name="getobject"></a>GetObject

`GetObject` представляет узел XAML, где вместо создания нового объекта средство записи объектов XAML должно получать значение содержащегося свойства объекта. Типичный случай, где узел `GetObject` обнаруживается в потоке узлов XAML для объекта коллекции или объекта словаря, когда содержащее свойство умышленно предназначено только для чтения в объектной модели резервного типа. В этом сценарии коллекция или словарь часто создаются и инициализируются (обычно пустыми) логикой инициализации типа-владельца.

## <a name="see-also"></a>См. также

- <xref:System.Xaml.XamlObjectReader>
- [Службы XAML](index.md)
- [Пространства имен языка XAML](namespaces.md)
