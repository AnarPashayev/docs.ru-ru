---
title: Общие сведения о расширениях разметки для XAML
ms.date: 03/30/2017
helpviewer_keywords:
- markup extensions [XAML Services], custom
- XAML [XAML Services], markup extensions
ms.assetid: 261b2b11-2dc0-462f-8c66-55b8c9c6e436
ms.openlocfilehash: efb41f31a3baa895b5739021af5fa36e32aefeea
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/15/2020
ms.locfileid: "90556997"
---
# <a name="overview-of-markup-extensions-for-xaml"></a><span data-ttu-id="95468-102">Общие сведения о расширениях разметки для XAML</span><span class="sxs-lookup"><span data-stu-id="95468-102">Overview of markup extensions for XAML</span></span>

<span data-ttu-id="95468-103">Расширения разметки — это метод XAML для получения значения, которое не является примитивом или конкретным типом XAML.</span><span class="sxs-lookup"><span data-stu-id="95468-103">Markup extensions are a XAML technique for obtaining a value that's not a primitive or a specific XAML type.</span></span> <span data-ttu-id="95468-104">Для использования атрибутов расширения разметки используют известную последовательность символов из открывающей фигурной скобки `{` для входа в область расширения разметки и закрывающей фигурной скобки `}` для выхода из нее.</span><span class="sxs-lookup"><span data-stu-id="95468-104">For attribute usage, markup extensions use the known character sequence of an opening curly brace `{` to enter the markup extension scope, and a closing curly brace `}` to exit.</span></span> <span data-ttu-id="95468-105">При использовании служб XAML .NET можно использовать некоторые стандартные расширения разметки языка XAML из сборки System. XAML.</span><span class="sxs-lookup"><span data-stu-id="95468-105">When using .NET XAML Services, you can use some of the predefined XAML language markup extensions from the System.Xaml assembly.</span></span> <span data-ttu-id="95468-106">Можно также создать подкласс из класса <xref:System.Windows.Markup.MarkupExtension> , определенного в System.Xaml, и определить собственные расширения разметки.</span><span class="sxs-lookup"><span data-stu-id="95468-106">You can also subclass from the <xref:System.Windows.Markup.MarkupExtension> class, defined in System.Xaml, and define your own markup extensions.</span></span> <span data-ttu-id="95468-107">Или можно использовать расширения разметки, определенные конкретной платформой, если вы уже ссылаетесь на эту платформу.</span><span class="sxs-lookup"><span data-stu-id="95468-107">Or you can use markup extensions defined by a particular framework if you are already referencing that framework.</span></span>

<span data-ttu-id="95468-108">При обращении к расширению разметки средство записи объектов XAML может предоставить службы пользовательскому классу <xref:System.Windows.Markup.MarkupExtension> точку подключения к службе в переопределении <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="95468-108">When a markup extension usage is accessed, the XAML object writer can provide services to a custom <xref:System.Windows.Markup.MarkupExtension> class through a service connection point in the <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="95468-109">Службы можно использовать для получения контекста использования, конкретных возможностей средства записи объектов, контекста схемы XAML и т. д.</span><span class="sxs-lookup"><span data-stu-id="95468-109">The services can be used to obtain context about the usage, specific capabilities of the object writer, XAML schema context, and so on.</span></span>

## <a name="xaml-defined-markup-extensions"></a><span data-ttu-id="95468-110">Расширения разметки, определенные XAML</span><span class="sxs-lookup"><span data-stu-id="95468-110">XAML-defined markup extensions</span></span>

<span data-ttu-id="95468-111">Несколько расширений разметки реализуются службами XAML .NET для поддержки языка XAML.</span><span class="sxs-lookup"><span data-stu-id="95468-111">Several markup extensions are implemented by .NET XAML Services for XAML language support.</span></span> <span data-ttu-id="95468-112">Они соответствуют частям спецификации XAML как языка.</span><span class="sxs-lookup"><span data-stu-id="95468-112">These markup extensions correspond to parts of the specification of XAML as a language.</span></span> <span data-ttu-id="95468-113">Обычно они распознаются по префиксу `x:` в синтаксисе, как показано в общем использовании.</span><span class="sxs-lookup"><span data-stu-id="95468-113">These are typically identifiable by the `x:` prefix in the syntax as seen in common usage.</span></span> <span data-ttu-id="95468-114">Реализации служб XAML .NET для этих элементов языка XAML являются производными от  <xref:System.Windows.Markup.MarkupExtension> базового класса.</span><span class="sxs-lookup"><span data-stu-id="95468-114">.NET XAML Services implementations for these XAML language elements all derive from the  <xref:System.Windows.Markup.MarkupExtension> base class.</span></span>

> [!NOTE]
> <span data-ttu-id="95468-115">Префикс `x:` используется для обычного сопоставления пространства имен языка XAML в корневом элементе XAML.</span><span class="sxs-lookup"><span data-stu-id="95468-115">The `x:` prefix is used for the typical XAML namespace mapping of the XAML language namespace, in the root element of a XAML production.</span></span> <span data-ttu-id="95468-116">Например, проект и шаблоны страниц Visual Studio для различных конкретных платформ инициируют XAML-файл с помощью этого `x:` сопоставления.</span><span class="sxs-lookup"><span data-stu-id="95468-116">For example, the Visual Studio project and page templates for various specific frameworks initiate a XAML file using this `x:` mapping.</span></span> <span data-ttu-id="95468-117">Можно выбрать другой маркер префикса в собственном сопоставлении пространства имен XAML, но в этой документации по умолчанию предполагается сопоставление `x:` как средство идентификации этих сущностей, которые являются определенной частью пространства имен языка XAML, в отличие от пространства имен XAML по умолчанию конкретной платформы или других произвольных пространств имен CLR или XML.</span><span class="sxs-lookup"><span data-stu-id="95468-117">You could choose a different prefix token in your own XAML namespace mapping, but this documentation will assume the default `x:` mapping as a means of identifying those entities that are a defined part of the XAML language XAML namespace, as opposed to a specific framework's default XAML namespace or other arbitrary CLR or XML namespaces.</span></span>

### <a name="xtype"></a><span data-ttu-id="95468-118">x:Type</span><span class="sxs-lookup"><span data-stu-id="95468-118">x:Type</span></span>

<span data-ttu-id="95468-119">`x:Type` предоставляет объект <xref:System.Type> для именованного типа.</span><span class="sxs-lookup"><span data-stu-id="95468-119">`x:Type` supplies the <xref:System.Type> object for the named type.</span></span> <span data-ttu-id="95468-120">Эта функция чаще всего используется в механизмах задержки, применяющих базовый тип CLR и наследование типов в качестве моникера группирования или идентификатора.</span><span class="sxs-lookup"><span data-stu-id="95468-120">This functionality is used most frequently in deferral mechanisms that use underlying CLR type and type derivation as a grouping moniker or identifier.</span></span> <span data-ttu-id="95468-121">Стили и шаблоны WPF и использование ими свойств `TargetType` — один из примеров.</span><span class="sxs-lookup"><span data-stu-id="95468-121">WPF styles and templates, and their usage of `TargetType` properties, are a specific example.</span></span> <span data-ttu-id="95468-122">Для получения дополнительной информации см. [x:Type Markup Extension](xtype-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="95468-122">For more information, see [x:Type Markup Extension](xtype-markup-extension.md).</span></span>

### <a name="xstatic"></a><span data-ttu-id="95468-123">x:Static</span><span class="sxs-lookup"><span data-stu-id="95468-123">x:Static</span></span>

<span data-ttu-id="95468-124">`x:Static` создает статические значения из сущностей кода типа значения, которые непосредственно не принадлежат к типу значения свойства, но могут быть приведены к нему.</span><span class="sxs-lookup"><span data-stu-id="95468-124">`x:Static` produces static values from value-type code entities that are not directly the type of a property's value, but can be evaluated to that type.</span></span> <span data-ttu-id="95468-125">Это полезно для указания значений, которые уже существуют в качестве известных констант в определении типа.</span><span class="sxs-lookup"><span data-stu-id="95468-125">This is useful for specifying values that already exist as well-known constants in a type definition.</span></span> <span data-ttu-id="95468-126">Для получения дополнительной информации см. [x:Static Markup Extension](xstatic-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="95468-126">For more information, see [x:Static Markup Extension](xstatic-markup-extension.md).</span></span>

### <a name="xnull"></a><span data-ttu-id="95468-127">x:Null</span><span class="sxs-lookup"><span data-stu-id="95468-127">x:Null</span></span>

<span data-ttu-id="95468-128">`x:Null` указывает `null` как значение для элемента XAML.</span><span class="sxs-lookup"><span data-stu-id="95468-128">`x:Null` specifies `null` as a value for a XAML member.</span></span> <span data-ttu-id="95468-129">В зависимости от структуры определенных типов или от более масштабных понятий платформы `null` не всегда является значением свойства по умолчанию или неявным значением атрибута пустой строки.</span><span class="sxs-lookup"><span data-stu-id="95468-129">Depending on the design of specific types or on larger framework concepts, `null` is not always a default value for a property, or the implied value of an empty string attribute.</span></span> <span data-ttu-id="95468-130">Для получения дополнительной информации см. [x:Null Markup Extension](xnull-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="95468-130">For more information, see [x:Null Markup Extension](xnull-markup-extension.md).</span></span>

### <a name="xarray"></a><span data-ttu-id="95468-131">x:Array</span><span class="sxs-lookup"><span data-stu-id="95468-131">x:Array</span></span>

<span data-ttu-id="95468-132">`x:Array` поддерживает создание общих массивов в синтаксисе XAML, когда поддержка коллекций, предоставляемая базовыми элементами и моделями элементов управления, намеренно не используется.</span><span class="sxs-lookup"><span data-stu-id="95468-132">`x:Array` supports creation of general arrays in XAML syntax in cases where the collection support that is provided by base elements and control models is deliberately not used.</span></span> <span data-ttu-id="95468-133">Для получения дополнительной информации см. [x:Array Markup Extension](xarray-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="95468-133">For more information, see [x:Array Markup Extension](xarray-markup-extension.md).</span></span> <span data-ttu-id="95468-134">В частности, в XAML 2009 доступ к массивам осуществляется как к языковым примитивы, а не как к расширению.</span><span class="sxs-lookup"><span data-stu-id="95468-134">In XAML 2009 specifically, arrays are accessed as language primitives instead of as an extension.</span></span> <span data-ttu-id="95468-135">Дополнительные сведения см. в разделе [XAML 2009 Language Features](xaml-2009-language-features.md).</span><span class="sxs-lookup"><span data-stu-id="95468-135">For more information, see [XAML 2009 Language Features](xaml-2009-language-features.md).</span></span>

### <a name="xreference"></a><span data-ttu-id="95468-136">x:Reference</span><span class="sxs-lookup"><span data-stu-id="95468-136">x:Reference</span></span>

<span data-ttu-id="95468-137">`x:Reference` — это часть XAML 2009, расширение исходного набора языков (2006).</span><span class="sxs-lookup"><span data-stu-id="95468-137">`x:Reference` is part of XAML 2009, an extension of the original (2006) language set.</span></span> <span data-ttu-id="95468-138">`x:Reference` представляет ссылку на другой существующий объект в графе объектов.</span><span class="sxs-lookup"><span data-stu-id="95468-138">`x:Reference` represents a reference to another existing object in an object graph.</span></span> <span data-ttu-id="95468-139">Этот объект идентифицируется по `x:Name`.</span><span class="sxs-lookup"><span data-stu-id="95468-139">That object is identified by its `x:Name`.</span></span> <span data-ttu-id="95468-140">Дополнительные сведения см. в разделе [x:Reference Markup Extension](xreference-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="95468-140">For more information, see [x:Reference Markup Extension](xreference-markup-extension.md).</span></span>

### <a name="other-x-constructs"></a><span data-ttu-id="95468-141">Другие конструкции x:</span><span class="sxs-lookup"><span data-stu-id="95468-141">Other x: Constructs</span></span>

<span data-ttu-id="95468-142">Существуют другие конструкции `x:` для поддержки возможностей языка XAML, но они не реализованы как расширения разметки.</span><span class="sxs-lookup"><span data-stu-id="95468-142">Other `x:` constructs to support XAML language features exist, but these are not implemented as markup extensions.</span></span> <span data-ttu-id="95468-143">Дополнительные сведения см. в статье [Пространство имен XAML (x:) языка XAML](namespace-language-features.md).</span><span class="sxs-lookup"><span data-stu-id="95468-143">For more information, see [XAML Namespace (x:) Language Features](namespace-language-features.md).</span></span>

## <a name="the-markupextension-base-class"></a><span data-ttu-id="95468-144">Базовый класс MarkupExtension</span><span class="sxs-lookup"><span data-stu-id="95468-144">The MarkupExtension Base Class</span></span>

<span data-ttu-id="95468-145">Чтобы определить пользовательское расширение разметки, которое может взаимодействовать с реализациями средств чтения и записи XAML по умолчанию в System.Xaml, можно создать класс, производный от абстрактного класса <xref:System.Windows.Markup.MarkupExtension> .</span><span class="sxs-lookup"><span data-stu-id="95468-145">To define a custom markup extension that can interact with the default implementations of XAML readers and XAML writers in System.Xaml, you derive a class from the abstract <xref:System.Windows.Markup.MarkupExtension> class.</span></span> <span data-ttu-id="95468-146">У этого класса есть один метод для переопределения, <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>.</span><span class="sxs-lookup"><span data-stu-id="95468-146">That class has one method to override, which is <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>.</span></span> <span data-ttu-id="95468-147">Вам также необходимо определить дополнительные конструкторы для поддержки аргументов в расширениях разметки, соответствующие устанавливаемым свойствам.</span><span class="sxs-lookup"><span data-stu-id="95468-147">You might also need to define additional constructors to support arguments to the markup extension usage, and matching settable properties.</span></span>

<span data-ttu-id="95468-148">Через <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A> пользовательское расширение разметки имеет доступ к контексту службы, который сообщает среде, где расширение разметки вызывается обработчиком XAML.</span><span class="sxs-lookup"><span data-stu-id="95468-148">Through <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>, a custom markup extension has access to a service context that reports the environment where the markup extension is invoked by a XAML processor.</span></span> <span data-ttu-id="95468-149">В пути загрузки это обычно <xref:System.Xaml.XamlObjectWriter> .</span><span class="sxs-lookup"><span data-stu-id="95468-149">In the load path, this is typically a <xref:System.Xaml.XamlObjectWriter>.</span></span> <span data-ttu-id="95468-150">В пути сохранения это обычно <xref:System.Xaml.XamlXmlWriter>.</span><span class="sxs-lookup"><span data-stu-id="95468-150">In the save path this is typically a <xref:System.Xaml.XamlXmlWriter>.</span></span> <span data-ttu-id="95468-151">Контекст службы передается как внутренний класс контекста поставщика службы XAML, реализующий шаблон поставщика службы.</span><span class="sxs-lookup"><span data-stu-id="95468-151">Each report the service context as an internal XAML service provider context class that implements a service provider pattern.</span></span> <span data-ttu-id="95468-152">Дополнительные сведения о доступных службах и о том, что они представляют, см. в разделе [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="95468-152">For more information about the available services and what they represent, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

<span data-ttu-id="95468-153">Класс расширения разметки должен использовать уровень общего доступа. Обработчики XAML всегда должны иметь возможность создать экземпляр класса поддержки расширения разметки для использования служб.</span><span class="sxs-lookup"><span data-stu-id="95468-153">Your markup extension class must use a public access level; XAML processors must always be able to instantiate the markup extension's support class in order to use its services.</span></span>

## <a name="defining-the-support-type-for-a-custom-markup-extension"></a><span data-ttu-id="95468-154">Определение типа поддержки для пользовательского расширения разметки</span><span class="sxs-lookup"><span data-stu-id="95468-154">Defining the Support Type for a Custom Markup Extension</span></span>

<span data-ttu-id="95468-155">При использовании служб XAML .NET или платформ, построенных на службах XAML .NET, существует два способа именования типа поддержки расширения разметки.</span><span class="sxs-lookup"><span data-stu-id="95468-155">When you use .NET XAML Services or frameworks that build on .NET XAML Services, you have two choices for how to name the markup extension support type.</span></span> <span data-ttu-id="95468-156">Имя типа соответствует тому, как средства записи объектов XAML пытаются получить доступ к типу поддержки расширения разметки и вызвать его при обнаружении использования расширения разметки в XAML.</span><span class="sxs-lookup"><span data-stu-id="95468-156">The type name is relevant to how XAML object writers attempt to access and invoke a markup extension support type when they encounter a markup extension usage in XAML.</span></span> <span data-ttu-id="95468-157">Используйте одну из следующих стратегий именования.</span><span class="sxs-lookup"><span data-stu-id="95468-157">Use one of the following naming strategies:</span></span>

- <span data-ttu-id="95468-158">Имя типа должно точно соответствовать маркеру использования разметки XAML.</span><span class="sxs-lookup"><span data-stu-id="95468-158">Name the type name to be an exact match to the XAML markup usage token.</span></span> <span data-ttu-id="95468-159">Например, для поддержки использование расширения `{Collate ...}` , назовите тип поддержки `Collate`.</span><span class="sxs-lookup"><span data-stu-id="95468-159">For example, to support a `{Collate ...}` extension usage, name the support type `Collate`.</span></span>
- <span data-ttu-id="95468-160">Имя типа должно состоять из маркера строки использования и суффикса `Extension`.</span><span class="sxs-lookup"><span data-stu-id="95468-160">Name the type name to be the usage string token plus the suffix `Extension`.</span></span> <span data-ttu-id="95468-161">Например, для поддержки использование расширения `{Collate ...}` , назовите тип поддержки `CollateExtension`.</span><span class="sxs-lookup"><span data-stu-id="95468-161">For example, to support a `{Collate ...}` extension usage, name the support type `CollateExtension`.</span></span>

<span data-ttu-id="95468-162">Порядок поиска следующий: выполняется поиск имени класса с суффиксом `Extension`, а затем имени класса без суффикса `Extension` .</span><span class="sxs-lookup"><span data-stu-id="95468-162">The order of lookup is to look for the `Extension`-suffixed class name first and then look for the class name without the `Extension` suffix.</span></span>

<span data-ttu-id="95468-163">С точки зрения использования разметки включение суффикса `Extension` как части использования допустимо.</span><span class="sxs-lookup"><span data-stu-id="95468-163">From the markup usage perspective, including the `Extension` suffix as part of the usage is valid.</span></span> <span data-ttu-id="95468-164">Тем не менее, это аналогично тому, что `Extension` действительно является частью имени класса, и средства записи объектов XAML не могут разрешить класс поддержки расширения разметки для такого использования, если класс поддержки не содержит суффикс `Extension` .</span><span class="sxs-lookup"><span data-stu-id="95468-164">However, this behaves as if `Extension` is truly part of the class name, and XAML object writers would fail to resolve a markup extension support class for that usage if the support class did not have the `Extension` suffix.</span></span>

### <a name="the-parameterless-constructor"></a><span data-ttu-id="95468-165">Конструктор без параметров</span><span class="sxs-lookup"><span data-stu-id="95468-165">The parameterless constructor</span></span>

<span data-ttu-id="95468-166">Для всех типов поддержки расширения разметки необходимо предоставить открытый конструктор без параметров.</span><span class="sxs-lookup"><span data-stu-id="95468-166">For all markup extension support types, you should expose a public parameterless constructor.</span></span> <span data-ttu-id="95468-167">Конструктор без параметров необходим для любого случая, когда средство записи объектов XAML создает экземпляр расширения разметки на основе использования объектного элемента.</span><span class="sxs-lookup"><span data-stu-id="95468-167">A parameterless constructor is required for any case where a XAML object writer instantiates the markup extension from an object element usage.</span></span> <span data-ttu-id="95468-168">Поддержка использования элемента объекта — это адекватное предположение для расширения разметки, особенно для сериализации.</span><span class="sxs-lookup"><span data-stu-id="95468-168">Supporting object element usage is a fair expectation for a markup extension, particularly for serialization.</span></span> <span data-ttu-id="95468-169">Однако если планируется поддержка только использования атрибутов расширения разметки, можно реализовать расширение разметки без открытого конструктора.</span><span class="sxs-lookup"><span data-stu-id="95468-169">However, you can implement a markup extension without a public constructor if you only intend to support attribute usages of the markup extension.</span></span>

<span data-ttu-id="95468-170">Если использование расширения разметки не имеет аргументов, конструктор без параметров необходим для поддержки использования.</span><span class="sxs-lookup"><span data-stu-id="95468-170">If your markup extension usage has no arguments, the parameterless constructor is required to support usage.</span></span>

## <a name="constructor-patterns-and-positional-arguments-for-a-custom-markup-extension"></a><span data-ttu-id="95468-171">Шаблоны конструктора и позиционные аргументы для пользовательского расширения разметки</span><span class="sxs-lookup"><span data-stu-id="95468-171">Constructor Patterns and Positional Arguments for a Custom Markup Extension</span></span>

<span data-ttu-id="95468-172">Для расширения разметки с предполагаемым использованием аргументов открытые конструкторы должны соответствовать режимам предполагаемого использования.</span><span class="sxs-lookup"><span data-stu-id="95468-172">For a markup extension with intended argument usage, the public constructors must correspond to the modes of the intended usage.</span></span> <span data-ttu-id="95468-173">Другими словами, если расширение разметки предполагает один позиционный аргумент для допустимого использования, необходимо поддерживать открытый конструктор с одним входным параметром, который принимает позиционный аргумент.</span><span class="sxs-lookup"><span data-stu-id="95468-173">In other words, if your markup extension is designed to require one positional argument as a valid usage, you should support a public constructor with one input parameter that takes the positional argument.</span></span>

<span data-ttu-id="95468-174">Например, предположим, что расширение разметки `Collate` предназначено только для поддержки режима с одним позиционным аргументом, представляющий этот режим, который задан как константа перечисления `CollationMode` .</span><span class="sxs-lookup"><span data-stu-id="95468-174">For example, suppose the `Collate` markup extension is intended to support only a mode where there is one positional argument that represents its mode, specified as a `CollationMode` enumeration constant.</span></span> <span data-ttu-id="95468-175">В этом случае должен быть конструктор следующего вида:</span><span class="sxs-lookup"><span data-stu-id="95468-175">In this case, there should be a constructor with the following form:</span></span>

```csharp
public Collate(CollationMode collationMode) {...}
```

<span data-ttu-id="95468-176">На базовом уровне аргументы, переданные расширению разметки — это строки, так как они перенаправляются из значений атрибутов разметки.</span><span class="sxs-lookup"><span data-stu-id="95468-176">At a basic level, the arguments passed to a markup extension are a string because they are being forwarded from the markup's attribute values.</span></span> <span data-ttu-id="95468-177">Можно сделать все аргументы строковыми и работать с входными данными на этом уровне.</span><span class="sxs-lookup"><span data-stu-id="95468-177">You can make all of your arguments strings and work with input at that level.</span></span> <span data-ttu-id="95468-178">Тем не менее, у вас есть доступ к определенной обработке, выполняемой до передачи аргументов расширения разметки классу поддержки.</span><span class="sxs-lookup"><span data-stu-id="95468-178">However, you do have access to certain processing that occurs before the markup extension arguments are passed to the support class.</span></span>

<span data-ttu-id="95468-179">Концептуально обработка выполняется так, будто расширение разметки объект — это объект, который должен быть создан, а затем задаются значения его членов.</span><span class="sxs-lookup"><span data-stu-id="95468-179">The processing works conceptually as if the markup extension is an object to be created, and then its member values are set.</span></span> <span data-ttu-id="95468-180">Каждое указанное свойство, которое необходимо установить, оценивается аналогично тому, как указанный элемент может быть задан для созданного объекта при анализе XAML.</span><span class="sxs-lookup"><span data-stu-id="95468-180">Each specified property to set is evaluated similar to how a specified member can be set on a created object when XAML is parsed.</span></span> <span data-ttu-id="95468-181">Однако имеется два важных отличия.</span><span class="sxs-lookup"><span data-stu-id="95468-181">There are two important differences:</span></span>

- <span data-ttu-id="95468-182">Как отмечалось ранее, тип поддержки расширения разметки не обязательно должен иметь конструктор без параметров для создания экземпляра в XAML.</span><span class="sxs-lookup"><span data-stu-id="95468-182">As noted previously, a markup extension support type does not need to have a parameterless constructor in order to be instantiated in XAML.</span></span> <span data-ttu-id="95468-183">Создание соответствующего объекта откладывается, пока его возможные аргументы в текстовом синтаксисе не преобразуются в маркеры как позиционные или именованные аргументы, а в это время вызывается соответствующий конструктор.</span><span class="sxs-lookup"><span data-stu-id="95468-183">Its object construction is deferred until its possible arguments in the text syntax are tokenized and evaluated as either positional or named arguments, and the appropriate constructor is called at that time.</span></span>
- <span data-ttu-id="95468-184">Использования расширения разметки могут быть вложенными.</span><span class="sxs-lookup"><span data-stu-id="95468-184">Markup extensions usages can be nested.</span></span> <span data-ttu-id="95468-185">Сначала вычисляется внутреннее расширение разметки.</span><span class="sxs-lookup"><span data-stu-id="95468-185">The innermost markup extension is evaluated first.</span></span> <span data-ttu-id="95468-186">Поэтому можно предположить такое использование и объявить один из параметров создания как тип, для создания которого требуется преобразователь значений (например, расширение разметки).</span><span class="sxs-lookup"><span data-stu-id="95468-186">Therefore, you can assume such a usage and declare one of the construction parameters to be a type that requires a value converter (such as a markup extension) to produce.</span></span>

<span data-ttu-id="95468-187">Использование такой обработки было показано в предыдущем примере.</span><span class="sxs-lookup"><span data-stu-id="95468-187">A reliance on such processing was shown in the previous example.</span></span> <span data-ttu-id="95468-188">Средство записи объектов XAML служб XAML .NET обрабатывает имена констант перечисления в перечисляемых значениях на собственном уровне.</span><span class="sxs-lookup"><span data-stu-id="95468-188">.NET XAML Services XAML object writer processes enumeration constant names into enumerated values at a native level.</span></span>

<span data-ttu-id="95468-189">Обработка текстового синтаксиса позиционного параметра расширения разметки также может использовать преобразователь типов, связанный с типом в аргументе конструктора.</span><span class="sxs-lookup"><span data-stu-id="95468-189">Processing text syntax of a markup extension positional parameter can also rely on a type converter that is associated with the type that is in the construction argument.</span></span>

<span data-ttu-id="95468-190">Аргументы называются позиционными, поскольку порядок, в котором маркеры указываются в использовании, соответствует позиции параметра конструктора, которому они назначены.</span><span class="sxs-lookup"><span data-stu-id="95468-190">The arguments are called positional arguments because the order in which the tokens in the usage is encountered corresponds to the positional order of the constructor parameter to which they are assigned.</span></span> <span data-ttu-id="95468-191">Например, рассмотрим следующую сигнатуру конструктора:</span><span class="sxs-lookup"><span data-stu-id="95468-191">For example, consider the following constructor signature:</span></span>

```csharp
public Collate(CollationMode collationMode, object collateThis) {...}
```

<span data-ttu-id="95468-192">Обработчик XAML ожидает два позиционных аргумента для данного расширения разметки.</span><span class="sxs-lookup"><span data-stu-id="95468-192">A XAML processor expects two positional arguments for this markup extension.</span></span> <span data-ttu-id="95468-193">Если применялось использование `{Collate AlphaUp,{x:Reference circularFile}}`,  маркер `AlphaUp` отправляется в первый параметр и вычисляется как именованная константа перечисления `CollationMode` .</span><span class="sxs-lookup"><span data-stu-id="95468-193">If there was a usage `{Collate AlphaUp,{x:Reference circularFile}}`, the `AlphaUp` token is sent to the first parameter and evaluated as a `CollationMode` enumeration named constant.</span></span> <span data-ttu-id="95468-194">Результат внутреннего `x:Reference` передается во второй параметр и вычисляется как объект.</span><span class="sxs-lookup"><span data-stu-id="95468-194">The result of the inner `x:Reference` is sent to the second parameter and evaluated as an object.</span></span>

<span data-ttu-id="95468-195">В указанных правилах синтаксиса расширения разметки и обработки XAML запятая — это разделитель как позиционных, так и именованных аргументов.</span><span class="sxs-lookup"><span data-stu-id="95468-195">In the XAML specified rules for markup extension syntax and processing, the comma is the delimiter between arguments, whether those arguments are positional arguments or named arguments.</span></span>

### <a name="duplicate-arity-of-positional-arguments"></a><span data-ttu-id="95468-196">Повторяющаяся арность для аргументов с заданной позицией</span><span class="sxs-lookup"><span data-stu-id="95468-196">Duplicate arity of positional arguments</span></span>

<span data-ttu-id="95468-197">Если средство записи объектов XAML обнаруживает использование расширения разметки с позиционными аргументами и существует несколько аргументов конструктора, принимающих количество аргументов (дублирующая арность), это необязательно ошибка.</span><span class="sxs-lookup"><span data-stu-id="95468-197">If a XAML object writer encounters a markup extension usage with positional arguments, and there are multiple constructor arguments that take that number of arguments (a duplicate arity), that is not necessarily an error.</span></span> <span data-ttu-id="95468-198">Поведение зависит от настраиваемого параметра контекста схемы XAML, <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A>.</span><span class="sxs-lookup"><span data-stu-id="95468-198">The behavior depends on a customizable XAML schema context setting, <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A>.</span></span> <span data-ttu-id="95468-199">Если <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A> — `true`, средство записи объектов XAML не должно создавать исключения только из-за дублирующей арности.</span><span class="sxs-lookup"><span data-stu-id="95468-199">If <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A> is `true`, a XAML object writer should not throw an exception only for reasons of duplicate arity.</span></span> <span data-ttu-id="95468-200">Последующее поведение строго не определено.</span><span class="sxs-lookup"><span data-stu-id="95468-200">Behavior beyond that point is not strictly defined.</span></span> <span data-ttu-id="95468-201">Базовое предположения проектирования состоит в том, что контекст схемы располагает информацией о типе отдельных параметров и может попытаться выполнить явные приведения, которые соответствуют дублированным кандидатам, чтобы увидеть, какая сигнатура оптимальная.</span><span class="sxs-lookup"><span data-stu-id="95468-201">The basic design assumption is that the schema context has type information available for the specific parameters and can attempt explicit casts that match the duplicate candidates to see which signature might be the best match.</span></span> <span data-ttu-id="95468-202">Исключение по-прежнему может быть вызвано, если никакие сигнатуры не могут передать тесты, используемые этим контекстом схемы, инициируемые средством записи объектов XAML.</span><span class="sxs-lookup"><span data-stu-id="95468-202">An exception might still be thrown if no signatures can pass the tests that are imposed by that particular schema context that is running on a XAML object writer.</span></span>

<span data-ttu-id="95468-203">По умолчанию <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A> находится `false` в среде CLR <xref:System.Xaml.XamlSchemaContext> для служб XAML .NET.</span><span class="sxs-lookup"><span data-stu-id="95468-203">By default, <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A> is `false` in the CLR-based <xref:System.Xaml.XamlSchemaContext> for .NET XAML Services.</span></span> <span data-ttu-id="95468-204">Поэтому <xref:System.Xaml.XamlObjectWriter> по умолчанию создает исключения, если обнаруживает использование расширения разметки с дублирующей арностью в конструкторах резервного типа.</span><span class="sxs-lookup"><span data-stu-id="95468-204">Thus, the default <xref:System.Xaml.XamlObjectWriter> throws exceptions if it encounters a markup extension usage where there is duplicate arity in the backing type's constructors.</span></span>

## <a name="named-arguments-for-a-custom-markup-extension"></a><span data-ttu-id="95468-205">Именованные аргументы для пользовательского расширения разметки</span><span class="sxs-lookup"><span data-stu-id="95468-205">Named arguments for a custom markup extension</span></span>

<span data-ttu-id="95468-206">Расширения разметки, заданные XAML, также могут использовать форму именованных аргументов.</span><span class="sxs-lookup"><span data-stu-id="95468-206">Markup extensions as specified by XAML can also use a named arguments form for usage.</span></span> <span data-ttu-id="95468-207">На первом уровне разметки текстовый синтаксис делится на аргументы.</span><span class="sxs-lookup"><span data-stu-id="95468-207">At the first level of tokenization, the text syntax is divided into arguments.</span></span> <span data-ttu-id="95468-208">Наличие знака равенства (=) в каком-либо из аргументов определяет его как именованный.</span><span class="sxs-lookup"><span data-stu-id="95468-208">The presence of an equals sign (=) within any argument identifies an argument as a named argument.</span></span> <span data-ttu-id="95468-209">Такой аргумент также размечается в виде пары имени и значения.</span><span class="sxs-lookup"><span data-stu-id="95468-209">Such an argument is also tokenized into a name/value pair.</span></span> <span data-ttu-id="95468-210">Имя в этом случае определяет открытое устанавливаемое свойство типа поддержки расширения разметки.</span><span class="sxs-lookup"><span data-stu-id="95468-210">The name in this case names a public settable property of the markup extension's support type.</span></span> <span data-ttu-id="95468-211">Если планируется поддержка использования именованных аргументов, следует предоставить эти открытые устанавливаемые свойства.</span><span class="sxs-lookup"><span data-stu-id="95468-211">If you intend to support named argument usage, you should provide these public settable properties.</span></span> <span data-ttu-id="95468-212">Свойства могут быть наследуемыми, пока они открытые.</span><span class="sxs-lookup"><span data-stu-id="95468-212">The properties can be inherited properties as long as they remain public.</span></span>

## <a name="accessing-service-provider-context-from-a-markup-extension-implementation"></a><span data-ttu-id="95468-213">Доступ к контексту поставщика службы из реализации расширения разметки</span><span class="sxs-lookup"><span data-stu-id="95468-213">Accessing Service Provider Context from a Markup Extension Implementation</span></span>

<span data-ttu-id="95468-214">Доступные службы одинаковы для всех преобразователей значений.</span><span class="sxs-lookup"><span data-stu-id="95468-214">The services available are the same for any value converter.</span></span> <span data-ttu-id="95468-215">Разница заключается в том, как преобразователь значения получает контекст службы.</span><span class="sxs-lookup"><span data-stu-id="95468-215">The difference is in how each value converter receives the service context.</span></span> <span data-ttu-id="95468-216">Доступ к службам и предоставляемые службы описаны в разделе [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="95468-216">Accessing services and the services available are documented in the topic [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

## <a name="property-element-usage-of-a-markup-extension"></a><span data-ttu-id="95468-217">Использование элемента свойства для расширения разметки</span><span class="sxs-lookup"><span data-stu-id="95468-217">Property element usage of a markup extension</span></span>

<span data-ttu-id="95468-218">Сценарии использования расширения разметки часто разрабатываются на основе применения расширения разметки в использовании атрибутов.</span><span class="sxs-lookup"><span data-stu-id="95468-218">The scenarios for markup extension usages are often designed around using the markup extension in attribute usage.</span></span> <span data-ttu-id="95468-219">Однако также существует возможность определить резервный класс для поддержки использования элемента свойства.</span><span class="sxs-lookup"><span data-stu-id="95468-219">However, it is also potentially possible to define the backing class to support property element usage.</span></span>

<span data-ttu-id="95468-220">Для поддержки использования элемента свойства в расширении разметки Определите открытый конструктор без параметров.</span><span class="sxs-lookup"><span data-stu-id="95468-220">To support property element usage of your markup extension, define a public parameterless constructor.</span></span> <span data-ttu-id="95468-221">Это должен быть конструктор экземпляра, а не статический конструктор.</span><span class="sxs-lookup"><span data-stu-id="95468-221">This should be an instance constructor not a static constructor.</span></span> <span data-ttu-id="95468-222">Это необходимо, поскольку обработчик XAML должен обычно вызывать конструктор без параметров для любого элемента объекта, который он обрабатывает из разметки, а сюда входят классы расширения разметки как элементы объекта.</span><span class="sxs-lookup"><span data-stu-id="95468-222">This is required because a XAML processor must generally invoke the parameterless constructor on any object element it processes from markup, and this includes markup extension classes as object elements.</span></span> <span data-ttu-id="95468-223">Для более сложных сценариев можно определить нестандартные пути создания для классов.</span><span class="sxs-lookup"><span data-stu-id="95468-223">For advanced scenarios, you can define non-default construction paths for classes.</span></span> <span data-ttu-id="95468-224">(Дополнительные сведения см. в разделе [Директива x:FactoryMethod](xfactorymethod-directive.md).) Однако не следует использовать эти шаблоны для расширения разметки, так как это значительно усложняет обнаружение шаблона использования для конструкторов и для пользователей необработанной разметки.</span><span class="sxs-lookup"><span data-stu-id="95468-224">(For more information, see [x:FactoryMethod Directive](xfactorymethod-directive.md).) However, you should not use these patterns for markup extension purposes because this makes discovery of the usage pattern much more difficult, both for designers and for users of raw markup.</span></span>

## <a name="attributing-for-a-custom-markup-extension"></a><span data-ttu-id="95468-225">Присвоение атрибутов пользовательскому расширению разметки</span><span class="sxs-lookup"><span data-stu-id="95468-225">Attributing for a custom markup extension</span></span>

<span data-ttu-id="95468-226">Для поддержки сред разработки и определенных сценариев средства записи объектов XAML необходимо пометить тип поддержки расширения разметки несколькими атрибутами среды CLR.</span><span class="sxs-lookup"><span data-stu-id="95468-226">To support both design environments and certain XAML object writer scenarios, you should attribute a markup extension support type with several CLR attributes.</span></span> <span data-ttu-id="95468-227">Они сообщают предполагаемое использование расширения разметки.</span><span class="sxs-lookup"><span data-stu-id="95468-227">These attributes report the intended markup extension usage.</span></span>

 <span data-ttu-id="95468-228"><xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute> предоставляет информацию о <xref:System.Type> для типа объекта, который возвращает <xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A> .</span><span class="sxs-lookup"><span data-stu-id="95468-228"><xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute> reports the <xref:System.Type> information for the object type that <xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A> returns.</span></span> <span data-ttu-id="95468-229">По чистой сигнатуре <xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A> возвращает <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="95468-229">By its pure signature, <xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A> returns <xref:System.Object>.</span></span> <span data-ttu-id="95468-230">Но различным пользователям может потребоваться более точная информация о типе возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="95468-230">But various consumers might want more precise return type information.</span></span> <span data-ttu-id="95468-231">В том числе:</span><span class="sxs-lookup"><span data-stu-id="95468-231">This includes:</span></span>

- <span data-ttu-id="95468-232">Конструкторы и среды разработки, которые могут предоставлять поддержку с учетом типа для использования расширения разметки.</span><span class="sxs-lookup"><span data-stu-id="95468-232">Designers and IDEs, who might be able to provide type-aware support for markup extension usages.</span></span>
- <span data-ttu-id="95468-233">Расширенные реализации обработчиков `SetMarkupExtension` в целевых классах, которые могут применять отражение для определения возвращаемого типа расширения разметки вместо ветвления на конкретных известных реализациях <xref:System.Windows.Markup.MarkupExtension> по имени.</span><span class="sxs-lookup"><span data-stu-id="95468-233">Advanced implementations of `SetMarkupExtension` handlers on target classes, which might rely on reflection to determine a markup extension's return type instead of branching on specific known <xref:System.Windows.Markup.MarkupExtension> implementations by name.</span></span>

## <a name="serialization-of-markup-extension-usages"></a><span data-ttu-id="95468-234">Сериализация использования расширения разметки</span><span class="sxs-lookup"><span data-stu-id="95468-234">Serialization of markup extension usages</span></span>

<span data-ttu-id="95468-235">Когда средство записи объектов XAML обрабатывает использование расширения разметки и вызывает метод <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>, контекст о том, что ранее оно было использованием расширения разметки, сохраняется в потоке узлов XAML, но не в графе объектов.</span><span class="sxs-lookup"><span data-stu-id="95468-235">When a XAML object writer processes a markup extension usage and calls <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>, the context for it previously being a markup extension usage persists in the XAML node stream but not in the object graph.</span></span> <span data-ttu-id="95468-236">В графе объектов сохраняется только значение.</span><span class="sxs-lookup"><span data-stu-id="95468-236">In the object graph, only the value is preserved.</span></span> <span data-ttu-id="95468-237">Если существуют сценарии разработки или другие причины для сохранения исходного использования расширения разметки в сериализованных выходных данных, необходимо создать собственную инфраструктуру для отслеживания использования расширения разметки из потока узлов XAML пути загрузки.</span><span class="sxs-lookup"><span data-stu-id="95468-237">If you have design scenarios or other reasons for persisting the original markup extension usage into the serialized output, you must design your own infrastructure for tracking the markup extension usages from the load path XAML node stream.</span></span> <span data-ttu-id="95468-238">Можно реализовать поведение, чтобы воссоздать элементы потока узлов из пути загрузки и воспроизвести их в средствах записи XAML для сериализации в пути сохранения, заменив значение в соответствующей позиции потока узлов.</span><span class="sxs-lookup"><span data-stu-id="95468-238">You can implement behavior to recreate the elements of the node stream from the load path and play them back to XAML writers for serialization in the save path, substituting for the value in the appropriate position of the node stream.</span></span>

## <a name="markup-extensions-in-the-xaml-node-stream"></a><span data-ttu-id="95468-239">Расширения разметки в потоке узлов XAML</span><span class="sxs-lookup"><span data-stu-id="95468-239">Markup extensions in the XAML node stream</span></span>

<span data-ttu-id="95468-240">При работе с потоком узлов XAML в пути загрузки использование расширения разметки отображается в потоке узлов как объект.</span><span class="sxs-lookup"><span data-stu-id="95468-240">If you are working with a XAML node stream on the load path, a markup extension usage appears in the node stream as an object.</span></span>

<span data-ttu-id="95468-241">Если использование расширения разметки применяет позиционные аргументы, оно представляется как начальный объект со значением инициализации.</span><span class="sxs-lookup"><span data-stu-id="95468-241">If the markup extension usage uses positional arguments, it is represented as a start object with an initialization value.</span></span> <span data-ttu-id="95468-242">В приблизительном текстовом представление поток узлов имеет следующий вид:</span><span class="sxs-lookup"><span data-stu-id="95468-242">As a rough text representation, the node stream resembles the following:</span></span>

<span data-ttu-id="95468-243">`StartObject` (<xref:System.Xaml.XamlType> — это тип определения расширения разметки, а не возвращаемый тип)</span><span class="sxs-lookup"><span data-stu-id="95468-243">`StartObject` (<xref:System.Xaml.XamlType> is the markup extension's definition type, not its return type)</span></span>

<span data-ttu-id="95468-244">`StartMember` (имя <xref:System.Xaml.XamlMember> — `_InitializationText`)</span><span class="sxs-lookup"><span data-stu-id="95468-244">`StartMember` (name of the <xref:System.Xaml.XamlMember> is `_InitializationText`)</span></span>

<span data-ttu-id="95468-245">`Value` (значение — это позиционные аргументы в виде строки, включая используемые разделители)</span><span class="sxs-lookup"><span data-stu-id="95468-245">`Value` (value is the positional arguments as a string including the intervening delimiters)</span></span>

`EndMember`

`EndObject`

<span data-ttu-id="95468-246">Использование расширения разметки с именованными аргументами представлено в качестве объекта с членами с соответствующими именами, для каждого из которых заданы значения в виде текстовых строк.</span><span class="sxs-lookup"><span data-stu-id="95468-246">A markup extension usage with named arguments is represented as an object with members of the relevant names, each set with text string values.</span></span>

<span data-ttu-id="95468-247">Фактически для вызова реализации `ProvideValue` расширения разметки требуется контекст схемы XAML, так как для этого необходимо сопоставление типов и создание экземпляра типа поддержки расширения разметки.</span><span class="sxs-lookup"><span data-stu-id="95468-247">Actually invoking the `ProvideValue` implementation of a markup extension requires the XAML schema context because that requires type-mapping and creating a markup extension support type instance.</span></span> <span data-ttu-id="95468-248">Это одна из причин того, почему использование расширения разметки сохраняется таким образом в потоках узлов служб XAML .NET по умолчанию. в части пути загрузки часто не предусмотрен необходимый контекст схемы XAML.</span><span class="sxs-lookup"><span data-stu-id="95468-248">This is one reason why markup extension usages are preserved this way in the default .NET XAML Services node streams -  the reader part of a load path often does not have the necessary XAML schema context available.</span></span>

<span data-ttu-id="95468-249">При работе с потоком узлов XAML в пути сохранении, как правило, ничего не в представлении графа объектов нет ничего, что могло бы сообщить, что сериализуемый объект был изначально предоставлен использованием расширения разметки и результатом `ProvideValue` .</span><span class="sxs-lookup"><span data-stu-id="95468-249">If you are working with a XAML node stream on the save path, there generally is nothing present in an object graph representation that can inform you that the object to serialize was originally provided by a markup extension usage and a `ProvideValue` result.</span></span> <span data-ttu-id="95468-250">В сценариях, требующих сохранения использования расширения разметки для циклической обработки и сохранении других изменений графа объектов, необходимо создать собственные методы сохранения информации об использовании расширения разметки из исходных входных данных XAML.</span><span class="sxs-lookup"><span data-stu-id="95468-250">Scenarios that need to persist markup extension usages for round-tripping while also capturing other changes in the object graph must devise their own techniques for preserving the knowledge of a markup extension usage from the original XAML input.</span></span> <span data-ttu-id="95468-251">Например, чтобы восстановить использования расширения разметки, может потребоваться поработать с потоком узлов в пути сохранении для восстановления использований расширения разметки или выполнить своего рода слияние исходного XAML и XAML обхода.</span><span class="sxs-lookup"><span data-stu-id="95468-251">For example, to restore the markup extension usages, you may need to work with the node stream on the save path in order to restore markup extension usages, or perform some type of merge between the original XAML and the round-tripped XAML.</span></span> <span data-ttu-id="95468-252">Некоторые платформы c реализацией XAML , например WPF, используют промежуточные типы (выражения) для представления случаев, где использования расширения разметки передают значения.</span><span class="sxs-lookup"><span data-stu-id="95468-252">Some XAML-implementing frameworks such as WPF use intermediate types (expressions) to help represent cases where markup extension usages provided the values.</span></span>

## <a name="see-also"></a><span data-ttu-id="95468-253">См. также</span><span class="sxs-lookup"><span data-stu-id="95468-253">See also</span></span>

- <xref:System.Windows.Markup.MarkupExtension>
- [<span data-ttu-id="95468-254">Преобразователи типов или расширения разметки для XAML</span><span class="sxs-lookup"><span data-stu-id="95468-254">Type Converters and Markup Extensions for XAML</span></span>](type-converters-and-markup-extensions.md)
- [<span data-ttu-id="95468-255">Расширения разметки и XAML WPF</span><span class="sxs-lookup"><span data-stu-id="95468-255">Markup Extensions and WPF XAML</span></span>](/dotnet/desktop/wpf/advanced/markup-extensions-and-wpf-xaml)
