---
title: Определение пользовательских типов для использования со службами XAML .NET
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: ff7e4229450e801a6d618c5141efde8cdcbef03d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "81433076"
---
# <a name="define-custom-types-for-use-with-net-xaml-services"></a><span data-ttu-id="f64e7-102">Определите пользовательские типы для использования с помощью служб .NET XAML</span><span class="sxs-lookup"><span data-stu-id="f64e7-102">Define custom types for use with .NET XAML Services</span></span>

<span data-ttu-id="f64e7-103">При определении типов пользовательских, которые являются бизнес-объектами или типами, не зависят от определенных фребов, существуют некоторые рекомендации для XAML, которым вы можете следовать.</span><span class="sxs-lookup"><span data-stu-id="f64e7-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="f64e7-104">Если вы будете следовать этим практикам, .NET XAML Services и его xAML читатели и xAML писатели могут обнаружить xAML характеристики вашего типа и дать ему соответствующее представление в потоке узлов XAML с помощью системы типа XAML.</span><span class="sxs-lookup"><span data-stu-id="f64e7-104">If you follow these practices, .NET XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="f64e7-105">Эта тема описывает наилучшую практику для определений типов, определений членов и CLR, приписывающих типы или члены.</span><span class="sxs-lookup"><span data-stu-id="f64e7-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>

## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="f64e7-106">Шаблоны конструкторов и определения типов для XAML</span><span class="sxs-lookup"><span data-stu-id="f64e7-106">Constructor Patterns and Type Definitions for XAML</span></span>

<span data-ttu-id="f64e7-107">Чтобы быть мгновенно настроенным в качестве элемента объекта в XAML, пользовательский класс должен соответствовать следующим требованиям:</span><span class="sxs-lookup"><span data-stu-id="f64e7-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>

- <span data-ttu-id="f64e7-108">Пользовательский класс должен быть общедоступным и должен подвергать безпаративному общественному конструктору.</span><span class="sxs-lookup"><span data-stu-id="f64e7-108">The custom class must be public and must expose a parameterless public constructor.</span></span> <span data-ttu-id="f64e7-109">(Примечания о структурах см. в следующем разделе.)</span><span class="sxs-lookup"><span data-stu-id="f64e7-109">(See following section for notes regarding structures.)</span></span>

- <span data-ttu-id="f64e7-110">Пользовательский класс не должен быть вложенным классом.</span><span class="sxs-lookup"><span data-stu-id="f64e7-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="f64e7-111">Дополнительная "точка" в полноименном пути делает разделение пространства класса неоднозначным и мешает другим функциям XAML, таким как прилагаемые свойства.</span><span class="sxs-lookup"><span data-stu-id="f64e7-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>
<span data-ttu-id="f64e7-112">Если объект может быть мгновенно элемент объекта, созданный объект может заполнить форму элемента свойства любых свойств, которые принимают объект в качестве основного типа.</span><span class="sxs-lookup"><span data-stu-id="f64e7-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>

<span data-ttu-id="f64e7-113">Вы все еще можете предоставить значения объектов для типов, которые не отвечают этим критериям, если вы включите преобразователь значения.</span><span class="sxs-lookup"><span data-stu-id="f64e7-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="f64e7-114">Для получения дополнительной [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md)информации см.</span><span class="sxs-lookup"><span data-stu-id="f64e7-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

### <a name="structures"></a><span data-ttu-id="f64e7-115">Структуры</span><span class="sxs-lookup"><span data-stu-id="f64e7-115">Structures</span></span>

<span data-ttu-id="f64e7-116">Структуры всегда могут быть построены в XAML, по определению CLR.</span><span class="sxs-lookup"><span data-stu-id="f64e7-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="f64e7-117">Это происходит потому, что компилятор CLR неявно создает беспараметрыный конструктор для структуры.</span><span class="sxs-lookup"><span data-stu-id="f64e7-117">This is because a CLR compiler implicitly creates a parameterless constructor for a structure.</span></span> <span data-ttu-id="f64e7-118">Этот конструктор инициализирует все значения свойств для своих по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f64e7-118">This constructor initializes all property values to their defaults.</span></span>

<span data-ttu-id="f64e7-119">В некоторых случаях поведение конструкции по умолчанию для структуры нежелательно.</span><span class="sxs-lookup"><span data-stu-id="f64e7-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="f64e7-120">Это может быть связано с тем, что структура предназначена для заполнения значений и концептуально функционировать как союз.</span><span class="sxs-lookup"><span data-stu-id="f64e7-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="f64e7-121">Как союз, содержащиеся ценности могут иметь взаимоисключающие толкования, и, следовательно, ни одно из его свойств не являются установленными.</span><span class="sxs-lookup"><span data-stu-id="f64e7-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="f64e7-122">Примером такой структуры в лексиконе WPF <xref:System.Windows.GridLength>является .</span><span class="sxs-lookup"><span data-stu-id="f64e7-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="f64e7-123">Такие структуры должны реализовывать преобразователь типа, чтобы значения могли быть выражены в форме атрибута, используя строковые конвенции, которые создают различные интерпретации или режимы значений структуры.</span><span class="sxs-lookup"><span data-stu-id="f64e7-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="f64e7-124">Структура должна также подвергать аналогичное поведение для построения кода через непараметрбезный конструктор.</span><span class="sxs-lookup"><span data-stu-id="f64e7-124">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>

### <a name="interfaces"></a><span data-ttu-id="f64e7-125">интерфейсов,</span><span class="sxs-lookup"><span data-stu-id="f64e7-125">Interfaces</span></span>

<span data-ttu-id="f64e7-126">Интерфейсы могут использоваться в качестве базовых типов элементов.</span><span class="sxs-lookup"><span data-stu-id="f64e7-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="f64e7-127">Система типа XAML проверяет список назначенных и ожидает, что объект, который предоставляется в качестве значения, может быть назначен интерфейсу.</span><span class="sxs-lookup"><span data-stu-id="f64e7-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="f64e7-128">Нет понятия о том, как интерфейс должен быть представлен в виде типа XAML до тех пор, пока соответствующий присваиваемый тип поддерживает требования к конструкции XAML.</span><span class="sxs-lookup"><span data-stu-id="f64e7-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>

### <a name="factory-methods"></a><span data-ttu-id="f64e7-129">Методы фабрики</span><span class="sxs-lookup"><span data-stu-id="f64e7-129">Factory Methods</span></span>

<span data-ttu-id="f64e7-130">Методы завода являются функцией XAML 2009.</span><span class="sxs-lookup"><span data-stu-id="f64e7-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="f64e7-131">Они изменяют принцип XAML, согласно которому объекты должны иметь беспараметрыные конструкторы.</span><span class="sxs-lookup"><span data-stu-id="f64e7-131">They modify the XAML principle that objects must have parameterless constructors.</span></span> <span data-ttu-id="f64e7-132">Методы завода не задокументированы в этой статье.</span><span class="sxs-lookup"><span data-stu-id="f64e7-132">Factory methods are not documented in this article.</span></span> <span data-ttu-id="f64e7-133">[См.:Директива FactoryMethod.](xfactorymethod-directive.md)</span><span class="sxs-lookup"><span data-stu-id="f64e7-133">See [x:FactoryMethod Directive](xfactorymethod-directive.md).</span></span>

## <a name="enumerations"></a><span data-ttu-id="f64e7-134">Перечисления</span><span class="sxs-lookup"><span data-stu-id="f64e7-134">Enumerations</span></span>

<span data-ttu-id="f64e7-135">Перечисления имеют поведение преобразования родного типа XAML.</span><span class="sxs-lookup"><span data-stu-id="f64e7-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="f64e7-136">Постоянные имена, указанные в XAML, разрешаются с базовым типом перечисления и возвращают значение перечисления писателю объекта XAML.</span><span class="sxs-lookup"><span data-stu-id="f64e7-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>

<span data-ttu-id="f64e7-137">XAML поддерживает использование флагов в стиле для <xref:System.FlagsAttribute> перечислений с прикладом.</span><span class="sxs-lookup"><span data-stu-id="f64e7-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="f64e7-138">Для получения дополнительной информации, см [XAML Syntax Подробно](../../framework/wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="f64e7-138">For more information, see [XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="f64e7-139">([XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md) написандля для аудитории WPF, но большая часть информации в этой теме актуальна для XAML, которая не специфична для конкретной платформы реализации.)</span><span class="sxs-lookup"><span data-stu-id="f64e7-139">([XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>

## <a name="member-definitions"></a><span data-ttu-id="f64e7-140">Определения участников</span><span class="sxs-lookup"><span data-stu-id="f64e7-140">Member Definitions</span></span>

<span data-ttu-id="f64e7-141">Типы могут определять члены для использования XAML.</span><span class="sxs-lookup"><span data-stu-id="f64e7-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="f64e7-142">Типы могут определять члены, пригодные для xAML, даже если этот конкретный тип не используется xAML.</span><span class="sxs-lookup"><span data-stu-id="f64e7-142">It's possible for types to define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="f64e7-143">Это возможно из-за наследования CLR.</span><span class="sxs-lookup"><span data-stu-id="f64e7-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="f64e7-144">До тех пор, пока некоторый тип, который наследует член поддерживает использование XAML как тип, и член поддерживает использование XAML для своего базового типа или имеет родной синтаксис XAML, этот член является XAML-использовать.</span><span class="sxs-lookup"><span data-stu-id="f64e7-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>

### <a name="properties"></a><span data-ttu-id="f64e7-145">Свойства</span><span class="sxs-lookup"><span data-stu-id="f64e7-145">Properties</span></span>

<span data-ttu-id="f64e7-146">Если вы определяете свойства как публичное свойство CLR, используя типичные шаблоны CLR `get` и `set` accessor и соответствующие языку ключевые слова, система типа XAML может сообщить о собственности как члене с соответствующей информацией, предоставленной для <xref:System.Xaml.XamlMember> свойств, таких как <xref:System.Xaml.XamlMember.IsReadPublic%2A> и <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="f64e7-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>

<span data-ttu-id="f64e7-147">Специфические свойства могут включить синтаксис текста, применяя. <xref:System.ComponentModel.TypeConverterAttribute></span><span class="sxs-lookup"><span data-stu-id="f64e7-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="f64e7-148">Для получения дополнительной [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md)информации см.</span><span class="sxs-lookup"><span data-stu-id="f64e7-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

<span data-ttu-id="f64e7-149">При отсутствии синтаксиса текста или родного преобразования XAML и при отсутствии дальнейшего косвенного направления,<xref:System.Xaml.XamlMember.TargetType%2A> например использования расширения разметки, тип свойства (в системе типа XAML) должен быть в состоянии вернуть экземпляр писателю объекта XAML, рассматривая целевой тип как тип CLR.</span><span class="sxs-lookup"><span data-stu-id="f64e7-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>

<span data-ttu-id="f64e7-150">При использовании XAML 2009 расширение [x:Reference Markup](xreference-markup-extension.md) может быть использовано для предоставления значений, если предыдущие соображения не выполнены; однако это больше проблема использования, чем проблема определения типа.</span><span class="sxs-lookup"><span data-stu-id="f64e7-150">If using XAML 2009, [x:Reference Markup Extension](xreference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>

### <a name="events"></a><span data-ttu-id="f64e7-151">События</span><span class="sxs-lookup"><span data-stu-id="f64e7-151">Events</span></span>

<span data-ttu-id="f64e7-152">Если вы определяете события как общедоступное событие CLR, система типа <xref:System.Xaml.XamlMember.IsEvent%2A> XAML может сообщить о событии как о участнике как `true`о.</span><span class="sxs-lookup"><span data-stu-id="f64e7-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="f64e7-153">Обработка событий не входит в сферу возможностей .NET XAML Services; проводка оставлена на определенные рамки и реализации.</span><span class="sxs-lookup"><span data-stu-id="f64e7-153">Wiring the event handlers is not within the scope of .NET XAML Services capabilities; wiring is left to specific frameworks and implementations.</span></span>

### <a name="methods"></a><span data-ttu-id="f64e7-154">Методы</span><span class="sxs-lookup"><span data-stu-id="f64e7-154">Methods</span></span>

<span data-ttu-id="f64e7-155">Внеекодивный код для методов не является возможностью XAML по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f64e7-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="f64e7-156">В большинстве случаев вы не ссылаетесь непосредственно на участников метода xAML, и роль методов в XAML заключается только в том, чтобы обеспечить поддержку конкретных шаблонов XAML.</span><span class="sxs-lookup"><span data-stu-id="f64e7-156">In most cases, you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="f64e7-157">[x:FactoryMethod Directive](xfactorymethod-directive.md) является исключением.</span><span class="sxs-lookup"><span data-stu-id="f64e7-157">[x:FactoryMethod Directive](xfactorymethod-directive.md) is an exception.</span></span>

### <a name="fields"></a><span data-ttu-id="f64e7-158">Поля</span><span class="sxs-lookup"><span data-stu-id="f64e7-158">Fields</span></span>

<span data-ttu-id="f64e7-159">Руководящие принципы проектирования CLR препятствуют нестатическому полям.</span><span class="sxs-lookup"><span data-stu-id="f64e7-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="f64e7-160">Для статических полей доступ к значениям статических полей можно только через [x:Static Markup Extension;](xstatic-markup-extension.md) в этом случае вы не делаете ничего особенного в определении CLR, чтобы разоблачить поле для [x:Static](xstatic-markup-extension.md) обычаев.</span><span class="sxs-lookup"><span data-stu-id="f64e7-160">For static fields, you can access static field values only through [x:Static Markup Extension](xstatic-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](xstatic-markup-extension.md) usages.</span></span>

## <a name="attachable-members"></a><span data-ttu-id="f64e7-161">Присоединенные члены</span><span class="sxs-lookup"><span data-stu-id="f64e7-161">Attachable Members</span></span>

<span data-ttu-id="f64e7-162">Прикрепляемые участники подвергаются воздействию XAML через шаблон метода аксессуаров по определяющему типу.</span><span class="sxs-lookup"><span data-stu-id="f64e7-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="f64e7-163">Сам по себе определяющий тип не должен быть пригодным для XAML как объект.</span><span class="sxs-lookup"><span data-stu-id="f64e7-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="f64e7-164">На самом деле, общий шаблон заключается в объявлении класса обслуживания, роль которого заключается в том, чтобы владеть прилагаемым членом и реализовывать связанные с ними поведения, но не выполнять никаких других функций, таких как представление uI.</span><span class="sxs-lookup"><span data-stu-id="f64e7-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="f64e7-165">Для следующих разделов, заполнитель *PropertyName* представляет имя вашего прилагаемого члена.</span><span class="sxs-lookup"><span data-stu-id="f64e7-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="f64e7-166">Это имя должно быть действительным в [XamlName Грамматика](xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="f64e7-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>

<span data-ttu-id="f64e7-167">Будьте осторожны с столкновениями имен между этими шаблонами и другими методами типа.</span><span class="sxs-lookup"><span data-stu-id="f64e7-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="f64e7-168">Если член существует, что соответствует одному из шаблонов, он может быть истолкован как прилагаемый путь использования члена процессором XAML, даже если это не было вашим намерением.</span><span class="sxs-lookup"><span data-stu-id="f64e7-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>

#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="f64e7-169">GetPropertyName Аксессуар</span><span class="sxs-lookup"><span data-stu-id="f64e7-169">The GetPropertyName Accessor</span></span>

<span data-ttu-id="f64e7-170">Подпись для `GetPropertyName` аксессуара должна быть:</span><span class="sxs-lookup"><span data-stu-id="f64e7-170">The signature for the `GetPropertyName` accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="f64e7-171">Объект `target` можно указать как более конкретный тип в реализации.</span><span class="sxs-lookup"><span data-stu-id="f64e7-171">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="f64e7-172">Вы можете использовать это для сферы использования вашего прилагаемого члена; использования за пределами предполагаемой области будут бросать недействительные исключения, которые затем всплывают по ошибке разбора XAML.</span><span class="sxs-lookup"><span data-stu-id="f64e7-172">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="f64e7-173">Имя `target` параметра не является обязательным `target` требованием, но в большинстве реализаций названо конвенцией.</span><span class="sxs-lookup"><span data-stu-id="f64e7-173">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>

- <span data-ttu-id="f64e7-174">Возвращаемое значение можно указать как более конкретный тип в реализации.</span><span class="sxs-lookup"><span data-stu-id="f64e7-174">The return value can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="f64e7-175">Для поддержки синтаксиса включенного <xref:System.ComponentModel.TypeConverter> текста для <xref:System.ComponentModel.TypeConverterAttribute> использования `GetPropertyName` атрибута прилагаемого члена, обращайтесь к аксессуару.</span><span class="sxs-lookup"><span data-stu-id="f64e7-175">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `GetPropertyName` accessor.</span></span> <span data-ttu-id="f64e7-176">Применение к `get` вместо `set` может показаться неинтуитивным; однако, эта конвенция может поддержать принципиальную схему читать-только прикрепляемых членов которые serializable, который полезн в сценариях конструктора.</span><span class="sxs-lookup"><span data-stu-id="f64e7-176">Applying to the `get` instead of the `set` may seem non-intuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>

#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="f64e7-177">Аксессуар SetPropertyName</span><span class="sxs-lookup"><span data-stu-id="f64e7-177">The SetPropertyName Accessor</span></span>

<span data-ttu-id="f64e7-178">Подпись для `SetPropertyName` аксессуара должна быть:</span><span class="sxs-lookup"><span data-stu-id="f64e7-178">The signature for the `SetPropertyName` accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="f64e7-179">Объект `target` может быть указан как более конкретный тип в реализации, с той же логикой и последствиями, как описано в предыдущем разделе.</span><span class="sxs-lookup"><span data-stu-id="f64e7-179">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>

- <span data-ttu-id="f64e7-180">Объект `value` можно указать как более конкретный тип в реализации.</span><span class="sxs-lookup"><span data-stu-id="f64e7-180">The `value` object can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="f64e7-181">Помните, что значением для этого метода является вход, поступающий от использования XAML, как правило, в форме атрибута.</span><span class="sxs-lookup"><span data-stu-id="f64e7-181">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="f64e7-182">Из формы атрибута должна быть поддержка преобразователя значений `GetPropertyName`для синтаксиса текста, и вы атрибут на s accessor.</span><span class="sxs-lookup"><span data-stu-id="f64e7-182">From attribute form there must be value converter support for a text syntax, and you attribute on the `GetPropertyName`s accessor.</span></span>

### <a name="attachable-member-stores"></a><span data-ttu-id="f64e7-183">Прикрепляемые магазины-члены</span><span class="sxs-lookup"><span data-stu-id="f64e7-183">Attachable Member Stores</span></span>

<span data-ttu-id="f64e7-184">Методов доступа, как правило, недостаточно для того, чтобы поместить прикрепляемые значения элемента в график объекта или извлечь значения из графика объекта и правильно их выставить.</span><span class="sxs-lookup"><span data-stu-id="f64e7-184">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="f64e7-185">Чтобы обеспечить эту `target` функциональность, объекты в предыдущих подписях доступа должны быть способны хранить значения.</span><span class="sxs-lookup"><span data-stu-id="f64e7-185">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="f64e7-186">Механизм хранения должен соответствовать принципу прилагаемого члена, согласно которому член привязывается к целям, в которых прилагаемый член не входит в список членов.</span><span class="sxs-lookup"><span data-stu-id="f64e7-186">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="f64e7-187">.NET XAML Services предоставляет технику реализации для присоединенных магазинов-членов через AA <xref:System.Xaml.IAttachedPropertyStore> и <xref:System.Xaml.AttachablePropertyServices>.</span><span class="sxs-lookup"><span data-stu-id="f64e7-187">.NET XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="f64e7-188"><xref:System.Xaml.IAttachedPropertyStore>используется авторами XAML для обнаружения реализации хранилища и должна быть `target` реализована по типу, который является аксессуарами.</span><span class="sxs-lookup"><span data-stu-id="f64e7-188"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="f64e7-189">Статические <xref:System.Xaml.AttachablePropertyServices> AIS используются в теле аксессуаров, и относятся к <xref:System.Xaml.AttachableMemberIdentifier>прикрепляемым членом по его .</span><span class="sxs-lookup"><span data-stu-id="f64e7-189">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>

## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="f64e7-190">Атрибуты CLR, связанные с XAML</span><span class="sxs-lookup"><span data-stu-id="f64e7-190">XAML-Related CLR Attributes</span></span>

<span data-ttu-id="f64e7-191">Правильное присвоение типов, участников и сборок важно для того, чтобы сообщать информацию о системе типа XAML в службы .NET XAML Services.</span><span class="sxs-lookup"><span data-stu-id="f64e7-191">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET XAML Services.</span></span> <span data-ttu-id="f64e7-192">Информация о системе типа XAML актуальна, если в одной из следующих ситуаций применяется:</span><span class="sxs-lookup"><span data-stu-id="f64e7-192">Reporting XAML type system information is relevant if either of the following situations apply:</span></span>

- <span data-ttu-id="f64e7-193">Вы намереваетесь использовать типы с системами XAML, которые непосредственно основаны на читателях .NET XAML XAML XAML и авторах XAML.</span><span class="sxs-lookup"><span data-stu-id="f64e7-193">You intend your types for use with XAML systems that are directly based on .NET XAML Services XAML readers and XAML writers.</span></span>
- <span data-ttu-id="f64e7-194">Вы определяете или используете платформу XAML, использующее, основанную на этих читателях XAML и авторах XAML.</span><span class="sxs-lookup"><span data-stu-id="f64e7-194">You define or use a XAML-utilizing framework that's based on those XAML readers and XAML writers.</span></span>

<span data-ttu-id="f64e7-195">Для перечисления каждого атрибута, связанного с XAML, который имеет [XAML-Related CLR Attributes for Custom Types and Libraries](clr-attributes-with-custom-types-and-libraries.md)отношение к поддержке XAML ваших пользовательских типов, см.</span><span class="sxs-lookup"><span data-stu-id="f64e7-195">For a listing of each XAML-related attribute that's relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](clr-attributes-with-custom-types-and-libraries.md).</span></span>

## <a name="usage"></a><span data-ttu-id="f64e7-196">Использование</span><span class="sxs-lookup"><span data-stu-id="f64e7-196">Usage</span></span>

<span data-ttu-id="f64e7-197">Использование пользовательских типов требует, чтобы автор разметки должен наметить префикс для пространства имен сборки и CLR, которые содержат пользовательский тип.</span><span class="sxs-lookup"><span data-stu-id="f64e7-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="f64e7-198">Эта процедура не документирована в этой теме.</span><span class="sxs-lookup"><span data-stu-id="f64e7-198">This procedure is not documented in this topic.</span></span>

## <a name="access-level"></a><span data-ttu-id="f64e7-199">Уровень доступа</span><span class="sxs-lookup"><span data-stu-id="f64e7-199">Access Level</span></span>

<span data-ttu-id="f64e7-200">XAML предоставляет средства для загрузки и мгновенного `internal` типа, которые имеют уровень доступа.</span><span class="sxs-lookup"><span data-stu-id="f64e7-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="f64e7-201">Эта возможность предоставляется таким образом, что пользовательский код может определить свои собственные типы, а затем мгновенно эти классы из разметки, которая также является частью той же области кода пользователя.</span><span class="sxs-lookup"><span data-stu-id="f64e7-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>

<span data-ttu-id="f64e7-202">Примером из WPF является всякий <xref:System.Windows.Controls.UserControl> раз, когда пользовательский код определяет, который предназначен как способ рефакторинга поведения пользовательского интерфейса, но `public` не как часть любого возможного механизма расширения, который может быть подразумеваен путем объявления поддерживающего класса с уровнем доступа.</span><span class="sxs-lookup"><span data-stu-id="f64e7-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="f64e7-203">Такой <xref:System.Windows.Controls.UserControl> ам-код `internal` может быть объявлен с доступом, если резервный код компилируется в ту же сборку, из которой он упоминается как тип XAML.</span><span class="sxs-lookup"><span data-stu-id="f64e7-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>

<span data-ttu-id="f64e7-204">Для приложения, которое загружает XAML под полное доверие и использует, <xref:System.Xaml.XamlObjectWriter>загрузка классов с `internal` уровнем доступа всегда включена.</span><span class="sxs-lookup"><span data-stu-id="f64e7-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>

<span data-ttu-id="f64e7-205">Для приложения, которое загружает XAML под частичным доверием, можно управлять характеристиками уровня доступа с помощью <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span><span class="sxs-lookup"><span data-stu-id="f64e7-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="f64e7-206">Кроме того, механизмы отсрочки (такие как система шаблонов WPF) должны быть в состоянии распространять любые разрешения уровня доступа и сохранять их для оценки времени выполнения; это обрабатывается внутренне путем <xref:System.Xaml.Permissions.XamlAccessLevel> передачи информации.</span><span class="sxs-lookup"><span data-stu-id="f64e7-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>

### <a name="wpf-implementation"></a><span data-ttu-id="f64e7-207">Внедрение WPF</span><span class="sxs-lookup"><span data-stu-id="f64e7-207">WPF Implementation</span></span>

<span data-ttu-id="f64e7-208">WPF XAML использует модель частичного доверия доступа, где, если BAML <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> загружается под частичным доверием, доступ ограничен для сборки, которая является источником BAML.</span><span class="sxs-lookup"><span data-stu-id="f64e7-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="f64e7-209">Для отсрочки WPF <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> использует в качестве механизма передачи информации об уровне доступа.</span><span class="sxs-lookup"><span data-stu-id="f64e7-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>

<span data-ttu-id="f64e7-210">В терминологии WPF XAML *внутренний тип* — это тип, который определяется той же сборкой, которая также включает ссылки XAML.</span><span class="sxs-lookup"><span data-stu-id="f64e7-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="f64e7-211">Такой тип может быть отображен через пространство имен XAML, которое намеренно опускает часть сборки отображения, например, `xmlns:local="clr-namespace:WPFApplication1"`.</span><span class="sxs-lookup"><span data-stu-id="f64e7-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span> <span data-ttu-id="f64e7-212">Если BAML ссылается на внутренний `internal` тип и у `GeneratedInternalTypeHelper` него есть уровень доступа, это генерирует класс для сборки.</span><span class="sxs-lookup"><span data-stu-id="f64e7-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="f64e7-213">Если вы хотите `GeneratedInternalTypeHelper`избежать, вы `public` либо должны использовать уровень доступа, либо должны учитывать соответствующий класс в отдельную сборку и сделать эту сборку зависимой.</span><span class="sxs-lookup"><span data-stu-id="f64e7-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>

## <a name="see-also"></a><span data-ttu-id="f64e7-214">См. также</span><span class="sxs-lookup"><span data-stu-id="f64e7-214">See also</span></span>

- [<span data-ttu-id="f64e7-215">Относящиеся к XAML атрибуты среды CLR для пользовательских типов и библиотек</span><span class="sxs-lookup"><span data-stu-id="f64e7-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](clr-attributes-with-custom-types-and-libraries.md)
- [<span data-ttu-id="f64e7-216">Службы XAML</span><span class="sxs-lookup"><span data-stu-id="f64e7-216">XAML Services</span></span>](../../../api/index.md)
