---
title: Определение пользовательских типов для использования со службами XAML .NET
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: 2c0578b5397172814c708706173c69ef69f91b2a
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/15/2020
ms.locfileid: "90551782"
---
# <a name="define-custom-types-for-use-with-net-xaml-services"></a><span data-ttu-id="b6e78-102">Определение пользовательских типов для использования со службами XAML .NET</span><span class="sxs-lookup"><span data-stu-id="b6e78-102">Define custom types for use with .NET XAML Services</span></span>

<span data-ttu-id="b6e78-103">При определении пользовательских типов, которые являются бизнес-объектами или типами, не имеющими зависимости от конкретных платформ, можно следовать определенным рекомендациям по XAML.</span><span class="sxs-lookup"><span data-stu-id="b6e78-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="b6e78-104">При соблюдении этих рекомендаций службы XAML .NET и их средства чтения и записи XAML могут обнаружить характеристики XAML вашего типа и присвоить ему соответствующее представление в потоке узлов XAML, используя систему типов XAML.</span><span class="sxs-lookup"><span data-stu-id="b6e78-104">If you follow these practices, .NET XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="b6e78-105">В этом разделе описываются рекомендации по определениям типов, определениям членов и присвоению атрибутов типов или членов в среде CLR.</span><span class="sxs-lookup"><span data-stu-id="b6e78-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>

## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="b6e78-106">Шаблоны конструктора и определения типов для XAML</span><span class="sxs-lookup"><span data-stu-id="b6e78-106">Constructor Patterns and Type Definitions for XAML</span></span>

<span data-ttu-id="b6e78-107">Для создания экземпляра в виде объектного элемента в XAML пользовательский класс должен удовлетворять следующим требованиям.</span><span class="sxs-lookup"><span data-stu-id="b6e78-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>

- <span data-ttu-id="b6e78-108">Пользовательский класс должен быть открытым и должен предоставлять открытый конструктор без параметров.</span><span class="sxs-lookup"><span data-stu-id="b6e78-108">The custom class must be public and must expose a parameterless public constructor.</span></span> <span data-ttu-id="b6e78-109">(Примечания о структурах см. в следующем разделе.)</span><span class="sxs-lookup"><span data-stu-id="b6e78-109">(See following section for notes regarding structures.)</span></span>

- <span data-ttu-id="b6e78-110">Пользовательский класс не должен быть вложенным классом.</span><span class="sxs-lookup"><span data-stu-id="b6e78-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="b6e78-111">Дополнительный "точка" в пути Full-Name делает деление класса-пространства неоднозначным и влияет на другие функции XAML, такие как вложенные свойства.</span><span class="sxs-lookup"><span data-stu-id="b6e78-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>
<span data-ttu-id="b6e78-112">Если объект может быть создан как объектный элемент, созданный объект может заполнить форму элемента свойства любых свойств, которые принимают объект в качестве базового типа.</span><span class="sxs-lookup"><span data-stu-id="b6e78-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>

<span data-ttu-id="b6e78-113">При включении преобразователя значений можно по-прежнему предоставлять значения объектов для типов, которые не соответствуют этим критериям.</span><span class="sxs-lookup"><span data-stu-id="b6e78-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="b6e78-114">Дополнительные сведения см. в разделе [преобразователи типов и расширения разметки для XAML](type-converters-and-markup-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="b6e78-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

### <a name="structures"></a><span data-ttu-id="b6e78-115">Структуры</span><span class="sxs-lookup"><span data-stu-id="b6e78-115">Structures</span></span>

<span data-ttu-id="b6e78-116">Структуры всегда могут быть построены в XAML, по определению среды CLR.</span><span class="sxs-lookup"><span data-stu-id="b6e78-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="b6e78-117">Это обусловлено тем, что компилятор CLR неявно создает конструктор без параметров для структуры.</span><span class="sxs-lookup"><span data-stu-id="b6e78-117">This is because a CLR compiler implicitly creates a parameterless constructor for a structure.</span></span> <span data-ttu-id="b6e78-118">Этот конструктор инициализирует все значения свойств значениями по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="b6e78-118">This constructor initializes all property values to their defaults.</span></span>

<span data-ttu-id="b6e78-119">В некоторых случаях поведение конструирования по умолчанию для структуры не желательно.</span><span class="sxs-lookup"><span data-stu-id="b6e78-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="b6e78-120">Это может быть вызвано тем, что структура предназначена для заполнения значений и концептуально работает как объединение.</span><span class="sxs-lookup"><span data-stu-id="b6e78-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="b6e78-121">Как объединение, содержащиеся значения могут иметь взаимоисключающие интерпретации, поэтому ни одно из его свойств не может быть задано.</span><span class="sxs-lookup"><span data-stu-id="b6e78-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="b6e78-122">Примером такой структуры в словаре WPF является <xref:System.Windows.GridLength> .</span><span class="sxs-lookup"><span data-stu-id="b6e78-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="b6e78-123">Такие структуры должны реализовывать преобразователь типов, чтобы значения можно было выразить в форме атрибутов с помощью строковых соглашений, которые создают различные интерпретации или режимы значений структуры.</span><span class="sxs-lookup"><span data-stu-id="b6e78-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="b6e78-124">Структура должна также предоставлять аналогичное поведение для построения кода с помощью конструктора без параметров.</span><span class="sxs-lookup"><span data-stu-id="b6e78-124">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>

### <a name="interfaces"></a><span data-ttu-id="b6e78-125">Интерфейсы</span><span class="sxs-lookup"><span data-stu-id="b6e78-125">Interfaces</span></span>

<span data-ttu-id="b6e78-126">Интерфейсы можно использовать в качестве базовых типов элементов.</span><span class="sxs-lookup"><span data-stu-id="b6e78-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="b6e78-127">Система типов XAML проверяет присваиваемый список и ждет, что объект, предоставленный в качестве значения, может быть назначен интерфейсу.</span><span class="sxs-lookup"><span data-stu-id="b6e78-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="b6e78-128">Не существует концепции того, как интерфейс должен быть представлен как тип XAML, если соответствующий назначаемый тип поддерживает требования к конструкции XAML.</span><span class="sxs-lookup"><span data-stu-id="b6e78-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>

### <a name="factory-methods"></a><span data-ttu-id="b6e78-129">Фабричные методы</span><span class="sxs-lookup"><span data-stu-id="b6e78-129">Factory Methods</span></span>

<span data-ttu-id="b6e78-130">Заводские методы являются функцией XAML 2009.</span><span class="sxs-lookup"><span data-stu-id="b6e78-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="b6e78-131">Они изменяют принцип XAML, в котором объекты должны иметь конструкторы без параметров.</span><span class="sxs-lookup"><span data-stu-id="b6e78-131">They modify the XAML principle that objects must have parameterless constructors.</span></span> <span data-ttu-id="b6e78-132">В этой статье не описаны заводские методы.</span><span class="sxs-lookup"><span data-stu-id="b6e78-132">Factory methods are not documented in this article.</span></span> <span data-ttu-id="b6e78-133">См. раздел [Директива x:FactoryMethod](xfactorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="b6e78-133">See [x:FactoryMethod Directive](xfactorymethod-directive.md).</span></span>

## <a name="enumerations"></a><span data-ttu-id="b6e78-134">Перечисления</span><span class="sxs-lookup"><span data-stu-id="b6e78-134">Enumerations</span></span>

<span data-ttu-id="b6e78-135">Перечисления имеют поведение преобразования собственного типа XAML.</span><span class="sxs-lookup"><span data-stu-id="b6e78-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="b6e78-136">Имена констант перечисления, указанные в XAML, разрешаются для базового типа перечисления и возвращают значение перечисления в средство записи объектов XAML.</span><span class="sxs-lookup"><span data-stu-id="b6e78-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>

<span data-ttu-id="b6e78-137">XAML поддерживает использование флагов для перечислений с <xref:System.FlagsAttribute> применением.</span><span class="sxs-lookup"><span data-stu-id="b6e78-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="b6e78-138">Дополнительные сведения см. [в разделе Подробное описание синтаксиса XAML](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail).</span><span class="sxs-lookup"><span data-stu-id="b6e78-138">For more information, see [XAML Syntax In Detail](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail).</span></span> <span data-ttu-id="b6e78-139">([Подробное описание синтаксиса XAML](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail) написано для аудитории WPF, но большая часть информации в этом разделе ОТНОСИТСЯ к XAML, который не относится к конкретной реализующей платформе.)</span><span class="sxs-lookup"><span data-stu-id="b6e78-139">([XAML Syntax In Detail](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>

## <a name="member-definitions"></a><span data-ttu-id="b6e78-140">Определения элементов</span><span class="sxs-lookup"><span data-stu-id="b6e78-140">Member Definitions</span></span>

<span data-ttu-id="b6e78-141">Типы могут определять элементы для использования XAML.</span><span class="sxs-lookup"><span data-stu-id="b6e78-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="b6e78-142">Типы могут определять элементы, которые могут использоваться XAML, даже если этот конкретный тип не может использоваться в XAML.</span><span class="sxs-lookup"><span data-stu-id="b6e78-142">It's possible for types to define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="b6e78-143">Это возможно благодаря наследованию CLR.</span><span class="sxs-lookup"><span data-stu-id="b6e78-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="b6e78-144">До тех пор, пока какой-либо тип, наследующий член, поддерживает использование XAML в качестве типа, а член поддерживает использование XAML для базового типа или имеет доступ к собственному синтаксису XAML, этот член может использоваться в XAML.</span><span class="sxs-lookup"><span data-stu-id="b6e78-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>

### <a name="properties"></a><span data-ttu-id="b6e78-145">Свойства</span><span class="sxs-lookup"><span data-stu-id="b6e78-145">Properties</span></span>

<span data-ttu-id="b6e78-146">Если вы определяете свойства как общедоступное свойство CLR с помощью `get` стандартных `set` шаблонов CLR и методов доступа и ключевых слов, соответствующих языку, система типов XAML может сообщить о свойстве как члену с соответствующей информацией, предоставляемой для <xref:System.Xaml.XamlMember> свойств, таких как <xref:System.Xaml.XamlMember.IsReadPublic%2A> и <xref:System.Xaml.XamlMember.IsWritePublic%2A> .</span><span class="sxs-lookup"><span data-stu-id="b6e78-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>

<span data-ttu-id="b6e78-147">Определенные свойства могут включать текстовый синтаксис путем применения <xref:System.ComponentModel.TypeConverterAttribute> .</span><span class="sxs-lookup"><span data-stu-id="b6e78-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="b6e78-148">Дополнительные сведения см. в разделе [преобразователи типов и расширения разметки для XAML](type-converters-and-markup-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="b6e78-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

<span data-ttu-id="b6e78-149">В отсутствие текстового синтаксиса или преобразования машинного кода XAML, а также при отсутствии дальнейших косвенных обращений, таких как использование расширения разметки, тип свойства ( <xref:System.Xaml.XamlMember.TargetType%2A> в системе типов XAML) должен иметь возможность возвращать экземпляр в средство записи объектов XAML, рассматривая целевой тип как тип CLR.</span><span class="sxs-lookup"><span data-stu-id="b6e78-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>

<span data-ttu-id="b6e78-150">Если используется XAML 2009, [расширение разметки x:Reference](xreference-markup-extension.md) можно использовать для предоставления значений, если предыдущие рекомендации не выполняются. Однако это является более частью проблемы использования, чем проблемы с определением типа.</span><span class="sxs-lookup"><span data-stu-id="b6e78-150">If using XAML 2009, [x:Reference Markup Extension](xreference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>

### <a name="events"></a><span data-ttu-id="b6e78-151">События</span><span class="sxs-lookup"><span data-stu-id="b6e78-151">Events</span></span>

<span data-ttu-id="b6e78-152">Если вы определяете события как общедоступное событие CLR, система типов XAML может сообщить о событии как члену с <xref:System.Xaml.XamlMember.IsEvent%2A> именем `true` .</span><span class="sxs-lookup"><span data-stu-id="b6e78-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="b6e78-153">Связывание обработчиков событий не входит в область возможностей служб XAML .NET. привязка оставлена конкретным платформам и реализациям.</span><span class="sxs-lookup"><span data-stu-id="b6e78-153">Wiring the event handlers is not within the scope of .NET XAML Services capabilities; wiring is left to specific frameworks and implementations.</span></span>

### <a name="methods"></a><span data-ttu-id="b6e78-154">Методы</span><span class="sxs-lookup"><span data-stu-id="b6e78-154">Methods</span></span>

<span data-ttu-id="b6e78-155">Встроенный код для методов не является возможностью XAML по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="b6e78-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="b6e78-156">В большинстве случаев не нужно напрямую ссылаться на члены методов из XAML, а роль методов в XAML — предоставить поддержку для конкретных шаблонов XAML.</span><span class="sxs-lookup"><span data-stu-id="b6e78-156">In most cases, you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="b6e78-157">[Директива x:FactoryMethod](xfactorymethod-directive.md) является исключением.</span><span class="sxs-lookup"><span data-stu-id="b6e78-157">[x:FactoryMethod Directive](xfactorymethod-directive.md) is an exception.</span></span>

### <a name="fields"></a><span data-ttu-id="b6e78-158">Поля</span><span class="sxs-lookup"><span data-stu-id="b6e78-158">Fields</span></span>

<span data-ttu-id="b6e78-159">Рекомендации по проектированию среды CLR не допустают нестатических полей.</span><span class="sxs-lookup"><span data-stu-id="b6e78-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="b6e78-160">Для статических полей доступ к значениям статических полей можно получить только с помощью [расширения разметки x:Static](xstatic-markup-extension.md). в этом случае не выполняется никаких специальных действий в определении CLR для предоставления поля для использования в [x:Static](xstatic-markup-extension.md) .</span><span class="sxs-lookup"><span data-stu-id="b6e78-160">For static fields, you can access static field values only through [x:Static Markup Extension](xstatic-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](xstatic-markup-extension.md) usages.</span></span>

## <a name="attachable-members"></a><span data-ttu-id="b6e78-161">Присоединяемые члены</span><span class="sxs-lookup"><span data-stu-id="b6e78-161">Attachable Members</span></span>

<span data-ttu-id="b6e78-162">Присоединяемые члены предоставляются XAML через шаблон метода доступа для определяющего типа.</span><span class="sxs-lookup"><span data-stu-id="b6e78-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="b6e78-163">Сам определяющий тип не обязательно должен быть доступен для использования в XAML как объект.</span><span class="sxs-lookup"><span data-stu-id="b6e78-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="b6e78-164">На самом деле, распространенным шаблоном является объявление класса службы, роль которого заключается в том, чтобы присоединить присоединяемый член и реализовать соответствующие поведения, но не обслуживает другие функции, такие как представление пользовательского интерфейса.</span><span class="sxs-lookup"><span data-stu-id="b6e78-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="b6e78-165">В следующих разделах местозаполнитель *PropertyName* представляет имя присоединяемого члена.</span><span class="sxs-lookup"><span data-stu-id="b6e78-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="b6e78-166">Это имя должно быть допустимым в [грамматике имяxaml](xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="b6e78-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>

<span data-ttu-id="b6e78-167">Соблюдайте осторожность при конфликтах имен между этими шаблонами и другими методами типа.</span><span class="sxs-lookup"><span data-stu-id="b6e78-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="b6e78-168">Если существует элемент, совпадающий с одним из шаблонов, он может быть интерпретирован обработчиком XAML как присоединяемый путь использования члена, даже если это не ваша цель.</span><span class="sxs-lookup"><span data-stu-id="b6e78-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>

#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="b6e78-169">Метод доступа ИмяСвойства</span><span class="sxs-lookup"><span data-stu-id="b6e78-169">The GetPropertyName Accessor</span></span>

<span data-ttu-id="b6e78-170">Сигнатура для `GetPropertyName` метода доступа должна быть такой:</span><span class="sxs-lookup"><span data-stu-id="b6e78-170">The signature for the `GetPropertyName` accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="b6e78-171">Объект `target` можно указать как более конкретный тип в реализации.</span><span class="sxs-lookup"><span data-stu-id="b6e78-171">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="b6e78-172">Его можно использовать для определения области использования присоединяемого члена; использование за пределами предполагаемой области действия приведет к созданию недопустимых исключений приведения, которые затем выводятся в результате ошибки синтаксического анализа XAML.</span><span class="sxs-lookup"><span data-stu-id="b6e78-172">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="b6e78-173">Имя параметра `target` не является обязательным, но `target` в большинстве реализаций оно называется по соглашению.</span><span class="sxs-lookup"><span data-stu-id="b6e78-173">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>

- <span data-ttu-id="b6e78-174">Возвращаемое значение можно указать как более конкретный тип в реализации.</span><span class="sxs-lookup"><span data-stu-id="b6e78-174">The return value can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="b6e78-175">Чтобы обеспечить поддержку <xref:System.ComponentModel.TypeConverter> синтаксиса текста для присоединяемого элемента, примените к нему доступ <xref:System.ComponentModel.TypeConverterAttribute> `GetPropertyName` .</span><span class="sxs-lookup"><span data-stu-id="b6e78-175">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `GetPropertyName` accessor.</span></span> <span data-ttu-id="b6e78-176">Применение к `get` вместо этого `set` может показаться не интуитивно понятным; однако это соглашение может поддерживать концепцию присоединяемых членов только для чтения, которые являются сериализуемыми, что полезно в сценариях конструктора.</span><span class="sxs-lookup"><span data-stu-id="b6e78-176">Applying to the `get` instead of the `set` may seem non-intuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>

#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="b6e78-177">Метод доступа Сетпропертинаме</span><span class="sxs-lookup"><span data-stu-id="b6e78-177">The SetPropertyName Accessor</span></span>

<span data-ttu-id="b6e78-178">Сигнатура для `SetPropertyName` метода доступа должна быть такой:</span><span class="sxs-lookup"><span data-stu-id="b6e78-178">The signature for the `SetPropertyName` accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="b6e78-179">`target`Объект может быть указан в реализации в качестве более конкретного типа с той же логикой и последствиями, как описано в предыдущем разделе.</span><span class="sxs-lookup"><span data-stu-id="b6e78-179">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>

- <span data-ttu-id="b6e78-180">Объект `value` можно указать как более конкретный тип в реализации.</span><span class="sxs-lookup"><span data-stu-id="b6e78-180">The `value` object can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="b6e78-181">Помните, что значение этого метода является входными данными, поступающими от использования XAML, обычно в форме атрибута.</span><span class="sxs-lookup"><span data-stu-id="b6e78-181">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="b6e78-182">В форме атрибута должна быть поддержка преобразователя значений для текстового синтаксиса, и атрибут для `GetPropertyName` метода доступа s.</span><span class="sxs-lookup"><span data-stu-id="b6e78-182">From attribute form there must be value converter support for a text syntax, and you attribute on the `GetPropertyName`s accessor.</span></span>

### <a name="attachable-member-stores"></a><span data-ttu-id="b6e78-183">Хранилища присоединяемых членов</span><span class="sxs-lookup"><span data-stu-id="b6e78-183">Attachable Member Stores</span></span>

<span data-ttu-id="b6e78-184">Методы доступа обычно недостаточно для предоставления средств для размещения значений присоединяемых членов в графе объектов, а также для извлечения значений из графа объектов и их правильной сериализации.</span><span class="sxs-lookup"><span data-stu-id="b6e78-184">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="b6e78-185">Чтобы обеспечить эту функциональность, `target` объекты в предыдущих сигнатурах метода доступа должны иметь возможность хранить значения.</span><span class="sxs-lookup"><span data-stu-id="b6e78-185">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="b6e78-186">Механизм хранения должен соответствовать принципу присоединяемого члена, который прикрепляется к целевым объектам, в которых присоединяемый элемент отсутствует в списке членов.</span><span class="sxs-lookup"><span data-stu-id="b6e78-186">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="b6e78-187">Службы XAML .NET предоставляют метод реализации для присоединяемых хранилищ членов через API-интерфейсы <xref:System.Xaml.IAttachedPropertyStore> и <xref:System.Xaml.AttachablePropertyServices> .</span><span class="sxs-lookup"><span data-stu-id="b6e78-187">.NET XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="b6e78-188"><xref:System.Xaml.IAttachedPropertyStore> используется модулями записи XAML для обнаружения реализации хранилища и должен быть реализован в типе, который является методом `target` доступа.</span><span class="sxs-lookup"><span data-stu-id="b6e78-188"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="b6e78-189">Статические <xref:System.Xaml.AttachablePropertyServices> API-интерфейсы используются в теле методов доступа и ссылаются на присоединяемый член по его свойству <xref:System.Xaml.AttachableMemberIdentifier> .</span><span class="sxs-lookup"><span data-stu-id="b6e78-189">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>

## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="b6e78-190">Связанные с XAML атрибуты среды CLR</span><span class="sxs-lookup"><span data-stu-id="b6e78-190">XAML-Related CLR Attributes</span></span>

<span data-ttu-id="b6e78-191">Правильное присвоение атрибутов типам, членам и сборкам важно для передачи сведений о системе типов XAML в службы .NET XAML.</span><span class="sxs-lookup"><span data-stu-id="b6e78-191">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET XAML Services.</span></span> <span data-ttu-id="b6e78-192">Создание отчетов о системе типов XAML имеет смысл, если применяется одна из следующих ситуаций.</span><span class="sxs-lookup"><span data-stu-id="b6e78-192">Reporting XAML type system information is relevant if either of the following situations apply:</span></span>

- <span data-ttu-id="b6e78-193">Вы планируете использовать типы для систем XAML, которые непосредственно основаны на средствах чтения XAML служб XAML .NET и модулях записи XAML.</span><span class="sxs-lookup"><span data-stu-id="b6e78-193">You intend your types for use with XAML systems that are directly based on .NET XAML Services XAML readers and XAML writers.</span></span>
- <span data-ttu-id="b6e78-194">Вы определяете или используете платформу, использующую XAML, основанную на этих средствах чтения и записи XAML.</span><span class="sxs-lookup"><span data-stu-id="b6e78-194">You define or use a XAML-utilizing framework that's based on those XAML readers and XAML writers.</span></span>

<span data-ttu-id="b6e78-195">Список всех атрибутов, связанных с XAML, которые относятся к поддержке XAML пользовательских типов, см. в разделе связанные с XAML [атрибуты среды CLR для пользовательских типов и библиотек](clr-attributes-with-custom-types-and-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="b6e78-195">For a listing of each XAML-related attribute that's relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](clr-attributes-with-custom-types-and-libraries.md).</span></span>

## <a name="usage"></a><span data-ttu-id="b6e78-196">Использование</span><span class="sxs-lookup"><span data-stu-id="b6e78-196">Usage</span></span>

<span data-ttu-id="b6e78-197">Для использования пользовательских типов необходимо, чтобы автор разметки сопоставлял префикс для сборки и пространство имен CLR, которое содержит пользовательский тип.</span><span class="sxs-lookup"><span data-stu-id="b6e78-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="b6e78-198">Эта процедура не описана в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="b6e78-198">This procedure is not documented in this topic.</span></span>

## <a name="access-level"></a><span data-ttu-id="b6e78-199">Уровень доступа</span><span class="sxs-lookup"><span data-stu-id="b6e78-199">Access Level</span></span>

<span data-ttu-id="b6e78-200">XAML предоставляет средства для загрузки и создания экземпляров типов, имеющих `internal` уровень доступа.</span><span class="sxs-lookup"><span data-stu-id="b6e78-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="b6e78-201">Эта возможность предоставляется, чтобы пользовательский код мог определять собственные типы, а затем создавать экземпляры этих классов из разметки, которая также является частью одной и той же области пользовательского кода.</span><span class="sxs-lookup"><span data-stu-id="b6e78-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>

<span data-ttu-id="b6e78-202">Примером из WPF является каждый раз, когда пользовательский код определяет <xref:System.Windows.Controls.UserControl> , который предназначен для оптимизации поведения пользовательского интерфейса, но не является частью любого возможного механизма расширения, который может быть подразумеваемым объявлением поддерживающего класса с `public` уровнем доступа.</span><span class="sxs-lookup"><span data-stu-id="b6e78-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="b6e78-203">Такой объект <xref:System.Windows.Controls.UserControl> может быть объявлен с `internal` доступом, если резервный код компилируется в ту же сборку, из которой он ссылается как на тип XAML.</span><span class="sxs-lookup"><span data-stu-id="b6e78-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>

<span data-ttu-id="b6e78-204">Для приложения, которое загружает XAML в режиме полного доверия и использует <xref:System.Xaml.XamlObjectWriter> , Загрузка классов с `internal` уровнем доступа всегда включена.</span><span class="sxs-lookup"><span data-stu-id="b6e78-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>

<span data-ttu-id="b6e78-205">Для приложения, которое загружает XAML в режиме частичного доверия, можно управлять характеристиками уровня доступа с помощью <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span><span class="sxs-lookup"><span data-stu-id="b6e78-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="b6e78-206">Кроме того, механизмы отсрочки (например, система шаблонов WPF) должны иметь возможность распространять любые разрешения уровня доступа и сохранять их для выполнения в конечном итоге. Это осуществляется внутренним образом путем передачи <xref:System.Xaml.Permissions.XamlAccessLevel> информации.</span><span class="sxs-lookup"><span data-stu-id="b6e78-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>

### <a name="wpf-implementation"></a><span data-ttu-id="b6e78-207">Реализация WPF</span><span class="sxs-lookup"><span data-stu-id="b6e78-207">WPF Implementation</span></span>

<span data-ttu-id="b6e78-208">XAML WPF использует модель доступа с частичным доверием, где при загрузке BAML в режиме частичного доверия доступ ограничен <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> для сборки, являющейся источником BAML.</span><span class="sxs-lookup"><span data-stu-id="b6e78-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="b6e78-209">Для РБП WPF использует <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> в качестве механизма для передачи сведений об уровне доступа.</span><span class="sxs-lookup"><span data-stu-id="b6e78-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>

<span data-ttu-id="b6e78-210">В терминологии WPF XAML *внутренний тип* — это тип, определяемый той же сборкой, которая также включает ссылающийся XAML.</span><span class="sxs-lookup"><span data-stu-id="b6e78-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="b6e78-211">Такой тип можно сопоставить с помощью пространства имен XAML, которое намеренно опускает сборку = часть сопоставления, например `xmlns:local="clr-namespace:WPFApplication1"` .</span><span class="sxs-lookup"><span data-stu-id="b6e78-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span> <span data-ttu-id="b6e78-212">Если BAML ссылается на внутренний тип, а этот тип имеет `internal` уровень доступа, то создается `GeneratedInternalTypeHelper` класс для сборки.</span><span class="sxs-lookup"><span data-stu-id="b6e78-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="b6e78-213">Если вы хотите избежать `GeneratedInternalTypeHelper` , необходимо либо использовать `public` уровень доступа, либо отнести соответствующий класс к отдельной сборке и сделать ее зависимой.</span><span class="sxs-lookup"><span data-stu-id="b6e78-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>

## <a name="see-also"></a><span data-ttu-id="b6e78-214">См. также</span><span class="sxs-lookup"><span data-stu-id="b6e78-214">See also</span></span>

- [<span data-ttu-id="b6e78-215">Относящиеся к XAML атрибуты среды CLR для пользовательских типов и библиотек</span><span class="sxs-lookup"><span data-stu-id="b6e78-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](clr-attributes-with-custom-types-and-libraries.md)
- [<span data-ttu-id="b6e78-216">Службы XAML</span><span class="sxs-lookup"><span data-stu-id="b6e78-216">XAML Services</span></span>](../../../api/index.md)
