---
title: Определение пользовательских типов для использования со службами XAML .NET
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: ff7e4229450e801a6d618c5141efde8cdcbef03d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "81433076"
---
# <a name="define-custom-types-for-use-with-net-xaml-services"></a>Определите пользовательские типы для использования с помощью служб .NET XAML

При определении типов пользовательских, которые являются бизнес-объектами или типами, не зависят от определенных фребов, существуют некоторые рекомендации для XAML, которым вы можете следовать. Если вы будете следовать этим практикам, .NET XAML Services и его xAML читатели и xAML писатели могут обнаружить xAML характеристики вашего типа и дать ему соответствующее представление в потоке узлов XAML с помощью системы типа XAML. Эта тема описывает наилучшую практику для определений типов, определений членов и CLR, приписывающих типы или члены.

## <a name="constructor-patterns-and-type-definitions-for-xaml"></a>Шаблоны конструкторов и определения типов для XAML

Чтобы быть мгновенно настроенным в качестве элемента объекта в XAML, пользовательский класс должен соответствовать следующим требованиям:

- Пользовательский класс должен быть общедоступным и должен подвергать безпаративному общественному конструктору. (Примечания о структурах см. в следующем разделе.)

- Пользовательский класс не должен быть вложенным классом. Дополнительная "точка" в полноименном пути делает разделение пространства класса неоднозначным и мешает другим функциям XAML, таким как прилагаемые свойства.
Если объект может быть мгновенно элемент объекта, созданный объект может заполнить форму элемента свойства любых свойств, которые принимают объект в качестве основного типа.

Вы все еще можете предоставить значения объектов для типов, которые не отвечают этим критериям, если вы включите преобразователь значения. Для получения дополнительной [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md)информации см.

### <a name="structures"></a>Структуры

Структуры всегда могут быть построены в XAML, по определению CLR. Это происходит потому, что компилятор CLR неявно создает беспараметрыный конструктор для структуры. Этот конструктор инициализирует все значения свойств для своих по умолчанию.

В некоторых случаях поведение конструкции по умолчанию для структуры нежелательно. Это может быть связано с тем, что структура предназначена для заполнения значений и концептуально функционировать как союз. Как союз, содержащиеся ценности могут иметь взаимоисключающие толкования, и, следовательно, ни одно из его свойств не являются установленными. Примером такой структуры в лексиконе WPF <xref:System.Windows.GridLength>является . Такие структуры должны реализовывать преобразователь типа, чтобы значения могли быть выражены в форме атрибута, используя строковые конвенции, которые создают различные интерпретации или режимы значений структуры. Структура должна также подвергать аналогичное поведение для построения кода через непараметрбезный конструктор.

### <a name="interfaces"></a>интерфейсов,

Интерфейсы могут использоваться в качестве базовых типов элементов. Система типа XAML проверяет список назначенных и ожидает, что объект, который предоставляется в качестве значения, может быть назначен интерфейсу. Нет понятия о том, как интерфейс должен быть представлен в виде типа XAML до тех пор, пока соответствующий присваиваемый тип поддерживает требования к конструкции XAML.

### <a name="factory-methods"></a>Методы фабрики

Методы завода являются функцией XAML 2009. Они изменяют принцип XAML, согласно которому объекты должны иметь беспараметрыные конструкторы. Методы завода не задокументированы в этой статье. [См.:Директива FactoryMethod.](xfactorymethod-directive.md)

## <a name="enumerations"></a>Перечисления

Перечисления имеют поведение преобразования родного типа XAML. Постоянные имена, указанные в XAML, разрешаются с базовым типом перечисления и возвращают значение перечисления писателю объекта XAML.

XAML поддерживает использование флагов в стиле для <xref:System.FlagsAttribute> перечислений с прикладом. Для получения дополнительной информации, см [XAML Syntax Подробно](../../framework/wpf/advanced/xaml-syntax-in-detail.md). ([XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md) написандля для аудитории WPF, но большая часть информации в этой теме актуальна для XAML, которая не специфична для конкретной платформы реализации.)

## <a name="member-definitions"></a>Определения участников

Типы могут определять члены для использования XAML. Типы могут определять члены, пригодные для xAML, даже если этот конкретный тип не используется xAML. Это возможно из-за наследования CLR. До тех пор, пока некоторый тип, который наследует член поддерживает использование XAML как тип, и член поддерживает использование XAML для своего базового типа или имеет родной синтаксис XAML, этот член является XAML-использовать.

### <a name="properties"></a>Свойства

Если вы определяете свойства как публичное свойство CLR, используя типичные шаблоны CLR `get` и `set` accessor и соответствующие языку ключевые слова, система типа XAML может сообщить о собственности как члене с соответствующей информацией, предоставленной для <xref:System.Xaml.XamlMember> свойств, таких как <xref:System.Xaml.XamlMember.IsReadPublic%2A> и <xref:System.Xaml.XamlMember.IsWritePublic%2A>.

Специфические свойства могут включить синтаксис текста, применяя. <xref:System.ComponentModel.TypeConverterAttribute> Для получения дополнительной [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md)информации см.

При отсутствии синтаксиса текста или родного преобразования XAML и при отсутствии дальнейшего косвенного направления,<xref:System.Xaml.XamlMember.TargetType%2A> например использования расширения разметки, тип свойства (в системе типа XAML) должен быть в состоянии вернуть экземпляр писателю объекта XAML, рассматривая целевой тип как тип CLR.

При использовании XAML 2009 расширение [x:Reference Markup](xreference-markup-extension.md) может быть использовано для предоставления значений, если предыдущие соображения не выполнены; однако это больше проблема использования, чем проблема определения типа.

### <a name="events"></a>События

Если вы определяете события как общедоступное событие CLR, система типа <xref:System.Xaml.XamlMember.IsEvent%2A> XAML может сообщить о событии как о участнике как `true`о. Обработка событий не входит в сферу возможностей .NET XAML Services; проводка оставлена на определенные рамки и реализации.

### <a name="methods"></a>Методы

Внеекодивный код для методов не является возможностью XAML по умолчанию. В большинстве случаев вы не ссылаетесь непосредственно на участников метода xAML, и роль методов в XAML заключается только в том, чтобы обеспечить поддержку конкретных шаблонов XAML. [x:FactoryMethod Directive](xfactorymethod-directive.md) является исключением.

### <a name="fields"></a>Поля

Руководящие принципы проектирования CLR препятствуют нестатическому полям. Для статических полей доступ к значениям статических полей можно только через [x:Static Markup Extension;](xstatic-markup-extension.md) в этом случае вы не делаете ничего особенного в определении CLR, чтобы разоблачить поле для [x:Static](xstatic-markup-extension.md) обычаев.

## <a name="attachable-members"></a>Присоединенные члены

Прикрепляемые участники подвергаются воздействию XAML через шаблон метода аксессуаров по определяющему типу. Сам по себе определяющий тип не должен быть пригодным для XAML как объект. На самом деле, общий шаблон заключается в объявлении класса обслуживания, роль которого заключается в том, чтобы владеть прилагаемым членом и реализовывать связанные с ними поведения, но не выполнять никаких других функций, таких как представление uI. Для следующих разделов, заполнитель *PropertyName* представляет имя вашего прилагаемого члена. Это имя должно быть действительным в [XamlName Грамматика](xamlname-grammar.md).

Будьте осторожны с столкновениями имен между этими шаблонами и другими методами типа. Если член существует, что соответствует одному из шаблонов, он может быть истолкован как прилагаемый путь использования члена процессором XAML, даже если это не было вашим намерением.

#### <a name="the-getpropertyname-accessor"></a>GetPropertyName Аксессуар

Подпись для `GetPropertyName` аксессуара должна быть:

`public static object GetPropertyName(object target)`

- Объект `target` можно указать как более конкретный тип в реализации. Вы можете использовать это для сферы использования вашего прилагаемого члена; использования за пределами предполагаемой области будут бросать недействительные исключения, которые затем всплывают по ошибке разбора XAML. Имя `target` параметра не является обязательным `target` требованием, но в большинстве реализаций названо конвенцией.

- Возвращаемое значение можно указать как более конкретный тип в реализации.

Для поддержки синтаксиса включенного <xref:System.ComponentModel.TypeConverter> текста для <xref:System.ComponentModel.TypeConverterAttribute> использования `GetPropertyName` атрибута прилагаемого члена, обращайтесь к аксессуару. Применение к `get` вместо `set` может показаться неинтуитивным; однако, эта конвенция может поддержать принципиальную схему читать-только прикрепляемых членов которые serializable, который полезн в сценариях конструктора.

#### <a name="the-setpropertyname-accessor"></a>Аксессуар SetPropertyName

Подпись для `SetPropertyName` аксессуара должна быть:

`public static void SetPropertyName(object target, object value)`

- Объект `target` может быть указан как более конкретный тип в реализации, с той же логикой и последствиями, как описано в предыдущем разделе.

- Объект `value` можно указать как более конкретный тип в реализации.

Помните, что значением для этого метода является вход, поступающий от использования XAML, как правило, в форме атрибута. Из формы атрибута должна быть поддержка преобразователя значений `GetPropertyName`для синтаксиса текста, и вы атрибут на s accessor.

### <a name="attachable-member-stores"></a>Прикрепляемые магазины-члены

Методов доступа, как правило, недостаточно для того, чтобы поместить прикрепляемые значения элемента в график объекта или извлечь значения из графика объекта и правильно их выставить. Чтобы обеспечить эту `target` функциональность, объекты в предыдущих подписях доступа должны быть способны хранить значения. Механизм хранения должен соответствовать принципу прилагаемого члена, согласно которому член привязывается к целям, в которых прилагаемый член не входит в список членов. .NET XAML Services предоставляет технику реализации для присоединенных магазинов-членов через AA <xref:System.Xaml.IAttachedPropertyStore> и <xref:System.Xaml.AttachablePropertyServices>. <xref:System.Xaml.IAttachedPropertyStore>используется авторами XAML для обнаружения реализации хранилища и должна быть `target` реализована по типу, который является аксессуарами. Статические <xref:System.Xaml.AttachablePropertyServices> AIS используются в теле аксессуаров, и относятся к <xref:System.Xaml.AttachableMemberIdentifier>прикрепляемым членом по его .

## <a name="xaml-related-clr-attributes"></a>Атрибуты CLR, связанные с XAML

Правильное присвоение типов, участников и сборок важно для того, чтобы сообщать информацию о системе типа XAML в службы .NET XAML Services. Информация о системе типа XAML актуальна, если в одной из следующих ситуаций применяется:

- Вы намереваетесь использовать типы с системами XAML, которые непосредственно основаны на читателях .NET XAML XAML XAML и авторах XAML.
- Вы определяете или используете платформу XAML, использующее, основанную на этих читателях XAML и авторах XAML.

Для перечисления каждого атрибута, связанного с XAML, который имеет [XAML-Related CLR Attributes for Custom Types and Libraries](clr-attributes-with-custom-types-and-libraries.md)отношение к поддержке XAML ваших пользовательских типов, см.

## <a name="usage"></a>Использование

Использование пользовательских типов требует, чтобы автор разметки должен наметить префикс для пространства имен сборки и CLR, которые содержат пользовательский тип. Эта процедура не документирована в этой теме.

## <a name="access-level"></a>Уровень доступа

XAML предоставляет средства для загрузки и мгновенного `internal` типа, которые имеют уровень доступа. Эта возможность предоставляется таким образом, что пользовательский код может определить свои собственные типы, а затем мгновенно эти классы из разметки, которая также является частью той же области кода пользователя.

Примером из WPF является всякий <xref:System.Windows.Controls.UserControl> раз, когда пользовательский код определяет, который предназначен как способ рефакторинга поведения пользовательского интерфейса, но `public` не как часть любого возможного механизма расширения, который может быть подразумеваен путем объявления поддерживающего класса с уровнем доступа. Такой <xref:System.Windows.Controls.UserControl> ам-код `internal` может быть объявлен с доступом, если резервный код компилируется в ту же сборку, из которой он упоминается как тип XAML.

Для приложения, которое загружает XAML под полное доверие и использует, <xref:System.Xaml.XamlObjectWriter>загрузка классов с `internal` уровнем доступа всегда включена.

Для приложения, которое загружает XAML под частичным доверием, можно управлять характеристиками уровня доступа с помощью <xref:System.Xaml.Permissions.XamlAccessLevel> API. Кроме того, механизмы отсрочки (такие как система шаблонов WPF) должны быть в состоянии распространять любые разрешения уровня доступа и сохранять их для оценки времени выполнения; это обрабатывается внутренне путем <xref:System.Xaml.Permissions.XamlAccessLevel> передачи информации.

### <a name="wpf-implementation"></a>Внедрение WPF

WPF XAML использует модель частичного доверия доступа, где, если BAML <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> загружается под частичным доверием, доступ ограничен для сборки, которая является источником BAML. Для отсрочки WPF <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> использует в качестве механизма передачи информации об уровне доступа.

В терминологии WPF XAML *внутренний тип* — это тип, который определяется той же сборкой, которая также включает ссылки XAML. Такой тип может быть отображен через пространство имен XAML, которое намеренно опускает часть сборки отображения, например, `xmlns:local="clr-namespace:WPFApplication1"`. Если BAML ссылается на внутренний `internal` тип и у `GeneratedInternalTypeHelper` него есть уровень доступа, это генерирует класс для сборки. Если вы хотите `GeneratedInternalTypeHelper`избежать, вы `public` либо должны использовать уровень доступа, либо должны учитывать соответствующий класс в отдельную сборку и сделать эту сборку зависимой.

## <a name="see-also"></a>См. также

- [Относящиеся к XAML атрибуты среды CLR для пользовательских типов и библиотек](clr-attributes-with-custom-types-and-libraries.md)
- [Службы XAML](../../../api/index.md)
