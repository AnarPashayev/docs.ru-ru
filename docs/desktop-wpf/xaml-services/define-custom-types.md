---
title: Определение пользовательских типов для использования со службами XAML .NET
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: 2c0578b5397172814c708706173c69ef69f91b2a
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/15/2020
ms.locfileid: "90551782"
---
# <a name="define-custom-types-for-use-with-net-xaml-services"></a>Определение пользовательских типов для использования со службами XAML .NET

При определении пользовательских типов, которые являются бизнес-объектами или типами, не имеющими зависимости от конкретных платформ, можно следовать определенным рекомендациям по XAML. При соблюдении этих рекомендаций службы XAML .NET и их средства чтения и записи XAML могут обнаружить характеристики XAML вашего типа и присвоить ему соответствующее представление в потоке узлов XAML, используя систему типов XAML. В этом разделе описываются рекомендации по определениям типов, определениям членов и присвоению атрибутов типов или членов в среде CLR.

## <a name="constructor-patterns-and-type-definitions-for-xaml"></a>Шаблоны конструктора и определения типов для XAML

Для создания экземпляра в виде объектного элемента в XAML пользовательский класс должен удовлетворять следующим требованиям.

- Пользовательский класс должен быть открытым и должен предоставлять открытый конструктор без параметров. (Примечания о структурах см. в следующем разделе.)

- Пользовательский класс не должен быть вложенным классом. Дополнительный "точка" в пути Full-Name делает деление класса-пространства неоднозначным и влияет на другие функции XAML, такие как вложенные свойства.
Если объект может быть создан как объектный элемент, созданный объект может заполнить форму элемента свойства любых свойств, которые принимают объект в качестве базового типа.

При включении преобразователя значений можно по-прежнему предоставлять значения объектов для типов, которые не соответствуют этим критериям. Дополнительные сведения см. в разделе [преобразователи типов и расширения разметки для XAML](type-converters-and-markup-extensions.md).

### <a name="structures"></a>Структуры

Структуры всегда могут быть построены в XAML, по определению среды CLR. Это обусловлено тем, что компилятор CLR неявно создает конструктор без параметров для структуры. Этот конструктор инициализирует все значения свойств значениями по умолчанию.

В некоторых случаях поведение конструирования по умолчанию для структуры не желательно. Это может быть вызвано тем, что структура предназначена для заполнения значений и концептуально работает как объединение. Как объединение, содержащиеся значения могут иметь взаимоисключающие интерпретации, поэтому ни одно из его свойств не может быть задано. Примером такой структуры в словаре WPF является <xref:System.Windows.GridLength> . Такие структуры должны реализовывать преобразователь типов, чтобы значения можно было выразить в форме атрибутов с помощью строковых соглашений, которые создают различные интерпретации или режимы значений структуры. Структура должна также предоставлять аналогичное поведение для построения кода с помощью конструктора без параметров.

### <a name="interfaces"></a>Интерфейсы

Интерфейсы можно использовать в качестве базовых типов элементов. Система типов XAML проверяет присваиваемый список и ждет, что объект, предоставленный в качестве значения, может быть назначен интерфейсу. Не существует концепции того, как интерфейс должен быть представлен как тип XAML, если соответствующий назначаемый тип поддерживает требования к конструкции XAML.

### <a name="factory-methods"></a>Фабричные методы

Заводские методы являются функцией XAML 2009. Они изменяют принцип XAML, в котором объекты должны иметь конструкторы без параметров. В этой статье не описаны заводские методы. См. раздел [Директива x:FactoryMethod](xfactorymethod-directive.md).

## <a name="enumerations"></a>Перечисления

Перечисления имеют поведение преобразования собственного типа XAML. Имена констант перечисления, указанные в XAML, разрешаются для базового типа перечисления и возвращают значение перечисления в средство записи объектов XAML.

XAML поддерживает использование флагов для перечислений с <xref:System.FlagsAttribute> применением. Дополнительные сведения см. [в разделе Подробное описание синтаксиса XAML](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail). ([Подробное описание синтаксиса XAML](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail) написано для аудитории WPF, но большая часть информации в этом разделе ОТНОСИТСЯ к XAML, который не относится к конкретной реализующей платформе.)

## <a name="member-definitions"></a>Определения элементов

Типы могут определять элементы для использования XAML. Типы могут определять элементы, которые могут использоваться XAML, даже если этот конкретный тип не может использоваться в XAML. Это возможно благодаря наследованию CLR. До тех пор, пока какой-либо тип, наследующий член, поддерживает использование XAML в качестве типа, а член поддерживает использование XAML для базового типа или имеет доступ к собственному синтаксису XAML, этот член может использоваться в XAML.

### <a name="properties"></a>Свойства

Если вы определяете свойства как общедоступное свойство CLR с помощью `get` стандартных `set` шаблонов CLR и методов доступа и ключевых слов, соответствующих языку, система типов XAML может сообщить о свойстве как члену с соответствующей информацией, предоставляемой для <xref:System.Xaml.XamlMember> свойств, таких как <xref:System.Xaml.XamlMember.IsReadPublic%2A> и <xref:System.Xaml.XamlMember.IsWritePublic%2A> .

Определенные свойства могут включать текстовый синтаксис путем применения <xref:System.ComponentModel.TypeConverterAttribute> . Дополнительные сведения см. в разделе [преобразователи типов и расширения разметки для XAML](type-converters-and-markup-extensions.md).

В отсутствие текстового синтаксиса или преобразования машинного кода XAML, а также при отсутствии дальнейших косвенных обращений, таких как использование расширения разметки, тип свойства ( <xref:System.Xaml.XamlMember.TargetType%2A> в системе типов XAML) должен иметь возможность возвращать экземпляр в средство записи объектов XAML, рассматривая целевой тип как тип CLR.

Если используется XAML 2009, [расширение разметки x:Reference](xreference-markup-extension.md) можно использовать для предоставления значений, если предыдущие рекомендации не выполняются. Однако это является более частью проблемы использования, чем проблемы с определением типа.

### <a name="events"></a>События

Если вы определяете события как общедоступное событие CLR, система типов XAML может сообщить о событии как члену с <xref:System.Xaml.XamlMember.IsEvent%2A> именем `true` . Связывание обработчиков событий не входит в область возможностей служб XAML .NET. привязка оставлена конкретным платформам и реализациям.

### <a name="methods"></a>Методы

Встроенный код для методов не является возможностью XAML по умолчанию. В большинстве случаев не нужно напрямую ссылаться на члены методов из XAML, а роль методов в XAML — предоставить поддержку для конкретных шаблонов XAML. [Директива x:FactoryMethod](xfactorymethod-directive.md) является исключением.

### <a name="fields"></a>Поля

Рекомендации по проектированию среды CLR не допустают нестатических полей. Для статических полей доступ к значениям статических полей можно получить только с помощью [расширения разметки x:Static](xstatic-markup-extension.md). в этом случае не выполняется никаких специальных действий в определении CLR для предоставления поля для использования в [x:Static](xstatic-markup-extension.md) .

## <a name="attachable-members"></a>Присоединяемые члены

Присоединяемые члены предоставляются XAML через шаблон метода доступа для определяющего типа. Сам определяющий тип не обязательно должен быть доступен для использования в XAML как объект. На самом деле, распространенным шаблоном является объявление класса службы, роль которого заключается в том, чтобы присоединить присоединяемый член и реализовать соответствующие поведения, но не обслуживает другие функции, такие как представление пользовательского интерфейса. В следующих разделах местозаполнитель *PropertyName* представляет имя присоединяемого члена. Это имя должно быть допустимым в [грамматике имяxaml](xamlname-grammar.md).

Соблюдайте осторожность при конфликтах имен между этими шаблонами и другими методами типа. Если существует элемент, совпадающий с одним из шаблонов, он может быть интерпретирован обработчиком XAML как присоединяемый путь использования члена, даже если это не ваша цель.

#### <a name="the-getpropertyname-accessor"></a>Метод доступа ИмяСвойства

Сигнатура для `GetPropertyName` метода доступа должна быть такой:

`public static object GetPropertyName(object target)`

- Объект `target` можно указать как более конкретный тип в реализации. Его можно использовать для определения области использования присоединяемого члена; использование за пределами предполагаемой области действия приведет к созданию недопустимых исключений приведения, которые затем выводятся в результате ошибки синтаксического анализа XAML. Имя параметра `target` не является обязательным, но `target` в большинстве реализаций оно называется по соглашению.

- Возвращаемое значение можно указать как более конкретный тип в реализации.

Чтобы обеспечить поддержку <xref:System.ComponentModel.TypeConverter> синтаксиса текста для присоединяемого элемента, примените к нему доступ <xref:System.ComponentModel.TypeConverterAttribute> `GetPropertyName` . Применение к `get` вместо этого `set` может показаться не интуитивно понятным; однако это соглашение может поддерживать концепцию присоединяемых членов только для чтения, которые являются сериализуемыми, что полезно в сценариях конструктора.

#### <a name="the-setpropertyname-accessor"></a>Метод доступа Сетпропертинаме

Сигнатура для `SetPropertyName` метода доступа должна быть такой:

`public static void SetPropertyName(object target, object value)`

- `target`Объект может быть указан в реализации в качестве более конкретного типа с той же логикой и последствиями, как описано в предыдущем разделе.

- Объект `value` можно указать как более конкретный тип в реализации.

Помните, что значение этого метода является входными данными, поступающими от использования XAML, обычно в форме атрибута. В форме атрибута должна быть поддержка преобразователя значений для текстового синтаксиса, и атрибут для `GetPropertyName` метода доступа s.

### <a name="attachable-member-stores"></a>Хранилища присоединяемых членов

Методы доступа обычно недостаточно для предоставления средств для размещения значений присоединяемых членов в графе объектов, а также для извлечения значений из графа объектов и их правильной сериализации. Чтобы обеспечить эту функциональность, `target` объекты в предыдущих сигнатурах метода доступа должны иметь возможность хранить значения. Механизм хранения должен соответствовать принципу присоединяемого члена, который прикрепляется к целевым объектам, в которых присоединяемый элемент отсутствует в списке членов. Службы XAML .NET предоставляют метод реализации для присоединяемых хранилищ членов через API-интерфейсы <xref:System.Xaml.IAttachedPropertyStore> и <xref:System.Xaml.AttachablePropertyServices> . <xref:System.Xaml.IAttachedPropertyStore> используется модулями записи XAML для обнаружения реализации хранилища и должен быть реализован в типе, который является методом `target` доступа. Статические <xref:System.Xaml.AttachablePropertyServices> API-интерфейсы используются в теле методов доступа и ссылаются на присоединяемый член по его свойству <xref:System.Xaml.AttachableMemberIdentifier> .

## <a name="xaml-related-clr-attributes"></a>Связанные с XAML атрибуты среды CLR

Правильное присвоение атрибутов типам, членам и сборкам важно для передачи сведений о системе типов XAML в службы .NET XAML. Создание отчетов о системе типов XAML имеет смысл, если применяется одна из следующих ситуаций.

- Вы планируете использовать типы для систем XAML, которые непосредственно основаны на средствах чтения XAML служб XAML .NET и модулях записи XAML.
- Вы определяете или используете платформу, использующую XAML, основанную на этих средствах чтения и записи XAML.

Список всех атрибутов, связанных с XAML, которые относятся к поддержке XAML пользовательских типов, см. в разделе связанные с XAML [атрибуты среды CLR для пользовательских типов и библиотек](clr-attributes-with-custom-types-and-libraries.md).

## <a name="usage"></a>Использование

Для использования пользовательских типов необходимо, чтобы автор разметки сопоставлял префикс для сборки и пространство имен CLR, которое содержит пользовательский тип. Эта процедура не описана в этом разделе.

## <a name="access-level"></a>Уровень доступа

XAML предоставляет средства для загрузки и создания экземпляров типов, имеющих `internal` уровень доступа. Эта возможность предоставляется, чтобы пользовательский код мог определять собственные типы, а затем создавать экземпляры этих классов из разметки, которая также является частью одной и той же области пользовательского кода.

Примером из WPF является каждый раз, когда пользовательский код определяет <xref:System.Windows.Controls.UserControl> , который предназначен для оптимизации поведения пользовательского интерфейса, но не является частью любого возможного механизма расширения, который может быть подразумеваемым объявлением поддерживающего класса с `public` уровнем доступа. Такой объект <xref:System.Windows.Controls.UserControl> может быть объявлен с `internal` доступом, если резервный код компилируется в ту же сборку, из которой он ссылается как на тип XAML.

Для приложения, которое загружает XAML в режиме полного доверия и использует <xref:System.Xaml.XamlObjectWriter> , Загрузка классов с `internal` уровнем доступа всегда включена.

Для приложения, которое загружает XAML в режиме частичного доверия, можно управлять характеристиками уровня доступа с помощью <xref:System.Xaml.Permissions.XamlAccessLevel> API. Кроме того, механизмы отсрочки (например, система шаблонов WPF) должны иметь возможность распространять любые разрешения уровня доступа и сохранять их для выполнения в конечном итоге. Это осуществляется внутренним образом путем передачи <xref:System.Xaml.Permissions.XamlAccessLevel> информации.

### <a name="wpf-implementation"></a>Реализация WPF

XAML WPF использует модель доступа с частичным доверием, где при загрузке BAML в режиме частичного доверия доступ ограничен <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> для сборки, являющейся источником BAML. Для РБП WPF использует <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> в качестве механизма для передачи сведений об уровне доступа.

В терминологии WPF XAML *внутренний тип* — это тип, определяемый той же сборкой, которая также включает ссылающийся XAML. Такой тип можно сопоставить с помощью пространства имен XAML, которое намеренно опускает сборку = часть сопоставления, например `xmlns:local="clr-namespace:WPFApplication1"` . Если BAML ссылается на внутренний тип, а этот тип имеет `internal` уровень доступа, то создается `GeneratedInternalTypeHelper` класс для сборки. Если вы хотите избежать `GeneratedInternalTypeHelper` , необходимо либо использовать `public` уровень доступа, либо отнести соответствующий класс к отдельной сборке и сделать ее зависимой.

## <a name="see-also"></a>См. также

- [Относящиеся к XAML атрибуты среды CLR для пользовательских типов и библиотек](clr-attributes-with-custom-types-and-libraries.md)
- [Службы XAML](../../../api/index.md)
