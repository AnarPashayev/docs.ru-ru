---
title: Контекст схемы языка XAML по умолчанию и контекст схемы языка XAML WPF
ms.date: 03/30/2017
ms.assetid: 04e06a15-09b3-4210-9bdf-9a64c2eccb83
ms.openlocfilehash: 2e92372de61230a98a02282cc28fc3f479cd94eb
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "81433082"
---
# <a name="default-xaml-schema-context-and-wpf-xaml-schema-context"></a><span data-ttu-id="4accb-102">Контекст схемы языка XAML по умолчанию и контекст схемы языка XAML WPF</span><span class="sxs-lookup"><span data-stu-id="4accb-102">Default XAML Schema Context and WPF XAML Schema Context</span></span>
<span data-ttu-id="4accb-103">Контекст схемы XAML — это концептуальная сущность, которая квалифицирует то, как производство XAML, использующего определенный словарь XAML, взаимодействует с поведением написания объектов, включая то, как разрешится отображение шрифтов, как загружаются сборки, как интерпретируются определенные настройки чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="4accb-103">A XAML schema context is a conceptual entity that qualifies how a XAML production that uses a particular XAML vocabulary interacts with the object writing behavior, including how type mapping resolves, how assemblies are loaded, how certain reader and writer settings are interpreted.</span></span> <span data-ttu-id="4accb-104">В этой теме описаны особенности службы .NET XAML и связанный с ним контекст схемы XAML по умолчанию, основанный на системе типа CLR.</span><span class="sxs-lookup"><span data-stu-id="4accb-104">This topic describes the features of .NET XAML Services and the associated default XAML schema context, which is based on the CLR type system.</span></span> <span data-ttu-id="4accb-105">В этой теме также описывается контекст схемы XAML, который используется для WPF.</span><span class="sxs-lookup"><span data-stu-id="4accb-105">This topic also describes the XAML schema context that is used for WPF.</span></span>

## <a name="default-xaml-schema-context"></a><span data-ttu-id="4accb-106">Контекст схемы XAML по умолчанию</span><span class="sxs-lookup"><span data-stu-id="4accb-106">Default XAML Schema Context</span></span>

<span data-ttu-id="4accb-107">.NET XAML Services реализует и использует контекст схемы XAML по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4accb-107">.NET XAML Services both implements and uses a default XAML schema context.</span></span> <span data-ttu-id="4accb-108">Поведение контекста схемы XAML по умолчанию не всегда <xref:System.Xaml.XamlSchemaContext> полностью отображается в API класса.</span><span class="sxs-lookup"><span data-stu-id="4accb-108">The default XAML schema context behavior is not always fully visible in the API of the <xref:System.Xaml.XamlSchemaContext> class.</span></span> <span data-ttu-id="4accb-109">Однако во многих случаях поведение, на которое влияет контекст схемы XAML по умолчанию, можно наблюдать через <xref:System.Xaml.XamlMember> <xref:System.Xaml.XamlType>общий API системы типа XAML, например, членов или aPI, разоблочаемых на считывателях XAML и авторах XAML, использующих контекст схемы XAML по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4accb-109">However, in many cases the behavior that the default XAML schema context influences is observable through common API of the XAML type system, such as members of <xref:System.Xaml.XamlMember> or <xref:System.Xaml.XamlType>, or through APIs exposed on XAML readers and XAML writers that are using the default XAML schema context.</span></span>

<span data-ttu-id="4accb-110">Можно <xref:System.Xaml.XamlSchemaContext> создать, который инкапсулирует поведение по умолчанию, вызывая <xref:System.Xaml.XamlSchemaContext> конструктор.</span><span class="sxs-lookup"><span data-stu-id="4accb-110">You can create a <xref:System.Xaml.XamlSchemaContext> that encapsulates the default behavior by calling the <xref:System.Xaml.XamlSchemaContext> constructor.</span></span> <span data-ttu-id="4accb-111">Это явно создает контекст схемы XAML по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4accb-111">This explicitly creates the default XAML schema context.</span></span> <span data-ttu-id="4accb-112">Тот же контекст схемы XAML по умолчанию создается неявно, если вы инициализируете считыватель XAML или xAML writer с помощью AIS, которые явно не принимают параметр <xref:System.Xaml.XamlSchemaContext> ввода.</span><span class="sxs-lookup"><span data-stu-id="4accb-112">The same default XAML schema context is created implicitly, if you initialize a XAML reader or XAML writer using APIs that do not explicitly take a <xref:System.Xaml.XamlSchemaContext> input parameter.</span></span>

<span data-ttu-id="4accb-113">Контекст схемы XAML по умолчанию опирается на отражение CLR для своего поведения отображения типов.</span><span class="sxs-lookup"><span data-stu-id="4accb-113">The default XAML schema context relies on CLR reflection for its type mapping behavior.</span></span> <span data-ttu-id="4accb-114">Это включает в себя <xref:System.Type>изучение <xref:System.Reflection.PropertyInfo> определения <xref:System.Reflection.MethodInfo>CLR , и связанных или .</span><span class="sxs-lookup"><span data-stu-id="4accb-114">This includes examining the defining CLR <xref:System.Type>, and related <xref:System.Reflection.PropertyInfo> or <xref:System.Reflection.MethodInfo>.</span></span> <span data-ttu-id="4accb-115">Кроме того, атрибуция CLR на типы или члены используется для заполнения специфики для типа XAML или информации о членах XAML, которая использует тип поддержки CLR.</span><span class="sxs-lookup"><span data-stu-id="4accb-115">Also, CLR attribution on types or members is used in order to fill in the specifics for XAML type or XAML member information that uses the CLR backing type.</span></span> <span data-ttu-id="4accb-116">Контекст схемы XAML по умолчанию не требует методов расширения системы типов, таких как `Invoker` шаблон, поскольку необходимая информация доступна из системы типа CLR.</span><span class="sxs-lookup"><span data-stu-id="4accb-116">The default XAML schema context does not require type system extension techniques such as the `Invoker` pattern, because the necessary information is available from the CLR type system.</span></span>

<span data-ttu-id="4accb-117">Для логики загрузки сборки контекст схемы XAML по умолчанию основывается главным образом на любых значениях сборки, предусмотренных в отображении пространства имен XAML.</span><span class="sxs-lookup"><span data-stu-id="4accb-117">For assembly loading logic, the default XAML schema context relies mainly on any assembly values provided in XAML namespace mappings.</span></span> <span data-ttu-id="4accb-118">Кроме <xref:System.Xaml.XamlReaderSettings.LocalAssembly%2A> того, можно намекнуть на сборку для загрузки, для сценариев, таких как загрузка внутренних типов.</span><span class="sxs-lookup"><span data-stu-id="4accb-118">Also, <xref:System.Xaml.XamlReaderSettings.LocalAssembly%2A> can hint an assembly to load, for scenarios such as loading internal types.</span></span>

## <a name="wpf-xaml-schema-context"></a><span data-ttu-id="4accb-119">WPF XAML Схема Контекст</span><span class="sxs-lookup"><span data-stu-id="4accb-119">WPF XAML Schema Context</span></span>

<span data-ttu-id="4accb-120">Контекст схемы WPF XAML описан в этой теме, поскольку реализация WPF представляет интересную иллюстрацию видов функций, которые могут быть введены путем внедрения контекста схемы XAML по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4accb-120">The WPF XAML schema context is described in this topic because the WPF implementation provides an interesting illustration of the kinds of features that can be introduced by implementing a non-default XAML schema context.</span></span> <span data-ttu-id="4accb-121">Кроме того, концепция контекста схемы XAML не очень подробно обсуждается в документации WPF, которая касается WPF XAML; поведение, которое позволяет контекст схемы XAML, может быть полностью понятнее только в том случае, если оно интегрировано с обсуждением того, как работает контекст схемы XAML по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4accb-121">Also, the XAML schema context concept is not discussed very much in the WPF documentation that addresses WPF XAML; the behavior that the XAML schema context enables might only be fully understandable if integrated with a discussion of how the default XAML schema context works.</span></span> <span data-ttu-id="4accb-122">Контекст схемы WPF XAML реализует следующее поведение.</span><span class="sxs-lookup"><span data-stu-id="4accb-122">The WPF XAML schema context implements the following behavior.</span></span>

<span data-ttu-id="4accb-123">**Осматриваемый переопределяет:** WPF имеет несколько моделей содержимого для XAML, где <xref:System.Windows.Markup.ContentPropertyAttribute> есть свойства содержимого XAML, которые функционируют без отнесенных.</span><span class="sxs-lookup"><span data-stu-id="4accb-123">**Lookup overrides:** WPF has a few content models for XAML where there are XAML content properties that function without being <xref:System.Windows.Markup.ContentPropertyAttribute> attributed.</span></span> <span data-ttu-id="4accb-124"><xref:System.Xaml.XamlType.LookupContentProperty%2A>переопределения для WPF реализовать это поведение.</span><span class="sxs-lookup"><span data-stu-id="4accb-124"><xref:System.Xaml.XamlType.LookupContentProperty%2A> overrides for WPF implement this behavior.</span></span>

<span data-ttu-id="4accb-125">**Отсрочка для выражений WPF:** WPF имеет несколько классов выражений, которые откладывают значение до тех пор, пока не доступен контекст времени выполнения.</span><span class="sxs-lookup"><span data-stu-id="4accb-125">**Deferral for WPF expressions:** WPF features several expression classes that defer a value until a runtime context is available.</span></span> <span data-ttu-id="4accb-126">Кроме того, расширение шаблона — это поведение в срок выполнения, которое опирается на методы отсрочки.</span><span class="sxs-lookup"><span data-stu-id="4accb-126">Also, template expansion is a runtime behavior that relies on deferral techniques.</span></span>

<span data-ttu-id="4accb-127">**Оптимизация поиска системы типа:** WPF имеет обширную словарную лексику XAML и объектную модель, включая определения членов базового класса, которые наследуют буквально сотни классов, определяемых WPF.</span><span class="sxs-lookup"><span data-stu-id="4accb-127">**Type system lookup optimizations:** WPF has an extensive XAML vocabulary and object model, including base class member definitions that inherit to literally hundreds of WPF-defined classes.</span></span> <span data-ttu-id="4accb-128">Кроме того, сам WPF распространяется на несколько собраний.</span><span class="sxs-lookup"><span data-stu-id="4accb-128">Also, WPF itself is spread across several assemblies.</span></span> <span data-ttu-id="4accb-129">WPF оптимизирует поиск типа, используя таблицы поиска и другие методы.</span><span class="sxs-lookup"><span data-stu-id="4accb-129">WPF optimizes its type lookup using lookup tables and other techniques.</span></span> <span data-ttu-id="4accb-130">Это обеспечивает улучшение производительности по сравнению с контекстом схемы XAML по умолчанию и его поиском типа на основе CLR.</span><span class="sxs-lookup"><span data-stu-id="4accb-130">This provides performance improvements over the default XAML schema context and its CLR-based type lookup.</span></span> <span data-ttu-id="4accb-131">В тех случаях, когда типы не существуют в таблице поиска, поведение использует методы контекста схемы XAML, похожие на контекст схемы XAML по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4accb-131">In cases where types do not exist in a lookup table, the behavior uses XAML schema context techniques that are similar to the default XAML schema context.</span></span>

<span data-ttu-id="4accb-132">**Расширение XamlType и XamlMember:** WPF расширяет концепции свойств с свойствами зависимости и понятиями событий с маршрутными событиями.</span><span class="sxs-lookup"><span data-stu-id="4accb-132">**XamlType and XamlMember extension:** WPF extends property concepts with dependency properties, and event concepts with routed events.</span></span> <span data-ttu-id="4accb-133">Чтобы придать этим концепциям большую видимость для операций обработки XAML, WPF расширяет <xref:System.Xaml.XamlType> и <xref:System.Xaml.XamlMember>добавляет внутренние свойства, которые сообщают свойство зависимости и маршрутные характеристики событий.</span><span class="sxs-lookup"><span data-stu-id="4accb-133">To give these concepts greater visibility for XAML processing operations, WPF extends <xref:System.Xaml.XamlType> and <xref:System.Xaml.XamlMember>, and adds internal properties that report dependency property and routed event characteristics.</span></span>

### <a name="accessing-the-wpf-xaml-schema-context"></a><span data-ttu-id="4accb-134">Доступ к контексту схемы WPF XAML</span><span class="sxs-lookup"><span data-stu-id="4accb-134">Accessing the WPF XAML Schema Context</span></span>

<span data-ttu-id="4accb-135">Если вы используете методы XAML, <xref:System.Windows.Markup.XamlReader?displayProperty=nameWithType> основанные на WPF или, <xref:System.Windows.Markup.XamlWriter?displayProperty=nameWithType>контекст схемы WPF XAML уже используется на тех реализациях XAML reader и XAML..</span><span class="sxs-lookup"><span data-stu-id="4accb-135">If you are using XAML techniques that are based on the WPF <xref:System.Windows.Markup.XamlReader?displayProperty=nameWithType> or <xref:System.Windows.Markup.XamlWriter?displayProperty=nameWithType>, the WPF XAML schema context is already in use on those XAML reader and XAML writer implementations.</span></span>

<span data-ttu-id="4accb-136">Если вы используете другие реализации XAML reader или XAML writer, которые не инициализируются с контекстом схемы WPF XAML, вы можете получить рабочий контекст схемы WPF XAML от <xref:System.Windows.Markup.XamlReader.GetWpfSchemaContext%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4accb-136">If you are using other XAML reader or XAML writer implementations that do not initialize with the WPF XAML schema context, you may be able to get a working WPF XAML schema context from <xref:System.Windows.Markup.XamlReader.GetWpfSchemaContext%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4accb-137">Затем это значение можно использовать в качестве инициализации для другого API, использующему <xref:System.Xaml.XamlSchemaContext>a.</span><span class="sxs-lookup"><span data-stu-id="4accb-137">You can then use this value as initialization for other API that use a <xref:System.Xaml.XamlSchemaContext>.</span></span> <span data-ttu-id="4accb-138">Например, можно <xref:System.Xaml.XamlXmlReader.%23ctor%2A> позвонить для инициализации и пройти контекст схемы WPF XAML.</span><span class="sxs-lookup"><span data-stu-id="4accb-138">For example, you could call <xref:System.Xaml.XamlXmlReader.%23ctor%2A> for initialization and pass the WPF XAML schema context.</span></span> <span data-ttu-id="4accb-139">Или можно использовать контекст схемы WPF XAML для операций системы типа XAML.</span><span class="sxs-lookup"><span data-stu-id="4accb-139">Or you could use the WPF XAML schema context for XAML type system operations.</span></span> <span data-ttu-id="4accb-140">Это может включать в <xref:System.Xaml.XamlType> себя <xref:System.Xaml.XamlMember>строительство <xref:System.Xaml.XamlSchemaContext.GetXamlType%2A?displayProperty=nameWithType>инициализации или , или вызова .</span><span class="sxs-lookup"><span data-stu-id="4accb-140">This might include construction initialization of a <xref:System.Xaml.XamlType> or <xref:System.Xaml.XamlMember>, or calling <xref:System.Xaml.XamlSchemaContext.GetXamlType%2A?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="4accb-141">Обратите внимание, что если вы получаете доступ к некоторым аспектам WPF XAML с точки зрения чистого потока узлов XAML, некоторые возможности платформы WPF, возможно, еще не действовали.</span><span class="sxs-lookup"><span data-stu-id="4accb-141">Note that if you access certain aspects of WPF XAML from a pure XAML node stream perspectives, some of the WPF framework capabilities may not have acted yet.</span></span> <span data-ttu-id="4accb-142">Например, шаблоны WPF для элементов управления еще не применяются.</span><span class="sxs-lookup"><span data-stu-id="4accb-142">For example, WPF templates for controls are not yet applied.</span></span> <span data-ttu-id="4accb-143">Таким образом, если вы получаете доступ к свойству, которое во время выполнения может быть заселено полным визуальным деревом, можно увидеть только значение свойства, которое ссылается на шаблон.</span><span class="sxs-lookup"><span data-stu-id="4accb-143">Thus if you access a property that at run time might be populated with a full visual tree, you might only see a property value that references a template.</span></span> <span data-ttu-id="4accb-144">Контекст службы, предусмотренный для расширений разметки WPF, также может быть неточным, если он предоставляется из ситуации, не работающей, и может привести к исключениям при попытке написать график объекта.</span><span class="sxs-lookup"><span data-stu-id="4accb-144">The service context provided for WPF markup extensions might also not be accurate if provided from a non-runtime situation, and can result in exceptions when attempting to write an object graph.</span></span>

## <a name="xaml-and-assembly-loading"></a><span data-ttu-id="4accb-145">XAML и сборка загрузки</span><span class="sxs-lookup"><span data-stu-id="4accb-145">XAML and Assembly Loading</span></span>

<span data-ttu-id="4accb-146">Загрузка сборки для XAML и .NET XAML Services <xref:System.AppDomain>интегрируется с концепцией CLR, определяемой .</span><span class="sxs-lookup"><span data-stu-id="4accb-146">Assembly loading for XAML and .NET XAML Services integrates with the CLR-defined concept of <xref:System.AppDomain>.</span></span> <span data-ttu-id="4accb-147">Контекст схемы XAML интерпретирует, как загрузить сборки или найти типы во время <xref:System.AppDomain> выполнения или время проектирования, основываясь на использовании и других факторах.</span><span class="sxs-lookup"><span data-stu-id="4accb-147">A XAML schema context interprets how to either load assemblies or find types at run time or design time, based on the use of <xref:System.AppDomain> and other factors.</span></span> <span data-ttu-id="4accb-148">Логика немного отличается в зависимости от того, XAML является свободным XAML для считывателя XAML, является XAML, составленный в DLL, `XamlBuildTask`или BAML генерируется `PresentationBuildTask`WPF.</span><span class="sxs-lookup"><span data-stu-id="4accb-148">The logic is slightly different depending on whether the XAML is loose XAML for a XAML reader, is XAML compiled into a DLL by `XamlBuildTask`, or is BAML generated by WPF's `PresentationBuildTask`.</span></span>

<span data-ttu-id="4accb-149">Контекст схемы XAML для WPF интегрируется с моделью применения <xref:System.AppDomain> WPF, которая, в свою очередь, использует, а также другие факторы, которые являются деталями реализации WPF.</span><span class="sxs-lookup"><span data-stu-id="4accb-149">The XAML schema context for WPF integrates with the WPF application model, which in turn uses <xref:System.AppDomain> as well as other factors that are WPF implementation details.</span></span>

#### <a name="xaml-reader-input-loose-xaml"></a><span data-ttu-id="4accb-150">Ввод чтения XAML (свободный XAML)</span><span class="sxs-lookup"><span data-stu-id="4accb-150">XAML reader input (loose XAML)</span></span>

01. <span data-ttu-id="4accb-151">Контекст схемы XAML итерируется <xref:System.AppDomain> через приложение, ища уже загруженную сборку, которая соответствует всем аспектам имени, начиная с самой недавно загруженной сборки.</span><span class="sxs-lookup"><span data-stu-id="4accb-151">The XAML schema context iterates through the <xref:System.AppDomain> of the application, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.</span></span> <span data-ttu-id="4accb-152">При обнаружении совпадения эта сборка используется для разрешения.</span><span class="sxs-lookup"><span data-stu-id="4accb-152">If a match is found, that assembly is used for resolution.</span></span>

02. <span data-ttu-id="4accb-153">В противном случае, один из <xref:System.Reflection.Assembly> следующих методов, основанных на CLR API, используется для загрузки сборки:</span><span class="sxs-lookup"><span data-stu-id="4accb-153">Otherwise, one of the following techniques based on CLR <xref:System.Reflection.Assembly> API are used to load an assembly:</span></span>

    - <span data-ttu-id="4accb-154">Если имя квалифицировано в отображении, позвоните <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> по квалифицированной фамилии.</span><span class="sxs-lookup"><span data-stu-id="4accb-154">If the name is qualified in the mapping, call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> on the qualified name.</span></span>

    - <span data-ttu-id="4accb-155">Если предыдущий шаг не удается, используйте короткое имя <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>(и маркер клавиши общего пользования, если он присутствует), чтобы вызвать .</span><span class="sxs-lookup"><span data-stu-id="4accb-155">If the previous step fails, use the short name (and public key token if present) to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>

    - <span data-ttu-id="4accb-156">Если имя неквалифицировано в отображении, позвоните <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4accb-156">If the name is unqualified in the mapping, call <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>.</span></span>

#### <a name="xamlbuildtask"></a><span data-ttu-id="4accb-157">XamlBuildTask</span><span class="sxs-lookup"><span data-stu-id="4accb-157">XamlBuildTask</span></span>

<span data-ttu-id="4accb-158">`XamlBuildTask`используется для Фонда связи Windows (WCF) и Фонда рабочего процесса Windows.</span><span class="sxs-lookup"><span data-stu-id="4accb-158">`XamlBuildTask` is used for Windows Communication Foundation (WCF) and Windows Workflow Foundation.</span></span>

<span data-ttu-id="4accb-159">Обратите внимание, что `XamlBuildTask` ссылки на сборку всегда полностью квалифицированы.</span><span class="sxs-lookup"><span data-stu-id="4accb-159">Note that assembly references through `XamlBuildTask` are always fully qualified.</span></span>

1. <span data-ttu-id="4accb-160">Позвоните <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> по квалифицированной фамилии.</span><span class="sxs-lookup"><span data-stu-id="4accb-160">Call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> on the qualified name.</span></span>

2. <span data-ttu-id="4accb-161">Если предыдущий шаг не удается, используйте короткое имя <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>(и маркер клавиши общего пользования, если он присутствует), чтобы вызвать .</span><span class="sxs-lookup"><span data-stu-id="4accb-161">If the previous step fails, use the short name (and public key token if present) to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>

#### <a name="baml-presentationbuildtask"></a><span data-ttu-id="4accb-162">БАМЛ (ПрезентацияBuildTask)</span><span class="sxs-lookup"><span data-stu-id="4accb-162">BAML (PresentationBuildTask)</span></span>

<span data-ttu-id="4accb-163">Сборка ДЛЯ BAML состоит из двух аспектов: загрузка начальной сборки, содержащей BAML в качестве компонента, и загрузка сборки для поддержки типов для любых типов, на которые ссылается производство BAML.</span><span class="sxs-lookup"><span data-stu-id="4accb-163">There are two aspects to assembly-loading for BAML: loading the initial assembly that contains the BAML as a component, and loading the type-backing assemblies for any types referenced by the BAML production.</span></span>

##### <a name="assembly-load-for-initial-markup"></a><span data-ttu-id="4accb-164">Сборочная нагрузка для первоначальной разметки:</span><span class="sxs-lookup"><span data-stu-id="4accb-164">Assembly load for initial markup:</span></span>

<span data-ttu-id="4accb-165">Ссылка на сборку для загрузки разметки всегда неквалифицирована.</span><span class="sxs-lookup"><span data-stu-id="4accb-165">The reference to the assembly to load the markup from is always unqualified.</span></span>

1. <span data-ttu-id="4accb-166">Контекст схемы WPF XAML итерируется через <xref:System.AppDomain> приложение WPF, ища уже загруженную сборку, которая соответствует всем аспектам имени, начиная с самой недавно загруженной сборки.</span><span class="sxs-lookup"><span data-stu-id="4accb-166">The WPF XAML schema context iterates through the <xref:System.AppDomain> of the WPF application, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.</span></span> <span data-ttu-id="4accb-167">При обнаружении совпадения эта сборка используется для разрешения.</span><span class="sxs-lookup"><span data-stu-id="4accb-167">If a match is found, that assembly is used for resolution.</span></span>

2. <span data-ttu-id="4accb-168">Если предыдущий шаг не удается, используйте короткое имя <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>(и маркер клавиши общего пользования, если он присутствует), чтобы вызвать .</span><span class="sxs-lookup"><span data-stu-id="4accb-168">If the previous step fails, use the short name (and public key token if present) to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>

##### <a name="assembly-references-by-baml-types"></a><span data-ttu-id="4accb-169">Ссылки на сборку по типам BAML:</span><span class="sxs-lookup"><span data-stu-id="4accb-169">Assembly references by BAML types:</span></span>

<span data-ttu-id="4accb-170">Ссылки на сборку типов, используемых в производстве BAML, всегда полностью квалифицированы, как выход задачи сборки.</span><span class="sxs-lookup"><span data-stu-id="4accb-170">Assembly references for types used in the BAML production are always fully qualified, as an output of the build task.</span></span>

01. <span data-ttu-id="4accb-171">Контекст схемы WPF XAML итерируется через <xref:System.AppDomain> приложение WPF, ища уже загруженную сборку, которая соответствует всем аспектам имени, начиная с самой недавно загруженной сборки.</span><span class="sxs-lookup"><span data-stu-id="4accb-171">The WPF XAML schema context iterates through the <xref:System.AppDomain> of the WPF application, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.</span></span> <span data-ttu-id="4accb-172">При обнаружении совпадения эта сборка используется для разрешения.</span><span class="sxs-lookup"><span data-stu-id="4accb-172">If a match is found, that assembly is used for resolution.</span></span>

02. <span data-ttu-id="4accb-173">В противном случае для загрузки сборки используется один из следующих методов:</span><span class="sxs-lookup"><span data-stu-id="4accb-173">Otherwise, one of the following techniques is used to load an assembly:</span></span>

    - <span data-ttu-id="4accb-174">Позвоните <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> по квалифицированной фамилии.</span><span class="sxs-lookup"><span data-stu-id="4accb-174">Call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> on the qualified name.</span></span>
  
    - <span data-ttu-id="4accb-175">Если короткое имя и комбинация маркеров общего ключа совпадают с сборкой, из которую был загружен BAML, используйте эту сборку.</span><span class="sxs-lookup"><span data-stu-id="4accb-175">If a short name + public key token combination match the assembly that the BAML was loaded from, use that assembly.</span></span>

    - <span data-ttu-id="4accb-176">Используйте короткое имя и <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>открытый маркер ключа для вызова.</span><span class="sxs-lookup"><span data-stu-id="4accb-176">Use short name + public key token to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>

## <a name="see-also"></a><span data-ttu-id="4accb-177">См. также</span><span class="sxs-lookup"><span data-stu-id="4accb-177">See also</span></span>

- [<span data-ttu-id="4accb-178">Общее представление о понятиях и структурах потока узлов XAML</span><span class="sxs-lookup"><span data-stu-id="4accb-178">Understanding XAML Node Stream Structures and Concepts</span></span>](understanding-xaml-node-stream-structures-and-concepts.md)
