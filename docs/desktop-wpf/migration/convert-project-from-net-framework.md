---
title: Перенос приложений WPF в .NET Core 3.0
description: Узнайте, как перенести приложение Windows Presentation Foundation (WPF) в .NET Core 3.0.
author: mjrousos
ms.date: 09/12/2019
ms.author: mikerou
ms.openlocfilehash: fda4f618ddb4a3edbe6f2dd9fba0b10bc618e88d
ms.sourcegitcommit: 71b8f5a2108a0f1a4ef1d8d75c5b3e129ec5ca1e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/29/2020
ms.locfileid: "84201559"
---
# <a name="migrating-wpf-apps-to-net-core"></a><span data-ttu-id="b7c40-103">Перенос приложений WPF в .NET Core</span><span class="sxs-lookup"><span data-stu-id="b7c40-103">Migrating WPF apps to .NET Core</span></span>

<span data-ttu-id="b7c40-104">В этой статье рассматриваются шаги, необходимые для переноса приложения Windows Presentation Foundation (WPF) из .NET Framework в .NET Core 3.0.</span><span class="sxs-lookup"><span data-stu-id="b7c40-104">This article covers the steps necessary to migrate a Windows Presentation Foundation (WPF) app from .NET Framework to .NET Core 3.0.</span></span> <span data-ttu-id="b7c40-105">Если у вас нет приложения WPF, которое нужно перенести, но вы хотите испытать этот процесс, используйте пример приложения **Bean Trader**, доступный на [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span><span class="sxs-lookup"><span data-stu-id="b7c40-105">If you don't have a WPF app on hand to port, but would like to try out the process, you can use the **Bean Trader** sample app available on [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span></span> <span data-ttu-id="b7c40-106">Исходное приложение (для .NET Framework 4.7.2) доступно в папке NetFx\BeanTraderClient.</span><span class="sxs-lookup"><span data-stu-id="b7c40-106">The original app (targeting .NET Framework 4.7.2) is available in the NetFx\BeanTraderClient folder.</span></span> <span data-ttu-id="b7c40-107">Сначала мы объясним основные шаги, необходимые для переноса приложений, а затем рассмотрим конкретные изменения, применимые к образцу **Bean Trader**.</span><span class="sxs-lookup"><span data-stu-id="b7c40-107">First we'll explain the steps necessary to port apps in general, and then we'll walk through the specific changes that apply to the **Bean Trader** sample.</span></span>

[!INCLUDE [desktop guide under construction](../../../includes/desktop-guide-preview-note.md)]

<span data-ttu-id="b7c40-108">Для перехода на .NET Core необходимо сначала:</span><span class="sxs-lookup"><span data-stu-id="b7c40-108">To migrate to .NET Core, you must first:</span></span>

01. <span data-ttu-id="b7c40-109">Изучить и обновить зависимости NuGet:</span><span class="sxs-lookup"><span data-stu-id="b7c40-109">Understand and update NuGet dependencies:</span></span>

    01. <span data-ttu-id="b7c40-110">Обновите зависимости NuGet, чтобы использовать формат `<PackageReference>`.</span><span class="sxs-lookup"><span data-stu-id="b7c40-110">Upgrade NuGet dependencies to use the `<PackageReference>` format.</span></span>
    01. <span data-ttu-id="b7c40-111">Ознакомьтесь с зависимостями NuGet верхнего уровня для совместимости .NET Core или .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="b7c40-111">Review top-level NuGet dependencies for .NET Core or .NET Standard compatibility.</span></span>
    01. <span data-ttu-id="b7c40-112">Обновите пакеты NuGet до более новых версий.</span><span class="sxs-lookup"><span data-stu-id="b7c40-112">Upgrade NuGet packages to newer versions.</span></span>
    01. <span data-ttu-id="b7c40-113">Используйте [Анализатор переносимости .NET](../../standard/analyzers/portability-analyzer.md) для изучения зависимостей .NET.</span><span class="sxs-lookup"><span data-stu-id="b7c40-113">Use the [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) to understand .NET dependencies.</span></span>

01. <span data-ttu-id="b7c40-114">Перенести файл проекта в новый формат в стиле SDK:</span><span class="sxs-lookup"><span data-stu-id="b7c40-114">Migrate the project file to the new SDK-style format:</span></span>

    01. <span data-ttu-id="b7c40-115">Укажите, следует ли ориентироваться на .NET Core и .NET Framework или только на .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c40-115">Choose whether to target both .NET Core and .NET Framework, or only .NET Core.</span></span>
    01. <span data-ttu-id="b7c40-116">Скопируйте соответствующие свойства и элементы файла проекта в новый файл проекта.</span><span class="sxs-lookup"><span data-stu-id="b7c40-116">Copy relevant project file properties and items to the new project file.</span></span>

01. <span data-ttu-id="b7c40-117">Устранить проблемы сборки:</span><span class="sxs-lookup"><span data-stu-id="b7c40-117">Fix build issues:</span></span>

    01. <span data-ttu-id="b7c40-118">Добавьте ссылку на пакет [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/).</span><span class="sxs-lookup"><span data-stu-id="b7c40-118">Add a reference to the [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) package.</span></span>
    01. <span data-ttu-id="b7c40-119">Найдите и исправьте различие на уровне API.</span><span class="sxs-lookup"><span data-stu-id="b7c40-119">Find and fix API-level differences.</span></span>
    01. <span data-ttu-id="b7c40-120">Удалите разделы *app.config*, отличные от `appSettings` или `connectionStrings`.</span><span class="sxs-lookup"><span data-stu-id="b7c40-120">Remove *app.config* sections other than `appSettings` or `connectionStrings`.</span></span>
    01. <span data-ttu-id="b7c40-121">При необходимости повторно создайте сформированный код.</span><span class="sxs-lookup"><span data-stu-id="b7c40-121">Regenerate generated code, if necessary.</span></span>

01. <span data-ttu-id="b7c40-122">Протестировать среду выполнения:</span><span class="sxs-lookup"><span data-stu-id="b7c40-122">Runtime testing:</span></span>

    01. <span data-ttu-id="b7c40-123">Убедитесь, что перенесенное приложение работает правильно.</span><span class="sxs-lookup"><span data-stu-id="b7c40-123">Confirm the ported app works as expected.</span></span>
    01. <span data-ttu-id="b7c40-124">Берите во внимание исключения <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="b7c40-124">Beware of <xref:System.NotSupportedException> exceptions.</span></span>

## <a name="about-the-sample"></a><span data-ttu-id="b7c40-125">Сведения о примере</span><span class="sxs-lookup"><span data-stu-id="b7c40-125">About the sample</span></span>

<span data-ttu-id="b7c40-126">Эта статья ссылается на пример приложения [Bean Trader](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader), поскольку оно использует разнообразные зависимости, аналогичные тем, которые могут иметь реальные приложения WPF.</span><span class="sxs-lookup"><span data-stu-id="b7c40-126">This article references the [Bean Trader sample app](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) because it uses a variety of dependencies similar to those that real-world WPF apps might have.</span></span> <span data-ttu-id="b7c40-127">Приложение небольшое, однако задумывалось для повышения уровня по сравнению с "Hello World" с точки зрения сложности.</span><span class="sxs-lookup"><span data-stu-id="b7c40-127">The app isn't large, but is meant to be a step up from 'Hello World' in terms of complexity.</span></span> <span data-ttu-id="b7c40-128">Приложение демонстрирует некоторые проблемы, с которыми пользователи могут столкнуться при переносе реальных приложений.</span><span class="sxs-lookup"><span data-stu-id="b7c40-128">The app demonstrates some issues users may encounter while porting real apps.</span></span> <span data-ttu-id="b7c40-129">Приложение взаимодействует со службой WCF, поэтому для правильной работы необходимо также запустить проект BeanTraderServer (доступный в том же репозитории GitHub) и убедиться, что конфигурация BeanTraderClient указывает на правильную конечную точку.</span><span class="sxs-lookup"><span data-stu-id="b7c40-129">The app communicates with a WCF service, so for it to run properly, you'll also need to run the BeanTraderServer project (available in the same GitHub repository) and make sure the BeanTraderClient configuration points to the correct endpoint.</span></span> <span data-ttu-id="b7c40-130">(По умолчанию в примере предполагается, что сервер работает на том же компьютере в `http://localhost:8090`, что будет таковым при запуске BeanTraderServer локально.)</span><span class="sxs-lookup"><span data-stu-id="b7c40-130">(By default, the sample assumes the server is running on the same machine at `http://localhost:8090`, which will be true if you launch BeanTraderServer locally.)</span></span>

<span data-ttu-id="b7c40-131">Помните, что этот пример приложения предназначен для демонстрации проблем и решений по переносу в .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c40-131">Keep in mind that this sample app is meant to demonstrate .NET Core porting challenges and solutions.</span></span> <span data-ttu-id="b7c40-132">Он не предназначен для демонстрации рекомендаций по использованию WPF.</span><span class="sxs-lookup"><span data-stu-id="b7c40-132">It's not meant to demonstrate WPF best practices.</span></span> <span data-ttu-id="b7c40-133">На самом деле он намеренно содержит некоторые антишаблоны, чтобы убедиться в том, что во время переноса вы столкнетесь по крайней мере с парой интересных проблем.</span><span class="sxs-lookup"><span data-stu-id="b7c40-133">In fact, it deliberately includes some anti-patterns to make sure you come across at least a couple of interesting challenges while porting.</span></span>

## <a name="getting-ready"></a><span data-ttu-id="b7c40-134">Подготовка</span><span class="sxs-lookup"><span data-stu-id="b7c40-134">Getting ready</span></span>

<span data-ttu-id="b7c40-135">Основной проблемой миграции приложения .NET Framework в .NET Core является то, что его зависимости могут работать по-разному или не работать вообще.</span><span class="sxs-lookup"><span data-stu-id="b7c40-135">The primary challenge of migrating a .NET Framework app to .NET Core is that its dependencies may work differently or not at all.</span></span> <span data-ttu-id="b7c40-136">Миграция намного проще, чем раньше; многие пакеты NuGet теперь нацелены на .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="b7c40-136">Migration is much easier than it used to be; many NuGet packages now target .NET Standard.</span></span> <span data-ttu-id="b7c40-137">Начиная с .NET Core версии 2.0, контактные зоны .NET Framework и .NET Core стали похожи.</span><span class="sxs-lookup"><span data-stu-id="b7c40-137">Starting with .NET Core 2.0, the .NET Framework and .NET Core surface areas have become similar.</span></span> <span data-ttu-id="b7c40-138">Несмотря на это, остаются некоторые различия (как в поддержке пакетов NuGet, так и в доступных API-интерфейсах .NET).</span><span class="sxs-lookup"><span data-stu-id="b7c40-138">Even so, some differences (both in support from NuGet packages and in available .NET APIs) remain.</span></span> <span data-ttu-id="b7c40-139">Первым шагом в переносе является проверка зависимостей приложения и того, что ссылки имеют формат, который легко переносится в .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c40-139">The first step in migrating is to review the app's dependencies and make sure references are in a format that's easily migrated to .NET Core.</span></span>

### <a name="upgrade-to-packagereference-nuget-references"></a><span data-ttu-id="b7c40-140">Обновление до ссылок NuGet `<PackageReference>`</span><span class="sxs-lookup"><span data-stu-id="b7c40-140">Upgrade to `<PackageReference>` NuGet references</span></span>

<span data-ttu-id="b7c40-141">Более старые проекты .NET Framework, как правило, перечисляют зависимости NuGet в файле *packages.config*.</span><span class="sxs-lookup"><span data-stu-id="b7c40-141">Older .NET Framework projects typically list their NuGet dependencies in a *packages.config* file.</span></span> <span data-ttu-id="b7c40-142">Новый формат файла проекта в стиле пакета SDK ссылается на пакеты NuGet в качестве элементов [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) в самом файле csproj, а не в отдельном файле конфигурации.</span><span class="sxs-lookup"><span data-stu-id="b7c40-142">The new SDK-style project file format references NuGet packages as [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) elements in the csproj file itself rather than in a separate config file.</span></span>

<span data-ttu-id="b7c40-143">При миграции существует два преимущества использования ссылок в стиле `<PackageReference>`.</span><span class="sxs-lookup"><span data-stu-id="b7c40-143">When migrating, there are two advantages to using `<PackageReference>`-style references:</span></span>

- <span data-ttu-id="b7c40-144">Это стиль ссылки NuGet, необходимый для нового файла проекта .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c40-144">This is the style of NuGet reference that is required for the new .NET Core project file.</span></span> <span data-ttu-id="b7c40-145">Если вы уже используете `<PackageReference>`, эти элементы файла проекта можно скопировать и вставить непосредственно в новый проект.</span><span class="sxs-lookup"><span data-stu-id="b7c40-145">If you're already using `<PackageReference>`, those project file elements can be copied and pasted directly into the new project.</span></span>
- <span data-ttu-id="b7c40-146">В отличие от файла packages.config, элементы `<PackageReference>` относятся только к зависимостям верхнего уровня, от которых проект зависит напрямую.</span><span class="sxs-lookup"><span data-stu-id="b7c40-146">Unlike a packages.config file, `<PackageReference>` elements only refer to the top-level dependencies that your project depends on directly.</span></span> <span data-ttu-id="b7c40-147">Все остальные транзитивные пакеты NuGet будут определены во время восстановления и записаны в автоматически сформированный файл obj\project.assets.json.</span><span class="sxs-lookup"><span data-stu-id="b7c40-147">All other transitive NuGet packages will be determined at restore time and recorded in the autogenerated obj\project.assets.json file.</span></span> <span data-ttu-id="b7c40-148">Это значительно упрощает определение зависимостей проекта, что полезно при определении того, будут ли необходимые зависимости работать в .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c40-148">This makes it much easier to determine what dependencies your project has, which is useful when determining whether the necessary dependencies will work on .NET Core or not.</span></span>

<span data-ttu-id="b7c40-149">Первым этапом перенесения приложения .NET Framework в .NET Core является его обновление для использования ссылок NuGet `<PackageReference>`.</span><span class="sxs-lookup"><span data-stu-id="b7c40-149">The first step to migrating a .NET Framework app to .NET Core is to update it to use `<PackageReference>` NuGet references.</span></span> <span data-ttu-id="b7c40-150">Visual Studio упрощает это задание.</span><span class="sxs-lookup"><span data-stu-id="b7c40-150">Visual Studio makes this simple.</span></span> <span data-ttu-id="b7c40-151">Просто щелкните правой кнопкой мыши файл *packages.config* проекта в **обозревателе решений** Visual Studio, а затем выберите **Перенести packages.config в PackageReference**.</span><span class="sxs-lookup"><span data-stu-id="b7c40-151">Just right-click the project's *packages.config* file in Visual Studio's **Solution Explorer**, and then select **Migrate packages.config to PackageReference**.</span></span>

![Обновление до PackageReference](./media/convert-project-from-net-framework/package-reference-migration.png)

<span data-ttu-id="b7c40-153">Откроется диалоговое окно с вычисленными зависимостями NuGet верхнего уровня и вопросом, какие другие пакеты NuGet следует повысить до верхнего уровня.</span><span class="sxs-lookup"><span data-stu-id="b7c40-153">A dialog appears showing calculated top-level NuGet dependencies and asking which other NuGet packages should be promoted to top-level.</span></span> <span data-ttu-id="b7c40-154">Для примера Bean Trader не нужно, чтобы эти пакеты были пакетами верхнего уровня, поэтому вы можете снять все эти флажки.</span><span class="sxs-lookup"><span data-stu-id="b7c40-154">None of these other packages need to be top-level for the Bean Trader sample, so you can uncheck all of those boxes.</span></span> <span data-ttu-id="b7c40-155">Затем нажмите кнопку **ОК**, и файл *packages.config* будет удален, а элементы `<PackageReference>` добавятся в файл проекта.</span><span class="sxs-lookup"><span data-stu-id="b7c40-155">Then, click **Ok** and the *packages.config* file is removed and `<PackageReference>` elements are added to the project file.</span></span>

<span data-ttu-id="b7c40-156">Ссылки в стиле `<PackageReference>`не хранят пакеты NuGet локально в папке пакетов.</span><span class="sxs-lookup"><span data-stu-id="b7c40-156">`<PackageReference>`-style references don't store NuGet packages locally in a packages folder.</span></span> <span data-ttu-id="b7c40-157">Они хранятся глобально для оптимизации.</span><span class="sxs-lookup"><span data-stu-id="b7c40-157">Instead, they're stored globally as an optimization.</span></span> <span data-ttu-id="b7c40-158">После завершения миграции измените файл csproj и удалите все элементы `<Analyzer>`, ссылающиеся на анализаторы, которые ранее поступили из каталога *...\packages*.</span><span class="sxs-lookup"><span data-stu-id="b7c40-158">After the migration completes, edit the csproj file and remove any `<Analyzer>` elements referring to the analyzers that previously came from the *..\packages* directory.</span></span> <span data-ttu-id="b7c40-159">Не беспокойтесь; анализаторы будут добавлены в проект, так как у вас по-прежнему есть ссылки на пакет NuGet.</span><span class="sxs-lookup"><span data-stu-id="b7c40-159">Don't worry; since you still have the NuGet package references, the analyzers will be included in the project.</span></span> <span data-ttu-id="b7c40-160">Необходимо просто очистить старые элементы packages.config в стиле `<Analyzer>`.</span><span class="sxs-lookup"><span data-stu-id="b7c40-160">You just need to clean up the old packages.config-style `<Analyzer>` elements.</span></span>

### <a name="review-nuget-packages"></a><span data-ttu-id="b7c40-161">Проверка пакетов NuGet</span><span class="sxs-lookup"><span data-stu-id="b7c40-161">Review NuGet packages</span></span>

<span data-ttu-id="b7c40-162">Теперь, когда вы видите пакеты NuGet верхнего уровня, от которых зависит проект, можно проверить, доступны ли эти пакеты в .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c40-162">Now that you can see the top-level NuGet packages that the project depends on, you can review whether those packages are available on .NET Core.</span></span> <span data-ttu-id="b7c40-163">Чтобы определить, поддерживает ли пакет .NET Core, просмотрите его зависимости на [nuget.org](https://www.nuget.org/). Эти сведения отображаются в верхней части страницы сведений о пакете, созданном сообществом [fuget.org](https://www.fuget.org/).</span><span class="sxs-lookup"><span data-stu-id="b7c40-163">You can determine whether a package supports .NET Core by looking at its dependencies on [nuget.org](https://www.nuget.org/). The community-created [fuget.org](https://www.fuget.org/) site shows this information prominently at the top of the package information page.</span></span>

<span data-ttu-id="b7c40-164">При разработке для .NET Core 3.0 должны работать все пакеты, предназначенные для .NET Core или .NET Standard (так как в .NET Core реализована контактная зона .NET Standard).</span><span class="sxs-lookup"><span data-stu-id="b7c40-164">When targeting .NET Core 3.0, any packages targeting .NET Core or .NET Standard should work (since .NET Core implements the .NET Standard surface area).</span></span> <span data-ttu-id="b7c40-165">В некоторых случаях конкретная версия используемого пакета не будет нацелена на .NET Core или .NET Standard, но более новые версии будут.</span><span class="sxs-lookup"><span data-stu-id="b7c40-165">In some cases, the specific version of a package that's used won't target .NET Core or .NET Standard, but newer versions will.</span></span> <span data-ttu-id="b7c40-166">В этом случае следует рассмотреть возможность обновления до последней версии пакета.</span><span class="sxs-lookup"><span data-stu-id="b7c40-166">In this case, you should consider upgrading to the latest version of the package.</span></span>

<span data-ttu-id="b7c40-167">Вы также можете использовать пакеты, предназначенные для .NET Framework, но это порождает некоторый риск.</span><span class="sxs-lookup"><span data-stu-id="b7c40-167">You can use packages targeting .NET Framework, as well, but that introduces some risk.</span></span> <span data-ttu-id="b7c40-168">Использование .NET Core с зависимостями .NET Framework разрешено, так как контактные зоны в .NET Core и .NET Framework похожи, что *часто* позволяет таким зависимостям работать.</span><span class="sxs-lookup"><span data-stu-id="b7c40-168">.NET Core to .NET Framework dependencies are allowed because .NET Core and .NET Framework surface areas are similar enough that such dependencies *often* work.</span></span> <span data-ttu-id="b7c40-169">Однако если пакет попытается использовать API .NET, который отсутствует в .NET Core, то возникнет исключение времени выполнения.</span><span class="sxs-lookup"><span data-stu-id="b7c40-169">However, if the package tries to use a .NET API that isn't present in .NET Core, you'll encounter a runtime exception.</span></span> <span data-ttu-id="b7c40-170">Из-за этого вы должны ссылаться на пакеты .NET Framework, только если другие параметры недоступны, и понимать, что это накладывает тестовую нагрузку.</span><span class="sxs-lookup"><span data-stu-id="b7c40-170">Because of that, you should only reference .NET Framework packages when no other options are available and understand that doing so imposes a test burden.</span></span>

<span data-ttu-id="b7c40-171">Если имеются ссылки на пакеты, которые не предназначены для .NET Core или .NET Standard, вам придется подумать о других вариантах:</span><span class="sxs-lookup"><span data-stu-id="b7c40-171">If there are packages referenced that don't target .NET Core or .NET Standard, you'll have to think about other alternatives:</span></span>

- <span data-ttu-id="b7c40-172">Существуют ли другие похожие пакеты, которые можно использовать вместо этого?</span><span class="sxs-lookup"><span data-stu-id="b7c40-172">Are there other similar packages that can be used instead?</span></span> <span data-ttu-id="b7c40-173">Иногда авторы NuGet публикуют отдельные версии ".Core" своих библиотек, специально предназначенные для .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c40-173">Sometimes NuGet authors publish separate '.Core' versions of their libraries specifically targeting .NET Core.</span></span> <span data-ttu-id="b7c40-174">Пакеты Enterprise Library являются примером сообщества, публикующего альтернативы ".NetCore".</span><span class="sxs-lookup"><span data-stu-id="b7c40-174">Enterprise Library packages are an example of the community publishing ".NetCore" alternatives.</span></span> <span data-ttu-id="b7c40-175">В других случаях для .NET Standard доступны более новые пакеты SDK для определенной службы (иногда с разными именами пакетов).</span><span class="sxs-lookup"><span data-stu-id="b7c40-175">In other cases, newer SDKs for a particular service (sometimes with different package names) are available for .NET Standard.</span></span> <span data-ttu-id="b7c40-176">Если доступных вариантов нет, можно приступить к использованию пакетов, предназначенных для .NET Framework, учитывая, что при выполнении в .NET Core их необходимо тщательно протестировать.</span><span class="sxs-lookup"><span data-stu-id="b7c40-176">If no alternatives are available, you can proceed using the .NET Framework-targeted packages, bearing in mind that you'll need to test them thoroughly once running on .NET Core.</span></span>

<span data-ttu-id="b7c40-177">Пример Bean Trader имеет следующие зависимости NuGet верхнего уровня:</span><span class="sxs-lookup"><span data-stu-id="b7c40-177">The Bean Trader sample has the following top-level NuGet dependencies:</span></span>

- [<span data-ttu-id="b7c40-178">**Castle.Windsor, версия 4.1.1**</span><span class="sxs-lookup"><span data-stu-id="b7c40-178">**Castle.Windsor, version 4.1.1**</span></span>](https://www.castleproject.org/projects/windsor/)  

  <span data-ttu-id="b7c40-179">Этот пакет предназначен для .NET Standard 1.6, поэтому он работает на .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c40-179">This package targets .NET Standard 1.6, so it works on .NET Core.</span></span>

- [<span data-ttu-id="b7c40-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, версия 2.6.3**</span><span class="sxs-lookup"><span data-stu-id="b7c40-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, version 2.6.3**</span></span>](https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers/2.6.3)  
  <span data-ttu-id="b7c40-181">Это мета-пакет, поэтому не сразу видно, какие платформы он поддерживает, однако [документация](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) указывает, что его последняя версия (2.9.2) будет работать как для .NET Framework, так и для .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c40-181">This is a meta-package, so it's not immediately obvious which platforms it supports, but [documentation](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indicates that its newest version (2.9.2) will work for both .NET Framework and .NET Core.</span></span>

- [<span data-ttu-id="b7c40-182">**Nito.AsyncEx версии 4.0.1**</span><span class="sxs-lookup"><span data-stu-id="b7c40-182">**Nito.AsyncEx, version 4.0.1**</span></span>](https://www.nuget.org/packages/Nito.AsyncEx/4.0.1)  

  <span data-ttu-id="b7c40-183">Этот пакет не предназначен для .NET Core, однако его новая версия 5.0 предназначена.</span><span class="sxs-lookup"><span data-stu-id="b7c40-183">This package doesn't target .NET Core, but the newer 5.0 version does.</span></span> <span data-ttu-id="b7c40-184">Это часто происходит при миграции, поскольку многие пакеты NuGet недавно добавили поддержку .NET Standard, а более старые версии проекта предназначены только для .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="b7c40-184">This is common when migrating because many NuGet packages have added .NET Standard support recently, but older project versions will only target .NET Framework.</span></span> <span data-ttu-id="b7c40-185">Если разница в версиях незначительна, обновление до более новой версии выполнить несложно.</span><span class="sxs-lookup"><span data-stu-id="b7c40-185">If the version difference is only a minor version difference, it's often easy to upgrade to the newer version.</span></span> <span data-ttu-id="b7c40-186">Поскольку это изменение основного номера версии, вам нужно быть осторожным при обновлении, так как изменения в пакете могут быть критическими.</span><span class="sxs-lookup"><span data-stu-id="b7c40-186">Because this is a major version change, you need to be cautious upgrading since there could be breaking changes in the package.</span></span> <span data-ttu-id="b7c40-187">Впрочем, у нас есть план дальнейших действий.</span><span class="sxs-lookup"><span data-stu-id="b7c40-187">There is a path forward, though, which is good.</span></span>

- [<span data-ttu-id="b7c40-188">**MahApps.Metro, версия 1.6.5**</span><span class="sxs-lookup"><span data-stu-id="b7c40-188">**MahApps.Metro, version 1.6.5**</span></span>](https://www.nuget.org/packages/MahApps.Metro/1.6.5)  

  <span data-ttu-id="b7c40-189">Этот пакет также не предназначен для .NET Core, но имеет более новую предварительную версию (2.0-alpha), которую можно использовать с этой целью.</span><span class="sxs-lookup"><span data-stu-id="b7c40-189">This package also doesn't target .NET Core, but has a newer pre-release (2.0-alpha) that does.</span></span> <span data-ttu-id="b7c40-190">Опять же, вам нужно обратить внимание на наличие критических изменений, однако новый пакет достаточно надежен.</span><span class="sxs-lookup"><span data-stu-id="b7c40-190">Again, you have to look out for breaking changes, but the newer package is encouraging.</span></span>

<span data-ttu-id="b7c40-191">Зависимости NuGet в примере Bean Trader либо предназначены для .NET Standard/.NET Core, либо имеют более новые версии, которые можно использовать, так что здесь вряд ли возникнут блокирующие проблемы.</span><span class="sxs-lookup"><span data-stu-id="b7c40-191">The Bean Trader sample's NuGet dependencies all either target .NET Standard/.NET Core or have newer versions that do, so there are unlikely to be any blocking issues here.</span></span>

### <a name="upgrade-nuget-packages"></a><span data-ttu-id="b7c40-192">Обновление пакетов NuGet</span><span class="sxs-lookup"><span data-stu-id="b7c40-192">Upgrade NuGet packages</span></span>

<span data-ttu-id="b7c40-193">Если это возможно, было бы неплохо обновить версии всех пакетов, предназначенных только для .NET Core или .NET Standard, до более поздних версий (с проектом, по-прежнему предназначенным для .NET Framework), чтобы обнаружить и устранить критические изменения на раннем этапе.</span><span class="sxs-lookup"><span data-stu-id="b7c40-193">If possible, it would be good to upgrade the versions of any packages that only target .NET Core or .NET Standard with more recent versions at this point (with the project still targeting .NET Framework) to discover and address any breaking changes early.</span></span>

<span data-ttu-id="b7c40-194">Если вы не хотите вносить изменения в существующую версию приложения .NET Framework, с этим можно подождать, пока у вас не появится новый файл проекта, нацеленный на .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c40-194">If you would rather not make any material changes to the existing .NET Framework version of the app, this can wait until you have a new project file targeting .NET Core.</span></span> <span data-ttu-id="b7c40-195">Однако обновление пакетов NuGet до версии, совместимой с .NET Core, заранее упрощает процесс миграции после создания нового файла проекта и уменьшает число различий между версиями приложения .NET Framework и .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c40-195">However, upgrading the NuGet packages to .NET Core-compatible versions ahead of time makes the migration process even easier once you create the new project file and reduces the number of differences between the .NET Framework and .NET Core versions of the app.</span></span>

<span data-ttu-id="b7c40-196">С помощью примера Bean Trader вы можете легко выполнить необходимые обновления (используя диспетчер пакетов NuGet Visual Studio) с одним исключением: обновление **MahApps.Metro версии 1.6.5** до версии **2.0** приводит к критическим изменениям, связанным с API-интерфейсами управления темой и диакритическими знаками.</span><span class="sxs-lookup"><span data-stu-id="b7c40-196">With the Bean Trader sample, all of the necessary upgrades can be made easily (using Visual Studio's NuGet package manager) with one exception: upgrading from **MahApps.Metro 1.6.5** to **2.0** reveals breaking changes related to theme and accent management APIs.</span></span>

<span data-ttu-id="b7c40-197">В идеале приложение будет обновлено для использования более новой версии пакета (поскольку она, скорее всего, будет работать в .NET Core).</span><span class="sxs-lookup"><span data-stu-id="b7c40-197">Ideally, the app would be updated to use the newer version of the package (since that is more likely to work on .NET Core).</span></span> <span data-ttu-id="b7c40-198">Однако в некоторых случаях это может оказаться невозможным.</span><span class="sxs-lookup"><span data-stu-id="b7c40-198">In some cases, however, that may not be feasible.</span></span> <span data-ttu-id="b7c40-199">В этих случаях не обновляйте **MahApps.Metro**, поскольку необходимые изменения нетривиальны, и в этом учебнике рассматривается переход на .NET Core 3, а не **MahApps.Metro 2.**</span><span class="sxs-lookup"><span data-stu-id="b7c40-199">In these cases, don't upgrade **MahApps.Metro** because the necessary changes are non-trivial and this tutorial focuses on migrating to .NET Core 3, not to **MahApps.Metro 2.**</span></span> <span data-ttu-id="b7c40-200">Кроме того, это зависимость .NET Framework с низким риском, поскольку приложение Bean Trader работает только с небольшой частью **MahApps.Metro**.</span><span class="sxs-lookup"><span data-stu-id="b7c40-200">Also, this is a low-risk .NET Framework dependency because the Bean Trader app only exercises a small part of **MahApps.Metro**.</span></span> <span data-ttu-id="b7c40-201">Чтобы убедиться, что все работает, после завершения миграции, конечно же, потребуется тестирование.</span><span class="sxs-lookup"><span data-stu-id="b7c40-201">It will, of course, require testing to make sure everything's working once the migration is complete.</span></span> <span data-ttu-id="b7c40-202">Если бы это был реальный сценарий, было бы неплохо подать заявку на отслеживание работы по переходу на **MahApps.Metro** версии 2.0, так как в результате непроведения миграции теперь остается некий технический долг.</span><span class="sxs-lookup"><span data-stu-id="b7c40-202">If this were a real-world scenario, it would be good to file an issue to track the work to move to **MahApps.Metro** version 2.0 since not doing the migration now leaves behind some technical debt.</span></span>

<span data-ttu-id="b7c40-203">После обновления пакетов NuGet до последних версий группа элементов `<PackageReference>` в файле проекта примера Bean Trader будет выглядеть следующим образом.</span><span class="sxs-lookup"><span data-stu-id="b7c40-203">Once the NuGet packages are updated to recent versions, the `<PackageReference>` item group in the Bean Trader sample's project file should look like this.</span></span>

```xml
<ItemGroup>
  <PackageReference Include="Castle.Windsor">
    <Version>4.1.1</Version>
  </PackageReference>
  <PackageReference Include="MahApps.Metro">
    <Version>1.6.5</Version>
  </PackageReference>
  <PackageReference Include="Microsoft.CodeAnalysis.FxCopAnalyzers">
    <Version>2.9.2</Version>
  </PackageReference>
  <PackageReference Include="Nito.AsyncEx">
    <Version>5.0.0</Version>
  </PackageReference>
</ItemGroup>
```

### <a name="net-framework-portability-analysis"></a><span data-ttu-id="b7c40-204">Анализ переносимости .NET Framework</span><span class="sxs-lookup"><span data-stu-id="b7c40-204">.NET Framework portability analysis</span></span>

<span data-ttu-id="b7c40-205">Как только вы поймете состояние зависимостей NuGet вашего проекта, следующее, что нужно учитывать — это зависимости API .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="b7c40-205">Once you understand the state of your project's NuGet dependencies, the next thing to consider is .NET Framework API dependencies.</span></span> <span data-ttu-id="b7c40-206">Средство [Анализатор переносимости .NET](../../standard/analyzers/portability-analyzer.md) полезно для понимания того, какие API .NET вашего проекта доступны на других платформах .NET.</span><span class="sxs-lookup"><span data-stu-id="b7c40-206">The [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) tool is useful for understanding which of the .NET APIs your project uses are available on other .NET platforms.</span></span>

<span data-ttu-id="b7c40-207">Средство поставляется в качестве [подключаемого модуля Visual Studio](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), [средства командной строки](https://github.com/Microsoft/dotnet-apiport/releases) или в виде [простого графического интерфейса](https://github.com/Microsoft/dotnet-apiport-ui), что упрощает его настройку.</span><span class="sxs-lookup"><span data-stu-id="b7c40-207">The tool comes as a [Visual Studio plugin](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), a [command-line tool](https://github.com/Microsoft/dotnet-apiport/releases), or wrapped in a [simple GUI](https://github.com/Microsoft/dotnet-apiport-ui), which simplifies its options.</span></span> <span data-ttu-id="b7c40-208">Дополнительные сведения об использовании анализатора переносимости .NET (порт API) см. в записи блога [Перенос настольных приложений в .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/).</span><span class="sxs-lookup"><span data-stu-id="b7c40-208">You can read more about using the .NET Portability Analyzer (API Port) using the GUI in the [Porting desktop apps to .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) blog post.</span></span> <span data-ttu-id="b7c40-209">Если вы предпочитаете использовать командную строку, необходимо выполнить следующие действия.</span><span class="sxs-lookup"><span data-stu-id="b7c40-209">If you prefer to use the command line, the necessary steps are:</span></span>

1. <span data-ttu-id="b7c40-210">Скачайте [Анализатор переносимости .NET](https://github.com/Microsoft/dotnet-apiport/releases), если у вас его еще нет.</span><span class="sxs-lookup"><span data-stu-id="b7c40-210">Download the [.NET Portability Analyzer](https://github.com/Microsoft/dotnet-apiport/releases) if you don't already have it.</span></span>
1. <span data-ttu-id="b7c40-211">Убедитесь, что приложение .NET Framework успешно переносится в сборку (это хорошая идея перед тем, как переходить на другую платформу).</span><span class="sxs-lookup"><span data-stu-id="b7c40-211">Make sure the .NET Framework app to be ported builds successfully (this is a good idea prior to migration regardless).</span></span>
1. <span data-ttu-id="b7c40-212">Запустите порт API с такой командной строкой.</span><span class="sxs-lookup"><span data-stu-id="b7c40-212">Run API Port with a command line like this.</span></span>

    ```console
    ApiPort.exe analyze -f <PathToBeanTraderBinaries> -r html -r excel -t ".NET Core"
    ```

    <span data-ttu-id="b7c40-213">Аргумент `-f` указывает путь, содержащий двоичные файлы для анализа.</span><span class="sxs-lookup"><span data-stu-id="b7c40-213">The `-f` argument specifies the path containing the binaries to analyze.</span></span> <span data-ttu-id="b7c40-214">Аргумент `-r` указывает нужный формат выходного файла.</span><span class="sxs-lookup"><span data-stu-id="b7c40-214">The `-r` argument specifies which output file format you want.</span></span> <span data-ttu-id="b7c40-215">Аргумент `-t` указывает, какая платформа .NET будет анализировать использование API.</span><span class="sxs-lookup"><span data-stu-id="b7c40-215">The `-t` argument specifies which .NET platform to analyze API usage against.</span></span> <span data-ttu-id="b7c40-216">В этом случае требуется .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c40-216">In this case, you want .NET Core.</span></span>

<span data-ttu-id="b7c40-217">При открытии HTML-отчета в первом разделе будут перечислены все анализируемые двоичные файлы и процентное соотношение API .NET, которые они используют на целевой платформе.</span><span class="sxs-lookup"><span data-stu-id="b7c40-217">When you open the HTML report, the first section will list all of the analyzed binaries and what percentage of the .NET APIs they use are available on the targeted platform.</span></span> <span data-ttu-id="b7c40-218">Процент сам по себе не имеет смысла.</span><span class="sxs-lookup"><span data-stu-id="b7c40-218">The percentage is not meaningful by itself.</span></span> <span data-ttu-id="b7c40-219">Более полезным является просмотр отсутствующих интерфейсов API.</span><span class="sxs-lookup"><span data-stu-id="b7c40-219">What's more useful is to see the specific APIs that are missing.</span></span> <span data-ttu-id="b7c40-220">Для этого либо выберите имя сборки, либо прокрутите вниз до отчетов для отдельных сборок.</span><span class="sxs-lookup"><span data-stu-id="b7c40-220">To do that, either select an assembly name or scroll down to the reports for individual assemblies.</span></span>

<span data-ttu-id="b7c40-221">Сосредоточьтесь на сборках, исходным кодом которых вы владеете.</span><span class="sxs-lookup"><span data-stu-id="b7c40-221">Focus on the assemblies that you own the source code for.</span></span> <span data-ttu-id="b7c40-222">Например, в отчете Bean Trader ApiPort есть множество двоичных файлов, но большинство из них относятся к пакетам NuGet.</span><span class="sxs-lookup"><span data-stu-id="b7c40-222">In the Bean Trader ApiPort report, for example, there are many binaries listed, but most of them belong to NuGet packages.</span></span> <span data-ttu-id="b7c40-223">`Castle.Windsor` показывает, что он зависит от некоторых API-интерфейсов System.Web, которые отсутствуют в .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c40-223">`Castle.Windsor` shows that it depends on some System.Web APIs that are missing in .NET Core.</span></span> <span data-ttu-id="b7c40-224">Это не проблема, потому что ранее вы убедились, что `Castle.Windsor` поддерживает .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c40-224">This isn't a concern because you previously verified that `Castle.Windsor` supports .NET Core.</span></span> <span data-ttu-id="b7c40-225">В пакетах NuGet часто используются разные двоичные файлы для различных платформ .NET, поэтому неважно, использует ли версия .NET Framework из `Castle.Windsor` System.Web API или нет, при условии, что пакет также нацелен на .NET Standard или .NET Core (что он и делает).</span><span class="sxs-lookup"><span data-stu-id="b7c40-225">It is common for NuGet packages to have different binaries for use with different .NET platforms, so whether the .NET Framework version of `Castle.Windsor` uses System.Web APIs or not is irrelevant as long as the package also targets .NET Standard or .NET Core (which it does).</span></span>

<span data-ttu-id="b7c40-226">В примере Bean Trader единственным двоичным файлом, который необходимо рассмотреть, является **BeanTraderClient**, а в отчете показано, что отсутствуют только два API-интерфейса .NET: `System.ServiceModel.ClientBase<T>.Close` и `System.ServiceModel.ClientBase<T>.Open`.</span><span class="sxs-lookup"><span data-stu-id="b7c40-226">With the Bean Trader sample, the only binary that you need to consider is **BeanTraderClient** and the report shows that only two .NET APIs are missing: `System.ServiceModel.ClientBase<T>.Close` and `System.ServiceModel.ClientBase<T>.Open`.</span></span>

![Отчет о переносимости BeanTraderClient](./media/convert-project-from-net-framework/portability-report.png)

<span data-ttu-id="b7c40-228">Маловероятно, что они станут блокирующими проблемами, потому что клиентские API WCF (в основном) поддерживаются на .NET Core, поэтому для этих центральных API должны быть доступны альтернативные варианты.</span><span class="sxs-lookup"><span data-stu-id="b7c40-228">These are unlikely to be blocking issues because WCF Client APIs are (mostly) supported on .NET Core, so there must be alternatives available for these central APIs.</span></span> <span data-ttu-id="b7c40-229">На самом деле, просматривая контактную зону .NET Core `System.ServiceModel`(используя <https://apisof.net>), вы увидите, что вместо этого в .NET Core есть асинхронные альтернативы.</span><span class="sxs-lookup"><span data-stu-id="b7c40-229">In fact, looking at `System.ServiceModel`'s .NET Core surface area (using <https://apisof.net>), you see that there are async alternatives in .NET Core instead.</span></span>

<span data-ttu-id="b7c40-230">На основании этого отчета и предыдущего анализа зависимостей NuGet можно сделать вывод, что, скорее всего, не должно быть никаких серьезных проблем при переносе примера Bean Trader в .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c40-230">Based on this report and the previous NuGet dependency analysis, it looks like there should be no major issues migrating the Bean Trader sample to .NET Core.</span></span> <span data-ttu-id="b7c40-231">Вы готовы к следующему этапу, в котором вы действительно начнете миграцию.</span><span class="sxs-lookup"><span data-stu-id="b7c40-231">You're ready for the next step in which you'll actually start the migration.</span></span>

## <a name="migrating-the-project-file"></a><span data-ttu-id="b7c40-232">Перенос файл проекта</span><span class="sxs-lookup"><span data-stu-id="b7c40-232">Migrating the project file</span></span>

<span data-ttu-id="b7c40-233">Если приложение не использует новый формат файла [в стиле пакета SDK](../../core/tools/csproj.md), потребуется новый файл проекта, предназначенный для .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c40-233">If your app isn't using the new [SDK-style project file format](../../core/tools/csproj.md), you'll need a new project file to target .NET Core.</span></span> <span data-ttu-id="b7c40-234">Можно заменить существующий файл csproj или, если вы хотите, чтобы существующий проект не был изменен и сохранить его текущее состояние, можно добавить новый файл csproj, предназначенный для .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c40-234">You can replace the existing csproj file or, if you prefer to keep the existing project untouched in its current state, you can add a new csproj file targeting .NET Core.</span></span> <span data-ttu-id="b7c40-235">Вы можете создать версии приложения для .NET Framework и .NET Core с одним файлом проекта в стиле пакета SDK с помощью [многоэлементного нацеливания](../../standard/library-guidance/cross-platform-targeting.md) (указав несколько целевых объектов `<TargetFrameworks>`).</span><span class="sxs-lookup"><span data-stu-id="b7c40-235">You can build versions of the app for .NET Framework and .NET Core with a single SDK-style project file with [multi-targeting](../../standard/library-guidance/cross-platform-targeting.md) (specifying multiple `<TargetFrameworks>` targets).</span></span>

<span data-ttu-id="b7c40-236">Чтобы создать новый файл проекта, можно создать новый проект WPF в Visual Studio или использовать команду `dotnet new wpf` во временном каталоге для создания файла проекта, а затем скопировать его в нужное место или переименовать.</span><span class="sxs-lookup"><span data-stu-id="b7c40-236">To create the new project file, you can create a new WPF project in Visual Studio or use the `dotnet new wpf` command in a temporary directory to generate the project file and then copy/rename it to the correct location.</span></span> <span data-ttu-id="b7c40-237">Существует также средство, созданное сообществом, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), которое может автоматизировать часть переноса файлов проекта.</span><span class="sxs-lookup"><span data-stu-id="b7c40-237">There is also a community-created tool, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), that can automate some of the project file migration.</span></span> <span data-ttu-id="b7c40-238">Это средство полезное, однако вмешательство человека все же нужно для просмотра результатов, чтобы убедиться, что все сведения о переносе верны.</span><span class="sxs-lookup"><span data-stu-id="b7c40-238">The tool is helpful but still needs a human to review the results to make sure all the details of the migration are correct.</span></span> <span data-ttu-id="b7c40-239">Одна конкретная область, которую средство не обрабатывает оптимально, — перенос пакетов NuGet из файлов *packages.config*.</span><span class="sxs-lookup"><span data-stu-id="b7c40-239">One particular area that the tool doesn't handle optimally is migrating NuGet packages from *packages.config* files.</span></span> <span data-ttu-id="b7c40-240">Если средство выполняется в файле проекта, который по-прежнему использует файл *packages.config* для ссылки на пакеты NuGet, он будет автоматически переноситься в элементы `<PackageReference>`, но будет добавлять элементы `<PackageReference>` для *всех* пакетов, а не только для пакетов верхнего уровня.</span><span class="sxs-lookup"><span data-stu-id="b7c40-240">If the tool runs on a project file that still uses a *packages.config* file to reference NuGet packages, it will migrate to `<PackageReference>` elements automatically, but will add `<PackageReference>` elements for *all* of the packages instead of just top-level ones.</span></span> <span data-ttu-id="b7c40-241">Если вы уже выполнили перенос элементов`<PackageReference>` с помощью Visual Studio (как было сделано в этом примере), это средство поможет выполнить оставшуюся часть преобразования.</span><span class="sxs-lookup"><span data-stu-id="b7c40-241">If you have already migrated to`<PackageReference>` elements with Visual Studio (as you've done in this sample), then the tool can help with the rest of the conversion.</span></span> <span data-ttu-id="b7c40-242">Как и рекомендует Скотт Хэнселман (Scott Hanselman) в [посте своего блога о переносе CSPROJ-файлов](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), перенос вручную является информативным и даст лучшие результаты, если у вас есть только несколько проектов, которые нужно перенести.</span><span class="sxs-lookup"><span data-stu-id="b7c40-242">Like Scott Hanselman recommends in [his blog post on migrating csproj files](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), porting by hand is educational and will give better results if you only have a few projects to port.</span></span> <span data-ttu-id="b7c40-243">Но если вы переносите десятки или сотни файлов проекта, то в качестве справки можно использовать такие средства, как [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017).</span><span class="sxs-lookup"><span data-stu-id="b7c40-243">But if you're porting dozens or hundreds of project files, then a tool like [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017) can be a help.</span></span>

<span data-ttu-id="b7c40-244">Чтобы создать новый файл проекта для примера Bean Trader, запустите `dotnet new wpf` во временном каталоге и переместите созданный файл *CSPROJ* в папку *BeanTraderClient* и переименуйте его на **BeanTraderClient.Core.csproj**.</span><span class="sxs-lookup"><span data-stu-id="b7c40-244">To create a new project file for the Bean Trader sample, run `dotnet new wpf` in a temporary directory and move the generated *.csproj* file into the *BeanTraderClient* folder and rename it **BeanTraderClient.Core.csproj**.</span></span>

<span data-ttu-id="b7c40-245">Поскольку новый формат файла проекта автоматически включает файлы C#, *RESX* и XAML, найденные в каталоге или в папке, файл проекта уже почти завершен.</span><span class="sxs-lookup"><span data-stu-id="b7c40-245">Because the new project file format automatically includes C# files, *resx* files, and XAML files that it finds in or under its directory, the project file is already almost complete!</span></span> <span data-ttu-id="b7c40-246">Чтобы завершить перенос, откройте старые и новые файлы проекта параллельно и просмотрите старый, чтобы узнать, нужно ли перенести какие-либо сведения, содержащиеся в нем.</span><span class="sxs-lookup"><span data-stu-id="b7c40-246">To finish the migration, open the old and new project files side-by-side and look through the old one to see if any information it contains needs to be migrated.</span></span> <span data-ttu-id="b7c40-247">В примере Bean Trader в новый проект нужно скопировать следующие элементы.</span><span class="sxs-lookup"><span data-stu-id="b7c40-247">In the Bean Trader sample case, the following items should be copied to the new project:</span></span>

- <span data-ttu-id="b7c40-248">Нужно скопировать свойства `<RootNamespace>`, `<AssemblyName>` и `<ApplicationIcon>`.</span><span class="sxs-lookup"><span data-stu-id="b7c40-248">The `<RootNamespace>`, `<AssemblyName>`, and `<ApplicationIcon>` properties should all be copied.</span></span>

- <span data-ttu-id="b7c40-249">Также в новый файл проекта необходимо добавить свойство `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>`, поскольку пример Bean Trader содержит атрибуты уровня сборки (например, `[AssemblyTitle]`) в файле AssemblyInfo.cs.</span><span class="sxs-lookup"><span data-stu-id="b7c40-249">You also need to add a `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` property to the new project file since the Bean Trader sample includes assembly-level attributes (like `[AssemblyTitle]`) in an AssemblyInfo.cs file.</span></span> <span data-ttu-id="b7c40-250">По умолчанию новые проекты в стиле пакета SDK автоматически создают эти атрибуты на основе свойств в файле CSPROJ.</span><span class="sxs-lookup"><span data-stu-id="b7c40-250">By default, new SDK-style projects will autogenerate these attributes based on properties in the csproj file.</span></span> <span data-ttu-id="b7c40-251">Поскольку вы не хотите, чтобы это произошло в данном случае (атрибуты, которые создаются автоматически, будут конфликтовать с атрибутами из AssemblyInfo.cs), запретите автоматическое создание атрибутов с помощью `<GenerateAssemblyInfo>`.</span><span class="sxs-lookup"><span data-stu-id="b7c40-251">Because you don't want that to happen in this case (the autogenerated attributes would conflict with those from AssemblyInfo.cs), you disable the autogenerated attributes with `<GenerateAssemblyInfo>`.</span></span>

- <span data-ttu-id="b7c40-252">Несмотря на то что файлы *resx* автоматически включаются в качестве внедренных ресурсов, другие элементы `<Resource>`, например изображения, не поддерживаются.</span><span class="sxs-lookup"><span data-stu-id="b7c40-252">Although *resx* files are automatically included as embedded resources, other `<Resource>` items like images are not.</span></span> <span data-ttu-id="b7c40-253">Таким образом, скопируйте элементы `<Resource>` для внедрения изображений и файлов значков.</span><span class="sxs-lookup"><span data-stu-id="b7c40-253">So, copy the `<Resource>` elements for embedding image and icon files.</span></span> <span data-ttu-id="b7c40-254">Вы можете упростить ссылки png в одну строку, используя поддержку стандартных масок в новом формате файла проекта: `<Resource Include="**\*.png" />`.</span><span class="sxs-lookup"><span data-stu-id="b7c40-254">You can simplify the png references to a single line by using the new project file format's support for globbing patterns: `<Resource Include="**\*.png" />`.</span></span>

- <span data-ttu-id="b7c40-255">Аналогичным образом элементы `<None>` включаются автоматически, но по умолчанию они не копируются в выходной каталог.</span><span class="sxs-lookup"><span data-stu-id="b7c40-255">Similarly, `<None>` items are included automatically, but they aren't copied to the output directory, by default.</span></span> <span data-ttu-id="b7c40-256">Поскольку проект Bean Trader включает в себя элемент `<None>`, *скопированный* в выходной каталог (используя поведения `PreserveNewest`), для этого файла необходимо обновить автоматически заполняемый элемент `<None>`.</span><span class="sxs-lookup"><span data-stu-id="b7c40-256">Because the Bean Trader project includes a `<None>` item that *is* copied to the output directory (using `PreserveNewest` behaviors), you need to update the automatically populated `<None>` item for that file, like this.</span></span>

  ```xml
  <None Update="BeanTrader.pfx">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
  ```

- <span data-ttu-id="b7c40-257">Пример Bean Trader включает в себя файл XAML (Default.Accent.xaml) в качестве `Content` (а не `Page`), поскольку темы и диакритические знаки, определенные в этом файле, загружаются из файла XAML во время выполнения, а не внедряются в само приложение.</span><span class="sxs-lookup"><span data-stu-id="b7c40-257">The Bean Trader sample includes a XAML file (Default.Accent.xaml) as `Content` (rather than as a `Page`) because themes and accents defined in this file are loaded from the file's XAML at runtime, rather than being embedded in the app itself.</span></span> <span data-ttu-id="b7c40-258">Новая система проектов автоматически включает этот файл в качестве `<Page>`, так как это XAML-файл.</span><span class="sxs-lookup"><span data-stu-id="b7c40-258">The new project system automatically includes this file as a `<Page>`, however, since it's a XAML file.</span></span> <span data-ttu-id="b7c40-259">Таким образом, вам нужно удалить XAML-файл как страницу (`<Page Remove="**\Default.Accent.xaml" />`) и добавить его в качестве содержимого.</span><span class="sxs-lookup"><span data-stu-id="b7c40-259">So, you need to both remove the XAML file as a page (`<Page Remove="**\Default.Accent.xaml" />`) and add it as content.</span></span>

  ```xml
  <Content Include="Resources\Themes\Default.Accent.xaml">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </Content>
  ```

- <span data-ttu-id="b7c40-260">Наконец, добавьте ссылки NuGet, скопировав `<ItemGroup>` со всеми элементами `<PackageReference>`.</span><span class="sxs-lookup"><span data-stu-id="b7c40-260">Finally, add NuGet references by copying the `<ItemGroup>` with all the `<PackageReference>` elements.</span></span> <span data-ttu-id="b7c40-261">Если вы еще не обновляли пакеты NuGet до версии, совместимой с .NET Core, вы можете сделать это теперь, когда ссылки на пакеты находятся в проекте, специфичном для .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c40-261">If you hadn't previously upgraded the NuGet packages to .NET Core-compatible versions, you could do that now that the package references are in a .NET Core-specific project.</span></span>

<span data-ttu-id="b7c40-262">На этом этапе необходимо добавить новый проект в решение BeanTrader и открыть его в Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="b7c40-262">At this point, it should be possible to add the new project to the BeanTrader solution and open it in Visual Studio.</span></span> <span data-ttu-id="b7c40-263">Проект должен выглядеть правильно в **обозревателе решений**, а `dotnet restore BeanTraderClient.Core.csproj` — успешно восстанавливать пакеты (с двумя ожидаемыми предупреждениями, связанными с используемой версией MahApps.Metro, нацеленной на .NET Framework).</span><span class="sxs-lookup"><span data-stu-id="b7c40-263">The project should look correct in **Solution Explorer**, and `dotnet restore BeanTraderClient.Core.csproj` should successfully restore packages (with two expected warnings related to the MahApps.Metro version you're using targeting .NET Framework).</span></span>

<span data-ttu-id="b7c40-264">Хотя оба файла проекта можно сохранить параллельно (и это даже может быть желательно, если вы хотите сохранить сборку старого проекта в том виде, в каком он был), это усложняет процесс переноса (оба проекта будут пытаться использовать одни и те же папки bin и obj), и обычно в этом нет необходимости.</span><span class="sxs-lookup"><span data-stu-id="b7c40-264">Although it's possible to keep both project files side-by-side (and may even be desirable if you want to keep building the old project exactly as it was), it complicates the migration process (the two projects will try to use the same bin and obj folders) and usually isn't necessary.</span></span> <span data-ttu-id="b7c40-265">Если вы хотите выполнить сборку для .NET Core и .NET Framework, в новом файле проекта свойство `<TargetFramework>netcoreapp3.0</TargetFramework>` можно заменить на `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>`.</span><span class="sxs-lookup"><span data-stu-id="b7c40-265">If you want to build for both .NET Core and .NET Framework targets, you can replace the `<TargetFramework>netcoreapp3.0</TargetFramework>` property in the new project file with `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` instead.</span></span> <span data-ttu-id="b7c40-266">Для примера Bean Trader удалите старый файл проекта (BeanTraderClient.csproj), так как он больше не нужен.</span><span class="sxs-lookup"><span data-stu-id="b7c40-266">For the Bean Trader sample, delete the old project file (BeanTraderClient.csproj) since it's no longer needed.</span></span> <span data-ttu-id="b7c40-267">Если вы предпочитаете хранить оба файла проекта, не забудьте создать их в разных выходных и промежуточных путях выходных данных.</span><span class="sxs-lookup"><span data-stu-id="b7c40-267">If you prefer to keep both project files, be sure to have them build to different output and intermediate output paths.</span></span>

## <a name="fix-build-issues"></a><span data-ttu-id="b7c40-268">Устранение проблем сборки</span><span class="sxs-lookup"><span data-stu-id="b7c40-268">Fix build issues</span></span>

<span data-ttu-id="b7c40-269">Третьим шагом процесса переноса является получение проекта для сборки.</span><span class="sxs-lookup"><span data-stu-id="b7c40-269">The third step of the porting process is getting the project to build.</span></span> <span data-ttu-id="b7c40-270">После преобразования файла проекта в проект типа SDK некоторые приложения уже будут успешно собраны.</span><span class="sxs-lookup"><span data-stu-id="b7c40-270">Some apps will already build successfully once the project file is converted to an SDK-style project.</span></span> <span data-ttu-id="b7c40-271">Если это касается вашего приложения, наши поздравления!</span><span class="sxs-lookup"><span data-stu-id="b7c40-271">If that's the case for your app, congratulations!</span></span> <span data-ttu-id="b7c40-272">Вы можете перейти к шагу 4.</span><span class="sxs-lookup"><span data-stu-id="b7c40-272">You can go on to Step 4.</span></span> <span data-ttu-id="b7c40-273">Для сборки других приложений для .NET Core потребуются некоторые обновления.</span><span class="sxs-lookup"><span data-stu-id="b7c40-273">Other apps will need some updates to get them building for .NET Core.</span></span> <span data-ttu-id="b7c40-274">Если вы, например, попробуете запустить `dotnet build` в примере проекта Bean Trader сейчас (или собрать его в Visual Studio), ошибок будет много, но вы их быстро исправите.</span><span class="sxs-lookup"><span data-stu-id="b7c40-274">If you try to run `dotnet build` on the Bean Trader sample project now, for example, (or build it in Visual Studio), there will be many errors, but you'll get them fixed quickly.</span></span>

### <a name="systemservicemodel-references-and-microsoftwindowscompatibility"></a><span data-ttu-id="b7c40-275">Ссылки на System.ServiceModel и Microsoft.Windows.Compatibility</span><span class="sxs-lookup"><span data-stu-id="b7c40-275">System.ServiceModel references and Microsoft.Windows.Compatibility</span></span>

<span data-ttu-id="b7c40-276">Общим источником ошибок является отсутствие ссылок на API, которые доступны для .NET Core, но не включаются в метапакет приложения .NET Core автоматически.</span><span class="sxs-lookup"><span data-stu-id="b7c40-276">A common source of errors is missing references for APIs that are available for .NET Core but not automatically included in the .NET Core app metapackage.</span></span> <span data-ttu-id="b7c40-277">Чтобы это решить, необходимо сослаться на пакет `Microsoft.Windows.Compatibility`.</span><span class="sxs-lookup"><span data-stu-id="b7c40-277">To address this, you should reference the `Microsoft.Windows.Compatibility` package.</span></span> <span data-ttu-id="b7c40-278">Пакет совместимости включает широкий набор интерфейсов API, которые являются общими в классических приложениях Windows, таких как клиент WCF, службы каталогов, реестр, настройка, API ACL и многое другое.</span><span class="sxs-lookup"><span data-stu-id="b7c40-278">The compatibility package includes a broad set of APIs that are common in Windows desktop apps, such as WCF client, directory services, registry, configuration, ACLs APIs, and more.</span></span>

<span data-ttu-id="b7c40-279">В примере Bean Trader большинство ошибок сборки вызваны отсутствием типов <xref:System.ServiceModel>.</span><span class="sxs-lookup"><span data-stu-id="b7c40-279">With the Bean Trader sample, the majority of the build errors are due to missing <xref:System.ServiceModel> types.</span></span> <span data-ttu-id="b7c40-280">Эти вопросы можно решить, обратившись к необходимым пакетам WCF NuGet.</span><span class="sxs-lookup"><span data-stu-id="b7c40-280">These could be addressed by referencing the necessary WCF NuGet packages.</span></span> <span data-ttu-id="b7c40-281">Клиентские API-интерфейсы WCF существуют в пакете `Microsoft.Windows.Compatibility`, поэтому обращение к пакету совместимости является еще лучшим решением (поскольку в нем также рассматриваются любые проблемы, связанные с API, а также решения проблем WCF, которые предоставляют пакет совместимости).</span><span class="sxs-lookup"><span data-stu-id="b7c40-281">WCF client APIs are among those present in the `Microsoft.Windows.Compatibility` package, though, so referencing the compatibility package is an even better solution (since it also addresses any issues related to APIs as well as solutions to the WCF issues that the compatibility package makes available).</span></span> <span data-ttu-id="b7c40-282">Пакет `Microsoft.Windows.Compatibility` помогает в большинстве сценариев переноса WPF и WinForms в .NET Core 3.0.</span><span class="sxs-lookup"><span data-stu-id="b7c40-282">The `Microsoft.Windows.Compatibility` package helps in most .NET Core 3.0 WPF and WinForms porting scenarios.</span></span> <span data-ttu-id="b7c40-283">После добавления ссылки NuGet в `Microsoft.Windows.Compatibility`остается только одна ошибка сборки!</span><span class="sxs-lookup"><span data-stu-id="b7c40-283">After adding the NuGet reference to `Microsoft.Windows.Compatibility`, only one build error remains!</span></span>

### <a name="cleaning-up-unused-files"></a><span data-ttu-id="b7c40-284">Очистка неиспользуемых файлов</span><span class="sxs-lookup"><span data-stu-id="b7c40-284">Cleaning up unused files</span></span>

<span data-ttu-id="b7c40-285">Один тип проблем с переносом, который часто возникает, связан с C# и файлами XAML, которые ранее не были включены в сборку, а теперь предоставляются новыми проектами в стиле SDK, которые автоматически включают в себя *весь* источник.</span><span class="sxs-lookup"><span data-stu-id="b7c40-285">One type of migration issue that comes up often relates to C# and XAML files that weren't previously included in the build getting picked up by the new SDK-style projects that include *all* source automatically.</span></span>

<span data-ttu-id="b7c40-286">Следующая ошибка сборки, отображаемая в примере Bean Trader, относится к неправильной реализации интерфейса в *OldUnusedViewModel.cs*.</span><span class="sxs-lookup"><span data-stu-id="b7c40-286">The next build error you see in the Bean Trader sample refers to a bad interface implementation in *OldUnusedViewModel.cs*.</span></span> <span data-ttu-id="b7c40-287">Имя файла является указанием, но при проверке вы обнаружите, что этот исходный файл неверен.</span><span class="sxs-lookup"><span data-stu-id="b7c40-287">The file name is a hint, but on inspection, you'll find that this source file is incorrect.</span></span> <span data-ttu-id="b7c40-288">Это не вызывало проблем ранее, поскольку файл не включался в исходный проект .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="b7c40-288">It didn't cause issues previously because it wasn't included in the original .NET Framework project.</span></span> <span data-ttu-id="b7c40-289">Исходные файлы, которые содержались на диске, но не включались в старый *csproj*, теперь включены автоматически.</span><span class="sxs-lookup"><span data-stu-id="b7c40-289">Source files that were present on disk but not included in the old *csproj* are included automatically now.</span></span>

<span data-ttu-id="b7c40-290">Для таких однократных проблем файл легко сравнить с предыдущим *csproj*, чтобы подтвердить, что файл не нужен, а затем либо `<Compile Remove="" />` его, либо, если исходный файл больше нигде не нужен, удалить его.</span><span class="sxs-lookup"><span data-stu-id="b7c40-290">For one-off issues like this, it's easy to compare to the previous *csproj* to confirm that the file isn't needed, and then either `<Compile Remove="" />` it or, if the source file isn't needed anywhere anymore, delete it.</span></span> <span data-ttu-id="b7c40-291">В этом случае можно просто удалить *OldUnusedViewModel.cs*.</span><span class="sxs-lookup"><span data-stu-id="b7c40-291">In this case, it's safe to just delete *OldUnusedViewModel.cs*.</span></span>

<span data-ttu-id="b7c40-292">Если у вас есть много исходных файлов, которые необходимо исключить таким образом, можно отключить автоматическое включение файлов C#, задав для свойства `<EnableDefaultCompileItems>` значение false в файле проекта.</span><span class="sxs-lookup"><span data-stu-id="b7c40-292">If you have many source files that would need to be excluded this way, you can disable auto-inclusion of C# files by setting the `<EnableDefaultCompileItems>` property to false in the project file.</span></span> <span data-ttu-id="b7c40-293">Затем вы можете скопировать элементы `<Compile Include>` из старого файла проекта в новый, чтобы собрать только те исходные тексты, которые вы собирались включить.</span><span class="sxs-lookup"><span data-stu-id="b7c40-293">Then, you can copy `<Compile Include>` items from the old project file to the new one in order to only build sources you intended to include.</span></span> <span data-ttu-id="b7c40-294">Аналогичным образом для отключения автоматического включения XAML-страниц можно использовать `<EnableDefaultPageItems>` и `<EnableDefaultItems>` может управлять и тем, и другим с помощью одного свойства.</span><span class="sxs-lookup"><span data-stu-id="b7c40-294">Similarly, `<EnableDefaultPageItems>` can be used to turn off auto-inclusion of XAML pages and `<EnableDefaultItems>` can control both with a single property.</span></span>

### <a name="a-brief-aside-on-multi-pass-compilers"></a><span data-ttu-id="b7c40-295">Краткий обзор компиляторов с несколькими проходами</span><span class="sxs-lookup"><span data-stu-id="b7c40-295">A brief aside on multi-pass compilers</span></span>

<span data-ttu-id="b7c40-296">После удаления из примера Bean Trader файла, вызвавшего ошибку, можно выполнить повторную сборку и получить четыре ошибки.</span><span class="sxs-lookup"><span data-stu-id="b7c40-296">After removing the offending file from the Bean Trader sample, you can re-build and will get four errors.</span></span> <span data-ttu-id="b7c40-297">Не делали это раньше?</span><span class="sxs-lookup"><span data-stu-id="b7c40-297">Didn't you have one before?</span></span> <span data-ttu-id="b7c40-298">Почему количество ошибок увеличилось?</span><span class="sxs-lookup"><span data-stu-id="b7c40-298">Why did the number of errors go up?</span></span> <span data-ttu-id="b7c40-299">Компилятор C# — это [компилятор с несколькими проходами](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span><span class="sxs-lookup"><span data-stu-id="b7c40-299">The C# compiler is a [multi-pass compiler](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span></span> <span data-ttu-id="b7c40-300">Это означает, что он проходит через каждый исходный файл дважды.</span><span class="sxs-lookup"><span data-stu-id="b7c40-300">This means that it goes through each source file twice.</span></span> <span data-ttu-id="b7c40-301">Во-первых, компилятор просто просматривает метаданные и объявления в каждом исходном файле и определяет все проблемы на уровне объявления.</span><span class="sxs-lookup"><span data-stu-id="b7c40-301">First, the compiler just looks at metadata and declarations in each source file and identifies any declaration-level problems.</span></span> <span data-ttu-id="b7c40-302">Вы уже исправили эти ошибки.</span><span class="sxs-lookup"><span data-stu-id="b7c40-302">Those are the errors you've fixed.</span></span> <span data-ttu-id="b7c40-303">Затем он снова проходит через код, чтобы собрать источник на C# в IL; это второй набор ошибок, который вы видите сейчас.</span><span class="sxs-lookup"><span data-stu-id="b7c40-303">Then it goes through the code again to build the C# source into IL; those are the second set of errors that you're seeing now.</span></span>

> [!NOTE]
> <span data-ttu-id="b7c40-304">Компилятор C# делает [более двух проходов](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), но в итоге ошибки компилятора при таких больших изменениях кода, как это, как правило, поступают в две волны.</span><span class="sxs-lookup"><span data-stu-id="b7c40-304">The C# compiler does [more than just two passes](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), but the end result is that compiler errors for large code changes like this tend to come in two waves.</span></span>

### <a name="third-party-dependency-fixes-castlewindsor"></a><span data-ttu-id="b7c40-305">Исправления зависимостей сторонних производителей (Castle.Windsor)</span><span class="sxs-lookup"><span data-stu-id="b7c40-305">Third-party dependency fixes (Castle.Windsor)</span></span>

<span data-ttu-id="b7c40-306">Еще один класс проблем, которые поступают в некоторых сценариях миграции, — различия в API между версиями зависимостей .NET Framework и .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c40-306">Another class of issue that comes up in some migration scenarios is API differences between .NET Framework and .NET Core versions of dependencies.</span></span> <span data-ttu-id="b7c40-307">Даже если пакет NuGet предназначен как для .NET Framework, так и .NET Standard или .NET Core, для разных библиотек может понадобиться использовать различные целевые объекты .NET.</span><span class="sxs-lookup"><span data-stu-id="b7c40-307">Even if a NuGet package targets both .NET Framework and .NET Standard or .NET Core, there may be different libraries for use with different .NET targets.</span></span> <span data-ttu-id="b7c40-308">Это позволяет пакетам поддерживать множество различных платформ .NET, которые могут потребовать различных реализаций.</span><span class="sxs-lookup"><span data-stu-id="b7c40-308">This allows the packages to support many different .NET platforms, which may require different implementations.</span></span> <span data-ttu-id="b7c40-309">Это также означает, что при использовании различных платформ .NET могут возникнуть небольшие различия в библиотеках API.</span><span class="sxs-lookup"><span data-stu-id="b7c40-309">It also means that there may be small API differences in the libraries when targeting different .NET platforms.</span></span>

<span data-ttu-id="b7c40-310">Следующий набор ошибок, которые вы увидите в примере Bean Trader, связан с API `Castle.Windsor`.</span><span class="sxs-lookup"><span data-stu-id="b7c40-310">The next set of errors you'll see in the Bean Trader sample are related to `Castle.Windsor` APIs.</span></span> <span data-ttu-id="b7c40-311">Проект .NET Core Bean Trader использует ту же версию `Castle.Windsor`, что и проект .NET Framework (4.1.1), но реализации этих двух платформ немного отличаются.</span><span class="sxs-lookup"><span data-stu-id="b7c40-311">The .NET Core Bean Trader project uses the same version of `Castle.Windsor` as the .NET Framework-targeted project (4.1.1), but the implementations for those two platforms are slightly different.</span></span>

<span data-ttu-id="b7c40-312">В этом случае вы увидите следующие проблемы, которые необходимо устранить:</span><span class="sxs-lookup"><span data-stu-id="b7c40-312">In this case, you see the following issues that need to be fixed:</span></span>

1. <span data-ttu-id="b7c40-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` недоступен в .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c40-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` isn't available on .NET Core.</span></span> <span data-ttu-id="b7c40-314">Однако существует похожий API `Classes.FromAssemblyContaining` и мы можем заменить оба использования `Classes.FromThisAssembly()` на вызовы `Classes.FromAssemblyContaining(t)`, где `t` — это тип, выполняющий вызов.</span><span class="sxs-lookup"><span data-stu-id="b7c40-314">There is, however, the similar API `Classes.FromAssemblyContaining` available, so we can replace both uses of `Classes.FromThisAssembly()` with calls to `Classes.FromAssemblyContaining(t)`, where `t` is the type making the call.</span></span>
1. <span data-ttu-id="b7c40-315">Аналогичным образом в *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`, который недоступен в .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c40-315">Similarly, in *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`.This is unavailable on .NET Core.</span></span> <span data-ttu-id="b7c40-316">Вместо этого вызов можно заменить на `FromAssembly.Containing(typeof(Bootstrapper))`.</span><span class="sxs-lookup"><span data-stu-id="b7c40-316">Instead, that call can be replaced with `FromAssembly.Containing(typeof(Bootstrapper))`.</span></span>

### <a name="updating-wcf-client-usage"></a><span data-ttu-id="b7c40-317">Обновление использования клиента WCF</span><span class="sxs-lookup"><span data-stu-id="b7c40-317">Updating WCF client usage</span></span>

<span data-ttu-id="b7c40-318">Устраняя различия в `Castle.Windsor`, последняя оставшаяся ошибка сборки в проекте .NET Core Bean Trader заключается в том, что `BeanTraderServiceClient` (который является производным от `DuplexClientBase`) не имеет метода `Open`.</span><span class="sxs-lookup"><span data-stu-id="b7c40-318">Having fixed the `Castle.Windsor` differences, the last remaining build error in the .NET Core Bean Trader project is that `BeanTraderServiceClient` (which derives from `DuplexClientBase`) doesn't have an `Open` method.</span></span> <span data-ttu-id="b7c40-319">Это не удивительно, поскольку это API, который был выделен Анализатором переносимости .NET в начале процесса миграции.</span><span class="sxs-lookup"><span data-stu-id="b7c40-319">This isn't surprising since this is an API that was highlighted by the .NET Portability Analyzer at the beginning of this migration process.</span></span> <span data-ttu-id="b7c40-320">Однако, глядя на `BeanTraderServiceClient`, мы обращаем внимание на большую проблему.</span><span class="sxs-lookup"><span data-stu-id="b7c40-320">Looking at `BeanTraderServiceClient` draws our attention to a larger issue, though.</span></span> <span data-ttu-id="b7c40-321">Этот клиент WCF был автоматически создан средством [Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span><span class="sxs-lookup"><span data-stu-id="b7c40-321">This WCF client was autogenerated by the [Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) tool.</span></span>

<span data-ttu-id="b7c40-322">**Клиенты WCF, созданные Svcutil, предназначены для использования в .NET Framework.**</span><span class="sxs-lookup"><span data-stu-id="b7c40-322">**WCF clients generated by Svcutil are meant for use on .NET Framework.**</span></span>

<span data-ttu-id="b7c40-323">Решения, использующие клиенты WCF, созданные с помощью svcutil, должны повторно создавать совместимые с .NET Standard клиенты для использования с .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c40-323">Solutions that use svcutil-generated WCF clients will need to regenerate .NET Standard-compatible clients for use with .NET Core.</span></span> <span data-ttu-id="b7c40-324">Одна из основных причин, по которой старые клиенты не работают, заключается в том, что они зависят от конфигурации приложения для определения привязок и конечных точек WCF.</span><span class="sxs-lookup"><span data-stu-id="b7c40-324">One of the main reasons the old clients won't work is that they depend on app configuration for defining WCF bindings and endpoints.</span></span> <span data-ttu-id="b7c40-325">Поскольку API-интерфейсы WCF .NET Standard могут работать на разных платформах (когда API System.Configuration недоступны), клиенты WCF для сценариев .NET Core и .NET Standard должны определять привязки и конечные точки программно, а не в конфигурации.</span><span class="sxs-lookup"><span data-stu-id="b7c40-325">Because .NET Standard WCF APIs can work cross-platform (where System.Configuration APIs aren't available), WCF clients for .NET Core and .NET Standard scenarios must define bindings and endpoints programmatically instead of in configuration.</span></span>

<span data-ttu-id="b7c40-326">Фактически любое использование клиента WCF, которое зависит от раздела `<system.serviceModel>` app.config (созданного с помощью Svcutil или вручную), необходимо изменить для работы в .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c40-326">In fact, any WCF client usage that depends on the `<system.serviceModel>` app.config section (whether created with Svcutil or manually) will need to be changed to work on .NET Core.</span></span>

<span data-ttu-id="b7c40-327">Существует два способа автоматического создания совместимых с .NET Standard клиентов WCF:</span><span class="sxs-lookup"><span data-stu-id="b7c40-327">There are two ways to automatically generate .NET Standard-compatible WCF clients:</span></span>

- <span data-ttu-id="b7c40-328">Средство `dotnet-svcutil` — это средство .NET, которое создает клиенты WCF таким же образом, как ранее работал Svcutil.</span><span class="sxs-lookup"><span data-stu-id="b7c40-328">The `dotnet-svcutil` tool is a .NET tool that generates WCF clients in a way that is similar to how Svcutil worked previously.</span></span>
- <span data-ttu-id="b7c40-329">Visual Studio может создавать клиенты WCF с помощью параметра [WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) его функции Подключенных служб.</span><span class="sxs-lookup"><span data-stu-id="b7c40-329">Visual Studio can generate WCF clients using the [WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) option of its Connected Services feature.</span></span>

<span data-ttu-id="b7c40-330">Любой из этих подходов хорошо работает.</span><span class="sxs-lookup"><span data-stu-id="b7c40-330">Either approach works well.</span></span> <span data-ttu-id="b7c40-331">Конечно же, код клиента WCF можно написать самостоятельно.</span><span class="sxs-lookup"><span data-stu-id="b7c40-331">Alternatively, of course, you could write the WCF client code yourself.</span></span> <span data-ttu-id="b7c40-332">В этом примере я решил использовать функцию Подключенной службы Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="b7c40-332">For this sample, I chose to use the Visual Studio Connected Service feature.</span></span> <span data-ttu-id="b7c40-333">Для этого щелкните правой кнопкой мыши проект *BeanTraderClient.Core* в обозревателе решений Visual Studio и выберите **Добавить** > **Подключенная служба**.</span><span class="sxs-lookup"><span data-stu-id="b7c40-333">To do that, right-click on the *BeanTraderClient.Core* project in Visual Studio's solution explorer and select **Add** > **Connected Service**.</span></span> <span data-ttu-id="b7c40-334">Затем выберите Microsoft WCF Web Service Reference Provider.</span><span class="sxs-lookup"><span data-stu-id="b7c40-334">Next, choose the WCF Web Service Reference Provider.</span></span> <span data-ttu-id="b7c40-335">Откроется диалоговое окно, в котором можно указать адрес внутренней веб-службы Bean Trader (`localhost:8080`, если сервер выполняется локально) и пространство имен, которое должны использовать создаваемые типы (например, **BeanTrader.Service**).</span><span class="sxs-lookup"><span data-stu-id="b7c40-335">This will bring up a dialog where you can specify the address of the backend Bean Trader web service (`localhost:8080` if you are running the server locally) and the namespace that generated types should use (**BeanTrader.Service**, for example).</span></span>

![Диалоговое окно подключенной службы для WCF Web Service Reference](./media/convert-project-from-net-framework/connected-service-dialog.png)

<span data-ttu-id="b7c40-337">После нажатия кнопки **Готово** в проект добавляется новый узел "Подключенные службы", а в этот узел добавляется файл Reference.cs, содержащий новый клиент WCF .NET Standard для доступа к службе Bean Trader.</span><span class="sxs-lookup"><span data-stu-id="b7c40-337">After you select the **Finish** button, a new Connected Services node is added to the project and a Reference.cs file is added under that node containing the new .NET Standard WCF client for accessing the Bean Trader service.</span></span> <span data-ttu-id="b7c40-338">Если взглянуть на методы `GetEndpointAddress` или `GetBindingForEndpoint` в этом файле, вы увидите, что привязки и конечные точки теперь создаются программно (вместо использования конфигурации приложения).</span><span class="sxs-lookup"><span data-stu-id="b7c40-338">If you look at the `GetEndpointAddress` or `GetBindingForEndpoint` methods in that file, you'll see that bindings and endpoints are now generated programmatically (instead of via app config).</span></span> <span data-ttu-id="b7c40-339">Функция "Add Connected Services" (Добавить Подключенные службы) также может добавлять в файл проекта ссылки на некоторые пакеты System.ServiceModel, которые не нужны, так как все необходимые пакеты WCF включены через Microsoft.Windows.Compatibility.</span><span class="sxs-lookup"><span data-stu-id="b7c40-339">The 'Add Connected Services' feature may also add references to some System.ServiceModel packages in the project file, which aren't needed since all necessary WCF packages are included via Microsoft.Windows.Compatibility.</span></span> <span data-ttu-id="b7c40-340">Проверьте csproj, чтобы узнать, добавлены ли какие-либо дополнительные элементы System.ServiceModel `<PackageReference>`, и если да, удалите их.</span><span class="sxs-lookup"><span data-stu-id="b7c40-340">Check the csproj to see if any extra System.ServiceModel `<PackageReference>` items have been added, and if so, remove them.</span></span>

<span data-ttu-id="b7c40-341">Наш проект теперь содержит новые клиентские классы WCF (в *Reference.cs*), но по-прежнему также содержит старые (в BeanTrader.cs).</span><span class="sxs-lookup"><span data-stu-id="b7c40-341">Our project has new WCF client classes now (in *Reference.cs*), but it also still has the old ones (in BeanTrader.cs).</span></span> <span data-ttu-id="b7c40-342">На этом этапе есть два варианта:</span><span class="sxs-lookup"><span data-stu-id="b7c40-342">There are two options at this point:</span></span>

- <span data-ttu-id="b7c40-343">Если вы хотите создать исходный проект .NET Framework (наряду с новым целевым объектом .NET Core), можно использовать элемент `<Compile Remove="BeanTrader.cs" />` в файле csproj проекта .NET Core, чтобы в версии приложения .NET Framework и в .NET Core использовались разные клиенты WCF.</span><span class="sxs-lookup"><span data-stu-id="b7c40-343">If you want to be able to build the original .NET Framework project (alongside the new .NET Core-targeted one), you can use a `<Compile Remove="BeanTrader.cs" />` item in the .NET Core project's csproj file so that the .NET Framework and .NET Core versions of the app use different WCF clients.</span></span> <span data-ttu-id="b7c40-344">Это имеет преимущество, поскольку оставляет существующий проект .NET Framework без изменений, но и недостаток, заключающийся в том, что код, использующий сгенерированные клиенты WCF, может использоваться несколько иначе в случае .NET Core, чем это было в проекте .NET Framework, так что для условной компиляции некоторого использования клиента WCF (создание клиентов, например), скорее всего, потребуется использовать директивы `#if`, чтобы работать в одном направлении при сборке для .NET Core и в другом — при сборке для .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="b7c40-344">This has the advantage of leaving the existing .NET Framework project unchanged, but has the disadvantage that code using the generated WCF clients may need to be slightly different in the .NET Core case than it was in the .NET Framework project, so you'll likely need to use `#if` directives to conditionally compile some WCF client usage (creating clients, for example) to work one way when built for .NET Core and another way when built for .NET Framework.</span></span>

- <span data-ttu-id="b7c40-345">Если, с другой стороны, некоторые изменения кода в существующем проекте .NET Framework приемлемы, вы можете удалить *BeanTrader.cs* полным составом.</span><span class="sxs-lookup"><span data-stu-id="b7c40-345">If, on the other hand, some code churn in the existing .NET Framework project is acceptable, you can remove *BeanTrader.cs* all together.</span></span> <span data-ttu-id="b7c40-346">Поскольку новый клиент WCF создан для .NET Standard, он будет работать в сценариях .NET Core и .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="b7c40-346">Because the new WCF client is built for .NET Standard, it will work in both .NET Core and .NET Framework scenarios.</span></span> <span data-ttu-id="b7c40-347">При создании для .NET Framework в дополнение к .NET Core (для нескольких версий или с помощью двух файлов csproj) этот новый файл *Reference.cs* можно использовать для обоих целевых объектов.</span><span class="sxs-lookup"><span data-stu-id="b7c40-347">If you are building for .NET Framework in addition to .NET Core (either by multi-targeting or by having two csproj files), you can use this new *Reference.cs* file for both targets.</span></span> <span data-ttu-id="b7c40-348">Преимущество такого подхода заключается в том, что код не будет нуждаться в бифуркации для поддержки двух различных клиентов WCF; один и тот же код будет использоваться везде.</span><span class="sxs-lookup"><span data-stu-id="b7c40-348">This approach has the advantage that the code won't need to bifurcate to support two different WCF clients; the same code will be used everywhere.</span></span> <span data-ttu-id="b7c40-349">Недостаток заключается в том, что он включает изменение (предположительно стабильного) проекта .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="b7c40-349">The drawback is that it involves changing the (presumably stable) .NET Framework project.</span></span>

<span data-ttu-id="b7c40-350">В случае с примером Bean Trader можно внести небольшие изменения в исходный проект, если это упростит перенос, поэтому выполните следующие действия для согласования использования клиента WCF:</span><span class="sxs-lookup"><span data-stu-id="b7c40-350">In the case of the Bean Trader sample, you can make small changes to the original project if it makes migration easier, so follow these steps to reconcile WCF client usage:</span></span>

01. <span data-ttu-id="b7c40-351">Добавьте новый файл Reference.cs в проект .NET Framework *BeanTraderClient.csproj* с помощью контекстного меню "Добавить существующий элемент" в обозревателе решений.</span><span class="sxs-lookup"><span data-stu-id="b7c40-351">Add the new Reference.cs file to the .NET Framework *BeanTraderClient.csproj* project using the 'Add existing item' context menu from the solution explorer.</span></span> <span data-ttu-id="b7c40-352">Не забудьте добавить "в качестве ссылки", чтобы один и тот же файл использовался обоими проектами (в отличие от копирования файла C#).</span><span class="sxs-lookup"><span data-stu-id="b7c40-352">Be sure to add 'as link' so that the same file is used by both projects (as opposed to copying the C# file).</span></span> <span data-ttu-id="b7c40-353">При создании для .NET Core и .NET Framework с одним csproj (с использованием настройки для различных версий) этот шаг не требуется.</span><span class="sxs-lookup"><span data-stu-id="b7c40-353">If you are building for both .NET Core and .NET Framework with a single csproj (using multi-targeting) then this step isn't necessary.</span></span>

01. <span data-ttu-id="b7c40-354">Удалите *BeanTrader.cs*.</span><span class="sxs-lookup"><span data-stu-id="b7c40-354">Delete *BeanTrader.cs*.</span></span>

01. <span data-ttu-id="b7c40-355">Новый клиент WCF аналогичен старому, но некоторые пространства имен в созданном коде отличаются.</span><span class="sxs-lookup"><span data-stu-id="b7c40-355">The new WCF client is similar to the old one, but a number of namespaces in the generated code are different.</span></span> <span data-ttu-id="b7c40-356">Поэтому необходимо обновить проект таким образом, чтобы типы клиента WCF использовались из BeanTrader.Service (или любого выбранного имени пространства имен) вместо BeanTrader.Model или без пространства имен.</span><span class="sxs-lookup"><span data-stu-id="b7c40-356">Because of this, it is necessary to update the project so that WCF client types are used from BeanTrader.Service (or whatever namespace name you chose) instead of BeanTrader.Model or without a namespace.</span></span> <span data-ttu-id="b7c40-357">Сборка *BeanTraderClient.Core.csproj* поможет определить, где необходимо внести эти изменения.</span><span class="sxs-lookup"><span data-stu-id="b7c40-357">Building *BeanTraderClient.Core.csproj* will help to identify where these changes need to be made.</span></span> <span data-ttu-id="b7c40-358">Исправления понадобятся как в C#, так и в исходных файлах XAML.</span><span class="sxs-lookup"><span data-stu-id="b7c40-358">Fixes will be needed both in C# and in XAML source files.</span></span>

01. <span data-ttu-id="b7c40-359">Наконец, вы обнаружите ошибку в *BeanTraderServiceClientFactory.cs*, поскольку доступные конструкторы для типа `BeanTraderServiceClient` изменились.</span><span class="sxs-lookup"><span data-stu-id="b7c40-359">Finally, you'll discover that there is an error in *BeanTraderServiceClientFactory.cs* because the available constructors for the `BeanTraderServiceClient` type have changed.</span></span> <span data-ttu-id="b7c40-360">Он использовался для предоставления аргумента `InstanceContext` (который был создан с помощью `CallbackHandler` из контейнера `Castle.Windsor` IoC).</span><span class="sxs-lookup"><span data-stu-id="b7c40-360">It used to be possible to supply an `InstanceContext` argument (which was created using a `CallbackHandler` from the `Castle.Windsor` IoC container).</span></span> <span data-ttu-id="b7c40-361">Новые конструкторы создают новые `CallbackHandler`.</span><span class="sxs-lookup"><span data-stu-id="b7c40-361">The new constructors create new `CallbackHandler`s.</span></span> <span data-ttu-id="b7c40-362">Однако в базовом типе`BeanTraderServiceClient` есть конструкторы, соответствующие тем, которые вам нужны.</span><span class="sxs-lookup"><span data-stu-id="b7c40-362">There are, however, constructors in `BeanTraderServiceClient`'s base type that match what you want.</span></span> <span data-ttu-id="b7c40-363">Так как автоматически сформированный клиентский код WCF существует в разделяемых классах, его можно легко расширить.</span><span class="sxs-lookup"><span data-stu-id="b7c40-363">Since the autogenerated WCF client code all exists in partial classes, you can easily extend it.</span></span> <span data-ttu-id="b7c40-364">Для этого создайте новый файл с именем *BeanTraderServiceClient.cs*, а затем — разделяемый класс с тем же именем (с помощью пространства имен BeanTrader.Service).</span><span class="sxs-lookup"><span data-stu-id="b7c40-364">To do this, create a new file called *BeanTraderServiceClient.cs* and then create a partial class with that same name (using the BeanTrader.Service namespace).</span></span> <span data-ttu-id="b7c40-365">Затем добавьте один конструктор к разделяемому типу, как показано здесь.</span><span class="sxs-lookup"><span data-stu-id="b7c40-365">Then, add one constructor to the partial type as shown here.</span></span>

    ```csharp
    public BeanTraderServiceClient(System.ServiceModel.InstanceContext callbackInstance) :
        base(callbackInstance, EndpointConfiguration.NetTcpBinding_BeanTraderService)
            { }
    ```

<span data-ttu-id="b7c40-366">После внесения этих изменений в примере Bean Trader будет использоваться новый клиент WCF, совместимый с .NET Standard, и вы сможете внести окончательное исправление изменения вызова `Open` в *TradingService.cs*, чтобы вместо этого использовать `await OpenAsync`.</span><span class="sxs-lookup"><span data-stu-id="b7c40-366">With those changes made, the Bean Trader sample will now be using a new .NET Standard-compatible WCF client and you can make the final fix of changing the `Open` call in *TradingService.cs* to use `await OpenAsync` instead.</span></span>

<span data-ttu-id="b7c40-367">С учетом проблем, устраняемых WCF, версия .NET Core примера Bean Trader теперь будет построена четко.</span><span class="sxs-lookup"><span data-stu-id="b7c40-367">With the WCF issues addressed, the .NET Core version of the Bean Trader sample now builds cleanly!</span></span>

## <a name="runtime-testing"></a><span data-ttu-id="b7c40-368">Тестирование среды выполнения</span><span class="sxs-lookup"><span data-stu-id="b7c40-368">Runtime testing</span></span>

<span data-ttu-id="b7c40-369">Легко забыть, что работа по переносу не завершается после четкого построения проекта на основе .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c40-369">It's easy to forget that migration work isn't done as soon as the project builds cleanly against .NET Core.</span></span> <span data-ttu-id="b7c40-370">Очень важно оставить время для тестирования приложения.</span><span class="sxs-lookup"><span data-stu-id="b7c40-370">It's important to leave time for testing the ported app, too.</span></span> <span data-ttu-id="b7c40-371">После успешного построения убедитесь, что приложение не просто работает, а работает должным образом, особенно если вы используете пакеты, предназначенные для .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="b7c40-371">Once things build successfully, make sure the app runs and works as expected, especially if you are using any packages targeting .NET Framework.</span></span>

<span data-ttu-id="b7c40-372">Давайте попробуем запустить перенесенное приложение Bean Trader и посмотрим, что произойдет.</span><span class="sxs-lookup"><span data-stu-id="b7c40-372">Let's try launching the ported Bean Trader app and see what happens.</span></span> <span data-ttu-id="b7c40-373">Приложение почти сразу завершается ошибкой со следующим исключением.</span><span class="sxs-lookup"><span data-stu-id="b7c40-373">The app doesn't get far before failing with the following exception.</span></span>

```output
System.Configuration.ConfigurationErrorsException: 'Configuration system failed to initialize'

Inner Exception
ConfigurationErrorsException: Unrecognized configuration section system.serviceModel.
```

<span data-ttu-id="b7c40-374">В этом, конечно, есть смысл.</span><span class="sxs-lookup"><span data-stu-id="b7c40-374">This makes sense, of course.</span></span> <span data-ttu-id="b7c40-375">Помните, что WCF больше не использует конфигурацию приложения, поэтому старую секцию system.serviceModel файла app.config необходимо удалить.</span><span class="sxs-lookup"><span data-stu-id="b7c40-375">Remember that WCF no longer uses app configuration, so the old system.serviceModel section of the app.config file needs to be removed.</span></span> <span data-ttu-id="b7c40-376">Обновленный клиент WCF включает в себя всю ту же информацию в своем коде, поэтому раздел конфигурации больше не нужен.</span><span class="sxs-lookup"><span data-stu-id="b7c40-376">The updated WCF client includes all of the same information in its code, so the config section isn't needed anymore.</span></span> <span data-ttu-id="b7c40-377">Если вы хотите, чтобы конечная точка WCF была настроена в файле app.config, добавьте ее в качестве параметра приложения и обновите код клиента WCF, чтобы получить конечную точку службы WCF из конфигурации.</span><span class="sxs-lookup"><span data-stu-id="b7c40-377">If you wanted the WCF endpoint to be configurable in app.config, you could add it as an app setting and update the WCF client code to retrieve the WCF service endpoint from configuration.</span></span>

<span data-ttu-id="b7c40-378">После удаления раздела system.serviceModel *app.config* приложение запускается, но завершается с другим исключением при входе пользователя в систему.</span><span class="sxs-lookup"><span data-stu-id="b7c40-378">After removing the system.serviceModel section of *app.config*, the app launches but fails with another exception when a user signs in.</span></span>

```output
System.PlatformNotSupportedException: 'Operation is not supported on this platform.'
```

<span data-ttu-id="b7c40-379">Неподдерживаемый API — `Func<T>.BeginInvoke`.</span><span class="sxs-lookup"><span data-stu-id="b7c40-379">The unsupported API is `Func<T>.BeginInvoke`.</span></span> <span data-ttu-id="b7c40-380">Как описано в [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940), .NET Core не поддерживает методы `BeginInvoke` и `EndInvoke` в типах делегатов из-за зависимостей с базовым удаленным взаимодействием.</span><span class="sxs-lookup"><span data-stu-id="b7c40-380">As explained in [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940), .NET Core doesn't support the `BeginInvoke` and `EndInvoke` methods on delegate types due to underlying remoting dependencies.</span></span> <span data-ttu-id="b7c40-381">Эта проблема и ее исправление более подробно описаны в записи блога [Перенос вызовов Delegate.BeginInvoke для .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/), но именно в этом случае вызовы `BeginInvoke` и `EndInvoke` следует заменить на `Task.Run` (или асинхронные альтернативы, если это возможно).</span><span class="sxs-lookup"><span data-stu-id="b7c40-381">This issue and its fix are explained in more detail in the [Migrating Delegate.BeginInvoke Calls for .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) blog post, but the gist is that `BeginInvoke` and `EndInvoke` calls should be replaced with `Task.Run` (or async alternatives, if possible).</span></span> <span data-ttu-id="b7c40-382">Применяя общее решение, вызов `BeginInvoke` можно заменить на вызов `Invoke`, запускаемый `Task.Run`.</span><span class="sxs-lookup"><span data-stu-id="b7c40-382">Applying the general solution here, the `BeginInvoke` call can be replaced with an `Invoke` call launched by `Task.Run`.</span></span>

```csharp
Task.Run(() =>
{
    return userInfoRetriever.Invoke();
}).ContinueWith(result =>
{
    // BeginInvoke's callback is replaced with ContinueWith
    var task = result.ConfigureAwait(false);
    CurrentTrader = task.GetAwaiter().GetResult();
}, TaskScheduler.Default);
```

<span data-ttu-id="b7c40-383">После удаления использования `BeginInvoke` приложение Bean Trader успешно работает в .NET Core!</span><span class="sxs-lookup"><span data-stu-id="b7c40-383">After removing the `BeginInvoke` usage, the Bean Trader app runs successfully on .NET Core!</span></span>

![Bean Trader, работающий на .NET Core](./media/convert-project-from-net-framework/running-on-core.png)

<span data-ttu-id="b7c40-385">Все приложения отличаются друг от друга, поэтому конкретные шаги, необходимые для миграции собственных приложений на .NET Core, будут отличаться.</span><span class="sxs-lookup"><span data-stu-id="b7c40-385">All apps are different, so the specific steps needed to migrate your own apps to .NET Core will vary.</span></span> <span data-ttu-id="b7c40-386">Но надеюсь, что в примере Bean Trader продемонстрирован общий рабочий процесс и типы проблем, которые можно ожидать.</span><span class="sxs-lookup"><span data-stu-id="b7c40-386">But hopefully the Bean Trader sample demonstrates the general workflow and the types of issues that can be expected.</span></span> <span data-ttu-id="b7c40-387">И несмотря на большой размер этой статьи, реальные изменения, необходимые в примере Bean Trader, чтобы он работал на .NET Core, были довольно незначительными.</span><span class="sxs-lookup"><span data-stu-id="b7c40-387">And, despite this article's length, the actual changes needed in the Bean Trader sample to make it work on .NET Core were fairly limited.</span></span> <span data-ttu-id="b7c40-388">Переход многих приложений в .NET Core происходит таким же образом; с небольшими изменениями кода или даже без них.</span><span class="sxs-lookup"><span data-stu-id="b7c40-388">Many apps migrate to .NET Core in this same way; with limited or even no code changes needed.</span></span>
