---
title: Миграция WPF Приложения на .NET Core 3.0
description: Узнайте, как перенести приложение Windows Presentation Foundation (WPF) в .NET Core 3.0.
author: mjrousos
ms.date: 09/12/2019
ms.author: mikerou
ms.openlocfilehash: f52005e7c8a6312b8c4e09a950f1f635af1894e4
ms.sourcegitcommit: cdf5084648bf5e77970cbfeaa23f1cab3e6e234e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/01/2020
ms.locfileid: "81432596"
---
# <a name="migrating-wpf-apps-to-net-core"></a>Миграция приложений WPF в ядро .NET

В этой статье рассматриваются шаги, необходимые для переноса приложения Windows Presentation Foundation (WPF) из рамочного .NET в .NET Core 3.0. Если у вас нет приложения WPF под рукой, чтобы порт, но хотели бы опробовать процесс, вы можете использовать образец приложения **Bean Trader,** доступный на [GitHub.](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) Оригинальное приложение (таргетинг .NET Framework 4.7.2) доступно в папке NetFx-BeanTraderClient. Сначала мы объясним шаги, необходимые для переноса приложений в целом, а затем мы пройдемся по конкретным изменениям, которые применяются к образцу **Bean Trader.**

[!INCLUDE [desktop guide under construction](../../../includes/desktop-guide-preview-note.md)]

Чтобы перейти на ядро .NET, необходимо сначала:

01. Понимание и обновление зависимостей NuGet:

    01. Обновление зависимостей NuGet `<PackageReference>` для использования формата.
    01. Просмотрите зависимость на высшем уровне NuGet для совместимости .NET Core или .NET Standard.
    01. Обновление пакетов NuGet до новых версий.
    01. Используйте [анализатор портативности .NET,](../../standard/analyzers/portability-analyzer.md) чтобы понять зависимости .NET.

01. Перевежните файл проекта в новый формат sDK:

    01. Выберите, таргетировать ли основное ядро .NET и рамки .NET, или только на ядро .NET.
    01. Копирование соответствующих свойств файлов проекта и элементов в новый файл проекта.

01. Исправление проблем со сборкой:

    01. Добавьте ссылку на пакет [Microsoft.Windows.Compatibility.](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/)
    01. Найдите и исправьте различия уровня API.
    01. Удалите разделы *app.config,* кроме `appSettings` или `connectionStrings`.
    01. При необходимости регенерировать генерируемый код.

01. Тестирование времени выполнения:

    01. Подтвердите, что портированное приложение работает как ожидалось.
    01. Остерегайтесь исключений. <xref:System.NotSupportedException>

## <a name="about-the-sample"></a>Сведения о примере

В этой статье содержится ссылка на [пример приложения Bean Trader,](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) поскольку оно использует различные зависимости, аналогичные тем, которые могут иметь реальные приложения WPF. Приложение не большой, но предназначен для шага вверх от "Hello World" с точки зрения сложности. Приложение демонстрирует некоторые проблемы, с которыми пользователи могут столкнуться при переносе реальных приложений. Приложение общается с службой WCF, так что для того, чтобы работать должным образом, вам также нужно запустить проект BeanTraderServer (доступно в том же репозитории GitHub) и убедитесь, что конфигурация BeanTraderClient указывает на правильную конечную точку. (По умолчанию, образец предполагает, что сервер *http://localhost:8090*работает на той же машине, что будет верно, если вы запустите BeanTraderServer локально.)

Имейте в виду, что этот пример приложения предназначен для демонстрации проблем и решений переноса .NET Core Core. Она не предназначена для демонстрации передового опыта WPF. В самом деле, он намеренно включает в себя некоторые анти-шаблоны, чтобы убедиться, что вы столкнетесь по крайней мере пару интересных проблем при переносе.

## <a name="getting-ready"></a>Подготовка

Основная проблема переноса приложения .NET Framework в ядро .NET заключается в том, что его зависимости могут работать по-другому или вообще не работать. Миграция намного проще, чем раньше; многие пакеты NuGet теперь нацелены на стандарт .NET. Начиная с .NET Core 2.0, поверхностные зоны .NET И.NET и .NET Core стали похожими. Несмотря на это, некоторые различия (как в поддержку пакетов NuGet, так и в доступных AIS .NET) остаются. Первым шагом в миграции является проверка зависимостей приложения и обеспечение того, чтобы ссылки были в формате, который легко переносится в ядро .NET.

### <a name="upgrade-to-packagereference-nuget-references"></a>Обновление `<PackageReference>` до ссылок NuGet

Старые проекты .NET Framework обычно перечисляют свои зависимости NuGet в файле *packages.config.* Новый формат файла проекта в стиле SDK [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) ссылается на пакеты NuGet как на элементы в самом файле csproj, а не в отдельном файле конфигурации.

При миграции есть два преимущества `<PackageReference>`использования ссылок в стиле:

- Это стиль ссылки NuGet, который необходим для нового файла проекта .NET Core. Если вы уже `<PackageReference>`используете, эти элементы файла проекта могут быть скопированы и вставлены непосредственно в новый проект.
- В отличие от файла `<PackageReference>` packages.config, элементы относятся только к зависимостям верхнего уровня, от которых напрямую зависит ваш проект. Все остальные транзитные пакеты NuGet будут определены во время восстановления и записаны в автогенерированном файле obj'project.assets.json. Это значительно упрощает определение зависимостей проекта, что полезно при определении того, будут ли необходимые зависимости работать на .NET Core или нет.

Первым шагом к переходу приложения .NET Framework в ядро .NET является обновление его для использования `<PackageReference>` ссылок NuGet. Visual Studio делает это простым. Просто право нажмите *на пакет проекта.конфигурация* файл в Visual Studio **Solution Explorer**, а затем выберите **Migrate packages.config к PackageReference**.

![Обновление до PackageReference](./media/convert-project-from-net-framework/package-reference-migration.png)

Появляется диалог, показывающий рассчитанные зависимые от NuGet верхнего уровня и спрашивающий, какие другие пакеты NuGet следует продвигать на высший уровень. Ни один из этих других пакетов не должен быть на высшем уровне для образца Bean Trader, так что вы можете отменить все эти коробки. Затем нажмите **Ok** и файл *packages.config* удаляется и `<PackageReference>` элементы добавляются в файл проекта.

`<PackageReference>`- Ссылки в стиле не хранят пакеты NuGet локально в папке пакетов. Вместо этого они хранятся по всему миру в качестве оптимизации. После завершения миграции отойдите от файла `<Analyzer>` csproj и удалите все элементы, относящиеся к анализателям, которые ранее пришли из *.. Каталог пакетов.* Не волнуйтесь; так как у вас все еще есть ссылки на пакет NuGet, анализаторы будут включены в проект. Вам просто нужно очистить старые элементы в `<Analyzer>` стиле packages.config.

### <a name="review-nuget-packages"></a>Просмотр пакетов NuGet

Теперь, когда вы можете увидеть пакеты NuGet верхнего уровня, от которого зависит проект, можно просмотреть, доступны ли эти пакеты на .NET Core. Вы можете определить, поддерживает ли пакет .NET Core, глядя на его зависимости от [nuget.org.](https://www.nuget.org/) Созданный сообществом [fuget.org](https://www.fuget.org/) сайт показывает эту информацию на видном месте в верхней части страницы информации пакета.

При таргетинге .NET Core 3.0 должны работать любые пакеты, ориентированные на .NET Core или .NET Standard (поскольку .NET Core реализует область поверхности .NET Standard). В некоторых случаях конкретная версия используемого пакета не будет нацелена на .NET Core или .NET Standard, но новые версии будут. В этом случае следует рассмотреть вопрос о переходе на последнюю версию пакета.

Вы также можете использовать пакеты, таргетинг на .NET Framework, но это создает определенный риск. "Ядро" для зависимостей .NET Framework разрешено, поскольку поверхностные области .NET Core и .NET Framework достаточно похожи, чтобы такие зависимости *часто* работали. Однако, если пакет попытается использовать API .NET, который не присутствует в ядро .NET, вы столкнетесь с исключением времени выполнения. Из-за этого следует ссылаться только на пакеты .NET Framework, когда нет других вариантов, и понимать, что это накладывает на тестовый груз.

Если на них ссылаются пакеты, не нацеленные на .NET Core или .NET Standard, вам придется подумать о других альтернативах:

- Есть ли другие аналогичные пакеты, которые могут быть использованы вместо этого? Иногда авторы NuGet публикуют отдельные '. Основные версии своих библиотек специально ориентированы на .NET Core. Пакеты корпоративной библиотеки являются примером публикации сообщества ". NetCore" альтернативы. В других случаях для .NET Standard доступны новые SDK для конкретной службы (иногда с разными названиями пакетов). Если альтернативы нет, вы можете продолжить использование пакетов, ориентированных на рамочную программу .NET, имея в виду, что вам нужно будет тщательно протестировать их после запуска на .NET Core.

Образец Bean Trader имеет следующие верхние уровни зависимостей NuGet:

- [**Castle.Windsor, версия 4.1.1**](https://www.castleproject.org/projects/windsor/)  

  Этот пакет нацелен на .NET Standard 1.6, поэтому он работает на ядро .NET.

- [**Microsoft.CodeAnalysis.FxCopAnalyzers, версия 2.6.3**](https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers/2.6.3)  
  Это мета-пакет, так что не сразу очевидно, какие платформы он поддерживает, но [документация](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) указывает, что его новейшая версия (2.9.2) будет работать как для .NET Framework и .NET Core.

- [**Nito.AsyncEx, версия 4.0.1**](https://www.nuget.org/packages/Nito.AsyncEx/4.0.1)  

  Этот пакет не нацелен на ядро .NET, но делает более новая версия 5.0. Это часто происходит при миграции, поскольку многие пакеты NuGet недавно добавили поддержку .NET Standard, но старые версии проектов будут нацелены только на .NET Framework. Если разница в версии является лишь незначительным отличием версии, часто легко перейти на более новую версию. Поскольку это основное изменение версии, необходимо быть осторожным обновлением, так как в пакете могут быть изменения. Существует путь вперед, хотя, что хорошо.

- [**MahApps.Metro, версия 1.6.5**](https://www.nuget.org/packages/MahApps.Metro/1.6.5)  

  Этот пакет также не нацелен на ядро .NET, но имеет более новую предварительную версию (2.0-альфа), которая делает. Опять же, вы должны смотреть на нарушение изменений, но новый пакет обнадеживает.

NuGet-зависимости образца Bean Trader нацелены либо на .NET Standard/.NET Core, либо имеют более новые версии, которые делают, так что здесь вряд ли будут какие-либо проблемы с блокировкой.

### <a name="upgrade-nuget-packages"></a>Обновление пакетов NuGet

Если это возможно, было бы хорошо обновить версии любых пакетов, которые нацелены только на .NET Core или .NET Standard с более поздними версиями на данный момент (с проектом, все еще ориентированным на .NET Framework), чтобы обнаружить и устранить любые изменения на ранних стадиях.

Если вы не хотите вносить какие-либо существенные изменения в существующую версию приложения .NET Framework, это может подождать, пока у вас не будет нового файла проекта, ориентированного на .NET Core. Однако обновление пакетов NuGet до версий, совместимых с ядром .NET, заблаговременно упрощает процесс миграции после создания нового файла проекта и уменьшает количество различий между версиями приложения .NET и .NET Core.

С образцом Bean Trader, все необходимые обновления могут быть сделаны легко (с помощью Visual Studio в NuGet менеджер пакета) с одним исключением: обновление от **MahApps.Metro 1.6.5** до **2.0** показывает нарушение изменения, связанные с темой и акцент управления AIS.

В идеале приложение будет обновляться, чтобы использовать более новую версию пакета (поскольку это, скорее всего, будет работать на .NET Core). Однако в некоторых случаях это может оказаться неосуществимым. В этих случаях не обновляйте **MahApps.Metro,** потому что необходимые изменения нетривиальны, и этот учебник фокусируется на переходе в .NET Core 3, а не на **MahApps.Metro 2.** Кроме того, это низкорисковый .NET Рамочный зависимость, потому что приложение Bean Trader только осуществляет небольшую часть **MahApps.Metro**. Это, конечно, потребует тестирования, чтобы убедиться, что все работает, как только миграция будет завершена. Если бы это был реальный сценарий, было бы хорошо, чтобы подать вопрос для отслеживания работы, чтобы перейти к **Версии MahApps.Metro** 2.0, так как не делать миграции в настоящее время оставляет позади некоторые технические задолженности.

После обновления пакетов NuGet до последних версий группа `<PackageReference>` элементов в файле проекта образца Bean Trader должна выглядеть следующим образом.

```xml
<ItemGroup>
  <PackageReference Include="Castle.Windsor">
    <Version>4.1.1</Version>
  </PackageReference>
  <PackageReference Include="MahApps.Metro">
    <Version>1.6.5</Version>
  </PackageReference>
  <PackageReference Include="Microsoft.CodeAnalysis.FxCopAnalyzers">
    <Version>2.9.2</Version>
  </PackageReference>
  <PackageReference Include="Nito.AsyncEx">
    <Version>5.0.0</Version>
  </PackageReference>
</ItemGroup>
```

### <a name="net-framework-portability-analysis"></a>Анализ переносимости рамочной платформы .NET

Как только вы поймете состояние зависимостей NuGet вашего проекта, следующее, что следует учитывать, это зависимости API-приложения для рамочного анима .NET. Инструмент [анализа переносимости .NET](../../standard/analyzers/portability-analyzer.md) полезен для понимания того, какие из APIs .NET, которые используется вашим проектом, доступны на других платформах .NET.

Инструмент поставляется как [визуальный плагин Studio](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), [командный инструмент,](https://github.com/Microsoft/dotnet-apiport/releases)или завернутый в [простой графический интерфейс,](https://github.com/Microsoft/dotnet-apiport-ui)который упрощает его варианты. Вы можете прочитать больше об использовании анализа переносимости .NET (API Port) с помощью графического интерфейса в [настольных приложениях Porting для](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) записи в блоге .NET Core. Если вы предпочитаете использовать командную строку, необходимые шаги:

1. Загрузите [анализируемость портативности .NET,](https://github.com/Microsoft/dotnet-apiport/releases) если у вас его еще нет.
1. Убедитесь, что приложение .NET Framework, чтобы быть портировано, успешно портируетсборки (это хорошая идея до миграции независимо от того).
1. Выполнить API Port с командной строкой, как это.

    ```console
    ApiPort.exe analyze -f <PathToBeanTraderBinaries> -r html -r excel -t ".NET Core"
    ```

    Аргумент `-f` определяет путь, содержащий файлы для анализа. Аргумент `-r` определяет, какой формат вывода файла выхотитесь. Аргумент `-t` определяет, какая платформа .NET для анализа использования API против. В этом случае требуется ядро .NET.

При открытии отчета HTML в первом разделе будут указаны все проанализированные файлы и какой процент APIs .NET они доступны на целевой платформе. Процент сам по себе не имеет смысла. Что более полезно, так это увидеть конкретные AIS, которые отсутствуют. Для этого выберите имя сборки или прокрутите вниз к отчетам для отдельных сборок.

Сосредоточьтесь на сборках, для получения исходного кода. Например, в отчете Bean Trader ApiPort есть много бинарных файлов, но большинство из них принадлежат пакетам NuGet. `Castle.Windsor`показывает, что это зависит от некоторых AБИИ System.Web, которые отсутствуют в .NET Core. Это не вызывает беспокойства, потому что вы ранее проверили, что `Castle.Windsor` поддерживает .NET Core. Часто пакеты NuGet имеют различные файлы для использования с различными платформами .NET, так что ли версия .NET Framework `Castle.Windsor` использует AAP System.Web или нет, не имеет значения до тех пор, пока пакет также нацелен на .NET Standard или .NET Core (что он и делает).

С образцом Bean Trader, только двоичный, что вам нужно рассмотреть это **BeanTraderClient** `System.ServiceModel.ClientBase<T>.Close` и `System.ServiceModel.ClientBase<T>.Open`доклад показывает, что только два .NET AIS отсутствуют: и .

![Отчет о переносимости BeanTraderClient](./media/convert-project-from-net-framework/portability-report.png)

Они вряд ли будут блокированием вопросов, потому что AIS клиента WCF (в основном) поддерживаются на .NET Core, поэтому должны быть альтернативы, доступные для этих центральных AI. В самом деле, глядя на `System.ServiceModel`'s <https://apisof.net>.NET Core поверхности (с помощью), вы видите, что Есть async альтернативы в .NET Core вместо.

Основываясь на этом отчете и предыдущем анализе зависимости NuGet, похоже, что не должно быть никаких серьезных проблем, перенося образец Bean Trader в ядро .NET. Вы готовы к следующему шагу, в котором вы фактически начнете миграцию.

## <a name="migrating-the-project-file"></a>Перенос файл проекта

Если приложение не использует новый [формат файла проекта в стиле SDK,](../../core/tools/csproj.md)вам понадобится новый файл проекта для целевой цели .NET Core. Можно заменить существующий файл csproj или, если вы предпочитаете сохранить существующий проект нетронутым в текущем состоянии, можно добавить новый файл csproj, ориентированный на .NET Core. Версии приложения для .NET Framework и .NET Core можно с помощью одного файла проекта `<TargetFrameworks>` в стиле SDK с [несколькими таргетингами](../../standard/library-guidance/cross-platform-targeting.md) (с указанием нескольких целей).

Для создания нового файла проекта можно создать новый проект WPF в Visual Studio или использовать `dotnet new wpf` команду во временном каталоге для создания файла проекта, а затем скопировать/переименовать его в нужное место. Существует также созданный сообществом [инструмент, CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), который может автоматизировать некоторые из миграции файла проекта. Инструмент полезен, но все еще нуждается в человеке, чтобы просмотреть результаты, чтобы убедиться, что все детали миграции верны. Одной из конкретных областей, с которыми инструмент не обрабатывает оптимально, является миграция пакетов NuGet из файлов *packages.config.* Если инструмент работает на файле проекта, который по-прежнему использует файл *packages.config* для ссылки на пакеты NuGet, он автоматически перекочегнет в `<PackageReference>` элементы, но добавит `<PackageReference>` элементы для *всех* пакетов, а не только для пакетов верхнего уровня. Если вы уже перешли`<PackageReference>` на элементы Visual Studio (как вы сделали в этом примере), то инструмент может помочь с остальной частью преобразования. Как Скотт Hanselman рекомендует в [своем блоге на мигрирующих файлов csproj](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), перенос вручную является образовательным и даст лучшие результаты, если у вас есть только несколько проектов в порт. Но если вы портируете десятки или сотни файлов проектов, то инструмент, как «CsprojToVs2017» может быть помощью.

Чтобы `dotnet new wpf` создать новый файл проекта для образца Bean Trader, запустите во временном каталоге и переместите генерируемый файл *.csproj* в папку *BeanTraderClient* и переименуйте его **BeanTraderClient.Core.csproj**.

Поскольку новый формат файла проекта автоматически включает файлы C', *файлы resx* и файлы XAML, которые он находит в каталоге или под его каталогом, файл проекта уже почти завершен! Чтобы завершить миграцию, откройте старые и новые файлы проекта бок о бок и просмотрите старый, чтобы увидеть, нужно ли мигрировать какую-либо содержащуюся в нем информацию. В примере Bean Trader следует скопировать в новый проект следующие элементы:

- Все `<RootNamespace>` `<AssemblyName>`свойства `<ApplicationIcon>` и свойства должны быть скопированы.

- Также необходимо добавить `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` свойство в новый файл проекта, так как образец `[AssemblyTitle]`Bean Trader включает атрибуты уровня сборки (например) в AssemblyInfo.cs файле. По умолчанию новые проекты в стиле SDK будут автоматически генерировать эти атрибуты на основе свойств в файле csproj. Поскольку вы не хотите, чтобы это произошло в этом случае (автогенерируемые атрибуты будут конфликтовать с атрибутами из AssemblyInfo.cs), вы отрабатываете аутогенерируемые атрибуты с `<GenerateAssemblyInfo>`помощью .

- Хотя *файлы resx* автоматически включаются `<Resource>` в качестве встроенных ресурсов, другие элементы, такие как изображения, не являются. Таким образом, `<Resource>` скопируйте элементы для встраивания файлов изображений и значков. Вы можете упростить ссылки png на одну строку, используя поддержку нового формата файла проекта для шаблонов globbing: `<Resource Include="**\*.png" />`.

- Аналогичным `<None>` образом элементы включаются автоматически, но по умолчанию они не скопированы в каталог вывода. Поскольку проект Bean `<None>` Trader включает элемент, *который* скопирован `PreserveNewest` в каталог вывода (с использованием поведения), необходимо обновить автоматически населенный `<None>` элемент для этого файла, как это.

  ```xml
  <None Update="BeanTrader.pfx">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
  ```

- Образец Bean Trader включает файл XAML (Default.Accent.xaml) `Content` `Page`как (а не как), потому что темы и акценты, определенные в этом файле, загружаются из XAML файла во время выполнения, а не встраиваются в само приложение. Новая система проекта автоматически включает `<Page>`этот файл как, однако, так как это файл XAML. Таким образом, вам нужно как удалить файл XAML в качестве страницы ()`<Page Remove="**\Default.Accent.xaml" />`и добавить его в качестве содержания.

  ```xml
  <Content Include="Resources\Themes\Default.Accent.xaml">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </Content>
  ```

- Наконец, добавьте ссылки NuGet, скопируя `<ItemGroup>` со всеми элементами. `<PackageReference>` Если ранее вы не обновляли пакеты NuGet до версий, совместимых с ядром .NET, вы можете сделать это сейчас, когда ссылки на пакет находятся в проекте .NET Core.

На этом этапе можно добавить новый проект в решение BeanTrader и открыть его в Visual Studio. Проект должен выглядеть правильно в `dotnet restore BeanTraderClient.Core.csproj` Solution **Explorer**и должен успешно восстановить пакеты (с двумя ожидаемыми предупреждениями, связанными с версией MahApps.Metro, которая используется для таргетинга .NET Framework).

Хотя оба файла проекта можно сохранить бок о бок (и даже может быть желательно, если вы хотите продолжать строить старый проект точно так же, как это было), это усложняет процесс миграции (два проекта будут пытаться использовать те же папки ядра и объята) и, как правило, не является необходимым. Если вы хотите построить для целей .NET Core и `<TargetFramework>netcoreapp3.0</TargetFramework>` .NET Framework, `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` вы можете заменить свойство в новом файле проекта вместо этого. Для примера Bean Trader удалите старый файл проекта (BeanTraderClient.csproj), так как он больше не нужен. Если вы предпочитаете хранить оба файла проекта, не забудьте построить их на различные выходные и промежуточные пути вывода.

## <a name="fix-build-issues"></a>Исправление проблем со сборкой

Третьим этапом процесса переноса является создание проекта. Некоторые приложения уже успешно строятся после того, как файл проекта будет преобразован в проект в стиле SDK. Если это так для вашего приложения, поздравления! Вы можете перейти к шагу 4. Другим приложениям потребуются некоторые обновления, чтобы получить их здание для .NET Core. Если вы попытаетесь запустить `dotnet build` на bean Trader образец проекта сейчас, например, (или построить его в Visual Studio), там будет много ошибок, но вы получите их быстро.

### <a name="systemservicemodel-references-and-microsoftwindowscompatibility"></a>Ссылки На System.ServiceModel и Microsoft.Windows.Совместимость

Распространенным источником ошибок являются ссылки на AA, которые доступны для .NET Core, но не автоматически включены в метапакет приложения .NET Core. Чтобы решить эту проблему, `Microsoft.Windows.Compatibility` следует ссылку на пакет. Пакет совместимости включает в себя широкий набор AI, которые распространены в настольных приложениях Windows, таких как клиент WCF, службы каталога, реестр, конфигурация, AI ACLs и многое другое.

С образцом Bean Trader большинство ошибок сборки <xref:System.ServiceModel> связано с отсутствующими типами. Эти проблемы могут быть решены путем ссылки на необходимые пакеты WCF NuGet. WCF клиент AIS являются одними из тех, кто присутствует в `Microsoft.Windows.Compatibility` пакете, хотя, так ссылаясь на пакет совместимости является еще лучшим решением (поскольку он также решает любые вопросы, связанные с AI, а также решения wCF вопросов, что пакет совместимости делает доступными). Пакет `Microsoft.Windows.Compatibility` помогает в большинстве сценариев переноса портаации .NET Core 3.0 WPF и WinForms. После добавления ссылки NuGet на `Microsoft.Windows.Compatibility`, только одна ошибка сборки остается!

### <a name="cleaning-up-unused-files"></a>Очистка неиспользованных файлов

Один из всплывает тип проблемы миграции, который возникает, часто относится к файлам C и XAML, которые ранее не были включены в сборку, подхватив новые проекты в стиле SDK, которые включают в себя *весь* исходный исход автоматически.

Следующая ошибка сборки, которую вы видите в примере Bean Trader, относится к плохой реализации интерфейса в *OldUnusedViewModel.cs.* Имя файла является подсказкой, но при проверке вы обнаружите, что этот исходный файл неверен. Ранее проблемы не возникали, так как не были включены в первоначальный проект .NET Framework. Исходные файлы, которые присутствовали на диске, но не включены в старый *csproj,* теперь автоматически включаются.

Для одноразовых проблем, как это, это легко сравнить с предыдущим *csproj,* чтобы подтвердить, `<Compile Remove="" />` что файл не нужен, а затем либо его или, если исходный файл не нужен в любом месте больше, удалить его. В этом случае можно просто удалить *OldUnusedViewModel.cs.*

Если у вас есть много исходных файлов, которые должны быть исключены таким образом, `<EnableDefaultCompileItems>` вы можете отключить автоматическое включение файлов C, установив свойство на ложное в файле проекта. Затем можно скопировать `<Compile Include>` элементы из старого файла проекта в новый, чтобы построить только источники, которые вы намеревались включить. Аналогичным `<EnableDefaultPageItems>` образом, может быть использован для выключения `<EnableDefaultItems>` автоматического включения страниц XAML и может управлять как с одним свойством.

### <a name="a-brief-aside-on-multi-pass-compilers"></a>Краткое в сторону на многопроходных компиляторов

После удаления файла-нарушителя из образца Bean Trader, вы можете перестроить и получите четыре ошибки. Разве у тебя его раньше не было? Почему выросло количество ошибок? Компилятор C' является [многопроходным компилятором.](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes) Это означает, что он проходит через каждый исходный файл дважды. Во-первых, компилятор просто просматривает метаданные и декларации в каждом исходном файле и определяет любые проблемы уровня декларации. Таковы ошибки, которые вы исправили. Затем он снова проходит через код, чтобы построить источник C-кода в IL; это второй набор ошибок, которые вы видите сейчас.

> [!NOTE]
> Компилятор СИ делает [больше, чем просто два прохода,](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes)но конечный результат заключается в том, что ошибки компилятора для больших изменений кода, как это, как правило, приходят в две волны.

### <a name="third-party-dependency-fixes-castlewindsor"></a>Исправления зависимости сторонних сторон (Castle.Windsor)

Другой класс проблем, который возникает в некоторых сценариях миграции, — это различия API между версиями зависимостей .NET и .NET Core. Даже если пакет NuGet нацелен как на .NET Framework, так и на стандарт .NET или .NET Core, могут быть разные библиотеки для использования с различными целями .NET. Это позволяет пакетам поддерживать множество различных платформ .NET, что может потребовать различных реализаций. Это также означает, что при таргетинге на различные платформы .NET могут быть небольшие различия в API в библиотеках.

Следующий набор ошибок, которые вы увидите в `Castle.Windsor` примере Bean Trader, связан с AIS. Проект .NET Core Bean Trader использует `Castle.Windsor` ту же версию, что и проект.NET Framework (4.1.1), но реализация для этих двух платформ несколько отличается.

В этом случае вы видите следующие проблемы, которые необходимо устранить:

1. `Castle.MicroKernel.Registration.Classes.FromThisAssembly`недоступен на основе .NET Core. Существует, однако, аналогичный `Classes.FromAssemblyContaining` API доступны, так `Classes.FromThisAssembly()` что мы `Classes.FromAssemblyContaining(t)`можем `t` заменить оба использования с вызовами, где тип делает вызов.
1. Аналогичным образом, `Castle.Windsor.Installer.FromAssembly`в *Bootstrapper.cs*, . Это недоступно на ядро .NET. Вместо этого этот вызов `FromAssembly.Containing(typeof(Bootstrapper))`может быть заменен .

### <a name="updating-wcf-client-usage"></a>Обновление использования клиентов WCF

`Castle.Windsor` Зафиксировав различия, последняя оставшаяся ошибка сборки в `BeanTraderServiceClient` проекте .NET `DuplexClientBase`Core Bean `Open` Trader заключается в том, что (который вытекает из) не имеет метода. Это неудивительно, так как это API, который был выделен анализатором переносимости .NET в начале этого процесса миграции. Глядя `BeanTraderServiceClient` на обращает наше внимание на более широкую проблему, однако. Этот клиент WCF был аутогенерирован инструментом [Svcutil.exe.](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)

**Клиенты WCF, генерируемые Svcutil, предназначены для использования на .NET Framework.**

Решения, которые используют svcutil генерируемых wCF клиентов необходимо будет регенерировать .NET стандартных совместимых клиентов для использования с .NET Core. Одна из основных причин, по которой старые клиенты не будут работать, заключается в том, что они зависят от конфигурации приложения для определения привязок и конечных точек WCF. Поскольку AI.net Standard WCF могут работать кросс-платформенными (где AIS System.Configuration недоступны), клиенты WCF для сценариев .NET Core и .NET Standard должны определять привязки и конечные точки за программно, а не в конфигурации.

В самом деле, любое использование `<system.serviceModel>` клиента WCF, который зависит от раздела app.config (будь то созданный с Svcutil или вручную) должны быть изменены для работы на .NET Core.

Существует два способа автоматического генерации клиентов WCF со стандартной со вместимостью .NET:

- Инструмент `dotnet-svcutil` является инструментом .NET, который генерирует клиентов WCF таким образом, что похож на то, как Svcutil работал ранее.
- Visual Studio может генерировать клиентов WCF, используя опцию [ссылки на веб-службы WCF](../../core/additional-tools/wcf-web-service-reference-guide.md) из своей функции Connected Services.

Любой подход работает хорошо. Кроме того, конечно, вы можете написать код клиента WCF самостоятельно. Для этого примера я решил использовать функцию службы Visual Studio Connected Service. Для этого нажмите правой кнопкой мыши на *проекте BeanTraderClient.Core* в explorer решения Visual Studio и выберите **Добавить** > **подключенную службу.** Затем выберите поставщика справочных услуг Web-сервиса WCF. Это позволит привести к диалогу, где вы можете указать адрес`localhost:8080` бэкэнда Bean Trader веб-службы (если вы работаете на сервере локально) и пространство имен, которые генерируются типы должны использовать (**BeanTrader.Service**, например).

![WCF Веб-служба Справочная Служба Диалог](./media/convert-project-from-net-framework/connected-service-dialog.png)

После выбора кнопки **«Завершение»** в проект добавляется новый узла Connected Services и под этим узла Reference.csм, содержащим новый клиент .NET Standard WCF для доступа к службе Bean Trader. Если вы `GetEndpointAddress` посмотрите `GetBindingForEndpoint` на или методы в этом файле, вы увидите, что привязки и конечные точки теперь генерируются программно (вместо того, чтобы с помощью конфигурации приложения). Функция «Добавить подключенные службы» может также добавить ссылки на некоторые пакеты System.ServiceModel в файле проекта, которые не нужны, так как все необходимые пакеты WCF включены через Microsoft.Windows.Compatibility. Проверьте csproj, чтобы увидеть, если `<PackageReference>` какие-либо дополнительные элементы System.ServiceModel были добавлены, и если да, удалить их.

Наш проект имеет новые классы клиентов WCF в настоящее время (в *Reference.cs),* но он также по-прежнему имеет старые (в BeanTrader.cs). На данный момент существует два варианта:

- Если вы хотите иметь возможность построить исходный проект .NET Framework (наряду с новым `<Compile Remove="BeanTrader.cs" />` целевым проектом .NET Core), вы можете использовать элемент в csproj-файле проекта .NET Core, чтобы в версиях приложения .NET Framework и .NET Core использовались различные клиенты WCF. Преимущество этого заключается в том, что существующий проект .NET Framework останется неизменным, но имеет недостаток, что код с использованием генерируемых клиентов WCF `#if` может быть немного иным в случае .NET Core, чем в проекте .NET Framework, так что вам, вероятно, придется использовать директивы для условного компиляции некоторых пользователей WCF (создание клиентов, например), чтобы работать в одну сторону при построении для .NET Core и другим способом, когда построен для .NET Core.

- Если, с другой стороны, неприемлемы некоторые оттоки кода в существующем проекте .NET Framework, можно удалить *BeanTrader.cs* все вместе. Поскольку новый клиент WCF построен для .NET Standard, он будет работать как в сценариях .NET Core, так и в рамочных .NET. Если вы строите для .NET Framework в дополнение к .NET Core (либо с помощью мультитаргетинга или с двумя файлами csproj), вы можете использовать этот новый *файл Reference.cs* для обеих целей. Этот подход имеет то преимущество, что код не нужно будет раздвоить для поддержки двух различных клиентов WCF; один и тот же код будет использоваться везде. Недостатком является то, что он включает в себя изменение (предположительно стабильный) рамочный проект .NET.

В случае с образцом Bean Trader можно внести небольшие изменения в исходный проект, если он упрощает миграцию, поэтому выполните следующие действия, чтобы согласовать использование клиентов WCF:

01. Добавьте новый Reference.cs файл в проект .NET *Framework BeanTraderClient.csproj,* используя контекстное меню «Добавить существующий элемент» от исследователя решения. Не забудьте добавить "как ссылка", так что тот же файл используется в обоих проектах (в отличие от копирования файла C'). Если вы строите как для .NET Core, так и для .NET Framework с одним csproj (с использованием мультитаргетинга), то этот шаг не требуется.

01. Удалить *BeanTrader.cs*.

01. Новый клиент WCF похож на старый, но ряд именных пространств в генерируемом коде различны. Из-за этого необходимо обновить проект так, чтобы типы клиентов WCF использовались с BeanTrader.Service (или любого имени, которое вы выбрали) вместо BeanTrader.Model или без пространства имен. Строительство *BeanTraderClient.Core.csproj* поможет определить, где эти изменения должны быть сделаны. Исправления будут необходимы как в C,, так и в исходных файлах XAML.

01. Наконец, вы обнаружите, что есть ошибка в *BeanTraderServiceClientFactory.cs,* `BeanTraderServiceClient` потому что доступные конструкторы для типа изменились. Раньше можно было поставить `InstanceContext` аргумент (который `CallbackHandler` был `Castle.Windsor` создан с помощью контейнера IoC). Новые конструкторы создают `CallbackHandler`новые s. Есть, однако, конструкторы `BeanTraderServiceClient`в 's базовый тип, которые соответствуют тому, что вы хотите. Поскольку автоматически генерируемый код клиента WCF существует в частичных классах, его можно легко расширить. Для этого создайте новый файл под названием *BeanTraderServiceClient.cs* а затем создайте частичный класс с тем же именем (с помощью пространства имен BeanTrader.Service). Затем добавьте один конструктор к частичному типу, как показано здесь.

    ```csharp
    public BeanTraderServiceClient(System.ServiceModel.InstanceContext callbackInstance) :
        base(callbackInstance, EndpointConfiguration.NetTcpBinding_BeanTraderService)
            { }
    ```

С этими изменениями, образец Bean Trader теперь будет использовать новый клиент WCF, совместимый `Open` со стандартом `await OpenAsync` .NET, и вы можете сделать окончательное решение об изменении вызова в *TradingService.cs* использовать вместо этого.

С WCF вопросы рассматриваются, .NET Основная версия образца Bean Trader теперь строит чисто!

## <a name="runtime-testing"></a>Тестирование времени выполнения

Легко забыть, что миграционная работа не выполняется, как только проект строится чисто против .NET Core. Важно также оставить время для тестирования портативного приложения. Как только вещи успешно строятся, убедитесь, что приложение работает и работает как ожидалось, особенно если вы используете какие-либо пакеты, ориентированные на .NET Framework.

Давайте попробуем запустить портированное приложение Bean Trader и посмотрим, что произойдет. Приложение не получает далеко, прежде чем сбой со следующим исключением.

```output
System.Configuration.ConfigurationErrorsException: 'Configuration system failed to initialize'

Inner Exception
ConfigurationErrorsException: Unrecognized configuration section system.serviceModel.
```

Это имеет смысл, конечно. Помните, что WCF больше не использует конфигурацию приложения, поэтому старый раздел system.serviceModel файла app.config должен быть удален. Обновленный клиент WCF содержит всю ту же информацию в своем коде, поэтому раздел конфигурации больше не нужен. Если вы хотите, чтобы конечная точка WCF была настраиваемой в app.config, вы можете добавить ее в качестве настройки приложения и обновить клиентский код WCF для извлечения конечную точку службы WCF из конфигурации.

После удаления раздела system.serviceModel *app.config,* приложение запускает, но не с другим исключением, когда пользователь вписывается.

```output
System.PlatformNotSupportedException: 'Operation is not supported on this platform.'
```

Неподдерживаемый API `Func<T>.BeginInvoke`. Как поясняется в [dotnet/corefx-5940](https://github.com/dotnet/corefx/issues/5940), .NET `BeginInvoke` `EndInvoke` Core не поддерживает и методы по типам делегатов из-за базовых зависимостей ремотирования. Эта проблема и ее исправление объясняются более подробно в [Migrating Delegate.BeginInvoke призывает к .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) блоге, но суть в том, что `BeginInvoke` и `EndInvoke` звонки должны быть заменены `Task.Run` (или async альтернативы, если это возможно). Применяя общее решение `BeginInvoke` здесь, вызов может `Invoke` быть `Task.Run`заменен вызовом, запущенным .

```csharp
Task.Run(() =>
{
    return userInfoRetriever.Invoke();
}).ContinueWith(result =>
{
    // BeginInvoke's callback is replaced with ContinueWith
    var task = result.ConfigureAwait(false);
    CurrentTrader = task.GetAwaiter().GetResult();
}, TaskScheduler.Default);
```

После удаления `BeginInvoke` использования приложение Bean Trader успешно работает на .NET Core!

![Трейдер по бемболу работает на ядро .NET](./media/convert-project-from-net-framework/running-on-core.png)

Все приложения отличаются друг от друга, поэтому конкретные шаги, необходимые для переноса собственных приложений в .NET Core, будут варьироваться. Но, надеюсь, образец Bean Trader демонстрирует общий рабочий процесс и типы проблем, которые можно ожидать. И, несмотря на длину этой статьи, фактические изменения, необходимые в образце Bean Trader, чтобы заставить его работать на .NET Core были довольно ограничены. Многие приложения мигрируют в ядро .NET таким же образом; с ограниченнымили или даже не требуется изменений кода.
