---
title: Общие сведения о привязке данных
description: Узнайте о различных источниках данных, которые вы можете добавить в свой проект Windows Presentation Foundation (WPF) для .NET Core. Источники данных можно привязать к XAML-элементам для создания динамических приложений.
author: adegeo
ms.date: 09/19/2019
ms.author: adegeo
dev_langs:
- csharp
- vb
ms.openlocfilehash: 3c9615d7d79b5da1c180bb505f5f37b99aeae775
ms.sourcegitcommit: e0803b8975d3eb12e735a5d07637020dd6dac5ef
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/01/2020
ms.locfileid: "89272001"
---
# <a name="data-binding-overview-in-wpf"></a>Общие сведения о привязке данных в WPF

Привязка данных в Windows Presentation Foundation (WPF) — это простой и последовательный способ представления данных и взаимодействия с ними для приложений. Элементы можно связывать с данными из различных источников данных в виде объектов .NET и XML. Любые <xref:System.Windows.Controls.ContentControl>, такие как <xref:System.Windows.Controls.Button>, и любые <xref:System.Windows.Controls.ItemsControl>, такие как <xref:System.Windows.Controls.ListBox> и <xref:System.Windows.Controls.ListView>, имеют встроенную функциональность, позволяющую гибко стилизовать отдельные элементы данных или коллекции элементов данных. Представления сортировки, фильтрации и группировки могут быть организованы поверх данных.

Функции привязки данных в WPF имеют несколько преимуществ перед традиционными моделями, включая внутреннюю поддержку привязки данных, гибкое представление данных пользовательского интерфейса и четкое разделение бизнес-логики и пользовательского интерфейса.

В этой статье сначала будут рассматриваться основные понятия привязки данных в WPF, а затем — использование класса <xref:System.Windows.Data.Binding> и других возможностей привязки данных.

[!INCLUDE [desktop guide under construction](../../../includes/desktop-guide-preview-note.md)]

## <a name="what-is-data-binding"></a>Понятие привязки данных

Привязка данных — это процесс установки соединения между пользовательским интерфейсом и отображаемыми данными. Если для привязки заданы правильные настройки, а изменения значений данных сопровождаются правильными уведомлениями, привязанные к данным элементы автоматически отражают изменения. Привязка данных может также означать, что, если внешнее представление данных в элементе изменяется, то базовые данные могут автоматически обновляться для отражения изменений. Например, если пользователь изменяет значение в элементе `TextBox`, базовое значение данных автоматически обновляется, чтобы отразить это изменение.

Привязка к данным обычно используется для того, чтобы поместить серверные или локальные данные конфигурации в формы или другие элементы управления пользовательского интерфейса. В WPF эта концепция расширяется, чтобы содержать привязку широкого диапазона свойств к различным источникам данных. В WPF свойства зависимости элементов можно привязать к объектам .NET (включая объекты ADO.NET или объекты, связанные с веб-службами и веб-свойствами) и к данным XML.

Привязку данных можно рассмотреть на примере следующего пользовательского интерфейса приложения со страницы [примера привязки данных][data-binding-demo], в котором отображается список элементов аукциона.

![Снимок экрана примера привязки данных](./media/data-binding-overview/demo.png "DataBinding_DataBindingDemo")

Приложение демонстрирует следующие возможности привязки данных.

- Содержимое ListBox привязано к коллекции объектов *AuctionItem*. Объект *AuctionItem* имеет такие свойства, как *Description*, *StartPrice*, *StartDate*, *Category*, *SpecialFeatures* и т. д.

- Данные (объекты *AuctionItem*), отображаемые в `ListBox`, шаблонизированы таким образом, чтобы описание и текущая цена были показаны для каждого элемента. Шаблон создается с помощью <xref:System.Windows.DataTemplate>. Кроме того, внешний вид каждого элемента зависит от значения *SpecialFeatures* отображаемого объекта *AuctionItem*. Если значением *SpecialFeatures* объекта *AuctionItem* является *Color*, элемент имеет синюю границу. Если значением является *Highlight*, элемент имеет оранжевые границы и помечается звездочкой. Раздел [Создание шаблонов данных](#data-templating) содержит сведения о создании шаблонов данных.

- Пользователь может группировать, фильтровать или сортировать данные с помощью предоставленного `CheckBoxes`. На рисунке, приведенном выше, выбраны элементы `CheckBoxes` **Группировать по категориям** и **Sort by category and date** (Сортировать по категориям и дате). Можно увидеть, что данные группируются по категориям продуктов, а имена категорий приводятся в алфавитном порядке. Из рисунка трудно заметить, что элементы в каждой категории также сортируются по начальной дате. Сортировка выполняется с помощью *представления коллекции*. Представления коллекций рассматриваются в разделе [Привязка к коллекциям](#binding-to-collections).

- Когда пользователь выбирает элемент, <xref:System.Windows.Controls.ContentControl> отображает сведения о выбранном элементе. Этот процесс называется *Сценарий отношения "основной — подробности"* . Сведения об этом типе привязки см. в разделе [Сценарий "основной — подробности"](#master-detail-binding-scenario).

- Типом свойства *StartDate* является <xref:System.DateTime>, который возвращает дату, включая время с точностью до миллисекунды. В этом приложении пользовательский преобразователь использовался для отображения даты в укороченном формате. Сведения о преобразователях см. в разделе [Преобразование данных](#data-conversion).

При нажатии кнопки *Добавить продукт* появляется следующая форма.

![Добавить страницу списка продуктов](./media/data-binding-overview/demo-addproductlisting.png "DataBinding_Demo_AddProductListing")

Пользователь может изменить поля формы, просмотреть список продуктов с помощью панелей краткого и подробного предварительного просмотра и выбрать `Submit` для добавления данных нового продукта. К новой записи будут применимы все существующие настройки группировки, фильтрации и сортировки. В этом конкретном случае элемент, введенный на приведенном выше рисунке, будет отображаться как второй элемент в категории *Компьютер*.

На этом рисунке не показана логика проверки, предоставленная в элементе управления *Start Date* <xref:System.Windows.Controls.TextBox>. Если пользователь вводит недопустимую дату (недопустимый формат или прошедшую дату), он будет уведомлен с помощью <xref:System.Windows.Controls.ToolTip> и красного восклицательного знака рядом с <xref:System.Windows.Controls.TextBox>. Сведения о создании логики проверки см. в разделе [Проверка данных](#data-validation).

Прежде чем перейти к другим описанным выше возможностям связывания данных, обсудим основные понятия, важные для понимания привязки данных WPF.

## <a name="basic-data-binding-concepts"></a>Основные понятия привязки данных

Независимо от того, какой элемент привязывается и какой источник данных используется, каждая привязка всегда соответствует модели, показанной на следующем рисунке.

![Схема, на которой показана базовая модель привязки данных.](./media/data-binding-overview/basic-data-binding-diagram.png)

Как показано на рисунке, привязка данных является, по существу, мостом между целью привязки и источником привязки. На рисунке представлены следующие основные концепции привязки данных WPF.

- Как правило, каждая привязка состоит из четырех компонентов:

  - целевой объект привязки;
  - целевое свойство;
  - источник привязки;
  - путь к значению в источнике привязки для использования.
  
  > Например, если необходимо привязать содержимое `TextBox` к свойству `Employee.Name`, целевой объект — это `TextBox`, целевое свойство — это свойство <xref:System.Windows.Controls.TextBox.Text%2A>, используемое значение — *Name*, а исходный объект — это объект *Employee*.

- Целевое свойство должно быть свойством зависимостей. Большинство свойств <xref:System.Windows.UIElement> являются свойствами зависимостей, а большинство свойств зависимостей, за исключением доступных только для чтения, по умолчанию поддерживают привязку данных. (Определять свойства зависимостей могут только типы, производные от <xref:System.Windows.DependencyObject>, а все типы <xref:System.Windows.UIElement> являются производными от `DependencyObject`.)

- Несмотря на то что это не указано на рисунке, следует отметить, что объект источника привязки не обязан быть пользовательским объектом .NET. Привязка данных WPF поддерживает данные в виде объектов .NET и XML. Чтобы предоставить несколько примеров, источником привязки может быть <xref:System.Windows.UIElement>, любой объект списка, объект ADO.NET или веб-служб или XmlNode, содержащий XML-данные. Дополнительные сведения см. в разделе [Общие сведения об источниках привязки](../../framework/wpf/data/binding-sources-overview.md).

Важно помнить, что при связывании цель привязки *привязывается к* источнику привязки. Например, при отображении некоторых базовых данных XML в <xref:System.Windows.Controls.ListBox> с помощью привязки данных вы привязываете `ListBox` к XML-данным.

Чтобы установить привязку, используйте объект <xref:System.Windows.Data.Binding>. В остальной части этой статьи обсуждаются многие понятия, связанные с некоторыми свойствами и использованием объекта `Binding`.

### <a name="direction-of-the-data-flow"></a>Направление потока данных

Как показывает стрелка на приведенном выше рисунке, поток данных связывания может идти от цели привязки к источнику привязки (например, исходное значение изменяется, когда пользователь изменяет значение `TextBox`) или от источника привязки к цели привязки (например, содержимое `TextBox` обновляется при изменениях в источнике привязки), если источник привязки предоставляет соответствующие уведомления.

Возможно, требуется, чтобы в приложении пользователи могли изменить данные и передать их обратно объекту источника. Или может потребоваться не предоставлять пользователям возможности обновления источника данных. Для управления потоком данных можно задать <xref:System.Windows.Data.Binding.Mode?displayProperty=nameWithType>.

На следующем рисунке показаны различные типы потоков данных.

![Поток данных привязки данных](./media/data-binding-overview/databinding-dataflow.png "DataBinding_DataFlow")

- Привязка<xref:System.Windows.Data.BindingMode.OneWay> приводит к автоматическому изменению свойства цели при изменении свойства источника, но изменения свойства цели не передаются обратно к свойству источника. Этот тип привязки подходит, если привязываемый элемент управления неявно доступен только для чтения. Например, можно привязаться к источнику, такому как биржевые сводки, или, возможно, свойство цели не имеет интерфейса для внесения изменений, например, цвета фона привязанной к данным таблицы. Если нет необходимости отслеживать изменения целевого свойства, можно работать в режиме привязки <xref:System.Windows.Data.BindingMode.OneWay> — в этом случае удастся избежать издержек режима привязки <xref:System.Windows.Data.BindingMode.TwoWay>.

- Привязка<xref:System.Windows.Data.BindingMode.TwoWay> приводит к изменению либо исходного свойства, либо целевого свойства для автоматического обновления другого свойства. Этот тип привязки подходит для изменяемых форм или других полностью интерактивных сценариев пользовательского интерфейса. Большинство свойств по умолчанию применяют привязку <xref:System.Windows.Data.BindingMode.OneWay>, но некоторые свойства зависимости (обычно это свойства пользовательских элементов управления, таких как <xref:System.Windows.Controls.TextBox.Text?displayProperty=nameWithType> и [CheckBox.IsChecked](xref:System.Windows.Controls.Primitives.ToggleButton.IsChecked)) по умолчанию имеют значение привязки <xref:System.Windows.Data.BindingMode.TwoWay>. Существует способ определить программно, использует ли свойство зависимостей односторонние или двухсторонние привязки по умолчанию: для этого нужно получить метаданные свойства, воспользовавшись методом <xref:System.Windows.DependencyProperty.GetMetadata%2A?displayProperty=nameWithType>, а затем проверить логическое значение свойства <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A?displayProperty=nameWithType>.

- <xref:System.Windows.Data.BindingMode.OneWayToSource> — это обратная привязка <xref:System.Windows.Data.BindingMode.OneWay>; она обновляет свойство источника при изменении свойства цели. Одним из примеров является пересчет исходного значения из пользовательского интерфейса.

- На рисунке не показана привязка <xref:System.Windows.Data.BindingMode.OneTime>, которая проводит инициализацию свойства цели свойством источника, но последующие изменения при этом не распространяются. Если в контексте данных производятся изменения или меняется объект, это изменение *не* отражается в свойстве цели. Этот тип привязки подходит, если приемлемо использовать снимок текущего состояния или данные действительно являются статичными. Этот тип привязки также является полезным, если нужно инициализировать целевое свойство с использованием какого-либо значения из исходного свойства, а контекст данных заранее неизвестен. Этот режим, по сути, — упрощенная форма привязки <xref:System.Windows.Data.BindingMode.OneWay>, которая обеспечивает более высокую производительность в случаях, когда значение источника не меняется.

Чтобы обнаружить изменения источника (применимые к привязкам <xref:System.Windows.Data.BindingMode.OneWay> и <xref:System.Windows.Data.BindingMode.TwoWay>), источник должен реализовать подходящий механизм уведомления об изменении свойств, например <xref:System.ComponentModel.INotifyPropertyChanged>. См. практическое руководство по [ реализации уведомления об изменении свойства](../../framework/wpf/data/how-to-implement-property-change-notification.md) в качестве примера реализации <xref:System.ComponentModel.INotifyPropertyChanged>.

Свойство <xref:System.Windows.Data.Binding.Mode?displayProperty=nameWithType> содержит дополнительные сведения о режимах привязки и пример того, как указать направление привязки.

### <a name="what-triggers-source-updates"></a>Что инициирует обновления источника

Привязки, которые являются <xref:System.Windows.Data.BindingMode.TwoWay> или <xref:System.Windows.Data.BindingMode.OneWayToSource>, ожидают изменений в свойстве цели и распространяют их обратно в источник, что называется обновлением источника. Например, можно изменять текст элемента TextBox для изменения базового значение источника.

Однако обновляется ли значение источника во время изменения текста или когда изменения текста завершается, а элемент управления теряет фокус? Свойство <xref:System.Windows.Data.Binding.UpdateSourceTrigger?displayProperty=nameWithType> определяет, что инициирует обновление источника. Точки правой стрелки на следующем рисунке иллюстрируют роль свойства <xref:System.Windows.Data.Binding.UpdateSourceTrigger?displayProperty=nameWithType>.

![Схема, показывающая роль свойства UpdateSourceTrigger.](./media/data-binding-overview/data-binding-updatesource-trigger.png)

Если значение `UpdateSourceTrigger` равно <xref:System.Windows.Data.UpdateSourceTrigger.PropertyChanged?displayProperty=nameWithType>, то значение, на которое указывает стрелка вправо <xref:System.Windows.Data.BindingMode.TwoWay> или привязки <xref:System.Windows.Data.BindingMode.OneWayToSource>, обновляется, как только изменяется свойство цели. Однако если значение `UpdateSourceTrigger` равно <xref:System.Windows.Data.UpdateSourceTrigger.LostFocus>, то это значение обновляется с новым значением, только когда целевое свойство теряет фокус.

Как и в случае со свойством <xref:System.Windows.Data.Binding.Mode%2A>, различные свойства зависимостей имеют разные значения <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A> по умолчанию. Значение по умолчанию для большинства свойств зависимостей — <xref:System.Windows.Data.UpdateSourceTrigger.PropertyChanged>, а свойство `TextBox.Text` имеет значение по умолчанию <xref:System.Windows.Data.UpdateSourceTrigger.LostFocus>. `PropertyChanged` означает, что исходные обновления обычно происходят при изменении целевого свойства. Мгновенное изменение подходит для "CheckBoxes" и других простых элементов управления. Однако для текстовых полей обновления после каждого нажатия клавиши уменьшают производительность и не дают пользователю обычной возможности удаления предыдущего символа и исправления ошибок ввода до того, как новое значение будет зафиксировано.

Сведения о том, как найти значение свойства зависимости по умолчанию, см. на странице свойств <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A>.

В следующей таблице приведен пример сценария для каждого значения <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A> с использованием <xref:System.Windows.Controls.TextBox> в качестве примера.

| Значение UpdateSourceTrigger | Когда обновляется значение источника | Пример сценария для TextBox |
| ------------------------- | ---------------------------------- | ---------------------------- |
| `LostFocus` (по умолчанию для <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=nameWithType>) | Возникает при потере фокуса элементом управления TextBox | TextBox, связанный с логикой проверки (см. раздел ниже [Проверка данных](#data-validation)) |
| `PropertyChanged` | При вводе данных в <xref:System.Windows.Controls.TextBox>. | Элементы управления TextBox в окне комнаты чата. |
| `Explicit` | Когда приложение вызывает <xref:System.Windows.Data.BindingExpression.UpdateSource%2A>. | Элемент управления TextBox в редактируемой форме (обновляет значения источника только при нажатии пользователем кнопки отправки) |

Пример см. в статье [Практическое руководство. Управление обновлением источника из поля TextBox](../../framework/wpf/data/how-to-control-when-the-textbox-text-updates-the-source.md).

## <a name="creating-a-binding"></a>Создание привязки

Подводя итог некоторым основным понятиям, описанным в предыдущих разделах, следует сказать, что привязка устанавливается с помощью объекта <xref:System.Windows.Data.Binding> и каждая привязка обычно состоит из четырех компонентов: цели привязки, свойства цели, источника привязки и пути к используемому значению источника. Этот раздел описывает установку привязки.

Рассмотрим следующий пример, в котором объектом источника привязки является класс с именем *MyData*, определенный в пространстве имен *SDKSample*. В качестве демонстрационного примера *MyData* имеет строковое свойство с именем *ColorName* со значением Red. Таким образом, в этом примере создается кнопка с красным фоном.

[!code-xaml[BindNonTextProperty](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/AutoConvertPropertyToColor.xaml#BindAutoConvertColor)]

Дополнительные сведения о синтаксисе объявления привязки и примеры настройки привязки в коде см. в разделе [Общие сведения об объявлении привязок](../../framework/wpf/data/binding-declarations-overview.md).

Если применить этот пример к основной диаграмме, полученное изображение будет выглядеть следующим образом. На этом рисунке описывается привязка <xref:System.Windows.Data.BindingMode.OneWay>, так как свойство Background поддерживает привязку <xref:System.Windows.Data.BindingMode.OneWay> по умолчанию.

![Схема, показывающая свойство Background привязки данных.](./media/data-binding-overview/data-binding-button-background-example.png)

Может возникнуть вопрос, почему эта привязка работает, даже несмотря на то, что свойство *ColorName* имеет тип "строка", а свойство <xref:System.Windows.Controls.Control.Background%2A> имеет тип <xref:System.Windows.Media.Brush>. Эта привязка происходит в результате преобразования типов по умолчанию, которое обсуждается в разделе [Преобразование данных](#data-conversion).

### <a name="specifying-the-binding-source"></a>Указание источника привязки

Обратите внимание, что в предыдущем примере источник привязки задается путем установки свойства [DockPanel.DataContext](xref:System.Windows.FrameworkElement.DataContext). Затем <xref:System.Windows.Controls.Button> наследует значение <xref:System.Windows.FrameworkElement.DataContext%2A> от <xref:System.Windows.Controls.DockPanel>, которое является его родительским элементом. Повторим, что объект источника привязки является одним из четырех необходимых компонентов привязки. Таким образом, без указания объекта источника привязки эта привязка не имела бы смысла.

Есть несколько способов для указания объекта источника привязки. С помощью свойства <xref:System.Windows.FrameworkElement.DataContext%2A> родительского элемента удобно привязывать несколько свойств к одному источнику. Однако иногда удобнее указывать источник привязки в отдельных объявлениях привязки. В предыдущем примере вместо использования свойства <xref:System.Windows.FrameworkElement.DataContext%2A> можно указать источник привязки, задав свойство <xref:System.Windows.Data.Binding.Source%2A?displayProperty=nameWithType> непосредственно в объявлении привязки кнопки, как показано в следующем примере.

[!code-xaml[BindNonTextPropertyCompactBinding](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/AutoConvertPropertyToColor.xaml#BindAutoConvertColorCompactBinding)]

Кроме установки свойства <xref:System.Windows.FrameworkElement.DataContext%2A> непосредственно на элемент, наследуя значение <xref:System.Windows.FrameworkElement.DataContext%2A> из родительского элемента (например, кнопки в первом примере), и явного указания источника привязки путем установки свойства <xref:System.Windows.Data.Binding.Source%2A?displayProperty=nameWithType> для привязки (например, кнопку в последнем примере), можно также использовать свойство <xref:System.Windows.Data.Binding.ElementName?displayProperty=nameWithType> или свойство <xref:System.Windows.Data.Binding.RelativeSource?displayProperty=nameWithType>, чтобы указать источник привязки. Свойство <xref:System.Windows.Data.Binding.ElementName%2A> полезно при привязке к другим элементам в приложении, например, при использовании ползунка для настройки ширины кнопки. Свойство <xref:System.Windows.Data.Binding.RelativeSource%2A> полезно, когда привязка указана в <xref:System.Windows.Controls.ControlTemplate> или <xref:System.Windows.Style>. Дополнительные сведения см. в разделе [Практическое руководство. Указание источника привязки](../../framework/wpf/data/how-to-specify-the-binding-source.md).

### <a name="specifying-the-path-to-the-value"></a>Указание пути к значению

Если источник привязки является объектом, используйте свойство <xref:System.Windows.Data.Binding.Path?displayProperty=nameWithType> для указания значения, используемого для привязки. Если вы выполняете привязку к данным XML, для указания значения используется свойство <xref:System.Windows.Data.Binding.XPath?displayProperty=nameWithType>. В некоторых случаях удобно применять свойство <xref:System.Windows.Data.Binding.Path%2A>, даже если это данные XML. Например, если требуется получить доступ к свойству Name возвращаемого XmlNode (в результате выполнения запроса XPath), в дополнение к свойству <xref:System.Windows.Data.Binding.XPath%2A> следует использовать свойство <xref:System.Windows.Data.Binding.Path%2A>.

Дополнительные сведения см. в описаниях свойств <xref:System.Windows.Data.Binding.Path%2A> и <xref:System.Windows.Data.Binding.XPath%2A>.

Хотя мы и подчеркнули, что путь <xref:System.Windows.Data.Binding.Path%2A> к используемому значению является одним из четырех необходимых компонентов привязки, в сценариях, когда требуется выполнить привязку ко всему объекту, используемое значение будет таким же, как у объекта источника привязки. В этих случаях можно не указывать <xref:System.Windows.Data.Binding.Path%2A>. Рассмотрим следующий пример.

[!code-xaml[EmptyBinding](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/EmptyBinding.xaml#EmptyBinding)]

В приведенном выше примере используется синтаксис пустой привязки: {Binding}. В этом случае <xref:System.Windows.Controls.ListBox> наследует DataContext от родительского элемента DockPanel (не показан в этом примере). Если путь не указан, по умолчанию производится привязка ко всему объекту. Другими словами, в этом примере путь не был указан, так как мы выполнили привязку свойства <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> ко всему объекту. (Подробное описание см. в разделе [Привязка к коллекциям](#binding-to-collections).)

Кроме привязки к коллекции, этот сценарий полезен также для привязки ко всему объекту, а не только к одному свойству объекта. Например, если объект источника является объектом типа <xref:System.String>, вы можете захотеть выполнить привязку к самой строке. Другим распространенным сценарием является необходимость привязки элемента к объекту с несколькими свойствами.

Может потребоваться применить пользовательскую логику, чтобы данные имели смысл для свойства целевого объекта привязки. Пользовательская логика может иметь вид пользовательского преобразователя, если тип преобразования по умолчанию не существует. Сведения о преобразователях см. в разделе [Преобразование данных](#data-conversion).

### <a name="binding-and-bindingexpression"></a>Привязка и класс BindingExpression

Прежде чем перейти к другим возможностям и использованию привязки данных, полезно познакомиться с классом <xref:System.Windows.Data.BindingExpression>. Как было показано в предыдущих разделах, класс <xref:System.Windows.Data.Binding> является классом высокого уровня для объявления привязки. Он предоставляет множество свойств, которые позволяют указать характеристики привязки. Связанный класс <xref:System.Windows.Data.BindingExpression>является базовым объектом, поддерживающим связь между источником и целью. Привязка содержит всю информацию, которая может использоваться совместно в нескольких выражениях привязки. <xref:System.Windows.Data.BindingExpression> — это выражение экземпляра, которое не может быть общим и содержит все сведения об экземпляре <xref:System.Windows.Data.Binding>.

Рассмотрим следующий пример, где `myDataObject` является экземпляром класса `MyData` , `myBinding` является объектом источника <xref:System.Windows.Data.Binding>, а `MyData` — это определенный класс, содержащий строковое свойство с именем `ColorName`. Этот пример связывает текстовое содержимое `myText`, экземпляр <xref:System.Windows.Controls.TextBlock>, с `ColorName`.

[!code-csharp[CodeOnlyBinding](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/ManualBinding.cs#CodeOnlyBinding)]
[!code-vb[CodeOnlyBinding](~/samples/snippets/desktop-guide/wpf/data-binding-overview/vb/ManualBinding.vb#CodeOnlyBinding)]

Один и тот же объект *myBinding* можно использовать для создания других привязок. Например, объект *myBinding* можно использовать для привязки текстового содержимого флажка к *ColorName*. В этом сценарии будут два экземпляра <xref:System.Windows.Data.BindingExpression>, совместно использующие объект *myBinding*.

Объект <xref:System.Windows.Data.BindingExpression> возвращается путем вызова <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A> для объекта, привязанного к данным. В следующих статьях демонстрируются некоторые случаи использования класса <xref:System.Windows.Data.BindingExpression>.

- [Получение объекта привязки из свойства целевого объекта привязки](../../framework/wpf/data/how-to-get-the-binding-object-from-a-bound-target-property.md)

- [Управление обновлением источника из поля TextBox](../../framework/wpf/data/how-to-control-when-the-textbox-text-updates-the-source.md)

## <a name="data-conversion"></a>Преобразование данных

В разделе [Создание привязки](#creating-a-binding) кнопка имеет красный цвет, так как ее свойство <xref:System.Windows.Controls.Control.Background%2A> привязано к строковому свойству со значением "Red". Это строковое значение работает, так как преобразователь типов находится в типе <xref:System.Windows.Media.Brush> для преобразования строкового значения в <xref:System.Windows.Media.Brush>.

Если добавить эти сведения на рисунок из раздела [Создание привязки](#creating-a-binding), схема будет выглядеть следующим образом.

![Схема, показывающая свойство привязки данных по умолчанию.](./media/data-binding-overview/data-binding-button-default-conversion.png)

Однако что делать, если вместо свойства строкового типа объект источника привязки имеет свойство *Color* типа <xref:System.Windows.Media.Color>? В этом случае для создания привязки в первую очередь необходимо преобразовать значение свойства *Color* в нечто, что примет свойство <xref:System.Windows.Controls.Control.Background%2A>. Понадобится создать пользовательский преобразователь, реализовав интерфейс <xref:System.Windows.Data.IValueConverter>, как показано в следующем примере.

[!code-csharp[CodeOnlyBinding](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/ColorBrushConverter.cs#ColorBrushConverter)]
[!code-vb[CodeOnlyBinding](~/samples/snippets/desktop-guide/wpf/data-binding-overview/vb/ColorBrushConverter.vb#ColorBrushConverter)]

Дополнительные сведения см. в разделе <xref:System.Windows.Data.IValueConverter>.

Теперь пользовательский преобразователь используется вместо преобразования по умолчанию и схема выглядит следующим образом.

![Схема, на которой показан пользовательский преобразователь привязки данных.](./media/data-binding-overview/data-binding-converter-color-example.png)

Таким образом, преобразования по умолчанию могут быть доступны благодаря преобразователям типов, присутствующим в типе, к которому производится привязка. Такое поведение будет зависеть от того, какие преобразователи типов доступны в целевом объекте. Если существуют какие-то сомнением, создайте свой собственный преобразователь.

Ниже приведены некоторые типовые сценарии, где имеет смысл реализация преобразователя данных.

- Данные должны отображаться по-разному в зависимости от региональных стандартов. Например, можно реализовать преобразователь валюты или преобразователь даты/времени в календаре на основе соглашений, используемых в определенных региональных стандартах.

- Используемые данные не обязательно предназначены для изменения текстового значения свойства, а предназначены для изменения некоторых других значений, например источника изображения, цвета или стиля отображаемого текста. Преобразователи могут использоваться в данном экземпляре для преобразования привязки неподходящего свойства, например привязки текстового поля к свойству Background ячейки таблицы.

- К одним и тем же данным можно привязать несколько элементов управления или несколько свойств элементов управления. В этом случае основная привязка может просто отображать текст, тогда как другие привязки обрабатывают специфичные проблемы отображения, но они по-прежнему используют одну и ту же привязку в качестве исходных данных.

- В целевом свойстве есть набор привязок, который называется <xref:System.Windows.Data.MultiBinding>. Чтобы получить конечное значение из значений привязок, для <xref:System.Windows.Data.MultiBinding> используется пользовательский <xref:System.Windows.Data.IMultiValueConverter>. Например, цвет может быть вычислен из соотношения красного, синего и зеленого значений, которые могут быть значениями одних и тех же или разных объектов источника привязки. Примеры и сведения см. в <xref:System.Windows.Data.MultiBinding>.

## <a name="binding-to-collections"></a>Привязка к коллекциям

Объект источника привязки может рассматриваться как отдельный объект, свойства которого содержат данные, или как коллекция данных полиморфных объектов, часто группируемых вместе (например, в результате запроса к базе данных). До сих пор мы обсуждали привязку только к отдельным объектам. Однако распространенным сценарием также является привязка к коллекции данных. Например, обычным сценарием является использование <xref:System.Windows.Controls.ItemsControl> как <xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.ListView> или <xref:System.Windows.Controls.TreeView> для отображения коллекции данных, например, в приложении, показанном в разделе [Понятие привязки данных](#what-is-data-binding).

К счастью, наша основная схема по-прежнему применима. При привязке <xref:System.Windows.Controls.ItemsControl> к коллекции схема выглядит следующим образом:

![Схема, показывающая объект ItemsControl привязки данных.](./media/data-binding-overview/data-binding-itemscontrol.png)

Как показано на данной схеме, для привязки свойства <xref:System.Windows.Controls.ItemsControl> к объекту коллекции свойство <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A?displayProperty=nameWithType> является свойством, которое необходимо использовать. `ItemsSource` можно представить как содержимое <xref:System.Windows.Controls.ItemsControl>. Привязка — <xref:System.Windows.Data.BindingMode.OneWay>, потому что свойство `ItemsSource` поддерживает привязку `OneWay` по умолчанию.

### <a name="how-to-implement-collections"></a>Способы реализации коллекций

Можно перечислить любую коллекцию, которая реализует интерфейс <xref:System.Collections.IEnumerable>. Однако чтобы настроить динамические привязки таким образом, чтобы вставки и удаления элементов в коллекции автоматически обновляли пользовательский интерфейс, в коллекции должен быть реализован интерфейс <xref:System.Collections.Specialized.INotifyCollectionChanged>. Этот интерфейс предоставляет событие, которое должно вызываться при каждом изменении коллекции.

WPF предоставляет класс <xref:System.Collections.ObjectModel.ObservableCollection%601>, который является встроенной реализацией коллекции данных, предоставляющей интерфейс <xref:System.Collections.Specialized.INotifyCollectionChanged>. Для полной поддержки передачи значений данных от объектов источника в цели каждый объект в коллекции, который поддерживает свойства связывания, должен также реализовывать интерфейс <xref:System.ComponentModel.INotifyPropertyChanged>. Дополнительные сведения см. в разделе [Общие сведения об источниках привязки](../../framework/wpf/data/binding-sources-overview.md).

Перед реализацией собственной коллекции рассмотрите возможность использования <xref:System.Collections.ObjectModel.ObservableCollection%601> или одного из существующих классов коллекций, таких как <xref:System.Collections.Generic.List%601>, <xref:System.Collections.ObjectModel.Collection%601> и <xref:System.ComponentModel.BindingList%601>, среди многих других. Если у вас есть расширенный скрипт и требуется реализовать собственную коллекцию, следует рассмотреть возможность использования <xref:System.Collections.IList>, что представляет коллекцию объектов, к которым можно по отдельности обращаться по индексу, и, следовательно, обеспечивать лучшую производительность.

### <a name="collection-views"></a>Представления коллекций

Так как <xref:System.Windows.Controls.ItemsControl> привязан к коллекции данных, могут потребоваться сортировка, фильтрация и группировка данных. Для этого используются представления коллекций, которые являются классами, реализующими интерфейс <xref:System.ComponentModel.ICollectionView>.

#### <a name="what-are-collection-views"></a>Понятие о представлениях коллекций

Представление коллекции — это слой, расположенный в верхней части связанной исходной коллекции, с помощью которого можно перемещаться по исходной коллекции и просматривать ее содержимое на основе запросов сортировки, фильтрации и группировки, не изменяя саму коллекцию. В представлении коллекции также поддерживается указатель на текущий элемент коллекции. Если исходная коллекция реализует интерфейс <xref:System.Collections.Specialized.INotifyCollectionChanged>, изменения, вызванные событием <xref:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged>, передаются в представления.

Так как представления не меняют базовые исходные коллекции, каждая исходная коллекция может иметь несколько связанных с ней представлений. Например, имеется коллекция объектов *Task*. С помощью представлений можно отображать одни и те же данные различными способами. Например, в левой части страницы можно отображать задачи, отсортированные по приоритету, а справа — сгруппированные по областям.

#### <a name="how-to-create-a-view"></a>Создание представления

Одним из способов создания и использования представления является непосредственное создание объекта представления и затем использование его в качестве источника привязки. В качестве примера рассмотрим приложение [Пример привязки данных][data-binding-demo], показанное в разделе [Понятие привязки данных](#what-is-data-binding). Приложение реализовано таким образом, что <xref:System.Windows.Controls.ListBox> привязывается к представлению коллекции данных, а не к коллекции данных напрямую. Следующий пример извлекается из приложения [Пример привязки данных][data-binding-demo]. Класс <xref:System.Windows.Data.CollectionViewSource> является XAML-прокси класса, который наследуется от <xref:System.Windows.Data.CollectionView>. В данном конкретном примере <xref:System.Windows.Data.CollectionViewSource.Source%2A> представления привязывается к коллекции *AuctionItems* (типа <xref:System.Collections.ObjectModel.ObservableCollection%601>) текущего объекта приложения.

[!code-xaml[CollectionView](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/CollectionView.xaml#CollectionView)]

Затем ресурс *listingDataView* служит источником привязки для элементов в приложении, таких как <xref:System.Windows.Controls.ListBox>.

[!code-xaml[ListBoxCollectionView](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/CollectionView.xaml#ListBoxCollectionView)]

Чтобы создать другое представление для той же коллекции, можно создать другой экземпляр <xref:System.Windows.Data.CollectionViewSource> и присвоить ему другое имя `x:Key`.

В приведенной ниже таблице показано, какие типы данных представления созданы в качестве представления коллекции по умолчанию либо объектом <xref:System.Windows.Data.CollectionViewSource> на основе типа исходной коллекции.

| Тип исходной коллекции                    | Тип представления коллекции | Примечания |
| ----------------------------------------- | -------------------- | ----- |
| <xref:System.Collections.IEnumerable>     | Внутренний тип, основанный на <xref:System.Windows.Data.CollectionView> | Невозможно группировать элементы. |
| <xref:System.Collections.IList>           | <xref:System.Windows.Data.ListCollectionView> | Самый быстрый. |
| <xref:System.ComponentModel.IBindingList> | <xref:System.Windows.Data.BindingListCollectionView> | |

#### <a name="using-a-default-view"></a>Использование представления по умолчанию

Один из способов создания и использования представления коллекции заключается в указании представления коллекции в качестве источника привязки. WPF также создает представление коллекции по умолчанию для каждой коллекции, используемой в качестве источника привязки. Если выполнить привязку непосредственно к коллекции, WPF выполняет привязку к представлению коллекции по умолчанию. Данное представление по умолчанию совместно используется всеми привязками к одной и той же коллекции, поэтому изменения, внесенные в представление по умолчанию одним привязанным элементом управления либо кодом (например, сортировка или изменение указателя на текущий элемент, что будет рассмотрено ниже), распространяются на все привязки к одной коллекции.

Чтобы получить представление по умолчанию, используйте метод <xref:System.Windows.Data.CollectionViewSource.GetDefaultView%2A>. Пример см. в разделе [Практическое руководство. Получение представления по умолчанию для коллекции данных](../../framework/wpf/data/how-to-get-the-default-view-of-a-data-collection.md).

#### <a name="collection-views-with-adonet-datatables"></a>Использование представлений коллекций с таблицами данных ADO.NET

Для улучшения производительности представления коллекции для ADO.NET <xref:System.Data.DataTable> или <xref:System.Data.DataView> объектов делегируют сортировку и фильтрацию <xref:System.Data.DataView>, что приводит к тому, что сортировка и фильтрация совместно используются всеми представлениями коллекции источника данных. Чтобы включить возможность независимой сортировки и фильтрации для каждого представления коллекции, инициализируйте каждое представление коллекции с использованием собственного объекта <xref:System.Data.DataView>.

#### <a name="sorting"></a>Сортировка

Как уже отмечалось ранее, представления могут применять сортировку для коллекции. Так как данные находятся в базовой коллекции, они могут иметь или не иметь некий порядок следования. Представление коллекции позволяет установить порядок или изменить порядок, используемый по умолчанию, на основе введенных признаков сравнения. Так как это представление данных на стороне клиента, распространенным скриптом является сортировка пользователем столбцов табличных данных по значениям, содержащимся в столбце. С использованием представлений управляемая пользователем сортировка может применяться еще раз без необходимости внесения изменений в основную коллекцию или создания повторного запроса к содержимому коллекции. Пример см. в статье [Практическое руководство. Сортировка столбцов GridView при нажатии на заголовок](../../framework/wpf/controls/how-to-sort-a-gridview-column-when-a-header-is-clicked.md).

В следующем примере показана логика сортировки для флажка "Sort by category and date" (Сортировать по категории и дате) в <xref:System.Windows.Controls.CheckBox> пользовательского интерфейса приложения, описанного в подразделе [Понятие привязки данных](#what-is-data-binding).

[!code-csharp[AddSortChecked](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/CollectionView.xaml.cs#AddSortChecked)]
[!code-vb[AddSortChecked](~/samples/snippets/desktop-guide/wpf/data-binding-overview/vb/CollectionView.xaml.vb#AddSortChecked)]

#### <a name="filtering"></a>Фильтрация

Представления могут также применять фильтр к коллекции, так чтобы представление отображало только определенное подмножество полной коллекции. Возможна фильтрация по условию в данных. Например, как показано в приложении из подраздела [Понятие привязки данных](#what-is-data-binding), флажок <xref:System.Windows.Controls.CheckBox> "Show only bargains" (Показывать только товары по сниженным ценам) содержит логику фильтрации товаров с ценой 25 долл. США и выше. Следующий код выполняется для установки *ShowOnlyBargainsFilter* в качестве обработчика событий <xref:System.Windows.Data.CollectionViewSource.Filter> при выборе <xref:System.Windows.Controls.CheckBox>.

[!code-csharp[ListingViewFilter](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/CollectionView.xaml.cs#ListingViewFilter)]
[!code-vb[ListingViewFilter](~/samples/snippets/desktop-guide/wpf/data-binding-overview/vb/CollectionView.xaml.vb#ListingViewFilter)]

Обработчик события *ShowOnlyBargainsFilter* реализуется следующим образом.

[!code-csharp[FilterEvent](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/CollectionView.xaml.cs#FilterEvent)]
[!code-vb[FilterEvent](~/samples/snippets/desktop-guide/wpf/data-binding-overview/vb/CollectionView.xaml.vb#FilterEvent)]

Если вместо <xref:System.Windows.Data.CollectionViewSource> используется один из классов <xref:System.Windows.Data.CollectionView>, для указания обратного вызова следует использовать свойство <xref:System.Windows.Data.CollectionView.Filter%2A>. Пример см. в разделе [Практическое руководство. Фильтрация данных в представлении](../../framework/wpf/data/how-to-filter-data-in-a-view.md).

#### <a name="grouping"></a>Группирование

За исключением внутреннего класса, предназначенного для просмотра коллекции <xref:System.Collections.IEnumerable>, все представления коллекций поддерживают функцию *группировки*, которая позволяет пользователю логически разбить коллекцию в представлении коллекции на группы. Группы могут быть явными, если пользователь предоставляет список групп, или неявными, если эти группы создаются динамически в зависимости от данных.

В следующем примере показана логика флажка "Группировка по категориям" <xref:System.Windows.Controls.CheckBox>.

[!code-csharp[ListingGroupCheck](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/CollectionView.xaml.cs#ListingGroupCheck)]
[!code-vb[ListingGroupCheck](~/samples/snippets/desktop-guide/wpf/data-binding-overview/vb/CollectionView.xaml.vb#ListingGroupCheck)]

Другой пример группировки см. в разделе [Практическое руководство. Группировка элементов в объекте ListView, реализующем GridView](../../framework/wpf/controls/how-to-group-items-in-a-listview-that-implements-a-gridview.md).

#### <a name="current-item-pointers"></a>Указатели на текущий элемент

В представлениях также присутствует понятие текущего элемента. Существует возможность перемещаться по объектам в представлении коллекции. При переходе перемещается указатель элемента, позволяющий извлечь объект, расположенный в определенном месте в коллекции. Пример см. в разделе [Перемещение по объектам в Data CollectionView](../../framework/wpf/data/how-to-navigate-through-the-objects-in-a-data-collectionview.md).

Поскольку WPF выполняет привязку к коллекции только с помощью представления (либо указанного пользователем, либо представления коллекции по умолчанию), для всех привязок к коллекциям имеется указатель на текущий элемент. При привязке к представлению символ косой черты ("/") в значении `Path` указывает на текущий элемент представления. В следующем примере контекст данных является представлением коллекции. В первой строке выполняется привязка к коллекции. Во второй строке выполняется привязка к текущему элементу коллекции. В третьей строке выполняется привязка к свойству `Description` текущего элемента коллекции.

```xaml
<Button Content="{Binding }" />
<Button Content="{Binding Path=/}" />
<Button Content="{Binding Path=/Description}" />
```

Косую черту и синтаксис свойства также можно комбинировать для обработки иерархии коллекций. В приведенном ниже примере выполняется привязка к текущему элементу коллекции `Offices`, который является свойством текущего элемента исходной коллекции.

```xaml
<Button Content="{Binding /Offices/}" />
```

На указатель текущего элемента влияют примененные к коллекции операции сортировки и фильтрации. При сортировке указатель текущего элемента устанавливается на последний выбранный элемент, однако представление коллекции перестраивается относительно его. (Возможно, до этого выбранный элемент был в начале списка, но теперь выбранный элемент может оказаться где-нибудь в середине.) При фильтрации выбранный элемент сохраняется, если данный выбор остается в представлении после фильтрации. В противном случае указатель текущего элемента устанавливается на первый элемент отфильтрованного представления коллекции.

#### <a name="master-detail-binding-scenario"></a>Сценарий "основной — подробности"

Понятие текущего элемента применимо не только для перемещения элементов в коллекции, но также для сценария привязки "основной — подробности". Еще раз рассмотрим пользовательский интерфейс приложения из подраздела [Понятие привязки данных](#what-is-data-binding). В этом приложении выбор внутри <xref:System.Windows.Controls.ListBox> определяет содержимое, отображаемое в <xref:System.Windows.Controls.ContentControl>. Другими словами, когда выбран элемент <xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.ContentControl> показывает сведения выбранного элемента.

Для реализации этого сценария необходимо наличие двух или более элементов управления, привязанных к одному и тому же представлению. Следующий пример из [примера привязки данных][data-binding-demo] показывает разметку <xref:System.Windows.Controls.ListBox> и <xref:System.Windows.Controls.ContentControl>, которую вы видите в пользовательском интерфейсе приложения в разделе [Понятие привязки данных](#what-is-data-binding).

[!code-xaml[ListBoxContentControl](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/CollectionView.xaml#ListBoxContentControl)]

Обратите внимание, что оба элемента управления привязаны к одному источнику, статическому ресурсу *listingDataView* (просмотреть определение этого ресурса можно в подразделе [Создание представления](#how-to-create-a-view)). Эта привязка работает потому, что если отдельный объект (<xref:System.Windows.Controls.ContentControl> в данном случае) привязан к представлению коллекции, то он автоматически привязывается к <xref:System.Windows.Data.CollectionView.CurrentItem%2A> представления. Объекты <xref:System.Windows.Data.CollectionViewSource> автоматически синхронизируют валюту и выделение. Если ваш элемент управления списком не привязан к объекту <xref:System.Windows.Data.CollectionViewSource>, как в данном примере, то, чтобы это сработало, его свойство <xref:System.Windows.Controls.Primitives.Selector.IsSynchronizedWithCurrentItem%2A> необходимо установить в `true`.

Другие примеры см. в разделах [Практическое руководство. Привязка к коллекции и вывод сведений в зависимости от выделенного элемента](../../framework/wpf/data/how-to-bind-to-a-collection-and-display-information-based-on-selection.md) и [Практическое руководство. Использование шаблона "основной — подробности" с иерархическими данными](../../framework/wpf/data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md).

Можно заметить, что в приведенном выше примере используется шаблон. Фактически данные не будут отображаться выбранным способом без использования шаблонов (один явно используется элементом <xref:System.Windows.Controls.ContentControl>, а другой — неявно элементом <xref:System.Windows.Controls.ListBox>). К шаблонам данных мы перейдем в следующем разделе.

## <a name="data-templating"></a>Шаблоны данных

Без использования шаблонов данных пользовательского интерфейса приложения в подразделе [Понятие привязки данных](#what-is-data-binding) будет выглядеть следующим образом.

![Демонстрация привязки данных без шаблонов данных](./media/data-binding-overview/demo-no-template.png)

Как показано в примере из предыдущего раздела, оба элемента управления — как <xref:System.Windows.Controls.ListBox>, так и <xref:System.Windows.Controls.ContentControl>, привязываются ко всему объекту коллекции (а точнее к представлению объекта коллекции) элементов *AuctionItem*. При отсутствии особых инструкций по способу отображения сбора данных элемент управления <xref:System.Windows.Controls.ListBox> отображает строковое представление каждого объекта в базовой коллекции, а элемент управления <xref:System.Windows.Controls.ContentControl> отображает строковое представление привязанного к ней объекта.

Чтобы решить эту проблему, приложение определяет <xref:System.Windows.DataTemplate?text=DataTemplates>. Как показано в примере в предыдущем разделе, <xref:System.Windows.Controls.ContentControl> явно использует шаблон данных *detailsProductListingTemplate*. Элемент управления <xref:System.Windows.Controls.ListBox> неявно использует следующий шаблон данных при отображении объектов *AuctionItem* в коллекции.

[!code-xaml[AuctionItemDataTemplate](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/CollectionView.xaml#AuctionItemDataTemplate)]

При использовании двух шаблонов DataTemplate результирующий пользовательский интерфейс будет аналогичен пользовательскому интерфейсу, показанному в разделе [Понятие привязки данных](#what-is-data-binding). Как можно увидеть на этом снимке, в дополнение к тому, что шаблоны DataTemplate дают возможность располагать данные в элементах управления, они позволяют определять подходящие визуальные элементы для данных. Например, элементы <xref:System.Windows.DataTrigger> используются в приведенном выше шаблоне <xref:System.Windows.DataTemplate>, чтобы элементы *AuctionItem* со значением *SpecialFeatures* для *HighLight* отображались с оранжевой границей и звездочкой.

Дополнительные сведения о шаблонах данных см. в разделе [Общие сведения о шаблонах данных](../../framework/wpf/data/data-templating-overview.md).

## <a name="data-validation"></a>Проверка данных

Для большинства приложений, принимающих входные данные от пользователя, необходима логика проверки, чтобы убедиться, что пользователь ввел ожидаемые данные. Проверка может основываться на типе, диапазоне, формате или других требованиях конкретного приложения. В этом разделе рассматривается, как работает проверка данных в WPF.

### <a name="associating-validation-rules-with-a-binding"></a>Связь правил проверки и привязки

Модель привязки данных WPF позволяет связать <xref:System.Windows.Data.Binding.ValidationRules%2A> с объектом <xref:System.Windows.Data.Binding>. Например, в следующем примере <xref:System.Windows.Controls.TextBox> привязывается к свойству с именем `StartPrice` и в свойство <xref:System.Windows.Data.Binding.ValidationRules%2A?displayProperty=nameWithType> добавляется объект <xref:System.Windows.Controls.ExceptionValidationRule>.

[!code-xaml[TextboxStartPrice](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/DataValidation.xaml#TextboxStartPrice)]

Объект <xref:System.Windows.Controls.ValidationRule> проверяет, является ли значение свойства допустимым. В состав WPF входят два типа встроенных объектов <xref:System.Windows.Controls.ValidationRule>:

- <xref:System.Windows.Controls.ExceptionValidationRule> выполняет проверку исключений, возникающих во время обновления свойства источника привязки. В предыдущем примере `StartPrice` имеет тип integer. Когда пользователь вводит значение, которое невозможно преобразовать в целое число, создается исключение, приводящее к тому, что привязка будет помечена как недопустимая. Альтернативным синтаксисом для явной установки свойства <xref:System.Windows.Controls.ExceptionValidationRule> является установка свойства <xref:System.Windows.Data.Binding.ValidatesOnExceptions%2A> в `true` для вашего объекта <xref:System.Windows.Data.Binding> или <xref:System.Windows.Data.MultiBinding>.

- Объект <xref:System.Windows.Controls.DataErrorValidationRule> проверяет наличие ошибок, вызванных объектами, реализующими интерфейс <xref:System.ComponentModel.IDataErrorInfo>. Пример использования этого правила проверки см. в <xref:System.Windows.Controls.DataErrorValidationRule>. Альтернативным синтаксисом для явной установки свойства <xref:System.Windows.Controls.DataErrorValidationRule> является установка свойства <xref:System.Windows.Data.Binding.ValidatesOnDataErrors%2A> в `true` для вашего объекта <xref:System.Windows.Data.Binding> или <xref:System.Windows.Data.MultiBinding>.

Вы можете также создать собственное правило проверки, выполнив наследование от класса <xref:System.Windows.Controls.ValidationRule> и реализовав метод <xref:System.Windows.Controls.ValidationRule.Validate%2A>. В следующем примере показано правило, используемое элементом управления "Дата начала" для *Добавление списка продуктов* <xref:System.Windows.Controls.TextBox>, показанного в разделе [Понятие привязки данных](#what-is-data-binding).

[!code-csharp[FutureDateRule](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/FutureDateRule.cs#FutureDateRule)]
[!code-vb[FutureDateRule](~/samples/snippets/desktop-guide/wpf/data-binding-overview/vb/FutureDateRule.vb#FutureDateRule)]

*StartDateEntryForm* <xref:System.Windows.Controls.TextBox> использует это правило *FutureDateRule*, как показано в следующем примере.

[!code-xaml[TextboxStartDate](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/DataValidation.xaml#TextboxStartDate)]

Поскольку значение <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A> равно <xref:System.Windows.Data.UpdateSourceTrigger.PropertyChanged>, механизм привязки обновляет исходное значение при каждом нажатии клавиши, что означает, что он также проверяет каждое правило в коллекции <xref:System.Windows.Data.Binding.ValidationRules%2A> при каждом нажатии клавиши. Это будет обсуждаться далее в разделе "Процесс проверки".

### <a name="providing-visual-feedback"></a>Предоставление визуального отклика

Если пользователь вводит недопустимое значение, можно сформировать отклик пользовательского интерфейса приложения на ошибку. Одним из способов предоставления такой обратной связи является установка присоединенного свойства <xref:System.Windows.Controls.Validation.ErrorTemplate%2A?displayProperty=nameWithType> для пользовательского <xref:System.Windows.Controls.ControlTemplate>. Как показано в предыдущем подразделе, *StartDateEntryForm* — <xref:System.Windows.Controls.TextBox> использует <xref:System.Windows.Controls.Validation.ErrorTemplate%2A> с именем *validationTemplate*. В следующем примере показано определение элемента *validationTemplate*.

[!code-xaml[ControlTemplate](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/DataValidation.xaml#ControlTemplate)]

Элемент <xref:System.Windows.Controls.AdornedElementPlaceholder> указывает, где должен размещаться элемент управления.

Кроме того, вы можете использовать <xref:System.Windows.Controls.ToolTip> для вывода сообщения об ошибке. Как *StartDateEntryForm*, так и *StartPriceEntryForm*<xref:System.Windows.Controls.TextBox> используют стиль *textStyleTextBox*, который создает <xref:System.Windows.Controls.ToolTip>, отображающий сообщение об ошибке. В следующем примере показано определение элемента *textStyleTextBox*. Присоединенное свойство <xref:System.Windows.Controls.Validation.HasError%2A?displayProperty=nameWithType> равно `true`, когда одна или несколько привязок к свойствам связанного элемента ошибочны.

[!code-xaml[TextBoxStyle](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/DataValidation.xaml#TextBoxStyle)]

При использовании пользовательских <xref:System.Windows.Controls.Validation.ErrorTemplate%2A> и <xref:System.Windows.Controls.ToolTip> *StartDateEntryForm* <xref:System.Windows.Controls.TextBox> при наличии ошибки проверки выглядит следующим образом:

![Ошибка проверки привязки данных](./media/data-binding-overview/demo-validation-date.png "DataBindingDemo_Validation")

Если <xref:System.Windows.Data.Binding> имеет связанные правила проверки, но для привязанного элемента управления не указан <xref:System.Windows.Controls.Validation.ErrorTemplate%2A>, для уведомления пользователей об ошибке проверки по умолчанию будет использоваться <xref:System.Windows.Controls.Validation.ErrorTemplate%2A>. <xref:System.Windows.Controls.Validation.ErrorTemplate%2A> по умолчанию — это шаблон элемента управления, определяющий красную границу на слое декоративных элементов. При использовании <xref:System.Windows.Controls.Validation.ErrorTemplate%2A> по умолчанию и пользовательского интерфейса <xref:System.Windows.Controls.ToolTip> *StartPriceEntryForm* <xref:System.Windows.Controls.TextBox> при наличии ошибки проверки выглядит следующим образом:

![Ошибка проверки привязки данных](./media/data-binding-overview/demo-validation-price.png "DataBindingDemo_ValidationDefault")

Пример предоставления логики проверки всех элементов управления в диалоговом окне см. в подразделе "Пользовательские диалоговые окна" раздела [Общие сведения о диалоговых окнах](../../framework/wpf/app-development/dialog-boxes-overview.md).

### <a name="validation-process"></a>Процесс проверки

Проверка обычно выполняется, когда целевое значение передается свойству источника привязки. Этот перенос выполняется для привязок <xref:System.Windows.Data.BindingMode.TwoWay> и <xref:System.Windows.Data.BindingMode.OneWayToSource>. Таким образом, причина обновления источника зависит от значения свойства <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A>, как описано в подразделе [Что инициирует обновления источника](#what-triggers-source-updates).

Следующие элементы описывают процесс *проверки*. При возникновении ошибки проверки или ошибки другого типа на любом этапе данного процесса процесс будет прерван.

1. Обработчик привязки проверяет, есть ли определенные пользовательские объекты <xref:System.Windows.Controls.ValidationRule>, где для <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> задано значение <xref:System.Windows.Controls.ValidationStep.RawProposedValue> для этого <xref:System.Windows.Data.Binding>. В этом случае он вызывает метод <xref:System.Windows.Controls.ValidationRule.Validate%2A> на каждом <xref:System.Windows.Controls.ValidationRule> до тех пор, пока один из них не выдаст ошибку или пока все они не сработают.

2. Обработчик привязки вызывает преобразователь, если таковой существует.

3. Если преобразователь сработает корректно, механизм связывания проверяет, нет ли каких-либо пользовательских объектов <xref:System.Windows.Controls.ValidationRule>, чей <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> имеет значение <xref:System.Windows.Controls.ValidationStep.ConvertedProposedValue> для этого <xref:System.Windows.Data.Binding>, и в этом случае он вызывает метод <xref:System.Windows.Controls.ValidationRule.Validate%2A> для каждого <xref:System.Windows.Controls.ValidationRule>, чей <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> имеет значение <xref:System.Windows.Controls.ValidationStep.ConvertedProposedValue>, пока один из них не встретится с ошибкой или пока все они не пройдут.

4. Обработчик привязки присваивает значение исходному свойству.

5. Обработчик привязки проверяет, есть ли определенные пользовательские объекты <xref:System.Windows.Controls.ValidationRule>, где для <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> задано значение <xref:System.Windows.Controls.ValidationStep.UpdatedValue> для этого <xref:System.Windows.Data.Binding>. В этом случае он вызывает метод <xref:System.Windows.Controls.ValidationRule.Validate%2A> на каждом <xref:System.Windows.Controls.ValidationRule>, чей <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> имеет значение <xref:System.Windows.Controls.ValidationStep.UpdatedValue>, до тех пор пока один из них не выдаст ошибку или пока все они не сработают. Если <xref:System.Windows.Controls.DataErrorValidationRule> связан с привязкой, а для его <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> задано значение по умолчанию <xref:System.Windows.Controls.ValidationStep.UpdatedValue>, <xref:System.Windows.Controls.DataErrorValidationRule> проверяется на этом этапе. В этот момент проверяется любая привязка, где <xref:System.Windows.Data.Binding.ValidatesOnDataErrors%2A> имеет значение `true`.

6. Обработчик привязки проверяет, есть ли определенные пользовательские объекты <xref:System.Windows.Controls.ValidationRule>, где для <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> задано значение <xref:System.Windows.Controls.ValidationStep.CommittedValue> для этого <xref:System.Windows.Data.Binding>. В этом случае он вызывает метод <xref:System.Windows.Controls.ValidationRule.Validate%2A> на каждом <xref:System.Windows.Controls.ValidationRule>, чей <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> имеет значение <xref:System.Windows.Controls.ValidationStep.CommittedValue>, до тех пор пока один из них не выдаст ошибку или пока все они не сработают.

Если <xref:System.Windows.Controls.ValidationRule> не передается в течение этого процесса, подсистема привязки создает объект <xref:System.Windows.Controls.ValidationError> и добавляет его в коллекцию <xref:System.Windows.Controls.Validation.Errors%2A?displayProperty=nameWithType> связанного элемента. Перед тем как обработчик привязки запустит объекты <xref:System.Windows.Controls.ValidationRule> на любом шаге, он удаляет все <xref:System.Windows.Controls.ValidationError>, добавленные во вложенное свойство <xref:System.Windows.Controls.Validation.Errors%2A?displayProperty=nameWithType> связанного элемента на этом шаге. Например, если <xref:System.Windows.Controls.ValidationRule>, чей <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> имеет значение <xref:System.Windows.Controls.ValidationStep.UpdatedValue>, завершилось с ошибкой, то в следующий раз, когда происходит процесс проверки, механизм привязки удаляет <xref:System.Windows.Controls.ValidationError> непосредственно перед вызовом любого <xref:System.Windows.Controls.ValidationRule>, у которого для <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> установлено значение <xref:System.Windows.Controls.ValidationStep.UpdatedValue>.

Если значение <xref:System.Windows.Controls.Validation.Errors%2A?displayProperty=nameWithType> не пустое, то прикрепленное свойство <xref:System.Windows.Controls.Validation.HasError%2A?displayProperty=nameWithType> элемента имеет значение `true`. Также если свойство <xref:System.Windows.Data.Binding.NotifyOnValidationError%2A> <xref:System.Windows.Data.Binding> имеет значение `true`, то обработчик привязки вызывает в элементе <xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType> присоединенное событие.

Также обратите внимание, что при передаче допустимого значения в любом направлении (от целевого объекта к источнику и от источника к целевому объекту) очищается вложенное свойство <xref:System.Windows.Controls.Validation.Errors%2A?displayProperty=nameWithType>.

Если привязка либо связана с <xref:System.Windows.Controls.ExceptionValidationRule>, либо имеет свойство <xref:System.Windows.Data.Binding.ValidatesOnExceptions%2A>, которое имеет значение `true`, и при установке источника привязки срабатывает исключение, то привязка проверяет, есть ли <xref:System.Windows.Data.Binding.UpdateSourceExceptionFilter%2A>. Вы можете использовать обратный вызов <xref:System.Windows.Data.Binding.UpdateSourceExceptionFilter%2A>, чтобы предоставить пользовательский обработчик для обработки исключений. Если для элемента <xref:System.Windows.Data.Binding> не указано <xref:System.Windows.Data.Binding.UpdateSourceExceptionFilter%2A>, механизм привязки создает <xref:System.Windows.Controls.ValidationError> с исключением и добавляет его в коллекцию <xref:System.Windows.Controls.Validation.Errors%2A?displayProperty=nameWithType> связанного элемента.

## <a name="debugging-mechanism"></a>Механизм отладки

Для получения сведений о состоянии конкретной привязки можно задать присоединенное свойство <xref:System.Diagnostics.PresentationTraceSources.TraceLevel%2A?displayProperty=nameWithType> на объекте, связанном с привязкой.

## <a name="see-also"></a>См. также

- <xref:System.Windows.Controls.DataErrorValidationRule>
- [Привязка к результатам запроса LINQ](../../framework/wpf/data/how-to-bind-to-the-results-of-a-linq-query.md)
- [Привязка данных](../../framework/wpf/advanced/optimizing-performance-data-binding.md)
- [Пример привязки данных][data-binding-demo]
- [Статьи с инструкциями](../../framework/wpf/data/data-binding-how-to-topics.md)
- [Привязка к источнику данных ADO.NET](../../framework/wpf/data/how-to-bind-to-an-ado-net-data-source.md)

[data-binding-demo]: https://github.com/microsoft/WPF-Samples/tree/master/Sample%20Applications/DataBindingDemo "Демонстрационное приложение привязки данных"
