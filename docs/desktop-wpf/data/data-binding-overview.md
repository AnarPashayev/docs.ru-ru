---
title: Общие сведения о привязке данных
description: Узнайте о различных источниках данных, которые можно добавить в свой проект, в Фонде презентации Windows для .NET Core. Источники данных могут быть привязаны к элементам XAML для создания динамических приложений.
author: thraka
ms.date: 09/19/2019
ms.author: adegeo
dev_langs:
- csharp
- vb
ms.openlocfilehash: 7f17ff094a35c04ba880c87c6966d7d249817516
ms.sourcegitcommit: b75a45f0cfe012b71b45dd9bf723adf32369d40c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/24/2020
ms.locfileid: "81433256"
---
# <a name="data-binding-overview-in-wpf"></a>Обзор связывания данных в WPF

Привязка данных в Windows Presentation Foundation (WPF) обеспечивает простой и последовательный способ представления приложений и взаимодействия с данными. Элементы могут быть привязаны к данным из различных источников данных в виде объектов .NET и XML. Любые <xref:System.Windows.Controls.ContentControl> <xref:System.Windows.Controls.Button> такие, <xref:System.Windows.Controls.ItemsControl>как <xref:System.Windows.Controls.ListBox> и <xref:System.Windows.Controls.ListView>любые, такие как и, имеют встроенный функционал, позволяющий гибкое укладка отдельных элементов данных или коллекции элементов данных. Представления сортировки, фильтрации и группировки могут быть организованы поверх данных.

Функциональность связывания данных в WPF имеет ряд преимуществ по сравнению с традиционными моделями, включая присущую поддержку связывания данных широким спектром свойств, гибкое представление данных в области uI и четкое отделение бизнес-логики от uI.

В этой статье сначала рассматриваются концепции, основополагающие для <xref:System.Windows.Data.Binding> связывания данных WPF, а затем охватывается использование класса и другие особенности связывания данных.

[!INCLUDE [desktop guide under construction](../../../includes/desktop-guide-preview-note.md)]

## <a name="what-is-data-binding"></a>Что такое привязка данных?

Связывание данных — это процесс, который устанавливает связь между uI приложения и отображаемыми данными. Если для привязки заданы правильные настройки, а изменения значений данных сопровождаются правильными уведомлениями, привязанные к данным элементы автоматически отражают изменения. Привязка данных может также означать, что, если внешнее представление данных в элементе изменяется, то базовые данные могут автоматически обновляться для отражения изменений. Например, если пользователь меняет значение `TextBox` в элементе, базовое значение данных автоматически обновляется, чтобы отразить это изменение.

Типичным использованием связывания данных является разбивание данных сервера или локальной конфигурации в формы или другие элементы управления доступом к использованию. В WPF эта концепция расширяется и включает привязку широкого спектра свойств к различным источникам данных. В WPF свойства зависимости элементов могут быть привязаны к объектам .NET (включая ADO.NET объектов или объектов, связанных с Web Services и Web свойствами) и данными XML.

Например, привязка данных, взгляните на следующий uI приложения из [демо-связывания данных,][data-binding-demo]в котором отображается список элементов аукциона.

![Скриншот выборки связывания данных](./media/data-binding-overview/demo.png "DataBinding_DataBindingDemo")

Приложение демонстрирует следующие особенности связывания данных:

- Содержание ListBox привязано к коллекции объектов *AuctionItem.* Объект *AuctionItem* имеет такие свойства, как *описание,* *StartPrice,* *StartDate,* *Категория,* *SpecialFeatures*и так далее.

- Данные (объекты*AuctionItem),* `ListBox` отображаемые в шаблоне, так что описание и текущая цена отображаются для каждого элемента. Шаблон создается с <xref:System.Windows.DataTemplate>помощью . Кроме того, внешний вид каждого элемента зависит от значения *SpecialFeatures* отображаемого объекта *AuctionItem*. Если значением *SpecialFeatures* объекта *AuctionItem* является *Color*, элемент имеет синюю границу. Если значением является *Highlight*, элемент имеет оранжевые границы и помечается звездочкой. Раздел [Создание шаблонов данных](#data-templating) содержит сведения о создании шаблонов данных.

- Пользователь может группировать, фильтровать или `CheckBoxes` сортировать данные с помощью предоставленных данных. На рисунке выше, **группа по категориям** и **сортировать по категориям и дате** `CheckBoxes` выбраны. Можно увидеть, что данные группируются по категориям продуктов, а имена категорий приводятся в алфавитном порядке. Из рисунка трудно заметить, что элементы в каждой категории также сортируются по начальной дате. Сортировка осуществляется с помощью *представления коллекции.* В разделе [«Связывание к коллекциям»](#binding-to-collections) рассматриваются представления коллекции.

- Когда пользователь выбирает элемент, <xref:System.Windows.Controls.ContentControl> отображается детали выбранного элемента. Этот опыт называется *сценарием Мастер-детали.* В разделе [сценарий Master-detail](#master-detail-binding-scenario) содержится информация об этом типе привязки.

- Тип свойства *StartDate* , <xref:System.DateTime>который возвращает дату, которая включает в себя время до миллисекунды. В этом приложении использовался пользовательский конвертер, так что отображается более короткая строка даты. В разделе [преобразования данных](#data-conversion) содержится информация о преобразователях.

Когда пользователь выбирает кнопку *Добавить продукт,* появляется следующая форма.

![Добавить страницу списка продуктов](./media/data-binding-overview/demo-addproductlisting.png "DataBinding_Demo_AddProductListing")

Пользователь может отсеивать поля в форме, просматривать список продуктов `Submit` с помощью коротких или подробных стекол предварительного просмотра и выбрать для добавления нового списка продуктов. Любые существующие настройки группировки, фильтрации и сортировки будут применяться к новой записи. В этом конкретном случае элемент, введенный на приведенном выше рисунке, будет отображаться как второй элемент в категории *Компьютер*.

На этом изображении не отображается логика проверки, указанная в *начальной дате.* <xref:System.Windows.Controls.TextBox> Если пользователь вводит недействительную дату (недействительный форматирование или прошлую дату), пользователь будет уведомлен с <xref:System.Windows.Controls.ToolTip> <xref:System.Windows.Controls.TextBox>красным восклицательным знаком рядом с . Сведения о создании логики проверки см. в разделе [Проверка данных](#data-validation).

Прежде чем перейти к различным особенностям связывания данных, изложенных выше, мы сначала обсудим фундаментальные концепции, которые имеют решающее значение для понимания связывания данных WPF.

## <a name="basic-data-binding-concepts"></a>Основные концепции связывания данных

Независимо от того, какой элемент вы привязываете и характер источника данных, каждая привязка всегда следует модели, иллюстрированной следующей цифрой.

![Диаграмма, отображающая базовую модель связывания данных.](./media/data-binding-overview/basic-data-binding-diagram.png)

Как видно на рисунке, связывание данных по существу является мостом между связывающей целью и связывающим источником. Цифра демонстрирует следующие фундаментальные концепции связывания данных WPF:

- Как правило, каждый привязка имеет четыре компонента:

  - Обязательный целевой объект.
  - Целевое свойство.
  - Источник привязки.
  - Путь к значению в используемом источнике связывания.
  
  > Например, если вы хотите связать `TextBox` содержимое `Employee.Name` объекта к свойству, объектом `TextBox`цели <xref:System.Windows.Controls.TextBox.Text%2A> является целевое свойство, значение для использования — *имя,* а исходным объектом является объект *сотрудника.*

- Целевое свойство должно быть свойством зависимостей. Большинство <xref:System.Windows.UIElement> свойств являются свойствами зависимостей, и большинство свойств зависимостей, за исключением свойств только для чтения, поддерживают связывание данных по умолчанию. (Только типы, <xref:System.Windows.DependencyObject> полученные из может <xref:System.Windows.UIElement> определить свойства `DependencyObject`зависимости; и все типы вытекают из .)

- Хотя объект не показан на рисунке, следует отметить, что объект связывающего источника не ограничивается тем, что является пользовательским объектом .NET. Связывание данных WPF поддерживает данные в виде объектов .NET и XML. Для приведения некоторых примеров <xref:System.Windows.UIElement>вашим связывающим источником может быть любой объект списка, объект ADO.NET или Web Services или XmlNode, содержащий данные XML. Для получения дополнительной информации смотрите [обзор связывающих источников](../../framework/wpf/data/binding-sources-overview.md).

Важно помнить, что при установлении привязки вы привязываете обязательную цель *к* связывающему источнику. Например, если вы отображаете некоторые базовые <xref:System.Windows.Controls.ListBox> данные XML в `ListBox` связывании данных, вы привязываете свои данные к данным XML.

Чтобы установить привязку, вы используете <xref:System.Windows.Data.Binding> объект. В остальной части этой статьи рассматриваются многие понятия, связанные `Binding` с и некоторые свойства и использование объекта.

### <a name="direction-of-the-data-flow"></a>Направление потока данных

Как указывает стрелка в предыдущем рисунке, поток данных привязки может перейти от привязной цели к связывающему `TextBox`источнику (например, значение источника изменяется, `TextBox` когда пользователь меняет значение) и/или от связывающего источника к цели связывания (например, содержимое обновляется с изменениями в связывающем источнике), если связывающий источник предоставляет соответствующие уведомления.

Возможно, приложение позволит пользователям изменять данные и распространять их обратно на исходный объект. Или может потребоваться не предоставлять пользователям возможности обновления источника данных. Вы можете контролировать поток данных, <xref:System.Windows.Data.Binding.Mode?displayProperty=nameWithType>установив.

Эта цифра иллюстрирует различные типы потока данных:

![Поток данных привязки данных](./media/data-binding-overview/databinding-dataflow.png "DataBinding_DataFlow")

- <xref:System.Windows.Data.BindingMode.OneWay>связывание приводит к изменениям в свойстве источника для автоматического обновления целевого свойства, но изменения в целевом свойстве не распространяются обратно в свойство источника. Этот тип привязки подходит, если привязываемый элемент управления неявно доступен только для чтения. Например, вы можете привязаться к источнику, такому как биржевый тикер, или, возможно, ваше целевое свойство не имеет интерфейса управления, предусмотренного для внесения изменений, таких как фоновый цвет таблицы, связанный с данными. Если нет необходимости отслеживать изменения целевого свойства, можно работать в режиме привязки <xref:System.Windows.Data.BindingMode.OneWay> — в этом случае удастся избежать издержек режима привязки <xref:System.Windows.Data.BindingMode.TwoWay>.

- <xref:System.Windows.Data.BindingMode.TwoWay>привязка вызывает изменения либо исходного свойства, либо целевого свойства для автоматического обновления другого. Этот тип привязки подходит для отсеиваемых форм или других полностью интерактивных сценариев uI. Большинство свойств <xref:System.Windows.Data.BindingMode.OneWay> по умолчанию для связывания, но некоторые свойства зависимости <xref:System.Windows.Controls.TextBox.Text?displayProperty=nameWithType> (как правило, свойства <xref:System.Windows.Data.BindingMode.TwoWay> пользовательских элементов управления, такие как и [CheckBox.IsChecked](xref:System.Windows.Controls.Primitives.ToggleButton.IsChecked) по умолчанию для связывания. Программный способ определить, связывает ли свойство зависимости одностороннее или двустороннее по умолчанию, — получить метаданные свойств, <xref:System.Windows.DependencyProperty.GetMetadata%2A?displayProperty=nameWithType> а затем проверить значение <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A?displayProperty=nameWithType> свойства Boolean.

- <xref:System.Windows.Data.BindingMode.OneWayToSource>является обратным <xref:System.Windows.Data.BindingMode.OneWay> связывания; он обновляет свойство источника при изменении целевого свойства. Одним из примеров является, если вам нужно только пересмотреть исходное значение из uI.

- Не иллюстрированная <xref:System.Windows.Data.BindingMode.OneTime> на рисунке привязка, что приводит к тому, что свойство источника инициализирует целевое свойство, но не распространяет последующие изменения. Если контекст данных изменяется или объект в контексте данных изменяется, изменение *не* отражается в целевом свойстве. Этот тип привязки является целесообразным, если либо снимок текущего состояния является целесообразным или данные действительно статические. Этот тип привязки также является полезным, если нужно инициализировать целевое свойство с использованием какого-либо значения из исходного свойства, а контекст данных заранее неизвестен. Этот режим по существу <xref:System.Windows.Data.BindingMode.OneWay> является более простой формой связывания, которая обеспечивает лучшую производительность в тех случаях, когда исходное значение не меняется.

Для обнаружения изменений <xref:System.Windows.Data.BindingMode.OneWay> источника <xref:System.Windows.Data.BindingMode.TwoWay> (применимых к и привязки) <xref:System.ComponentModel.INotifyPropertyChanged>источник должен реализовать подходящий механизм уведомления об изменении свойства, такой как. Узнайте, [как: Внедрить уведомление об изменении свойств](../../framework/wpf/data/how-to-implement-property-change-notification.md) для примера <xref:System.ComponentModel.INotifyPropertyChanged> реализации.

Свойство <xref:System.Windows.Data.Binding.Mode?displayProperty=nameWithType> предоставляет более подробную информацию о режимах связывания и пример того, как указать направление привязки.

### <a name="what-triggers-source-updates"></a>Что вызывает обновления источников

Привязки, которые являются <xref:System.Windows.Data.BindingMode.TwoWay> или <xref:System.Windows.Data.BindingMode.OneWayToSource> слушают изменения в целевом свойстве и распространяют их обратно в источник, известный как обновление источника. Например, можно изменять текст элемента TextBox для изменения базового значение источника.

Тем не менее, ваше исходное значение обновляется во время редактирования текста или после завершения редактирования текста и элемент управления теряет фокус? Свойство <xref:System.Windows.Data.Binding.UpdateSourceTrigger?displayProperty=nameWithType> определяет, что вызывает обновление источника. Точки правых стрелок на следующем рисунке <xref:System.Windows.Data.Binding.UpdateSourceTrigger?displayProperty=nameWithType> иллюстрируют роль свойства.

![Диаграмма, отображая роль свойства UpdateSourceTrigger.](./media/data-binding-overview/data-binding-updatesource-trigger.png)

Если `UpdateSourceTrigger` значение, <xref:System.Windows.Data.UpdateSourceTrigger.PropertyChanged?displayProperty=nameWithType>то значение, на что указывает <xref:System.Windows.Data.BindingMode.TwoWay> правая стрелка или <xref:System.Windows.Data.BindingMode.OneWayToSource> привязки обновляется, как только целевое свойство изменяется. Однако, `UpdateSourceTrigger` если <xref:System.Windows.Data.UpdateSourceTrigger.LostFocus>значение , то это значение обновляется только с новым значением, когда целевое свойство теряет фокус.

Как и <xref:System.Windows.Data.Binding.Mode%2A> в свойстве, различные <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A> свойства зависимостей имеют различные значения по умолчанию. Значение по умолчанию для большинства свойств зависимостей — <xref:System.Windows.Data.UpdateSourceTrigger.PropertyChanged>, а свойство `TextBox.Text` имеет значение по умолчанию <xref:System.Windows.Data.UpdateSourceTrigger.LostFocus>. `PropertyChanged`означает, что обновления источников обычно происходят всякий раз, когда целевое свойство изменяется. Мгновенные изменения отлично подходят для CheckBoxes и других простых элементов управления. Однако для текстовых полей обновление после каждого нажатия клавиши может снизить производительность и лишает пользователя обычной возможности задней и исправить ошибки ввода текста перед совершением нового значения.

Ознакомьтесь со страницей <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A> свойств для получения информации о том, как найти значение свойства зависимости по умолчанию.

В следующей таблице приводится <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A> пример <xref:System.Windows.Controls.TextBox> сценария для каждого значения, используя в качестве примера.

| Значение UpdateSourceTrigger | Когда значение источника обновляется | Пример сценария для TextBox |
| ------------------------- | ---------------------------------- | ---------------------------- |
| `LostFocus`(по <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=nameWithType>умолчанию для) | Когда элемент textBox теряет фокус. | TextBox, связанный с логикой проверки [(см. Проверку данных](#data-validation) ниже). |
| `PropertyChanged` | Как вы вводите <xref:System.Windows.Controls.TextBox>в . | Управление TextBox в окне чата. |
| `Explicit` | Когда приложение <xref:System.Windows.Data.BindingExpression.UpdateSource%2A>звонит . | TextBox управляет в редактировании (обновляет значения источника только тогда, когда пользователь нажимает кнопку отправки). |

Например, [см. Как: Управление, когда текст TextBox обновляет источник.](../../framework/wpf/data/how-to-control-when-the-textbox-text-updates-the-source.md)

## <a name="creating-a-binding"></a>Создание связывания

Чтобы пересмотреть некоторые из понятий, рассмотренных в предыдущих разделах, вы устанавливаете привязку с использованием <xref:System.Windows.Data.Binding> объекта, и каждый привязка обычно имеет четыре компонента: обязательная цель, целевое свойство, связывающий источник и путь к исходному значению для использования. Этот раздел описывает установку привязки.

Рассмотрим следующий пример, в котором объектом источника привязки является класс с именем *MyData*, определенный в пространстве имен *SDKSample*. Для демонстрационных целей *MyData* имеет свойство строки под названием *ColorName,* значение которого установлено на "Красный". Таким образом, в этом примере создается кнопка с красным фоном.

[!code-xaml[BindNonTextProperty](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/AutoConvertPropertyToColor.xaml#BindAutoConvertColor)]

Для получения дополнительной [информации](../../framework/wpf/data/binding-declarations-overview.md)об обязательном синтаксисе декларации и примерах того, как настроить привязку в коде, см.

Если применить этот пример к основной диаграмме, полученное изображение будет выглядеть следующим образом. Эта цифра <xref:System.Windows.Data.BindingMode.OneWay> описывает привязку, <xref:System.Windows.Data.BindingMode.OneWay> поскольку свойство фонового фона поддерживает привязку по умолчанию.

![Диаграмма, понагревающая свойство фонового фона, связывающее данные.](./media/data-binding-overview/data-binding-button-background-example.png)

Вы можете задаться вопросом, почему эта привязка <xref:System.Windows.Controls.Control.Background%2A> работает, даже <xref:System.Windows.Media.Brush>если свойство *ColorName* имеет строку типа, в то время как свойство типа. В этом связующее дело используется конверсия типа по умолчанию, которая обсуждается в разделе [преобразования данных.](#data-conversion)

### <a name="specifying-the-binding-source"></a>Указание связывающего источника

Обратите внимание, что в предыдущем примере источник связывания указан путем установки свойства [DockPanel.DataContext.](xref:System.Windows.FrameworkElement.DataContext) Затем <xref:System.Windows.Controls.Button> наследует <xref:System.Windows.FrameworkElement.DataContext%2A> значение от <xref:System.Windows.Controls.DockPanel>, который является его родительским элементом. Повторим, что объект источника привязки является одним из четырех необходимых компонентов привязки. Таким образом, без указания объекта источника привязки эта привязка не имела бы смысла.

Есть несколько способов для указания объекта источника привязки. Использование <xref:System.Windows.FrameworkElement.DataContext%2A> свойства на родительском элементе полезно, когда вы привязываете несколько свойств к тому же источнику. Однако иногда удобнее указывать источник привязки в отдельных объявлениях привязки. В предыдущем примере вместо <xref:System.Windows.FrameworkElement.DataContext%2A> использования свойства можно указать связывающий источник, установив <xref:System.Windows.Data.Binding.Source%2A?displayProperty=nameWithType> свойство непосредственно на обязательной декларации кнопки, как в следующем примере.

[!code-xaml[BindNonTextPropertyCompactBinding](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/AutoConvertPropertyToColor.xaml#BindAutoConvertColorCompactBinding)]

Помимо <xref:System.Windows.FrameworkElement.DataContext%2A> установки свойства непосредственно на элементе, наследования <xref:System.Windows.FrameworkElement.DataContext%2A> значения от предка (например, кнопки в первом <xref:System.Windows.Data.Binding.Source%2A?displayProperty=nameWithType> примере) и явного указания связывающего источника, <xref:System.Windows.Data.Binding.ElementName?displayProperty=nameWithType> установив <xref:System.Windows.Data.Binding.RelativeSource?displayProperty=nameWithType> свойство на привязке (например, кнопка последнего примера), можно также использовать свойство или свойство для указания связывающего источника. Свойство <xref:System.Windows.Data.Binding.ElementName%2A> полезно, когда вы привязываетесь к другим элементам в приложении, например, когда вы используете ползунок для регулировки ширины кнопки. Свойство <xref:System.Windows.Data.Binding.RelativeSource%2A> полезно, когда привязка <xref:System.Windows.Controls.ControlTemplate> указана в <xref:System.Windows.Style>или . Для получения дополнительной [How to: Specify the binding source](../../framework/wpf/data/how-to-specify-the-binding-source.md)информации см.

### <a name="specifying-the-path-to-the-value"></a>Определение пути к значению

Если ваш связывающий источник <xref:System.Windows.Data.Binding.Path?displayProperty=nameWithType> является объектом, вы используете свойство, чтобы указать значение, чтобы использовать для привязки. Если вы привязываетесь к <xref:System.Windows.Data.Binding.XPath?displayProperty=nameWithType> данным XML, вы используете свойство для указания значения. В некоторых случаях может быть <xref:System.Windows.Data.Binding.Path%2A> применимо использование свойства даже в том случае, если ваши данные XML. Например, если вы хотите получить доступ к свойству имя возвращенного XmlNode (в результате <xref:System.Windows.Data.Binding.Path%2A> запроса XPath), вы должны использовать свойство в дополнение к свойству. <xref:System.Windows.Data.Binding.XPath%2A>

Для получения дополнительной <xref:System.Windows.Data.Binding.Path%2A> информации см. <xref:System.Windows.Data.Binding.XPath%2A>

Хотя мы подчеркивали, <xref:System.Windows.Data.Binding.Path%2A> что значение для использования является одним из четырех необходимых компонентов связывания, в сценариях, которые вы хотите привязать ко всему объекту, значение для использования будет таким же, как обязательный объект источника. В этих случаях применимо не <xref:System.Windows.Data.Binding.Path%2A>указывать . Рассмотрим следующий пример.

[!code-xaml[EmptyBinding](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/EmptyBinding.xaml#EmptyBinding)]

В приведенном выше примере используется синтаксис пустой привязки: {Binding}. В этом случае <xref:System.Windows.Controls.ListBox> DataContext наследуется из родительского элемента DockPanel (не показанного в этом примере). Если путь не указан, по умолчанию производится привязка ко всему объекту. Другими словами, в этом примере путь был исключен, потому что мы связываем <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> свойство со всем объектом. (См. раздел [«Связывание коллекций»](#binding-to-collections) для углубленного обсуждения.)

Кроме привязки к коллекции, этот сценарий полезен также для привязки ко всему объекту, а не только к одному свойству объекта. Например, если исходный объект <xref:System.String>имеет тип, вы можете просто привязаться к самой строке. Другим распространенным сценарием является необходимость привязки элемента к объекту с несколькими свойствами.

Возможно, потребуется применить пользовательскую логику, чтобы данные были значимыми для вашего целевого свойства. Пользовательская логика может быть в виде пользовательского конвертера, если преобразования типа по умолчанию не существует. Просмотрите [конверсию данных](#data-conversion) для получения информации о преобразователях.

### <a name="binding-and-bindingexpression"></a>Привязка и класс BindingExpression

Прежде чем перейти к другим функциям и использованию <xref:System.Windows.Data.BindingExpression> связывания данных, полезно ввести класс. Как вы видели в предыдущих разделах, <xref:System.Windows.Data.Binding> класс является классом высокого уровня для объявления привязки; он содержит множество свойств, которые позволяют указать характеристики связывания. Связанный класс, <xref:System.Windows.Data.BindingExpression>— это основной объект, поддерживающий связь между источником и целью. Привязка содержит всю информацию, которая может использоваться совместно в нескольких выражениях привязки. A <xref:System.Windows.Data.BindingExpression> — это выражение экземпляра, которым нельзя <xref:System.Windows.Data.Binding>поделиться и содержит всю информацию о экземпляре .

Рассмотрим следующий `myDataObject` пример, где `MyData` экземпляр `myBinding` класса, <xref:System.Windows.Data.Binding> является исходным объектом и `MyData` является определенным `MyDataProperty`классом, содержащим свойство строки, названное Этот пример связывает содержание `myText`текста, <xref:System.Windows.Controls.TextBlock>экземпляр, `MyDataProperty`к .

[!code-csharp[CodeOnlyBinding](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/ManualBinding.cs#CodeOnlyBinding)]
[!code-vb[CodeOnlyBinding](~/samples/snippets/desktop-guide/wpf/data-binding-overview/vb/ManualBinding.vb#CodeOnlyBinding)]

Один и тот же объект *myBinding* можно использовать для создания других привязок. Например, вы можете использовать объект *myBinding* для привязки текстового содержимого флажка к *MyDataProperty.* В этом сценарии будет два <xref:System.Windows.Data.BindingExpression> экземпляра совместного использования объекта *myBinding.*

Объект <xref:System.Windows.Data.BindingExpression> возвращается, <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A> вызывая объект, связанный с данными. Следующие статьи демонстрируют некоторые из <xref:System.Windows.Data.BindingExpression> обычаев класса:

- [Получение объекта привязки из свойства целевого объекта привязки](../../framework/wpf/data/how-to-get-the-binding-object-from-a-bound-target-property.md)

- [Управление Когда текст TextBox обновляет источник](../../framework/wpf/data/how-to-control-when-the-textbox-text-updates-the-source.md)

## <a name="data-conversion"></a>Преобразование данных

В [разделе «Создание связывания»](#creating-a-binding) кнопка красная, поскольку ее <xref:System.Windows.Controls.Control.Background%2A> свойство привязано к свойству строки со значением «Красный». Это значение строки работает, потому <xref:System.Windows.Media.Brush> что преобразователь <xref:System.Windows.Media.Brush>типа присутствует на типе для преобразования значения строки в .

Добавление этой информации к рисунку в разделе [«Создание связывающей](#creating-a-binding) части» выглядит следующим образом.

![Диаграмма, повезрающая свойство, связывающее данные по умолчанию.](./media/data-binding-overview/data-binding-button-default-conversion.png)

Однако, что делать, если вместо того, чтобы свойство строки типа связывания исходного объекта имеет *свойство цвета* типа? <xref:System.Windows.Media.Color> В этом случае для того, чтобы привязка работала, вам нужно <xref:System.Windows.Controls.Control.Background%2A> сначала превратить значение свойства *цвета* в то, что принимает свойство. Необходимо создать пользовательский конвертер путем <xref:System.Windows.Data.IValueConverter> реализации интерфейса, как в следующем примере.

[!code-csharp[CodeOnlyBinding](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/ColorBrushConverter.cs#ColorBrushConverter)]
[!code-vb[CodeOnlyBinding](~/samples/snippets/desktop-guide/wpf/data-binding-overview/vb/ColorBrushConverter.vb#ColorBrushConverter)]

Подробнее см. в разделе <xref:System.Windows.Data.IValueConverter>.

Теперь вместо преобразования по умолчанию используется пользовательский конвертер, и наша диаграмма выглядит следующим образом.

![Диаграмма, покажающая пользовательский конвертер, связывающий данные.](./media/data-binding-overview/data-binding-converter-color-example.png)

Таким образом, преобразования по умолчанию могут быть доступны благодаря преобразователям типов, присутствующим в типе, к которому производится привязка. Такое поведение будет зависеть от того, какие преобразователи типов доступны в целевом объекте. Если существуют какие-то сомнением, создайте свой собственный преобразователь.

Ниже приведены некоторые типичные сценарии, в которых имеет смысл реализовать преобразователь данных:

- Данные должны отображаться по-разному в зависимости от региональных стандартов. Например, можно реализовать конвертер валюты или конвертер даты/времени календаря на основе конвенций, используемых в определенной культуре.

- Используемые данные не обязательно предназначены для изменения текстового значения свойства, а предназначены для изменения некоторых других значений, например источника изображения, цвета или стиля отображаемого текста. Преобразователи могут использоваться в данном экземпляре для преобразования привязки неподходящего свойства, например привязки текстового поля к свойству Background ячейки таблицы.

- К одним и тем же данным привязано несколько элементов управления или несколько свойств элементов управления. В этом случае основная привязка может просто отображать текст, тогда как другие привязки обрабатывают специфичные проблемы отображения, но они по-прежнему используют одну и ту же привязку в качестве исходных данных.

- Целевое свойство имеет набор привязок, <xref:System.Windows.Data.MultiBinding>который называется . Для <xref:System.Windows.Data.MultiBinding>этого используется <xref:System.Windows.Data.IMultiValueConverter> обычай для получения конечного значения из значений привязок. Например, цвет может быть вычислен из соотношения красного, синего и зеленого значений, которые могут быть значениями одних и тех же или разных объектов источника привязки. Смотрите <xref:System.Windows.Data.MultiBinding> примеры и информацию.

## <a name="binding-to-collections"></a>Привязка к коллекциям

Обязательный объект источника может рассматриваться как один объект, свойства которого содержат данные, либо как сбор данных полиморфных объектов, которые часто сгруппированы вместе (например, как результат запроса в базу данных). До сих пор мы обсуждали только привязку к отдельным объектам. Однако привязка к сбору данных является распространенным сценарием. Например, общим сценарием является <xref:System.Windows.Controls.ItemsControl> использование <xref:System.Windows.Controls.ListBox>такого сценария, как , <xref:System.Windows.Controls.ListView>или <xref:System.Windows.Controls.TreeView> отображение сбора данных, например, в приложении, показанном в разделе [Привязка данных.](#what-is-data-binding)

К счастью, наша основная схема по-прежнему применима. Если вы привязываете <xref:System.Windows.Controls.ItemsControl> к коллекции, диаграмма выглядит следующим образом.

![Диаграмма, повезрающая объект, связывающий данные, объект ItemsControl.](./media/data-binding-overview/data-binding-itemscontrol.png)

Как показано на этой диаграмме, чтобы привязать <xref:System.Windows.Controls.ItemsControl> к объекту сбора, <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A?displayProperty=nameWithType> свойство является свойством для использования. Вы можете `ItemsSource` думать, как <xref:System.Windows.Controls.ItemsControl>содержание . Привязка <xref:System.Windows.Data.BindingMode.OneWay> происходит `ItemsSource` потому, что свойство поддерживает `OneWay` связывание по умолчанию.

### <a name="how-to-implement-collections"></a>Как реализовать коллекции

Вы можете перечислить любую коллекцию, <xref:System.Collections.IEnumerable> которая реализует интерфейс. Однако для настройки динамических привязок таким образом, чтобы вставки или удаления <xref:System.Collections.Specialized.INotifyCollectionChanged> в коллекции обновляли интерфейс автоматически, коллекция должна реализовать интерфейс. Этот интерфейс предоставляет событие, которое должно вызываться при каждом изменении коллекции.

WPF предоставляет <xref:System.Collections.ObjectModel.ObservableCollection%601> класс, который представляет собой встроенную реализацию сбора <xref:System.Collections.Specialized.INotifyCollectionChanged> данных, которая предоставляет интерфейс. Чтобы полностью поддерживать передачу значений данных от исходных объектов к целям, <xref:System.ComponentModel.INotifyPropertyChanged> каждый объект в вашей коллекции, поддерживающий связываемые свойства, должен также реализовать интерфейс. Для получения дополнительной информации смотрите [обзор связывающих источников](../../framework/wpf/data/binding-sources-overview.md).

Прежде чем реализовать свою собственную коллекцию, рассмотрите <xref:System.Collections.ObjectModel.ObservableCollection%601> возможность <xref:System.Collections.Generic.List%601> <xref:System.Collections.ObjectModel.Collection%601>использования <xref:System.ComponentModel.BindingList%601>или одного из существующих классов коллекции, таких как, и, среди многих других. Если у вас есть расширенный сценарий и <xref:System.Collections.IList>вы хотите реализовать свою собственную коллекцию, рассмотрите возможность использования, который обеспечивает необщий сбор объектов, которые могут быть индивидуально доступны индексом, и, таким образом, обеспечивает наилучшую производительность.

### <a name="collection-views"></a>Представления коллекции

Как <xref:System.Windows.Controls.ItemsControl> только ваш связан с сбором данных, вы можете сортировать, фильтровать или группировать данные. Для этого используются представления коллекции, которые <xref:System.ComponentModel.ICollectionView> являются классами, которые реализуют интерфейс.

#### <a name="what-are-collection-views"></a>Что такое представления коллекции?

Представление коллекции — это слой, расположенный в верхней части связанной исходной коллекции, с помощью которого можно перемещаться по исходной коллекции и просматривать ее содержимое на основе запросов сортировки, фильтрации и группировки, не изменяя саму коллекцию. В представлении коллекции также поддерживается указатель на текущий элемент коллекции. Если сбор исходных <xref:System.Collections.Specialized.INotifyCollectionChanged> источников реализует интерфейс, <xref:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged> изменения, поднятые событием, распространяются на представления.

Так как представления не меняют базовые исходные коллекции, каждая исходная коллекция может иметь несколько связанных с ней представлений. Например, имеется коллекция объектов *Task*. С помощью представлений можно отображать одни и те же данные различными способами. Например, в левой части страницы можно отображать задачи, отсортированные по приоритету, а справа — сгруппированные по областям.

#### <a name="how-to-create-a-view"></a>Создание представления

Одним из способов создания и использования представления является непосредственное создание объекта представления и затем использование его в качестве источника привязки. Например, рассмотрим [демо-приложение, передающееся привязке данных,][data-binding-demo] в разделе [«Что является связывающей данными».](#what-is-data-binding) Приложение реализовано таким <xref:System.Windows.Controls.ListBox> образом, что привязывается к представлению по сбору данных, а не непосредственно к сбору данных. Следующий пример извлекается из [демо-приложения связывания данных.][data-binding-demo] Класс <xref:System.Windows.Data.CollectionViewSource> является прокси XAML класса, который <xref:System.Windows.Data.CollectionView>наследует от . В данном конкретном <xref:System.Windows.Data.CollectionViewSource.Source%2A> примере представление привязано к коллекции <xref:System.Collections.ObjectModel.ObservableCollection%601> *AuctionItems* (типа) текущего объекта приложения.

[!code-xaml[CollectionView](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/CollectionView.xaml#CollectionView)]

Затем *список ресурсовDataView* служит связующим источником для элементов в приложении, таких как <xref:System.Windows.Controls.ListBox>.

[!code-xaml[ListBoxCollectionView](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/CollectionView.xaml#ListBoxCollectionView)]

Чтобы создать другое представление для той <xref:System.Windows.Data.CollectionViewSource> же коллекции, `x:Key` можно создать другой экземпляр и дать ему другое имя.

В следующей таблице показано, какие типы данных <xref:System.Windows.Data.CollectionViewSource> представления создаются как представление собрания по умолчанию или на основе типа сбора исходных данных.

| Тип исходной коллекции                    | Тип представления коллекции | Примечания |
| ----------------------------------------- | -------------------- | ----- |
| <xref:System.Collections.IEnumerable>     | Внутренний тип, основанный на<xref:System.Windows.Data.CollectionView> | Невозможно группировать элементы. |
| <xref:System.Collections.IList>           | <xref:System.Windows.Data.ListCollectionView> | Самый быстрый. |
| <xref:System.ComponentModel.IBindingList> | <xref:System.Windows.Data.BindingListCollectionView> | |

#### <a name="using-a-default-view"></a>Использование представления по умолчанию

Один из способов создания и использования представления коллекции заключается в указании представления коллекции в качестве источника привязки. WPF также создает представление коллекции по умолчанию для каждой коллекции, используемой в качестве источника привязки. Если выполнить привязку непосредственно к коллекции, WPF выполняет привязку к представлению коллекции по умолчанию. Это представление по умолчанию совместно во всех привязки к той же коллекции, так что изменение, внесенное в представление по умолчанию одним связанным элементом или кодом (например, сортировка или изменение указателя текущего элемента, обсуждаемого позже), отражено во всех других привязки к той же коллекции.

Чтобы получить представление по умолчанию, вы используете <xref:System.Windows.Data.CollectionViewSource.GetDefaultView%2A> метод. Например, [см. Получить представление по умолчанию в сборе данных.](../../framework/wpf/data/how-to-get-the-default-view-of-a-data-collection.md)

#### <a name="collection-views-with-adonet-datatables"></a>Представления коллекции с ADO.NET DataTables

Для повышения производительности представления <xref:System.Data.DataTable> <xref:System.Data.DataView> коллекции для ADO.NET или <xref:System.Data.DataView>объектов делегируют сортировку и фильтрацию в раздел, что приводит к совместному сортировке и фильтрации во всех представлениях о сборе источников данных. Чтобы каждый вид коллекции сортировать и фильтровать независимо, инициализировать каждый вид коллекции со своим собственным <xref:System.Data.DataView> объектом.

#### <a name="sorting"></a>Сортировка

Как уже отмечалось ранее, представления могут применять сортировку для коллекции. Так как данные находятся в базовой коллекции, они могут иметь или не иметь некий порядок следования. Представление коллекции позволяет установить порядок или изменить порядок, используемый по умолчанию, на основе введенных признаков сравнения. Так как это представление данных на стороне клиента, распространенным скриптом является сортировка пользователем столбцов табличных данных по значениям, содержащимся в столбце. С использованием представлений управляемая пользователем сортировка может применяться еще раз без необходимости внесения изменений в основную коллекцию или создания повторного запроса к содержимому коллекции. Например, [см. колонку GridView при нажатии заголовка.](../../framework/wpf/controls/how-to-sort-a-gridview-column-when-a-header-is-clicked.md)

В следующем примере показана логика сортировки <xref:System.Windows.Controls.CheckBox> раздела "Сортировать по категориям и дате" uI приложения в разделе [Что такое связывание данных.](#what-is-data-binding)

[!code-csharp[AddSortChecked](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/CollectionView.xaml.cs#AddSortChecked)]
[!code-vb[AddSortChecked](~/samples/snippets/desktop-guide/wpf/data-binding-overview/vb/CollectionView.xaml.vb#AddSortChecked)]

#### <a name="filtering"></a>Фильтрация

Представления также могут применять фильтр к коллекции, так что представление показывает только определенное подмножество полной коллекции. Возможна фильтрация по условию в данных. Например, как это делается приложением в разделе [Что является связыванием данных,](#what-is-data-binding) "Показать только сделки" <xref:System.Windows.Controls.CheckBox> содержит логику, чтобы отфильтровать элементы, которые стоят $ 25 или больше. Следующий код выполняется для установки *ShowOnlyBargainsFilter* <xref:System.Windows.Data.CollectionViewSource.Filter> <xref:System.Windows.Controls.CheckBox> в качестве обработчика событий при выборе.

[!code-csharp[ListingViewFilter](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/CollectionView.xaml.cs#ListingViewFilter)]
[!code-vb[ListingViewFilter](~/samples/snippets/desktop-guide/wpf/data-binding-overview/vb/CollectionView.xaml.vb#ListingViewFilter)]

Обработчик событий *ShowOnlyBargainsFilter* имеет следующую реализацию.

[!code-csharp[FilterEvent](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/CollectionView.xaml.cs#FilterEvent)]
[!code-vb[FilterEvent](~/samples/snippets/desktop-guide/wpf/data-binding-overview/vb/CollectionView.xaml.vb#FilterEvent)]

Если вы используете <xref:System.Windows.Data.CollectionView> один из <xref:System.Windows.Data.CollectionViewSource>классов непосредственно вместо, вы будете использовать <xref:System.Windows.Data.CollectionView.Filter%2A> свойство, чтобы указать обратный вызов. Пример см. в разделе [Практическое руководство. Фильтрация данных в представлении](../../framework/wpf/data/how-to-filter-data-in-a-view.md).

#### <a name="grouping"></a>Группирование

За исключением внутреннего класса, который просматривает коллекцию, <xref:System.Collections.IEnumerable> все представления коллекции группируют *группу*поддержки, что позволяет пользователю разделить коллекцию в представлении коллекции на логические группы. Группы могут быть явными, если пользователь предоставляет список групп, или неявными, если эти группы создаются динамически в зависимости от данных.

Следующий пример показывает логику "Группа <xref:System.Windows.Controls.CheckBox>по категориям".

[!code-csharp[ListingGroupCheck](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/CollectionView.xaml.cs#ListingGroupCheck)]
[!code-vb[ListingGroupCheck](~/samples/snippets/desktop-guide/wpf/data-binding-overview/vb/CollectionView.xaml.vb#ListingGroupCheck)]

Другой пример группировки см. в разделе [Практическое руководство. Группировка элементов в объекте ListView, реализующем GridView](../../framework/wpf/controls/how-to-group-items-in-a-listview-that-implements-a-gridview.md).

#### <a name="current-item-pointers"></a>Текущие указатели элементов

В представлениях также присутствует понятие текущего элемента. Существует возможность перемещаться по объектам в представлении коллекции. При переходе перемещается указатель элемента, позволяющий извлечь объект, расположенный в определенном месте в коллекции. Например, [см. Навигацию по объектам в данных CollectionView.](../../framework/wpf/data/how-to-navigate-through-the-objects-in-a-data-collectionview.md)

Поскольку WPF выполняет привязку к коллекции только с помощью представления (либо указанного пользователем, либо представления коллекции по умолчанию), для всех привязок к коллекциям имеется указатель на текущий элемент. При привязке к представлению символ косой черты ("/") в значении `Path` указывает на текущий элемент представления. В следующем примере контекст данных является представлением коллекции. В первой строке выполняется привязка к коллекции. Во второй строке выполняется привязка к текущему элементу коллекции. В третьей строке выполняется привязка к свойству `Description` текущего элемента коллекции.

```xaml
<Button Content="{Binding }" />
<Button Content="{Binding Path=/}" />
<Button Content="{Binding Path=/Description}" />
```

Косую черту и синтаксис свойства также можно комбинировать для обработки иерархии коллекций. В приведенном ниже примере выполняется привязка к текущему элементу коллекции `Offices`, который является свойством текущего элемента исходной коллекции.

```xaml
<Button Content="{Binding /Offices/}" />
```

На указатель текущего элемента влияют примененные к коллекции операции сортировки и фильтрации. При сортировке указатель текущего элемента устанавливается на последний выбранный элемент, однако представление коллекции перестраивается относительно его. (Возможно, выбранный элемент был в начале списка раньше, но теперь выбранный элемент может быть где-то посередине.) Фильтрация сохраняет выбранный элемент, если этот выбор остается в поле зрения после фильтрации. В противном случае указатель текущего элемента устанавливается на первый элемент отфильтрованного представления коллекции.

#### <a name="master-detail-binding-scenario"></a>Сценарий связывания мастер-детали

Понятие текущего элемента применимо не только для перемещения элементов в коллекции, но также для сценария привязки "основной — подробности". Рассмотрим uI-иного итога приложения в разделе [«Что такое привязка данных».](#what-is-data-binding) В этом приложении выбор <xref:System.Windows.Controls.ListBox> в пределах определения <xref:System.Windows.Controls.ContentControl>содержимого, отображаемого в . Другими словами, при <xref:System.Windows.Controls.ListBox> выборе элемента <xref:System.Windows.Controls.ContentControl> отображается детали выбранного элемента.

Для реализации этого сценария необходимо наличие двух или более элементов управления, привязанных к одному и тому же представлению. В следующем примере из [демо-связывания данных][data-binding-demo] показана разметка <xref:System.Windows.Controls.ListBox> и <xref:System.Windows.Controls.ContentControl> отображается на uI приложения в разделе Что [такое привязка данных.](#what-is-data-binding)

[!code-xaml[ListBoxContentControl](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/CollectionView.xaml#ListBoxContentControl)]

Обратите внимание, что оба элемента управления связаны с тем же источником, статическим ресурсом *listingDataView* (см. определение этого ресурса в [разделе «Как создать раздел представления»).](#how-to-create-a-view) Эта привязка работает, потому <xref:System.Windows.Controls.ContentControl> что, когда объект синглтона (в данном <xref:System.Windows.Data.CollectionView.CurrentItem%2A> случае) связан с представлением коллекции, он автоматически привязывается к представлению. Объекты <xref:System.Windows.Data.CollectionViewSource> автоматически синхронизируют валюту и выбор. Если элемент управления списка не <xref:System.Windows.Data.CollectionViewSource> привязан к объекту, как в <xref:System.Windows.Controls.Primitives.Selector.IsSynchronizedWithCurrentItem%2A> этом `true` примере, то для этого необходимо установить его свойство.

В других примерах [см. Bind to the collection и отображаем информацию, основанную на выборе,](../../framework/wpf/data/how-to-bind-to-a-collection-and-display-information-based-on-selection.md) и [используйте шаблон master-detail с иерархическими данными.](../../framework/wpf/data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md)

Можно заметить, что в приведенном выше примере используется шаблон. В самом деле, данные не будут отображаться так, как мы хотим без <xref:System.Windows.Controls.ContentControl> использования шаблонов (один <xref:System.Windows.Controls.ListBox>явно используется и один косвенно используется ). К шаблонам данных мы перейдем в следующем разделе.

## <a name="data-templating"></a>Шаблоны данных

Без использования шаблонов данных наш uI-единомышлений приложений в разделе [«Что такое привязка данных»](#what-is-data-binding) будет выглядеть следующим образом.

![Демонстрация привязки данных без шаблонов данных](./media/data-binding-overview/demo-no-template.png)

Как показано в примере в предыдущем <xref:System.Windows.Controls.ListBox> разделе, <xref:System.Windows.Controls.ContentControl> как элемент управления, так и связанные со всем объектом коллекции (или, более конкретно, видом на объект коллекции) *аукционного*пункта s. Без конкретных инструкций по отображению сбора данных отображается репрезентативное представление каждого объекта в базовой коллекции, а также <xref:System.Windows.Controls.ListBox> <xref:System.Windows.Controls.ContentControl> отображаетренное представление строки объекта, к который он обязан.

Чтобы решить эту проблему, <xref:System.Windows.DataTemplate?text=DataTemplates>приложение определяет . Как показано в примере в <xref:System.Windows.Controls.ContentControl> предыдущем разделе, явно использует шаблон *данных ProductListingTemplate.* Элемент <xref:System.Windows.Controls.ListBox> управления неявно использует следующий шаблон данных при отображении объектов *AuctionItem* в коллекции.

[!code-xaml[AuctionItemDataTemplate](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/CollectionView.xaml#AuctionItemDataTemplate)]

С помощью этих двух DataTemplates полученный доступ к единому доступу отображается в разделе [Связывание данных.](#what-is-data-binding) Как вы можете видеть на этом скриншоте, в дополнение к тому, чтобы позволить вам размещать данные в элементах управления, DataTemplates позволяют определить убедительные визуальные эффекты для ваших данных. Например, <xref:System.Windows.DataTrigger>s используются <xref:System.Windows.DataTemplate> в вышеуказанном так, что *AuctionItem*s с *SpecialFeatures* значение *HighLight* будет отображаться с оранжевой границей и звездой.

Для получения дополнительной информации о [Data templating overview](../../framework/wpf/data/data-templating-overview.md)шаблонах данных см.

## <a name="data-validation"></a>Проверка данных

Большинство приложений, которые принимают пользовательский вход, должны иметь логику проверки, чтобы убедиться, что пользователь ввел ожидаемую информацию. Проверки проверки могут быть основаны на типе, диапазоне, формате или других требованиях к приложениям. В этом разделе рассматриваются способы проверки данных в WPF.

### <a name="associating-validation-rules-with-a-binding"></a>Связывание правил проверки с привязкой

Модель связывания данных WPF позволяет ассоциироваться <xref:System.Windows.Data.Binding.ValidationRules%2A> с объектом. <xref:System.Windows.Data.Binding> Например, следующий пример <xref:System.Windows.Controls.TextBox> связывает свойство `StartPrice` с <xref:System.Windows.Controls.ExceptionValidationRule> именем <xref:System.Windows.Data.Binding.ValidationRules%2A?displayProperty=nameWithType> и добавляет объект в свойство.

[!code-xaml[TextboxStartPrice](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/DataValidation.xaml#TextboxStartPrice)]

Объект <xref:System.Windows.Controls.ValidationRule> проверяет, является ли значение свойства действительным. WPF имеет два типа <xref:System.Windows.Controls.ValidationRule> встроенных объектов:

- Проверка <xref:System.Windows.Controls.ExceptionValidationRule> исключений, брошенных при обновлении свойства связывающего источника. В предыдущем примере `StartPrice` имеет тип integer. Когда пользователь вводит значение, которое невозможно преобразовать в целое число, создается исключение, приводящее к тому, что привязка будет помечена как недопустимая. Альтернативный синтаксис <xref:System.Windows.Controls.ExceptionValidationRule> для настройки явно <xref:System.Windows.Data.Binding.ValidatesOnExceptions%2A> госустановка заключается в настройке свойства `true` на объекте <xref:System.Windows.Data.Binding> или <xref:System.Windows.Data.MultiBinding> объекте.

- Объект <xref:System.Windows.Controls.DataErrorValidationRule> проверяет ошибки, поднятые объектами, реализуемыми в интерфейсе. <xref:System.ComponentModel.IDataErrorInfo> Например, при использовании этого <xref:System.Windows.Controls.DataErrorValidationRule>правила проверки см. Альтернативный синтаксис <xref:System.Windows.Controls.DataErrorValidationRule> для настройки явно <xref:System.Windows.Data.Binding.ValidatesOnDataErrors%2A> госустановка заключается в настройке свойства `true` на объекте <xref:System.Windows.Data.Binding> или <xref:System.Windows.Data.MultiBinding> объекте.

Вы также можете создать свое собственное правило <xref:System.Windows.Controls.ValidationRule> проверки, выдвивая из класса и реализуя <xref:System.Windows.Controls.ValidationRule.Validate%2A> метод. В следующем примере показано правило, используемое в <xref:System.Windows.Controls.TextBox> *списке добавленных продуктов* "Дата начала" из раздела ["Что такое связывание данных".](#what-is-data-binding)

[!code-csharp[FutureDateRule](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/FutureDateRule.cs#FutureDateRule)]
[!code-vb[FutureDateRule](~/samples/snippets/desktop-guide/wpf/data-binding-overview/vb/FutureDateRule.vb#FutureDateRule)]

*StartDateEntryForm* <xref:System.Windows.Controls.TextBox> использует это *FutureDateRule*, как показано в следующем примере.

[!code-xaml[TextboxStartDate](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/DataValidation.xaml#TextboxStartDate)]

Поскольку <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A> значение <xref:System.Windows.Data.UpdateSourceTrigger.PropertyChanged>является, связывающий двигатель обновляет исходное значение на каждом <xref:System.Windows.Data.Binding.ValidationRules%2A> нажатии клавиши, что означает, что он также проверяет каждое правило в коллекции на каждом нажатии клавиши. Это будет обсуждаться далее в разделе "Процесс проверки".

### <a name="providing-visual-feedback"></a>Обеспечение визуальной обратной связи

Если пользователь вводит недействительное значение, вы можете предоставить некоторую обратную связь об ошибке в пользовательском интерфейсе приложения. Один из способов обеспечить <xref:System.Windows.Controls.Validation.ErrorTemplate%2A?displayProperty=nameWithType> такую обратную связь <xref:System.Windows.Controls.ControlTemplate>заключается в том, чтобы установить прилагаемое свойство к обычаю . Как показано в предыдущем подразделе, *StartDateEntryForm* <xref:System.Windows.Controls.TextBox> использует так называемый <xref:System.Windows.Controls.Validation.ErrorTemplate%2A> *валидационный шаблон.* В следующем примере показано определение *проверкиTemplate*.

[!code-xaml[ControlTemplate](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/DataValidation.xaml#ControlTemplate)]

Элемент <xref:System.Windows.Controls.AdornedElementPlaceholder> определяет, где должен быть размещен элемент управления, который украшается.

Кроме того, вы также <xref:System.Windows.Controls.ToolTip> можете использовать сообщение об ошибке. Как *StartDateEntryForm,* так и *StartPriceEntryForm*<xref:System.Windows.Controls.TextBox>es используют стиль *textTextTextBox*, который создает <xref:System.Windows.Controls.ToolTip> сообщение об ошибке. В следующем примере показано определение элемента *textStyleTextBox*. Прилагаемое <xref:System.Windows.Controls.Validation.HasError%2A?displayProperty=nameWithType> `true` свойство — это когда одна или несколько привязок к свойствам связанного элемента находятся в ошибке.

[!code-xaml[TextBoxStyle](~/samples/snippets/desktop-guide/wpf/data-binding-overview/csharp/DataValidation.xaml#TextBoxStyle)]

С обычаем <xref:System.Windows.Controls.Validation.ErrorTemplate%2A> <xref:System.Windows.Controls.ToolTip>и, *StartDateEntryForm* <xref:System.Windows.Controls.TextBox> выглядит следующим, когда есть ошибка проверки.

![Ошибка проверки привязки данных](./media/data-binding-overview/demo-validation-date.png "DataBindingDemo_Validation")

Если <xref:System.Windows.Data.Binding> у вас есть связанные правила <xref:System.Windows.Controls.Validation.ErrorTemplate%2A> проверки, но вы <xref:System.Windows.Controls.Validation.ErrorTemplate%2A> не указываете на связанном элементе управления, по умолчанию будет использоваться для уведомления пользователей при наличии ошибки проверки. По <xref:System.Windows.Controls.Validation.ErrorTemplate%2A> умолчанию шаблон управления определяет красную границу в слое украшения. При выполнении <xref:System.Windows.Controls.Validation.ErrorTemplate%2A> <xref:System.Windows.Controls.ToolTip>по умолчанию и единообразного варианта использования и информации о доступе к доступу *StartPriceEntryForm* <xref:System.Windows.Controls.TextBox> выглядит следующим образом при наличии ошибки проверки.

![Ошибка проверки привязки данных](./media/data-binding-overview/demo-validation-price.png "DataBindingDemo_ValidationDefault")

Например, как предоставить логику для проверки всех элементов управления в диалоговом поле, см. [Dialog boxes overview](../../framework/wpf/app-development/dialog-boxes-overview.md)

### <a name="validation-process"></a>Процесс проверки

Проверка обычно выполняется, когда целевое значение передается свойству источника привязки. Эта передача <xref:System.Windows.Data.BindingMode.TwoWay> происходит <xref:System.Windows.Data.BindingMode.OneWayToSource> и привязки. Повторяю, что вызывает обновление источника, зависит <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A> от значения свойства, как описано в разделе [Что вызывает обновления источника.](#what-triggers-source-updates)

Следующие элементы описывают процесс *проверки.* Если ошибка проверки или другой тип ошибки происходит в любое время в течение этого процесса, процесс приостанавливается:

1. Связывающий двигатель проверяет, <xref:System.Windows.Controls.ValidationRule> есть <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> ли какие-либо пользовательские объекты, определенные, <xref:System.Windows.Controls.ValidationStep.RawProposedValue> которые установлены для этого, <xref:System.Windows.Data.Binding>и в этом случае он вызывает <xref:System.Windows.Controls.ValidationRule.Validate%2A> метод на каждом, <xref:System.Windows.Controls.ValidationRule> пока один из них не работает в ошибку или до тех пор, пока все из них проходят.

2. Обработчик привязки вызывает преобразователь, если таковой существует.

3. Если преобразователь успешно, связывающий <xref:System.Windows.Controls.ValidationRule> двигатель проверяет, есть ли <xref:System.Windows.Data.Binding>какие-либо пользовательские <xref:System.Windows.Controls.ValidationRule.Validate%2A> объекты, определенные, которые <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> установлены <xref:System.Windows.Controls.ValidationStep.ConvertedProposedValue> для этого, и в этом случае он вызывает метод на каждом, <xref:System.Windows.Controls.ValidationRule> который установил <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> до <xref:System.Windows.Controls.ValidationStep.ConvertedProposedValue> тех пор, пока один из них не натыкается на ошибку или пока все они не проходят.

4. Обработчик привязки присваивает значение исходному свойству.

5. Связывающий двигатель проверяет, <xref:System.Windows.Controls.ValidationRule> есть <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> ли какие-либо <xref:System.Windows.Data.Binding>пользовательские объекты, <xref:System.Windows.Controls.ValidationRule.Validate%2A> определенные, которые установлены <xref:System.Windows.Controls.ValidationStep.UpdatedValue> для этого, и в этом случае он вызывает метод на каждом, <xref:System.Windows.Controls.ValidationRule> который установил <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> до <xref:System.Windows.Controls.ValidationStep.UpdatedValue> тех пор, пока один из них работает в ошибку или до тех пор, пока все из них проходят. Если <xref:System.Windows.Controls.DataErrorValidationRule> а.е. связан <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> с привязкой <xref:System.Windows.Controls.ValidationStep.UpdatedValue>и <xref:System.Windows.Controls.DataErrorValidationRule> настроен по умолчанию, то проверка проверяется в этой точке. На данный момент проверяется любой привязка, на которую <xref:System.Windows.Data.Binding.ValidatesOnDataErrors%2A> имеется `true` набор.

6. Связывающий двигатель проверяет, <xref:System.Windows.Controls.ValidationRule> есть <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> ли какие-либо <xref:System.Windows.Data.Binding>пользовательские объекты, <xref:System.Windows.Controls.ValidationRule.Validate%2A> определенные, которые установлены <xref:System.Windows.Controls.ValidationStep.CommittedValue> для этого, и в этом случае он вызывает метод на каждом, <xref:System.Windows.Controls.ValidationRule> который установил <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> до <xref:System.Windows.Controls.ValidationStep.CommittedValue> тех пор, пока один из них работает в ошибку или до тех пор, пока все из них проходят.

Если <xref:System.Windows.Controls.ValidationRule> номер не проходит в любое время на протяжении всего процесса, связывающий двигатель создает <xref:System.Windows.Controls.ValidationError> объект и добавляет его в <xref:System.Windows.Controls.Validation.Errors%2A?displayProperty=nameWithType> сбор связанного элемента. Перед тем, как <xref:System.Windows.Controls.ValidationRule> связывающий двигатель запускает <xref:System.Windows.Controls.ValidationError> объекты на <xref:System.Windows.Controls.Validation.Errors%2A?displayProperty=nameWithType> любом этапе, он удаляет все, что было добавлено в прикрепленное свойство связанного элемента во время этого шага. Например, если <xref:System.Windows.Controls.ValidationRule> <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> действие <xref:System.Windows.Controls.ValidationStep.UpdatedValue> которого не удавилось, при следующем моменте <xref:System.Windows.Controls.ValidationError> процесса проверки <xref:System.Windows.Controls.ValidationRule> привязывающий движок удаляет его непосредственно перед вызовом. <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> <xref:System.Windows.Controls.ValidationStep.UpdatedValue>

Когда <xref:System.Windows.Controls.Validation.Errors%2A?displayProperty=nameWithType> не пусто, <xref:System.Windows.Controls.Validation.HasError%2A?displayProperty=nameWithType> прилагаемое свойство `true`элемента устанавливается в. Кроме того, <xref:System.Windows.Data.Binding.NotifyOnValidationError%2A> если <xref:System.Windows.Data.Binding> свойство `true`установлено, то связывающий двигатель поднимает <xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType> прикрепленное событие на элементе.

Также обратите внимание, что допустимая передача стоимости в любом направлении (цель к источнику или источнику цели) очищает <xref:System.Windows.Controls.Validation.Errors%2A?displayProperty=nameWithType> прикрепленное свойство.

Если привязка <xref:System.Windows.Controls.ExceptionValidationRule> либо связана с <xref:System.Windows.Data.Binding.ValidatesOnExceptions%2A> ним, либо `true` имеет свойство устанавливается и исключение выбрасывается, когда связывающий <xref:System.Windows.Data.Binding.UpdateSourceExceptionFilter%2A>двигатель устанавливает источник, связывающий двигатель проверяет, есть ли . У вас есть возможность <xref:System.Windows.Data.Binding.UpdateSourceExceptionFilter%2A> использовать обратный вызов, чтобы предоставить пользовательский обработчик для обработки исключений. Если <xref:System.Windows.Data.Binding.UpdateSourceExceptionFilter%2A> не указан <xref:System.Windows.Data.Binding>на, связывающий <xref:System.Windows.Controls.ValidationError> двигатель создает за исключением и добавляет его в <xref:System.Windows.Controls.Validation.Errors%2A?displayProperty=nameWithType> сбор связанного элемента.

## <a name="debugging-mechanism"></a>Механизм отладки

Вы можете установить <xref:System.Diagnostics.PresentationTraceSources.TraceLevel%2A?displayProperty=nameWithType> прилагаемое свойство на объекте, связанном с обязательным, для получения информации о статусе конкретного привязки.

## <a name="see-also"></a>См. также

- <xref:System.Windows.Controls.DataErrorValidationRule>
- [Привязывайки к результатам запроса LIN](../../framework/wpf/data/how-to-bind-to-the-results-of-a-linq-query.md)
- [Связывание данных](../../framework/wpf/advanced/optimizing-performance-data-binding.md)
- [Демо-версия связывания данных][data-binding-demo]
- [Как статьи](../../framework/wpf/data/data-binding-how-to-topics.md)
- [Привязка к источнику данных ADO.NET](../../framework/wpf/data/how-to-bind-to-an-ado-net-data-source.md)

[data-binding-demo]: https://github.com/microsoft/WPF-Samples/tree/master/Sample%20Applications/DataBindingDemo "демо-приложение для связывания данных"
