---
title: Оператор SyncLock
ms.date: 07/20/2015
f1_keywords:
- vb.SyncLock
- SyncLock
helpviewer_keywords:
- threading [Visual Basic], locks
- SyncLock statement [Visual Basic]
- locks, threads
ms.assetid: 14501703-298f-4d43-b139-c4b6366af176
ms.openlocfilehash: 0f430edce99513b0de9ef437d70648a128b336b8
ms.sourcegitcommit: 17ee6605e01ef32506f8fdc686954244ba6911de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/22/2019
ms.locfileid: "74352807"
---
# <a name="synclock-statement"></a>Оператор SyncLock
Получает монопольную блокировку для блока операторов перед выполнением блока.  
  
## <a name="syntax"></a>Синтаксис  
  
```vb  
SyncLock lockobject  
    [ block ]  
End SyncLock  
```  
  
## <a name="parts"></a>Части  
 `lockobject`  
 Обязательно. Выражение, результатом которого является ссылка на объект.  
  
 `block`  
 Необязательно. Блок инструкций, которые выполняются при получении блокировки.  
  
 `End SyncLock`  
 Завершает блок `SyncLock`.  
  
## <a name="remarks"></a>Заметки  
 Оператор `SyncLock` гарантирует, что несколько потоков не выполняют блок инструкций одновременно. `SyncLock` предотвращает вход каждого потока в блок до тех пор, пока не будет выполнен другой поток.  
  
 Чаще всего `SyncLock` используется для защиты данных от одновременного обновления более чем одним потоком. Если инструкции, управляющие данными, должны переходить к завершению без прерывания, помещайте их в блок `SyncLock`.  
  
 Блок операторов, защищенный монопольной блокировкой, иногда называют *критическим разделом*.  
  
## <a name="rules"></a>Правила  
  
- Ветвления. Невозможно выполнить ветвление в блок `SyncLock`, находящийся за пределами блока.  
  
- Блокировка значения объекта. Значение `lockobject` не может быть `Nothing`. Объект Lock необходимо создать до его использования в инструкции `SyncLock`.  
  
     Невозможно изменить значение `lockobject` при выполнении блока `SyncLock`. Механизм требует, чтобы объект блокировки оставался без изменений.  
  
- Оператор [await](../../../visual-basic/language-reference/operators/await-operator.md) нельзя использовать в блоке `SyncLock`.  
  
## <a name="behavior"></a>Поведение  
  
- Механизм. Когда поток достигает оператора `SyncLock`, он вычисляет выражение `lockobject` и приостанавливает выполнение до тех пор, пока не получит монопольную блокировку на объект, возвращенный выражением. Когда другой поток достигает оператора `SyncLock`, он не получает блокировку до тех пор, пока первый поток не выполнит инструкцию `End SyncLock`.  
  
- Защищенные данные. Если `lockobject` является `Shared` переменной, монопольная блокировка запрещает потоку в любом экземпляре класса выполнять блок `SyncLock`, пока он выполняется любым другим потоком. Это защищает данные, которые являются общими для всех экземпляров.  
  
     Если `lockobject` является переменной экземпляра (не `Shared`), блокировка не дает потоку, запущенному в текущем экземпляре, выполнять блок `SyncLock` в то же время, что и другой поток в том же экземпляре. Это защищает данные, обслуживаемые отдельным экземпляром.  
  
- Приобретение и выпуск. Блок `SyncLock` ведет себя как конструкция `Try...Finally`, в которой блок `Try` получает монопольную блокировку на `lockobject`, а блок `Finally` освобождает ее. По этой причине блок `SyncLock` гарантирует освобождение блокировки, независимо от того, как вы выйдете из блока. Это справедливо даже в случае необработанного исключения.  
  
- Платформа вызывает. Блок `SyncLock` получает и освобождает монопольную блокировку, вызывая методы `Enter` и `Exit` класса `Monitor` в пространстве имен <xref:System.Threading>.  
  
## <a name="programming-practices"></a>Рекомендации по программированию  
 `lockobject`ное выражение всегда должно оцениваться как объект, который относится исключительно к вашему классу. Следует объявить переменную объекта `Private`, чтобы защитить данные, принадлежащие текущему экземпляру, или переменную объекта `Private Shared`, чтобы защитить данные, общие для всех экземпляров.  
  
 Не следует использовать ключевое слово `Me` для предоставления объекта блокировки для данных экземпляра. Если код, внешний для класса, имеет ссылку на экземпляр класса, он может использовать эту ссылку в качестве объекта блокировки для `SyncLock` блока, совершенно отличного от вашего, защищая различные данные. Таким образом, класс и другой класс могут заблокировать друг друга от запуска несвязанных блоков `SyncLock`. Подобная блокировка строки может быть проблематичной, так как любой другой код в процессе, использующий одну и ту же строку, будет совместно использовать одну и ту же блокировку.  
  
 Не следует также использовать метод `Me.GetType` для предоставления объекта блокировки для общих данных. Это происходит потому, что `GetType` всегда возвращает один и тот же `Type` объект для заданного имени класса. Внешний код может вызвать `GetType` для класса и получить тот же объект блокировки, который вы используете. Это приведет к тому, что два класса блокируют друг друга из блоков `SyncLock`.  
  
## <a name="examples"></a>Примеры  
  
### <a name="description"></a>Описание  
 В следующем примере показан класс, который поддерживает простой список сообщений. Он хранит сообщения в массиве и последнем используемом элементе этого массива в переменной. `addAnotherMessage` процедура увеличивает последний элемент и сохраняет новое сообщение. Эти две операции защищаются инструкциями `SyncLock` и `End SyncLock`, так как после увеличения последнего элемента новое сообщение должно быть сохранено до того, как любой другой поток снова сможет снова увеличить последний элемент.  
  
 Если класс `simpleMessageList` предоставил общий список сообщений между всеми экземплярами, переменные `messagesList` и `messagesLast` будут объявлены как `Shared`. В этом случае переменную `messagesLock` также следует `Shared`, чтобы в каждом экземпляре использовался один объект блокировки.  
  
### <a name="code"></a>Код  
 [!code-vb[VbVbalrThreading#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrThreading/VB/Class1.vb#1)]  
  
### <a name="description"></a>Описание  
 В следующем примере используются потоки и `SyncLock`. Пока используется оператор `SyncLock`, блок операторов является критическим разделом и `balance` никогда не становится отрицательным числом. Можно закомментировать операторы `SyncLock` и `End SyncLock`, чтобы увидеть результат выхода из ключевого слова `SyncLock`.  
  
### <a name="code"></a>Код  
 [!code-vb[VbVbalrThreading#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrThreading/VB/class2.vb#21)]  
  
### <a name="comments"></a>Комментарии  
  
## <a name="see-also"></a>См. также

- <xref:System.Threading.Monitor?displayProperty=nameWithType>
- <xref:System.Threading.Interlocked?displayProperty=nameWithType>
- [Обзор примитивов синхронизации](../../../standard/threading/overview-of-synchronization-primitives.md)
