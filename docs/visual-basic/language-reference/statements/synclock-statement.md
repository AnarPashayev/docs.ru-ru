---
title: Оператор SyncLock (Visual Basic)
ms.date: 07/20/2015
f1_keywords:
- vb.SyncLock
- SyncLock
helpviewer_keywords:
- threading [Visual Basic], locks
- SyncLock statement [Visual Basic]
- locks, threads
ms.assetid: 14501703-298f-4d43-b139-c4b6366af176
ms.openlocfilehash: 3a12c3ac7250ee2904d571406d5008d451c9dc35
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61783829"
---
# <a name="synclock-statement"></a>Оператор SyncLock
Применяет монопольную блокировку для блока инструкций, перед выполнением блока.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
SyncLock lockobject  
    [ block ]  
End SyncLock  
```  
  
## <a name="parts"></a>Части  
 `lockobject`  
 Обязательный. Выражение, возвращающее ссылку на объект.  
  
 `block`  
 Необязательный параметр. Блок операторов, которые должны выполняться, когда блокировка получена.  
  
 `End SyncLock`  
 Завершает `SyncLock` блока.  
  
## <a name="remarks"></a>Примечания  
 `SyncLock` Оператор гарантирует, что несколько потоков не выполняют блок операторов одновременно. `SyncLock` запрещает каждому потоку входе в блок, пока не выполняется ни один поток.  
  
 Наиболее распространенное использование `SyncLock` предназначены для защиты данных не будет обновляться одновременно более чем одним потоком. Если операторы для работы с данными необходимо перейти к завершению работы без прерывания, поместите их внутри `SyncLock` блока.  
  
 Блок операторов, защищенный монопольной блокировкой иногда называют *критический раздел*.  
  
## <a name="rules"></a>Правила  
  
- Ветвление. Нельзя осуществлять ветвление в `SyncLock` заблокировать вне блока.  
  
- Значение объекта блокировки. Значение `lockobject` не может быть `Nothing`. Необходимо создать объект блокировки, прежде чем использовать его в `SyncLock` инструкции.  
  
     Не удается изменить значение `lockobject` при выполнении `SyncLock` блока. Механизм требует, что объект блокировки остаются неизменными.  
  
- Нельзя использовать [Await](../../../visual-basic/language-reference/operators/await-operator.md) оператор в `SyncLock` блока.  
  
## <a name="behavior"></a>Поведение  
  
- Механизм. Когда поток достигает `SyncLock` инструкции, она оценивает `lockobject` выражение и приостанавливает выполнение, пока не получит монопольную блокировку для объекта, возвращаемого выражением. Когда другой поток достигает `SyncLock` инструкции, она не использовать блокировку пока первый поток выполняет `End SyncLock` инструкции.  
  
- Защищенные данные. Если `lockobject` — `Shared` переменных, монопольная блокировка предотвращает поток в любом экземпляре класса выполнение `SyncLock` блокировать во время его выполнения любого другого потока. Это обеспечивает защиту данных, которая является общей для всех экземпляров.  
  
     Если `lockobject` является переменной экземпляра (не `Shared`), Блокировка предотвращает одновременное выполнение потока в текущем экземпляре выполнения `SyncLock` блока, в то же время как другой поток, в том же экземпляре. Это обеспечивает защиту данных, содержащихся в отдельном экземпляре.  
  
- Получение и выпуск. Объект `SyncLock` блок ведет себя как `Try...Finally` построения, в котором `Try` блок применяет монопольную блокировку на `lockobject` и `Finally` блок освобождает его. По этой причине `SyncLock` блок гарантирует освобождение блокировки, независимо от того, как выйти из блока. Это справедливо даже в случае необработанного исключения.  
  
- Платформа вызывает функцию. `SyncLock` Блок получает и освобождает монопольную блокировку, вызывая `Enter` и `Exit` методы `Monitor` в класс <xref:System.Threading> пространства имен.  
  
## <a name="programming-practices"></a>Примеры программирования  
 `lockobject` Выражение всегда следует проверять на объект, к которому относится исключительно к классу. Следует объявлять `Private` объектной переменной, чтобы защитить данные, относящиеся к текущим экземпляром, или `Private Shared` объектной переменной, чтобы защитить данные, общие для всех экземпляров.  
  
 Не следует использовать `Me` ключевое слово для предоставления блокировки для экземпляра объекта данных. Если код, внешним по отношению к классу имеет ссылку на экземпляр вашего класса, он может использовать эту ссылку, как объект блокировки для `SyncLock` блок полностью отличаться от впечатления разработчика, защиты данных. Таким образом, класс и другой класс может заблокировать друг с другом выполнение их несвязанных `SyncLock` блоков. Аналогичным образом, блокировка строки может вызывать затруднения, так как любой другой код в процесс, использующий ту же строку будет совместно использовать ту же блокировку.  
  
 Также не следует использовать `Me.GetType` метод, чтобы предоставить объект блокировки для общих данных. Это обусловлено `GetType` всегда возвращает тот же `Type` объект для заданного имени класса. Внешний код может осуществлять вызов `GetType` в классе и получить тот же объект блокировки, которые вы используете. Это может привести в обоих классах блокировки друг с другом и с их `SyncLock` блоков.  
  
## <a name="examples"></a>Примеры  
  
### <a name="description"></a>Описание  
 В следующем примере класс, который поддерживает простой список сообщений. Сообщения хранятся в массиве, а последний элемент этого массива в переменной. `addAnotherMessage` Процедура увеличивает значение последнего элемента и сохраняет новое сообщение. Эти две операции защищены с помощью `SyncLock` и `End SyncLock` инструкции, так как после последнего элемента был увеличен, должен храниться новое сообщение, прежде, чем любой другой поток может снова увеличить последнего элемента.  
  
 Если `simpleMessageList` один список сообщений для всех его экземпляров, переменные общих классов `messagesList` и `messagesLast` должна быть объявлена как `Shared`. В данном случае переменная `messagesLock` также должен быть `Shared`, таким образом, чтобы могла быть объект блокировки, используемые каждым экземпляром.  
  
### <a name="code"></a>Код  
 [!code-vb[VbVbalrThreading#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrThreading/VB/Class1.vb#1)]  
  
### <a name="description"></a>Описание  
 В следующем примере используются потоки и `SyncLock`. Поскольку `SyncLock` присутствует оператор, блокировка оператора является критической секции и `balance` никогда не будет отрицательным числом. Вы можете закомментировать `SyncLock` и `End SyncLock` инструкции, чтобы увидеть эффект пропускают `SyncLock` ключевое слово.  
  
### <a name="code"></a>Код  
 [!code-vb[VbVbalrThreading#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrThreading/VB/class2.vb#21)]  
  
### <a name="comments"></a>Комментарии  
  
## <a name="see-also"></a>См. также

- <xref:System.Threading.Monitor?displayProperty=nameWithType>
- <xref:System.Threading.Interlocked?displayProperty=nameWithType>
- [Обзор примитивов синхронизации](../../../standard/threading/overview-of-synchronization-primitives.md)
