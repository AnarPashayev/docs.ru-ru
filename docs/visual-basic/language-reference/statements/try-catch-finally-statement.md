---
title: Try... CATCH... Оператор Finally - Visual Basic
description: Узнайте, как использовать с Visual Basic Try/Catch/Finally, Операторы обработки исключений.
ms.date: 12/07/2018
f1_keywords:
- vb.Try...Catch...Finally
- vb.when
- vb.Finally
- vb.Catch
- vb.Try
helpviewer_keywords:
- Try...Catch...Finally statements
- Try statement [Visual Basic]
- try-catch exception handling, Try...Catch...Finally statements
- error handling, while running code
- Try statement [Visual Basic], Try...Catch...Finally
- Finally keyword [Visual Basic], Try...Catch...Finally
- Catch statement [Visual Basic]
- When keyword [Visual Basic]
- Visual Basic code, handling errors while running
- structured exception handling, Try...Catch...Finally statements
ms.assetid: d6488026-ccb3-42b8-a810-0d97b9d6472b
ms.custom: seodec18
ms.openlocfilehash: 2e4fef836b08f536565105dbab76292b2fc4388e
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61934268"
---
# <a name="trycatchfinally-statement-visual-basic"></a>Оператор Try... Catch... Finally (Visual Basic)

Предоставляет способ обработки некоторых или всех возможных ошибок, которые могут возникать в конкретном блоке кода, не прерывая выполнение кода.

## <a name="syntax"></a>Синтаксис

```vb
Try
    [ tryStatements ]
    [ Exit Try ]
[ Catch [ exception [ As type ] ] [ When expression ]
    [ catchStatements ]
    [ Exit Try ] ]
[ Catch ... ]
[ Finally
    [ finallyStatements ] ]
End Try
```

## <a name="parts"></a>Части

|Термин|Определение|
|---|---|
|`tryStatements`|Необязательный параметр. Операторы, где может произойти ошибка. Может быть составным оператором.|
|`Catch`|Необязательный параметр. Несколько `Catch` блоки, которые разрешено. При возникновении исключения при обработке `Try` block, каждый `Catch` инструкции является проверяются в порядке следования, чтобы определить, обрабатывает ли он исключения, с `exception` представляет исключение, которое возникло исключение.|
|`exception`|Необязательный параметр. Любое имя переменной. Начальное значение `exception` — это значение возникшей ошибки. Используется с `Catch` ошибок перехвачено. Если этот параметр опущен, `Catch` инструкции перехватывает все исключения.|
|`type`|Необязательный параметр. Указывает тип класса фильтра. Если значение `exception` имеет тип, указанный в `type` или производного типа, идентификатор становится привязанным к объекту исключения.|
|`When`|Необязательный параметр. Объект `Catch` инструкции с `When` предложение перехватывает исключения только тогда, когда `expression` принимает значение `True`. Объект `When` предложение применяется только после проверки типа исключения, и `expression` может ссылаться на идентификатор, представляющий исключение.|
|`expression`|Необязательный параметр. Должен неявно преобразовываться в `Boolean`. Любое выражение, которое описывает универсальный фильтр. Обычно используется для фильтрации по номеру ошибки. Используется с `When` ключевое слово для определения условий, при которых перехватывается ошибка.|
|`catchStatements`|Необязательный параметр. Операторы обработки ошибок, возникающих в соответствующем `Try` блока. Может быть составным оператором.|
|`Exit Try`|Необязательный параметр. Ключевое слово, которое выходит за пределы `Try...Catch...Finally` структуры. Выполнение возобновляется с кода, который сразу `End Try` инструкции. `Finally` Инструкция будет выполняться по-прежнему. Не допускается в `Finally` блоков.|
|`Finally`|Необязательный параметр. Объект `Finally` блоке выполняется всегда, когда выполнение покидает любую часть `Try...Catch` инструкции.|
|`finallyStatements`|Необязательный параметр. Операторы, выполняемые после всех других действий по обработке ошибки.|
|`End Try`|Завершает `Try...Catch...Finally` структуры.|

## <a name="remarks"></a>Примечания

Если предполагается, что конкретное исключение может произойти во время определенного раздела кода, поместить код в `Try` блокировать и использовать `Catch` блок для сохранения управления и обработки исключения, если оно происходит.

Объект `Try…Catch` оператор состоит из `Try` блока, а затем по одному или нескольким `Catch` предложений, задающих обработчики для различных исключений. Когда исключение `Try` block, Visual Basic выполняет поиск `Catch` оператор, который обрабатывает исключение. Если соответствующий `Catch` не найден оператор, Visual Basic проверяет метод, который вызвал текущий метод, и так далее вверх по стеку вызовов. Если нет `Catch` блокировка найдена, Visual Basic отображает для пользователя сообщение о необработанном исключении и останавливает выполнение программы.

Можно использовать более чем один `Catch` инструкции в `Try…Catch` инструкции. После этого, порядок `Catch` предложения важно, поскольку они проверяются в порядке. Перехватывайте более конкретные исключения перед менее конкретными.

Следующие `Catch` инструкции условия являются более общим и будет перехватывать все исключения, которые являются производными от <xref:System.Exception> класса. Обычно следует использовать один из этих вариантов как и в последнем `Catch` блока в `Try...Catch...Finally` структуры, после перехвата определенных исключений, предполагается, что. Поток управления не сможет достичь `Catch` блок, который следует за любой из этих вариантов.

- `type` Является `Exception`, например: `Catch ex As Exception`

- Инструкция не `exception` переменной, например: `Catch`

При `Try…Catch…Finally` инструкции вложен в другой `Try` блока, Visual Basic сначала проверяет каждый `Catch` инструкции в самом внутреннем содержащемся `Try` блока. Если совпадающих `Catch` оператор найден, поиск продолжается `Catch` инструкции внешнего `Try…Catch…Finally` блока.

Локальные переменные из `Try` блок не доступны в `Catch` заблокирован, поскольку это отдельные блоки. Если вы хотите использовать переменную в нескольких блоках, объявить переменную за пределами `Try...Catch...Finally` структуры.

> [!TIP]
> `Try…Catch…Finally` Инструкция доступна в качестве фрагмента кода IntelliSense. В диспетчере фрагментов кода, разверните **шаблоны кода: If, For Each, Try Catch, свойство, д**, а затем **обработка ошибок (исключения)**. Дополнительные сведения см. в статье [Фрагменты кода](/visualstudio/ide/code-snippets).

## <a name="finally-block"></a>Блок finally

Если у вас есть один или несколько операторов, которые необходимо выполнить перед закрытием `Try` структуру, используйте `Finally` блока. Управление передается `Finally` блокировать только перед передачей из `Try…Catch` структуры. Это справедливо, даже если исключение возникает внутри `Try` структуры.

Объект `Finally` блок полезен для выполнить код, который необходимо выполнить, даже если существует одно исключение. Управление передается `Finally` блока независимо от способа `Try...Catch` блокировать завершает работу.

Код в `Finally` блоке даже при возникновении кода `Return` инструкции в `Try` или `Catch` блока. Элемент управления не проходит из `Try` или `Catch` блокировать в соответствующий `Finally` блока в следующих случаях:

- [Оператор End](end-statement.md) встречается в `Try` или `Catch` блока.

- Объект <xref:System.StackOverflowException> создается в `Try` или `Catch` блока.

Не допускается Явная передача выполнения в `Finally` блока. Передача выполнения из `Finally` недопустимый блок, за исключением случая возникновения исключения.

Если `Try` инструкция не содержит хотя бы один `Catch` блок, он должен содержать `Finally` блока.

> [!TIP]
> Если у вас нет перехватывать определенные исключения `Using` инструкции ведет себя как `Try…Finally` блока, а также гарантирует освобождение ресурсов, независимо от способа выхода из блока. Это справедливо даже с необработанным исключением. Дополнительные сведения см. в разделе [Оператор using](using-statement.md).

## <a name="exception-argument"></a>Исключение аргумента

`Catch` Блок `exception` аргумент является экземпляром <xref:System.Exception> класс или класс, производный от `Exception` класса. `Exception` Ошибки, возникшей в соответствующий экземпляр класса `Try` блока.

Свойства `Exception` объекта справки для определения причины и месторасположения исключения. Например <xref:System.Exception.StackTrace%2A> списки свойств вызванных методов, которые привели к исключению, помогая обнаружить, где произошла ошибка в коде. <xref:System.Exception.Message%2A> Возвращает сообщение, описывающее исключение. <xref:System.Exception.HelpLink%2A> Возвращает ссылку на связанный файл справки. <xref:System.Exception.InnerException%2A> Возвращает `Exception` возвращает объект, вызвавший текущее исключение, или его `Nothing` при наличии не оригинал `Exception`.

## <a name="considerations-when-using-a-trycatch-statement"></a>Рекомендации по использованию Try... Оператор catch

Используйте `Try…Catch` инструкции только для того, чтобы сообщить о программе необычные или непредвиденных событий. Возможны следующие причины этого.

- Перехват исключений во время выполнения создает дополнительную нагрузку и может работать медленнее, чем предварительно проверки, чтобы избежать исключений.

- Если `Catch` блок обрабатывается неправильно, исключение может быть некорректно отображается для пользователей.

- Обработка исключений позволяет более сложные программы.

Вы не всегда обязательно `Try…Catch` инструкция проверки условия, которое вероятность. В следующем примере проверяется, существует ли файл, прежде чем пытаться открыть его. Это уменьшает необходимость перехват исключения, вызванного <xref:System.IO.File.OpenText%2A> метод.

[!code-vb[VbVbalrStatements#94](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class1.vb#94)]

Убедитесь, что код в `Catch` блоки мог правильно выдавать исключения для пользователей, посредством ведения журнала с потоками или соответствующие сообщения. В противном случае исключения может оставаться неизвестно.

## <a name="async-methods"></a>Асинхронные методы

Если пометить метод [Async](../modifiers/async.md) модификатор, можно использовать [Await](../operators/await-operator.md) в этом методе. Оператор с модификатором `Await` оператор приостанавливает выполнение метода до завершения выполнения ожидающей задачи. Задача представляет выполняющуюся работу. Когда задачи, связанные с `Await` оператор завершается, выполнение возобновляется в тот же метод. Дополнительные сведения см. в разделе [поток управления в асинхронных программах](../../../visual-basic/programming-guide/concepts/async/control-flow-in-async-programs.md).

Задачи, возвращаемой функцией асинхронный метод может оказаться в состоянии сбоя, указывающее на то, что оно выполнено из-за необработанного исключения. Задача также может завершиться в отмененном состоянии, что приводит к `OperationCanceledException` вызываемом из выражения await. Чтобы перехватывать исключения любого типа, поместите `Await` выражения, который связан с задачей в `Try` блокировать и перехватить исключение в `Catch` блока. Пример приведен далее в этом разделе.

Задача может находиться в состоянии сбоя, так как несколько исключений отвечали за его завершение со сбоем. Например, задача может быть результатом вызова метода <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType>. Когда вы ожидаете такую задачу, перехваченное исключение имеет только одно из исключений и невозможно предсказать, какое исключение будет перехвачено. Пример приведен далее в этом разделе.

`Await` Выражение не может быть внутри `Catch` блока или `Finally` блока.

## <a name="iterators"></a>Итераторы

Функции итератора или `Get` доступа выполняет настраиваемую итерацию по коллекции. Итератор использует [Yield](yield-statement.md) инструкцию для возврата всех элементов коллекции по одному за раз. Вызов функции итератора с помощью [для каждого... Следующий оператор](for-each-next-statement.md).

Объект `Yield` инструкцию можно внутри `Try` блока. Объект `Try` блока, содержащего `Yield` инструкция может иметь `Catch` блокируется и может иметь `Finally` блока. См. в разделе «Попробуйте блоков в Visual Basic» [итераторы](../../programming-guide/concepts/iterators.md) пример.

Объект `Yield` оператор не может находиться внутри `Catch` блока или `Finally` блока.

Если `For Each` текст (за пределами функции итератора) вызывает исключение, `Catch` блок в функции итератора не выполняется, но `Finally` выполняется блок в функции итератора. Объект `Catch` блока внутри функции итератора перехватываются только исключения, возникшие внутри функции итератора.

## <a name="partial-trust-situations"></a>Ситуациях частичного доверия

В ситуациях частичного доверия, например приложения, размещенного в общей сетевой папке `Try...Catch...Finally` не перехватывает исключения безопасности, происходящие до вызова метода, который содержит вызов. Приведенный ниже, поместите его на общем ресурсе сервера и запуск оттуда, создающий ошибку «System.Security.SecurityException: Не удалось выполнить запрос.» Дополнительные сведения о исключения безопасности, см. в разделе <xref:System.Security.SecurityException> класса.

[!code-vb[VbVbalrStatements#85](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class1.vb#85)]

В такой ситуации частичного доверия необходимо поместить `Process.Start` инструкции в отдельном `Sub`. Начальный вызов `Sub` завершится ошибкой. Это позволяет `Try...Catch` перехватить его перед `Sub` , содержащий `Process.Start` запускается и создается исключение безопасности.

## <a name="examples"></a>Примеры

### <a name="the-structure-of-trycatchfinally"></a>Структура Try... CATCH... Наконец

Следующий пример иллюстрирует структуру `Try...Catch...Finally` инструкции.

[!code-vb[VbVbalrStatements#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class1.vb#86)]  

### <a name="exception-in-a-method-called-from-a-try-block"></a>Исключение в метод, вызываемый из блока Try

В следующем примере `CreateException` вызывает метод `NullReferenceException`. Код, который создает исключение, не находится в `Try` блока. Таким образом `CreateException` метод не обрабатывает исключение. `RunSample` Метод обработки исключения, так как вызов `CreateException` метод находится в `Try` блока.

В примере `Catch` инструкций для нескольких типов исключений, в порядке от наиболее конкретных к наиболее общим.

[!code-vb[VbVbalrStatements#91](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class1.vb#91)]

### <a name="the-catch-when-statement"></a>Оператор Catch при

В следующем примере показано, как использовать `Catch When` инструкции для фильтрации по условному выражению. Если условное выражение вычислено как `True`, код в `Catch` блоке.

[!code-vb[VbVbalrStatements#92](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class1.vb#92)]

### <a name="nested-try-statements"></a>Вложенные инструкции Try

В следующем примере имеется `Try…Catch` инструкции, содержащейся в `Try` блока. Внутренний `Catch` блок вызывает исключение, которое имеет его `InnerException` свойство присвоено исходное исключение. Внешний `Catch` блок сообщает собственное исключение и внутреннее исключение.

[!code-vb[VbVbalrStatements#93](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class1.vb#93)]

### <a name="exception-handling-for-async-methods"></a>Обработке исключений для асинхронных методов

В следующем примере демонстрируется обработка исключений для асинхронных методов. Чтобы перехватить исключение, которое применяется для асинхронной задачи, `Await` выражение находится `Try` блок вызывающего объекта, а исключение перехватывается в `Catch` блока.

Раскомментируйте строку `Throw New Exception` в этом примере для демонстрации обработки исключений. Исключение перехватывается в `Catch` блокировать задачи `IsFaulted` свойству `True`и задачи `Exception.InnerException` свойству исключение.

Раскомментируйте строку `Throw New OperationCancelledException`, чтобы показать, что происходит при отмене асинхронного процесса. Исключение перехватывается в `Catch` блока, а также задачи `IsCanceled` свойству `True`. Тем не менее, при некоторых условиях, которые не применяются к этому примеру `IsFaulted` присваивается `True` и `IsCanceled` присваивается `False`.

[!code-vb[csAsyncExceptions#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/csasyncexceptions/vb/class1.vb#1)]

### <a name="handling-multiple-exceptions-in-async-methods"></a>Обработка нескольких исключений в асинхронных методах

В следующем примере демонстрируется обработка исключений, когда несколько задач могут привести к нескольким исключениям. `Try` Блок содержит `Await` выражение для задачи, <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> возвращается. Задача завершена, когда три задачи, к которому <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> применяется завершены.

Каждая из трех задач вызывает исключение. `Catch` Блок итерацию по исключениям, которые находятся в `Exception.InnerExceptions` свойство задачи, `Task.WhenAll` возвращается.

[!code-vb[csAsyncExceptions#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/csasyncexceptions/vb/class1.vb#3)]

## <a name="see-also"></a>См. также

- <xref:Microsoft.VisualBasic.Information.Err%2A>
- <xref:System.Exception>
- [Оператор Exit](exit-statement.md)
- [Оператор On Error](on-error-statement.md)
- [Рекомендации по использованию фрагментов кода](/visualstudio/ide/best-practices-for-using-code-snippets)
- [Обработка исключений](../../../standard/parallel-programming/exception-handling-task-parallel-library.md)
- [Оператор Throw](throw-statement.md)