---
title: Попробуйте... Перехватить... Оператор finally
description: Узнайте, как использовать обработку исключений с инструкциями Visual Basic try/catch/finally.
ms.date: 12/07/2018
f1_keywords:
- vb.Try...Catch...Finally
- vb.when
- vb.Finally
- vb.Catch
- vb.Try
helpviewer_keywords:
- Try...Catch...Finally statements
- Try statement [Visual Basic]
- try-catch exception handling, Try...Catch...Finally statements
- error handling, while running code
- Try statement [Visual Basic], Try...Catch...Finally
- Finally keyword [Visual Basic], Try...Catch...Finally
- Catch statement [Visual Basic]
- When keyword [Visual Basic]
- Visual Basic code, handling errors while running
- structured exception handling, Try...Catch...Finally statements
ms.assetid: d6488026-ccb3-42b8-a810-0d97b9d6472b
ms.custom: seodec18
ms.openlocfilehash: eb04b6cff0847009407e38a3696e9be7c700356c
ms.sourcegitcommit: 30a558d23e3ac5a52071121a52c305c85fe15726
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/25/2019
ms.locfileid: "75337333"
---
# <a name="trycatchfinally-statement-visual-basic"></a>Оператор Try... Catch... Finally (Visual Basic)

Предоставляет способ управления некоторыми или всеми возможными ошибками, которые могут возникнуть в данном блоке кода, при этом выполняется код.

## <a name="syntax"></a>Синтаксис

```vb
Try
    [ tryStatements ]
    [ Exit Try ]
[ Catch [ exception [ As type ] ] [ When expression ]
    [ catchStatements ]
    [ Exit Try ] ]
[ Catch ... ]
[ Finally
    [ finallyStatements ] ]
End Try
```

## <a name="parts"></a>Части

|Термин|Определение|
|---|---|
|`tryStatements`|(Необязательный аргумент) Операторы, в которых может возникнуть ошибка. Может быть составным оператором.|
|`Catch`|(Необязательный аргумент) Разрешено несколько блоков `Catch`. Если при обработке блока `Try` возникает исключение, каждая инструкция `Catch` проверяется в текстовом порядке, чтобы определить, обрабатывается ли исключение, с `exception` представляющего созданное исключение.|
|`exception`|(Необязательный аргумент) Любое имя переменной. Начальное значение `exception` — это значение возникшей ошибки. Используется с `Catch` для указания перехваченной ошибки. Если этот параметр опущен, то оператор `Catch` перехватывает любое исключение.|
|`type`|(Необязательный аргумент) Указывает тип фильтра класса. Если значение `exception` имеет тип, заданный `type` или производного типа, то идентификатор привязывается к объекту исключения.|
|`When`|(Необязательный аргумент) Инструкция `Catch` с предложением `When` перехватывает исключения только в том случае, если `expression` вычисляется как `True`. Предложение `When` применяется только после проверки типа исключения, а `expression` может ссылаться на идентификатор, представляющий исключение.|
|`expression`|(Необязательный аргумент) Должен быть неявно преобразуемым в `Boolean`. Любое выражение, описывающее универсальный фильтр. Обычно используется для фильтрации по номеру ошибки. Используется с ключевым словом `When` для указания обстоятельств, при которых ошибка будет перехвачена.|
|`catchStatements`|(Необязательный аргумент) Инструкции для управления ошибками, происходящими в связанном блоке `Try`. Может быть составным оператором.|
|`Exit Try`|(Необязательный аргумент) Ключевое слово, которое нарушает структуру `Try...Catch...Finally`. Выполнение возобновляется с помощью кода сразу после оператора `End Try`. Инструкция `Finally` будет по-прежнему выполняться. Не допускается в блоках `Finally`.|
|`Finally`|(Необязательный аргумент) Блок `Finally` всегда выполняется, когда выполнение покидает любую часть инструкции `Try...Catch`.|
|`finallyStatements`|(Необязательный аргумент) Инструкции, которые выполняются после возникновения всех других ошибок обработки.|
|`End Try`|Завершает структуру `Try...Catch...Finally`.|

## <a name="remarks"></a>Заметки

Если вы предполагаете, что конкретное исключение может возникнуть во время определенного раздела кода, разместите код в блоке `Try` и используйте блок `Catch` для удержания управления и обработайте исключение, если оно происходит.

Оператор `Try…Catch` состоит из блока `Try`, за которым следует одно или несколько `Catch` предложений, которые указывают обработчики для различных исключений. При возникновении исключения в блоке `Try` Visual Basic ищет инструкцию `Catch`, которая обрабатывает исключение. Если соответствующая `Catch` инструкция не найдена, Visual Basic проверяет метод, который вызвал текущий метод, и т. д. в стеке вызовов. Если блок `Catch` не найден, Visual Basic выводит пользователю сообщение о необработанном исключении и прекращает выполнение программы.

В инструкции `Try…Catch` можно использовать более одной инструкции `Catch`. В этом случае порядок предложений `Catch` важен, так как они анализируются по порядку. Перехватывайте более конкретные исключения перед менее конкретными.

Следующие условия оператора `Catch` являются минимально конкретными, и будут перехватывать все исключения, производные от класса <xref:System.Exception>. Обычно следует использовать один из этих вариантов в качестве последнего блока `Catch` в структуре `Try...Catch...Finally`, после того как будут перехватываться все определенные исключения. Поток управления никогда не может достичь блока `Catch`, который следует за одним из этих вариантов.

- `type` `Exception`, например: `Catch ex As Exception`

- Оператор не имеет `exception` переменной, например: `Catch`

Если `Try…Catch…Finally` оператор вложен в другой блок `Try`, Visual Basic сначала проверяет каждую инструкцию `Catch` во внутреннем блоке `Try`. Если соответствующий оператор `Catch` не найден, поиск продолжается до инструкций `Catch` внешнего блока `Try…Catch…Finally`.

Локальные переменные из блока `Try` недоступны в блоке `Catch`, так как они являются отдельными блоками. Если вы хотите использовать переменную более чем в одном блоке, объявите переменную вне структуры `Try...Catch...Finally`.

> [!TIP]
> Оператор `Try…Catch…Finally` доступен в виде фрагмента кода IntelliSense. В диспетчере фрагментов кода разверните узел **шаблоны кода — Если для каждого, попробуйте перехватить, свойство и т. д**., а затем — **Обработка ошибок (исключения)** . Дополнительные сведения см. в статье [Фрагменты кода](/visualstudio/ide/code-snippets).

## <a name="finally-block"></a>Блок finally

Если имеется одна или несколько инструкций, которые должны выполняться до выхода из структуры `Try`, используйте блок `Finally`. Управление передается блоку `Finally` непосредственно перед передачей структуры `Try…Catch`. Это справедливо, даже если в структуре `Try` возникает исключение.

Блок `Finally` полезен для выполнения любого кода, который должен выполняться, даже если возникает исключение. Элемент управления передается блоку `Finally` независимо от того, как происходит выход из блока `Try...Catch`.

Код в блоке `Finally` выполняется, даже если код встречает инструкцию `Return` в блоке `Try` или `Catch`. Элемент управления не передается из `Try` или `Catch` блока в соответствующий блок `Finally` в следующих случаях:

- [Оператор End](end-statement.md) встречается в блоке `Try` или `Catch`.

- В блоке `Try` или `Catch` выдается <xref:System.StackOverflowException>.

Не допускается явное перенаправление выполнения в блок `Finally`. Передача выполнения из блока `Finally` недопустима, за исключением исключения.

Если `Try`ная инструкция не содержит хотя бы один блок `Catch`, она должна содержать блок `Finally`.

> [!TIP]
> Если не нужно перехватывать определенные исключения, `Using`ная инструкция ведет себя как `Try…Finally` блок и гарантирует освобождение ресурсов, независимо от способа выхода из блока. Это справедливо даже при необработанном исключении. Дополнительные сведения см. в разделе [Оператор using](using-statement.md).

## <a name="exception-argument"></a>Аргумент исключения

Аргумент `Catch` Block `exception` является экземпляром класса <xref:System.Exception> или класса, производного от класса `Exception`. Экземпляр класса `Exception` соответствует ошибке, произошедшей в блоке `Try`.

Свойства объекта `Exception` помогают определить причину и расположение исключения. Например, свойство <xref:System.Exception.StackTrace%2A> перечисляет вызываемые методы, которые привели к исключению, помогая найти место возникновения ошибки в коде. <xref:System.Exception.Message%2A> возвращает сообщение, описывающее исключение. <xref:System.Exception.HelpLink%2A> возвращает ссылку на связанный файл справки. <xref:System.Exception.InnerException%2A> возвращает объект `Exception`, вызвавший текущее исключение, или возвращает `Nothing`, если исходный `Exception`отсутствует.

## <a name="considerations-when-using-a-trycatch-statement"></a>Рекомендации по использованию try... Оператор catch

Используйте оператор `Try…Catch` только для сигнализации о возникновении необычных или непредвиденных событий программы. К таким причинам относятся следующие.

- Перехват исключений во время выполнения создает дополнительные издержки и, скорее всего, будет медленнее, чем Предварительная проверка, чтобы избежать исключений.

- Если блок `Catch` обрабатывается неправильно, исключение может быть неправильно сообщено пользователям.

- Обработка исключений делает программу более сложной.

Не всегда требуется оператор `Try…Catch`, чтобы проверить наличие условия, которое может произойти. В следующем примере проверяется, существует ли файл, прежде чем пытаться его открыть. Это уменьшает необходимость в перехвате исключения, вызываемого методом <xref:System.IO.File.OpenText%2A>.

[!code-vb[VbVbalrStatements#94](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class1.vb#94)]

Убедитесь, что код в блоках `Catch` может правильно сообщать об исключениях пользователям, независимо от того, является ли он потокобезопасным или соответствующим сообщением. В противном случае исключения могут остаться неизвестными.

## <a name="async-methods"></a>Асинхронные методы

Если метод помечается модификатором [Async](../modifiers/async.md) , можно использовать оператор [await](../operators/await-operator.md) в методе. Инструкция с оператором `Await` приостанавливает выполнение метода до тех пор, пока не завершится ожидаемая задача. Задача представляет выполняющуюся работу. При завершении задачи, связанной с оператором `Await`, выполнение возобновляется в том же методе. Дополнительные сведения см. [в разделе поток управления в асинхронных программах](../../../visual-basic/programming-guide/concepts/async/control-flow-in-async-programs.md).

Задача, возвращаемая асинхронным методом, может завершиться с ошибкой, что означает, что она завершилась из-за необработанного исключения. Задача также может завершаться в отмененном состоянии, что приводит к возникновению `OperationCanceledException` из выражения await. Чтобы перехватить исключение любого типа, поместите `Await` выражение, связанное с задачей, в блок `Try` и перехватите исключение в блоке `Catch`. Пример приведен далее в этом разделе.

Задача может находиться в неисправном состоянии, так как за ее сбоем отвечает несколько исключений. Например, задача может быть результатом вызова метода <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType>. При ожидании такой задачи Перехваченное исключение является только одним из исключений, и вы не можете предсказать, какое исключение будет перехвачено. Пример приведен далее в этом разделе.

Выражение `Await` не может находиться в блоке `Catch` или блоке `Finally`.

## <a name="iterators"></a>Iterators

Функция итератора или метод доступа `Get` выполняет настраиваемую итерацию по коллекции. Итератор использует оператор [yield](yield-statement.md) для возвращения каждого элемента коллекции по одному за раз. Для вызова функции-итератора используется оператор [For Each... Следующий оператор](for-each-next-statement.md).

Оператор `Yield` может находиться в блоке `Try`. Блок `Try`, содержащий инструкцию `Yield`, может иметь `Catch` блоки и может иметь блок `Finally`. Пример см. в разделе "пробные блоки в Visual Basic" [итераторов](../../programming-guide/concepts/iterators.md) .

Оператор `Yield` не может находиться в блоке `Catch` или в блоке `Finally`.

Если тело `For Each` (за пределами функции итератора) создает исключение, блок `Catch` в функции-итераторе не выполняется, но выполняется блок `Finally` в функции итератора. Блок `Catch` внутри функции итератора перехватывает только исключения, происходящие внутри функции итератора.

## <a name="partial-trust-situations"></a>Ситуации частичного доверия

В ситуациях частичного доверия, таких как приложение, размещенное в общей сетевой папке, `Try...Catch...Finally` не перехватывает исключения безопасности, происходящие до вызова метода, содержащего вызов. В следующем примере, когда вы помещаете его на серверный ресурс и выполняете его, вызывается ошибка "System. Security. SecurityException: запрос не выполнен". Дополнительные сведения об исключениях безопасности см. в разделе класс <xref:System.Security.SecurityException>.

[!code-vb[VbVbalrStatements#85](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class1.vb#85)]

В подобной ситуации частичного доверия необходимо разместить оператор `Process.Start` в отдельном `Sub`. Начальный вызов `Sub` завершится ошибкой. Это позволяет `Try...Catch` перехватить его до запуска `Sub`, содержащего `Process.Start`, и созданного исключения безопасности.

## <a name="examples"></a>Примеры

### <a name="the-structure-of-trycatchfinally"></a>Структура try... Перехватить... Счете

В следующем примере показана структура оператора `Try...Catch...Finally`.

[!code-vb[VbVbalrStatements#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class1.vb#86)]  

### <a name="exception-in-a-method-called-from-a-try-block"></a>Исключение в методе, вызываемом из блока try

В следующем примере метод `CreateException` создает исключение `NullReferenceException`. Код, создающий исключение, не находится в блоке `Try`. Поэтому метод `CreateException` не обрабатывает исключение. Метод `RunSample` обрабатывает исключение, так как вызов метода `CreateException` находится в блоке `Try`.

Пример включает `Catch`ные инструкции для нескольких типов исключений, упорядоченные от наиболее конкретных к наиболее общим.

[!code-vb[VbVbalrStatements#91](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class1.vb#91)]

### <a name="the-catch-when-statement"></a>Оператор Catch When

В следующем примере показано, как использовать инструкцию `Catch When` для фильтрации по условному выражению. Если условное выражение имеет значение `True`, выполняется код в блоке `Catch`.

[!code-vb[VbVbalrStatements#92](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class1.vb#92)]

### <a name="nested-try-statements"></a>Вложенные операторы Try

В следующем примере имеется оператор `Try…Catch`, содержащийся в блоке `Try`. Внутренний блок `Catch` вызывает исключение, свойство `InnerException` которого установлено в исходное исключение. Блок внешних `Catch` сообщает свое собственное исключение и внутреннее исключение.

[!code-vb[VbVbalrStatements#93](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class1.vb#93)]

### <a name="exception-handling-for-async-methods"></a>Обработка исключений для асинхронных методов

В следующем примере демонстрируется обработка исключений для асинхронных методов. Чтобы перехватить исключение, которое применяется к асинхронной задаче, `Await` выражение находится в `Try`ном блоке вызывающего, а исключение перехвачено в блоке `Catch`.

Раскомментируйте строку `Throw New Exception` в этом примере для демонстрации обработки исключений. Исключение перехвачено в блоке `Catch`, свойство `IsFaulted` задачи имеет значение `True`, а для свойства `Exception.InnerException` задачи задано исключение.

Раскомментируйте строку `Throw New OperationCancelledException`, чтобы показать, что происходит при отмене асинхронного процесса. Исключение перехвачено в блоке `Catch`, а свойство `IsCanceled` задачи имеет значение `True`. Однако при некоторых условиях, которые не применяются к этому примеру, `IsFaulted` имеет значение `True` а `IsCanceled` имеет значение `False`.

[!code-vb[csAsyncExceptions#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/csasyncexceptions/vb/class1.vb#1)]

### <a name="handling-multiple-exceptions-in-async-methods"></a>Обработка нескольких исключений в асинхронных методах

В следующем примере демонстрируется обработка исключений, когда несколько задач могут привести к нескольким исключениям. Блок `Try` содержит выражение `Await` для задачи, которая <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> возвращается. Задача завершится, когда будут выполнены три задачи, к которым применяется <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType>.

Каждая из трех задач вызывает исключение. Блок `Catch` проходит по исключениям, которые находятся в свойстве `Exception.InnerExceptions` задачи, возвращаемой `Task.WhenAll`.

[!code-vb[csAsyncExceptions#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/csasyncexceptions/vb/class1.vb#3)]

## <a name="see-also"></a>См. также:

- <xref:Microsoft.VisualBasic.Information.Err%2A>
- <xref:System.Exception>
- [Оператор Exit](exit-statement.md)
- [Оператор On Error](on-error-statement.md)
- [Рекомендации по использованию фрагментов кода](/visualstudio/ide/best-practices-for-using-code-snippets)
- [Обработка исключений](../../../standard/parallel-programming/exception-handling-task-parallel-library.md)
- [Оператор Throw](throw-statement.md)
