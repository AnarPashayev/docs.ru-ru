---
title: Попробуйте... Перехватить... Оператор finally
description: Узнайте, как использовать обработку исключений с инструкциями Visual Basic try/catch/finally.
ms.date: 12/07/2018
f1_keywords:
- vb.Try...Catch...Finally
- vb.when
- vb.Finally
- vb.Catch
- vb.Try
helpviewer_keywords:
- Try...Catch...Finally statements
- Try statement [Visual Basic]
- try-catch exception handling, Try...Catch...Finally statements
- error handling, while running code
- Try statement [Visual Basic], Try...Catch...Finally
- Finally keyword [Visual Basic], Try...Catch...Finally
- Catch statement [Visual Basic]
- When keyword [Visual Basic]
- Visual Basic code, handling errors while running
- structured exception handling, Try...Catch...Finally statements
ms.assetid: d6488026-ccb3-42b8-a810-0d97b9d6472b
ms.openlocfilehash: 22f1611786a3da512632b5b547b7ef141c8f65c6
ms.sourcegitcommit: f8c270376ed905f6a8896ce0fe25b4f4b38ff498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/04/2020
ms.locfileid: "84391772"
---
# <a name="trycatchfinally-statement-visual-basic"></a>Оператор Try... Catch... Finally (Visual Basic)

Предоставляет способ управления некоторыми или всеми возможными ошибками, которые могут возникнуть в данном блоке кода, при этом выполняется код.

## <a name="syntax"></a>Синтаксис

```vb
Try
    [ tryStatements ]
    [ Exit Try ]
[ Catch [ exception [ As type ] ] [ When expression ]
    [ catchStatements ]
    [ Exit Try ] ]
[ Catch ... ]
[ Finally
    [ finallyStatements ] ]
End Try
```

## <a name="parts"></a>Компоненты

|Термин|Определение|
|---|---|
|`tryStatements`|Необязательный элемент. Операторы, в которых может возникнуть ошибка. Может быть составным оператором.|
|`Catch`|Необязательный элемент. `Catch`Разрешено несколько блоков. Если при обработке блока возникает исключение, `Try` Каждая `Catch` инструкция проверяется в текстовом порядке, чтобы определить, обрабатывается ли исключение, и `exception` представляет исключение, которое было выдано.|
|`exception`|Необязательный элемент. Любое имя переменной. Начальное значение `exception` — это значение возникшей ошибки. Используется с `Catch` для указания перехваченной ошибки. Если этот параметр опущен, `Catch` инструкция перехватывает любое исключение.|
|`type`|Необязательный элемент. Указывает тип фильтра класса. Если значение относится к `exception` типу, заданному параметром `type` или производного типа, идентификатор привязывается к объекту исключения.|
|`When`|Необязательный элемент. `Catch`Оператор с `When` предложением перехватывает исключения только в том случае `expression` , если значение равно `True` . `When`Предложение применяется только после проверки типа исключения и `expression` может ссылаться на идентификатор, представляющий исключение.|
|`expression`|Необязательный элемент. Должен быть неявно преобразуемым в `Boolean` . Любое выражение, описывающее универсальный фильтр. Обычно используется для фильтрации по номеру ошибки. Используется с `When` ключевым словом для указания обстоятельств, при которых ошибка перехвачена.|
|`catchStatements`|Необязательный элемент. Инструкции для управления ошибками, происходящими в связанном `Try` блоке. Может быть составным оператором.|
|`Exit Try`|Необязательный элемент. Ключевое слово, которое нарушает `Try...Catch...Finally` структуру. Выполнение возобновляется с помощью кода, непосредственно следующего за `End Try` оператором. `Finally`Инструкция будет по-прежнему выполняться. Не допускается в `Finally` блоках.|
|`Finally`|Необязательный элемент. `Finally`Блок всегда выполняется, когда выполнение покидает любую часть `Try...Catch` инструкции.|
|`finallyStatements`|Необязательный элемент. Инструкции, которые выполняются после возникновения всех других ошибок обработки.|
|`End Try`|Завершает `Try...Catch...Finally` структуру.|

## <a name="remarks"></a>Комментарии

Если предполагается, что конкретное исключение может возникнуть во время определенного раздела кода, разместите код в `Try` блоке и используйте `Catch` блок для удержания управления и обработайте исключение, если оно происходит.

`Try…Catch`Оператор состоит из `Try` блока, за которым следует одно или несколько `Catch` предложений, которые задают обработчики для различных исключений. При возникновении исключения в `Try` блоке Visual Basic ищет `Catch` инструкцию, которая обрабатывает исключение. Если соответствующий `Catch` оператор не найден, Visual Basic проверяет метод, который вызвал текущий метод, и т. д. в стеке вызовов. Если `Catch` блок не найден, Visual Basic отображает пользователю сообщение о необработанном исключении и останавливает выполнение программы.

В операторе можно использовать более одной `Catch` инструкции `Try…Catch` . В этом случае порядок `Catch` предложений важен, так как они анализируются по порядку. Перехватывайте более конкретные исключения перед менее конкретными.

Следующие `Catch` условия инструкции являются наименее конкретными, и будут перехватывать все исключения, производные от <xref:System.Exception> класса. Обычно следует использовать один из этих вариантов в качестве последнего `Catch` блока в `Try...Catch...Finally` структуре после перехвата всех конкретных исключений. Поток управления никогда не может достичь `Catch` блока, который следует за одним из этих вариантов.

- Например `type` `Exception` :`Catch ex As Exception`

- Оператор не имеет `exception` переменной, например:`Catch`

Если `Try…Catch…Finally` инструкция вложена в другой `Try` блок, Visual Basic сначала проверяет каждую `Catch` инструкцию во внутреннем `Try` блоке. Если соответствующий `Catch` оператор не найден, поиск продолжается до `Catch` инструкций внешнего `Try…Catch…Finally` блока.

Локальные переменные из `Try` блока недоступны в `Catch` блоке, так как они являются отдельными блоками. Если вы хотите использовать переменную более чем в одном блоке, объявите переменную за пределами `Try...Catch...Finally` структуры.

> [!TIP]
> `Try…Catch…Finally`Инструкция доступна в виде фрагмента кода IntelliSense. В диспетчере фрагментов кода разверните узел **шаблоны кода — Если для каждого, попробуйте перехватить, свойство и т. д**., а затем — **Обработка ошибок (исключения)**. Дополнительные сведения см. в статье [Фрагменты кода](/visualstudio/ide/code-snippets).

## <a name="finally-block"></a>Блок finally

Если имеется одна или несколько инструкций, которые должны выполняться до выхода из `Try` структуры, используйте `Finally` блок. Управление передается `Finally` блоку непосредственно перед его передачей из `Try…Catch` структуры. Это справедливо даже в том случае, если исключение происходит в любой точке `Try` структуры.

`Finally`Блок полезен для выполнения любого кода, который должен выполняться, даже если возникает исключение. Элемент управления передается `Finally` блоку независимо от того, как `Try...Catch` блок завершает работу.

Код в `Finally` блоке выполняется, даже если код встречает `Return` инструкцию в `Try` `Catch` блоке или. Элемент управления не передается `Try` из `Catch` блока или в соответствующий `Finally` блок в следующих случаях:

- [Оператор End](end-statement.md) встречается в `Try` `Catch` блоке или.

- <xref:System.StackOverflowException>Исключение создается в `Try` `Catch` блоке или.

Не допускается явное перенаправление выполнения в `Finally` блок. Передача выполнения из `Finally` блока недопустима, за исключением исключения.

Если `Try` инструкция не содержит хотя бы один `Catch` блок, она должна содержать `Finally` блок.

> [!TIP]
> Если не нужно перехватывать определенные исключения, `Using` инструкция ведет себя как `Try…Finally` блок и гарантирует утилизацию ресурсов независимо от того, как вы выйдете из блока. Это справедливо даже при необработанном исключении. Дополнительные сведения см. в разделе [оператор using](using-statement.md).

## <a name="exception-argument"></a>Аргумент исключения

`Catch`Аргумент блока `exception` является экземпляром <xref:System.Exception> класса или классом, производным от `Exception` класса. `Exception`Экземпляр класса соответствует ошибке, произошедшей в `Try` блоке.

Свойства `Exception` объекта помогают определить причину и расположение исключения. Например, <xref:System.Exception.StackTrace%2A> свойство перечисляет вызываемые методы, которые привели к исключению, помогая найти место возникновения ошибки в коде. <xref:System.Exception.Message%2A>Возвращает сообщение, описывающее исключение. <xref:System.Exception.HelpLink%2A>Возвращает ссылку на связанный файл справки. <xref:System.Exception.InnerException%2A>Возвращает `Exception` объект, который привел к текущему исключению, или возвращается `Nothing` при отсутствии исходного `Exception` .

## <a name="considerations-when-using-a-trycatch-statement"></a>Рекомендации по использованию try... Оператор catch

Используйте `Try…Catch` оператор, чтобы сообщить о возникновении необычных или непредвиденных событий программы. К таким причинам относятся следующие.

- Перехват исключений во время выполнения создает дополнительные издержки и, скорее всего, будет медленнее, чем Предварительная проверка, чтобы избежать исключений.

- Если `Catch` блок обрабатывается неправильно, исключение может быть неправильно сообщено пользователям.

- Обработка исключений делает программу более сложной.

Не всегда требуется `Try…Catch` оператор для проверки условия, которое может произойти. В следующем примере проверяется, существует ли файл, прежде чем пытаться его открыть. Это уменьшает необходимость в перехвате исключения, вызываемого <xref:System.IO.File.OpenText%2A> методом.

[!code-vb[VbVbalrStatements#94](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class1.vb#94)]

Убедитесь, что код в `Catch` блоках может правильно сообщать об исключениях пользователям, независимо от того, является ли он потокобезопасным или соответствующим сообщением. В противном случае исключения могут остаться неизвестными.

## <a name="async-methods"></a>Асинхронные методы

Если метод помечается модификатором [Async](../modifiers/async.md) , можно использовать оператор [await](../operators/await-operator.md) в методе. Оператор с `Await` оператором приостанавливает выполнение метода до тех пор, пока не завершится ожидаемая задача. Задача представляет выполняющуюся работу. Когда задача, связанная с `Await` оператором, завершается, выполнение возобновляется в том же методе. Дополнительные сведения см. [в разделе поток управления в асинхронных программах](../../programming-guide/concepts/async/control-flow-in-async-programs.md).

Задача, возвращаемая асинхронным методом, может завершиться с ошибкой, что означает, что она завершилась из-за необработанного исключения. Задача также может завершаться в отмененном состоянии, что приводит к `OperationCanceledException` возникновению исключения из выражения await. Чтобы перехватить исключение любого типа, поместите `Await` выражение, связанное с задачей, в `Try` блок и перехватите исключение в `Catch` блоке. Пример приведен далее в этом разделе.

Задача может находиться в неисправном состоянии, так как за ее сбоем отвечает несколько исключений. Например, задача может быть результатом вызова метода <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType>. При ожидании такой задачи Перехваченное исключение является только одним из исключений, и вы не можете предсказать, какое исключение будет перехвачено. Пример приведен далее в этом разделе.

`Await`Выражение не может находиться внутри `Catch` блока или `Finally` блока.

## <a name="iterators"></a>Iterators

Функция итератора или `Get` метод доступа выполняет настраиваемую итерацию по коллекции. Итератор использует оператор [yield](yield-statement.md) для возвращения каждого элемента коллекции по одному за раз. Для вызова функции-итератора используется оператор [For Each... Следующий оператор](for-each-next-statement.md).

`Yield`Оператор может находиться внутри `Try` блока. `Try`Блок, содержащий `Yield` оператор, может иметь `Catch` блоки и может иметь `Finally` блок. Пример см. в разделе "пробные блоки в Visual Basic" [итераторов](../../programming-guide/concepts/iterators.md) .

`Yield`Оператор не может находиться внутри `Catch` блока или блока `Finally` .

Если `For Each` тело (за пределами функции итератора) создает исключение, `Catch` блок в функции итератора не выполняется, но `Finally` выполняется блок в функции iterator. `Catch`Блок внутри функции итератора перехватывает только исключения, происходящие внутри функции итератора.

## <a name="partial-trust-situations"></a>Ситуации частичного доверия

В ситуациях частичного доверия, таких как приложение, размещенное в общей сетевой папке, не `Try...Catch...Finally` перехватывает исключения безопасности, происходящие до вызова метода, содержащего вызов. В следующем примере, когда вы помещаете его на серверный ресурс и выполняете его, вызывается ошибка "System. Security. SecurityException: запрос не выполнен". Дополнительные сведения об исключениях безопасности см. в разделе <xref:System.Security.SecurityException> класс.

[!code-vb[VbVbalrStatements#85](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class1.vb#85)]

В подобной ситуации частичного доверия необходимо разместить `Process.Start` оператор в отдельном `Sub` . Начальный вызов метода `Sub` завершится ошибкой. Это позволяет `Try...Catch` перехватить его перед `Sub` запуском, который содержит, `Process.Start` и созданным исключением безопасности.

## <a name="examples"></a>Примеры

### <a name="the-structure-of-trycatchfinally"></a>Структура try... Перехватить... Счете

В следующем примере показана структура `Try...Catch...Finally` инструкции.

[!code-vb[VbVbalrStatements#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class1.vb#86)]  

### <a name="exception-in-a-method-called-from-a-try-block"></a>Исключение в методе, вызываемом из блока try

В следующем примере `CreateException` метод создает исключение `NullReferenceException` . Код, создающий исключение, не находится в `Try` блоке. Поэтому `CreateException` метод не обрабатывает исключение. `RunSample`Метод обрабатывает исключение, так как вызов `CreateException` метода находится в `Try` блоке.

Пример включает в себя `Catch` инструкции для нескольких типов исключений, упорядоченные от наиболее конкретных к наиболее общим.

[!code-vb[VbVbalrStatements#91](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class1.vb#91)]

### <a name="the-catch-when-statement"></a>Оператор Catch When

В следующем примере показано, как использовать `Catch When` инструкцию для фильтрации по условному выражению. Если условное выражение имеет значение `True` , код в `Catch` блоке выполняется.

[!code-vb[VbVbalrStatements#92](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class1.vb#92)]

### <a name="nested-try-statements"></a>Вложенные операторы Try

В следующем примере содержится `Try…Catch` оператор, содержащийся в `Try` блоке. Внутренний `Catch` блок создает исключение, `InnerException` для свойства которого задано исходное исключение. Внешний `Catch` блок сообщает свое собственное исключение и внутреннее исключение.

[!code-vb[VbVbalrStatements#93](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class1.vb#93)]

### <a name="exception-handling-for-async-methods"></a>Обработка исключений для асинхронных методов

В следующем примере демонстрируется обработка исключений для асинхронных методов. Чтобы перехватить исключение, которое применяется к асинхронной задаче, `Await` выражение находится в `Try` блоке вызывающего объекта, а исключение перехвачено в `Catch` блоке.

Раскомментируйте строку `Throw New Exception` в этом примере для демонстрации обработки исключений. Исключение перехвачено в `Catch` блоке, `IsFaulted` свойство задачи имеет значение `True` , а `Exception.InnerException` для свойства задачи задано исключение.

Раскомментируйте строку `Throw New OperationCancelledException`, чтобы показать, что происходит при отмене асинхронного процесса. Исключение перехвачено в `Catch` блоке, а `IsCanceled` свойство задачи имеет значение `True` . Однако при некоторых условиях, которые не применяются к этому примеру, параметру присваивается значение, а параметру присваивается `IsFaulted` `True` `IsCanceled` значение `False` .

[!code-vb[csAsyncExceptions#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/csasyncexceptions/vb/class1.vb#1)]

### <a name="handling-multiple-exceptions-in-async-methods"></a>Обработка нескольких исключений в асинхронных методах

В следующем примере демонстрируется обработка исключений, когда несколько задач могут привести к нескольким исключениям. `Try`Блок содержит `Await` выражение для <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> возвращаемой задачи. Задача завершится, когда будут выполнены три задачи, к которым <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> применяется.

Каждая из трех задач вызывает исключение. `Catch`Блок проходит по исключениям, которые находятся в `Exception.InnerExceptions` свойстве `Task.WhenAll` возвращаемой задачи.

[!code-vb[csAsyncExceptions#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/csasyncexceptions/vb/class1.vb#3)]

## <a name="see-also"></a>См. также раздел

- <xref:Microsoft.VisualBasic.Information.Err%2A>
- <xref:System.Exception>
- [Оператор Exit](exit-statement.md)
- [Оператор On Error](on-error-statement.md)
- [Рекомендации по использованию фрагментов кода](/visualstudio/ide/best-practices-for-using-code-snippets)
- [Обработка исключений](../../../standard/parallel-programming/exception-handling-task-parallel-library.md)
- [Оператор Throw](throw-statement.md)
