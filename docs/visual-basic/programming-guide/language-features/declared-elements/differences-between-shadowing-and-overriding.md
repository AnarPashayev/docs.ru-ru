---
title: Различия между удаленным управлением и переопределением
ms.date: 07/20/2015
helpviewer_keywords:
- shadowing, vs. overriding
- overriding, vs. shadowing
ms.assetid: 2d014a0b-7630-407d-8f4e-24bd87987923
ms.openlocfilehash: 8d1ebdcd0a23dff69a7acca22268c03e30ec06d9
ms.sourcegitcommit: 17ee6605e01ef32506f8fdc686954244ba6911de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/22/2019
ms.locfileid: "74345418"
---
# <a name="differences-between-shadowing-and-overriding-visual-basic"></a>Различия между сокрытием и переопределением (Visual Basic)
При определении класса, который наследуется от базового класса, иногда требуется переопределить один или несколько элементов базового класса в производном классе. Для этой цели доступны как затенение, так и переопределение.  
  
## <a name="comparison"></a>Сравнение  
 Затенение и переопределение используются и при наследовании производного класса от базового класса, и при одновременном определении одного объявленного элемента с другим. Но существуют значительные различия между ними.  
  
 В следующей таблице сравнивается затенение с переопределением.  
  
||||  
|---|---|---|  
|Точка сравнения|Удаленное управление|переопределение|  
|Цель|Обеспечивает защиту от последующего изменения базового класса, которое вводит член, уже определенный в производном классе|Достижение полиморфизма путем определения другой реализации процедуры или свойства с одной и той же вызывающей последовательностью<sup>1</sup>|  
|Переопределенный элемент|Любой объявленный тип элемента|Только процедура (`Function`, `Sub`или `Operator`) или свойство|  
|Переопределяющий элемент|Любой объявленный тип элемента|Только процедура или свойство с одинаковой вызывающей последовательностью<sup>1</sup>|  
|Уровень доступа переопределяющего элемента|Любой уровень доступа|Невозможно изменить уровень доступа переопределенного элемента|  
|Удобочитаемость и записи переопределения элемента|Любое сочетание|Невозможно изменить удобочитаемость или записи переопределенного свойства|  
|Управление переопределением|Элемент базового класса не может принудительно применять или запрещать тень|В элементе базового класса можно указать `MustOverride`, `NotOverridable`или `Overridable`|  
|Использование ключевого слова|`Shadows` рекомендуется в производном классе; `Shadows` предполагается, если не указаны ни `Shadows`, ни `Overrides`<sup>2</sup>|в базовом классе требуется `Overridable` или `MustOverride`; `Overrides` требуется в производном классе|  
|Наследование переопределения элементов классами, производными от производного класса|Элемент с тенью, наследуемый более производными классами; затененный элемент по-прежнему скрыт<sup>3</sup>|Переопределяющий элемент, наследуемый более производными классами; переопределенный элемент все еще переопределен|  
  
 <sup>1</sup> *вызывающая последовательность* состоит из типа элемента (`Function`, `Sub`, `Operator`или `Property`), имени, списка параметров и типа возвращаемого значения. Процедуру нельзя переопределить с помощью свойства или наоборот. Нельзя переопределить один тип процедуры (`Function`, `Sub`или `Operator`) другим типом.  
  
 <sup>2</sup> если не указать ни `Shadows`, ни `Overrides`, компилятор выдает предупреждающее сообщение, помогающее определить, какой тип переопределения вы хотите использовать. При пропуске предупреждения используется механизм теневого копирования.  
  
 <sup>3</sup> если элемент с тенью недоступен в последующем производном классе, то затенение не наследуется. Например, если объявить элемент с тенью как `Private`, то класс, производный от производного класса, наследует исходный элемент, а не затененный элемент.  
  
## <a name="guidelines"></a>Рекомендации  
 Обычно переопределение используется в следующих случаях:  
  
- Вы определяете классы, производные от полиморфизма.  
  
- Необходимо обеспечить безопасность, чтобы компилятор принудительно применяет идентичный тип элемента и вызывающую последовательность.  
  
 Затенение обычно используется в следующих случаях:  
  
- Предполагается, что базовый класс может быть изменен и определен элемент с тем же именем, что и у вашего.  
  
- Требуется свобода изменения типа элемента или последовательности вызовов.  
  
## <a name="see-also"></a>См. также

- [Ссылки на объявленные элементы](../../../../visual-basic/programming-guide/language-features/declared-elements/references-to-declared-elements.md)
- [Затенение в Visual Basic](../../../../visual-basic/programming-guide/language-features/declared-elements/shadowing.md)
- [Практическое руководство. Сокрытие переменной с тем же именем, что и ваша переменная](../../../../visual-basic/programming-guide/language-features/declared-elements/how-to-hide-a-variable-with-the-same-name-as-your-variable.md)
- [Практическое руководство. Сокрытие наследуемой переменной](../../../../visual-basic/programming-guide/language-features/declared-elements/how-to-hide-an-inherited-variable.md)
- [Практическое руководство. Доступ к переменной, скрытой производным классом](../../../../visual-basic/programming-guide/language-features/declared-elements/how-to-access-a-variable-hidden-by-a-derived-class.md)
- [Shadows](../../../../visual-basic/language-reference/modifiers/shadows.md)
- [Переопределения](../../../../visual-basic/language-reference/modifiers/overrides.md)
