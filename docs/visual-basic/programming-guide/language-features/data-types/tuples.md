---
title: Кортежи в Visual Basic
ms.date: 04/23/2017
helpviewer_keywords:
- tuples [Visual Basic]
ms.assetid: 3e66cd1b-3432-4e1d-8c37-5ebacae8f53f
ms.openlocfilehash: 146e9c2360cea153d2f487769d5b983516861e8d
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61663301"
---
# <a name="tuples-visual-basic"></a>Кортежи (Visual Basic)

Начиная с Visual Basic 2017, язык Visual Basic предлагает встроенную поддержку для кортежей, которая делает создание кортежей и обращение к элементов кортежей, проще. Кортеж — это структура данных нетребовательный к ресурсам, с определенным номером и последовательность значений. При создании экземпляра кортежа, вы определяете, номер и тип данных каждого значения (или элемент). Например 2 кортежей (или пара) состоит из двух элементов. Возможно, первый `Boolean` значения, второй — `String`. Поскольку кортежи позволяют легко для сохранения нескольких значений в одном объекте, они часто используются как простой способ возврата нескольких значений из метода.

> [!IMPORTANT]
> Требуется поддержка кортежей <xref:System.ValueTuple> типа. Если .NET Framework 4.7 не установлена, необходимо добавить пакет NuGet `System.ValueTuple`, который можно найти в коллекции NuGet. Без этого пакета может появиться ошибка компиляции аналогичную «Предопределенный тип «ValueTuple(Of,,,)» не определен и не импортирован.»

## <a name="instantiating-and-using-a-tuple"></a>Создание экземпляра и использование кортежа

Создать кортеж, заключив его круглые скобки обмена мгновенными сообщениями значений с разделителями запятыми. Затем каждое из этих значений становится полем элемента кортежа. Например, следующий код определяет triple (или трех кортежей) с `Date` как его первое значение `String` как второй и `Boolean` как третьего.

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#1)]

По умолчанию имя каждого поля в кортеже включает строку `Item` вместе с положением от единицы поля в кортеже. Для этого 3 кортежа `Date` поле является `Item1`, `String` поле является `Item2`и `Boolean` поле является `Item3`. В следующем примере отображаются значения полей кортежа, созданный в предыдущей строке кода

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#2)]

Полей кортежа Visual Basic доступны для чтения и записи; После создания экземпляра кортежа его значения можно изменить. В следующем примере два из трех полей кортежа, созданные в предыдущем примере изменяет и отображает результат.

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#3)]

## <a name="instantiating-and-using-a-named-tuple"></a>Создание экземпляра и использование именованного кортежа

Вместо того чтобы использовать имена по умолчанию для полей кортежа, можно создать экземпляр *именованный кортеж* путем назначения собственные имена элементов кортежа. Поля кортежа может осуществляться по именам назначенных *или* по их именам по умолчанию. В следующем примере создается же трем кортежам как ранее, за исключением того, что она явно указана первое поле `EventDate`, второй `Name`, а третий `IsHoliday`. Затем он отображает значения полей, изменяет их и повторно отображает значения полей.

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#4)]

## <a name="inferred-tuple-element-names"></a>Выводимые имена элементов кортежа

Начиная с версии 15.3 Visual Basic, Visual Basic может вывести имена элементов кортежа; необходимо назначить их явно. Кортеж выводимые имена полезны при инициализации кортежа из набора переменных, и вы хотите использовать имя элемента кортежа должен совпадать с именем переменной. 

В следующем примере создается `stateInfo` кортеж, содержащий три явно именованные элементы, `state`, `stateName`, и `capital`. Обратите внимание, что в именах элементов, оператора инициализации кортежа просто присваивает именованных элементов значения переменных с одинаковыми именами.

[!code-vb[ExplicitlyNamed](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#1)]
 
Так как элементы и переменные имеют тем же именем, компилятор Visual Basic может вывести имена полей, как показано в следующем примере.

[!code-vb[ExplicitlyNamed](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

Чтобы включить выводимые имена элементов кортежа, необходимо определить версии компилятора Visual Basic для использования в проекте Visual Basic (\*.vbproj) файла: 

```xml 
<PropertyGroup> 
  <LangVersion>15.3</LangVersion> 
</PropertyGroup> 
```

Номер версии может быть любой версии компилятора Visual Basic, начиная с версии 15.3. Вместо того чтобы жестко программировать определенной версией компилятора, можно также указать «Latest» для параметра `LangVersion` для компиляции с самой последней версии компилятора Visual Basic, установленного на компьютере.

Дополнительные сведения см. в разделе [параметр версии языка Visual Basic](../../../language-reference/configure-language-version.md).

В некоторых случаях компилятор Visual Basic не может определить имя элемента кортежа из имя кандидата, и поле кортежа может ссылаться только с помощью его имя по умолчанию, например `Item1`, `Item2`и т. д. Сюда входит следующее.

- Имя кандидата является таким же, как имя элемента кортежа, такие как `Item3`, `Rest`, или `ToString`.

- Имя кандидата дублируется в кортеже.
 
Если не удается вывести имя поля, Visual Basic не создает ошибку компилятора, а также является исключение, возникающее во время выполнения. Вместо этого поля кортежа должны иметь двухкомпонентные их предопределенные имена, такие как `Item1` и `Item2`. 
  
## <a name="tuples-versus-structures"></a>Кортежи и структур

Кортеж Visual Basic — это тип значения, который является экземпляром любого **System.ValueTuple** универсальных типов. Например `holiday` кортеж, определяемый в предыдущем примере является экземпляром класса <xref:System.ValueTuple%603> структуры. Он должен быть упрощенный контейнер для данных. Так как кортеж стремится упростить процесс для создания объекта с несколькими элементами данных, у него нет некоторых функций, которые могут иметь пользовательская структура. Сюда входит следующее.

- Пользовательские элементы. Нельзя определить свои собственные свойства, методы или события для кортежа.

- Проверка. Невозможно проверить данные, назначенных полей.

- Неизменность. Кортежи Visual Basic являются изменяемыми. Напротив пользовательская структура позволяет контролировать, имеет ли экземпляр изменяемым или неизменяемым.

Если пользовательские элементы, свойства и проверка полей или неизменность важны, следует использовать Visual Basic [структуры](../../../language-reference/statements/structure-statement.md) инструкцию, чтобы определить тип пользовательское значение.

Кортеж Visual Basic наследовать члены его **ValueTuple** типа. В дополнение к его поля к ним относятся следующие методы:

| Член | Описание |
| ---|---|
| CompareTo | Сравнивает текущий кортеж для другой кортеж с одинаковое количество элементов. |
| Равно | Определяет, равен ли текущий кортеж с другой кортеж или объектом. |
| GetHashCode | Вычисляет хэш-код для текущего экземпляра. |
| ToString | Возвращает строковое представление этого кортежа, который принимает форму `(Item1, Item2...)`, где `Item1` и `Item2` представляют значения полей кортежа. |

Кроме того **ValueTuple** типы реализуют <xref:System.Collections.IStructuralComparable> и <xref:System.Collections.IStructuralEquatable> интерфейсы, которые позволяют определять компараторы клиента.

## <a name="assignment-and-tuples"></a>Назначение и кортежи

Visual Basic поддерживает назначения между типами кортежей с одинаковым количеством полей. Можно преобразовать типы полей, если выполняется одно из следующих:

- Исходные и целевые поля имеют тот же тип.

- Расширяющее (или неявное) преобразования типа источника в целевой тип определен. 

- `Option Strict` является `On`, и определяется сужением (или неявного) преобразования типа источника в целевой тип. Это преобразование может создавать исключения, если исходное значение находится вне диапазона типа целевого объекта.

Другие преобразования в контексте назначений не учитываются. Рассмотрим возможные виды назначений между типами кортежей.

В приведенных ниже примерах можно использовать указанные переменные:

[!code-vb[Assign](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple3.vb#1)]

Первые две переменные, `unnamed` и `anonymous`, не имеют предоставленных полям семантические имена. По умолчанию используются соответствующие имена полей `Item1` и `Item2`. Последние две переменные, `named` и `differentName` иметь имена полей семантики. Обратите внимание на то, что поля в этих двух кортежах называются по-разному.

Все четыре этих кортежа имеют одинаковое количество полей (называется «арность»), а типы этих полей идентичны. Таким образом, все эти назначения работают:

[!code-vb[Assign](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple3.vb#2)]

Обратите внимание на то, что имена кортежей не назначаются. Значения полей назначаются в соответствии с порядком полей в кортеже.

Наконец, обратите внимание, что можно назначить `named` кортеж `conversion` кортежа, несмотря на то что в первое поле `named` — `Integer`и в первое поле `conversion` является `Long`. Это назначение завершается успешно, поскольку преобразование `Integer` для `Long` расширяющие преобразования.

[!code-vb[Assign](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple3.vb#3)]

Кортежи с различным количеством полей не назначаются:

```vb
' Does not compile.
' VB30311: Value of type '(Integer, Integer, Integer)' cannot be converted
'          to '(Answer As Integer, Message As String)'
var differentShape = (1, 2, 3)
named = differentShape
```

## <a name="tuples-as-method-return-values"></a>Кортежи как возвращаемые значения методов

Метод может возвращать только одно значение. Часто Однако требуется вызов метода для возврата нескольких значений. Существует несколько способов обойти это ограничение:

- Можно создать пользовательский класс или структуру, свойства или поля представляют значения, возвращаемые этим методом. Таким образом — это трудоемкое решение; его необходимо определить пользовательский тип, единственным назначением которого является для извлечения значений из вызова метода.

- Вам могут возвращать одиночное значение из метода и остальные значения путем их передачи по ссылке в метод. Это включает в себя затраты на создание экземпляров переменной и риски, случайно перезаписать значение переменной, которая передается по ссылке.

- Можно использовать кортеж, который предоставляет упрощенного решения для извлечения нескольких возвращаемых значений.

Например **TryParse** методы возврата .NET `Boolean` значение, указывающее, успешно ли выполнена операция синтаксического анализа. Результат операции анализа возвращается в переменную, переданную по ссылке в метод. Как правило, вызов метода синтаксического анализа, такие как <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> выглядит следующим образом:

[!code-vb[Return](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#1)]

Мы может возвращать кортеж из операции анализа, если мы Подведем краткие вызов <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> в нашем собственном методе. В следующем примере `NumericLibrary.ParseInteger` вызовы <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> метод и возвращает именованный кортеж с двумя элементами. 

[!code-vb[Return](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

Затем можно вызвать метод с помощью следующего кода:

[!code-vb[Return](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)]

## <a name="visual-basic-tuples-and-tuples-in-the-net-framework"></a>Visual Basic кортежи и кортежи, в .NET Framework

Кортеж Visual Basic — это экземпляр одного из **System.ValueTuple** универсальных типов, которые впервые появились в .NET Framework 4.7. .NET Framework также включает набор универсальных **System.Tuple** классы. Эти классы, тем не менее, отличаются от кортежей Visual Basic и **System.ValueTuple** универсальных типов в несколькими способами:

- Элементы **кортежа** классы являются свойства с именем `Item1`, `Item2`, и т. д. В Visual Basic кортежей и **ValueTuple** типы, элементы кортежа: поля.

- Элементы нельзя назначить значимые имена **кортежа** экземпляра или **ValueTuple** экземпляра. Visual Basic позволяет присваивать имена, которые обмениваются данными значение поля.

- Свойства **кортежа** экземпляра доступны только для чтения; кортежи неизменны. В Visual Basic кортежей и **ValueTuple** типов, полей кортежа доступны для чтения и записи; кортежи являются изменяемыми.

- Универсальный **кортежа** типы являются ссылочными типами. Используя эти **кортежа** типы происходит распределение объектов. В критических путях это может заметно влиять на производительность приложения. Кортежи Visual Basic и **ValueTuple** типы являются типами значений.

Методы расширения в <xref:System.TupleExtensions> класс упрощают преобразование кортежей Visual Basic и .NET **кортежа** объектов. **ToTuple** метод преобразует кортеж Visual Basic .NET **кортежа** объекта и **ToValueTuple** метод преобразует .NET **кортежа** Объект, в кортеж Visual Basic.

Следующий пример создает кортеж, преобразует его в .NET **кортежа** объекта и преобразует его обратно в кортеж Visual Basic. Затем в примере сравнивается этого кортежа с исходной схемы, чтобы убедиться, что они равны.

[!code-vb[Convert](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple2.vb#1)]

## <a name="see-also"></a>См. также

- [Справочник по языку Visual Basic](index.md)
