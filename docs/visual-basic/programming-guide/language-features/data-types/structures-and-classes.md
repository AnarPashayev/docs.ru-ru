---
title: Структуры и классы
ms.date: 07/20/2015
helpviewer_keywords:
- classes [Visual Basic], vs. structures
- structures [Visual Basic]
- classes [Visual Basic]
- structures [Visual Basic], compared to classes
- structures [Visual Basic], structure variables
- structure variables [Visual Basic]
ms.assetid: a221e74a-ffcf-4bdc-a0f6-a088a9bf26cc
ms.openlocfilehash: 3353935a74bb77fa4a630e706aa425063c7a610a
ms.sourcegitcommit: 17ee6605e01ef32506f8fdc686954244ba6911de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/22/2019
ms.locfileid: "74346328"
---
# <a name="structures-and-classes-visual-basic"></a><span data-ttu-id="3afc1-102">Структуры и классы (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="3afc1-102">Structures and Classes (Visual Basic)</span></span>
<span data-ttu-id="3afc1-103">Visual Basic объединяет синтаксис структур и классов, в результате чего обе сущности поддерживают большинство одних и тех же функций.</span><span class="sxs-lookup"><span data-stu-id="3afc1-103">Visual Basic unifies the syntax for structures and classes, with the result that both entities support most of the same features.</span></span> <span data-ttu-id="3afc1-104">Однако существуют и важные различия между структурами и классами.</span><span class="sxs-lookup"><span data-stu-id="3afc1-104">However, there are also important differences between structures and classes.</span></span>  
  
 <span data-ttu-id="3afc1-105">Классы имеют преимущество ссылочных типов — передача ссылки более эффективна, чем передача переменной структуры со всеми ее данными.</span><span class="sxs-lookup"><span data-stu-id="3afc1-105">Classes have the advantage of being reference types — passing a reference is more efficient than passing a structure variable with all its data.</span></span> <span data-ttu-id="3afc1-106">С другой стороны, структуры не нуждаются в выделении памяти в глобальной куче.</span><span class="sxs-lookup"><span data-stu-id="3afc1-106">On the other hand, structures do not require allocation of memory on the global heap.</span></span>  
  
 <span data-ttu-id="3afc1-107">Поскольку наследование из структуры невозможно, структуры следует использовать только для объектов, которые не нужно расширять.</span><span class="sxs-lookup"><span data-stu-id="3afc1-107">Because you cannot inherit from a structure, structures should be used only for objects that do not need to be extended.</span></span> <span data-ttu-id="3afc1-108">Используйте структуры, если создаваемый объект имеет небольшой размер экземпляра и учитывает характеристики производительности классов и структур.</span><span class="sxs-lookup"><span data-stu-id="3afc1-108">Use structures when the object you wish to create has a small instance size, and take into account the performance characteristics of classes versus structures.</span></span>  
  
## <a name="similarities"></a><span data-ttu-id="3afc1-109">Сходства</span><span class="sxs-lookup"><span data-stu-id="3afc1-109">Similarities</span></span>  
 <span data-ttu-id="3afc1-110">Структуры и классы похожи в следующих отношениях:</span><span class="sxs-lookup"><span data-stu-id="3afc1-110">Structures and classes are similar in the following respects:</span></span>  
  
- <span data-ttu-id="3afc1-111">Оба типа являются типами *контейнеров* , то есть они содержат другие типы в качестве членов.</span><span class="sxs-lookup"><span data-stu-id="3afc1-111">Both are *container* types, meaning that they contain other types as members.</span></span>  
  
- <span data-ttu-id="3afc1-112">Оба имеют члены, которые могут включать конструкторы, методы, свойства, поля, константы, перечисления, события и обработчики событий.</span><span class="sxs-lookup"><span data-stu-id="3afc1-112">Both have members, which can include constructors, methods, properties, fields, constants, enumerations, events, and event handlers.</span></span> <span data-ttu-id="3afc1-113">Однако не путайте эти члены с объявленными *элементами* структуры.</span><span class="sxs-lookup"><span data-stu-id="3afc1-113">However, do not confuse these members with the declared *elements* of a structure.</span></span>  
  
- <span data-ttu-id="3afc1-114">Члены обоих типов могут иметь индивидуальные уровни доступа.</span><span class="sxs-lookup"><span data-stu-id="3afc1-114">Members of both can have individualized access levels.</span></span> <span data-ttu-id="3afc1-115">Например, один элемент можно объявить `Public` и другой `Private`.</span><span class="sxs-lookup"><span data-stu-id="3afc1-115">For example, one member can be declared `Public` and another `Private`.</span></span>  
  
- <span data-ttu-id="3afc1-116">Оба могут реализовывать интерфейсы.</span><span class="sxs-lookup"><span data-stu-id="3afc1-116">Both can implement interfaces.</span></span>  
  
- <span data-ttu-id="3afc1-117">Оба могут иметь общие конструкторы с параметрами или без них.</span><span class="sxs-lookup"><span data-stu-id="3afc1-117">Both can have shared constructors, with or without parameters.</span></span>  
  
- <span data-ttu-id="3afc1-118">Оба свойства могут предоставлять *свойство по умолчанию*, если это свойство принимает по крайней мере один параметр.</span><span class="sxs-lookup"><span data-stu-id="3afc1-118">Both can expose a *default property*, provided that property takes at least one parameter.</span></span>  
  
- <span data-ttu-id="3afc1-119">Оба могут объявлять и создавать события, и оба могут объявлять делегаты.</span><span class="sxs-lookup"><span data-stu-id="3afc1-119">Both can declare and raise events, and both can declare delegates.</span></span>  
  
## <a name="differences"></a><span data-ttu-id="3afc1-120">Разница</span><span class="sxs-lookup"><span data-stu-id="3afc1-120">Differences</span></span>  
 <span data-ttu-id="3afc1-121">Структуры и классы отличаются в следующих особенности:</span><span class="sxs-lookup"><span data-stu-id="3afc1-121">Structures and classes differ in the following particulars:</span></span>  
  
- <span data-ttu-id="3afc1-122">Структуры являются *типами значений*; классы являются *ссылочными типами*.</span><span class="sxs-lookup"><span data-stu-id="3afc1-122">Structures are *value types*; classes are *reference types*.</span></span> <span data-ttu-id="3afc1-123">Переменная типа структуры содержит данные структуры, а не содержит ссылку на данные в качестве типа класса.</span><span class="sxs-lookup"><span data-stu-id="3afc1-123">A variable of a structure type contains the structure's data, rather than containing a reference to the data as a class type does.</span></span>  
  
- <span data-ttu-id="3afc1-124">Структуры используют выделение стека; классы используют выделение кучи.</span><span class="sxs-lookup"><span data-stu-id="3afc1-124">Structures use stack allocation; classes use heap allocation.</span></span>  
  
- <span data-ttu-id="3afc1-125">Все элементы структуры `Public` по умолчанию; переменные и константы класса `Private` по умолчанию, а другие члены класса по умолчанию `Public`.</span><span class="sxs-lookup"><span data-stu-id="3afc1-125">All structure elements are `Public` by default; class variables and constants are `Private` by default, while other class members are `Public` by default.</span></span> <span data-ttu-id="3afc1-126">Такое поведение членов класса обеспечивает совместимость с системой по умолчанию Visual Basic 6,0.</span><span class="sxs-lookup"><span data-stu-id="3afc1-126">This behavior for class members provides compatibility with the Visual Basic 6.0 system of defaults.</span></span>  
  
- <span data-ttu-id="3afc1-127">Структура должна иметь по крайней мере одну необщую переменную или ненастраиваемый нестандартный элемент события; класс может быть полностью пустым.</span><span class="sxs-lookup"><span data-stu-id="3afc1-127">A structure must have at least one nonshared variable or nonshared, noncustom event element; a class can be completely empty.</span></span>  
  
- <span data-ttu-id="3afc1-128">Элементы структуры не могут объявляться как `Protected`; члены класса могут.</span><span class="sxs-lookup"><span data-stu-id="3afc1-128">Structure elements cannot be declared as `Protected`; class members can.</span></span>  
  
- <span data-ttu-id="3afc1-129">Процедура структуры может управлять событиями только в том случае, если она является [общей](../../../../visual-basic/language-reference/modifiers/shared.md)`Sub`ной процедурой и только с помощью [оператора AddHandler](../../../../visual-basic/language-reference/statements/addhandler-statement.md). Любая процедура класса может обрабатывать события с помощью ключевого слова [Handles](../../../../visual-basic/language-reference/statements/handles-clause.md) или оператора `AddHandler`.</span><span class="sxs-lookup"><span data-stu-id="3afc1-129">A structure procedure can handle events only if it is a [Shared](../../../../visual-basic/language-reference/modifiers/shared.md)`Sub` procedure, and only by means of the [AddHandler Statement](../../../../visual-basic/language-reference/statements/addhandler-statement.md); any class procedure can handle events, using either the [Handles](../../../../visual-basic/language-reference/statements/handles-clause.md) keyword or the `AddHandler` statement.</span></span> <span data-ttu-id="3afc1-130">Дополнительные сведения см. в статье [Events (Visual Basic)](../../../../visual-basic/programming-guide/language-features/events/index.md) (События в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="3afc1-130">For more information, see [Events](../../../../visual-basic/programming-guide/language-features/events/index.md).</span></span>  
  
- <span data-ttu-id="3afc1-131">В объявлениях переменных структуры не могут указываться инициализаторы или исходные размеры для массивов; объявления переменных класса могут.</span><span class="sxs-lookup"><span data-stu-id="3afc1-131">Structure variable declarations cannot specify initializers or initial sizes for arrays; class variable declarations can.</span></span>  
  
- <span data-ttu-id="3afc1-132">Структуры неявным образом наследуют от класса <xref:System.ValueType?displayProperty=nameWithType> и не могут наследоваться от любого другого типа. классы могут наследовать от любого класса или классов, кроме <xref:System.ValueType?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3afc1-132">Structures implicitly inherit from the <xref:System.ValueType?displayProperty=nameWithType> class and cannot inherit from any other type; classes can inherit from any class or classes other than <xref:System.ValueType?displayProperty=nameWithType>.</span></span>  
  
- <span data-ttu-id="3afc1-133">Структуры не наследуются; классы.</span><span class="sxs-lookup"><span data-stu-id="3afc1-133">Structures are not inheritable; classes are.</span></span>  
  
- <span data-ttu-id="3afc1-134">Структуры никогда не завершаются, поэтому среда CLR никогда не вызывает метод <xref:System.Object.Finalize%2A> для любой структуры. классы завершаются сборщиком мусора (GC), который вызывает <xref:System.Object.Finalize%2A> класса при обнаружении отсутствия активных ссылок.</span><span class="sxs-lookup"><span data-stu-id="3afc1-134">Structures are never terminated, so the common language runtime (CLR) never calls the <xref:System.Object.Finalize%2A> method on any structure; classes are terminated by the garbage collector (GC), which calls <xref:System.Object.Finalize%2A> on a class when it detects there are no active references remaining.</span></span>  
  
- <span data-ttu-id="3afc1-135">Для структуры не требуется конструктор; класс выполняет.</span><span class="sxs-lookup"><span data-stu-id="3afc1-135">A structure does not require a constructor; a class does.</span></span>  
  
- <span data-ttu-id="3afc1-136">Структуры могут иметь необщие конструкторы, только если они принимают параметры. классы могут иметь параметры с параметрами или без них.</span><span class="sxs-lookup"><span data-stu-id="3afc1-136">Structures can have nonshared constructors only if they take parameters; classes can have them with or without parameters.</span></span>  
  
 <span data-ttu-id="3afc1-137">Каждая структура имеет неявный открытый конструктор без параметров.</span><span class="sxs-lookup"><span data-stu-id="3afc1-137">Every structure has an implicit public constructor without parameters.</span></span> <span data-ttu-id="3afc1-138">Этот конструктор инициализирует все элементы данных структуры значениями по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="3afc1-138">This constructor initializes all the structure's data elements to their default values.</span></span> <span data-ttu-id="3afc1-139">Это поведение нельзя переопределить.</span><span class="sxs-lookup"><span data-stu-id="3afc1-139">You cannot redefine this behavior.</span></span>  
  
## <a name="instances-and-variables"></a><span data-ttu-id="3afc1-140">Экземпляры и переменные</span><span class="sxs-lookup"><span data-stu-id="3afc1-140">Instances and Variables</span></span>  
 <span data-ttu-id="3afc1-141">Поскольку структуры являются типами значений, каждая переменная структуры постоянно привязана к отдельному экземпляру структуры.</span><span class="sxs-lookup"><span data-stu-id="3afc1-141">Because structures are value types, each structure variable is permanently bound to an individual structure instance.</span></span> <span data-ttu-id="3afc1-142">Классы являются ссылочными типами, и объектная переменная может ссылаться на различные экземпляры класса в разное время.</span><span class="sxs-lookup"><span data-stu-id="3afc1-142">But classes are reference types, and an object variable can refer to various class instances at different times.</span></span> <span data-ttu-id="3afc1-143">Это различие влияет на использование структур и классов следующими способами.</span><span class="sxs-lookup"><span data-stu-id="3afc1-143">This distinction affects your usage of structures and classes in the following ways:</span></span>  
  
- <span data-ttu-id="3afc1-144">**Инициализации.**</span><span class="sxs-lookup"><span data-stu-id="3afc1-144">**Initialization.**</span></span> <span data-ttu-id="3afc1-145">Переменная структуры неявно включает инициализацию элементов с помощью конструктора без параметров структуры.</span><span class="sxs-lookup"><span data-stu-id="3afc1-145">A structure variable implicitly includes an initialization of the elements using the structure's parameterless constructor.</span></span> <span data-ttu-id="3afc1-146">Поэтому `Dim s As struct1` эквивалентна `Dim s As struct1 = New struct1()`.</span><span class="sxs-lookup"><span data-stu-id="3afc1-146">Therefore, `Dim s As struct1` is equivalent to `Dim s As struct1 = New struct1()`.</span></span>  
  
- <span data-ttu-id="3afc1-147">**Присвоение переменных.**</span><span class="sxs-lookup"><span data-stu-id="3afc1-147">**Assigning Variables.**</span></span> <span data-ttu-id="3afc1-148">При назначении одной переменной структуры другому или передаче экземпляра структуры в аргумент процедуры текущие значения всех элементов переменной копируются в новую структуру.</span><span class="sxs-lookup"><span data-stu-id="3afc1-148">When you assign one structure variable to another, or pass a structure instance to a procedure argument, the current values of all the variable elements are copied to the new structure.</span></span> <span data-ttu-id="3afc1-149">При присвоении одной переменной объекта другому или передаче переменной объекта в процедуру копируется только указатель ссылки.</span><span class="sxs-lookup"><span data-stu-id="3afc1-149">When you assign one object variable to another, or pass an object variable to a procedure, only the reference pointer is copied.</span></span>  
  
- <span data-ttu-id="3afc1-150">**Ничего не назначается.**</span><span class="sxs-lookup"><span data-stu-id="3afc1-150">**Assigning Nothing.**</span></span> <span data-ttu-id="3afc1-151">Переменной структуры можно присвоить значение [Nothing](../../../../visual-basic/language-reference/nothing.md) , но экземпляр будет связан с переменной.</span><span class="sxs-lookup"><span data-stu-id="3afc1-151">You can assign the value [Nothing](../../../../visual-basic/language-reference/nothing.md) to a structure variable, but the instance continues to be associated with the variable.</span></span> <span data-ttu-id="3afc1-152">Вы по-прежнему можете вызывать свои методы и обращаться к его элементам данных, хотя переменные элементы повторно инициализируются с помощью назначения.</span><span class="sxs-lookup"><span data-stu-id="3afc1-152">You can still call its methods and access its data elements, although variable elements are reinitialized by the assignment.</span></span>  
  
     <span data-ttu-id="3afc1-153">Напротив, если для переменной объекта задано значение `Nothing`, то вы не связываете его ни с одним экземпляром класса, и вы не сможете получить доступ к членам через переменную, пока не назначите ей другой экземпляр.</span><span class="sxs-lookup"><span data-stu-id="3afc1-153">In contrast, if you set an object variable to `Nothing`, you dissociate it from any class instance, and you cannot access any members through the variable until you assign another instance to it.</span></span>  
  
- <span data-ttu-id="3afc1-154">**Несколько экземпляров.**</span><span class="sxs-lookup"><span data-stu-id="3afc1-154">**Multiple Instances.**</span></span> <span data-ttu-id="3afc1-155">Объектная переменная может иметь разные экземпляры класса, назначенные ему в разное время, а несколько объектных переменных могут одновременно ссылаться на один и тот же экземпляр класса.</span><span class="sxs-lookup"><span data-stu-id="3afc1-155">An object variable can have different class instances assigned to it at different times, and several object variables can refer to the same class instance at the same time.</span></span> <span data-ttu-id="3afc1-156">Изменения, вносимые в значения членов класса, влияют на эти члены при доступе через другую переменную, указывающую на тот же экземпляр.</span><span class="sxs-lookup"><span data-stu-id="3afc1-156">Changes you make to the values of class members affect those members when accessed through another variable pointing to the same instance.</span></span>  
  
     <span data-ttu-id="3afc1-157">Однако элементы структуры изолированы в своем собственном экземпляре.</span><span class="sxs-lookup"><span data-stu-id="3afc1-157">Structure elements, however, are isolated within their own instance.</span></span> <span data-ttu-id="3afc1-158">Изменения в их значениях не отражаются ни в каких других переменных структуры, даже в других экземплярах того же объявления `Structure`.</span><span class="sxs-lookup"><span data-stu-id="3afc1-158">Changes to their values are not reflected in any other structure variables, even in other instances of the same `Structure` declaration.</span></span>  
  
- <span data-ttu-id="3afc1-159">**Проверке.**</span><span class="sxs-lookup"><span data-stu-id="3afc1-159">**Equality.**</span></span> <span data-ttu-id="3afc1-160">Проверка на равенство двух структур должна выполняться с помощью тестового элемента.</span><span class="sxs-lookup"><span data-stu-id="3afc1-160">Equality testing of two structures must be performed with an element-by-element test.</span></span> <span data-ttu-id="3afc1-161">С помощью метода <xref:System.Object.Equals%2A> можно сравнивать две объектные переменные.</span><span class="sxs-lookup"><span data-stu-id="3afc1-161">Two object variables can be compared using the <xref:System.Object.Equals%2A> method.</span></span> <span data-ttu-id="3afc1-162"><xref:System.Object.Equals%2A> указывает, указывают ли две переменные на один и тот же экземпляр.</span><span class="sxs-lookup"><span data-stu-id="3afc1-162"><xref:System.Object.Equals%2A> indicates whether the two variables point to the same instance.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3afc1-163">См. также</span><span class="sxs-lookup"><span data-stu-id="3afc1-163">See also</span></span>

- [<span data-ttu-id="3afc1-164">Типы данных</span><span class="sxs-lookup"><span data-stu-id="3afc1-164">Data Types</span></span>](../../../../visual-basic/programming-guide/language-features/data-types/index.md)
- [<span data-ttu-id="3afc1-165">Составные типы данных</span><span class="sxs-lookup"><span data-stu-id="3afc1-165">Composite Data Types</span></span>](../../../../visual-basic/programming-guide/language-features/data-types/composite-data-types.md)
- [<span data-ttu-id="3afc1-166">Value Types and Reference Types</span><span class="sxs-lookup"><span data-stu-id="3afc1-166">Value Types and Reference Types</span></span>](../../../../visual-basic/programming-guide/language-features/data-types/value-types-and-reference-types.md)
- [<span data-ttu-id="3afc1-167">Структуры</span><span class="sxs-lookup"><span data-stu-id="3afc1-167">Structures</span></span>](../../../../visual-basic/programming-guide/language-features/data-types/structures.md)
- [<span data-ttu-id="3afc1-168">Устранение неполадок, связанных с типами данных</span><span class="sxs-lookup"><span data-stu-id="3afc1-168">Troubleshooting Data Types</span></span>](../../../../visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md)
- [<span data-ttu-id="3afc1-169">Структуры и другие элементы программирования</span><span class="sxs-lookup"><span data-stu-id="3afc1-169">Structures and Other Programming Elements</span></span>](../../../../visual-basic/programming-guide/language-features/data-types/structures-and-other-programming-elements.md)
- [<span data-ttu-id="3afc1-170">Объекты и классы</span><span class="sxs-lookup"><span data-stu-id="3afc1-170">Objects and Classes</span></span>](../../../../visual-basic/programming-guide/language-features/objects-and-classes/index.md)
