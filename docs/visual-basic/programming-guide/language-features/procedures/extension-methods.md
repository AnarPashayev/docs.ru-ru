---
title: Методы расширения (Visual Basic)
ms.date: 07/20/2015
f1_keywords:
- vb.ExtensionMethods
helpviewer_keywords:
- extending data types [Visual Basic]
- extension methods [Visual Basic]
ms.assetid: b8020aae-374d-46a9-bcb7-8cc2390b93b6
ms.openlocfilehash: 9e005d0dc7da154fbaffbf7e02c55445a1213195
ms.sourcegitcommit: 558d78d2a68acd4c95ef23231c8b4e4c7bac3902
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2019
ms.locfileid: "59296242"
---
# <a name="extension-methods-visual-basic"></a>Методы расширения (Visual Basic)
Методы расширения позволяют разработчикам добавлять пользовательские функциональные возможности типам данных, которые уже определены без создания нового производного типа. Методы расширения делают возможным написание метода, который может вызываться, как если бы это был метод экземпляра существующего типа.  
  
## <a name="remarks"></a>Примечания  
 Метод расширения может быть только `Sub` процедуры или `Function` процедуры. Нельзя определить свойство расширения, поле или событие. Все методы расширения должны быть помечены атрибутом расширения `<Extension()>` из <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> пространства имен.  
  
 Первый параметр в определении метода расширения указывает тип данных, который расширяет метод. При выполнении метода первый параметр привязан к экземпляру типа данных, который вызывает метод.  
  
## <a name="example"></a>Пример  
  
### <a name="description"></a>Описание  
 В следующем примере определяется `Print` расширение <xref:System.String> тип данных. Данный метод использует `Console.WriteLine` для отображения строки. Параметр `Print` метод, `aString`, устанавливает, что метод расширяет <xref:System.String> класса.  
  
 [!code-vb[VbVbalrExtensionMethods#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/StringExtensions.vb#1)]  
  
 Обратите внимание, что определение метода расширения помечено атрибутом расширения `<Extension()>`. Помечать модуль, в котором определен метод является необязательным, но каждый метод расширения должен быть помечен. <xref:System.Runtime.CompilerServices> Чтобы получить доступ к атрибуту расширения должен быть импортирован.  
  
 Методы расширения могут быть объявлены только внутри модулей. Как правило модуль, в котором определен метод расширения не одного модуля, который, в котором он вызывается. Вместо этого модуль, содержащий метод расширения, импортируется, если необходимо, чтобы включить их в область. После модуля, содержащего `Print` находится в области, метод можно вызывать, как если бы он был обычным экземпляром метода, не принимающую аргументы, такие как `ToUpper`:  
  
 [!code-vb[VbVbalrExtensionMethods#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/Class1.vb#2)]  
  
 Следующий пример, `PrintAndPunctuate`, также является расширением <xref:System.String>, но определенным с двумя параметрами. Первый параметр, `aString`, устанавливает, что метод расширения расширяет <xref:System.String>. Второй параметр, `punc`, должен быть строкой знаков пунктуации, передается в качестве аргумента при вызове метода. Метод отображает строку, за которой следует пунктуации.  
  
 [!code-vb[VbVbalrExtensionMethods#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/Class2.vb#3)]  
  
 Метод вызывается отправкой аргумента строки для `punc`: `example.PrintAndPunctuate(".")`  
  
 В следующем примере показан `Print` и `PrintAndPunctuate` определяются и вызываются. <xref:System.Runtime.CompilerServices> импортируется в модуле определения, чтобы обеспечить доступ к атрибуту расширения.  
  
### <a name="code"></a>Код  
  
```vb  
Imports System.Runtime.CompilerServices  
  
Module StringExtensions  
  
    <Extension()>   
    Public Sub Print(ByVal aString As String)  
        Console.WriteLine(aString)  
    End Sub  
  
    <Extension()>   
    Public Sub PrintAndPunctuate(ByVal aString As String,   
                                 ByVal punc As String)  
        Console.WriteLine(aString & punc)  
    End Sub  
  
End Module  
```  
  
 Затем методы расширения вносятся в область действия и именем.  
  
```vb  
Imports ConsoleApplication2.StringExtensions  
Module Module1  
  
    Sub Main()  
  
        Dim example As String = "Example string"  
        example.Print()  
  
        example = "Hello"  
        example.PrintAndPunctuate(".")  
        example.PrintAndPunctuate("!!!!")  
  
    End Sub  
End Module  
```  
  
### <a name="comments"></a>Комментарии  
 Все, что необходимо для выполнения этих или подобных методов расширения является то, что они в области видимости. Если в области модуля, содержащего метод расширения, он отображается в технологии IntelliSense и может вызываться, как если бы он был обычным методом экземпляра.  
  
 Обратите внимание, что при вызове методов аргумент не отправляется для первого параметра. Параметр `aString` в предыдущий метод определения привязан к `example`, экземпляр `String` , вызывает их. Компилятор будет использовать `example` в качестве аргумента, отправляемого в первый параметр.  
  
 Если метод расширения вызывается для объекта, который имеет значение `Nothing`, метод расширения выполняется. Это относится к обычным методам экземпляров. Вы можете явным образом проверить наличие `Nothing` в методе расширения.  
  
## <a name="types-that-can-be-extended"></a>Типы, которые могут быть расширены  
 Можно определить метод расширения большинства типов, которые могут быть представлены в списке параметров Visual Basic, включая следующие:  
  
-   Классы (ссылочные типы)  
  
-   Структуры (типы значений)  
  
-   интерфейсов,  
  
-   Делегаты  
  
-   Аргументы ByVal и ByRef  
  
-   Параметры базового метода  
  
-   Массивы  
  
 Так как первый параметр указывает тип данных, который расширяет метод расширения, он является обязательным и не может быть необязательным. По этой причине `Optional` параметров и `ParamArray` параметров не может быть первым параметром в списке параметров.  
  
 Методы расширения не учитываются при позднем связывании. В следующем примере инструкция `anObject.PrintMe()` вызывает <xref:System.MissingMemberException> исключение, то же исключение возникает, если второй `PrintMe` определение метода расширения были удалены.  
  
 [!code-vb[VbVbalrExtensionMethods#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/Class6.vb#9)]  
  
## <a name="best-practices"></a>Рекомендации  
 Методы расширения предоставляют удобный и мощный способ расширить существующий тип. Однако для успешного использования, существуют некоторые моменты, которые следует учитывать. Эти советы главным образом касаются авторов библиотек классов, но они могут повлиять на любое приложение, использующее методы расширения.  
  
 Как правило методы расширения, добавленные к типам, которые вы не владеете являются более уязвимыми, чем методы расширения, добавленные к типам, которыми можно управлять. Число объектов может возникнуть в классах, которые вам не принадлежат, могут конфликтовать с методами расширения.  
  
-   Если существует любой доступный элемент экземпляра, который имеет сигнатуру, совместимую с аргументами в вызывающей инструкции, при этом сужающие преобразования не требуется для параметра от аргумента, метод экземпляра будет использоваться в предпочтение любому методу расширения. Таким образом Если соответствующий метод экземпляра добавляется класс в некоторой точке, существующий элемент расширения, основанные на могут стать недоступными.  
  
-   Автор метода расширения не может помешать другим программистам записать конфликтующие методы расширения, которые могут иметь приоритет над исходным расширением.  
  
-   Надежность можно повысить, помещая методы расширения в свое собственное пространство имен. Потребители библиотеки можно включить пространство имен или исключите его или выбрать пространства имен отдельно от остальной части библиотеки.  
  
-   Возможно, более безопасным расширить интерфейсы, а не расширить классы, особенно в том случае, если вы не являетесь владельцем интерфейса или класса. Изменения в интерфейсе влияет на каждый класс, который его реализует. Таким образом автор, можно снизить вероятность добавить или изменить методы в интерфейсе. Тем не менее если класс реализует два интерфейса, имеющих методы расширения с такой же сигнатурой, ни один из методов расширения не виден.  
  
-   Расширить наиболее конкретный тип, можно. В иерархии типов Если выбран тип, от которого многие другие типы являются производными, существуют уровни возможностей для введения методов экземпляра или других методов расширения, которые могут конфликтовать с вашими.  
  
## <a name="extension-methods-instance-methods-and-properties"></a>Методы расширения, методы экземпляра и свойства  
 Если метод экземпляра в области имеет сигнатуру, совместимую с аргументом вызывающего оператора, метод экземпляра выбирается в предпочтение любому методу расширения. Метод экземпляра имеет приоритет, даже если метод расширения является более подходящим. В следующем примере `ExampleClass` содержит метод экземпляра с именем `ExampleMethod` , имеющий один параметр типа `Integer`. Метод расширения `ExampleMethod` расширяет `ExampleClass`, и имеет один параметр типа `Long`.  
  
 [!code-vb[VbVbalrExtensionMethods#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/Class4.vb#4)]  
  
 Первый вызов `ExampleMethod` в следующем коде вызывает метод расширения, так как `arg1` — `Long` и совместим только с `Long` параметр метода расширения. Второй вызов `ExampleMethod` имеет `Integer` аргумент, `arg2`, и он вызывает метод экземпляра.  
  
 [!code-vb[VbVbalrExtensionMethods#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/Class4.vb#5)]  
  
 Теперь обратный типы данных параметров в два метода:  
  
 [!code-vb[VbVbalrExtensionMethods#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/Class5.vb#6)]  
  
 В этот раз код в `Main` вызывает метод экземпляра оба раза. Это обусловлено тем, как `arg1` и `arg2` иметь расширяющее преобразование `Long`, а метод экземпляра имеет преимущество перед методом расширения в обоих случаях.  
  
 [!code-vb[VbVbalrExtensionMethods#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/Class5.vb#7)]  
  
 Таким образом метод расширения не может заменить существующий метод экземпляра. Тем не менее если метод расширения имеет то же имя, как метод экземпляра, но подписи не конфликтуют, может осуществляться оба метода. Например если класс `ExampleClass` содержит метод с именем `ExampleMethod` , не имеющий аргументов, методы расширения с тем же именем, но различными сигнатурами, допускаются, как показано в следующем коде.  
  
 [!code-vb[VbVbalrExtensionMethods#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/Module3.vb#8)]  
  
 Результат выполнения этого кода выглядит следующим образом:  
  
 `Extension method`  
  
 `Instance method`  
  
 Ситуация выглядит проще со свойствами: Если метод расширения имеет имя, совпадающее с именем свойства класса, он расширяет, метод расширения невидим и недоступен.  
  
## <a name="extension-method-precedence"></a>Приоритет метода расширения  
 Когда два метода расширения, имеющие одинаковые сигнатуры в области и доступны, будет вызван метод с более высоким приоритетом. Приоритет метода расширения основан на механизм, используемый для переноса метода в область действия. Ниже показана иерархия приоритетов от самого высокого до самого низкого.  
  
1. Методы расширения, определенные внутри текущего модуля.  
  
2. Методы расширения определенные внутри типов данных в текущем пространстве имен или какой-либо из его родительских объектов с дочерними пространствами имен, имеющими более высокий приоритет, чем родительские пространства имен.  
  
3. Методы расширения, определенные внутри любых импортов типа в текущем файле.  
  
4. Методы расширения, определенные внутри любых импортов пространств имен в текущем файле.  
  
5. Методы расширения, определенные внутри любых импортов типов на уровне проекта.  
  
6. Методы расширения, определенные внутри любых импортов пространств имен уровня проекта.  
  
 Если приоритет не помогает устранить неоднозначность, можно использовать полное доменное имя для указания метода, который вы вызываете. Если `Print` метод в предыдущем примере определен в модуле с именем `StringExtensions`, полное доменное имя является `StringExtensions.Print(example)` вместо `example.Print()`.  
  
## <a name="see-also"></a>См. также

- <xref:System.Runtime.CompilerServices>
- <xref:System.Runtime.CompilerServices.ExtensionAttribute>
- [Методы расширения](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md)
- [Оператор Module](../../../../visual-basic/language-reference/statements/module-statement.md)
- [Параметры и аргументы процедуры](./procedure-parameters-and-arguments.md)
- [Необязательные параметры](./optional-parameters.md)
- [Массивы параметров](./parameter-arrays.md)
- [Общие сведения об атрибутах](../../../../visual-basic/programming-guide/concepts/attributes/index.md)
- [Область видимости в Visual Basic](../../../../visual-basic/programming-guide/language-features/declared-elements/scope.md)
