---
title: Устранение неполадок в процедурах (Visual Basic)
ms.date: 07/20/2015
helpviewer_keywords:
- troubleshooting Visual Basic, procedures
- procedures [Visual Basic], troubleshooting
- Visual Basic code, procedures
- troubleshooting procedures
- procedures [Visual Basic], about procedures
ms.assetid: 525721e8-2e02-4f75-b5d8-6b893462cf2b
ms.openlocfilehash: 492a7474a38a7e41b7e3b3f59dfa118c30256ea4
ms.sourcegitcommit: 0be8a279af6d8a43e03141e349d3efd5d35f8767
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/18/2019
ms.locfileid: "58830140"
---
# <a name="troubleshooting-procedures-visual-basic"></a>Устранение неполадок в процедурах (Visual Basic)
Этой странице перечислены некоторые распространенные проблемы, которые могут возникнуть при работе с процедурами.  
  
## <a name="returning-an-array-type-from-a-function-procedure"></a>Возврат типа массива из процедуры Function  
 Если `Function` процедура возвращает массив, нельзя использовать `Function` имя для хранения значения элементов массива. Если вы попытаетесь это сделать, компилятор интерпретирует его как вызов `Function`. Следующий пример приводит к возникновению ошибки ошибки компилятора.  
  
 `Function allOnes(ByVal n As Integer) As Integer()`  
  
 `For i As Integer = 1 To n - 1`  
  
 `' The following statement generates a`   `COMPILER ERROR`  `.`  
  
 `allOnes(i) = 1`  
  
 `Next i`  
  
 `' The following statement generates a`   `COMPILER ERROR`  `.`  
  
 `Return allOnes()`  
  
 `End Function`  
  
 Инструкция `allOnes(i) = 1` создает ошибку компилятора, поскольку для вызова `allOnes` с аргументом неверного типа данных (одноэлементный `Integer` вместо `Integer` массива). Инструкция `Return allOnes()` создает ошибку компилятора, поскольку для вызова `allOnes` без аргумента.  
  
 **Правильный подход:** Чтобы иметь возможность изменять элементы массива, который должен быть возвращен, определение внутреннего массива как локальная переменная. В следующем примере компилируется без ошибок.  
  
 [!code-vb[VbVbcnProcedures#66](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#66)]  
  
## <a name="argument-not-being-modified-by-procedure-call"></a>Аргумент не изменяется путем вызова процедуры  
 Если вы планируете разрешить процедуре изменять программный элемент базового аргумента в вызывающем коде, его необходимо передавать по ссылке. Однако процедуру можно доступа к элементам аргумента ссылочного типа, даже если он передается по значению.  
  
-   **Базовый переменной**. Чтобы разрешить процедуре заменить значение элемента базовой переменной, процедура должна объявить параметр [ByRef](../../../../visual-basic/language-reference/modifiers/byref.md). Также, вызывающий код не должен заключать аргумент в круглые скобки, поскольку это переопределяет `ByRef` механизма передачи.  
  
-   **Ссылаться на элементы типа**. Если параметр объявлен [ByVal](../../../../visual-basic/language-reference/modifiers/byval.md), процедура не может изменить элемент базовой переменной. Тем не менее если аргумент является ссылочным типом, процедура может изменить члены объекта, на который он указывает, несмотря на то, что она не может заменить значение переменной. Например если аргумент является переменной массива, ему нельзя присвоить новый массив, в него, но его можно изменить один или несколько его элементов. Изменение элементов, отражаются в базовой переменной массива в вызывающем коде.  
  
 В следующем примере определяется две процедуры, которые принимают переменную массива по значению и работают на своих элементов. Процедура `increase` просто добавляет единицу к каждому элементу. Процедура `replace` присваивает новый массив в параметре `a()` и добавляет единицу к каждому элементу. Тем не менее переназначение не влияет на базовую переменную массива в вызывающем коде, так как `a()` объявляется `ByVal`.  
  
 [!code-vb[VbVbcnProcedures#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#35)]  
  
 [!code-vb[VbVbcnProcedures#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#38)]  
  
 Следующий пример выполняет вызовы `increase` и `replace`.  
  
 [!code-vb[VbVbcnProcedures#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#37)]  
  
 Первый `MsgBox` вызове отображается «после увеличения (n): 11, 21, 31, 41". Так как `n` является ссылочным типом, `increase` может изменить его элементы, несмотря на то, что он передается `ByVal`.  
  
 Второй `MsgBox` вызове отображается «после замены(n): 11, 21, 31, 41". Так как `n` передается `ByVal`, `replace` нельзя изменить переменную `n` путем присвоения нового массива. Когда `replace` создает новый экземпляр массива `k` и назначает его локальной переменной `a`, он теряет ссылку на `n` передается в вызывающий код. Когда он увеличивает члены `a`, только локальный массив `k` снижается.  
  
 **Правильный подход:** Чтобы иметь возможность изменить элемент базовой переменной, передайте его по ссылке. В следующем примере показано изменение в объявлении `replace` , позволяющее заменить один массив на другой в вызывающем коде.  
  
 [!code-vb[VbVbcnProcedures#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#64)]  
  
## <a name="unable-to-define-an-overload"></a>Не удалось определить перегрузку  
 Если вы хотите определить перегруженные версии процедуры, необходимо использовать с тем же именем, но другой сигнатурой. Если компилятор не может отличить объявление от перегрузки с такой же сигнатурой, он создает ошибку.  
  
 *Подпись* процедуры определяется имя процедуры и список параметров. Каждая перегрузка должен иметь имя, совпадающее с именем все другие перегрузки, но должна отличаться от всех, по крайней мере одним из других компонентов подписи. Дополнительные сведения см. в разделе [Procedure Overloading](./procedure-overloading.md).  
  
 Следующие элементы, даже если они относятся к списку параметров, не являются компонентами подписи процедуры:  
  
-   Ключевые слова модификаторов процедур, таких как `Public`, `Shared`, и `Static`  
  
-   Имена параметров  
  
-   Ключевые слова модификаторов параметров, таких как `ByRef` и `Optional`  
  
-   Тип данных возвращаемого значения (за исключением оператора преобразования)  
  
 Нельзя перегрузить процедуру путем изменения только один или несколько из вышеперечисленных элементов.  
  
 **Правильный подход:** Чтобы иметь возможность определить перегрузка процедуры, необходимо изменить подпись. Так как необходимо использовать тем же именем, необходимо изменить число, порядок или типы данных параметров. В универсальной процедуры можно изменять количество параметров типа. В оператор преобразования ([функция CType](../../../../visual-basic/language-reference/functions/ctype-function.md)), можно изменять тип возвращаемого значения.  
  
### <a name="overload-resolution-with-optional-and-paramarray-arguments"></a>Перегрузка разрешение с необязательными и ParamArray-аргументы  
 Если происходит перегрузка процедуры с одним или несколькими [необязательно](../../../../visual-basic/language-reference/modifiers/optional.md) параметров или [ParamArray](../../../../visual-basic/language-reference/modifiers/paramarray.md) параметр, необходимо избегать дублирования *неявные перегрузки*. Сведения см. в разделе [вопросы, связанные с перегрузкой процедур](./considerations-in-overloading-procedures.md).  
  
## <a name="calling-a-wrong-version-of-an-overloaded-procedure"></a>Вызов неверной версии перегруженной процедуры  
 Если процедура имеет несколько перегруженных версий, необходимо уметь работать с их списки параметров и понять, как Visual Basic разрешает вызовы между перегрузками. В противном случае можно вызвать перегрузку, отличную от предполагаемой.  
  
 После определения перегрузку, которую необходимо вызвать, следует соблюдать следующие правила:  
  
-   Укажите правильное количество аргументов и в правильном порядке.  
  
-   В идеальном случае аргументы должны иметь те же типы данных, что и соответствующие параметры. В любом случае тип данных каждого аргумента должен расширяться до соответствующего параметра. Это справедливо даже с [оператор Option Strict](../../../../visual-basic/language-reference/statements/option-strict-statement.md) присвоено `Off`. Если перегрузка требует сужающего преобразования списка аргументов, перегрузки не может быть вызвана.  
  
-   Если аргументы, которые требуют расширения, задайте их типы данных, как можно ближе к типам данных параметров. Если два или несколько перегрузок принимают типы данных аргументов, компилятор разрешает вызов перегрузка, которая вызывает для наименьший объем расширения.  
  
 Можно уменьшить вероятность несоответствия типов данных с помощью [функция CType](../../../../visual-basic/language-reference/functions/ctype-function.md) ключевые слова преобразования при подготовке аргументов.  
  
### <a name="overload-resolution-failure"></a>Сбой разрешения перегрузки  
 При вызове перегруженной процедуры, компилятор пытается устранить все, кроме одной из перегрузок. Если он завершается успешно, он разрешает вызов этой перегрузки. Если оно устраняет все случаи перегрузки, или если он не может уменьшить быть выбран единственный вариант, он создает ошибку.  
  
 Следующий пример иллюстрирует процесс разрешения перегрузки.  
  
 [!code-vb[VbVbcnProcedures#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#62)]  
  
 [!code-vb[VbVbcnProcedures#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#63)]  
  
 В первом вызове компилятор устраняет первую перегрузку, так как тип первого аргумента (`Short`) сужается к типу соответствующего параметра (`Byte`). Затем исключаются третья перегрузка, так как каждый тип аргумента во второй перегрузке (`Short` и `Single`) можно расширить до соответствующего типа в третьей перегрузке (`Integer` и `Single`). Вторая перегрузка требует меньшего расширения, поэтому компилятор использует его для вызова.  
  
 Во втором вызове компилятор не может устранить перегрузок на основании сужающим. Это устраняет третья перегрузка по той же причине, как и в первом вызове, так как оно может вызвать вторую перегрузку с меньшим расширением типов аргументов. Однако компилятору не удается разрешить между первой и второй перегрузок. Каждый имеет один определенный тип параметра, можно расширить до соответствующего типа в другой (`Byte` для `Short`, но `Single` для `Double`). Поэтому компилятор создает ошибку разрешения перегрузки.  
  
 **Правильный подход:** Чтобы иметь возможность вызов перегруженной процедуры без неоднозначности, используйте [функция CType](../../../../visual-basic/language-reference/functions/ctype-function.md) в соответствии с типами данных аргументов в типы параметров. В следующем примере показан вызов `z` , требующий разрешения вторая перегрузка.  
  
 [!code-vb[VbVbcnProcedures#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#65)]  
  
### <a name="overload-resolution-with-optional-and-paramarray-arguments"></a>Перегрузка разрешение с необязательными и ParamArray-аргументы  
 Если две перегрузки процедуры имеют идентичные подписи, за исключением того, что последний параметр объявляется [необязательно](../../../../visual-basic/language-reference/modifiers/optional.md) в одном и [ParamArray](../../../../visual-basic/language-reference/modifiers/paramarray.md) в другой, компилятор разрешает вызов процедуры в соответствии с наиболее точное соответствие. Для получения дополнительной информации см. [Overload Resolution](./overload-resolution.md).  
  
## <a name="see-also"></a>См. также

- [Процедуры](./index.md)
- [Подпрограммы](./sub-procedures.md)
- [Процедуры функций](./function-procedures.md)
- [Процедуры свойств](./property-procedures.md)
- [Процедуры операторов](./operator-procedures.md)
- [Параметры и аргументы процедуры](./procedure-parameters-and-arguments.md)
- [Перегрузка процедур](./procedure-overloading.md)
- [Вопросы, связанные с перегрузкой процедур](./considerations-in-overloading-procedures.md)
- [Разрешение перегрузки](./overload-resolution.md)
