---
title: Подробная информация о сериализации XML
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- XML serialization, about XML serialization
- ICollection interface, serializing
- XmlSerializer class, serializing
- serialization, about serialization
- DataSet class, serializing
- XML Schema, serializing
ms.assetid: 8c63200d-db63-4a03-a93d-21641623df62
ms.openlocfilehash: d644e80cbf5ac17fca4df039d915c847a1936217
ms.sourcegitcommit: 961ec21c22d2f1d55c9cc8a7edf2ade1d1fd92e3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/02/2020
ms.locfileid: "80588459"
---
# <a name="xml-serialization"></a>сериализация XML

Сериализация представляет собой процесс преобразования объекта в форму, подготовленную для передачи. Например, можно сериализовать объект и передать его по Интернету с использованием протокола HTTP между клиентом и сервером. И наоборот, при десериализации объект воссоздается из потока.

 При XML-сериализации в поток XML сериализуются только открытые поля и значения свойств объекта. XML-сериализация не учитывает информацию о типе. Например, если имеется объект **Book**, который существует в пространстве имен **Library**, нет никакой гарантии, что он десериализуется в объект аналогичного типа.

> [!NOTE]
> XML-сериализация не выполняет преобразование методов, индексаторов, закрытых полей или свойств только для чтения (кроме коллекций только для чтения). Для сериализации всех полей и свойств объекта, как открытых, так и закрытых, используйте <xref:System.Runtime.Serialization.DataContractSerializer> вместо XML-сериализации.

 Центральным классом XML-сериализации является класс <xref:System.Xml.Serialization.XmlSerializer>, а наиболее важные методы в этом классе — **Serialize** и **Deserialize**. <xref:System.Xml.Serialization.XmlSerializer> создает файлы C# и компилирует их в файлы DLL для выполнения сериализации. В платформе .NET Framework 2.0 [инструмент создания XML-сериализатора (Sgen.exe)](xml-serializer-generator-tool-sgen-exe.md) предназначен для создания таких сборок сериализации заранее, они будут развертываться вместе с приложением и повышать производительность при запуске. Поток XML, генерируемый **XmlSerializer,** соответствует рекомендации World Wide Web Consortium (W3C) [XML Schema (XSD) 1.0.](https://www.w3.org/TR/xslt) Более того, создаваемые типы данных соответствуют документу "XML Schema Part 2: Datatypes".

 Данные в объектах описываются с помощью конструкций языка программирования, например классов, полей, свойств, типов примитивов, массивов и даже встроенного XML в форме объектов **XmlElement** или **XmlAttribute**. Предусмотрена возможность создания собственных классов, аннотируемых атрибутами, или использования инструмента определения схемы XML для создания классов на основе существующей схемы XML.

 При наличии схемы XML можно запустить инструмент определения схемы XML, чтобы создать набор классов со строгим типом схемы, которые аннотированы атрибутами. При сериализации экземпляра такого класса созданный XML соответствует схеме XML. Благодаря такому классу можно создать код с использованием объектной модели, которой легко управлять, и при этом гарантировать соответствие созданного XML схеме XML. Это альтернативный вариант использования других классов в платформе .NET Framework, например классов **XmlReader** и **XmlWriter**, для анализа и записи в поток XML. Дополнительные сведения см. в разделе [XML-документы и данные](../../../docs/standard/data/xml/index.md). Эти классы позволяют анализировать любой поток XML. И наоборот, используйте **XmlSerializer**, когда предполагается, что поток XML соответствует известной схеме XML.

 Атрибуты управляют потоком XML, который создан классом **XmlSerializer**, позволяя задавать пространство имен XML, имя элемента, имя атрибута потока XML и т. д. Дополнительные сведения об этих атрибутах и о том, как они управляют XML-сериализацией, см. в разделе [Управление сериализацией XML с использованием атрибутов](controlling-xml-serialization-using-attributes.md). Таблица атрибутов, используемых для управления созданным XML, представлена в разделе [Атрибуты управления сериализацией XML](attributes-that-control-xml-serialization.md).

 Класс **XmlSerializer** может продолжать сериализовывать объект и создавать поток XML с кодировкой SOAP. Созданный XML соответствует требованиям раздела 5 документа консорциума World Wide Web (www.w3.org) "Simple Object Access Protocol (SOAP) 1.1". Дополнительные сведения об этом процессе см. в разделе [Практическое руководство. Сериализация объекта как потока XML с кодировкой SOAP](how-to-serialize-an-object-as-a-soap-encoded-xml-stream.md). Таблица атрибутов, используемых для управления созданным XML, представлена в разделе [Атрибуты управления сериализацией с кодировкой SOAP](attributes-that-control-encoded-soap-serialization.md).

 Класс **XmlSerializer** создает сообщения SOAP, созданные и переданные в XML-веб-службы. Для управления сообщениями SOAP можно применять атрибуты к классам, возвращаемым значениям, параметрам и полям, обнаруженным в файле XML-веб-службы (файл ASMX). Можно применять оба атрибута, указанные в списках "Атрибуты управления XML-сериализацией" и "Атрибуты управления сериализацией с кодировкой SOAP", поскольку XML-веб-служба использует либо литеральный стиль, либо стиль с кодировкой SOAP. Дополнительные сведения о применении атрибутов для управления XML, созданным XML-веб-службой, см. в разделе [Сериализация XML с использованием XML-веб-служб](xml-serialization-with-xml-web-services.md). Для получения дополнительной информации об веб-сервисах SOAP и XML [см.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/dkwy2d72(v=vs.100))

## <a name="security-considerations-for-xmlserializer-applications"></a>Вопросы безопасности в отношении приложений с XmlSerializer

При создании приложения, использующим **XmlSerializer,** будьте осведомлены о следующих элементах и их последствиях:

- **XmlSerializer** создает файлы C# (CS) и компилирует их в файлы DLL в каталоге, названном переменной среды TEMP. С помощью этих файлов DLL выполняется сериализация.

  > [!NOTE]
  > Такие сборки сериализации можно создавать заранее и подписать с помощью инструмента SGen.exe. Такой способ невозможно использовать на сервере веб-служб. Другими словами, этот способ используется только для клиентов и сериализации вручную.

  Код и файлы DLL уязвимы для вредоносного процесса в момент создания и компиляции. На компьютере с Microsoft Windows NT версии 4.0 или более поздней два или большее число пользователей могут иметь совместный доступ к каталогу TEMP. Совместный доступ к каталогу TEMP представляет угрозу, если у двух учетных записей разные привилегии безопасности и приложение запускается из учетной записи с более высокими привилегиями с использованием **XmlSerializer**. В таком случае один из пользователей может нарушить безопасность компьютера, заменив либо компилируемый файл CS, либо файл DLL. Чтобы устранить такую уязвимость, нужно обязательно убедиться, что в каждой учетной записи на компьютере имеется отдельный профиль. По умолчанию переменная среды TEMP указывает на разные каталоги для каждой учетной записи.

- Если злоумышленник отправляет непрерывный поток данных XML на веб-сервер (атака типа "отказ в обслуживании"), **XmlSerializer** продолжает обрабатывать данные, пока на их обработку не будут потрачены все ресурсы системы.

  Такой вид атаки блокируется, если используется компьютер с запущенными службами Internet Information Services (IIS) и приложение работает в среде IIS. В службах IIS используется логический элемент, который не обрабатывает потоки, размер которых больше заданного значения (по умолчанию 4 КБ). Если создается приложение, не использующее службы IIS и выполняющее сериализацию с помощью **XmlSerializer**, необходимо реализовать похожий логический элемент, который будет блокировать атаки типа "отказ в обслуживании".

- **XmlSerializer** сериализует данные и запускает соответствующий код с использованием любого переданного ему типа.

  Вредоносный объект может представлять угрозу в двух случаях. Он может запустить вредоносный код или ввести его в файл C#, созданный **XmlSerializer**. В первом случае, если вредоносный объект пытается запустить разрушительную процедуру, система управления доступом для кода предотвращает повреждение. Во втором случае теоретически существует вероятность того, что вредоносный объект может каким-либо способом ввести код в файл C#, созданный **XmlSerializer**. Несмотря на то что эта проблема была тщательно изучена и вероятность такой атаки минимальна, следует принять меры предосторожности, т. е. никогда не сериализовывать данные неизвестного и недоверенного типа.

- Сериализованные конфиденциальные данные могут быть уязвимы.

  После того, как **XmlSerializer** имеет серийные данные, он может храниться как файл XML или другой магазин данных. Если хранилище данных доступно для других процессов или видно в интрасети или в Интернете, данные могут быть украдены и использованы с преступными намерениями. Например, если создается приложение, которое сериализует заказы, содержащие номера кредитных карт, такие данные очень важны. Чтобы предотвратить злонамеренное использование, всегда защищайте хранилище данных и принимайте все меры, чтобы сделать его закрытым.

## <a name="serialization-of-a-simple-class"></a>Сериализация простого класса

В следующем примере кода показан базовый класс с открытым полем.

```vb
Public Class OrderForm
    Public OrderDate As DateTime
End Class
```

```csharp
public class OrderForm
{
    public DateTime OrderDate;
}
```

При сериализации экземпляра этого класса этот процесс может выглядеть следующим образом.

```xml
<OrderForm>
    <OrderDate>12/12/01</OrderDate>
</OrderForm>
```

Дополнительные примеры XML-сериализации см. в разделе [Примеры сериализации XML](examples-of-xml-serialization.md).

## <a name="items-that-can-be-serialized"></a>Элементы, которые можно сериализовать

С помощью класса **XmlSerializer** можно сериализовать следующие элементы:

- Открытые свойства чтения/записи и поля открытых классов.

- Классы, реализующие **ICollection** или **IEnumerable**.

  > [!NOTE]
  > Сериализуются только коллекции, а не открытые свойства.

- Объекты **XmlElement**.

- Объекты **XmlNode**.

- Объекты **DataSet**.

 Дополнительные сведения о сериализации и десериализации объектов см. в разделах [Практическое руководство. Сериализация объекта](how-to-serialize-an-object.md) и [Практическое руководство. Десериализация объекта](how-to-deserialize-an-object.md).

## <a name="advantages-of-using-xml-serialization"></a>Преимущества XML-сериализации

Класс **XmlSerializer** обеспечивает полный и гибкий контроль при сериализации объекта как XML. При создании XML-веб-службы к классам и членам можно применять атрибуты управления сериализацией, чтобы выходные данные XML соответствовали определенной схеме.

Например, **XmlSerializer** позволяет:

- Указать, нужно ли кодировать поле или свойство как атрибут или элемент.

- Указать используемое пространство имен XML.

- Указать имя элемента или атрибута, если имя поля или свойства неправильное.

Еще одним преимуществом XML-сериализации является отсутствие ограничений для разрабатываемых приложений, поскольку создаваемый поток XML соответствует определенной схеме. Допустим, имеется схема, которая используется для описания книг. В ней представлены такие элементы, как название, автор, издатель и номер ISBN. Можно разработать приложение, которое обрабатывает данные XML любым удобным способом, например как заказ книги или список книг. В любом случае единственным требованием является соответствие потока XML указанной схеме языка определения схемы XML (XSD).

## <a name="xml-serialization-considerations"></a>Вопросы, связанные XML-сериализацией

При использовании класса **XmlSerializer** следует обратить внимание на следующие аспекты:

- Инструмент Sgen.exe разработан только для создания сборок сериализации для обеспечения оптимальной производительности.

- Сериализованные данные содержат только сами данные и структуру классов. Удостоверения типа и информация о сборке не сохраняются.

- Могут быть сериализованы только открытые свойства и поля. Для свойств должны быть указаны открытые методы доступа (методы get и set). Если необходимо сериализовать закрытые данные, вместо XML-сериализации используйте класс <xref:System.Runtime.Serialization.DataContractSerializer>.

- Класс должен иметь беспараметрыный конструктор, который будет сериализован **XmlSerializer.**

- Методы не могут быть сериализованы.

- **XmlSerializer** может по-разному обрабатывать классы, реализующие **IEnumerable** или **ICollection**, если они соответствуют определенным требованиям, см. ниже.

  Класс, реализующий **IEnumerable**, должен реализовывать открытый метод **Add**, принимающий один параметр. Параметр метода **Add** должен соответствовать (быть полиморфным) типу, возвращаемому из свойства **IEnumerator.Current**, которое возвращается из метода **GetEnumerator**.

  Класс, реализующий **ICollection** в дополнение к **IEnumerable** (например, **CollectionBase**), должен иметь открытое индексированное свойство **Item** (индексатор в C#), которое принимает целое число, и должен иметь открытое свойство **Count** типа **integer**. Параметр, передаваемый методу **Add**, должен быть того же типа, что и возвращаемый из свойства **Item**, или быть одной из баз такого типа.

  Для классов, реализующих **ICollection**, сериализуемые значения извлекаются из индексированного свойства **Item**, а не путем вызова **GetEnumerator**. Кроме того, открытые поля и свойства не сериализуются, за исключением открытых полей, которые возвращают другой класс коллекции (реализующий **ICollection**). Дополнительные примеры XML-сериализации см. в разделе [Примеры сериализации XML](examples-of-xml-serialization.md).

## <a name="xsd-data-type-mapping"></a>Сопоставление типа данных XSD

Документ W3C под названием [XML Schema Part 2: Datatypes](https://www.w3.org/TR/xmlschema-2/) определяет простые типы данных, допускаемые в схеме определения XML Schema (XSD). Для большинства из них (например, **int** и **decimal**) существует соответствующий тип данных в платформе .NET Framework. Однако для некоторых типов данных XML не предусмотрен соответствующий тип данных в платформе .NET Framework (например, тип данных **NMTOKEN**). В таких случаях при использовании инструмента определения схемы XML ([инструмент определения схемы XML (Xsd.exe)](xml-schema-definition-tool-xsd-exe.md)) для создания классов из схемы к члену строкового типа применяется соответствующий атрибут, и его свойство **DataType** задается как имя типа данных XML. Например, если схема содержит элемент с именем "MyToken" с типом данных XML **NMTOKEN**, созданный класс может содержать член, см. пример ниже.

```vb
<XmlElement(DataType:="NMTOKEN")> _
Public MyToken As String
```

```csharp
[XmlElement(DataType = "NMTOKEN")]
public string MyToken;
```

Аналогичным образом, при создании класса, который должен соответствовать определенной схеме XML (XSD), следует применить соответствующий атрибут и задать его свойство **DataType** как необходимое имя типа данных XML.

Полный список сопоставлений типов см. в свойстве **DataType** для любого из следующих классов атрибутов:

- <xref:System.Xml.Serialization.SoapAttributeAttribute>

- <xref:System.Xml.Serialization.SoapElementAttribute>

- <xref:System.Xml.Serialization.XmlArrayItemAttribute>

- <xref:System.Xml.Serialization.XmlAttributeAttribute>

- <xref:System.Xml.Serialization.XmlElementAttribute>

- <xref:System.Xml.Serialization.XmlRootAttribute>

## <a name="see-also"></a>См. также

- <xref:System.Xml.Serialization.XmlSerializer>
- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.IO.FileStream>
- [Сериализация XML и SOAP](xml-and-soap-serialization.md)
- [Двоичная сериализация](binary-serialization.md)
- [Сериализация](index.md)
- <xref:System.Xml.Serialization.XmlSerializer>
- [Примеры сериализации XML](examples-of-xml-serialization.md)
- [Практическое руководство. Сериализация объекта](how-to-serialize-an-object.md)
- [Практическое руководство. Десериализация объекта](how-to-deserialize-an-object.md)
