---
title: Реализация метода Dispose
ms.date: 04/07/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Dispose method
- garbage collection, Dispose method
ms.assetid: eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9
ms.openlocfilehash: f3d3269ccf56954f963762503d2bc1c53b9e6b83
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/15/2020
ms.locfileid: "78238992"
---
# <a name="implementing-a-dispose-method"></a><span data-ttu-id="34672-102">Реализация метода Dispose</span><span class="sxs-lookup"><span data-stu-id="34672-102">Implementing a Dispose method</span></span>

<span data-ttu-id="34672-103">Реализация метода <xref:System.IDisposable.Dispose%2A> необходима для освобождения неуправляемых ресурсов, которые использует ваше приложение.</span><span class="sxs-lookup"><span data-stu-id="34672-103">You implement a <xref:System.IDisposable.Dispose%2A> method to release unmanaged resources used by your application.</span></span> <span data-ttu-id="34672-104">Сборщик мусора .NET не выделяет и не освобождает неуправляемую память.</span><span class="sxs-lookup"><span data-stu-id="34672-104">The .NET garbage collector does not allocate or release unmanaged memory.</span></span>  
  
<span data-ttu-id="34672-105">Шаблон ликвидации объекта, именуемый также [шаблоном удаления](implementing-dispose.md), налагает определенные правила на время жизни объекта.</span><span class="sxs-lookup"><span data-stu-id="34672-105">The pattern for disposing an object, referred to as a [dispose pattern](implementing-dispose.md), imposes order on the lifetime of an object.</span></span> <span data-ttu-id="34672-106">Шаблон удаления используется только для объектов, осуществляющих доступ к неуправляемым ресурсам, таких как дескрипторы файлов и каналов, дескрипторы реестра, дескрипторы ожидания и указатели на блоки неуправляемой памяти.</span><span class="sxs-lookup"><span data-stu-id="34672-106">The dispose pattern is used only for objects that access unmanaged resources, such as file and pipe handles, registry handles, wait handles, or pointers to blocks of unmanaged memory.</span></span> <span data-ttu-id="34672-107">Это вызвано тем, что сборщик мусора очень эффективно удаляет неиспользуемые управляемые объекты, но не может удалить неуправляемые объекты.</span><span class="sxs-lookup"><span data-stu-id="34672-107">This is because the garbage collector is very efficient at reclaiming unused managed objects, but it is unable to reclaim unmanaged objects.</span></span>  
  
<span data-ttu-id="34672-108">Существует два варианта шаблона удаления:</span><span class="sxs-lookup"><span data-stu-id="34672-108">The dispose pattern has two variations:</span></span>  
  
- <span data-ttu-id="34672-109">Заключение в оболочку каждого неуправляемого ресурса, используемого типом в безопасном дескрипторе (то есть в классе, производном от <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="34672-109">You wrap each unmanaged resource that a type uses in a safe handle (that is, in a class derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>).</span></span> <span data-ttu-id="34672-110">В этом случае необходимо реализовать интерфейс <xref:System.IDisposable> и дополнительный метод `Dispose(Boolean)`.</span><span class="sxs-lookup"><span data-stu-id="34672-110">In this case, you implement the <xref:System.IDisposable> interface and an additional `Dispose(Boolean)` method.</span></span> <span data-ttu-id="34672-111">Это рекомендуемый вариант, не требующий переопределения метода <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="34672-111">This is the recommended variation and doesn't require overriding the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span>  
  
  > [!NOTE]
  > <span data-ttu-id="34672-112">Пространство имен <xref:Microsoft.Win32.SafeHandles?displayProperty=nameWithType> содержит набор классов, производных от <xref:System.Runtime.InteropServices.SafeHandle>. Эти классы перечислены в разделе [Использование безопасных дескрипторов](#SafeHandles).</span><span class="sxs-lookup"><span data-stu-id="34672-112">The <xref:Microsoft.Win32.SafeHandles?displayProperty=nameWithType> namespace provides a set of classes derived from <xref:System.Runtime.InteropServices.SafeHandle>, which are listed in the [Using safe handles](#SafeHandles) section.</span></span> <span data-ttu-id="34672-113">Если не удается найти класс, способный освободить неуправляемый ресурс, можно реализовать собственный подкласс <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="34672-113">If you can't find a class that is suitable for releasing your unmanaged resource, you can implement your own subclass of <xref:System.Runtime.InteropServices.SafeHandle>.</span></span>  
  
- <span data-ttu-id="34672-114">Реализация интерфейса <xref:System.IDisposable> и дополнительного метода `Dispose(Boolean)`, а также переопределение метода <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="34672-114">You implement the <xref:System.IDisposable> interface and an additional `Dispose(Boolean)` method, and you also override the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="34672-115">Необходимо переопределить метод <xref:System.Object.Finalize%2A>, чтобы убедиться, что неуправляемые ресурсы удаляются, если реализация <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> не вызывается объектом-получателем типа.</span><span class="sxs-lookup"><span data-stu-id="34672-115">You must override <xref:System.Object.Finalize%2A> to ensure that unmanaged resources are disposed of if your <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation is not called by a consumer of your type.</span></span> <span data-ttu-id="34672-116">При использовании рекомендуемого метода, описанного в предыдущем пункте, класс <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> делает это от вашего имени.</span><span class="sxs-lookup"><span data-stu-id="34672-116">If you use the recommended technique discussed in the previous bullet, the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class does this on your behalf.</span></span>  
  
<span data-ttu-id="34672-117">Чтобы обеспечить соответствующую очистку ресурсов, метод <xref:System.IDisposable.Dispose%2A> должен быть доступен для многократного вызова без выдачи исключения.</span><span class="sxs-lookup"><span data-stu-id="34672-117">To help ensure that resources are always cleaned up appropriately, a <xref:System.IDisposable.Dispose%2A> method should be callable multiple times without throwing an exception.</span></span>  
  
<span data-ttu-id="34672-118">В приведенном для метода <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> примере показано, как сборка мусора может привести к выполнению метода завершения, в то время как по-прежнему будет использоваться неуправляемая ссылка на объект или его члены.</span><span class="sxs-lookup"><span data-stu-id="34672-118">The code example provided for the <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> method shows how garbage collection can cause a finalizer to run, while an unmanaged reference to the object or its members is still in use.</span></span> <span data-ttu-id="34672-119">Возможно, имеет смысл использовать <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType>, чтобы запретить сборку мусора для объекта с момента начала текущей процедуры до вызова этого метода.</span><span class="sxs-lookup"><span data-stu-id="34672-119">It may make sense to utilize <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> to make the object ineligible for garbage collection from the start of the current routine to the point where this method is called.</span></span>
  
<a name="Dispose2"></a>
## <a name="dispose-and-disposeboolean"></a><span data-ttu-id="34672-120">Dispose() и Dispose(Boolean)</span><span class="sxs-lookup"><span data-stu-id="34672-120">Dispose() and Dispose(Boolean)</span></span>  

<span data-ttu-id="34672-121">Интерфейс <xref:System.IDisposable> требует реализации одного метода <xref:System.IDisposable.Dispose%2A> без параметров.</span><span class="sxs-lookup"><span data-stu-id="34672-121">The <xref:System.IDisposable> interface requires the implementation of a single parameterless method, <xref:System.IDisposable.Dispose%2A>.</span></span> <span data-ttu-id="34672-122">Однако шаблон удаления требует реализации двух методов `Dispose`:</span><span class="sxs-lookup"><span data-stu-id="34672-122">However, the dispose pattern requires two `Dispose` methods to be implemented:</span></span>  
  
- <span data-ttu-id="34672-123">Реализация открытого невиртуального (в Visual Basic — `NonInheritable`) метода <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> без параметров.</span><span class="sxs-lookup"><span data-stu-id="34672-123">A public non-virtual (`NonInheritable` in Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation that has no parameters.</span></span>  
  
- <span data-ttu-id="34672-124">Защищенный виртуальный (в Visual Basic — `Overridable`) метод `Dispose` со следующей подписью:</span><span class="sxs-lookup"><span data-stu-id="34672-124">A protected virtual (`Overridable` in Visual Basic) `Dispose` method whose signature is:</span></span>  
  
  [!code-csharp[Conceptual.Disposable#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#8)]
  [!code-vb[Conceptual.Disposable#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#8)]  
  
### <a name="the-dispose-overload"></a><span data-ttu-id="34672-125">Перегрузка Dispose()</span><span class="sxs-lookup"><span data-stu-id="34672-125">The Dispose() overload</span></span>

<span data-ttu-id="34672-126">Поскольку открытый невиртуальный (`NonInheritable` в Visual Basic) метод `Dispose` без параметров вызывается объектом-получателем типа, его назначение состоит в том, чтобы освободить неуправляемые ресурсы и указать, что метод завершения, если он задан, не должен выполняться.</span><span class="sxs-lookup"><span data-stu-id="34672-126">Because the public, non-virtual (`NonInheritable` in Visual Basic), parameterless `Dispose` method is called by a consumer of the type, its purpose is to free unmanaged resources and to indicate that the finalizer, if one is present, doesn't have to run.</span></span> <span data-ttu-id="34672-127">Он имеет стандартную реализацию:</span><span class="sxs-lookup"><span data-stu-id="34672-127">Because of this, it has a standard implementation:</span></span>  
  
[!code-csharp[Conceptual.Disposable#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#7)]
[!code-vb[Conceptual.Disposable#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#7)]  
  
<span data-ttu-id="34672-128">Метод `Dispose` полностью выполняет очистку объектов, поэтому сборщику мусора не требуется вызывать переопределенный метод <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="34672-128">The `Dispose` method performs all object cleanup, so the garbage collector no longer needs to call the objects' <xref:System.Object.Finalize%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="34672-129">Таким образом, вызов метода <xref:System.GC.SuppressFinalize%2A> не позволит сборщику мусора запустить метод завершения.</span><span class="sxs-lookup"><span data-stu-id="34672-129">Therefore, the call to the <xref:System.GC.SuppressFinalize%2A> method prevents the garbage collector from running the finalizer.</span></span> <span data-ttu-id="34672-130">Если тип не имеет метода завершения, вызов метода <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> не производит эффекта.</span><span class="sxs-lookup"><span data-stu-id="34672-130">If the type has no finalizer, the call to <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> has no effect.</span></span> <span data-ttu-id="34672-131">Обратите внимание, что фактическая работа по освобождению неуправляемых ресурсов выполняется вторым перегруженным методом `Dispose`.</span><span class="sxs-lookup"><span data-stu-id="34672-131">Note that the actual work of releasing unmanaged resources is performed by the second overload of the `Dispose` method.</span></span>  
  
### <a name="the-disposeboolean-overload"></a><span data-ttu-id="34672-132">Перегрузка Dispose(Boolean)</span><span class="sxs-lookup"><span data-stu-id="34672-132">The Dispose(Boolean) overload</span></span>

<span data-ttu-id="34672-133">Во второй перегрузке *disposing* используется параметр типа <xref:System.Boolean>, который указывает, откуда осуществляется вызов метода: из метода <xref:System.IDisposable.Dispose%2A> (значение `true`) или из метода завершения (значение `false`).</span><span class="sxs-lookup"><span data-stu-id="34672-133">In the second overload, the *disposing* parameter is a <xref:System.Boolean> that indicates whether the method call comes from a <xref:System.IDisposable.Dispose%2A> method (its value is `true`) or from a finalizer (its value is `false`).</span></span>  
  
<span data-ttu-id="34672-134">Тело метода состоит из двух блоков кода:</span><span class="sxs-lookup"><span data-stu-id="34672-134">The body of the method consists of two blocks of code:</span></span>  
  
- <span data-ttu-id="34672-135">Блок, который освобождает неуправляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="34672-135">A block that frees unmanaged resources.</span></span> <span data-ttu-id="34672-136">Этот блок выполняется вне зависимости от значения параметра `disposing`.</span><span class="sxs-lookup"><span data-stu-id="34672-136">This block executes regardless of the value of the `disposing` parameter.</span></span>  
  
- <span data-ttu-id="34672-137">Условный блок, который освобождает управляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="34672-137">A conditional block that frees managed resources.</span></span> <span data-ttu-id="34672-138">Этот блок выполняется, если параметр `disposing` имеет значение `true`.</span><span class="sxs-lookup"><span data-stu-id="34672-138">This block executes if the value of `disposing` is `true`.</span></span> <span data-ttu-id="34672-139">К управляемым ресурсам, которые он освобождает, могут относиться:</span><span class="sxs-lookup"><span data-stu-id="34672-139">The managed resources that it frees can include:</span></span>  
  
  <span data-ttu-id="34672-140">**Управляемые объекты, реализующие <xref:System.IDisposable>.**</span><span class="sxs-lookup"><span data-stu-id="34672-140">**Managed objects that implement <xref:System.IDisposable>.**</span></span> <span data-ttu-id="34672-141">Условный блок может использоваться для вызова реализации <xref:System.IDisposable.Dispose%2A>.</span><span class="sxs-lookup"><span data-stu-id="34672-141">The conditional block can be used to call their <xref:System.IDisposable.Dispose%2A> implementation.</span></span> <span data-ttu-id="34672-142">При использовании безопасного дескриптора в качестве оболочки для неуправляемого ресурса необходимо вызвать реализацию <xref:System.Runtime.InteropServices.SafeHandle.Dispose%28System.Boolean%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="34672-142">If you have used a safe handle to wrap your unmanaged resource, you should call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose%28System.Boolean%29?displayProperty=nameWithType> implementation here.</span></span>  
  
  <span data-ttu-id="34672-143">**Управляемые объекты, которые используют большие объемы памяти или дефицитные ресурсы**.</span><span class="sxs-lookup"><span data-stu-id="34672-143">**Managed objects that consume large amounts of memory or consume scarce resources.**</span></span> <span data-ttu-id="34672-144">При использовании метода `Dispose` эти объекты освобождаются быстрее, чем при недетерминированной очистке сборщиком мусора.</span><span class="sxs-lookup"><span data-stu-id="34672-144">Freeing these objects explicitly in the `Dispose` method releases them faster than if they were reclaimed non-deterministically by the garbage collector.</span></span>  
  
<span data-ttu-id="34672-145">Если метод вызывается из метода завершения (т. е. если свойство *disposing* имеет значение `false`), выполняется только тот код, который освобождает неуправляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="34672-145">If the method call comes from a finalizer (that is, if *disposing* is `false`), only the code that frees unmanaged resources executes.</span></span> <span data-ttu-id="34672-146">Поскольку порядок уничтожения управляемых объектов сборщиком мусора во время завершения не определен, вызов этой перегрузки `Dispose` со значением `false` предотвращает попытки метода завершения освободить управляемые ресурсы, которые уже могли быть освобождены.</span><span class="sxs-lookup"><span data-stu-id="34672-146">Because the order in which the garbage collector destroys managed objects during finalization is not defined, calling this `Dispose` overload with a value of `false` prevents the finalizer from trying to release managed resources that may have already been reclaimed.</span></span>  
  
## <a name="implementing-the-dispose-pattern-for-a-base-class"></a><span data-ttu-id="34672-147">Реализация шаблона удаления для базового класса</span><span class="sxs-lookup"><span data-stu-id="34672-147">Implementing the dispose pattern for a base class</span></span>

<span data-ttu-id="34672-148">При реализации шаблона удаления для базового класса необходимо следующее:</span><span class="sxs-lookup"><span data-stu-id="34672-148">If you implement the dispose pattern for a base class, you must provide the following:</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="34672-149">Вам следует реализовать этот шаблон для всех базовых классов, которые реализуют <xref:System.IDisposable.Dispose> и не являются `sealed` (`NotInheritable` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="34672-149">You should implement this pattern for all base classes that implement <xref:System.IDisposable.Dispose> and are not `sealed` (`NotInheritable` in Visual Basic).</span></span>  
  
- <span data-ttu-id="34672-150">Реализация <xref:System.IDisposable.Dispose%2A>, которая вызывает метод `Dispose(Boolean)`.</span><span class="sxs-lookup"><span data-stu-id="34672-150">A <xref:System.IDisposable.Dispose%2A> implementation that calls the `Dispose(Boolean)` method.</span></span>  
  
- <span data-ttu-id="34672-151">Метод `Dispose(Boolean)`, который выполняет фактическую работу по освобождению ресурсов.</span><span class="sxs-lookup"><span data-stu-id="34672-151">A `Dispose(Boolean)` method that performs the actual work of releasing resources.</span></span>  
  
- <span data-ttu-id="34672-152">Любой класс, производный от класса <xref:System.Runtime.InteropServices.SafeHandle>, который создает оболочку для неуправляемого ресурс (рекомендуется), или переопределенный метод <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="34672-152">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="34672-153">Класс <xref:System.Runtime.InteropServices.SafeHandle> содержит метод завершения, что освобождает разработчика от необходимости создавать его вручную.</span><span class="sxs-lookup"><span data-stu-id="34672-153">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span>  
  
<span data-ttu-id="34672-154">Вот общий шаблон реализации шаблона удаления для базового класса, который использует безопасный дескриптор.</span><span class="sxs-lookup"><span data-stu-id="34672-154">Here's the general pattern for implementing the dispose pattern for a base class that uses a safe handle.</span></span>  
  
[!code-csharp[System.IDisposable#3](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
[!code-vb[System.IDisposable#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]  
  
> [!NOTE]
> <span data-ttu-id="34672-155">В предыдущем примере используется объект <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> для иллюстрации шаблона. Вместо него может использоваться любой объект, производный от <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="34672-155">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="34672-156">Обратите внимание, что в этом примере неправильно создаются экземпляры объекта <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>.</span><span class="sxs-lookup"><span data-stu-id="34672-156">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>  
  
<span data-ttu-id="34672-157">Вот общий шаблон реализации шаблона удаления для базового класса, который переопределяет метод <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="34672-157">Here's the general pattern for implementing the dispose pattern for a base class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span>  
  
[!code-csharp[System.IDisposable#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
[!code-vb[System.IDisposable#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]  
  
> [!NOTE]
> <span data-ttu-id="34672-158">В C# переопределение <xref:System.Object.Finalize%2A?displayProperty=nameWithType> выполняется путем определения [деструктора](../../csharp/programming-guide/classes-and-structs/destructors.md).</span><span class="sxs-lookup"><span data-stu-id="34672-158">In C#, you override <xref:System.Object.Finalize%2A?displayProperty=nameWithType> by defining a [destructor](../../csharp/programming-guide/classes-and-structs/destructors.md).</span></span>  
  
## <a name="implementing-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="34672-159">Реализация шаблона удаления для производного класса</span><span class="sxs-lookup"><span data-stu-id="34672-159">Implementing the dispose pattern for a derived class</span></span>

<span data-ttu-id="34672-160">Класс, производный от класса, реализующего интерфейс <xref:System.IDisposable>, не должен реализовывать интерфейс <xref:System.IDisposable>, поскольку реализация метода <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> базового класса наследуется производными классами.</span><span class="sxs-lookup"><span data-stu-id="34672-160">A class derived from a class that implements the <xref:System.IDisposable> interface shouldn't implement <xref:System.IDisposable>, because the base class implementation of <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> is inherited by its derived classes.</span></span> <span data-ttu-id="34672-161">Вместо этого для высвобождения ресурсов производного класса необходимо предоставить следующее.</span><span class="sxs-lookup"><span data-stu-id="34672-161">Instead, to release resources of a derived class, you provide the following:</span></span>  
  
- <span data-ttu-id="34672-162">Метод `protected Dispose(Boolean)`, который переопределяет метод базового класса и выполняет фактическую работу по освобождению ресурсов производного класса.</span><span class="sxs-lookup"><span data-stu-id="34672-162">A `protected Dispose(Boolean)` method that overrides the base class method and performs the actual work of releasing the resources of the derived class.</span></span> <span data-ttu-id="34672-163">Этот метод должен также вызвать метод `Dispose(Boolean)` базового класса и передать состояние удаления ресурса в качестве аргумента.</span><span class="sxs-lookup"><span data-stu-id="34672-163">This method should also call the `Dispose(Boolean)` method of the base class and pass its disposing status for the argument.</span></span>  
  
- <span data-ttu-id="34672-164">Любой класс, производный от класса <xref:System.Runtime.InteropServices.SafeHandle>, который создает оболочку для неуправляемого ресурс (рекомендуется), или переопределенный метод <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="34672-164">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="34672-165">Класс <xref:System.Runtime.InteropServices.SafeHandle> содержит метод завершения, что освобождает разработчика от необходимости создавать его вручную.</span><span class="sxs-lookup"><span data-stu-id="34672-165">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span> <span data-ttu-id="34672-166">Если есть метод завершения, он должен вызывать перегруженный метод `Dispose(Boolean)`, указывая при этом аргумент *disposing* со значением `false`.</span><span class="sxs-lookup"><span data-stu-id="34672-166">If you do provide a finalizer, it should call the `Dispose(Boolean)` overload with a *disposing* argument of `false`.</span></span>  
  
<span data-ttu-id="34672-167">Вот общий шаблон реализации шаблона удаления для производного класса, который использует безопасный дескриптор:</span><span class="sxs-lookup"><span data-stu-id="34672-167">Here's the general pattern for implementing the dispose pattern for a derived class that uses a safe handle:</span></span>  
  
[!code-csharp[System.IDisposable#4](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
[!code-vb[System.IDisposable#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]  
  
> [!NOTE]
> <span data-ttu-id="34672-168">В предыдущем примере используется объект <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> для иллюстрации шаблона. Вместо него может использоваться любой объект, производный от <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="34672-168">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="34672-169">Обратите внимание, что в этом примере неправильно создаются экземпляры объекта <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>.</span><span class="sxs-lookup"><span data-stu-id="34672-169">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>  
  
<span data-ttu-id="34672-170">Вот общий шаблон реализации шаблона удаления для производного класса, который переопределяет метод <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="34672-170">Here's the general pattern for implementing the dispose pattern for a derived class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span></span>  
  
[!code-csharp[System.IDisposable#6](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived2.cs#6)]
[!code-vb[System.IDisposable#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived2.vb#6)]  
  
> [!NOTE]
> <span data-ttu-id="34672-171">В C# переопределение <xref:System.Object.Finalize%2A?displayProperty=nameWithType> выполняется путем определения [деструктора](../../csharp/programming-guide/classes-and-structs/destructors.md).</span><span class="sxs-lookup"><span data-stu-id="34672-171">In C#, you override <xref:System.Object.Finalize%2A?displayProperty=nameWithType> by defining a [destructor](../../csharp/programming-guide/classes-and-structs/destructors.md).</span></span>  
  
<a name="SafeHandles"></a>
## <a name="using-safe-handles"></a><span data-ttu-id="34672-172">Использование безопасных дескрипторов</span><span class="sxs-lookup"><span data-stu-id="34672-172">Using safe handles</span></span>

<span data-ttu-id="34672-173">Написание кода для метода завершения объекта является сложной задачей, которая может вызвать проблемы при неправильном выполнении.</span><span class="sxs-lookup"><span data-stu-id="34672-173">Writing code for an object's finalizer is a complex task that can cause problems if not done correctly.</span></span> <span data-ttu-id="34672-174">Поэтому вместо реализации метода завершения рекомендуется создавать объекты <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="34672-174">Therefore, we recommend that you construct <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> objects instead of implementing a finalizer.</span></span>  
  
<span data-ttu-id="34672-175">Классы, производные от класса <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>, упрощают проблемы времени существования объекта путем назначения и освобождения дескрипторов без прерываний.</span><span class="sxs-lookup"><span data-stu-id="34672-175">Classes derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class simplify object lifetime issues by assigning and releasing handles without interruption.</span></span> <span data-ttu-id="34672-176">Они содержат критический метод завершения, который обязательно выполняется во время выгрузки домена приложения.</span><span class="sxs-lookup"><span data-stu-id="34672-176">They contain a critical finalizer that is guaranteed to run while an application domain is unloading.</span></span> <span data-ttu-id="34672-177">Дополнительные сведения о преимуществах использования безопасного дескриптора см. в разделе <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="34672-177">For more information about the advantages of using a safe handle, see <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>.</span></span> <span data-ttu-id="34672-178">Безопасные дескрипторы предоставляются следующими производными классами в пространстве имен <xref:Microsoft.Win32.SafeHandles>:</span><span class="sxs-lookup"><span data-stu-id="34672-178">The following derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace provide safe handles:</span></span>  
  
- <span data-ttu-id="34672-179">Классы <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> и <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> — для файлов, файлов сопоставления памяти и каналов.</span><span class="sxs-lookup"><span data-stu-id="34672-179">The <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>, and <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class, for files, memory mapped files, and pipes.</span></span>  
  
- <span data-ttu-id="34672-180">Класс <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> — для представлений памяти.</span><span class="sxs-lookup"><span data-stu-id="34672-180">The <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class, for memory views.</span></span>  
  
- <span data-ttu-id="34672-181">Классы <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle> и <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> — для конструкций шифрования.</span><span class="sxs-lookup"><span data-stu-id="34672-181">The <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes, for cryptography constructs.</span></span>  
  
- <span data-ttu-id="34672-182">Класс <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> — для разделов реестра.</span><span class="sxs-lookup"><span data-stu-id="34672-182">The <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class, for registry keys.</span></span>  
  
- <span data-ttu-id="34672-183">Класс <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> — для дескрипторов ожидания.</span><span class="sxs-lookup"><span data-stu-id="34672-183">The <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class, for wait handles.</span></span>  
  
<a name="base"></a>
## <a name="using-a-safe-handle-to-implement-the-dispose-pattern-for-a-base-class"></a><span data-ttu-id="34672-184">Использование безопасного дескриптора для реализации шаблона удаления для базового класса</span><span class="sxs-lookup"><span data-stu-id="34672-184">Using a safe handle to implement the dispose pattern for a base class</span></span>

<span data-ttu-id="34672-185">В следующем примере показан шаблон удаления для базового класса `DisposableStreamResource`, который использует безопасный дескриптор для инкапсуляции неуправляемых ресурсов.</span><span class="sxs-lookup"><span data-stu-id="34672-185">The following example illustrates the dispose pattern for a base class, `DisposableStreamResource`, that uses a safe handle to encapsulate unmanaged resources.</span></span> <span data-ttu-id="34672-186">Он определяет класс `DisposableResource`, который использует <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> для создания экземпляра объекта <xref:System.IO.Stream>, который представляет открытый файл.</span><span class="sxs-lookup"><span data-stu-id="34672-186">It defines a `DisposableResource` class that uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> to wrap a <xref:System.IO.Stream> object that represents an open file.</span></span> <span data-ttu-id="34672-187">Метод `DisposableResource` также включает свойство `Size`, которое возвращает общее количество байтов в файловом потоке.</span><span class="sxs-lookup"><span data-stu-id="34672-187">The `DisposableResource` method also includes a single property, `Size`, that returns the total number of bytes in the file stream.</span></span>  
  
[!code-csharp[Conceptual.Disposable#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/base1.cs#9)]
[!code-vb[Conceptual.Disposable#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/base1.vb#9)]  
  
<a name="derived"></a>
## <a name="using-a-safe-handle-to-implement-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="34672-188">Использование безопасного дескриптора для реализации шаблона удаления для производного класса</span><span class="sxs-lookup"><span data-stu-id="34672-188">Using a safe handle to implement the dispose pattern for a derived class</span></span>

<span data-ttu-id="34672-189">В следующем примере показан шаблон удаления для производного класса `DisposableStreamResource2`, унаследованного от класса `DisposableStreamResource`, представленного в предыдущем примере.</span><span class="sxs-lookup"><span data-stu-id="34672-189">The following example illustrates the dispose pattern for a derived class, `DisposableStreamResource2`, that inherits from the `DisposableStreamResource` class presented in the previous example.</span></span> <span data-ttu-id="34672-190">Класс добавляет дополнительный метод `WriteFileInfo` и использует объект <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> для создания экземпляра дескриптора записываемого файла.</span><span class="sxs-lookup"><span data-stu-id="34672-190">The class adds an additional method, `WriteFileInfo`, and uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to wrap the handle of the writable file.</span></span>  
  
[!code-csharp[Conceptual.Disposable#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/derived1.cs#10)]
[!code-vb[Conceptual.Disposable#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/derived1.vb#10)]  
  
## <a name="see-also"></a><span data-ttu-id="34672-191">См. также</span><span class="sxs-lookup"><span data-stu-id="34672-191">See also</span></span>

- <xref:System.GC.SuppressFinalize%2A>
- <xref:System.IDisposable>
- <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>
- <xref:Microsoft.Win32.SafeHandles>
- <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>
- <xref:System.Object.Finalize%2A?displayProperty=nameWithType>
- [<span data-ttu-id="34672-192">Практическое руководство. Определение и использование классов и структур (C++/CLI)</span><span class="sxs-lookup"><span data-stu-id="34672-192">How to: Define and Consume Classes and Structs (C++/CLI)</span></span>](/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli)
- [<span data-ttu-id="34672-193">Шаблон ликвидации</span><span class="sxs-lookup"><span data-stu-id="34672-193">Dispose Pattern</span></span>](implementing-dispose.md)
