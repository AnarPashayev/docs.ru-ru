---
title: Реализация метода Dispose
description: В этой статье описывается реализация метода Dispose, который освобождает неуправляемые ресурсы, используемые вашим кодом в .NET.
ms.date: 05/27/2020
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Dispose method
- garbage collection, Dispose method
ms.assetid: eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9
ms.openlocfilehash: c8b4b9a79577776bc049ef77e222d63374178708
ms.sourcegitcommit: b16c00371ea06398859ecd157defc81301c9070f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/05/2020
ms.locfileid: "84447177"
---
# <a name="implement-a-dispose-method"></a><span data-ttu-id="28ebf-103">Реализация метода Dispose</span><span class="sxs-lookup"><span data-stu-id="28ebf-103">Implement a Dispose method</span></span>

<span data-ttu-id="28ebf-104">Реализация метода <xref:System.IDisposable.Dispose%2A> в основном используется для освобождения неуправляемых ресурсов, которые используются в коде.</span><span class="sxs-lookup"><span data-stu-id="28ebf-104">Implementing the <xref:System.IDisposable.Dispose%2A> method is primarily for releasing unmanaged resources used by your code.</span></span> <span data-ttu-id="28ebf-105">При работе с членами экземпляра, которые являются реализациями <xref:System.IDisposable>, обычно применяются каскадные вызовы <xref:System.IDisposable.Dispose%2A>.</span><span class="sxs-lookup"><span data-stu-id="28ebf-105">When working with instance members that are <xref:System.IDisposable> implementations, it's common to cascade <xref:System.IDisposable.Dispose%2A> calls.</span></span> <span data-ttu-id="28ebf-106">Существуют и другие причины для реализации <xref:System.IDisposable.Dispose%2A>, например отмена ранее выполненных действий.</span><span class="sxs-lookup"><span data-stu-id="28ebf-106">There are additional reasons for implementing <xref:System.IDisposable.Dispose%2A>, such as undoing something that was previously done.</span></span> <span data-ttu-id="28ebf-107">Так можно освободить выделенную память, удалить из коллекции добавленный элемент, сообщить об отмене запрошенной блокировки и т. д.</span><span class="sxs-lookup"><span data-stu-id="28ebf-107">For example, freeing memory that was allocated, removing an item from a collection that was added, signaling the release of a lock that was acquired, and so on.</span></span>

<span data-ttu-id="28ebf-108">[Сборщик мусора .NET](index.md) не выделяет и не освобождает неуправляемую память.</span><span class="sxs-lookup"><span data-stu-id="28ebf-108">The [.NET garbage collector](index.md) does not allocate or release unmanaged memory.</span></span> <span data-ttu-id="28ebf-109">Шаблон освобождения объекта налагает определенные правила на время существования объекта.</span><span class="sxs-lookup"><span data-stu-id="28ebf-109">The pattern for disposing an object, referred to as the dispose pattern, imposes order on the lifetime of an object.</span></span> <span data-ttu-id="28ebf-110">Шаблон освобождения используется для объектов, которые реализуют интерфейс <xref:System.IDisposable>, и часто встречается при взаимодействии с дескрипторами файлов и каналов, дескрипторами реестра, дескрипторами ожидания и указателями на блоки неуправляемой памяти.</span><span class="sxs-lookup"><span data-stu-id="28ebf-110">The dispose pattern is used for objects that implement the <xref:System.IDisposable> interface, and is common when interacting with file and pipe handles, registry handles, wait handles, or pointers to blocks of unmanaged memory.</span></span> <span data-ttu-id="28ebf-111">Это связано с тем, что сборщик мусора не может удалять неуправляемые объекты.</span><span class="sxs-lookup"><span data-stu-id="28ebf-111">This is because the garbage collector is unable to reclaim unmanaged objects.</span></span>

<span data-ttu-id="28ebf-112">Чтобы обеспечить нормальную очистку таких ресурсов, метод <xref:System.IDisposable.Dispose%2A> должен быть идемпотентным, то есть поддерживать многократный вызов без создания исключений.</span><span class="sxs-lookup"><span data-stu-id="28ebf-112">To help ensure that resources are always cleaned up appropriately, a <xref:System.IDisposable.Dispose%2A> method should be idempotent, such that it is callable multiple times without throwing an exception.</span></span> <span data-ttu-id="28ebf-113">Кроме того, последующие вызовы <xref:System.IDisposable.Dispose%2A> не должны выполнять никаких действий.</span><span class="sxs-lookup"><span data-stu-id="28ebf-113">Furthermore, subsequent invocations of <xref:System.IDisposable.Dispose%2A> should do nothing.</span></span>

<span data-ttu-id="28ebf-114">В приведенном для метода <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> примере показано, как сборка мусора может привести к выполнению метода завершения, в то время как по-прежнему будет использоваться неуправляемая ссылка на объект или его члены.</span><span class="sxs-lookup"><span data-stu-id="28ebf-114">The code example provided for the <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> method shows how garbage collection can cause a finalizer to run, while an unmanaged reference to the object or its members is still in use.</span></span> <span data-ttu-id="28ebf-115">Возможно, имеет смысл использовать <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType>, чтобы запретить сборку мусора для объекта с момента начала текущей процедуры до вызова этого метода.</span><span class="sxs-lookup"><span data-stu-id="28ebf-115">It may make sense to utilize <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> to make the object ineligible for garbage collection from the start of the current routine to the point where this method is called.</span></span>

## <a name="safe-handles"></a><span data-ttu-id="28ebf-116">Безопасные дескрипторы</span><span class="sxs-lookup"><span data-stu-id="28ebf-116">Safe handles</span></span>

<span data-ttu-id="28ebf-117">Написание кода для метода завершения объекта является сложной задачей, которая может вызвать проблемы при неправильном выполнении.</span><span class="sxs-lookup"><span data-stu-id="28ebf-117">Writing code for an object's finalizer is a complex task that can cause problems if not done correctly.</span></span> <span data-ttu-id="28ebf-118">Поэтому вместо реализации метода завершения рекомендуется создавать объекты <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="28ebf-118">Therefore, we recommend that you construct <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> objects instead of implementing a finalizer.</span></span>

<span data-ttu-id="28ebf-119"><xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> — это абстрактный управляемый тип, выполняющий роль оболочки для <xref:System.IntPtr?displayProperty=nameWithType>, который идентифицирует неуправляемый ресурс.</span><span class="sxs-lookup"><span data-stu-id="28ebf-119">A <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract managed type that wraps an <xref:System.IntPtr?displayProperty=nameWithType> that identifies an unmanaged resource.</span></span> <span data-ttu-id="28ebf-120">В среде Windows он может обозначать дескриптор, а в среде UNIX — дескриптор файла.</span><span class="sxs-lookup"><span data-stu-id="28ebf-120">On Windows it might identify a handle while on Unix, a file descriptor.</span></span> <span data-ttu-id="28ebf-121">Он обеспечивает всю логику, которая гарантирует, что при удалении `SafeHandle` или уничтожении всех ссылок на `SafeHandle` и завершении экземпляра `SafeHandle` ресурс будет освобожден один и только один раз.</span><span class="sxs-lookup"><span data-stu-id="28ebf-121">It provides all of the logic necessary to ensure that this resource is released once and only once, when the `SafeHandle` is disposed of or when all references to the `SafeHandle` have been dropped and the `SafeHandle` instance is finalized.</span></span>

<span data-ttu-id="28ebf-122"><xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> — это абстрактный базовый класс.</span><span class="sxs-lookup"><span data-stu-id="28ebf-122">The <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract base class.</span></span> <span data-ttu-id="28ebf-123">Производные классы предоставляют определенные экземпляры для различных видов дескрипторов.</span><span class="sxs-lookup"><span data-stu-id="28ebf-123">Derived classes provide specific instances for different kinds of handle.</span></span> <span data-ttu-id="28ebf-124">Эти производные классы проверяют, какие значения <xref:System.IntPtr?displayProperty=nameWithType> считаются недопустимыми и как фактически освободить дескриптор.</span><span class="sxs-lookup"><span data-stu-id="28ebf-124">These derived classes validate what values for the <xref:System.IntPtr?displayProperty=nameWithType> are considered invalid and how to actually free the handle.</span></span> <span data-ttu-id="28ebf-125">Например, класс <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> является производным от `SafeHandle`, выступает оболочкой для структур `IntPtrs`, которые определяют открытые дескрипторы файлов, а также переопределяет свой метод <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> для его закрытия (через функцию `close` в UNIX или `CloseHandle` в Windows).</span><span class="sxs-lookup"><span data-stu-id="28ebf-125">For example, <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> derives from `SafeHandle` to wrap `IntPtrs` that identify open file handles/descriptors, and overrides its <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> method to close it (via the `close` function on Unix or `CloseHandle` function on Windows).</span></span> <span data-ttu-id="28ebf-126">Большинство API-интерфейсов в библиотеках .NET, которые создают неуправляемый ресурс, заключают его в `SafeHandle` и возвращают `SafeHandle` по мере необходимости, но не выдают необработанный указатель.</span><span class="sxs-lookup"><span data-stu-id="28ebf-126">Most APIs in .NET libraries that create an unmanaged resource will wrap it in a `SafeHandle` and return that `SafeHandle` to you as needed, rather than handing back the raw pointer.</span></span> <span data-ttu-id="28ebf-127">В ситуациях, когда вы взаимодействуете с неуправляемым компонентом и получаете структуру `IntPtr` для неуправляемого ресурса, можно создать собственный тип `SafeHandle` в качестве оболочки структуры.</span><span class="sxs-lookup"><span data-stu-id="28ebf-127">In situations where you interact with an unmanaged component and get an `IntPtr` for an unmanaged resource, you can create your own `SafeHandle` type to wrap it.</span></span> <span data-ttu-id="28ebf-128">В результате для некоторых типов, которые не являются `SafeHandle`, нужно реализовать методы завершения. Реализации шаблона освобождения чаще всего являются оболочками для других управляемых ресурсов, некоторые из которых могут быть `SafeHandle`.</span><span class="sxs-lookup"><span data-stu-id="28ebf-128">As a result, few non-`SafeHandle` types need to implement finalizers; most disposable pattern implementations only end up wrapping other managed resources, some of which may be `SafeHandle`s.</span></span>

<span data-ttu-id="28ebf-129">Безопасные дескрипторы предоставляются следующими производными классами в пространстве имен <xref:Microsoft.Win32.SafeHandles>:</span><span class="sxs-lookup"><span data-stu-id="28ebf-129">The following derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace provide safe handles:</span></span>

- <span data-ttu-id="28ebf-130">Классы <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> и <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> — для файлов, файлов сопоставления памяти и каналов.</span><span class="sxs-lookup"><span data-stu-id="28ebf-130">The <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>, and <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class, for files, memory mapped files, and pipes.</span></span>
- <span data-ttu-id="28ebf-131">Класс <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> — для представлений памяти.</span><span class="sxs-lookup"><span data-stu-id="28ebf-131">The <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class, for memory views.</span></span>
- <span data-ttu-id="28ebf-132">Классы <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle> и <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> — для конструкций шифрования.</span><span class="sxs-lookup"><span data-stu-id="28ebf-132">The <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes, for cryptography constructs.</span></span>
- <span data-ttu-id="28ebf-133">Класс <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> — для разделов реестра.</span><span class="sxs-lookup"><span data-stu-id="28ebf-133">The <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class, for registry keys.</span></span>
- <span data-ttu-id="28ebf-134">Класс <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> — для дескрипторов ожидания.</span><span class="sxs-lookup"><span data-stu-id="28ebf-134">The <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class, for wait handles.</span></span>

## <a name="dispose-and-disposebool"></a><span data-ttu-id="28ebf-135">Dispose() и Dispose(bool)</span><span class="sxs-lookup"><span data-stu-id="28ebf-135">Dispose() and Dispose(bool)</span></span>

<span data-ttu-id="28ebf-136">Интерфейс <xref:System.IDisposable> требует реализации одного метода <xref:System.IDisposable.Dispose%2A> без параметров.</span><span class="sxs-lookup"><span data-stu-id="28ebf-136">The <xref:System.IDisposable> interface requires the implementation of a single parameterless method, <xref:System.IDisposable.Dispose%2A>.</span></span> <span data-ttu-id="28ebf-137">Кроме того, любой незапечатанный класс должен иметь дополнительный метод перегрузки `Dispose(bool)`, в котором реализуется следующее:</span><span class="sxs-lookup"><span data-stu-id="28ebf-137">Also, any non-sealed class should have an additional `Dispose(bool)` overload method to be implemented:</span></span>

- <span data-ttu-id="28ebf-138">невиртуальный (`public` в Visual Basic) метод <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> с атрибутом `NonInheritable` и без параметров;</span><span class="sxs-lookup"><span data-stu-id="28ebf-138">A `public` non-virtual (`NonInheritable` in Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation that has no parameters.</span></span>

- <span data-ttu-id="28ebf-139">метод `Dispose` с атрибутом `protected virtual` (`Overridable` в Visual Basic) со следующей сигнатурой:</span><span class="sxs-lookup"><span data-stu-id="28ebf-139">A `protected virtual` (`Overridable` in Visual Basic) `Dispose` method whose signature is:</span></span>

  [!code-csharp[Conceptual.Disposable#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#8)]
  [!code-vb[Conceptual.Disposable#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#8)]

  > [!IMPORTANT]
  > <span data-ttu-id="28ebf-140">Параметр `disposing` при вызове из метода завершения должен иметь значение `false`, а при вызове из метода <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> — значение `true`.</span><span class="sxs-lookup"><span data-stu-id="28ebf-140">The `disposing` parameter should be `false` when called from a finalizer, and `true` when called from the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="28ebf-141">Иными словами, при детерминированном вызове он будет иметь значение `true`, а при недетерминированном вызове — `false`.</span><span class="sxs-lookup"><span data-stu-id="28ebf-141">In other words, it is `true` when deterministically called and `false` when non-deterministically called.</span></span>

### <a name="the-dispose-method"></a><span data-ttu-id="28ebf-142">Метод Dispose()</span><span class="sxs-lookup"><span data-stu-id="28ebf-142">The Dispose() method</span></span>

<span data-ttu-id="28ebf-143">Поскольку невиртуальный (`public` в Visual Basic) метод `Dispose` с атрибутом `NonInheritable` без параметров вызывается объектом-получателем типа, его назначение состоит в том, чтобы освободить неуправляемые ресурсы и указать, что метод завершения, если он задан, не должен выполняться.</span><span class="sxs-lookup"><span data-stu-id="28ebf-143">Because the `public`, non-virtual (`NonInheritable` in Visual Basic), parameterless `Dispose` method is called by a consumer of the type, its purpose is to free unmanaged resources, perform general cleanup, and to indicate that the finalizer, if one is present, doesn't have to run.</span></span> <span data-ttu-id="28ebf-144">Освобождение физической памяти, связанной с управляемым объектом, всегда оставляется [сборщику мусора](index.md).</span><span class="sxs-lookup"><span data-stu-id="28ebf-144">Freeing the actual memory associated with a managed object is always the domain of the [garbage collector](index.md).</span></span> <span data-ttu-id="28ebf-145">Он имеет стандартную реализацию:</span><span class="sxs-lookup"><span data-stu-id="28ebf-145">Because of this, it has a standard implementation:</span></span>

[!code-csharp[Conceptual.Disposable#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#7)]
[!code-vb[Conceptual.Disposable#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#7)]

<span data-ttu-id="28ebf-146">Метод `Dispose` полностью выполняет очистку объектов, поэтому сборщику мусора не требуется вызывать переопределенный метод <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="28ebf-146">The `Dispose` method performs all object cleanup, so the garbage collector no longer needs to call the objects' <xref:System.Object.Finalize%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="28ebf-147">Таким образом, вызов метода <xref:System.GC.SuppressFinalize%2A> не позволит сборщику мусора запустить метод завершения.</span><span class="sxs-lookup"><span data-stu-id="28ebf-147">Therefore, the call to the <xref:System.GC.SuppressFinalize%2A> method prevents the garbage collector from running the finalizer.</span></span> <span data-ttu-id="28ebf-148">Если тип не имеет метода завершения, вызов метода <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> не производит эффекта.</span><span class="sxs-lookup"><span data-stu-id="28ebf-148">If the type has no finalizer, the call to <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> has no effect.</span></span> <span data-ttu-id="28ebf-149">Обратите внимание, что фактическая очистка выполняется в перегрузке метода `Dispose(bool)`.</span><span class="sxs-lookup"><span data-stu-id="28ebf-149">Note that the actual cleanup is performed by the `Dispose(bool)` method overload.</span></span>

### <a name="the-disposebool-method-overload"></a><span data-ttu-id="28ebf-150">Перегрузка метода Dispose(Boolean)</span><span class="sxs-lookup"><span data-stu-id="28ebf-150">The Dispose(bool) method overload</span></span>

<span data-ttu-id="28ebf-151">В этой перегрузке параметр `disposing` типа <xref:System.Boolean> указывает, откуда осуществляется вызов метода: из метода <xref:System.IDisposable.Dispose%2A> (значение `true`) или из метода завершения (значение `false`).</span><span class="sxs-lookup"><span data-stu-id="28ebf-151">In the overload, the `disposing` parameter is a <xref:System.Boolean> that indicates whether the method call comes from a <xref:System.IDisposable.Dispose%2A> method (its value is `true`) or from a finalizer (its value is `false`).</span></span>

<span data-ttu-id="28ebf-152">Тело метода состоит из двух блоков кода:</span><span class="sxs-lookup"><span data-stu-id="28ebf-152">The body of the method consists of two blocks of code:</span></span>

- <span data-ttu-id="28ebf-153">Блок, который освобождает неуправляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="28ebf-153">A block that frees unmanaged resources.</span></span> <span data-ttu-id="28ebf-154">Этот блок выполняется вне зависимости от значения параметра `disposing`.</span><span class="sxs-lookup"><span data-stu-id="28ebf-154">This block executes regardless of the value of the `disposing` parameter.</span></span>
- <span data-ttu-id="28ebf-155">Условный блок, который освобождает управляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="28ebf-155">A conditional block that frees managed resources.</span></span> <span data-ttu-id="28ebf-156">Этот блок выполняется, если параметр `disposing` имеет значение `true`.</span><span class="sxs-lookup"><span data-stu-id="28ebf-156">This block executes if the value of `disposing` is `true`.</span></span> <span data-ttu-id="28ebf-157">К управляемым ресурсам, которые он освобождает, могут относиться:</span><span class="sxs-lookup"><span data-stu-id="28ebf-157">The managed resources that it frees can include:</span></span>

  - <span data-ttu-id="28ebf-158">**Управляемые объекты, реализующие <xref:System.IDisposable>.**</span><span class="sxs-lookup"><span data-stu-id="28ebf-158">**Managed objects that implement <xref:System.IDisposable>.**</span></span> <span data-ttu-id="28ebf-159">Условный блок может использоваться для вызова реализации <xref:System.IDisposable.Dispose%2A> (каскадное удаление).</span><span class="sxs-lookup"><span data-stu-id="28ebf-159">The conditional block can be used to call their <xref:System.IDisposable.Dispose%2A> implementation (cascade dispose).</span></span> <span data-ttu-id="28ebf-160">При использовании класса, производного от <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>, в качестве оболочки для неуправляемого ресурса необходимо вызвать реализацию <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="28ebf-160">If you have used a derived class of <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> to wrap your unmanaged resource, you should call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType> implementation here.</span></span>

  - <span data-ttu-id="28ebf-161">**Управляемые объекты, которые используют большие объемы памяти или дефицитные ресурсы**.</span><span class="sxs-lookup"><span data-stu-id="28ebf-161">**Managed objects that consume large amounts of memory or consume scarce resources.**</span></span> <span data-ttu-id="28ebf-162">Назначайте ссылки на большие управляемые объекты в `null`, чтобы они чаще оказывались недоступными.</span><span class="sxs-lookup"><span data-stu-id="28ebf-162">Assign large managed object references to `null` to make them more likely to be unreachable.</span></span> <span data-ttu-id="28ebf-163">Это позволяет освободить их быстрее, чем при недетерминированном алгоритме удаления.</span><span class="sxs-lookup"><span data-stu-id="28ebf-163">This releases them faster than if they were reclaimed non-deterministically.</span></span>

<span data-ttu-id="28ebf-164">Если метод вызывается из метода завершения, должен выполняться только тот код, который освобождает неуправляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="28ebf-164">If the method call comes from a finalizer, only the code that frees unmanaged resources should execute.</span></span> <span data-ttu-id="28ebf-165">Разработчик обязан следить, чтобы эта ветвь кода не взаимодействовала с управляемыми объектами, которые могли быть освобождены.</span><span class="sxs-lookup"><span data-stu-id="28ebf-165">The implementer is responsible for ensuring the the false path doesn't interact with managed objects that may have been reclaimed.</span></span> <span data-ttu-id="28ebf-166">Это важно, поскольку порядок, в котором сборщик мусора уничтожает управляемые объекты в процессе завершения, не детерминирован.</span><span class="sxs-lookup"><span data-stu-id="28ebf-166">This is important because the order in which the garbage collector destroys managed objects during finalization is non-deterministic.</span></span>

## <a name="cascade-dispose-calls"></a><span data-ttu-id="28ebf-167">Каскадные вызовы Dispose</span><span class="sxs-lookup"><span data-stu-id="28ebf-167">Cascade dispose calls</span></span>

<span data-ttu-id="28ebf-168">Если класс имеет собственное поле или свойство, а его тип реализует <xref:System.IDisposable>, сам класс также обязан реализовывать <xref:System.IDisposable>.</span><span class="sxs-lookup"><span data-stu-id="28ebf-168">If your class owns a field or property, and its type implements <xref:System.IDisposable>, the containing class itself should also implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="28ebf-169">Класс, который создает экземпляр реализации <xref:System.IDisposable> и сохраняет его в качестве члена экземпляра, обязан самостоятельно очищать его.</span><span class="sxs-lookup"><span data-stu-id="28ebf-169">A class that instantiates an <xref:System.IDisposable> implementation and storing it as an instance member, is also responsible for its cleanup.</span></span> <span data-ttu-id="28ebf-170">Это поможет гарантировать, что удаляемые ссылочные типы получат возможность выполнять очистку детерминированно с помощью метода <xref:System.IDisposable.Dispose%2A>.</span><span class="sxs-lookup"><span data-stu-id="28ebf-170">This is to help ensure that the referenced disposable types are given the opportunity to deterministically perform clean up through the <xref:System.IDisposable.Dispose%2A> method.</span></span> <span data-ttu-id="28ebf-171">В нашем примере представлен класс `sealed` (или `NotInheritable` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="28ebf-171">In this example, the class is `sealed` (or `NotInheritable` in Visual Basic).</span></span>

[!code-csharp[Conceptual.Disposable#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/disposable1.cs#1)]
[!code-vb[Conceptual.Disposable#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/disposable1.vb#1)]

## <a name="implement-the-dispose-pattern"></a><span data-ttu-id="28ebf-172">Реализация шаблона освобождения</span><span class="sxs-lookup"><span data-stu-id="28ebf-172">Implement the dispose pattern</span></span>

<span data-ttu-id="28ebf-173">Все незапечатанные классы (в Visual Basic это классы, не имеющие модификатора `NotInheritable`) должны считаться потенциальным базовым классом, так как они поддерживают наследование.</span><span class="sxs-lookup"><span data-stu-id="28ebf-173">All non-sealed classes or (Visual Basic classes not modified as `NotInheritable`) should be considered a potential base class, because they could be inherited.</span></span> <span data-ttu-id="28ebf-174">При реализации шаблона освобождения для любого класса, который может быть базовым, необходимо обеспечить следующее:</span><span class="sxs-lookup"><span data-stu-id="28ebf-174">If you implement the dispose pattern for any potential base class, you must provide the following:</span></span>

- <span data-ttu-id="28ebf-175">Реализация <xref:System.IDisposable.Dispose%2A>, которая вызывает метод `Dispose(bool)`.</span><span class="sxs-lookup"><span data-stu-id="28ebf-175">A <xref:System.IDisposable.Dispose%2A> implementation that calls the `Dispose(bool)` method.</span></span>
- <span data-ttu-id="28ebf-176">Метод `Dispose(bool)`, который выполняет фактическую очистку.</span><span class="sxs-lookup"><span data-stu-id="28ebf-176">A `Dispose(bool)` method that performs the actual cleanup.</span></span>
- <span data-ttu-id="28ebf-177">Любой класс, производный от класса <xref:System.Runtime.InteropServices.SafeHandle>, который создает оболочку для неуправляемого ресурс (рекомендуется), или переопределенный метод <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="28ebf-177">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="28ebf-178">Класс <xref:System.Runtime.InteropServices.SafeHandle> предоставляет метод завершения, поэтому вам не нужно создавать этот метод самостоятельно.</span><span class="sxs-lookup"><span data-stu-id="28ebf-178">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer, so you do not have to write one yourself.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="28ebf-179">Базовый класс может ссылаться только на управляемые объекты и реализовывать шаблон освобождения.</span><span class="sxs-lookup"><span data-stu-id="28ebf-179">It is possible for a base class to only reference managed objects, and implement the dispose pattern.</span></span> <span data-ttu-id="28ebf-180">В таких случаях метод завершения не нужен.</span><span class="sxs-lookup"><span data-stu-id="28ebf-180">In these cases, a finalizer is unnecessary.</span></span> <span data-ttu-id="28ebf-181">Метод завершения нужен только в том случае, если используются прямые ссылки на неуправляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="28ebf-181">A finalizer is only required if you directly reference unmanaged resources.</span></span>

<span data-ttu-id="28ebf-182">Вот общий шаблон реализации шаблона удаления для базового класса, который использует безопасный дескриптор.</span><span class="sxs-lookup"><span data-stu-id="28ebf-182">Here's the general pattern for implementing the dispose pattern for a base class that uses a safe handle.</span></span>

[!code-csharp[System.IDisposable#3](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
[!code-vb[System.IDisposable#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]

> [!NOTE]
> <span data-ttu-id="28ebf-183">В предыдущем примере используется объект <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> для иллюстрации шаблона. Вместо него может использоваться любой объект, производный от <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="28ebf-183">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="28ebf-184">Обратите внимание, что в этом примере неправильно создаются экземпляры объекта <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>.</span><span class="sxs-lookup"><span data-stu-id="28ebf-184">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="28ebf-185">Вот общий шаблон реализации шаблона удаления для базового класса, который переопределяет метод <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="28ebf-185">Here's the general pattern for implementing the dispose pattern for a base class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span>

[!code-csharp[System.IDisposable#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
[!code-vb[System.IDisposable#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]

> [!TIP]
> <span data-ttu-id="28ebf-186">В C# [метод завершения](../../csharp/programming-guide/classes-and-structs/destructors.md) создается путем переопределения метода <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="28ebf-186">In C#, you create a [finalizer](../../csharp/programming-guide/classes-and-structs/destructors.md) by overriding <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="28ebf-187">В Visual Basic для этого используется `Protected Overrides Sub Finalize()`.</span><span class="sxs-lookup"><span data-stu-id="28ebf-187">In Visual Basic, this is done with `Protected Overrides Sub Finalize()`.</span></span>

## <a name="implement-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="28ebf-188">Реализация шаблона освобождения для производного класса</span><span class="sxs-lookup"><span data-stu-id="28ebf-188">Implement the dispose pattern for a derived class</span></span>

<span data-ttu-id="28ebf-189">Класс, производный от класса, реализующего интерфейс <xref:System.IDisposable>, не должен реализовывать интерфейс <xref:System.IDisposable>, поскольку реализация метода <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> базового класса наследуется производными классами.</span><span class="sxs-lookup"><span data-stu-id="28ebf-189">A class derived from a class that implements the <xref:System.IDisposable> interface shouldn't implement <xref:System.IDisposable>, because the base class implementation of <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> is inherited by its derived classes.</span></span> <span data-ttu-id="28ebf-190">Вместо этого для очистки производного класса необходимо предоставить следующее:</span><span class="sxs-lookup"><span data-stu-id="28ebf-190">Instead, to cleanup a derived class, you provide the following:</span></span>

- <span data-ttu-id="28ebf-191">Метод `protected override void Dispose(bool)`, который переопределяет метод базового класса и выполняет фактическую очистку производного класса.</span><span class="sxs-lookup"><span data-stu-id="28ebf-191">A `protected override void Dispose(bool)` method that overrides the base class method and performs the actual cleanup of the derived class.</span></span> <span data-ttu-id="28ebf-192">Кроме того, этот метод должен вызывать метод `base.Dispose(bool)` базового класса (`MyBase.Dispose(bool)` в Visual Basic) и передавать состояние освобождения ресурса в качестве аргумента.</span><span class="sxs-lookup"><span data-stu-id="28ebf-192">This method must also call the `base.Dispose(bool)` (`MyBase.Dispose(bool)` in Visual Basic) method of the base class and pass its disposing status for the argument.</span></span>
- <span data-ttu-id="28ebf-193">Любой класс, производный от класса <xref:System.Runtime.InteropServices.SafeHandle>, который создает оболочку для неуправляемого ресурс (рекомендуется), или переопределенный метод <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="28ebf-193">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="28ebf-194">Класс <xref:System.Runtime.InteropServices.SafeHandle> содержит метод завершения, что освобождает разработчика от необходимости создавать его вручную.</span><span class="sxs-lookup"><span data-stu-id="28ebf-194">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span> <span data-ttu-id="28ebf-195">Если есть метод завершения, он должен вызывать перегрузку `Dispose(bool)`, указывая аргумент `disposing` со значением `false`.</span><span class="sxs-lookup"><span data-stu-id="28ebf-195">If you do provide a finalizer, it must call the `Dispose(bool)` overload with a `disposing` argument of `false`.</span></span>

<span data-ttu-id="28ebf-196">Вот общий шаблон реализации шаблона удаления для производного класса, который использует безопасный дескриптор:</span><span class="sxs-lookup"><span data-stu-id="28ebf-196">Here's the general pattern for implementing the dispose pattern for a derived class that uses a safe handle:</span></span>

[!code-csharp[System.IDisposable#4](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
[!code-vb[System.IDisposable#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]

> [!NOTE]
> <span data-ttu-id="28ebf-197">В предыдущем примере используется объект <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> для иллюстрации шаблона. Вместо него может использоваться любой объект, производный от <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="28ebf-197">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="28ebf-198">Обратите внимание, что в этом примере неправильно создаются экземпляры объекта <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>.</span><span class="sxs-lookup"><span data-stu-id="28ebf-198">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="28ebf-199">Вот общий шаблон реализации шаблона удаления для производного класса, который переопределяет метод <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="28ebf-199">Here's the general pattern for implementing the dispose pattern for a derived class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span></span>

[!code-csharp[System.IDisposable#6](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived2.cs#6)]
[!code-vb[System.IDisposable#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived2.vb#6)]

## <a name="implement-the-dispose-pattern-with-safe-handles"></a><span data-ttu-id="28ebf-200">Реализация шаблона освобождения с безопасными дескрипторами</span><span class="sxs-lookup"><span data-stu-id="28ebf-200">Implement the dispose pattern with safe handles</span></span>

<span data-ttu-id="28ebf-201">В следующем примере показан шаблон удаления для базового класса `DisposableStreamResource`, который использует безопасный дескриптор для инкапсуляции неуправляемых ресурсов.</span><span class="sxs-lookup"><span data-stu-id="28ebf-201">The following example illustrates the dispose pattern for a base class, `DisposableStreamResource`, that uses a safe handle to encapsulate unmanaged resources.</span></span> <span data-ttu-id="28ebf-202">Он определяет класс `DisposableStreamResource`, который использует <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> для создания экземпляра объекта <xref:System.IO.Stream>, который представляет открытый файл.</span><span class="sxs-lookup"><span data-stu-id="28ebf-202">It defines a `DisposableStreamResource` class that uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> to wrap a <xref:System.IO.Stream> object that represents an open file.</span></span> <span data-ttu-id="28ebf-203">Кроме того, этот класс содержит одно свойство, `Size`, которое возвращает общее количество байтов в файловом потоке.</span><span class="sxs-lookup"><span data-stu-id="28ebf-203">The class also includes a single property, `Size`, that returns the total number of bytes in the file stream.</span></span>

[!code-csharp[Conceptual.Disposable#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/base1.cs#9)]
[!code-vb[Conceptual.Disposable#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/base1.vb#9)]

## <a name="implement-the-dispose-pattern-for-a-derived-class-with-safe-handles"></a><span data-ttu-id="28ebf-204">Реализация шаблона освобождения для производного класса с безопасными дескрипторами</span><span class="sxs-lookup"><span data-stu-id="28ebf-204">Implement the dispose pattern for a derived class with safe handles</span></span>

<span data-ttu-id="28ebf-205">В следующем примере показан шаблон удаления для производного класса `DisposableStreamResource2`, унаследованного от класса `DisposableStreamResource`, представленного в предыдущем примере.</span><span class="sxs-lookup"><span data-stu-id="28ebf-205">The following example illustrates the dispose pattern for a derived class, `DisposableStreamResource2`, that inherits from the `DisposableStreamResource` class presented in the previous example.</span></span> <span data-ttu-id="28ebf-206">Класс добавляет дополнительный метод `WriteFileInfo` и использует объект <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> для создания экземпляра дескриптора записываемого файла.</span><span class="sxs-lookup"><span data-stu-id="28ebf-206">The class adds an additional method, `WriteFileInfo`, and uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to wrap the handle of the writable file.</span></span>

[!code-csharp[Conceptual.Disposable#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/derived1.cs#10)]
[!code-vb[Conceptual.Disposable#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/derived1.vb#10)]

## <a name="see-also"></a><span data-ttu-id="28ebf-207">См. также</span><span class="sxs-lookup"><span data-stu-id="28ebf-207">See also</span></span>

- <xref:System.GC.SuppressFinalize%2A>
- <xref:System.IDisposable>
- <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>
- <xref:Microsoft.Win32.SafeHandles>
- <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>
- <xref:System.Object.Finalize%2A?displayProperty=nameWithType>
- [<span data-ttu-id="28ebf-208">Определение и использование классов и структур (C++/CLI)</span><span class="sxs-lookup"><span data-stu-id="28ebf-208">Define and consume classes and structs (C++/CLI)</span></span>](/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli)
