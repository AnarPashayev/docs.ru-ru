---
title: Перегрузки операторов
ms.date: 10/22/2008
helpviewer_keywords:
- operators [.NET Framework], overloads
- names [.NET Framework], overloaded operators
- member design guidelines, operators
- overloaded operators
ms.assetid: 37585bf2-4c27-4dee-849a-af70e3338cc1
ms.openlocfilehash: 7757e6cfdb9ae31f6e94c26a2684f8176174499a
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/24/2020
ms.locfileid: "95734820"
---
# <a name="operator-overloads"></a>Перегрузки операторов

Перегрузки операторов позволяют отображать типы платформ, как если бы они были встроенными примитивами языка.

 Хотя в некоторых ситуациях это разрешено и полезно, перегрузки операторов следует использовать осторожно. Существует множество случаев, когда перегрузка операторов была нарушена, например, когда конструкторы инфраструктуры начали использовать операторы для операций, которые должны быть простыми методами. Следующие рекомендации помогут решить, когда и как использовать перегрузку операторов.

 ❌ Избегайте определения перегрузок операторов, за исключением типов, которые должны иметь вид примитивов (встроенных) типов.

 ✔️ Рассмотрите возможность определения перегрузок операторов в типе, который должен иметь вид примитивного типа.

 Например, <xref:System.String?displayProperty=nameWithType> имеет `operator==` и `operator!=` определен.

 ✔️ определить перегрузки операторов в структурах, представляющих числа (например, <xref:System.Decimal?displayProperty=nameWithType> ).

 ❌ НЕ милые при определении перегрузок операторов.

 Перегрузка операторов полезна в случаях, когда она сразу же очевидна, как будет получен результат операции. Например, имеет смысл вычесть его <xref:System.DateTime> из другого `DateTime` и получить <xref:System.TimeSpan> . Однако не рекомендуется использовать оператор логического объединения для объединения двух запросов к базе данных или для записи в поток с помощью оператора сдвига.

 ❌ НЕ следует предоставлять перегрузки операторов, если по крайней мере один из операндов не относится к типу, определяющему перегрузку.

 ✔️ операторы перегрузки в симметричном режиме.

 Например, при перегрузке необходимо `operator==` также перегрузить `operator!=` . Аналогично, при перегрузке `operator<` , следует также перегружать `operator>` и т. д.

 ✔️ Рассмотрите возможность предоставления методов с понятными именами, соответствующими каждому перегруженному оператору.

 Многие языки не поддерживают перегрузку операторов. По этой причине рекомендуется, чтобы типы, которые являются перегрузками операторов, включали дополнительный метод с соответствующим доменным именем, обеспечивающим эквивалентную функциональность.

 Следующая таблица содержит список операторов и соответствующие имена понятных методов.

|Символ оператора C#|Имя метаданных|Понятное имя|
|-------------------------|-------------------|-------------------|
|`N/A`|`op_Implicit`|`To<TypeName>/From<TypeName>`|
|`N/A`|`op_Explicit`|`To<TypeName>/From<TypeName>`|
|`+ (binary)`|`op_Addition`|`Add`|
|`- (binary)`|`op_Subtraction`|`Subtract`|
|`* (binary)`|`op_Multiply`|`Multiply`|
|`/`|`op_Division`|`Divide`|
|`%`|`op_Modulus`|`Mod or Remainder`|
|`^`|`op_ExclusiveOr`|`Xor`|
|`& (binary)`|`op_BitwiseAnd`|`BitwiseAnd`|
|<code>&#124;</code>|`op_BitwiseOr`|`BitwiseOr`|
|`&&`|`op_LogicalAnd`|`And`|
|<code>&#124;&#124;</code>|`op_LogicalOr`|`Or`|
|`=`|`op_Assign`|`Assign`|
|`<<`|`op_LeftShift`|`LeftShift`|
|`>>`|`op_RightShift`|`RightShift`|
|`N/A`|`op_SignedRightShift`|`SignedRightShift`|
|`N/A`|`op_UnsignedRightShift`|`UnsignedRightShift`|
|`==`|`op_Equality`|`Equals`|
|`!=`|`op_Inequality`|`Equals`|
|`>`|`op_GreaterThan`|`CompareTo`|
|`<`|`op_LessThan`|`CompareTo`|
|`>=`|`op_GreaterThanOrEqual`|`CompareTo`|
|`<=`|`op_LessThanOrEqual`|`CompareTo`|
|`*=`|`op_MultiplicationAssignment`|`Multiply`|
|`-=`|`op_SubtractionAssignment`|`Subtract`|
|`^=`|`op_ExclusiveOrAssignment`|`Xor`|
|`<<=`|`op_LeftShiftAssignment`|`LeftShift`|
|`%=`|`op_ModulusAssignment`|`Mod`|
|`+=`|`op_AdditionAssignment`|`Add`|
|`&=`|`op_BitwiseAndAssignment`|`BitwiseAnd`|
|<code>&#124;=</code>|`op_BitwiseOrAssignment`|`BitwiseOr`|
|`,`|`op_Comma`|`Comma`|
|`/=`|`op_DivisionAssignment`|`Divide`|
|`--`|`op_Decrement`|`Decrement`|
|`++`|`op_Increment`|`Increment`|
|`- (unary)`|`op_UnaryNegation`|`Negate`|
|`+ (unary)`|`op_UnaryPlus`|`Plus`|
|`~`|`op_OnesComplement`|`OnesComplement`|

### <a name="overloading-operator-"></a>Перегрузка оператора = =

 Перегрузка `operator ==` является довольно сложной. Семантика оператора должна быть совместима с несколькими другими членами, такими как <xref:System.Object.Equals%2A?displayProperty=nameWithType> .

### <a name="conversion-operators"></a>Операторы преобразования

 Операторы преобразования — это унарные операторы, позволяющие выполнять преобразование из одного типа в другой. Операторы должны быть определены как статические члены либо в операнде, либо в типе возвращаемого значения. Существует два типа операторов преобразования: Implicit и EXPLICIT.

 ❌ НЕ следует предоставлять оператор преобразования, если такое преобразование явно не ожидается конечными пользователями.

 ❌ НЕ определяйте операторы преобразования за пределами домена типа.

 Например,, <xref:System.Int32> <xref:System.Double> и <xref:System.Decimal> являются числовыми типами, тогда как <xref:System.DateTime> — нет. Поэтому оператор преобразования в не должен быть преобразован в `Double(long)` `DateTime` . В этом случае предпочтительнее использовать конструктор.

 ❌ НЕ следует предоставлять неявный оператор преобразования, если преобразование потенциально может быть утеряно.

 Например, не должно быть неявного преобразования из `Double` в, `Int32` поскольку `Double` имеет более широкий диапазон, чем `Int32` . Оператор явного преобразования может быть предоставлен даже в том случае, если преобразование потенциально теряется.

 ❌ НЕ создавайте исключения из неявных приведений.

 Конечным пользователям очень сложно понять, что происходит, так как они могут не знать, что выполняется преобразование.

 ✔️ выдавать исключение, <xref:System.InvalidCastException?displayProperty=nameWithType> Если вызов оператора CAST приводит к преобразованию потери данных и контракт оператора не допускает преобразования с потерей данных.

 *Части © 2005, 2009 Корпорация Майкрософт. Все права защищены.*

 *Перепечатано с разрешения Pearson Education, Inc. из книги [Инфраструктура программных проектов. Соглашения, идиомы и шаблоны для многократно используемых библиотек .NET (2-е издание)](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619), авторы: Кржиштоф Цвалина (Krzysztof Cwalina) и Брэд Абрамс (Brad Abrams). Книга опубликована 22 октября 2008 г. издательством Addison-Wesley Professional в рамках серии, посвященной разработке для Microsoft Windows.*

## <a name="see-also"></a>См. также раздел

- [Рекомендации по проектированию членов](member.md)
- [Рекомендации по проектированию платформы](index.md)
