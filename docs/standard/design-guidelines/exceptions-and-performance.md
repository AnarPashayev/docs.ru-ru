---
title: Исключения и производительность
ms.date: 10/22/2008
ms.technology: dotnet-standard
helpviewer_keywords:
- tester-doer pattern
- TryParse pattern
- exceptions, throwing
- exceptions, performance
- throwing exceptions, performance
ms.assetid: 3ad6aad9-08e6-4232-b336-0e301f2493e6
ms.openlocfilehash: a558547f0e6770e7e76ca31f760d6e2f55c712db
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/02/2020
ms.locfileid: "84289789"
---
# <a name="exceptions-and-performance"></a>Исключения и производительность
Одной из распространенных проблем, связанных с исключениями, является то, что если исключения используются для кода, который обычно завершается ошибкой, производительность реализации будет неприемлемой. Это является действительной проблемой. Когда член создает исключение, его производительность может быть меньше. Однако можно достичь хорошей производительности, при этом строго придерживаться правил исключения, которые не позволяют использовать коды ошибок. Два шаблона, описанные в этом разделе, предлагают способы этого.

 ❌НЕ используйте коды ошибок из-за проблем, с которыми исключения могут негативно сказаться на производительности.

 Чтобы повысить производительность, можно использовать шаблон Test-злодея или шаблон Try-Parse, описанный в следующих двух разделах.

## <a name="tester-doer-pattern"></a>Тест-инженер — шаблон злодея
 Иногда производительность члена, вызывающего исключение, может быть улучшена путем разбиения члена на два. Рассмотрим <xref:System.Collections.Generic.ICollection%601.Add%2A> метод <xref:System.Collections.Generic.ICollection%601> интерфейса.

```csharp
ICollection<int> numbers = ...
numbers.Add(1);
```

 Метод `Add` вызывает исключение, если коллекция доступна только для чтения. Это может быть проблемой с производительностью в сценариях, когда ожидается, что вызов метода будет выполняться часто. Один из способов устранения проблемы заключается в том, чтобы проверить, является ли коллекция доступной для записи, прежде чем пытаться добавить значение.

```csharp
ICollection<int> numbers = ...
...
if (!numbers.IsReadOnly)
{
    numbers.Add(1);
}
```

 Элемент, используемый для проверки условия, которое в нашем примере является свойством `IsReadOnly` , называется инженером-тестировщиком. Элемент, используемый для выполнения потенциального вызова операции, `Add` метод в нашем примере, называется злодея.

 ✔️ Рассмотрите шаблон Test-злодея для членов, которые могут создавать исключения в распространенных сценариях, чтобы избежать проблем с производительностью, связанных с исключениями.

## <a name="try-parse-pattern"></a>Шаблон Try-Parse
 Для очень чувствительных к производительности интерфейсов API следует использовать еще более быстрый шаблон, чем шаблон Test-злодея, описанный в предыдущем разделе. Шаблон вызывает метод для настройки имени элемента, чтобы сделать строго определенный тестовый случай частью семантики элемента. Например, <xref:System.DateTime> определяет <xref:System.DateTime.Parse%2A> метод, который создает исключение, если синтаксический анализ строки завершается ошибкой. Он также определяет соответствующий <xref:System.DateTime.TryParse%2A> метод, который пытается выполнить синтаксический анализ, но возвращает значение false, если синтаксический анализ завершается неудачно, и возвращает результат успешного анализа с помощью `out` параметра.

```csharp
public struct DateTime
{
    public static DateTime Parse(string dateTime)
    {
        ...
    }
    public static bool TryParse(string dateTime, out DateTime result)
    {
        ...
    }
}
```

 При использовании этого шаблона важно определить функциональность Try в условиях ограниченного использования. Если элемент завершается ошибкой по какой-либо причине, отличной от правильно определенной, член должен по-прежнему вызывать соответствующее исключение.

 ✔️ РАССМОТРИМ шаблон Try-Parse для членов, которые могут вызывать исключения в распространенных сценариях, чтобы избежать проблем с производительностью, связанных с исключениями.

 ✔️ использовать префикс "try" и логический тип возвращаемого значения для методов, реализующих этот шаблон.

 ✔️ предоставить элемент, создающий исключения, для каждого члена с помощью шаблона try-Parse.

 *Части © 2005, 2009 Корпорация Майкрософт. Все права защищены.*

 *Перепечатано с разрешения Pearson Education, Inc. из книги [Инфраструктура программных проектов. Соглашения, идиомы и шаблоны для многократно используемых библиотек .NET (2-е издание)](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619), авторы: Кржиштоф Цвалина (Krzysztof Cwalina) и Брэд Абрамс (Brad Abrams). Книга опубликована 22 октября 2008 г. издательством Addison-Wesley Professional в рамках серии, посвященной разработке для Microsoft Windows.*

## <a name="see-also"></a>См. также

- [Рекомендации по проектированию платформы](index.md)
- [Правила разработки исключений](exceptions.md)
