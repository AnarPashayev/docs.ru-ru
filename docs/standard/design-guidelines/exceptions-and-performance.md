---
title: Исключения и производительность
ms.date: 10/22/2008
helpviewer_keywords:
- tester-doer pattern
- TryParse pattern
- exceptions, throwing
- exceptions, performance
- throwing exceptions, performance
ms.assetid: 3ad6aad9-08e6-4232-b336-0e301f2493e6
ms.openlocfilehash: babe378e0d61357709006e08f71ff578492f116c
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/24/2020
ms.locfileid: "95734755"
---
# <a name="exceptions-and-performance"></a>Исключения и производительность

Одной из распространенных проблем, связанных с исключениями, является то, что если исключения используются для кода, который обычно завершается ошибкой, производительность реализации будет неприемлемой. Это является действительной проблемой. Когда член создает исключение, его производительность может быть меньше. Однако можно достичь хорошей производительности, при этом строго придерживаться правил исключения, которые не позволяют использовать коды ошибок. Два шаблона, описанные в этом разделе, предлагают способы этого.

 ❌ НЕ используйте коды ошибок из-за проблем, с которыми исключения могут негативно сказаться на производительности.

 Чтобы повысить производительность, можно использовать шаблон Tester-Doer или шаблон Try-Parse, как описано в следующих двух разделах.

## <a name="tester-doer-pattern"></a>Шаблон Tester-Doer

 Иногда производительность члена, вызывающего исключение, может быть улучшена путем разбиения члена на два. Рассмотрим <xref:System.Collections.Generic.ICollection%601.Add%2A> метод <xref:System.Collections.Generic.ICollection%601> интерфейса.

```csharp
ICollection<int> numbers = ...
numbers.Add(1);
```

 Метод `Add` вызывает исключение, если коллекция доступна только для чтения. Это может быть проблемой с производительностью в сценариях, когда ожидается, что вызов метода будет выполняться часто. Один из способов устранения проблемы заключается в том, чтобы проверить, является ли коллекция доступной для записи, прежде чем пытаться добавить значение.

```csharp
ICollection<int> numbers = ...
...
if (!numbers.IsReadOnly)
{
    numbers.Add(1);
}
```

 Элемент, используемый для проверки условия, которое в нашем примере является свойством `IsReadOnly` , называется инженером-тестировщиком. Элемент, используемый для выполнения потенциального вызова операции, `Add` метод в нашем примере, называется злодея.

 ✔️ Рассмотрите шаблон Tester-Doer для членов, которые могут создавать исключения в распространенных сценариях, чтобы избежать проблем с производительностью, связанных с исключениями.

## <a name="try-parse-pattern"></a>Шаблон Try-Parse

 Для очень чувствительных к производительности интерфейсов API следует использовать еще более быстрый шаблон, чем шаблон Tester-Doer, описанный в предыдущем разделе. Шаблон вызывает метод для настройки имени элемента, чтобы сделать строго определенный тестовый случай частью семантики элемента. Например, <xref:System.DateTime> определяет <xref:System.DateTime.Parse%2A> метод, который создает исключение, если синтаксический анализ строки завершается ошибкой. Он также определяет соответствующий <xref:System.DateTime.TryParse%2A> метод, который пытается выполнить синтаксический анализ, но возвращает значение false, если синтаксический анализ завершается неудачно, и возвращает результат успешного анализа с помощью `out` параметра.

```csharp
public struct DateTime
{
    public static DateTime Parse(string dateTime)
    {
        ...
    }
    public static bool TryParse(string dateTime, out DateTime result)
    {
        ...
    }
}
```

 При использовании этого шаблона важно определить функциональность Try в условиях ограниченного использования. Если элемент завершается ошибкой по какой-либо причине, отличной от правильно определенной, член должен по-прежнему вызывать соответствующее исключение.

 ✔️ Рассмотрите шаблон Try-Parse для членов, которые могут создавать исключения в распространенных сценариях, чтобы избежать проблем с производительностью, связанных с исключениями.

 ✔️ использовать префикс "try" и логический тип возвращаемого значения для методов, реализующих этот шаблон.

 ✔️ предоставить элемент, создающий исключения, для каждого члена, используя шаблон Try-Parse.

 *Части © 2005, 2009 Корпорация Майкрософт. Все права защищены.*

 *Перепечатано с разрешения Pearson Education, Inc. из книги [Инфраструктура программных проектов. Соглашения, идиомы и шаблоны для многократно используемых библиотек .NET (2-е издание)](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619), авторы: Кржиштоф Цвалина (Krzysztof Cwalina) и Брэд Абрамс (Brad Abrams). Книга опубликована 22 октября 2008 г. издательством Addison-Wesley Professional в рамках серии, посвященной разработке для Microsoft Windows.*

## <a name="see-also"></a>См. также раздел

- [Рекомендации по проектированию платформы](index.md)
- [Правила разработки исключений](exceptions.md)
