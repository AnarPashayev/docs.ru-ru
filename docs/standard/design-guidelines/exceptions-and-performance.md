---
title: Исключения и производительность
ms.date: 10/22/2008
ms.technology: dotnet-standard
helpviewer_keywords:
- tester-doer pattern
- TryParse pattern
- exceptions, throwing
- exceptions, performance
- throwing exceptions, performance
ms.assetid: 3ad6aad9-08e6-4232-b336-0e301f2493e6
ms.openlocfilehash: afa4e748599781a5979823320d8913ff5357d415
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2020
ms.locfileid: "76741640"
---
# <a name="exceptions-and-performance"></a>Исключения и производительность
Одной из распространенных проблем, связанных с исключениями, является то, что если исключения используются для кода, который обычно завершается ошибкой, производительность реализации будет неприемлемой. Это является действительной проблемой. Когда член создает исключение, его производительность может быть меньше. Однако можно достичь хорошей производительности, при этом строго придерживаться правил исключения, которые не позволяют использовать коды ошибок. Два шаблона, описанные в этом разделе, предлагают способы этого.

 ❌ не используют коды ошибок из-за проблем, которые могут негативно сказаться на производительности.

 Чтобы повысить производительность, можно использовать шаблон Test-злодея или шаблон Try-Parse, описанный в следующих двух разделах.

## <a name="tester-doer-pattern"></a>Тест-инженер — шаблон злодея
 Иногда производительность члена, вызывающего исключение, может быть улучшена путем разбиения члена на два. Рассмотрим метод <xref:System.Collections.Generic.ICollection%601.Add%2A> интерфейса <xref:System.Collections.Generic.ICollection%601>.

```csharp
ICollection<int> numbers = ...
numbers.Add(1);
```

 Метод `Add` вызывает исключение, если коллекция доступна только для чтения. Это может быть проблемой с производительностью в сценариях, когда ожидается, что вызов метода будет выполняться часто. Один из способов устранения проблемы заключается в том, чтобы проверить, является ли коллекция доступной для записи, прежде чем пытаться добавить значение.

```csharp
ICollection<int> numbers = ...
...
if (!numbers.IsReadOnly)
{
    numbers.Add(1);
}
```

 Элемент, используемый для проверки условия, которое в нашем примере является свойством `IsReadOnly`, называется инженером-тестировщиком. Элемент, используемый для выполнения потенциального вызова операции, `Add` метод в нашем примере, называется злодея.

 ✔️ Рассмотрите шаблон Test-злодея для членов, которые могут создавать исключения в распространенных сценариях, чтобы избежать проблем с производительностью, связанных с исключениями.

## <a name="try-parse-pattern"></a>Шаблон Try-Parse
 Для очень чувствительных к производительности интерфейсов API следует использовать еще более быстрый шаблон, чем шаблон Test-злодея, описанный в предыдущем разделе. Шаблон вызывает метод для настройки имени элемента, чтобы сделать строго определенный тестовый случай частью семантики элемента. Например, <xref:System.DateTime> определяет метод <xref:System.DateTime.Parse%2A>, который создает исключение, если синтаксический анализ строки завершается ошибкой. Он также определяет соответствующий метод <xref:System.DateTime.TryParse%2A>, который пытается выполнить синтаксический анализ, но возвращает значение false, если синтаксический анализ завершается неудачно, и возвращает результат успешного синтаксического анализа с помощью параметра `out`.

```csharp
public struct DateTime
{
    public static DateTime Parse(string dateTime)
    {
        ...
    }
    public static bool TryParse(string dateTime, out DateTime result)
    {
        ...
    }
}
```

 При использовании этого шаблона важно определить функциональность Try в условиях ограниченного использования. Если элемент завершается ошибкой по какой-либо причине, отличной от правильно определенной, член должен по-прежнему вызывать соответствующее исключение.

 ✔️ РАССМОТРИМ шаблон Try-Parse для членов, которые могут вызывать исключения в распространенных сценариях, чтобы избежать проблем с производительностью, связанных с исключениями.

 ✔️ использовать префикс "try" и логический тип возвращаемого значения для методов, реализующих этот шаблон.

 ✔️ предоставить элемент, создающий исключения, для каждого члена с помощью шаблона try-Parse.

 *Части © 2005, 2009 Корпорация Майкрософт. Все права защищены.*

 *Перепечатано с разрешения Pearson Education, Inc. из книги [Инфраструктура программных проектов. Соглашения, идиомы и шаблоны для многократно используемых библиотек .NET (2-е издание)](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619), авторы: Кржиштоф Цвалина (Krzysztof Cwalina) и Брэд Абрамс (Brad Abrams). Книга опубликована 22 октября 2008 г. издательством Addison-Wesley Professional в рамках серии, посвященной разработке для Microsoft Windows.*

## <a name="see-also"></a>См. также:

- [Рекомендации по проектированию на основе Framework](../../../docs/standard/design-guidelines/index.md)
- [Правила разработки исключений](../../../docs/standard/design-guidelines/exceptions.md)
