---
title: Исключения и производительность
ms.date: 10/22/2008
ms.technology: dotnet-standard
helpviewer_keywords:
- tester-doer pattern
- TryParse pattern
- exceptions, throwing
- exceptions, performance
- throwing exceptions, performance
ms.assetid: 3ad6aad9-08e6-4232-b336-0e301f2493e6
ms.openlocfilehash: e3a7fa0f284ebf028a18cae37c050d7ceda9bb79
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2020
ms.locfileid: "75709391"
---
# <a name="exceptions-and-performance"></a>Исключения и производительность
Одной из распространенных проблем, связанных с исключениями, является то, что если исключения используются для кода, который обычно завершается ошибкой, производительность реализации будет неприемлемой. Это является действительной проблемой. Когда член создает исключение, его производительность может быть меньше. Однако можно достичь хорошей производительности, при этом строго придерживаться правил исключения, которые не позволяют использовать коды ошибок. Два шаблона, описанные в этом разделе, предлагают способы этого.

 **X DO NOT** использование кодов ошибок из-за проблемы, что исключения могут негативно повлиять на производительность.

 Чтобы повысить производительность, можно использовать шаблон Test-злодея или шаблон Try-Parse, описанный в следующих двух разделах.

## <a name="tester-doer-pattern"></a>Тест-инженер — шаблон злодея
 Иногда производительность члена, вызывающего исключение, может быть улучшена путем разбиения члена на два. Рассмотрим метод <xref:System.Collections.Generic.ICollection%601.Add%2A> интерфейса <xref:System.Collections.Generic.ICollection%601>.

```csharp
ICollection<int> numbers = ...
numbers.Add(1);
```

 Метод `Add` вызывает исключение, если коллекция доступна только для чтения. Это может быть проблемой с производительностью в сценариях, когда ожидается, что вызов метода будет выполняться часто. Один из способов устранения проблемы заключается в том, чтобы проверить, является ли коллекция доступной для записи, прежде чем пытаться добавить значение.

```csharp
ICollection<int> numbers = ...
...
if (!numbers.IsReadOnly)
{
    numbers.Add(1);
}
```

 Элемент, используемый для проверки условия, которое в нашем примере является свойством `IsReadOnly`, называется инженером-тестировщиком. Элемент, используемый для выполнения потенциального вызова операции, `Add` метод в нашем примере, называется злодея.

 **✓ CONSIDER** шаблон Tester-Doer для членов, которые могут вызвать исключения общие сценарии, чтобы избежать проблем с производительностью связанных с исключениями.

## <a name="try-parse-pattern"></a>Шаблон Try-Parse
 Для очень чувствительных к производительности интерфейсов API следует использовать еще более быстрый шаблон, чем шаблон Test-злодея, описанный в предыдущем разделе. Шаблон вызывает метод для настройки имени элемента, чтобы сделать строго определенный тестовый случай частью семантики элемента. Например, <xref:System.DateTime> определяет метод <xref:System.DateTime.Parse%2A>, который создает исключение, если синтаксический анализ строки завершается ошибкой. Он также определяет соответствующий метод <xref:System.DateTime.TryParse%2A>, который пытается выполнить синтаксический анализ, но возвращает значение false, если синтаксический анализ завершается неудачно, и возвращает результат успешного синтаксического анализа с помощью параметра `out`.

```csharp
public struct DateTime
{
    public static DateTime Parse(string dateTime)
    {
        ...
    }
    public static bool TryParse(string dateTime, out DateTime result)
    {
        ...
    }
}
```

 При использовании этого шаблона важно определить функциональность Try в условиях ограниченного использования. Если элемент завершается ошибкой по какой-либо причине, отличной от правильно определенной, член должен по-прежнему вызывать соответствующее исключение.

 **✓ CONSIDER** синтаксического анализа Try шаблон для членов, которые могут вызвать исключения общие сценарии, чтобы избежать проблем с производительностью связанных с исключениями.

 **✓ DO** использовать префикс «Try» и логический тип возвращаемого значения для методов реализации данного шаблона.

 **✓ DO** предоставляют член исключения для каждого элемента, используя шаблон синтаксического анализа Try.

 *Части © 2005, 2009 Корпорация Майкрософт. Все права защищены.*

 *Перепечатано с разрешения Pearson Education, Inc. из книги [Инфраструктура программных проектов. Соглашения, идиомы и шаблоны для многократно используемых библиотек .NET (2-е издание)](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619), авторы: Кржиштоф Цвалина (Krzysztof Cwalina) и Брэд Абрамс (Brad Abrams). Книга опубликована 22 октября 2008 г. издательством Addison-Wesley Professional в рамках серии, посвященной разработке для Microsoft Windows.*

## <a name="see-also"></a>См. также:

- [Рекомендации по проектированию на основе Framework](../../../docs/standard/design-guidelines/index.md)
- [Правила разработки исключений](../../../docs/standard/design-guidelines/exceptions.md)
