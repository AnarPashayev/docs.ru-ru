---
title: Запечатывание
ms.date: 10/22/2008
helpviewer_keywords:
- limiting extensibility
- classes [.NET Framework], sealing
- preventing customization
- sealed classes
ms.assetid: cc42267f-bb7a-427a-845e-df97408528d4
ms.openlocfilehash: bf8aad5d79e659ad9a767c2b0992eb9ee05fd531
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/24/2020
ms.locfileid: "95730946"
---
# <a name="sealing"></a>Запечатывание

Одной из функций объектно-ориентированных платформ является то, что разработчики могут расширять и настраивать их способами, не предусмотренными конструкторами инфраструктуры. Это как мощность, так и опасность расширяемого проектирования. При проектировании платформы, следовательно, очень важно тщательно спроектировать расширяемость при необходимости и ограничить расширяемость, когда она опасно.

 Мощный механизм, который предотвращает запечатывание расширяемости. Можно запечатывать либо класс, либо отдельные члены. Запечатывание класса не позволяет пользователям наследовать от класса. Запечатывание элемента не позволяет пользователям переопределять конкретный элемент.

 ❌ Не запечатывать классы без хорошей причины.

 Запечатывание класса, так как вы не можете подумать о сценарии расширяемости, не является хорошей причиной. Пользователи платформы могут наследовать от классов по различным неочевидным причинам, например к добавлению удобных членов. Примеры неочевидных причин, по которым пользователям необходимо наследовать от типа, см. в разделе [незапечатанные классы](unsealed-classes.md) .

 Ниже приведены веские причины для запечатывания класса.

- Класс является статическим классом. См. раздел [Разработка статических классов](static-class.md).

- Класс хранит секреты с учетом уровня безопасности в наследуемых защищенных членах.

- Класс наследует многие виртуальные члены, и стоимость их запечатывания по отдельности может перевесить преимущества незапечатанного класса.

- Класс является атрибутом, который требует очень быстрого поиска в среде выполнения. Запечатанные атрибуты имеют несколько более высокие уровни производительности, чем незапечатанные. См. раздел [атрибуты](attributes.md).

 ❌ НЕ объявляйте защищенные или виртуальные члены в запечатанных типах.

 По определению Запечатанные типы не могут наследоваться от. Это означает, что нельзя вызывать защищенные члены в запечатанных типах, а виртуальные методы в запечатанных типах не могут быть переопределены.

 ✔️ Рассмотрите возможность запечатывания переопределяемых элементов.

 Проблемы, которые могут возникнуть в результате введения виртуальных членов (обсуждаются в [виртуальных членах](virtual-members.md)), применяются и к переопределениям, хотя и немного меньше. Запечатывание экранирования от этих проблем, начиная с этой точки в иерархии наследования.

 *Части © 2005, 2009 Корпорация Майкрософт. Все права защищены.*

 *Перепечатано с разрешения Pearson Education, Inc. из книги [Инфраструктура программных проектов. Соглашения, идиомы и шаблоны для многократно используемых библиотек .NET (2-е издание)](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619), авторы: Кржиштоф Цвалина (Krzysztof Cwalina) и Брэд Абрамс (Brad Abrams). Книга опубликована 22 октября 2008 г. издательством Addison-Wesley Professional в рамках серии, посвященной разработке для Microsoft Windows.*

## <a name="see-also"></a>См. также раздел

- [Рекомендации по проектированию платформы](index.md)
- [Разработка с обеспечением расширяемости](designing-for-extensibility.md)
- [Незапечатанные классы](unsealed-classes.md)
