---
title: Разработка событий
ms.date: 10/22/2008
ms.technology: dotnet-standard
helpviewer_keywords:
- pre-events
- events [.NET Framework], design guidelines
- member design guidelines, events
- event handlers [.NET Framework], event design guidelines
- post-events
- signatures, event handling
ms.assetid: 67b3c6e2-6a8f-480d-a78f-ebeeaca1b95a
ms.openlocfilehash: b44ee5933f8629b4dddbf3be1b79b2e77b0254f7
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2020
ms.locfileid: "76741685"
---
# <a name="event-design"></a>Разработка событий
События — это наиболее часто используемая форма обратных вызовов (конструкций, позволяющая платформе вызывать пользовательский код). Другие механизмы обратного вызова включают члены, принимающие делегаты, виртуальные члены и подключаемые модули на основе интерфейсов. данные из исследований удобства использования указывают на то, что большинство разработчиков более удобно использовать события, чем они используют другие механизмы обратного вызова. . События хорошо интегрируются с Visual Studio и многими языками.

 Важно отметить, что существует две группы событий: события, вызванные до изменения состояния системы, называемые событиями pre-Events, и события, возникающие после изменения состояния, называемые событиями после. Примером предварительного события может быть `Form.Closing`, который вызывается перед закрытием формы. Примером события, поступающего после закрытия формы, может быть `Form.Closed`.

 ✔️ использовать термин «raise» для событий, а не «пожар» или «Trigger».

 ✔️ использовать <xref:System.EventHandler%601?displayProperty=nameWithType> вместо того, чтобы вручную создавать новые делегаты для использования в качестве обработчиков событий.

 ✔️ Рассмотрите возможность использования подкласса <xref:System.EventArgs> в качестве аргумента события, если только вы не уверены, что событие никогда не будет передавать какие-либо данные в метод обработки событий. в этом случае можно использовать тип `EventArgs` напрямую.

 Если вы подаете API с помощью `EventArgs` напрямую, вы никогда не сможете добавлять данные, которые будут перенесены с событием без нарушения совместимости. Если вы используете подкласс, даже если изначально он полностью пуст, вы сможете добавлять свойства в подкласс при необходимости.

 для вызова каждого события ✔️ использовать защищенный виртуальный метод. Это применимо только к нестатическим событиям в незапечатанных классах, а не к структурам, запечатанным классам или статическим событиям.

 Цель метода — предоставить способ для производного класса, обрабатывающий событие с помощью переопределения. Переопределение является более гибким, быстрым и естественным способом управления событиями базового класса в производных классах. По соглашению имя метода должно начинаться с "on" и состоять из имени события.

 Производный класс может не вызывать базовую реализацию метода в его переопределении. Будьте готовы к этому, не включая обработку в методе, который требуется для правильной работы базового класса.

 ✔️ принимать один параметр для защищенного метода, который вызывает событие.

 Параметр должен иметь имя `e` и быть типизированным в качестве класса аргумента события.

 ❌ не передавать NULL в качестве отправителя при вызове нестатического события.

 ✔️ передать NULL в качестве отправителя при вызове статического события.

 При вызове события ❌ не передавать значение NULL в качестве параметра данных события.

 Следует передавать `EventArgs.Empty`, если вы не хотите передавать какие бы то ни было данные в метод обработки событий. Разработчики предполагают, что этот параметр не должен иметь значение null.

 ✔️ Рассмотрите возможность вызова событий, которые может отменить конечный пользователь. Это относится только к предварительным событиям.

 Используйте <xref:System.ComponentModel.CancelEventArgs?displayProperty=nameWithType> или его подкласс в качестве аргумента события, чтобы разрешить конечному пользователю отменять события.

### <a name="custom-event-handler-design"></a>Разработка пользовательского обработчика событий
 Существуют случаи, в которых `EventHandler<T>` нельзя использовать, например, если платформа должна работать с более ранними версиями среды CLR, которые не поддерживали универсальные шаблоны. В таких случаях может потребоваться разработать и разработать пользовательский делегат обработчика событий.

 ✔️ использовать тип возвращаемого значения void для обработчиков событий.

 Обработчик событий может вызывать несколько методов обработки событий, возможно, для нескольких объектов. Если методы обработки событий позволяли возвращать значение, то для каждого вызова события было бы несколько возвращаемых значений.

 ✔️ использовать `object` как тип первого параметра обработчика событий и вызвать его `sender`.

 ✔️ использовать <xref:System.EventArgs?displayProperty=nameWithType> или его подкласс в качестве типа второго параметра обработчика событий и вызвать его `e`.

 ❌ не имеют более двух параметров в обработчиках событий.

 *Части © 2005, 2009 Корпорация Майкрософт. Все права защищены.*

 *Перепечатано с разрешения Pearson Education, Inc. из книги [Инфраструктура программных проектов. Соглашения, идиомы и шаблоны для многократно используемых библиотек .NET (2-е издание)](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619), авторы: Кржиштоф Цвалина (Krzysztof Cwalina) и Брэд Абрамс (Brad Abrams). Книга опубликована 22 октября 2008 г. издательством Addison-Wesley Professional в рамках серии, посвященной разработке для Microsoft Windows.*

## <a name="see-also"></a>См. также раздел

- [Правила разработки членов](../../../docs/standard/design-guidelines/member.md)
- [Рекомендации по проектированию на основе Framework](../../../docs/standard/design-guidelines/index.md)
