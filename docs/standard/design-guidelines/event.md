---
title: Разработка событий
ms.date: 10/22/2008
ms.technology: dotnet-standard
helpviewer_keywords:
- pre-events
- events [.NET Framework], design guidelines
- member design guidelines, events
- event handlers [.NET Framework], event design guidelines
- post-events
- signatures, event handling
ms.assetid: 67b3c6e2-6a8f-480d-a78f-ebeeaca1b95a
ms.openlocfilehash: 78d765a7af77b1e6a6ecd483677cea2d4c6b0d5b
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2020
ms.locfileid: "75709430"
---
# <a name="event-design"></a>Разработка событий
События — это наиболее часто используемая форма обратных вызовов (конструкций, позволяющая платформе вызывать пользовательский код). Другие механизмы обратного вызова включают члены, принимающие делегаты, виртуальные члены и подключаемые модули на основе интерфейсов. данные из исследований удобства использования указывают на то, что большинство разработчиков более удобно использовать события, чем они используют другие механизмы обратного вызова. . События хорошо интегрируются с Visual Studio и многими языками.  
  
 Важно отметить, что существует две группы событий: события, вызванные до изменения состояния системы, называемые событиями pre-Events, и события, возникающие после изменения состояния, называемые событиями после. Примером предварительного события может быть `Form.Closing`, который вызывается перед закрытием формы. Примером события, поступающего после закрытия формы, может быть `Form.Closed`.  
  
 **✓ DO** использовать термин «raise» для событий, а не «fire» или «триггер».  
  
 **✓ DO** используйте <xref:System.EventHandler%601?displayProperty=nameWithType> вместо того чтобы вручную создавать новые делегаты для использования в качестве обработчиков событий.  
  
 **✓ CONSIDER** с помощью подкласс <xref:System.EventArgs> в качестве аргумента события, пока не будет точно знать, что событие никогда не понадобится передавать данные метода обработки событий в этом случае можно использовать `EventArgs` ввести напрямую.  
  
 Если вы подаете API с помощью `EventArgs` напрямую, вы никогда не сможете добавлять данные, которые будут перенесены с событием без нарушения совместимости. Если вы используете подкласс, даже если изначально он полностью пуст, вы сможете добавлять свойства в подкласс при необходимости.  
  
 **✓ DO** использовать защищенный виртуальный метод для каждого события. Это применимо только к нестатическим событиям в незапечатанных классах, а не к структурам, запечатанным классам или статическим событиям.  
  
 Цель метода — предоставить способ для производного класса, обрабатывающий событие с помощью переопределения. Переопределение является более гибким, быстрым и естественным способом управления событиями базового класса в производных классах. По соглашению имя метода должно начинаться с "on" и состоять из имени события.  
  
 Производный класс может не вызывать базовую реализацию метода в его переопределении. Будьте готовы к этому, не включая обработку в методе, который требуется для правильной работы базового класса.  
  
 **✓ DO** принимать один параметр для защищенный метод, который вызывает событие.  
  
 Параметр должен иметь имя `e` и быть типизированным в качестве класса аргумента события.  
  
 **X DO NOT** передает null в качестве отправителя при нестатические события.  
  
 **✓ DO** передает null в качестве отправителя при статические события.  
  
 **X DO NOT** передает null в качестве параметра данных события при возникновении события.  
  
 Следует передавать `EventArgs.Empty`, если вы не хотите передавать какие бы то ни было данные в метод обработки событий. Разработчики предполагают, что этот параметр не должен иметь значение null.  
  
 **✓ CONSIDER** вызов событий, которые можно отменить конечного пользователя. Это относится только к предварительным событиям.  
  
 Используйте <xref:System.ComponentModel.CancelEventArgs?displayProperty=nameWithType> или его подкласс в качестве аргумента события, чтобы разрешить конечному пользователю отменять события.  
  
### <a name="custom-event-handler-design"></a>Разработка пользовательского обработчика событий  
 Существуют случаи, в которых `EventHandler<T>` нельзя использовать, например, если платформа должна работать с более ранними версиями среды CLR, которые не поддерживали универсальные шаблоны. В таких случаях может потребоваться разработать и разработать пользовательский делегат обработчика событий.  
  
 **✓ DO** использовать тип возвращаемого значения void для обработчиков событий.  
  
 Обработчик событий может вызывать несколько методов обработки событий, возможно, для нескольких объектов. Если методы обработки событий позволяли возвращать значение, то для каждого вызова события было бы несколько возвращаемых значений.  
  
 **✓ DO** использовать `object` как тип первого аргумента обработчика событий и вызывает его `sender`.  
  
 **✓ DO** использовать <xref:System.EventArgs?displayProperty=nameWithType> или его подкласс в качестве типа второго аргумента обработчика событий и вызывает его `e`.  
  
 **X DO NOT** иметь более двух параметров на обработчики событий.  
  
 *Части © 2005, 2009 Корпорация Майкрософт. Все права защищены.*  
  
 *Перепечатано с разрешения Pearson Education, Inc. из книги [Инфраструктура программных проектов. Соглашения, идиомы и шаблоны для многократно используемых библиотек .NET (2-е издание)](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619), авторы: Кржиштоф Цвалина (Krzysztof Cwalina) и Брэд Абрамс (Brad Abrams). Книга опубликована 22 октября 2008 г. издательством Addison-Wesley Professional в рамках серии, посвященной разработке для Microsoft Windows.*  
  
## <a name="see-also"></a>См. также:

- [Правила разработки членов](../../../docs/standard/design-guidelines/member.md)
- [Рекомендации по проектированию на основе Framework](../../../docs/standard/design-guidelines/index.md)
