---
title: Разработка событий
ms.date: 10/22/2008
ms.technology: dotnet-standard
helpviewer_keywords:
- pre-events
- events [.NET Framework], design guidelines
- member design guidelines, events
- event handlers [.NET Framework], event design guidelines
- post-events
- signatures, event handling
ms.assetid: 67b3c6e2-6a8f-480d-a78f-ebeeaca1b95a
author: KrzysztofCwalina
ms.openlocfilehash: 530c68ea5342263acd07f8dc8a8c8ce889652503
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62026449"
---
# <a name="event-design"></a>Разработка событий
События являются наиболее часто используемые формой обратные вызовы (конструкции, которые позволяют framework для вызова пользовательского кода). Другие механизмы обратного вызова участием делегатов, виртуальные члены и основанная на интерфейсах подключаемых модулей. Данные из исследований об удобстве использования, указывают, что большинство разработчиков удобнее работать с помощью событий, чем они при использовании других методов обратного вызова. События хорошо интегрированы с Visual Studio и многих языков.  
  
 Важно отметить, что две группы событий: события, возникающие до состояния изменения в системе, вызывается предварительного события и события, возникающие после изменения состояния, вызывается после события. Примером предварительного события может служить `Form.Closing`, который вызывается перед закрытием формы. Примером после события может служить `Form.Closed`, который вызывается после закрытия формы.  
  
 **✓ DO** использовать термин «raise» для событий, а не «fire» или «триггер».  
  
 **✓ DO** используйте <xref:System.EventHandler%601?displayProperty=nameWithType> вместо того чтобы вручную создавать новые делегаты для использования в качестве обработчиков событий.  
  
 **✓ CONSIDER** с помощью подкласс <xref:System.EventArgs> в качестве аргумента события, пока не будет точно знать, что событие никогда не понадобится передавать данные метода обработки событий в этом случае можно использовать `EventArgs` ввести напрямую.  
  
 При доставке API с помощью `EventArgs` напрямую, вы никогда не сможете добавить данные, разделяя без риска нарушить совместимость с событием. Если вы используете подкласс, даже если изначально полностью пустым, можно для добавления свойств в подкласс, при необходимости.  
  
 **✓ DO** использовать защищенный виртуальный метод для каждого события. Это значение применимо только на нестатические события незапечатанных классов, не для структур, запечатанные классы или статические события.  
  
 Метод предназначена для предоставления способа для производного класса для обработки события с помощью переопределения. Переопределение является более гибким, быстрее и более естественный способ обработки событий базового класса в производных классах. По соглашению имя метода должно начинаться с «On» и следовать имя события.  
  
 Производный класс можно не вызывать базовую реализацию метода в его переопределения. Быть готовы к этому, не включив обработку в метод, который необходим для базового класса для правильной работы.  
  
 **✓ DO** принимать один параметр для защищенный метод, который вызывает событие.  
  
 Параметр должен иметь имя `e` и должны быть типизированы как класс аргументов события.  
  
 **X DO NOT** передает null в качестве отправителя при нестатические события.  
  
 **✓ DO** передает null в качестве отправителя при статические события.  
  
 **X DO NOT** передает null в качестве параметра данных события при возникновении события.  
  
 Необходимо передать `EventArgs.Empty` Если вы не хотите передавать все данные в метод обработки события. Разработчики предполагают, что этот параметр не должен иметь значение null.  
  
 **✓ CONSIDER** вызов событий, которые можно отменить конечного пользователя. Это относится только к предварительного события.  
  
 Используйте <xref:System.ComponentModel.CancelEventArgs?displayProperty=nameWithType> или его подкласс как аргумент и позволяющие конечным пользователям для отмены события.  
  
### <a name="custom-event-handler-design"></a>Разработка настраиваемого обработчика событий  
 Бывают случаи, в котором `EventHandler<T>` не может использоваться, например когда платформа должна работать в более ранних версиях среды CLR, который не поддерживает универсальные шаблоны. В таких случаях может потребоваться для проектирования и разработки делегат обработчика пользовательского события.  
  
 **✓ DO** использовать тип возвращаемого значения void для обработчиков событий.  
  
 Обработчик событий может вызывать несколько событий, обработка методов, возможно, на несколько объектов. Если методы обработки событий было разрешено для возврата значения, то должно быть несколько возвращаемые значения для каждого вызова событий.  
  
 **✓ DO** использовать `object` как тип первого аргумента обработчика событий и вызывает его `sender`.  
  
 **✓ DO** использовать <xref:System.EventArgs?displayProperty=nameWithType> или его подкласс в качестве типа второго аргумента обработчика событий и вызывает его `e`.  
  
 **X DO NOT** иметь более двух параметров на обработчики событий.  
  
 *Фрагменты: © Корпорация Майкрософт (Microsoft Corporation), 2005, 2009. Все права защищены.*  
  
 *Перепечатано разрешением Пирсона для образовательных учреждений, Inc. из [рекомендации по разработке Framework: Условные обозначения, стили и шаблоны для библиотеки .NET для повторного использования, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) Кшиштов Квалина и Брэд Абрамс, опубликованных 22 октября 2008 г., издательство Addison-Wesley Professional как части цикла разработки Microsoft Windows.*  
  
## <a name="see-also"></a>См. также

- [Правила разработки членов](../../../docs/standard/design-guidelines/member.md)
- [Рекомендации по проектированию на основе Framework](../../../docs/standard/design-guidelines/index.md)
