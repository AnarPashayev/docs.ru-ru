---
title: Разработка событий
ms.date: 10/22/2008
ms.technology: dotnet-standard
helpviewer_keywords:
- pre-events
- events [.NET Framework], design guidelines
- member design guidelines, events
- event handlers [.NET Framework], event design guidelines
- post-events
- signatures, event handling
ms.assetid: 67b3c6e2-6a8f-480d-a78f-ebeeaca1b95a
ms.openlocfilehash: 852c99b1a41691911f7ae82d3b8104526811757d
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/02/2020
ms.locfileid: "84289828"
---
# <a name="event-design"></a>Разработка событий
События — это наиболее часто используемая форма обратных вызовов (конструкций, позволяющая платформе вызывать пользовательский код). К другим механизмам обратного вызова относятся участники, принимающие делегаты, виртуальные элементы и подключаемые модули на основе интерфейсов. данные из исследований удобства использования указывают на то, что большинство разработчиков более удобно использовать при использовании событий, чем другие механизмы обратного вызова. События хорошо интегрируются с Visual Studio и многими языками.

 Важно отметить, что существует две группы событий: события, вызванные до изменения состояния системы, называемые событиями pre-Events, и события, возникающие после изменения состояния, называемые событиями после. Примером предварительного события может быть `Form.Closing` , что происходит перед закрытием формы. Примером поступающего события может быть `Form.Closed` , что возникает после закрытия формы.

 ✔️ использовать термин «raise» для событий, а не «пожар» или «Trigger».

 ✔️ использовать <xref:System.EventHandler%601?displayProperty=nameWithType> вместо ручного создания новых делегатов для использования в качестве обработчиков событий.

 ✔️ Рассмотрите возможность использования подкласса в <xref:System.EventArgs> качестве аргумента события, если только вы не уверены, что событие никогда не будет передавать какие-либо данные в метод обработки событий. в этом случае можно использовать `EventArgs` тип напрямую.

 Если вы подаете API `EventArgs` напрямую, вы никогда не сможете добавлять данные, которые будут перенесены с событием без нарушения совместимости. Если вы используете подкласс, даже если изначально он полностью пуст, вы сможете добавлять свойства в подкласс при необходимости.

 для вызова каждого события ✔️ использовать защищенный виртуальный метод. Это применимо только к нестатическим событиям в незапечатанных классах, а не к структурам, запечатанным классам или статическим событиям.

 Цель метода — предоставить способ для производного класса, обрабатывающий событие с помощью переопределения. Переопределение является более гибким, быстрым и естественным способом управления событиями базового класса в производных классах. По соглашению имя метода должно начинаться с "on" и состоять из имени события.

 Производный класс может не вызывать базовую реализацию метода в его переопределении. Будьте готовы к этому, не включая обработку в методе, который требуется для правильной работы базового класса.

 ✔️ принимать один параметр для защищенного метода, который вызывает событие.

 Параметр должен иметь имя `e` и быть типизированным в качестве класса аргумента события.

 ❌НЕ передавайте значение NULL в качестве отправителя при вызове нестатического события.

 ✔️ передать NULL в качестве отправителя при вызове статического события.

 ❌НЕ передавайте значение NULL в качестве параметра данных события при вызове события.

 `EventArgs.Empty`Если вы не хотите передавать какие бы то ни было данные в метод обработки событий, необходимо передать значение. Разработчики предполагают, что этот параметр не должен иметь значение null.

 ✔️ Рассмотрите возможность вызова событий, которые может отменить конечный пользователь. Это относится только к предварительным событиям.

 Используйте <xref:System.ComponentModel.CancelEventArgs?displayProperty=nameWithType> или его подкласс в качестве аргумента события, чтобы разрешить конечному пользователю отменять события.

### <a name="custom-event-handler-design"></a>Разработка пользовательского обработчика событий
 Существуют случаи, в которых `EventHandler<T>` нельзя использовать, например, если платформе требуется работать с более ранними версиями среды CLR, которые не поддерживали универсальные шаблоны. В таких случаях может потребоваться разработать и разработать пользовательский делегат обработчика событий.

 ✔️ использовать тип возвращаемого значения void для обработчиков событий.

 Обработчик событий может вызывать несколько методов обработки событий, возможно, для нескольких объектов. Если методы обработки событий позволяли возвращать значение, то для каждого вызова события было бы несколько возвращаемых значений.

 ✔️ использовать в `object` качестве типа первого параметра обработчика событий и вызывать его `sender` .

 ✔️ использовать <xref:System.EventArgs?displayProperty=nameWithType> или его подкласс в качестве типа второго параметра обработчика событий и вызвать его `e` .

 ❌В обработчиках событий не более двух параметров.

 *Части © 2005, 2009 Корпорация Майкрософт. Все права защищены.*

 *Перепечатано с разрешения Pearson Education, Inc. из книги [Инфраструктура программных проектов. Соглашения, идиомы и шаблоны для многократно используемых библиотек .NET (2-е издание)](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619), авторы: Кржиштоф Цвалина (Krzysztof Cwalina) и Брэд Абрамс (Brad Abrams). Книга опубликована 22 октября 2008 г. издательством Addison-Wesley Professional в рамках серии, посвященной разработке для Microsoft Windows.*

## <a name="see-also"></a>См. также

- [Рекомендации по проектированию членов](member.md)
- [Рекомендации по проектированию платформы](index.md)
