---
title: Рекомендации по использованию коллекций
ms.date: 10/22/2008
ms.technology: dotnet-standard
ms.assetid: 297b8f1d-b11f-4dc6-960a-8e990817304e
ms.openlocfilehash: 50497de6569b448ab036af8a1fbf76a47565e2bb
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2020
ms.locfileid: "76741862"
---
# <a name="guidelines-for-collections"></a>Рекомендации по использованию коллекций
Любой тип, предназначенный специально для управления группой объектов с некоторыми общими характеристиками, может рассматриваться как коллекция. Он почти всегда подходит для таких типов, чтобы реализовать <xref:System.Collections.IEnumerable> или <xref:System.Collections.Generic.IEnumerable%601>, поэтому в этом разделе мы расскажем только о типах, реализующих один или оба этих интерфейса, которые должны быть коллекциями.

 ❌ не используйте неслабо типизированные коллекции в общедоступных API.

 Тип всех возвращаемых значений и параметров, представляющих элементы коллекции, должен быть точным типом элемента, а не любым из его базовых типов (это относится только к открытым элементам коллекции).

 ❌ не используйте <xref:System.Collections.ArrayList> или <xref:System.Collections.Generic.List%601> в общедоступных интерфейсах API.

 Эти типы представляют собой структуры данных, предназначенные для использования во внутренней реализации, а не в общедоступных API. `List<T>` оптимизирована для повышения производительности и энергопотребления за счет очистки интерфейсов API и гибкости. Например, если вы возвращаете `List<T>`, вы никогда не сможете получать уведомления, когда клиентский код изменяет коллекцию. Кроме того, `List<T>` предоставляет множество членов, таких как <xref:System.Collections.Generic.List%601.BinarySearch%2A>, которые не являются полезными или применимы во многих сценариях. В следующих двух разделах описываются типы (абстракции), специально предназначенные для использования в общедоступных API.

 ❌ не используйте `Hashtable` или `Dictionary<TKey,TValue>` в общедоступных интерфейсах API.

 Эти типы представляют собой структуры данных, предназначенные для использования во внутренней реализации. Общедоступные API-интерфейсы должны использовать <xref:System.Collections.IDictionary>, `IDictionary <TKey, TValue>`или пользовательский тип, реализующий один или оба интерфейса.

 ❌ не используют <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Collections.IEnumerator>или любой другой тип, реализующий любой из этих интерфейсов, за исключением типа возвращаемого значения метода `GetEnumerator`.

 Типы, возвращающие перечислители из методов, отличных от `GetEnumerator`, нельзя использовать с инструкцией `foreach`.

 ❌ не реализуйте `IEnumerator<T>` и `IEnumerable<T>` для одного и того же типа. То же относится и к неуниверсальным интерфейсам `IEnumerator` и `IEnumerable`.

## <a name="collection-parameters"></a>Параметры коллекции
 ✔️ использовать в качестве типа параметра минимально специализированный тип. Большинство членов, принимающих коллекции в качестве параметров, используют интерфейс `IEnumerable<T>`.

 ❌ избегать использования <xref:System.Collections.Generic.ICollection%601> или <xref:System.Collections.ICollection> в качестве параметра только для доступа к свойству `Count`.

 Вместо этого рекомендуется использовать `IEnumerable<T>` или `IEnumerable` и динамически проверять, реализует ли объект `ICollection<T>` или `ICollection`.

## <a name="collection-properties-and-return-values"></a>Свойства коллекции и возвращаемые значения
 ❌ не предоставляют настраиваемые свойства коллекции.

 Пользователи могут заменить содержимое коллекции, сначала очистив коллекцию, а затем добавив новое содержимое. Если замена всей коллекции является распространенным сценарием, попробуйте предоставить метод `AddRange` в коллекции.

 ✔️ использовать `Collection<T>` или подкласс `Collection<T>` для свойств или возвращаемых значений, представляющих коллекции для чтения и записи.

 Если `Collection<T>` не соответствует какому-либо требованию (например, коллекция не должна реализовывать <xref:System.Collections.IList>), используйте пользовательскую коллекцию, реализуя `IEnumerable<T>`, `ICollection<T>`или <xref:System.Collections.Generic.IList%601>.

 ✔️ использовать <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>, подкласс `ReadOnlyCollection<T>`или в редких случаях `IEnumerable<T>` для свойств или возвращаемых значений, представляющих коллекции только для чтения.

 В общем случае предпочтительнее `ReadOnlyCollection<T>`. Если он не соответствует какому-либо требованию (например, коллекция не должна реализовывать `IList`), используйте пользовательскую коллекцию, реализуя `IEnumerable<T>`, `ICollection<T>`или `IList<T>`. Если вы реализуете пользовательскую коллекцию, доступную только для чтения, реализуйте `ICollection<T>.IsReadOnly`, чтобы вернуть `true`.

 Если вы уверены, что единственной ситуацией, которую вы хотите поддерживать, является однопроходная итерация, можно просто использовать `IEnumerable<T>`.

 ✔️ РЕКОМЕНДУЕТСЯ использовать подклассы универсальных базовых коллекций вместо непосредственного использования коллекций.

 Это позволяет улучшить имя и добавить вспомогательные элементы, отсутствующие в базовых типах коллекций. Это особенно применимо к интерфейсам API высокого уровня.

 ✔️ РЕКОМЕНДУЕТСЯ возвращать подкласс `Collection<T>` или `ReadOnlyCollection<T>` из очень часто используемых методов и свойств.

 Это сделает возможным добавление вспомогательных методов или изменение реализации коллекции в будущем.

 ✔️ РЕКОМЕНДУЕТСЯ использовать коллекцию с ключом, если элементы, хранящиеся в коллекции, имеют уникальные ключи (имена, идентификаторы и т. д.). Коллекции с ключом — это коллекции, которые могут индексироваться как целое число и как ключ, и обычно реализуются путем наследования от `KeyedCollection<TKey,TItem>`.

 Коллекции с ключом обычно имеют больший объем памяти, и их не следует использовать, если издержки памяти привышают преимущества использования ключей.

 ❌ не возвращают значения NULL из свойств коллекции или из методов, возвращающих коллекции. Вместо этого следует возвращать пустую коллекцию или пустой массив.

 Общее правило состоит в том, что коллекции или массивы null и пустые (0 элементов) должны обрабатываться одинаково.

### <a name="snapshots-versus-live-collections"></a>Моментальные снимки и динамические коллекции
 Коллекции, представляющие состояние в определенный момент времени, называются коллекциями моментальных снимков. Например, коллекция, содержащая строки, возвращаемые запросом к базе данных, будет моментальным снимком. Коллекции, которые всегда представляют текущее состояние, называются активными коллекциями. Например, коллекция элементов `ComboBox` является динамической коллекцией.

 ❌ не возвращают коллекции моментальных снимков из свойств. Свойства должны возвращать динамические коллекции.

 Методы получения свойств должны быть очень простыми операциями. Для возврата моментального снимка необходимо создать копию внутренней коллекции в операции O (n).

 ✔️ использовать либо коллекцию моментальных снимков, либо динамический `IEnumerable<T>` (или его подтип) для представления коллекций, которые являются временными (т. е. могут изменяться без явного изменения коллекции).

 Как правило, все коллекции, представляющие общий ресурс (например, файлы в каталоге), являются временными. Такие коллекции очень трудны или невозможно реализовать как динамические коллекции, если только реализация не является просто перечислителем.

## <a name="choosing-between-arrays-and-collections"></a>Выбор между массивами и коллекциями
 ✔️ предпочтительно использовать коллекции для массивов.

 Коллекции обеспечивают больший контроль над содержимым, могут развиваться со временем и более пригодны для использования. Кроме того, использование массивов для сценариев только для чтения не рекомендуется, поскольку затраты на клонирование массива являются недопустимыми. В исследованиях удобства использования было показано, что некоторым разработчикам удобнее пользоваться API-интерфейсами на основе коллекций.

 Однако при разработке низкоуровневых интерфейсов API может быть лучше использовать массивы для сценариев чтения и записи. Массивы имеют меньший объем памяти, что позволяет сократить рабочий набор, а доступ к элементам массива выполняется быстрее, поскольку он оптимизирован средой выполнения.

 ✔️ Рассмотрите возможность использования массивов в низкоуровневых API, чтобы максимально увеличить потребление памяти и повысить производительность.

 ✔️ использовать массивы байтов вместо коллекций байтов.

 ❌ не используйте массивы для свойств, если свойство должно возвращать новый массив (например, копию внутреннего массива) каждый раз при вызове метода получения свойства.

## <a name="implementing-custom-collections"></a>Реализация пользовательских коллекций
 ✔️ Рассмотрите наследование от `Collection<T>`, `ReadOnlyCollection<T>`или `KeyedCollection<TKey,TItem>` при проектировании новых коллекций.

 ✔️ реализовать `IEnumerable<T>` при проектировании новых коллекций. Рассмотрите возможность реализации `ICollection<T>` или даже `IList<T>` там, где это имеет смысл.

 При реализации такой пользовательской коллекции следует использовать шаблон API, установленный `Collection<T>` и `ReadOnlyCollection<T>` как можно точнее. То есть явно реализуйте одни и те же члены, назовите такие параметры, как имена этих двух коллекций, и т. д.

 ✔️ Рассмотрите возможность реализации неуниверсальных интерфейсов коллекций (`IList` и `ICollection`), если коллекция часто передается интерфейсам API, принимающим эти интерфейсы в качестве входных данных.

 ❌ избегать реализации интерфейсов коллекций для типов со сложными API, не связанными с понятием коллекции.

 ❌ не наследовать от неуниверсальных базовых коллекций, таких как `CollectionBase`. Вместо этого используйте `Collection<T>`, `ReadOnlyCollection<T>`и `KeyedCollection<TKey,TItem>`.

### <a name="naming-custom-collections"></a>Именование пользовательских коллекций
 Коллекции (типы, реализующие `IEnumerable`) создаются главным образом по двум причинам: (1) для создания новой структуры данных с операциями, зависящими от структуры, и часто отличающимися характеристиками производительности, чем существующие структуры данных (например, <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.LinkedList%601>, <xref:System.Collections.Generic.Stack%601>) и (2) для создания специализированной коллекции для хранения определенного набора элементов (например, <xref:System.Collections.Specialized.StringCollection>). Структуры данных чаще всего используются во внутренней реализации приложений и библиотек. Специализированные коллекции, главным образом, должны предоставляться в API-интерфейсах (как типы свойств и параметров).

 ✔️ использовать суффикс "Dictionary" в именах абстракций, реализующих `IDictionary` или `IDictionary<TKey,TValue>`.

 ✔️ использовать суффикс "Collection" в именах типов, реализующих `IEnumerable` (или любого из его потомков) и представляющих список элементов.

 ✔️ использовать соответствующее имя структуры данных для пользовательских структур данных.

 ❌ избегать использования суффиксов, которые подразумевают определенную реализацию, например "LinkedList" или "Hashtable", в именах абстракций коллекций.

 ✔️ Рассмотрите возможность добавления имен коллекций с именем типа элемента. Например, коллекция, в которой хранятся элементы типа `Address` (реализация `IEnumerable<Address>`), должна иметь имя `AddressCollection`. Если тип элемента является интерфейсом, то префикс "I" типа элемента можно опустить. Таким же набор элементов <xref:System.IDisposable> можно вызывать `DisposableCollection`.

 ✔️ РЕКОМЕНДУЕТСЯ использовать префикс "ReadOnly" в именах коллекций только для чтения, если соответствующая записываемая коллекция может быть добавлена или уже существует в платформе.

 Например, доступная только для чтения коллекция строк должна вызываться `ReadOnlyStringCollection`.

 *Части © 2005, 2009 Корпорация Майкрософт. Все права защищены.*

 *Перепечатано с разрешения Pearson Education, Inc. из книги [Инфраструктура программных проектов. Соглашения, идиомы и шаблоны для многократно используемых библиотек .NET (2-е издание)](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619), авторы: Кржиштоф Цвалина (Krzysztof Cwalina) и Брэд Абрамс (Brad Abrams). Книга опубликована 22 октября 2008 г. издательством Addison-Wesley Professional в рамках серии, посвященной разработке для Microsoft Windows.*

## <a name="see-also"></a>См. также:

- [Рекомендации по проектированию на основе Framework](../../../docs/standard/design-guidelines/index.md)
- [Правила использования](../../../docs/standard/design-guidelines/usage-guidelines.md)
