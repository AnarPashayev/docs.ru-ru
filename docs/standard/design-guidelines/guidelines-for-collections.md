---
title: Рекомендации по использованию коллекций
ms.date: 10/22/2008
ms.assetid: 297b8f1d-b11f-4dc6-960a-8e990817304e
ms.openlocfilehash: a143e88be01bf2c8f45e25f26498d2d3ccbd98da
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/24/2020
ms.locfileid: "95706675"
---
# <a name="guidelines-for-collections"></a>Рекомендации по использованию коллекций

Любой тип, предназначенный специально для управления группой объектов с некоторыми общими характеристиками, может рассматриваться как коллекция. Почти всегда подходит для таких типов, чтобы реализовать <xref:System.Collections.IEnumerable> или <xref:System.Collections.Generic.IEnumerable%601> , поэтому в этом разделе мы будем рассматривать только типы, реализующие один или оба этих интерфейса для коллекций.

 ❌ НЕ используйте неслабо типизированные коллекции в общедоступных API.

 Тип всех возвращаемых значений и параметров, представляющих элементы коллекции, должен быть точным типом элемента, а не любым из его базовых типов (это относится только к открытым элементам коллекции).

 ❌ НЕ используйте <xref:System.Collections.ArrayList> или <xref:System.Collections.Generic.List%601> в общедоступных API.

 Эти типы представляют собой структуры данных, предназначенные для использования во внутренней реализации, а не в общедоступных API. `List<T>` оптимизирована для повышения производительности и энергопотребления за счет очистки интерфейсов API и гибкости. Например, если вы вернете `List<T>` , вы не сможете получать уведомления, когда клиентский код изменяет коллекцию. Кроме того, `List<T>` предоставляет множество членов, таких как <xref:System.Collections.Generic.List%601.BinarySearch%2A> , которые не являются полезными или применимы во многих сценариях. В следующих двух разделах описываются типы (абстракции), специально предназначенные для использования в общедоступных API.

 ❌ НЕ используйте `Hashtable` или `Dictionary<TKey,TValue>` в общедоступных API.

 Эти типы представляют собой структуры данных, предназначенные для использования во внутренней реализации. Общедоступные API должны использовать <xref:System.Collections.IDictionary> , `IDictionary <TKey, TValue>` или пользовательский тип, реализующий один или оба интерфейса.

 ❌ НЕ используйте <xref:System.Collections.Generic.IEnumerator%601> , <xref:System.Collections.IEnumerator> или любой другой тип, реализующий любой из этих интерфейсов, за исключением типа возвращаемого значения `GetEnumerator` метода.

 Типы, возвращающие перечислители из методов, отличных от `GetEnumerator` , нельзя использовать с `foreach` инструкцией.

 ❌ НЕ реализуйте `IEnumerator<T>` и `IEnumerable<T>` для того же типа. То же самое относится к неуниверсальным интерфейсам `IEnumerator` и `IEnumerable` .

## <a name="collection-parameters"></a>Параметры коллекции

 ✔️ использовать в качестве типа параметра минимально специализированный тип. Большинство членов, принимающих коллекции в качестве параметров, используют `IEnumerable<T>` интерфейс.

 ❌ Избегайте использования <xref:System.Collections.Generic.ICollection%601> или <xref:System.Collections.ICollection> в качестве параметра только для доступа к `Count` свойству.

 Вместо этого рекомендуется использовать `IEnumerable<T>` или `IEnumerable` и динамически проверять, реализует ли объект `ICollection<T>` или `ICollection` .

## <a name="collection-properties-and-return-values"></a>Свойства коллекции и возвращаемые значения

 ❌ НЕ предоставлять настраиваемые свойства коллекции.

 Пользователи могут заменить содержимое коллекции, сначала очистив коллекцию, а затем добавив новое содержимое. Если замена всей коллекции является распространенным сценарием, рассмотрите возможность предоставления `AddRange` метода коллекции.

 ✔️ использовать `Collection<T>` или подкласс `Collection<T>` для свойств или возвращаемых значений, представляющих коллекции для чтения и записи.

 Если не `Collection<T>` соответствует какому-либо требованию (например, коллекция не должна реализовывать <xref:System.Collections.IList> ), используйте пользовательскую коллекцию, реализовав `IEnumerable<T>` , `ICollection<T>` или <xref:System.Collections.Generic.IList%601> .

 ✔️ использовать <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> , подкласс `ReadOnlyCollection<T>` или в редких случаях `IEnumerable<T>` для свойств или возвращаемых значений, представляющих коллекции только для чтения.

 Как правило, предпочитать `ReadOnlyCollection<T>` . Если он не соответствует некоторым требованиям (например, коллекция не должна реализовывать `IList` ), используйте пользовательскую коллекцию, реализовав `IEnumerable<T>` , `ICollection<T>` или `IList<T>` . Если вы реализуете пользовательскую коллекцию, доступную только для чтения, реализуйте `ICollection<T>.IsReadOnly` для возврата `true` .

 В случаях, когда вы уверены, что единственный сценарий, который вы хотите поддерживать, — это однопроходная итерация, можно просто использовать `IEnumerable<T>` .

 ✔️ РЕКОМЕНДУЕТСЯ использовать подклассы универсальных базовых коллекций вместо непосредственного использования коллекций.

 Это позволяет улучшить имя и добавить вспомогательные элементы, отсутствующие в базовых типах коллекций. Это особенно применимо к интерфейсам API высокого уровня.

 ✔️ РЕКОМЕНДУЕТСЯ возвращать подкласс `Collection<T>` или `ReadOnlyCollection<T>` из очень часто используемых методов и свойств.

 Это сделает возможным добавление вспомогательных методов или изменение реализации коллекции в будущем.

 ✔️ РЕКОМЕНДУЕТСЯ использовать коллекцию с ключом, если элементы, хранящиеся в коллекции, имеют уникальные ключи (имена, идентификаторы и т. д.). Коллекции с ключом — это коллекции, которые могут индексироваться как целое число и ключ, и обычно реализуются путем наследования от `KeyedCollection<TKey,TItem>` .

 Коллекции с ключом обычно имеют больший объем памяти, и их не следует использовать, если издержки памяти привышают преимущества использования ключей.

 ❌ НЕ возвращайте значения NULL из свойств коллекции или из методов, возвращающих коллекции. Вместо этого следует возвращать пустую коллекцию или пустой массив.

 Общее правило состоит в том, что коллекции или массивы null и пустые (0 элементов) должны обрабатываться одинаково.

### <a name="snapshots-versus-live-collections"></a>Моментальные снимки и динамические коллекции

 Коллекции, представляющие состояние в определенный момент времени, называются коллекциями моментальных снимков. Например, коллекция, содержащая строки, возвращаемые запросом к базе данных, будет моментальным снимком. Коллекции, которые всегда представляют текущее состояние, называются активными коллекциями. Например, коллекция `ComboBox` элементов является динамической коллекцией.

 ❌ НЕ возвращайте коллекции моментальных снимков из свойств. Свойства должны возвращать динамические коллекции.

 Методы получения свойств должны быть очень простыми операциями. Для возврата моментального снимка необходимо создать копию внутренней коллекции в операции O (n).

 ✔️ использовать либо коллекцию моментальных снимков, либо динамический `IEnumerable<T>` (или его подтип) для представления коллекций, которые являются временными (т. е. могут изменяться без явного изменения коллекции).

 Как правило, все коллекции, представляющие общий ресурс (например, файлы в каталоге), являются временными. Такие коллекции очень трудны или невозможно реализовать как динамические коллекции, если только реализация не является просто перечислителем.

## <a name="choosing-between-arrays-and-collections"></a>Выбор между массивами и коллекциями

 ✔️ предпочтительно использовать коллекции для массивов.

 Коллекции обеспечивают больший контроль над содержимым, могут развиваться со временем и более пригодны для использования. Кроме того, использование массивов для сценариев только для чтения не рекомендуется, поскольку затраты на клонирование массива являются недопустимыми. В исследованиях удобства использования было показано, что некоторым разработчикам удобнее пользоваться API-интерфейсами на основе коллекций.

 Однако при разработке низкоуровневых интерфейсов API может быть лучше использовать массивы для сценариев чтения и записи. Массивы имеют меньший объем памяти, что позволяет сократить рабочий набор, а доступ к элементам массива выполняется быстрее, поскольку он оптимизирован средой выполнения.

 ✔️ Рассмотрите возможность использования массивов в низкоуровневых API, чтобы максимально увеличить потребление памяти и повысить производительность.

 ✔️ использовать массивы байтов вместо коллекций байтов.

 ❌ НЕ используйте массивы для свойств, если свойство должно возвращать новый массив (например, копию внутреннего массива) каждый раз при вызове метода получения свойства.

## <a name="implementing-custom-collections"></a>Реализация пользовательских коллекций

 ✔️ Рассмотрите наследование от `Collection<T>` , `ReadOnlyCollection<T>` или `KeyedCollection<TKey,TItem>` при проектировании новых коллекций.

 ✔️ реализовать `IEnumerable<T>` при проектировании новых коллекций. Рассмотрите возможность реализации `ICollection<T>` или даже `IList<T>` там, где это имеет смысл.

 При реализации такой пользовательской коллекции следует следовать шаблону API, установленному с помощью, `Collection<T>` и `ReadOnlyCollection<T>` как можно точнее. То есть явно реализуйте одни и те же члены, назовите такие параметры, как имена этих двух коллекций, и т. д.

 ✔️ Рассмотрите реализацию неуниверсальных интерфейсов коллекций ( `IList` и `ICollection` ), если коллекция часто передается интерфейсам API, принимающим эти интерфейсы в качестве входных данных.

 ❌ Избегайте реализации интерфейсов коллекций для типов со сложными API, не связанными с понятием коллекции.

 ❌ НЕ наследовать от неуниверсальных базовых коллекций, таких как `CollectionBase` . Используйте вместо них типы данных `Collection<T>`, `ReadOnlyCollection<T>` и `KeyedCollection<TKey,TItem>`.

### <a name="naming-custom-collections"></a>Именование пользовательских коллекций

 Коллекции (типы, реализующие `IEnumerable` ) создаются главным образом по двум причинам: (1) для создания новой структуры данных с операциями, зависящими от структуры, и часто отличающимися характеристиками производительности, чем существующие структуры данных (например,,,  <xref:System.Collections.Generic.List%601> <xref:System.Collections.Generic.LinkedList%601> <xref:System.Collections.Generic.Stack%601> ) и (2), для создания специализированной коллекции для хранения определенного набора элементов (например,  <xref:System.Collections.Specialized.StringCollection> ). Структуры данных чаще всего используются во внутренней реализации приложений и библиотек. Специализированные коллекции, главным образом, должны предоставляться в API-интерфейсах (как типы свойств и параметров).

 ✔️ использовать суффикс Dictionary в именах абстракций, реализующих `IDictionary` или `IDictionary<TKey,TValue>` .

 ✔️ использовать суффикс "Collection" в именах типов, реализующих `IEnumerable` (или любого из его потомков) и представляющих список элементов.

 ✔️ использовать соответствующее имя структуры данных для пользовательских структур данных.

 ❌ Старайтесь не использовать суффиксы, которые подразумевают определенную реализацию, например "LinkedList" или "Hashtable", в именах абстракций коллекции.

 ✔️ Рассмотрите возможность добавления имен коллекций с именем типа элемента. Например, коллекция, в которой хранятся элементы типа `Address` (реализация `IEnumerable<Address>` ), должна иметь имя `AddressCollection` . Если тип элемента является интерфейсом, то префикс "I" типа элемента можно опустить. Таким же набор <xref:System.IDisposable> элементов можно вызывать `DisposableCollection` .

 ✔️ РЕКОМЕНДУЕТСЯ использовать префикс "ReadOnly" в именах коллекций только для чтения, если соответствующая записываемая коллекция может быть добавлена или уже существует в платформе.

 Например, необходимо вызвать коллекцию строк, доступную только для чтения `ReadOnlyStringCollection` .

 *Части © 2005, 2009 Корпорация Майкрософт. Все права защищены.*

 *Перепечатано с разрешения Pearson Education, Inc. из книги [Инфраструктура программных проектов. Соглашения, идиомы и шаблоны для многократно используемых библиотек .NET (2-е издание)](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619), авторы: Кржиштоф Цвалина (Krzysztof Cwalina) и Брэд Абрамс (Brad Abrams). Книга опубликована 22 октября 2008 г. издательством Addison-Wesley Professional в рамках серии, посвященной разработке для Microsoft Windows.*

## <a name="see-also"></a>См. также раздел

- [Рекомендации по проектированию платформы](index.md)
- [Рекомендации по использованию](usage-guidelines.md)
