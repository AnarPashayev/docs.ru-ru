---
title: Рекомендации по использованию коллекций
ms.date: 10/22/2008
ms.assetid: 297b8f1d-b11f-4dc6-960a-8e990817304e
ms.openlocfilehash: a143e88be01bf2c8f45e25f26498d2d3ccbd98da
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/24/2020
ms.locfileid: "95706675"
---
# <a name="guidelines-for-collections"></a><span data-ttu-id="88a42-102">Рекомендации по использованию коллекций</span><span class="sxs-lookup"><span data-stu-id="88a42-102">Guidelines for Collections</span></span>

<span data-ttu-id="88a42-103">Любой тип, предназначенный специально для управления группой объектов с некоторыми общими характеристиками, может рассматриваться как коллекция.</span><span class="sxs-lookup"><span data-stu-id="88a42-103">Any type designed specifically to manipulate a group of objects having some common characteristic can be considered a collection.</span></span> <span data-ttu-id="88a42-104">Почти всегда подходит для таких типов, чтобы реализовать <xref:System.Collections.IEnumerable> или <xref:System.Collections.Generic.IEnumerable%601> , поэтому в этом разделе мы будем рассматривать только типы, реализующие один или оба этих интерфейса для коллекций.</span><span class="sxs-lookup"><span data-stu-id="88a42-104">It is almost always appropriate for such types to implement <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>, so in this section we only consider types implementing one or both of those interfaces to be collections.</span></span>

 <span data-ttu-id="88a42-105">❌ НЕ используйте неслабо типизированные коллекции в общедоступных API.</span><span class="sxs-lookup"><span data-stu-id="88a42-105">❌ DO NOT use weakly typed collections in public APIs.</span></span>

 <span data-ttu-id="88a42-106">Тип всех возвращаемых значений и параметров, представляющих элементы коллекции, должен быть точным типом элемента, а не любым из его базовых типов (это относится только к открытым элементам коллекции).</span><span class="sxs-lookup"><span data-stu-id="88a42-106">The type of all return values and parameters representing collection items should be the exact item type, not any of its base types (this applies only to public members of the collection).</span></span>

 <span data-ttu-id="88a42-107">❌ НЕ используйте <xref:System.Collections.ArrayList> или <xref:System.Collections.Generic.List%601> в общедоступных API.</span><span class="sxs-lookup"><span data-stu-id="88a42-107">❌ DO NOT use <xref:System.Collections.ArrayList> or <xref:System.Collections.Generic.List%601> in public APIs.</span></span>

 <span data-ttu-id="88a42-108">Эти типы представляют собой структуры данных, предназначенные для использования во внутренней реализации, а не в общедоступных API.</span><span class="sxs-lookup"><span data-stu-id="88a42-108">These types are data structures designed to be used in internal implementation, not in public APIs.</span></span> <span data-ttu-id="88a42-109">`List<T>` оптимизирована для повышения производительности и энергопотребления за счет очистки интерфейсов API и гибкости.</span><span class="sxs-lookup"><span data-stu-id="88a42-109">`List<T>` is optimized for performance and power at the cost of cleanness of the APIs and flexibility.</span></span> <span data-ttu-id="88a42-110">Например, если вы вернете `List<T>` , вы не сможете получать уведомления, когда клиентский код изменяет коллекцию.</span><span class="sxs-lookup"><span data-stu-id="88a42-110">For example, if you return `List<T>`, you will not ever be able to receive notifications when client code modifies the collection.</span></span> <span data-ttu-id="88a42-111">Кроме того, `List<T>` предоставляет множество членов, таких как <xref:System.Collections.Generic.List%601.BinarySearch%2A> , которые не являются полезными или применимы во многих сценариях.</span><span class="sxs-lookup"><span data-stu-id="88a42-111">Also, `List<T>` exposes many members, such as <xref:System.Collections.Generic.List%601.BinarySearch%2A>, that are not useful or applicable in many scenarios.</span></span> <span data-ttu-id="88a42-112">В следующих двух разделах описываются типы (абстракции), специально предназначенные для использования в общедоступных API.</span><span class="sxs-lookup"><span data-stu-id="88a42-112">The following two sections describe types (abstractions) designed specifically for use in public APIs.</span></span>

 <span data-ttu-id="88a42-113">❌ НЕ используйте `Hashtable` или `Dictionary<TKey,TValue>` в общедоступных API.</span><span class="sxs-lookup"><span data-stu-id="88a42-113">❌ DO NOT use `Hashtable` or `Dictionary<TKey,TValue>` in public APIs.</span></span>

 <span data-ttu-id="88a42-114">Эти типы представляют собой структуры данных, предназначенные для использования во внутренней реализации.</span><span class="sxs-lookup"><span data-stu-id="88a42-114">These types are data structures designed to be used in internal implementation.</span></span> <span data-ttu-id="88a42-115">Общедоступные API должны использовать <xref:System.Collections.IDictionary> , `IDictionary <TKey, TValue>` или пользовательский тип, реализующий один или оба интерфейса.</span><span class="sxs-lookup"><span data-stu-id="88a42-115">Public APIs should use <xref:System.Collections.IDictionary>, `IDictionary <TKey, TValue>`, or a custom type implementing one or both of the interfaces.</span></span>

 <span data-ttu-id="88a42-116">❌ НЕ используйте <xref:System.Collections.Generic.IEnumerator%601> , <xref:System.Collections.IEnumerator> или любой другой тип, реализующий любой из этих интерфейсов, за исключением типа возвращаемого значения `GetEnumerator` метода.</span><span class="sxs-lookup"><span data-stu-id="88a42-116">❌ DO NOT use <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Collections.IEnumerator>, or any other type that implements either of these interfaces, except as the return type of a `GetEnumerator` method.</span></span>

 <span data-ttu-id="88a42-117">Типы, возвращающие перечислители из методов, отличных от `GetEnumerator` , нельзя использовать с `foreach` инструкцией.</span><span class="sxs-lookup"><span data-stu-id="88a42-117">Types returning enumerators from methods other than `GetEnumerator` cannot be used with the `foreach` statement.</span></span>

 <span data-ttu-id="88a42-118">❌ НЕ реализуйте `IEnumerator<T>` и `IEnumerable<T>` для того же типа.</span><span class="sxs-lookup"><span data-stu-id="88a42-118">❌ DO NOT implement both `IEnumerator<T>` and `IEnumerable<T>` on the same type.</span></span> <span data-ttu-id="88a42-119">То же самое относится к неуниверсальным интерфейсам `IEnumerator` и `IEnumerable` .</span><span class="sxs-lookup"><span data-stu-id="88a42-119">The same applies to the nongeneric interfaces `IEnumerator` and `IEnumerable`.</span></span>

## <a name="collection-parameters"></a><span data-ttu-id="88a42-120">Параметры коллекции</span><span class="sxs-lookup"><span data-stu-id="88a42-120">Collection Parameters</span></span>

 <span data-ttu-id="88a42-121">✔️ использовать в качестве типа параметра минимально специализированный тип.</span><span class="sxs-lookup"><span data-stu-id="88a42-121">✔️ DO use the least-specialized type possible as a parameter type.</span></span> <span data-ttu-id="88a42-122">Большинство членов, принимающих коллекции в качестве параметров, используют `IEnumerable<T>` интерфейс.</span><span class="sxs-lookup"><span data-stu-id="88a42-122">Most members taking collections as parameters use the `IEnumerable<T>` interface.</span></span>

 <span data-ttu-id="88a42-123">❌ Избегайте использования <xref:System.Collections.Generic.ICollection%601> или <xref:System.Collections.ICollection> в качестве параметра только для доступа к `Count` свойству.</span><span class="sxs-lookup"><span data-stu-id="88a42-123">❌ AVOID using <xref:System.Collections.Generic.ICollection%601> or <xref:System.Collections.ICollection> as a parameter just to access the `Count` property.</span></span>

 <span data-ttu-id="88a42-124">Вместо этого рекомендуется использовать `IEnumerable<T>` или `IEnumerable` и динамически проверять, реализует ли объект `ICollection<T>` или `ICollection` .</span><span class="sxs-lookup"><span data-stu-id="88a42-124">Instead, consider using `IEnumerable<T>` or `IEnumerable` and dynamically checking whether the object implements `ICollection<T>` or `ICollection`.</span></span>

## <a name="collection-properties-and-return-values"></a><span data-ttu-id="88a42-125">Свойства коллекции и возвращаемые значения</span><span class="sxs-lookup"><span data-stu-id="88a42-125">Collection Properties and Return Values</span></span>

 <span data-ttu-id="88a42-126">❌ НЕ предоставлять настраиваемые свойства коллекции.</span><span class="sxs-lookup"><span data-stu-id="88a42-126">❌ DO NOT provide settable collection properties.</span></span>

 <span data-ttu-id="88a42-127">Пользователи могут заменить содержимое коллекции, сначала очистив коллекцию, а затем добавив новое содержимое.</span><span class="sxs-lookup"><span data-stu-id="88a42-127">Users can replace the contents of the collection by clearing the collection first and then adding the new contents.</span></span> <span data-ttu-id="88a42-128">Если замена всей коллекции является распространенным сценарием, рассмотрите возможность предоставления `AddRange` метода коллекции.</span><span class="sxs-lookup"><span data-stu-id="88a42-128">If replacing the whole collection is a common scenario, consider providing the `AddRange` method on the collection.</span></span>

 <span data-ttu-id="88a42-129">✔️ использовать `Collection<T>` или подкласс `Collection<T>` для свойств или возвращаемых значений, представляющих коллекции для чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="88a42-129">✔️ DO use `Collection<T>` or a subclass of `Collection<T>` for properties or return values representing read/write collections.</span></span>

 <span data-ttu-id="88a42-130">Если не `Collection<T>` соответствует какому-либо требованию (например, коллекция не должна реализовывать <xref:System.Collections.IList> ), используйте пользовательскую коллекцию, реализовав `IEnumerable<T>` , `ICollection<T>` или <xref:System.Collections.Generic.IList%601> .</span><span class="sxs-lookup"><span data-stu-id="88a42-130">If `Collection<T>` does not meet some requirement (e.g., the collection must not implement <xref:System.Collections.IList>), use a custom collection by implementing `IEnumerable<T>`, `ICollection<T>`, or <xref:System.Collections.Generic.IList%601>.</span></span>

 <span data-ttu-id="88a42-131">✔️ использовать <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> , подкласс `ReadOnlyCollection<T>` или в редких случаях `IEnumerable<T>` для свойств или возвращаемых значений, представляющих коллекции только для чтения.</span><span class="sxs-lookup"><span data-stu-id="88a42-131">✔️ DO use <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>, a subclass of `ReadOnlyCollection<T>`, or in rare cases `IEnumerable<T>` for properties or return values representing read-only collections.</span></span>

 <span data-ttu-id="88a42-132">Как правило, предпочитать `ReadOnlyCollection<T>` .</span><span class="sxs-lookup"><span data-stu-id="88a42-132">In general, prefer `ReadOnlyCollection<T>`.</span></span> <span data-ttu-id="88a42-133">Если он не соответствует некоторым требованиям (например, коллекция не должна реализовывать `IList` ), используйте пользовательскую коллекцию, реализовав `IEnumerable<T>` , `ICollection<T>` или `IList<T>` .</span><span class="sxs-lookup"><span data-stu-id="88a42-133">If it does not meet some requirement (e.g., the collection must not implement `IList`), use a custom collection by implementing `IEnumerable<T>`, `ICollection<T>`, or `IList<T>`.</span></span> <span data-ttu-id="88a42-134">Если вы реализуете пользовательскую коллекцию, доступную только для чтения, реализуйте `ICollection<T>.IsReadOnly` для возврата `true` .</span><span class="sxs-lookup"><span data-stu-id="88a42-134">If you do implement a custom read-only collection, implement `ICollection<T>.IsReadOnly` to return `true`.</span></span>

 <span data-ttu-id="88a42-135">В случаях, когда вы уверены, что единственный сценарий, который вы хотите поддерживать, — это однопроходная итерация, можно просто использовать `IEnumerable<T>` .</span><span class="sxs-lookup"><span data-stu-id="88a42-135">In cases where you are sure that the only scenario you will ever want to support is forward-only iteration, you can simply use `IEnumerable<T>`.</span></span>

 <span data-ttu-id="88a42-136">✔️ РЕКОМЕНДУЕТСЯ использовать подклассы универсальных базовых коллекций вместо непосредственного использования коллекций.</span><span class="sxs-lookup"><span data-stu-id="88a42-136">✔️ CONSIDER using subclasses of generic base collections instead of using the collections directly.</span></span>

 <span data-ttu-id="88a42-137">Это позволяет улучшить имя и добавить вспомогательные элементы, отсутствующие в базовых типах коллекций.</span><span class="sxs-lookup"><span data-stu-id="88a42-137">This allows for a better name and for adding helper members that are not present on the base collection types.</span></span> <span data-ttu-id="88a42-138">Это особенно применимо к интерфейсам API высокого уровня.</span><span class="sxs-lookup"><span data-stu-id="88a42-138">This is especially applicable to high-level APIs.</span></span>

 <span data-ttu-id="88a42-139">✔️ РЕКОМЕНДУЕТСЯ возвращать подкласс `Collection<T>` или `ReadOnlyCollection<T>` из очень часто используемых методов и свойств.</span><span class="sxs-lookup"><span data-stu-id="88a42-139">✔️ CONSIDER returning a subclass of `Collection<T>` or `ReadOnlyCollection<T>` from very commonly used methods and properties.</span></span>

 <span data-ttu-id="88a42-140">Это сделает возможным добавление вспомогательных методов или изменение реализации коллекции в будущем.</span><span class="sxs-lookup"><span data-stu-id="88a42-140">This will make it possible for you to add helper methods or change the collection implementation in the future.</span></span>

 <span data-ttu-id="88a42-141">✔️ РЕКОМЕНДУЕТСЯ использовать коллекцию с ключом, если элементы, хранящиеся в коллекции, имеют уникальные ключи (имена, идентификаторы и т. д.).</span><span class="sxs-lookup"><span data-stu-id="88a42-141">✔️ CONSIDER using a keyed collection if the items stored in the collection have unique keys (names, IDs, etc.).</span></span> <span data-ttu-id="88a42-142">Коллекции с ключом — это коллекции, которые могут индексироваться как целое число и ключ, и обычно реализуются путем наследования от `KeyedCollection<TKey,TItem>` .</span><span class="sxs-lookup"><span data-stu-id="88a42-142">Keyed collections are collections that can be indexed by both an integer and a key and are usually implemented by inheriting from `KeyedCollection<TKey,TItem>`.</span></span>

 <span data-ttu-id="88a42-143">Коллекции с ключом обычно имеют больший объем памяти, и их не следует использовать, если издержки памяти привышают преимущества использования ключей.</span><span class="sxs-lookup"><span data-stu-id="88a42-143">Keyed collections usually have larger memory footprints and should not be used if the memory overhead outweighs the benefits of having the keys.</span></span>

 <span data-ttu-id="88a42-144">❌ НЕ возвращайте значения NULL из свойств коллекции или из методов, возвращающих коллекции.</span><span class="sxs-lookup"><span data-stu-id="88a42-144">❌ DO NOT return null values from collection properties or from methods returning collections.</span></span> <span data-ttu-id="88a42-145">Вместо этого следует возвращать пустую коллекцию или пустой массив.</span><span class="sxs-lookup"><span data-stu-id="88a42-145">Return an empty collection or an empty array instead.</span></span>

 <span data-ttu-id="88a42-146">Общее правило состоит в том, что коллекции или массивы null и пустые (0 элементов) должны обрабатываться одинаково.</span><span class="sxs-lookup"><span data-stu-id="88a42-146">The general rule is that null and empty (0 item) collections or arrays should be treated the same.</span></span>

### <a name="snapshots-versus-live-collections"></a><span data-ttu-id="88a42-147">Моментальные снимки и динамические коллекции</span><span class="sxs-lookup"><span data-stu-id="88a42-147">Snapshots Versus Live Collections</span></span>

 <span data-ttu-id="88a42-148">Коллекции, представляющие состояние в определенный момент времени, называются коллекциями моментальных снимков.</span><span class="sxs-lookup"><span data-stu-id="88a42-148">Collections representing a state at some point in time are called snapshot collections.</span></span> <span data-ttu-id="88a42-149">Например, коллекция, содержащая строки, возвращаемые запросом к базе данных, будет моментальным снимком.</span><span class="sxs-lookup"><span data-stu-id="88a42-149">For example, a collection containing rows returned from a database query would be a snapshot.</span></span> <span data-ttu-id="88a42-150">Коллекции, которые всегда представляют текущее состояние, называются активными коллекциями.</span><span class="sxs-lookup"><span data-stu-id="88a42-150">Collections that always represent the current state are called live collections.</span></span> <span data-ttu-id="88a42-151">Например, коллекция `ComboBox` элементов является динамической коллекцией.</span><span class="sxs-lookup"><span data-stu-id="88a42-151">For example, a collection of `ComboBox` items is a live collection.</span></span>

 <span data-ttu-id="88a42-152">❌ НЕ возвращайте коллекции моментальных снимков из свойств.</span><span class="sxs-lookup"><span data-stu-id="88a42-152">❌ DO NOT return snapshot collections from properties.</span></span> <span data-ttu-id="88a42-153">Свойства должны возвращать динамические коллекции.</span><span class="sxs-lookup"><span data-stu-id="88a42-153">Properties should return live collections.</span></span>

 <span data-ttu-id="88a42-154">Методы получения свойств должны быть очень простыми операциями.</span><span class="sxs-lookup"><span data-stu-id="88a42-154">Property getters should be very lightweight operations.</span></span> <span data-ttu-id="88a42-155">Для возврата моментального снимка необходимо создать копию внутренней коллекции в операции O (n).</span><span class="sxs-lookup"><span data-stu-id="88a42-155">Returning a snapshot requires creating a copy of an internal collection in an O(n) operation.</span></span>

 <span data-ttu-id="88a42-156">✔️ использовать либо коллекцию моментальных снимков, либо динамический `IEnumerable<T>` (или его подтип) для представления коллекций, которые являются временными (т. е. могут изменяться без явного изменения коллекции).</span><span class="sxs-lookup"><span data-stu-id="88a42-156">✔️ DO use either a snapshot collection or a live `IEnumerable<T>` (or its subtype) to represent collections that are volatile (i.e., that can change without explicitly modifying the collection).</span></span>

 <span data-ttu-id="88a42-157">Как правило, все коллекции, представляющие общий ресурс (например, файлы в каталоге), являются временными.</span><span class="sxs-lookup"><span data-stu-id="88a42-157">In general, all collections representing a shared resource (e.g., files in a directory) are volatile.</span></span> <span data-ttu-id="88a42-158">Такие коллекции очень трудны или невозможно реализовать как динамические коллекции, если только реализация не является просто перечислителем.</span><span class="sxs-lookup"><span data-stu-id="88a42-158">Such collections are very difficult or impossible to implement as live collections unless the implementation is simply a forward-only enumerator.</span></span>

## <a name="choosing-between-arrays-and-collections"></a><span data-ttu-id="88a42-159">Выбор между массивами и коллекциями</span><span class="sxs-lookup"><span data-stu-id="88a42-159">Choosing Between Arrays and Collections</span></span>

 <span data-ttu-id="88a42-160">✔️ предпочтительно использовать коллекции для массивов.</span><span class="sxs-lookup"><span data-stu-id="88a42-160">✔️ DO prefer collections over arrays.</span></span>

 <span data-ttu-id="88a42-161">Коллекции обеспечивают больший контроль над содержимым, могут развиваться со временем и более пригодны для использования.</span><span class="sxs-lookup"><span data-stu-id="88a42-161">Collections provide more control over contents, can evolve over time, and are more usable.</span></span> <span data-ttu-id="88a42-162">Кроме того, использование массивов для сценариев только для чтения не рекомендуется, поскольку затраты на клонирование массива являются недопустимыми.</span><span class="sxs-lookup"><span data-stu-id="88a42-162">In addition, using arrays for read-only scenarios is discouraged because the cost of cloning the array is prohibitive.</span></span> <span data-ttu-id="88a42-163">В исследованиях удобства использования было показано, что некоторым разработчикам удобнее пользоваться API-интерфейсами на основе коллекций.</span><span class="sxs-lookup"><span data-stu-id="88a42-163">Usability studies have shown that some developers feel more comfortable using collection-based APIs.</span></span>

 <span data-ttu-id="88a42-164">Однако при разработке низкоуровневых интерфейсов API может быть лучше использовать массивы для сценариев чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="88a42-164">However, if you are developing low-level APIs, it might be better to use arrays for read-write scenarios.</span></span> <span data-ttu-id="88a42-165">Массивы имеют меньший объем памяти, что позволяет сократить рабочий набор, а доступ к элементам массива выполняется быстрее, поскольку он оптимизирован средой выполнения.</span><span class="sxs-lookup"><span data-stu-id="88a42-165">Arrays have a smaller memory footprint, which helps reduce the working set, and access to elements in an array is faster because it is optimized by the runtime.</span></span>

 <span data-ttu-id="88a42-166">✔️ Рассмотрите возможность использования массивов в низкоуровневых API, чтобы максимально увеличить потребление памяти и повысить производительность.</span><span class="sxs-lookup"><span data-stu-id="88a42-166">✔️ CONSIDER using arrays in low-level APIs to minimize memory consumption and maximize performance.</span></span>

 <span data-ttu-id="88a42-167">✔️ использовать массивы байтов вместо коллекций байтов.</span><span class="sxs-lookup"><span data-stu-id="88a42-167">✔️ DO use byte arrays instead of collections of bytes.</span></span>

 <span data-ttu-id="88a42-168">❌ НЕ используйте массивы для свойств, если свойство должно возвращать новый массив (например, копию внутреннего массива) каждый раз при вызове метода получения свойства.</span><span class="sxs-lookup"><span data-stu-id="88a42-168">❌ DO NOT use arrays for properties if the property would have to return a new array (e.g., a copy of an internal array) every time the property getter is called.</span></span>

## <a name="implementing-custom-collections"></a><span data-ttu-id="88a42-169">Реализация пользовательских коллекций</span><span class="sxs-lookup"><span data-stu-id="88a42-169">Implementing Custom Collections</span></span>

 <span data-ttu-id="88a42-170">✔️ Рассмотрите наследование от `Collection<T>` , `ReadOnlyCollection<T>` или `KeyedCollection<TKey,TItem>` при проектировании новых коллекций.</span><span class="sxs-lookup"><span data-stu-id="88a42-170">✔️ CONSIDER inheriting from `Collection<T>`, `ReadOnlyCollection<T>`, or `KeyedCollection<TKey,TItem>` when designing new collections.</span></span>

 <span data-ttu-id="88a42-171">✔️ реализовать `IEnumerable<T>` при проектировании новых коллекций.</span><span class="sxs-lookup"><span data-stu-id="88a42-171">✔️ DO implement `IEnumerable<T>` when designing new collections.</span></span> <span data-ttu-id="88a42-172">Рассмотрите возможность реализации `ICollection<T>` или даже `IList<T>` там, где это имеет смысл.</span><span class="sxs-lookup"><span data-stu-id="88a42-172">Consider implementing `ICollection<T>` or even `IList<T>` where it makes sense.</span></span>

 <span data-ttu-id="88a42-173">При реализации такой пользовательской коллекции следует следовать шаблону API, установленному с помощью, `Collection<T>` и `ReadOnlyCollection<T>` как можно точнее.</span><span class="sxs-lookup"><span data-stu-id="88a42-173">When implementing such custom collection, follow the API pattern established by `Collection<T>` and `ReadOnlyCollection<T>` as closely as possible.</span></span> <span data-ttu-id="88a42-174">То есть явно реализуйте одни и те же члены, назовите такие параметры, как имена этих двух коллекций, и т. д.</span><span class="sxs-lookup"><span data-stu-id="88a42-174">That is, implement the same members explicitly, name the parameters like these two collections name them, and so on.</span></span>

 <span data-ttu-id="88a42-175">✔️ Рассмотрите реализацию неуниверсальных интерфейсов коллекций ( `IList` и `ICollection` ), если коллекция часто передается интерфейсам API, принимающим эти интерфейсы в качестве входных данных.</span><span class="sxs-lookup"><span data-stu-id="88a42-175">✔️ CONSIDER implementing nongeneric collection interfaces (`IList` and `ICollection`) if the collection will often be passed to APIs taking these interfaces as input.</span></span>

 <span data-ttu-id="88a42-176">❌ Избегайте реализации интерфейсов коллекций для типов со сложными API, не связанными с понятием коллекции.</span><span class="sxs-lookup"><span data-stu-id="88a42-176">❌ AVOID implementing collection interfaces on types with complex APIs unrelated to the concept of a collection.</span></span>

 <span data-ttu-id="88a42-177">❌ НЕ наследовать от неуниверсальных базовых коллекций, таких как `CollectionBase` .</span><span class="sxs-lookup"><span data-stu-id="88a42-177">❌ DO NOT inherit from nongeneric base collections such as `CollectionBase`.</span></span> <span data-ttu-id="88a42-178">Используйте вместо них типы данных `Collection<T>`, `ReadOnlyCollection<T>` и `KeyedCollection<TKey,TItem>`.</span><span class="sxs-lookup"><span data-stu-id="88a42-178">Use `Collection<T>`, `ReadOnlyCollection<T>`, and `KeyedCollection<TKey,TItem>` instead.</span></span>

### <a name="naming-custom-collections"></a><span data-ttu-id="88a42-179">Именование пользовательских коллекций</span><span class="sxs-lookup"><span data-stu-id="88a42-179">Naming Custom Collections</span></span>

 <span data-ttu-id="88a42-180">Коллекции (типы, реализующие `IEnumerable` ) создаются главным образом по двум причинам: (1) для создания новой структуры данных с операциями, зависящими от структуры, и часто отличающимися характеристиками производительности, чем существующие структуры данных (например,,,  <xref:System.Collections.Generic.List%601> <xref:System.Collections.Generic.LinkedList%601> <xref:System.Collections.Generic.Stack%601> ) и (2), для создания специализированной коллекции для хранения определенного набора элементов (например,  <xref:System.Collections.Specialized.StringCollection> ).</span><span class="sxs-lookup"><span data-stu-id="88a42-180">Collections (types that implement `IEnumerable`) are created mainly for two reasons: (1) to create a new data structure with structure-specific operations and often different performance characteristics than existing data structures (e.g.,  <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.LinkedList%601>, <xref:System.Collections.Generic.Stack%601>), and (2) to create a specialized collection for holding a specific set of items (e.g.,  <xref:System.Collections.Specialized.StringCollection>).</span></span> <span data-ttu-id="88a42-181">Структуры данных чаще всего используются во внутренней реализации приложений и библиотек.</span><span class="sxs-lookup"><span data-stu-id="88a42-181">Data structures are most often used in the internal implementation of applications and libraries.</span></span> <span data-ttu-id="88a42-182">Специализированные коллекции, главным образом, должны предоставляться в API-интерфейсах (как типы свойств и параметров).</span><span class="sxs-lookup"><span data-stu-id="88a42-182">Specialized collections are mainly to be exposed in APIs (as property and parameter types).</span></span>

 <span data-ttu-id="88a42-183">✔️ использовать суффикс Dictionary в именах абстракций, реализующих `IDictionary` или `IDictionary<TKey,TValue>` .</span><span class="sxs-lookup"><span data-stu-id="88a42-183">✔️ DO use the "Dictionary" suffix in names of abstractions implementing `IDictionary` or `IDictionary<TKey,TValue>`.</span></span>

 <span data-ttu-id="88a42-184">✔️ использовать суффикс "Collection" в именах типов, реализующих `IEnumerable` (или любого из его потомков) и представляющих список элементов.</span><span class="sxs-lookup"><span data-stu-id="88a42-184">✔️ DO use the "Collection" suffix in names of types implementing `IEnumerable` (or any of its descendants) and representing a list of items.</span></span>

 <span data-ttu-id="88a42-185">✔️ использовать соответствующее имя структуры данных для пользовательских структур данных.</span><span class="sxs-lookup"><span data-stu-id="88a42-185">✔️ DO use the appropriate data structure name for custom data structures.</span></span>

 <span data-ttu-id="88a42-186">❌ Старайтесь не использовать суффиксы, которые подразумевают определенную реализацию, например "LinkedList" или "Hashtable", в именах абстракций коллекции.</span><span class="sxs-lookup"><span data-stu-id="88a42-186">❌ AVOID using any suffixes implying particular implementation, such as "LinkedList" or "Hashtable," in names of collection abstractions.</span></span>

 <span data-ttu-id="88a42-187">✔️ Рассмотрите возможность добавления имен коллекций с именем типа элемента.</span><span class="sxs-lookup"><span data-stu-id="88a42-187">✔️ CONSIDER prefixing collection names with the name of the item type.</span></span> <span data-ttu-id="88a42-188">Например, коллекция, в которой хранятся элементы типа `Address` (реализация `IEnumerable<Address>` ), должна иметь имя `AddressCollection` .</span><span class="sxs-lookup"><span data-stu-id="88a42-188">For example, a collection storing items of type `Address` (implementing `IEnumerable<Address>`) should be named `AddressCollection`.</span></span> <span data-ttu-id="88a42-189">Если тип элемента является интерфейсом, то префикс "I" типа элемента можно опустить.</span><span class="sxs-lookup"><span data-stu-id="88a42-189">If the item type is an interface, the "I" prefix of the item type can be omitted.</span></span> <span data-ttu-id="88a42-190">Таким же набор <xref:System.IDisposable> элементов можно вызывать `DisposableCollection` .</span><span class="sxs-lookup"><span data-stu-id="88a42-190">Thus, a collection of <xref:System.IDisposable> items can be called `DisposableCollection`.</span></span>

 <span data-ttu-id="88a42-191">✔️ РЕКОМЕНДУЕТСЯ использовать префикс "ReadOnly" в именах коллекций только для чтения, если соответствующая записываемая коллекция может быть добавлена или уже существует в платформе.</span><span class="sxs-lookup"><span data-stu-id="88a42-191">✔️ CONSIDER using the "ReadOnly" prefix in names of read-only collections if a corresponding writeable collection might be added or already exists in the framework.</span></span>

 <span data-ttu-id="88a42-192">Например, необходимо вызвать коллекцию строк, доступную только для чтения `ReadOnlyStringCollection` .</span><span class="sxs-lookup"><span data-stu-id="88a42-192">For example, a read-only collection of strings should be called `ReadOnlyStringCollection`.</span></span>

 <span data-ttu-id="88a42-193">*Части © 2005, 2009 Корпорация Майкрософт. Все права защищены.*</span><span class="sxs-lookup"><span data-stu-id="88a42-193">*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*</span></span>

 <span data-ttu-id="88a42-194">*Перепечатано с разрешения Pearson Education, Inc. из книги [Инфраструктура программных проектов. Соглашения, идиомы и шаблоны для многократно используемых библиотек .NET (2-е издание)](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619), авторы: Кржиштоф Цвалина (Krzysztof Cwalina) и Брэд Абрамс (Brad Abrams). Книга опубликована 22 октября 2008 г. издательством Addison-Wesley Professional в рамках серии, посвященной разработке для Microsoft Windows.*</span><span class="sxs-lookup"><span data-stu-id="88a42-194">*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*</span></span>

## <a name="see-also"></a><span data-ttu-id="88a42-195">См. также раздел</span><span class="sxs-lookup"><span data-stu-id="88a42-195">See also</span></span>

- [<span data-ttu-id="88a42-196">Рекомендации по проектированию платформы</span><span class="sxs-lookup"><span data-stu-id="88a42-196">Framework Design Guidelines</span></span>](index.md)
- [<span data-ttu-id="88a42-197">Рекомендации по использованию</span><span class="sxs-lookup"><span data-stu-id="88a42-197">Usage Guidelines</span></span>](usage-guidelines.md)
