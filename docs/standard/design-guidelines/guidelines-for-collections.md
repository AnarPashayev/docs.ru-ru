---
title: Рекомендации по использованию коллекций
ms.date: 10/22/2008
ms.technology: dotnet-standard
ms.assetid: 297b8f1d-b11f-4dc6-960a-8e990817304e
author: KrzysztofCwalina
ms.openlocfilehash: a8e8672d71500478dbbe28512e413e8ada501f45
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61669054"
---
# <a name="guidelines-for-collections"></a>Рекомендации по использованию коллекций
Можно рассматривать как коллекцию любого типа, разработанные специально для того, для использования группы объектов, с некоторыми общими характеристиками. Это почти всегда требуется для таких типов, для реализации <xref:System.Collections.IEnumerable> или <xref:System.Collections.Generic.IEnumerable%601>, поэтому в этом разделе мы учитываем только типы, реализовав один или оба этих интерфейса, как коллекции.  
  
 **X DO NOT** использования слабо типизированных коллекций в открытых интерфейсах API.  
  
 Тип все возвращаемые значения и параметры, представляющие элементы коллекции должен быть тип точное элемента, не любой из его базовых типов (это относится только к открытых членов коллекции).  
  
 **X DO NOT** использовать <xref:System.Collections.ArrayList> или <xref:System.Collections.Generic.List%601> в открытых интерфейсах API.  
  
 Эти типы являются структурами данных, предназначенной для использования в внутренней реализации, не в общедоступных интерфейсов API. `List<T>` оптимизирован для производительности и мощность за счет cleanness API-интерфейсов и гибкость. Например, если возвращается `List<T>`, не когда-нибудь можно получать уведомления, когда клиентский код изменяет коллекцию. Кроме того `List<T>` предоставляет большое количество элементов, таких как <xref:System.Collections.Generic.List%601.BinarySearch%2A>, которые не полезны или не подходит для многих сценариев. Ниже описаны типы (абстракции) разработан специально для использования общедоступных интерфейсов API.  
  
 **X DO NOT** использовать `Hashtable` или `Dictionary<TKey,TValue>` в открытых интерфейсах API.  
  
 Эти типы являются структурами данных, предназначенной для использования в внутренней реализации. Общедоступные API следует использовать <xref:System.Collections.IDictionary>, `IDictionary <TKey, TValue>`, или пользовательского типа, реализовав один или оба интерфейса.  
  
 **X DO NOT** использовать <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Collections.IEnumerator>, или любого другого типа, который реализует один из этих интерфейсов, за исключением того, как тип возвращаемого значения `GetEnumerator` метод.  
  
 Типы, отличные от возвращение перечислители методов `GetEnumerator` нельзя использовать с `foreach` инструкции.  
  
 **X DO NOT** реализовывать `IEnumerator<T>` и `IEnumerable<T>` на тот же тип. То же применимо к неуниверсальных интерфейсов `IEnumerator` и `IEnumerable`.  
  
## <a name="collection-parameters"></a>Параметры сбора  
 **✓ DO** использовать возможные специализированные наименее тип в качестве типа параметра. Большинство членов использованию коллекций, поскольку параметры используют `IEnumerable<T>` интерфейс.  
  
 **X AVOID** с помощью <xref:System.Collections.Generic.ICollection%601> или <xref:System.Collections.ICollection> как параметр только для доступа к `Count` свойство.  
  
 Вместо этого рассмотрите возможность использования `IEnumerable<T>` или `IEnumerable` и динамически проверяется, реализует ли объект `ICollection<T>` или `ICollection`.  
  
## <a name="collection-properties-and-return-values"></a>Свойства коллекции и возвращаемые значения  
 **X DO NOT** предоставляют настраиваемые коллекции свойств.  
  
 Пользователи могут заменить содержимое коллекции, сначала очистив коллекции, а затем добавив новое содержимое. Если замена всей коллекции является распространенным сценарием, подберите `AddRange` метод в коллекции.  
  
 **✓ DO** использовать `Collection<T>` или подкласс `Collection<T>` для свойства или возвращаемого значения представления коллекции для чтения и записи.  
  
 Если `Collection<T>` не соответствует требованиям некоторых (например, коллекции не должен реализовывать <xref:System.Collections.IList>), используйте пользовательскую коллекцию, реализовав `IEnumerable<T>`, `ICollection<T>`, или <xref:System.Collections.Generic.IList%601>.  
  
 **✓ DO** использовать <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>, подкласс `ReadOnlyCollection<T>`, или, в редких случаях `IEnumerable<T>` для свойства или возвращаемого значения представления коллекции только для чтения.  
  
 Как правило, предпочитаю `ReadOnlyCollection<T>`. Если он не соответствует требованиям некоторых (например, коллекции не должен реализовывать `IList`), используйте пользовательскую коллекцию, реализовав `IEnumerable<T>`, `ICollection<T>`, или `IList<T>`. Если реализуется пользовательская коллекция только для чтения, реализовать `ICollection<T>.IsReadOnly` для возврата `true`.  
  
 В случаях, где вы уверены, что единственный случай, когда-нибудь потребуется поддерживать является последовательного итерации, можно просто использовать `IEnumerable<T>`.  
  
 **✓ CONSIDER** с использованием подклассов универсальных коллекций базовый вместо использования коллекций.  
  
 Благодаря этому для более понятным названием, а также для добавления вспомогательные методы, которые не существуют в базовой коллекции типов. Этот параметр хорошо подходит для API высокого уровня.  
  
 **✓ CONSIDER** возврат подкласс `Collection<T>` или `ReadOnlyCollection<T>` из очень часто используемые методы и свойства.  
  
 Это сделает его можно добавить вспомогательные методы или измените реализацию коллекции в будущем.  
  
 **✓ CONSIDER** с помощью является коллекцией с ключом, если элементы, хранящихся в коллекции имеют уникальные ключи (имена, идентификаторы и т. д.). С ключом коллекции являются коллекциями, которые могут быть проиндексирован как целое число, так и ключ и обычно реализуются путем наследования от `KeyedCollection<TKey,TItem>`.  
  
 Коллекции с ключом обычно требуют больше ресурсов памяти традиционными и не должны использоваться, если дополнительная нагрузка на память перевешивает преимущества ключи.  
  
 **X DO NOT** возвращать значения null из свойства коллекции или методами, возвращающими коллекции. Вместо этого возвращать пустую коллекцию или пустой массив.  
  
 Общее правило состоит в null и пустые коллекции (0 элементов) или массивов следует обрабатывается так же.  
  
### <a name="snapshots-versus-live-collections"></a>Моментальные снимки и динамической коллекции  
 Коллекции, представляющий состояние в определенный момент во времени, называются моментальный снимок коллекции. Например коллекция, содержащая строки, возвращаемые из запроса к базе данных будет моментального снимка. Коллекции, которые всегда представляют текущее состояние, называются динамической коллекций. Например, коллекция `ComboBox` элементов является коллекцией с динамической.  
  
 **X DO NOT** возвращают коллекции моментального снимка из свойств. Свойства должны возвращать динамической коллекций.  
  
 Методы получения свойств должны быть очень простых операций. Возвращение моментального снимка требуется создание копии во внутреннюю коллекцию в операцией O(n).  
  
 **✓ DO** использовать моментальный снимок коллекции или активной `IEnumerable<T>` (или его подтипов) для представления коллекций, которые являются volatile (т. е., можно изменить без явного изменения коллекции).  
  
 Как правило все коллекции, представляющий общий ресурс (например, файлы в каталоге) нестабильны. Такие коллекции являются очень сложно или невозможно реализовать как динамические коллекции, если реализация не просто последовательного перечислителя.  
  
## <a name="choosing-between-arrays-and-collections"></a>Выбор между массивы и коллекции  
 **✓ DO** предпочтение коллекций и массивы.  
  
 Коллекции обеспечивают больший контроль над содержимым, со временем могут развиваться и могут более использоваться. Кроме того использование массивов для сценариев только для чтения не рекомендуется, так как затраты на клонирование массива чрезмерно высокой. Удобство использования исследования показали, что некоторым разработчикам удобнее работать с помощью интерфейсов API на основе коллекций.  
  
 Тем не менее если вы разрабатываете низкоуровневые API, рекомендуется использовать массивы для сценариев чтения и записи. Массивы имеют меньший объем памяти, помогает сократить рабочего набора, и доступ к элементам массива выполняется быстрее, так как он оптимизирован средой выполнения.  
  
 **✓ CONSIDER** использование массивов в API нижнего уровня к минимуму потребление памяти и повышения производительности.  
  
 **✓ DO** использовать байтовые массивы вместо коллекции байтов.  
  
 **X DO NOT** используйте массивы для свойств, если свойство будет иметь для возврата нового массива (например, копия внутреннего массива) каждый раз, вызывается метод считывания свойства.  
  
## <a name="implementing-custom-collections"></a>Реализация пользовательских коллекций  
 **✓ CONSIDER** наследование от `Collection<T>`, `ReadOnlyCollection<T>`, или `KeyedCollection<TKey,TItem>` при разработке новых семейств сайтов.  
  
 **✓ DO** реализации `IEnumerable<T>` при разработке новых семейств сайтов. Рассмотрите возможность реализации `ICollection<T>` или даже `IList<T>` где имеет смысл.  
  
 При реализации таких настраиваемой коллекции, следуют шаблону API, опубликованный консорциумом `Collection<T>` и `ReadOnlyCollection<T>` как можно точнее. То есть явным образом реализовывать те же члены, имена параметров, как эти две коллекции назовите их и т. д.  
  
 **✓ CONSIDER** реализация интерфейсов неуниверсальных коллекций (`IList` и `ICollection`) если коллекции часто передается в API-интерфейсы используя эти интерфейсы в качестве входных данных.  
  
 **X AVOID** реализация интерфейсов коллекций в типах сложных API-интерфейсами, не относящуюся к концепцию коллекции.  
  
 **X DO NOT** наследовать от неуниверсальных коллекций базовый, такие как `CollectionBase`. Используйте `Collection<T>`, `ReadOnlyCollection<T>`, и `KeyedCollection<TKey,TItem>` вместо этого.  
  
### <a name="naming-custom-collections"></a>Именование пользовательских коллекций  
 Коллекции (типы, реализующие `IEnumerable`) создаются в основном по двум причинам: (1) чтобы создать новую структуру данных с помощью операций, зависящих от структуры и часто различаются по быстродействию чем существующие структуры данных (например, <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.LinkedList%601>, <xref:System.Collections.Generic.Stack%601>) и (2) для создания специализированных коллекции для Удерживая определенный набор элементов (например, <xref:System.Collections.Specialized.StringCollection>). Структуры данных чаще всего используются в внутренней реализации приложений и библиотек. Специализированные коллекции главным образом должны быть предоставлены в API (как свойства и типы параметров).  
  
 **✓ DO** используйте суффикс «Словарь» в именах реализации абстракций `IDictionary` или `IDictionary<TKey,TValue>`.  
  
 **✓ DO** используйте суффикс «Коллекция» в именах типы, реализующие `IEnumerable` (или один из его потомков) и представляет список элементов.  
  
 **✓ DO** использовать имя структуры соответствующие данные для пользовательских структур данных.  
  
 **X AVOID** использовать любые суффиксы, подразумевая конкретной реализации, такие как «LinkedList» или «Хэш-таблица», в именах абстракций коллекции.  
  
 **✓ CONSIDER** префикса имен коллекций с именем типа элемента. Например, коллекция хранения элементов типа `Address` (реализация `IEnumerable<Address>`) должен быть назван `AddressCollection`. Если тип является интерфейсом, «I» префикс элемента типа может быть опущен. Таким образом, коллекция <xref:System.IDisposable> элементов может вызываться `DisposableCollection`.  
  
 **✓ CONSIDER** с помощью префикса «ReadOnly» в именах коллекций только для чтения, если соответствующую ему коллекцию для записи могут быть добавлены или уже существует в структуре.  
  
 Например, должен быть вызван только для чтения коллекцию строк `ReadOnlyStringCollection`.  
  
 *Фрагменты: © Корпорация Майкрософт (Microsoft Corporation), 2005, 2009. Все права защищены.*  
  
 *Перепечатано разрешением Пирсона для образовательных учреждений, Inc. из [рекомендации по разработке Framework: Условные обозначения, стили и шаблоны для библиотеки .NET для повторного использования, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) Кшиштов Квалина и Брэд Абрамс, опубликованных 22 октября 2008 г., издательство Addison-Wesley Professional как части цикла разработки Microsoft Windows.*  
  
## <a name="see-also"></a>См. также

- [Рекомендации по проектированию на основе Framework](../../../docs/standard/design-guidelines/index.md)
- [Правила использования](../../../docs/standard/design-guidelines/usage-guidelines.md)
