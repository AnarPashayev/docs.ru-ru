---
title: Рекомендации по использованию коллекций
ms.date: 10/22/2008
ms.technology: dotnet-standard
ms.assetid: 297b8f1d-b11f-4dc6-960a-8e990817304e
ms.openlocfilehash: 231d8b04c11f19c4440e184533e1eeaded72b70b
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2020
ms.locfileid: "75709326"
---
# <a name="guidelines-for-collections"></a>Рекомендации по использованию коллекций
Любой тип, предназначенный специально для управления группой объектов с некоторыми общими характеристиками, может рассматриваться как коллекция. Он почти всегда подходит для таких типов, чтобы реализовать <xref:System.Collections.IEnumerable> или <xref:System.Collections.Generic.IEnumerable%601>, поэтому в этом разделе мы расскажем только о типах, реализующих один или оба этих интерфейса, которые должны быть коллекциями.  
  
 **X DO NOT** использования слабо типизированных коллекций в открытых интерфейсах API.  
  
 Тип всех возвращаемых значений и параметров, представляющих элементы коллекции, должен быть точным типом элемента, а не любым из его базовых типов (это относится только к открытым элементам коллекции).  
  
 **X DO NOT** использовать <xref:System.Collections.ArrayList> или <xref:System.Collections.Generic.List%601> в открытых интерфейсах API.  
  
 Эти типы представляют собой структуры данных, предназначенные для использования во внутренней реализации, а не в общедоступных API. `List<T>` оптимизирована для повышения производительности и энергопотребления за счет очистки интерфейсов API и гибкости. Например, если вы возвращаете `List<T>`, вы никогда не сможете получать уведомления, когда клиентский код изменяет коллекцию. Кроме того, `List<T>` предоставляет множество членов, таких как <xref:System.Collections.Generic.List%601.BinarySearch%2A>, которые не являются полезными или применимы во многих сценариях. В следующих двух разделах описываются типы (абстракции), специально предназначенные для использования в общедоступных API.  
  
 **X DO NOT** использовать `Hashtable` или `Dictionary<TKey,TValue>` в открытых интерфейсах API.  
  
 Эти типы представляют собой структуры данных, предназначенные для использования во внутренней реализации. Общедоступные API-интерфейсы должны использовать <xref:System.Collections.IDictionary>, `IDictionary <TKey, TValue>`или пользовательский тип, реализующий один или оба интерфейса.  
  
 **X DO NOT** использовать <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Collections.IEnumerator>, или любого другого типа, который реализует один из этих интерфейсов, за исключением того, как тип возвращаемого значения `GetEnumerator` метод.  
  
 Типы, возвращающие перечислители из методов, отличных от `GetEnumerator`, нельзя использовать с инструкцией `foreach`.  
  
 **X DO NOT** реализовывать `IEnumerator<T>` и `IEnumerable<T>` на тот же тип. То же относится и к неуниверсальным интерфейсам `IEnumerator` и `IEnumerable`.  
  
## <a name="collection-parameters"></a>Параметры коллекции  
 **✓ DO** использовать возможные специализированные наименее тип в качестве типа параметра. Большинство членов, принимающих коллекции в качестве параметров, используют интерфейс `IEnumerable<T>`.  
  
 **X AVOID** с помощью <xref:System.Collections.Generic.ICollection%601> или <xref:System.Collections.ICollection> как параметр только для доступа к `Count` свойство.  
  
 Вместо этого рекомендуется использовать `IEnumerable<T>` или `IEnumerable` и динамически проверять, реализует ли объект `ICollection<T>` или `ICollection`.  
  
## <a name="collection-properties-and-return-values"></a>Свойства коллекции и возвращаемые значения  
 **X DO NOT** предоставляют настраиваемые коллекции свойств.  
  
 Пользователи могут заменить содержимое коллекции, сначала очистив коллекцию, а затем добавив новое содержимое. Если замена всей коллекции является распространенным сценарием, попробуйте предоставить метод `AddRange` в коллекции.  
  
 **✓ DO** использовать `Collection<T>` или подкласс `Collection<T>` для свойства или возвращаемого значения представления коллекции для чтения и записи.  
  
 Если `Collection<T>` не соответствует какому-либо требованию (например, коллекция не должна реализовывать <xref:System.Collections.IList>), используйте пользовательскую коллекцию, реализуя `IEnumerable<T>`, `ICollection<T>`или <xref:System.Collections.Generic.IList%601>.  
  
 **✓ DO** использовать <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>, подкласс `ReadOnlyCollection<T>`, или, в редких случаях `IEnumerable<T>` для свойства или возвращаемого значения представления коллекции только для чтения.  
  
 В общем случае предпочтительнее `ReadOnlyCollection<T>`. Если он не соответствует какому-либо требованию (например, коллекция не должна реализовывать `IList`), используйте пользовательскую коллекцию, реализуя `IEnumerable<T>`, `ICollection<T>`или `IList<T>`. Если вы реализуете пользовательскую коллекцию, доступную только для чтения, реализуйте `ICollection<T>.IsReadOnly`, чтобы вернуть `true`.  
  
 Если вы уверены, что единственной ситуацией, которую вы хотите поддерживать, является однопроходная итерация, можно просто использовать `IEnumerable<T>`.  
  
 **✓ CONSIDER** с использованием подклассов универсальных коллекций базовый вместо использования коллекций.  
  
 Это позволяет улучшить имя и добавить вспомогательные элементы, отсутствующие в базовых типах коллекций. Это особенно применимо к интерфейсам API высокого уровня.  
  
 **✓ CONSIDER** возврат подкласс `Collection<T>` или `ReadOnlyCollection<T>` из очень часто используемые методы и свойства.  
  
 Это сделает возможным добавление вспомогательных методов или изменение реализации коллекции в будущем.  
  
 **✓ CONSIDER** с помощью является коллекцией с ключом, если элементы, хранящихся в коллекции имеют уникальные ключи (имена, идентификаторы и т. д.). Коллекции с ключом — это коллекции, которые могут индексироваться как целое число и как ключ, и обычно реализуются путем наследования от `KeyedCollection<TKey,TItem>`.  
  
 Коллекции с ключом обычно имеют больший объем памяти, и их не следует использовать, если издержки памяти привышают преимущества использования ключей.  
  
 **X DO NOT** возвращать значения null из свойства коллекции или методами, возвращающими коллекции. Вместо этого следует возвращать пустую коллекцию или пустой массив.  
  
 Общее правило состоит в том, что коллекции или массивы null и пустые (0 элементов) должны обрабатываться одинаково.  
  
### <a name="snapshots-versus-live-collections"></a>Моментальные снимки и динамические коллекции  
 Коллекции, представляющие состояние в определенный момент времени, называются коллекциями моментальных снимков. Например, коллекция, содержащая строки, возвращаемые запросом к базе данных, будет моментальным снимком. Коллекции, которые всегда представляют текущее состояние, называются активными коллекциями. Например, коллекция элементов `ComboBox` является динамической коллекцией.  
  
 **X DO NOT** возвращают коллекции моментального снимка из свойств. Свойства должны возвращать динамические коллекции.  
  
 Методы получения свойств должны быть очень простыми операциями. Для возврата моментального снимка необходимо создать копию внутренней коллекции в операции O (n).  
  
 **✓ DO** использовать моментальный снимок коллекции или активной `IEnumerable<T>` (или его подтипов) для представления коллекций, которые являются volatile (т. е., можно изменить без явного изменения коллекции).  
  
 Как правило, все коллекции, представляющие общий ресурс (например, файлы в каталоге), являются временными. Такие коллекции очень трудны или невозможно реализовать как динамические коллекции, если только реализация не является просто перечислителем.  
  
## <a name="choosing-between-arrays-and-collections"></a>Выбор между массивами и коллекциями  
 **✓ DO** предпочтение коллекций и массивы.  
  
 Коллекции обеспечивают больший контроль над содержимым, могут развиваться со временем и более пригодны для использования. Кроме того, использование массивов для сценариев только для чтения не рекомендуется, поскольку затраты на клонирование массива являются недопустимыми. В исследованиях удобства использования было показано, что некоторым разработчикам удобнее пользоваться API-интерфейсами на основе коллекций.  
  
 Однако при разработке низкоуровневых интерфейсов API может быть лучше использовать массивы для сценариев чтения и записи. Массивы имеют меньший объем памяти, что позволяет сократить рабочий набор, а доступ к элементам массива выполняется быстрее, поскольку он оптимизирован средой выполнения.  
  
 **✓ CONSIDER** использование массивов в API нижнего уровня к минимуму потребление памяти и повышения производительности.  
  
 **✓ DO** использовать байтовые массивы вместо коллекции байтов.  
  
 **X DO NOT** используйте массивы для свойств, если свойство будет иметь для возврата нового массива (например, копия внутреннего массива) каждый раз, вызывается метод считывания свойства.  
  
## <a name="implementing-custom-collections"></a>Реализация пользовательских коллекций  
 **✓ CONSIDER** наследование от `Collection<T>`, `ReadOnlyCollection<T>`, или `KeyedCollection<TKey,TItem>` при разработке новых семейств сайтов.  
  
 **✓ DO** реализации `IEnumerable<T>` при разработке новых семейств сайтов. Рассмотрите возможность реализации `ICollection<T>` или даже `IList<T>` там, где это имеет смысл.  
  
 При реализации такой пользовательской коллекции следует использовать шаблон API, установленный `Collection<T>` и `ReadOnlyCollection<T>` как можно точнее. То есть явно реализуйте одни и те же члены, назовите такие параметры, как имена этих двух коллекций, и т. д.  
  
 **✓ CONSIDER** реализация интерфейсов неуниверсальных коллекций (`IList` и `ICollection`) если коллекции часто передается в API-интерфейсы используя эти интерфейсы в качестве входных данных.  
  
 **X AVOID** реализация интерфейсов коллекций в типах сложных API-интерфейсами, не относящуюся к концепцию коллекции.  
  
 **X DO NOT** наследовать от неуниверсальных коллекций базовый, такие как `CollectionBase`. Используйте вместо них типы данных `Collection<T>`, `ReadOnlyCollection<T>` и `KeyedCollection<TKey,TItem>`.  
  
### <a name="naming-custom-collections"></a>Именование пользовательских коллекций  
 Коллекции (типы, реализующие `IEnumerable`) создаются главным образом по двум причинам: (1) для создания новой структуры данных с операциями, зависящими от структуры, и часто отличающимися характеристиками производительности, чем существующие структуры данных (например, <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.LinkedList%601>, <xref:System.Collections.Generic.Stack%601>) и (2) для создания специализированной коллекции для хранения определенного набора элементов (например, <xref:System.Collections.Specialized.StringCollection>). Структуры данных чаще всего используются во внутренней реализации приложений и библиотек. Специализированные коллекции, главным образом, должны предоставляться в API-интерфейсах (как типы свойств и параметров).  
  
 **✓ DO** используйте суффикс «Словарь» в именах реализации абстракций `IDictionary` или `IDictionary<TKey,TValue>`.  
  
 **✓ DO** используйте суффикс «Коллекция» в именах типы, реализующие `IEnumerable` (или один из его потомков) и представляет список элементов.  
  
 **✓ DO** использовать имя структуры соответствующие данные для пользовательских структур данных.  
  
 **X AVOID** использовать любые суффиксы, подразумевая конкретной реализации, такие как «LinkedList» или «Хэш-таблица», в именах абстракций коллекции.  
  
 **✓ CONSIDER** префикса имен коллекций с именем типа элемента. Например, коллекция, в которой хранятся элементы типа `Address` (реализация `IEnumerable<Address>`), должна иметь имя `AddressCollection`. Если тип элемента является интерфейсом, то префикс "I" типа элемента можно опустить. Таким же набор элементов <xref:System.IDisposable> можно вызывать `DisposableCollection`.  
  
 **✓ CONSIDER** с помощью префикса «ReadOnly» в именах коллекций только для чтения, если соответствующую ему коллекцию для записи могут быть добавлены или уже существует в структуре.  
  
 Например, доступная только для чтения коллекция строк должна вызываться `ReadOnlyStringCollection`.  
  
 *Части © 2005, 2009 Корпорация Майкрософт. Все права защищены.*  
  
 *Перепечатано с разрешения Pearson Education, Inc. из книги [Инфраструктура программных проектов. Соглашения, идиомы и шаблоны для многократно используемых библиотек .NET (2-е издание)](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619), авторы: Кржиштоф Цвалина (Krzysztof Cwalina) и Брэд Абрамс (Brad Abrams). Книга опубликована 22 октября 2008 г. издательством Addison-Wesley Professional в рамках серии, посвященной разработке для Microsoft Windows.*  
  
## <a name="see-also"></a>См. также:

- [Рекомендации по проектированию на основе Framework](../../../docs/standard/design-guidelines/index.md)
- [Правила использования](../../../docs/standard/design-guidelines/usage-guidelines.md)
