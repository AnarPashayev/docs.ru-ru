---
title: Разработка интерфейса
ms.date: 10/22/2008
helpviewer_keywords:
- interfaces [.NET Framework], design guidelines
- type design guidelines, interfaces
- class library design guidelines [.NET Framework], interfaces
ms.assetid: a016bd18-6710-4358-9438-9f190a295392
ms.openlocfilehash: 9f8ff38d5825091d4d5d3716ed6025a8d04c592d
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/18/2020
ms.locfileid: "94821012"
---
# <a name="interface-design"></a>Разработка интерфейса
Хотя большинство API-интерфейсов лучше моделировать с помощью классов и структур, существуют случаи, когда интерфейсы более подходят или являются единственным вариантом.

 Среда CLR не поддерживает множественное наследование (т. е. классы CLR не могут наследовать более чем от одного базового класса), но позволяют типам реализовать один или несколько интерфейсов в дополнение к наследованию от базового класса. Поэтому интерфейсы часто используются для достижения результата множественного наследования. Например, <xref:System.IDisposable> является интерфейсом, который позволяет типам поддерживать возможность уничтожения независимо от любых других иерархий наследования, в которых они хотят участвовать.

 Другая ситуация, при которой необходимо определить интерфейс, заключается в создании общего интерфейса, который может поддерживаться несколькими типами, включая некоторые типы значений. Типы значений не могут наследовать от типов, отличных от <xref:System.ValueType> , но они могут реализовывать интерфейсы, поэтому использование интерфейса является единственным вариантом для предоставления общего базового типа.

 ✔️ определить интерфейс, если требуется поддержка некоторых общих API-интерфейсов набором типов, включающим типы значений.

 ✔️ РЕКОМЕНДУЕТСЯ определять интерфейс, если требуется поддержка его функциональности для типов, которые уже наследуются от другого типа.

 ❌ Избегайте использования интерфейсов маркера (интерфейсы без элементов).

 Если необходимо пометить класс как имеющий определенную характеристику (маркер), как правило, используйте настраиваемый атрибут, а не интерфейс.

 ✔️ предоставить по крайней мере один тип, который является реализацией интерфейса.

 Это помогает проверить структуру интерфейса. Например, <xref:System.Collections.Generic.List%601> является реализацией <xref:System.Collections.Generic.IList%601> интерфейса.

 ✔️ предоставить по крайней мере один API, который использует каждый определяемый интерфейс (метод, принимающий интерфейс в качестве параметра или свойства, типизированного как интерфейс).

 Это помогает проверить структуру интерфейса. Например, <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> использует <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> интерфейс.

 ❌ НЕ добавляйте члены к интерфейсу, который был отгружен ранее.

 Это приведет к нарушению реализации интерфейса. Чтобы избежать проблем с управлением версиями, необходимо создать новый интерфейс.

 За исключением ситуаций, описанных в этих рекомендациях, следует в общем случае выбирать классы вместо интерфейсов при проектировании библиотек с многократным использованием управляемого кода.

 *Части © 2005, 2009 Корпорация Майкрософт. Все права защищены.*

 *Перепечатано с разрешения Pearson Education, Inc. из книги [Инфраструктура программных проектов. Соглашения, идиомы и шаблоны для многократно используемых библиотек .NET (2-е издание)](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619), авторы: Кржиштоф Цвалина (Krzysztof Cwalina) и Брэд Абрамс (Brad Abrams). Книга опубликована 22 октября 2008 г. издательством Addison-Wesley Professional в рамках серии, посвященной разработке для Microsoft Windows.*

## <a name="see-also"></a>См. также статью

- [Рекомендации по проектированию типов](type.md)
- [Рекомендации по проектированию платформы](index.md)
