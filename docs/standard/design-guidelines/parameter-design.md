---
title: Разработка параметров
ms.date: 10/22/2008
helpviewer_keywords:
- member design guidelines [.NET Framework], parameters
- members [.NET Framework], parameters
- names [.NET Framework], parameters
- parameters, design guidelines
- reserved parameters
ms.assetid: 3f33bf46-4a7b-43b3-bb78-1ffebe0dcfa6
ms.openlocfilehash: 815075198f34c0c045603b9d377b9d5fbdf1a91d
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/24/2020
ms.locfileid: "95707884"
---
# <a name="parameter-design"></a>Разработка параметров

В этом разделе приводятся общие рекомендации по проектированию параметров, включая разделы с рекомендациями по проверке аргументов. Кроме того, следует ознакомиться с рекомендациями, описанными в разделе [параметры именования](naming-parameters.md).

 ✔️ использовать тип наименее производного параметра, который предоставляет функциональные возможности, необходимые для элемента.

 Например, предположим, что требуется разработать метод, который перечисляет коллекцию и выводит каждый элемент на консоль. Такой метод должен принимать в <xref:System.Collections.IEnumerable> качестве параметра, а не <xref:System.Collections.ArrayList> или <xref:System.Collections.IList> , например.

 ❌ НЕ используйте зарезервированные параметры.

 Если в какой-либо будущей версии требуется больше входных данных для члена, можно добавить новую перегрузку.

 ❌ НЕ имеют общедоступных методов, которые принимают указатели, массивы указателей или многомерные массивы в качестве параметров.

 Указатели и многомерные массивы относительно сложно правильно использовать. В большинстве случаев можно перерабатывать API, чтобы избежать использования этих типов в качестве параметров.

 ✔️ поместить все `out` параметры после всех параметров по значению и `ref` (за исключением массивов параметров), даже если это приводит к несогласованности в порядке параметров между перегрузками (см. раздел [перегрузка членов](member-overloading.md)).

 `out`Параметры можно рассматривать как дополнительные возвращаемые значения, и группирование их вместе делает сигнатуру метода проще для понимания.

 ✔️ быть единообразными в параметрах именования при переопределении членов или реализации членов интерфейса.

 Это улучшает связь между методами.

### <a name="choosing-between-enum-and-boolean-parameters"></a>Выбор между перечислением и логическими параметрами  

 ✔️ использовать перечисления, если элемент в противном случае будет иметь два или более логических параметра.

 ❌ НЕ используйте логические значения, если нет уверенности в том, что больше не будет необходимости более двух значений.

 Перечисления предоставляют некоторое место для добавления значений в будущем, но следует помнить о всех последствиях добавления значений к перечислениям, которые описаны в статье о [структуре перечисления](enum.md).

 ✔️ Рассмотрите возможность использования логических значений для параметров конструктора, которые действительно являются двумя состояниями, и просто используются для инициализации логических свойств.

### <a name="validating-arguments"></a>Проверка аргументов

 ✔️ проверить аргументы, передаваемые в открытые, защищенные или явно реализованные члены. <xref:System.ArgumentException?displayProperty=nameWithType>Если проверка завершается неудачно, вызовите или один из его подклассов.

 Обратите внимание, что фактическая проверка не обязательно должна выполняться в самом открытом или защищенном члене. Это может произойти на более низком уровне в некоторых частных или внутренних подпрограммых. Главным моментом является то, что вся контактная зона, предоставляемая конечным пользователям, проверяет аргументы.

 ✔️ выдавать исключение, <xref:System.ArgumentNullException> Если аргумент NULL передается и член не поддерживает аргументы null.

 ✔️ проверить параметры перечисления.

 Не представим, что аргументы перечисления будут находиться в диапазоне, определенном перечислением. Среда CLR позволяет приведение любого целочисленного значения к значению перечисления, даже если оно не определено в перечислении.

 ❌ НЕ используйте <xref:System.Enum.IsDefined%2A?displayProperty=nameWithType> для проверок диапазона Enum.

 ✔️ Имейте в виду, что изменяемые аргументы могли измениться после проверки.

 Если элемент защищен с учетом безопасности, рекомендуется создать копию, а затем проверить и обработать аргумент.

### <a name="parameter-passing"></a>Передача параметров

 С точки зрения конструктора инфраструктуры существует три основные группы параметров: по значению, параметры `ref` и `out` Параметры.

 Когда аргумент передается через параметр по значению, член получает копию фактического аргумента, переданного в. Если аргумент является типом значения, в стек помещается копия аргумента. Если аргумент является ссылочным типом, в стек помещается копия ссылки. Наиболее популярные языки CLR, такие как C#, VB.NET и C++, по умолчанию передают параметры по значению.

 При передаче аргумента через `ref` параметр член получает ссылку на фактический аргумент, переданный в. Если аргумент является типом значения, в стек помещается ссылка на аргумент. Если аргумент является ссылочным типом, ссылка на ссылку помещается в стек. `Ref` параметры можно использовать, чтобы разрешить члену изменять аргументы, передаваемые вызывающим объектом.

 `Out` параметры похожи на `ref` параметры с некоторыми небольшими различиями. Параметр изначально считается неназначенным и не может быть прочитан в теле элемента до того, как ему будет присвоено какое-либо значение. Кроме того, параметру необходимо назначить некоторое значение перед возвратом члена.

 ❌ Избегайте использования `out` `ref` параметров или.

 `out`Для использования `ref` параметров или требуются возможности работы с указателями, понимание того, как типы значений и ссылочные типы различаются, и обрабатывает методы с несколькими возвращаемыми значениями. Кроме того, различие между `out` `ref` параметрами и не является широко понятным. Архитекторы платформ, разрабатываемые для общей аудитории, не должны ждать, чтобы пользователи работали с главными рабочими средами `out` или `ref` параметрами.

 ❌ НЕ передавайте ссылочные типы по ссылке.

 Существует несколько ограниченных исключений правила, например метод, который может использоваться для замены ссылок.

### <a name="members-with-variable-number-of-parameters"></a>Члены с переменным числом параметров

 Члены, которые могут принимать переменное число аргументов, выражаются путем предоставления параметра массива. Например, <xref:System.String> предоставляет следующий метод:

```csharp
public class String {
    public static string Format(string format, object[] parameters);
}
```

 Затем пользователь может вызвать <xref:System.String.Format%2A?displayProperty=nameWithType> метод следующим образом:

 `String.Format("File {0} not found in {1}",new object[]{filename,directory});`

 Добавление ключевого слова C# params в параметр массива приводит к изменению параметра на так называемый параметр массива params и предоставляет ярлык для создания временного массива.

```csharp
public class String {
    public static string Format(string format, params object[] parameters);
}
```

 Это позволяет пользователю вызывать метод, передавая элементы массива непосредственно в списке аргументов.

 `String.Format("File {0} not found in {1}",filename,directory);`

 Обратите внимание, что ключевое слово params можно добавить только к последнему параметру в списке параметров.

 ✔️ РЕКОМЕНДУЕТСЯ добавить ключевое слово params к параметрам массива, если предполагается, что конечные пользователи будут передавать массивы с небольшим числом элементов. Если предполагается, что множество элементов будет передаваться в типичных сценариях, пользователи, вероятно, не будут передавать эти элементы в любом случае, поэтому ключевое слово params не требуется.

 ❌ Старайтесь не использовать массивы params, если у вызывающего объекта почти всегда есть входные данные, которые уже находятся в массиве.

 Например, члены с параметрами массива байтов почти никогда не вызываются путем передачи отдельных байтов. По этой причине параметры массива байтов в .NET Framework не используют ключевое слово params.

 ❌ НЕ используйте массивы params, если массив изменяется членом, принимающим параметр массива params.

 Из-за того, что многие компиляторы переключают аргументы в временный массив в месте вызова, массив может быть временным объектом, поэтому любые изменения массива будут потеряны.

 ✔️ Рассмотрите возможность использования ключевого слова params в простой перегрузке, даже если более сложная перегрузка не может его использовать.

 Задайте себе, если бы пользователь мог бы получить значение массива params в одной перегрузке, даже если это не было во всех перегрузках.

 ✔️ Попытайтесь Упорядочить параметры, чтобы можно было использовать ключевое слово params.

 ✔️ Рассмотрите возможность предоставления специальных перегрузок и путей кода для вызовов с небольшим количеством аргументов в чрезвычайно чувствительных к производительности API.

 Это позволяет избежать создания объектов Array при вызове API с небольшим числом аргументов. Произведение имен параметров путем создания единственного значения параметра массива и добавления числового суффикса.

 Это следует делать только в том случае, если вы собираетесь использовать весь путь к коду, а не просто создаете массив и вызываете более общий метод.

 ✔️ Помните, что значение NULL можно передать как аргумент массива params.

 Перед обработкой необходимо проверить, что массив не равен null.

 ❌ НЕ используйте `varargs` методы, в противном случае называемые многоточием.

 Некоторые языки CLR, такие как C++, поддерживают альтернативное соглашение для передачи списков параметров переменных, называемых `varargs` методами. Это соглашение не должно использоваться в платформах, поскольку оно несовместимо с CLS.

### <a name="pointer-parameters"></a>Параметры указателя

 Как правило, указатели не должны отображаться в общедоступной контактной зоне хорошо спроектированной инфраструктуры управляемого кода. В большинстве случаев указатели должны быть инкапсулированы. Однако в некоторых случаях указатели необходимы для обеспечения взаимодействия, и использование указателей в таких случаях уместно.

 ✔️ предоставить альтернативу любому элементу, принимающему аргумент-указатель, поскольку указатели не являются CLS-совместимыми.

 ❌ Старайтесь не выполнять дорогостоящую проверку аргументов для аргументов указателя.

 При проектировании элементов с указателями ✔️ следовать общим соглашениям, связанным с указателем.

 Например, нет необходимости передавать начальный индекс, так как для достижения того же результата можно использовать простые арифметические операции с указателями.

 *Части &copy; 2005, 2009 Корпорация Майкрософт. Все права защищены.*

 *Перепечатано с разрешения Pearson Education, Inc. из книги [Инфраструктура программных проектов. Соглашения, идиомы и шаблоны для многократно используемых библиотек .NET (2-е издание)](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619), авторы: Кржиштоф Цвалина (Krzysztof Cwalina) и Брэд Абрамс (Brad Abrams). Книга опубликована 22 октября 2008 г. издательством Addison-Wesley Professional в рамках серии, посвященной разработке для Microsoft Windows.*

## <a name="see-also"></a>См. также раздел

- [Рекомендации по проектированию членов](member.md)
- [Рекомендации по проектированию платформы](index.md)
