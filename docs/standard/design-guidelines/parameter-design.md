---
title: Разработка параметров
ms.date: 10/22/2008
ms.technology: dotnet-standard
helpviewer_keywords:
- member design guidelines [.NET Framework], parameters
- members [.NET Framework], parameters
- names [.NET Framework], parameters
- parameters, design guidelines
- reserved parameters
ms.assetid: 3f33bf46-4a7b-43b3-bb78-1ffebe0dcfa6
author: KrzysztofCwalina
ms.openlocfilehash: 93554594b49b742a6a5e8461b6b16046701ec07c
ms.sourcegitcommit: 30a558d23e3ac5a52071121a52c305c85fe15726
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/25/2019
ms.locfileid: "75347853"
---
# <a name="parameter-design"></a>Конструктор параметров

В этом разделе приводятся общие рекомендации по проектированию параметров, включая разделы с рекомендациями по проверке аргументов. Кроме того, следует ознакомиться с рекомендациями, описанными в разделе [параметры именования](../../../docs/standard/design-guidelines/naming-parameters.md).  
  
 **✓ DO** использовать бы производный тип параметра, который предоставляет функциональные возможности, необходимые для элемента.  
  
 Например, предположим, что требуется разработать метод, который перечисляет коллекцию и выводит каждый элемент на консоль. Такой метод должен принимать <xref:System.Collections.IEnumerable> в качестве параметра, а не <xref:System.Collections.ArrayList> или <xref:System.Collections.IList>, например.  
  
 **X DO NOT** использовать зарезервированные параметры.  
  
 Если в какой-либо будущей версии требуется больше входных данных для члена, можно добавить новую перегрузку.  
  
 **X DO NOT** открытым методы, принимающие указатели, массивы указателей или многомерных массивов в качестве параметров.  
  
 Указатели и многомерные массивы относительно сложно правильно использовать. В большинстве случаев можно перерабатывать API, чтобы избежать использования этих типов в качестве параметров.  
  
 **✓ DO** поместите все `out` параметров после всех по значению и `ref` параметров (за исключением массивы параметров), даже если это приводит к несогласованность параметров перегрузки в (см. [члена Перегрузка](../../../docs/standard/design-guidelines/member-overloading.md)).  
  
 Параметры `out` могут рассматриваться как дополнительные возвращаемые значения, и их группирование позволяет проще понять сигнатуру метода.  
  
 **✓ DO** быть согласованы в именовании параметров при перегрузке членов или реализации интерфейсов.  
  
 Это улучшает связь между методами.  
  
### <a name="choose-between-enum-and-boolean-parameters"></a>Выбор между перечислением и логическими параметрами  
 **✓ DO** использовать перечисления, если член будет иметь два или более логических параметров.  
  
 **X DO NOT** используйте логические значения, пока не будет точно знать, никогда не возникнет необходимость использования более двух значений.  
  
 Перечисления предоставляют некоторое место для добавления значений в будущем, но следует помнить о всех последствиях добавления значений к перечислениям, которые описаны в статье о [структуре перечисления](../../../docs/standard/design-guidelines/enum.md).  
  
 **✓ CONSIDER** с помощью логических значений для параметров конструктора, действительно два значения состояния и используются исключительно для инициализации свойства типа Boolean.  
  
### <a name="validate-arguments"></a>Проверить аргументы  
 **✓ DO** проверить аргументы, передаваемые открытый, защищенный или явно реализованный членов. Вызовите <xref:System.ArgumentException?displayProperty=nameWithType>или один из его подклассов, если проверка завершается неудачно.  
  
 Обратите внимание, что фактическая проверка не обязательно должна выполняться в самом открытом или защищенном члене. Это может произойти на более низком уровне в некоторых частных или внутренних подпрограммых. Главным моментом является то, что вся контактная зона, предоставляемая конечным пользователям, проверяет аргументы.  
  
 **✓ DO** throw <xref:System.ArgumentNullException> Если передается аргумент null и элемент не поддерживает аргументы null.  
  
 **✓ DO** проверки для параметров перечислений.  
  
 Не представим, что аргументы перечисления будут находиться в диапазоне, определенном перечислением. Среда CLR позволяет приведение любого целочисленного значения к значению перечисления, даже если оно не определено в перечислении.  
  
 **X DO NOT** использовать <xref:System.Enum.IsDefined%2A?displayProperty=nameWithType> диапазона перечисления проверяет.  
  
 **✓ DO** Имейте в виду, что изменяемые аргументы могут были изменены после они были проверены.  
  
 Если элемент защищен с учетом безопасности, рекомендуется создать копию, а затем проверить и обработать аргумент.  
  
### <a name="pass-parameters"></a>Передача параметров  
 С точки зрения конструктора инфраструктуры существуют три основные группы параметров: параметры по значению, параметры `ref` и параметры `out`.  
  
 Когда аргумент передается через параметр по значению, член получает копию фактического аргумента, переданного в. Если аргумент является типом значения, в стек помещается копия аргумента. Если аргумент является ссылочным типом, в стек помещается копия ссылки. Наиболее популярные языки CLR, такие как C#, Visual Basic и C++, по умолчанию передают параметры по значению.  
  
 Когда аргумент передается через параметр `ref`, член получает ссылку на фактический аргумент, переданный в. Если аргумент является типом значения, в стек помещается ссылка на аргумент. Если аргумент является ссылочным типом, ссылка на ссылку помещается в стек. `Ref` параметры можно использовать, чтобы разрешить члену изменять аргументы, передаваемые вызывающим объектом.  
  
 Параметры `Out` похожи на параметры `ref` и некоторые небольшие различия. Параметр изначально считается неназначенным и не может быть прочитан в теле элемента до того, как ему будет присвоено какое-либо значение. Кроме того, параметру необходимо назначить некоторое значение перед возвратом члена.  
  
 **X AVOID** с помощью `out` или `ref` параметров.  
  
 Для использования параметров `out` или `ref` требуется взаимодействие с указателями, понимание того, как типы значений и ссылочные типы различаются, и обрабатывает методы с несколькими возвращаемыми значениями. Кроме того, различие между параметрами `out` и `ref` не является широко понятным. Архитекторы платформ, разрабатываемые для общей аудитории, не должны ждать, чтобы пользователи работали с `out` или `ref` параметрами.  
  
 **X DO NOT** передачи ссылочных типов по ссылке.  
  
 Существует несколько ограниченных исключений правила, например метод, который может использоваться для замены ссылок.  
  
### <a name="members-with-variable-number-of-parameters"></a>Члены с переменным числом параметров  
 Члены, которые могут принимать переменное число аргументов, выражаются путем предоставления параметра массива. Например, <xref:System.String> предоставляет следующий метод:  
  
```csharp  
public class String {  
    public static string Format(string format, object[] parameters);  
}  
```  
  
 Затем пользователь может вызвать метод <xref:System.String.Format%2A?displayProperty=nameWithType> следующим образом:  
  
 `String.Format("File {0} not found in {1}",new object[]{filename,directory});`  
  
 Добавление ключевого слова C# params в параметр массива приводит к изменению параметра на так называемый параметр массива params и предоставляет ярлык для создания временного массива.  
  
```csharp  
public class String {  
    public static string Format(string format, params object[] parameters);  
}  
```  
  
 Это позволяет пользователю вызывать метод, передавая элементы массива непосредственно в списке аргументов.  
  
 `String.Format("File {0} not found in {1}",filename,directory);`  
  
 Обратите внимание, что ключевое слово params можно добавить только к последнему параметру в списке параметров.  
  
 **✓ CONSIDER** Добавление ключевого слова params параметров массива, если ожидается, что конечных пользователей для передачи массивов с небольшим числом элементов. Если предполагается, что множество элементов будет передаваться в типичных сценариях, пользователи, вероятно, не будут передавать эти элементы в любом случае, поэтому ключевое слово params не требуется.  
  
 **X AVOID** использование массивов params в том случае, если вызывающий объект будет почти всегда уже входные данные в виде массива.  
  
 Например, члены с параметрами массива байтов почти никогда не вызываются путем передачи отдельных байтов. По этой причине параметры массива байтов в .NET Framework не используют ключевое слово params.  
  
 **X DO NOT** используйте массивы params, если массив изменен членом, принимающим параметр params массива.  
  
 Из-за того, что многие компиляторы переключают аргументы в временный массив в месте вызова, массив может быть временным объектом, поэтому любые изменения массива будут потеряны.  
  
 **✓ CONSIDER** с помощью ключевого слова params в простой перегрузке, даже если более сложная перегрузка не может использовать его.  
  
 Задайте себе, если бы пользователь мог бы получить значение массива params в одной перегрузке, даже если это не было во всех перегрузках.  
  
 **✓ DO** попытайтесь Упорядочить параметры, чтобы сделать возможным использование ключевого слова params.  
  
 **✓ CONSIDER** предусматривать особые перегрузки и ветви кода для вызовов с небольшим числом аргументов в API-интерфейсы важна высокая производительность.  
  
 Это позволяет избежать создания объектов Array при вызове API с небольшим числом аргументов. Произведение имен параметров путем создания единственного значения параметра массива и добавления числового суффикса.  
  
 Это следует делать только в том случае, если вы собираетесь использовать весь путь к коду, а не просто создаете массив и вызываете более общий метод.  
  
 **✓ DO** Имейте в виду, null может быть передан в качестве аргумента массива params.  
  
 Перед обработкой необходимо проверить, что массив не равен null.  
  
 **X DO NOT** использовать `varargs` методы, также известный как кнопку с многоточием.  
  
 Некоторые языки CLR, такие как C++, поддерживают альтернативное соглашение для передачи списков параметров переменных, именуемых `varargs` методами. Это соглашение не должно использоваться в платформах, поскольку оно несовместимо с CLS.  
  
### <a name="pointer-parameters"></a>Параметры указателя  
 Как правило, указатели не должны отображаться в общедоступной контактной зоне хорошо спроектированной инфраструктуры управляемого кода. В большинстве случаев указатели должны быть инкапсулированы. Однако в некоторых случаях указатели необходимы для обеспечения взаимодействия, и использование указателей в таких случаях уместно.  
  
 **✓ DO** предоставляют альтернативный для любого элемента, который принимает указатель в качестве аргумента, так как указатели не являются CLS-совместимыми.  
  
 **X AVOID** затратного контроля аргументов указатель аргументов.  
  
 **✓ DO** соглашениям общих указателей при разработке члены с указателями.  
  
 Например, нет необходимости передавать начальный индекс, так как для достижения того же результата можно использовать простые арифметические операции с указателями.  
  
 *Части © 2005, 2009 Корпорация Майкрософт. Все права защищены.*  
  
 *Перепечатано с разрешения Pearson Education, Inc. из книги [Инфраструктура программных проектов. Соглашения, идиомы и шаблоны для многократно используемых библиотек .NET (2-е издание)](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619), авторы: Кржиштоф Цвалина (Krzysztof Cwalina) и Брэд Абрамс (Brad Abrams). Книга опубликована 22 октября 2008 г. издательством Addison-Wesley Professional в рамках серии, посвященной разработке для Microsoft Windows.*  
  
## <a name="see-also"></a>См. также:

- [Правила разработки членов](../../../docs/standard/design-guidelines/member.md)
- [Рекомендации по проектированию на основе Framework](../../../docs/standard/design-guidelines/index.md)
