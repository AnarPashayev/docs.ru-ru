---
title: Разработка свойств
ms.date: 10/22/2008
helpviewer_keywords:
- member design guidelines, properties
- properties [.NET Framework], design guidelines
ms.assetid: 127cbc0c-cbed-48fd-9c89-7c5d4f98f163
ms.openlocfilehash: ed287b98c012622caa5f8f1cc90fced90dda3e62
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/24/2020
ms.locfileid: "95730972"
---
# <a name="property-design"></a>Разработка свойств

Хотя свойства технически похожи на методы, они сильно отличаются в плане их сценариев использования. Они должны отображаться как интеллектуальные поля. Они имеют синтаксис для вызова полей и гибкость методов.

 ✔️ создать свойства только для получения, если вызывающий объект не может изменить значение свойства.

 Помните, что если тип свойства является изменяемым ссылочным типом, значение свойства можно изменить, даже если это свойство доступно только для получения.

 ❌ НЕ следует предоставлять свойства или свойства только для установки с методом задания, имеющим более широкие возможности доступа, чем метод получения.

 Например, не используйте свойства с открытым методом задания и защищенным методом считывания.

 Если метод получения свойства не может быть предоставлен, реализуйте в качестве метода функцию. Рассмотрите возможность запуска имени метода с помощью `Set` и следуйте указаниям, с которыми вы настроили свойство. Например, <xref:System.AppDomain> имеет метод, вызываемый `SetCachePath` вместо наличия свойства только для установки с именем `CachePath` .

 ✔️ предоставляют разумные значения по умолчанию для всех свойств, гарантируя, что значения по умолчанию не приводят к появлению бреши в системе безопасности или неэффективному коду.

 ✔️ разрешить задавать свойства в любом порядке, даже если это приводит к временному недопустимому состоянию объекта.

 Обычно два или более свойства взаимосвязаны с точкой, в которой некоторые значения одного свойства могут быть недопустимыми с учетом значений других свойств одного и того же объекта. В таких случаях исключения, являющиеся результатом недопустимого состояния, должны быть отложены до тех пор, пока взаимосвязанные свойства фактически не будут использоваться объектом вместе.

 ✔️ сохранить предыдущее значение, если метод задания свойства создает исключение.

 ❌ Избегайте вызова исключений из методов получения свойств.

 Методы получения свойств должны быть простыми операциями и не должны иметь никаких предусловий. Если метод получения может вызвать исключение, то, возможно, он будет переработано, чтобы быть методом. Обратите внимание, что это правило не применяется к индексаторам, в которых мы предполагаем исключения в результате проверки аргументов.

### <a name="indexed-property-design"></a>Разработка индексированных свойств

 Индексированное свойство — это специальное свойство, которое может иметь параметры и может вызываться с помощью специального синтаксиса, аналогичного индексированию массива.

 Индексированные свойства обычно называются индексаторами. Индексаторы следует использовать только в интерфейсах API, которые предоставляют доступ к элементам в логической коллекции. Например, строка представляет собой набор символов, а индексатор в <xref:System.String?displayProperty=nameWithType> был добавлен для доступа к его символам.

 ✔️ Рассмотрите возможность использования индексаторов для предоставления доступа к данным, хранящимся во внутреннем массиве.

 ✔️ Рассмотрите возможность предоставления индексаторов для типов, представляющих коллекции элементов.

 ❌ Старайтесь не использовать индексированные свойства более чем с одним параметром.

 Если для проектирования требуется несколько параметров, следует подумать, действительно ли свойство представляет метод доступа к логической коллекции. Если это не так, используйте вместо них методы. Рекомендуется начинать имя метода с помощью `Get` или `Set` .

 ❌ Не используйте индексаторы с типами параметров, отличными от <xref:System.Int32?displayProperty=nameWithType> ,, <xref:System.Int64?displayProperty=nameWithType> <xref:System.String?displayProperty=nameWithType> , <xref:System.Object?displayProperty=nameWithType> или перечисления.

 Если для разработки требуются другие типы параметров, настоятельно повторно оцените, действительно ли API представляет метод доступа к логической коллекции. В противном случае используйте метод. Рекомендуется начинать имя метода с помощью `Get` или `Set` .

 ✔️ использовать имя `Item` для индексированных свойств, если нет очевидного лучшего имени (например, см. <xref:System.String.Chars%2A> свойство в `System.String` ).

 В C# индексаторы по умолчанию имеют именованный элемент. <xref:System.Runtime.CompilerServices.IndexerNameAttribute>Можно использовать для настройки этого имени.

 ❌ НЕ следует предоставлять и индексатор, и методы, которые являются семантически эквивалентными.

 ❌ НЕ следует предоставлять более одного семейства перегруженных индексаторов в одном типе.

 Это обеспечивается компилятором C#.

 ❌ НЕ используйте нестандартные индексированные свойства.

 Это обеспечивается компилятором C#.

### <a name="property-change-notification-events"></a>События уведомления об изменении свойств

 Иногда бывает полезно указать событие, уведомляющее пользователя об изменениях в значении свойства. Например, `System.Windows.Forms.Control` вызывает `TextChanged` событие после изменения значения его `Text` Свойства.

 ✔️ Рассмотрите возможность вызова событий уведомлений об изменениях при изменении значений свойств в интерфейсах API высокого уровня (обычно в компонентах конструктора).

 Если есть хороший сценарий, при котором пользователю известно, когда изменяется свойство объекта, объект должен создать событие уведомления об изменении для свойства.

 Однако вряд ли стоит тратить издержки на создание таких событий для низкоуровневых API, таких как базовые типы или коллекции. Например, <xref:System.Collections.Generic.List%601> не может вызывать такие события при добавлении нового элемента в список и `Count` изменении свойства.

 ✔️ Рассмотрите возможность создания событий уведомления об изменениях, когда значение свойства изменяется через внешние силы.

 Если значение свойства изменяется с помощью некоторой внешней силы (не путем вызова методов объекта), события вызываются разработчиком, что значение изменяется и изменилось. Хорошим примером является `Text` свойство элемента управления "текстовое поле". Когда пользователь вводит текст в `TextBox` , значение свойства изменяется автоматически.

 *Части © 2005, 2009 Корпорация Майкрософт. Все права защищены.*

 *Перепечатано с разрешения Pearson Education, Inc. из книги [Инфраструктура программных проектов. Соглашения, идиомы и шаблоны для многократно используемых библиотек .NET (2-е издание)](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619), авторы: Кржиштоф Цвалина (Krzysztof Cwalina) и Брэд Абрамс (Brad Abrams). Книга опубликована 22 октября 2008 г. издательством Addison-Wesley Professional в рамках серии, посвященной разработке для Microsoft Windows.*

## <a name="see-also"></a>См. также раздел

- [Рекомендации по проектированию членов](member.md)
- [Рекомендации по проектированию платформы](index.md)
