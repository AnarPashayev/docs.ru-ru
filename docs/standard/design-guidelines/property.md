---
title: Разработка свойств
ms.date: 10/22/2008
ms.technology: dotnet-standard
helpviewer_keywords:
- member design guidelines, properties
- properties [.NET Framework], design guidelines
ms.assetid: 127cbc0c-cbed-48fd-9c89-7c5d4f98f163
author: KrzysztofCwalina
ms.openlocfilehash: e4ed4fd39a9ebd63b9d5dbff38dc15647d65934f
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62026322"
---
# <a name="property-design"></a>Разработка свойств
Несмотря на то, что свойства с технической точки зрения очень похожи на методы, между ними есть различия с точки зрения сценарии их использования. Они должны рассматриваться как интеллектуальные поля. Они имеют синтаксис вызова полей и гибкость методов.  
  
 **✓ DO** Создание свойства только для чтения, если вызывающий объект не следует изменять значение свойства.  
  
 Следует помнить, что если тип свойства является изменяемым ссылочным типом, значение свойства можно изменить, даже если свойство только для чтения.  
  
 **X DO NOT** предоставить только для набора свойств или свойств задания, имеющих широкий доступ, нежели метод считывания.  
  
 Например не используйте свойства с помощью открытого метода задания и защищенного метода получения.  
  
 Если не может быть указан метод получения свойства, следует реализуйте функции как метод. Начните имя метода с `Set` , а после что вы будет имя свойства. Например <xref:System.AppDomain> имеет метод под названием `SetCachePath` вместо того, свойство только для задания с именем `CachePath`.  
  
 **✓ DO** предоставить значения по умолчанию для всех свойств, убедившись, что значения по умолчанию не приводят к брешь в системе безопасности или совсем неэффективный код.  
  
 **✓ DO** позволяют устанавливать в любом порядке, даже если это приводит к временной недопустимое состояние объекта свойства.  
  
 Чаще всего два или несколько свойств быть взаимосвязанных в точку, где некоторые значения одного свойства могут быть недопустимыми данных значений других свойств того же объекта. В таких случаях исключения, полученный в результате в недопустимом состоянии должны быть отложены, пока взаимосвязанных свойства фактически используются совместно с объектом.  
  
 **✓ DO** сохраняют предыдущее значение, если метод задания свойства вызывает исключение.  
  
 **X AVOID** исключения из методов получения свойства.  
  
 Методы получения свойств должны быть простыми операциями и не должен иметь каких-либо условий. Если свойства getter может создавать исключения, он, вероятно, должны быть переработаны методом. Обратите внимание, что это правило не применяется к индексаторов, где ожидается, что исключения, в результате проверки аргументов.  
  
### <a name="indexed-property-design"></a>Разработка индексированных свойств  
 Индексированное свойство представляет собой специальное свойство, которое может иметь параметры и могут вызываться с помощью специального синтаксиса, аналогично индексации массива.  
  
 Индексированные свойства обычно называются индексаторов. Индексаторы следует использовать только в API, которые обеспечивают доступ к элементам в это логическая коллекция. Например, строка — это совокупность символов и индексатор по <xref:System.String?displayProperty=nameWithType> был добавлен для доступа к его символов.  
  
 **✓ CONSIDER** использовать индексаторы для предоставления доступа к данным, хранящимся во внутреннем массиве.  
  
 **✓ CONSIDER** обеспечить индексаторы для типов, представляющих коллекции элементов.  
  
 **X AVOID** использование индексированных свойств с более чем одним параметром.  
  
 Если в программе требуется несколько параметров, пересмотрите ли свойство действительно представляет метод доступа к логической коллекции. Если этого не произошло, следует используйте методы. Начните имя метода с `Get` или `Set`.  
  
 **X AVOID** индексаторы с типами параметров, отличных от <xref:System.Int32?displayProperty=nameWithType>, <xref:System.Int64?displayProperty=nameWithType>, <xref:System.String?displayProperty=nameWithType>, <xref:System.Object?displayProperty=nameWithType>, или перечисления.  
  
 Если для разработки требуются другие типы параметров, проверьте ли API действительно представляет метод доступа к логической коллекции. Если этого не произошло, используйте метод. Начните имя метода с `Get` или `Set`.  
  
 **✓ DO** используйте имя `Item` для индексированных свойств при отсутствии очевидно, что более понятные имена (например, см. <xref:System.String.Chars%2A> свойство `System.String`).  
  
 В C# индексаторы, по умолчанию, с именем элемента. <xref:System.Runtime.CompilerServices.IndexerNameAttribute> Можно использовать для настройки этого имени.  
  
 **X DO NOT** предоставляют индексатор и методы, которые семантически эквивалентны.  
  
 **X DO NOT** предоставляют более одного семейства перегруженных индексаторов в одном типе.  
  
 Это реализуется с помощью компилятора C#.  
  
 **X DO NOT** нестандартное использование индексированных свойств.  
  
 Это реализуется с помощью компилятора C#.  
  
### <a name="property-change-notification-events"></a>События уведомления об изменении свойства  
 Иногда полезно предоставляют событие, уведомляя пользователя об изменениях значения свойства. Например `System.Windows.Forms.Control` вызывает `TextChanged` событий после значение его `Text` свойство изменилось.  
  
 **✓ CONSIDER** вызов изменения события уведомления при изменении значений свойств в API высокого уровня (обычно компонентов конструктора).  
  
 Если подходящий сценарий для пользователя, чтобы знать, когда изменения свойства объекта, объект должен вызывать событие уведомления об изменении свойства.  
  
 Однако маловероятно, чтобы его стоило трудозатрат, связанных с создавать эти события для API низкого уровня, например базовых типов или коллекций. Например <xref:System.Collections.Generic.List%601> не будет вызывать такие события, когда новый элемент добавляется в список и `Count` изменения свойств.  
  
 **✓ CONSIDER** вызов изменения события уведомления при изменении значения свойства через внешних событий.  
  
 При изменении значения свойства с помощью некоторых внешних столь (отличных от путем вызова методов в объекте), вызвано события указывают разработчику, что значение изменяется и изменилось. Хорошим примером является `Text` свойства элемент управления текстовым полем. Когда пользователь вводит текст в `TextBox`, автоматически изменяет значение свойства.  
  
 *Фрагменты: © Корпорация Майкрософт (Microsoft Corporation), 2005, 2009. Все права защищены.*  
  
 *Перепечатано разрешением Пирсона для образовательных учреждений, Inc. из [рекомендации по разработке Framework: Условные обозначения, стили и шаблоны для библиотеки .NET для повторного использования, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) Кшиштов Квалина и Брэд Абрамс, опубликованных 22 октября 2008 г., издательство Addison-Wesley Professional как части цикла разработки Microsoft Windows.*  
  
## <a name="see-also"></a>См. также

- [Правила разработки членов](../../../docs/standard/design-guidelines/member.md)
- [Рекомендации по проектированию на основе Framework](../../../docs/standard/design-guidelines/index.md)
