---
title: Разработка свойств
ms.date: 10/22/2008
ms.technology: dotnet-standard
helpviewer_keywords:
- member design guidelines, properties
- properties [.NET Framework], design guidelines
ms.assetid: 127cbc0c-cbed-48fd-9c89-7c5d4f98f163
ms.openlocfilehash: 8b6570b1b7c292729b78f2fe52f24f73319efe6c
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2020
ms.locfileid: "76743666"
---
# <a name="property-design"></a>Разработка свойств
Хотя свойства технически похожи на методы, они сильно отличаются в плане их сценариев использования. Они должны отображаться как интеллектуальные поля. Они имеют синтаксис для вызова полей и гибкость методов.

 ✔️ создать свойства только для получения, если вызывающий объект не может изменить значение свойства.

 Помните, что если тип свойства является изменяемым ссылочным типом, значение свойства можно изменить, даже если это свойство доступно только для получения.

 ❌ не предоставляют свойства или свойства только для установки с методом задания, имеющим более широкие возможности доступа, чем метод получения.

 Например, не используйте свойства с открытым методом задания и защищенным методом считывания.

 Если метод получения свойства не может быть предоставлен, реализуйте в качестве метода функцию. Рассмотрите возможность запуска имени метода с `Set` и выполните действия с именем свойства. Например, <xref:System.AppDomain> имеет метод с именем `SetCachePath` вместо того, чтобы иметь свойство только для набора, именуемое `CachePath`.

 ✔️ предоставляют разумные значения по умолчанию для всех свойств, гарантируя, что значения по умолчанию не приводят к появлению бреши в системе безопасности или неэффективному коду.

 ✔️ разрешить задавать свойства в любом порядке, даже если это приводит к временному недопустимому состоянию объекта.

 Обычно два или более свойства взаимосвязаны с точкой, в которой некоторые значения одного свойства могут быть недопустимыми с учетом значений других свойств одного и того же объекта. В таких случаях исключения, являющиеся результатом недопустимого состояния, должны быть отложены до тех пор, пока взаимосвязанные свойства фактически не будут использоваться объектом вместе.

 ✔️ сохранить предыдущее значение, если метод задания свойства создает исключение.

 ❌ избежать возникновения исключений из методов получения свойств.

 Методы получения свойств должны быть простыми операциями и не должны иметь никаких предусловий. Если метод получения может вызвать исключение, то, возможно, он будет переработано, чтобы быть методом. Обратите внимание, что это правило не применяется к индексаторам, в которых мы предполагаем исключения в результате проверки аргументов.

### <a name="indexed-property-design"></a>Разработка индексированных свойств
 Индексированное свойство — это специальное свойство, которое может иметь параметры и может вызываться с помощью специального синтаксиса, аналогичного индексированию массива.

 Индексированные свойства обычно называются индексаторами. Индексаторы следует использовать только в интерфейсах API, которые предоставляют доступ к элементам в логической коллекции. Например, строка представляет собой набор символов, а индексатор для <xref:System.String?displayProperty=nameWithType> был добавлен для доступа к его символам.

 ✔️ Рассмотрите возможность использования индексаторов для предоставления доступа к данным, хранящимся во внутреннем массиве.

 ✔️ Рассмотрите возможность предоставления индексаторов для типов, представляющих коллекции элементов.

 ❌ Избегайте использования индексированных свойств более чем с одним параметром.

 Если для проектирования требуется несколько параметров, следует подумать, действительно ли свойство представляет метод доступа к логической коллекции. Если это не так, используйте вместо них методы. Попробуйте запустить имя метода с помощью `Get` или `Set`.

 ❌ избегать использования индексаторов с типами параметров, отличными от <xref:System.Int32?displayProperty=nameWithType>, <xref:System.Int64?displayProperty=nameWithType>, <xref:System.String?displayProperty=nameWithType>, <xref:System.Object?displayProperty=nameWithType>или перечисления.

 Если для разработки требуются другие типы параметров, настоятельно повторно оцените, действительно ли API представляет метод доступа к логической коллекции. В противном случае используйте метод. Попробуйте запустить имя метода с помощью `Get` или `Set`.

 ✔️ использовать имя `Item` для индексированных свойств, если нет очевидного лучшего имени (например, см. свойство <xref:System.String.Chars%2A> в `System.String`).

 В C#индексаторы по умолчанию имеют именованный элемент. Для настройки этого имени можно использовать <xref:System.Runtime.CompilerServices.IndexerNameAttribute>.

 ❌ не предоставляют и индексатор, и методы, которые являются семантически эквивалентными.

 ❌ не предоставляют более одного семейства перегруженных индексаторов в одном типе.

 Это обеспечивается C# компилятором.

 ❌ не используют индексированные свойства, не являющиеся свойствами по умолчанию.

 Это обеспечивается C# компилятором.

### <a name="property-change-notification-events"></a>События уведомления об изменении свойств
 Иногда бывает полезно указать событие, уведомляющее пользователя об изменениях в значении свойства. Например, `System.Windows.Forms.Control` вызывает событие `TextChanged` после изменения значения свойства `Text`.

 ✔️ Рассмотрите возможность вызова событий уведомлений об изменениях при изменении значений свойств в интерфейсах API высокого уровня (обычно в компонентах конструктора).

 Если есть хороший сценарий, при котором пользователю известно, когда изменяется свойство объекта, объект должен создать событие уведомления об изменении для свойства.

 Однако вряд ли стоит тратить издержки на создание таких событий для низкоуровневых API, таких как базовые типы или коллекции. Например, <xref:System.Collections.Generic.List%601> не будет вызывать такие события при добавлении нового элемента в список и изменении свойства `Count`.

 ✔️ Рассмотрите возможность создания событий уведомления об изменениях, когда значение свойства изменяется через внешние силы.

 Если значение свойства изменяется с помощью некоторой внешней силы (не путем вызова методов объекта), события вызываются разработчиком, что значение изменяется и изменилось. Хорошим примером является свойство `Text` элемента управления "текстовое поле". Когда пользователь вводит текст в `TextBox`, значение свойства изменяется автоматически.

 *Части © 2005, 2009 Корпорация Майкрософт. Все права защищены.*

 *Перепечатано с разрешения Pearson Education, Inc. из книги [Инфраструктура программных проектов. Соглашения, идиомы и шаблоны для многократно используемых библиотек .NET (2-е издание)](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619), авторы: Кржиштоф Цвалина (Krzysztof Cwalina) и Брэд Абрамс (Brad Abrams). Книга опубликована 22 октября 2008 г. издательством Addison-Wesley Professional в рамках серии, посвященной разработке для Microsoft Windows.*

## <a name="see-also"></a>См. также:

- [Правила разработки членов](../../../docs/standard/design-guidelines/member.md)
- [Рекомендации по проектированию на основе Framework](../../../docs/standard/design-guidelines/index.md)
