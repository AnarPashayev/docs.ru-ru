---
title: Разработка свойств
ms.date: 10/22/2008
ms.technology: dotnet-standard
helpviewer_keywords:
- member design guidelines, properties
- properties [.NET Framework], design guidelines
ms.assetid: 127cbc0c-cbed-48fd-9c89-7c5d4f98f163
ms.openlocfilehash: 5d5cdbfdb38c7aebaca6cbcdeb63959ac12884e0
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2020
ms.locfileid: "75709131"
---
# <a name="property-design"></a>Разработка свойств
Хотя свойства технически похожи на методы, они сильно отличаются в плане их сценариев использования. Они должны отображаться как интеллектуальные поля. Они имеют синтаксис для вызова полей и гибкость методов.  
  
 **✓ DO** Создание свойства только для чтения, если вызывающий объект не следует изменять значение свойства.  
  
 Помните, что если тип свойства является изменяемым ссылочным типом, значение свойства можно изменить, даже если это свойство доступно только для получения.  
  
 **X DO NOT** предоставить только для набора свойств или свойств задания, имеющих широкий доступ, нежели метод считывания.  
  
 Например, не используйте свойства с открытым методом задания и защищенным методом считывания.  
  
 Если метод получения свойства не может быть предоставлен, реализуйте в качестве метода функцию. Рассмотрите возможность запуска имени метода с `Set` и выполните действия с именем свойства. Например, <xref:System.AppDomain> имеет метод с именем `SetCachePath` вместо того, чтобы иметь свойство только для набора, именуемое `CachePath`.  
  
 **✓ DO** предоставить значения по умолчанию для всех свойств, убедившись, что значения по умолчанию не приводят к брешь в системе безопасности или совсем неэффективный код.  
  
 **✓ DO** позволяют устанавливать в любом порядке, даже если это приводит к временной недопустимое состояние объекта свойства.  
  
 Обычно два или более свойства взаимосвязаны с точкой, в которой некоторые значения одного свойства могут быть недопустимыми с учетом значений других свойств одного и того же объекта. В таких случаях исключения, являющиеся результатом недопустимого состояния, должны быть отложены до тех пор, пока взаимосвязанные свойства фактически не будут использоваться объектом вместе.  
  
 **✓ DO** сохраняют предыдущее значение, если метод задания свойства вызывает исключение.  
  
 **X AVOID** исключения из методов получения свойства.  
  
 Методы получения свойств должны быть простыми операциями и не должны иметь никаких предусловий. Если метод получения может вызвать исключение, то, возможно, он будет переработано, чтобы быть методом. Обратите внимание, что это правило не применяется к индексаторам, в которых мы предполагаем исключения в результате проверки аргументов.  
  
### <a name="indexed-property-design"></a>Разработка индексированных свойств  
 Индексированное свойство — это специальное свойство, которое может иметь параметры и может вызываться с помощью специального синтаксиса, аналогичного индексированию массива.  
  
 Индексированные свойства обычно называются индексаторами. Индексаторы следует использовать только в интерфейсах API, которые предоставляют доступ к элементам в логической коллекции. Например, строка представляет собой набор символов, а индексатор для <xref:System.String?displayProperty=nameWithType> был добавлен для доступа к его символам.  
  
 **✓ CONSIDER** использовать индексаторы для предоставления доступа к данным, хранящимся во внутреннем массиве.  
  
 **✓ CONSIDER** обеспечить индексаторы для типов, представляющих коллекции элементов.  
  
 **X AVOID** использование индексированных свойств с более чем одним параметром.  
  
 Если для проектирования требуется несколько параметров, следует подумать, действительно ли свойство представляет метод доступа к логической коллекции. Если это не так, используйте вместо них методы. Попробуйте запустить имя метода с помощью `Get` или `Set`.  
  
 **X AVOID** индексаторы с типами параметров, отличных от <xref:System.Int32?displayProperty=nameWithType>, <xref:System.Int64?displayProperty=nameWithType>, <xref:System.String?displayProperty=nameWithType>, <xref:System.Object?displayProperty=nameWithType>, или перечисления.  
  
 Если для разработки требуются другие типы параметров, настоятельно повторно оцените, действительно ли API представляет метод доступа к логической коллекции. В противном случае используйте метод. Попробуйте запустить имя метода с помощью `Get` или `Set`.  
  
 **✓ DO** используйте имя `Item` для индексированных свойств при отсутствии очевидно, что более понятные имена (например, см. <xref:System.String.Chars%2A> свойство `System.String`).  
  
 В C#индексаторы по умолчанию имеют именованный элемент. Для настройки этого имени можно использовать <xref:System.Runtime.CompilerServices.IndexerNameAttribute>.  
  
 **X DO NOT** предоставляют индексатор и методы, которые семантически эквивалентны.  
  
 **X DO NOT** предоставляют более одного семейства перегруженных индексаторов в одном типе.  
  
 Это обеспечивается C# компилятором.  
  
 **X DO NOT** нестандартное использование индексированных свойств.  
  
 Это обеспечивается C# компилятором.  
  
### <a name="property-change-notification-events"></a>События уведомления об изменении свойств  
 Иногда бывает полезно указать событие, уведомляющее пользователя об изменениях в значении свойства. Например, `System.Windows.Forms.Control` вызывает событие `TextChanged` после изменения значения свойства `Text`.  
  
 **✓ CONSIDER** вызов изменения события уведомления при изменении значений свойств в API высокого уровня (обычно компонентов конструктора).  
  
 Если есть хороший сценарий, при котором пользователю известно, когда изменяется свойство объекта, объект должен создать событие уведомления об изменении для свойства.  
  
 Однако вряд ли стоит тратить издержки на создание таких событий для низкоуровневых API, таких как базовые типы или коллекции. Например, <xref:System.Collections.Generic.List%601> не будет вызывать такие события при добавлении нового элемента в список и изменении свойства `Count`.  
  
 **✓ CONSIDER** вызов изменения события уведомления при изменении значения свойства через внешних событий.  
  
 Если значение свойства изменяется с помощью некоторой внешней силы (не путем вызова методов объекта), события вызываются разработчиком, что значение изменяется и изменилось. Хорошим примером является свойство `Text` элемента управления "текстовое поле". Когда пользователь вводит текст в `TextBox`, значение свойства изменяется автоматически.  
  
 *Части © 2005, 2009 Корпорация Майкрософт. Все права защищены.*  
  
 *Перепечатано с разрешения Pearson Education, Inc. из книги [Инфраструктура программных проектов. Соглашения, идиомы и шаблоны для многократно используемых библиотек .NET (2-е издание)](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619), авторы: Кржиштоф Цвалина (Krzysztof Cwalina) и Брэд Абрамс (Brad Abrams). Книга опубликована 22 октября 2008 г. издательством Addison-Wesley Professional в рамках серии, посвященной разработке для Microsoft Windows.*  
  
## <a name="see-also"></a>См. также:

- [Правила разработки членов](../../../docs/standard/design-guidelines/member.md)
- [Рекомендации по проектированию на основе Framework](../../../docs/standard/design-guidelines/index.md)
