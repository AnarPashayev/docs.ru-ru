---
title: Выбор между классом и структурой
ms.date: 10/22/2008
ms.technology: dotnet-standard
helpviewer_keywords:
- class library design guidelines [.NET Framework], structures
- class library design guidelines [.NET Framework], classes
- structures [.NET Framework], vs. classes
- classes [.NET Framework], design guidelines
- type design guidelines, structures
- structures [.NET Framework], design guidelines
- classes [.NET Framework], vs. structures
- type design guidelines, classes
ms.assetid: f8b8ec9b-0ba7-4dea-aadf-a93395cd804f
author: KrzysztofCwalina
ms.openlocfilehash: 5041368ca1a440698c399c935ac72aba2002c3ba
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2019
ms.locfileid: "64615263"
---
# <a name="choosing-between-class-and-struct"></a><span data-ttu-id="a2e53-102">Выбор между классом и структурой</span><span class="sxs-lookup"><span data-stu-id="a2e53-102">Choosing Between Class and Struct</span></span>
<span data-ttu-id="a2e53-103">Одним из основных проектных решений, каждый конструктор framework сталкивается является разработки типом, как класс (ссылочного типа) или как структура (тип значения).</span><span class="sxs-lookup"><span data-stu-id="a2e53-103">One of the basic design decisions every framework designer faces is whether to design a type as a class (a reference type) or as a struct (a value type).</span></span> <span data-ttu-id="a2e53-104">При этом важно хорошо понимать различия в поведении ссылочных типов и типов значений.</span><span class="sxs-lookup"><span data-stu-id="a2e53-104">Good understanding of the differences in the behavior of reference types and value types is crucial in making this choice.</span></span>  
  
 <span data-ttu-id="a2e53-105">Первый разница между ссылочные типы и типы значений, которые мы будем считать, является то, что ссылочные типы выделенными в куче и сборщиком мусора, тогда как выделяются типы значений, либо в стеке или встроенный в, которая содержит типы и освобожден, когда стек Освобождает или когда освобождается содержащего их типа.</span><span class="sxs-lookup"><span data-stu-id="a2e53-105">The first difference between reference types and value types we will consider is that reference types are allocated on the heap and garbage-collected, whereas value types are allocated either on the stack or inline in containing types and deallocated when the stack unwinds or when their containing type gets deallocated.</span></span> <span data-ttu-id="a2e53-106">Поэтому операций выделения и освобождения типы значений являются в целом дешевле, чем операций выделения и освобождения ссылочных типов.</span><span class="sxs-lookup"><span data-stu-id="a2e53-106">Therefore, allocations and deallocations of value types are in general cheaper than allocations and deallocations of reference types.</span></span>  
  
 <span data-ttu-id="a2e53-107">Далее массивы, ссылки на типы: выделить вне строки, то есть элементы массива имеют только ссылки на экземпляры ссылочного типа, размещенных в куче.</span><span class="sxs-lookup"><span data-stu-id="a2e53-107">Next, arrays of reference types are allocated out-of-line, meaning the array elements are just references to instances of the reference type residing on the heap.</span></span> <span data-ttu-id="a2e53-108">Массивы типов значений выделяются встроенный, это означает, что элементы массива являются фактическим экземплярам типа значения.</span><span class="sxs-lookup"><span data-stu-id="a2e53-108">Value type arrays are allocated inline, meaning that the array elements are the actual instances of the value type.</span></span> <span data-ttu-id="a2e53-109">Поэтому операций выделения и освобождения массивы типов значений являются гораздо дешевле, чем операций выделения и освобождения массивов ссылочного типа.</span><span class="sxs-lookup"><span data-stu-id="a2e53-109">Therefore, allocations and deallocations of value type arrays are much cheaper than allocations and deallocations of reference type arrays.</span></span> <span data-ttu-id="a2e53-110">Кроме того в большинстве случаев значение массивов типа проявляется гораздо лучше расположение ссылок.</span><span class="sxs-lookup"><span data-stu-id="a2e53-110">In addition, in a majority of cases value type arrays exhibit much better locality of reference.</span></span>  
  
 <span data-ttu-id="a2e53-111">Далее разницу связана с использование памяти.</span><span class="sxs-lookup"><span data-stu-id="a2e53-111">The next difference is related to memory usage.</span></span> <span data-ttu-id="a2e53-112">Типы значений упаковываться при приведении к ссылочным типом или один из интерфейсов, которые они реализуют.</span><span class="sxs-lookup"><span data-stu-id="a2e53-112">Value types get boxed when cast to a reference type or one of the interfaces they implement.</span></span> <span data-ttu-id="a2e53-113">Они получают из упакованной при приведении к типу значения.</span><span class="sxs-lookup"><span data-stu-id="a2e53-113">They get unboxed when cast back to the value type.</span></span> <span data-ttu-id="a2e53-114">Так как поля являются объектами, которые назначаются в куче и сборщиком мусора, слишком много упаковке и распаковке может иметь негативное влияние на кучи сборщика мусора и в конечном счете производительность приложения.</span><span class="sxs-lookup"><span data-stu-id="a2e53-114">Because boxes are objects that are allocated on the heap and are garbage-collected, too much boxing and unboxing can have a negative impact on the heap, the garbage collector, and ultimately the performance of the application.</span></span>  <span data-ttu-id="a2e53-115">Напротив таких упаковка-преобразование не происходит, когда они приводятся ссылочные типы.</span><span class="sxs-lookup"><span data-stu-id="a2e53-115">In contrast, no such boxing occurs as reference types are cast.</span></span> <span data-ttu-id="a2e53-116">(Дополнительные сведения см. в разделе [упаковка-преобразование и распаковка-преобразование](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span><span class="sxs-lookup"><span data-stu-id="a2e53-116">(For more information, see [Boxing and Unboxing](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span></span>
  
 <span data-ttu-id="a2e53-117">Затем назначения типа ссылки Копировать ссылку, тогда как назначения типа значение скопируйте все значение.</span><span class="sxs-lookup"><span data-stu-id="a2e53-117">Next, reference type assignments copy the reference, whereas value type assignments copy the entire value.</span></span> <span data-ttu-id="a2e53-118">Поэтому назначения больших ссылочных типов являются дешевле, чем назначения типов больших значений.</span><span class="sxs-lookup"><span data-stu-id="a2e53-118">Therefore, assignments of large reference types are cheaper than assignments of large value types.</span></span>  
  
 <span data-ttu-id="a2e53-119">Наконец ссылочные типы передаются по ссылке, тогда как типы значений передаются по значению.</span><span class="sxs-lookup"><span data-stu-id="a2e53-119">Finally, reference types are passed by reference, whereas value types are passed by value.</span></span> <span data-ttu-id="a2e53-120">Изменение экземпляра ссылочного типа влияет на все ссылки, указывающие на экземпляре.</span><span class="sxs-lookup"><span data-stu-id="a2e53-120">Changes to an instance of a reference type affect all references pointing to the instance.</span></span> <span data-ttu-id="a2e53-121">Экземпляры типов значения копируются в том случае, когда они передаются по значению.</span><span class="sxs-lookup"><span data-stu-id="a2e53-121">Value type instances are copied when they are passed by value.</span></span> <span data-ttu-id="a2e53-122">При изменении экземпляра типа значения, она Конечно не влияет на любой из его копии.</span><span class="sxs-lookup"><span data-stu-id="a2e53-122">When an instance of a value type is changed, it of course does not affect any of its copies.</span></span> <span data-ttu-id="a2e53-123">Так как копии явным образом не создаются пользователем, но создаются неявно, когда аргументы передаются или возвращаемые значения возвращаются, типы значений, которые могут быть изменены могут запутать многие пользователи.</span><span class="sxs-lookup"><span data-stu-id="a2e53-123">Because the copies are not created explicitly by the user but are implicitly created when arguments are passed or return values are returned, value types that can be changed can be confusing to many users.</span></span> <span data-ttu-id="a2e53-124">Таким образом типы значений должны быть неизменными.</span><span class="sxs-lookup"><span data-stu-id="a2e53-124">Therefore, value types should be immutable.</span></span>  
  
 <span data-ttu-id="a2e53-125">Как правило большинство типов в платформе должно быть классов.</span><span class="sxs-lookup"><span data-stu-id="a2e53-125">As a rule of thumb, the majority of types in a framework should be classes.</span></span> <span data-ttu-id="a2e53-126">Тем не менее, существуют некоторые ситуации, в которых характеристики типа значением делающие их более подходящими использовать структуры.</span><span class="sxs-lookup"><span data-stu-id="a2e53-126">There are, however, some situations in which the characteristics of a value type make it more appropriate to use structs.</span></span>  
  
 <span data-ttu-id="a2e53-127">**✓ CONSIDER** определение структуры вместо класса, если экземпляры типа невелики и имеют короткое время существования или внедрены в другие объекты.</span><span class="sxs-lookup"><span data-stu-id="a2e53-127">**✓ CONSIDER** defining a struct instead of a class if instances of the type are small and commonly short-lived or are commonly embedded in other objects.</span></span>  
  
 <span data-ttu-id="a2e53-128">**X AVOID** определение структуры, если тип не содержит все следующие характеристики:</span><span class="sxs-lookup"><span data-stu-id="a2e53-128">**X AVOID** defining a struct unless the type has all of the following characteristics:</span></span>  
  
- <span data-ttu-id="a2e53-129">Он логически представляет одиночное значение, аналогичную типы-примитивы (`int`, `double`и т. д.).</span><span class="sxs-lookup"><span data-stu-id="a2e53-129">It logically represents a single value, similar to primitive types (`int`, `double`, etc.).</span></span>  
  
- <span data-ttu-id="a2e53-130">Он имеет размер экземпляра в разделе 16 байт.</span><span class="sxs-lookup"><span data-stu-id="a2e53-130">It has an instance size under 16 bytes.</span></span>  
  
- <span data-ttu-id="a2e53-131">Он станет неизменяемым.</span><span class="sxs-lookup"><span data-stu-id="a2e53-131">It is immutable.</span></span>  
  
- <span data-ttu-id="a2e53-132">Упаковываемый часто не будет.</span><span class="sxs-lookup"><span data-stu-id="a2e53-132">It will not have to be boxed frequently.</span></span>  
  
 <span data-ttu-id="a2e53-133">Во всех остальных случаях необходимо определить типы как классы.</span><span class="sxs-lookup"><span data-stu-id="a2e53-133">In all other cases, you should define your types as classes.</span></span>  
  
 <span data-ttu-id="a2e53-134">*Фрагменты: © Корпорация Майкрософт (Microsoft Corporation), 2005, 2009. Все права защищены.*</span><span class="sxs-lookup"><span data-stu-id="a2e53-134">*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*</span></span>  
  
 <span data-ttu-id="a2e53-135">*Перепечатано разрешением Пирсона для образовательных учреждений, Inc. из [рекомендации по разработке Framework: Условные обозначения, стили и шаблоны для библиотеки .NET для повторного использования, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) Кшиштов Квалина и Брэд Абрамс, опубликованных 22 октября 2008 г., издательство Addison-Wesley Professional как части цикла разработки Microsoft Windows.*</span><span class="sxs-lookup"><span data-stu-id="a2e53-135">*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a2e53-136">См. также</span><span class="sxs-lookup"><span data-stu-id="a2e53-136">See also</span></span>

- [<span data-ttu-id="a2e53-137">Рекомендации по разработке типов</span><span class="sxs-lookup"><span data-stu-id="a2e53-137">Type Design Guidelines</span></span>](../../../docs/standard/design-guidelines/type.md)
- [<span data-ttu-id="a2e53-138">Рекомендации по проектированию на основе Framework</span><span class="sxs-lookup"><span data-stu-id="a2e53-138">Framework Design Guidelines</span></span>](../../../docs/standard/design-guidelines/index.md)
