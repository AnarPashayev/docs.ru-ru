---
title: Универсальные шаблоны в .NET
description: Сведения об универсальных шаблонах в .NET. Узнайте, как определять и использовать универсальные шаблоны, какие у них преимущества и недостатки, как работает библиотека классов и языковая поддержка и т. д.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
- cpp
helpviewer_keywords:
- generic methods, type inference
- generics [.NET], collections
- generic interfaces [.NET]
- constructed generic types
- nested generic types
- generic type definitions
- generic classes [.NET]
- generics [.NET], interfaces
- generics [.NET], about
- generics [.NET]
- generic collections [.NET]
- generic delegates [.NET]
- generic type arguments
- generics [.NET], delegates
- generics [.NET], features
- constraints [.NET]
- generic types
- generic type parameters
ms.assetid: 2994d786-c5c7-4666-ab23-4c83129fe39c
ms.openlocfilehash: 40a789d9eaa835b1c464f25b5a33a7c1d766d2f8
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/18/2020
ms.locfileid: "94827260"
---
# <a name="generics-in-net"></a>Универсальные шаблоны в .NET

Универсальные шаблоны позволяют точно настроить метод, класс, структуру или интерфейс в соответствии с типом обрабатываемых данных. Например, вместо использования класса <xref:System.Collections.Hashtable> , который позволяет ключам и значениям быть любого типа, можно использовать универсальный класс <xref:System.Collections.Generic.Dictionary%602> и указать допустимый тип ключа и тип значения. Помимо прочего, преимуществами универсальных шаблонов являются улучшенная возможность многократного использования кода и сохранения типов.  

## <a name="defining-and-using-generics"></a>Определение и использование универсальных шаблонов
 Универсальными шаблонами являются классы, структуры, интерфейсы и методы, которые имеют прототипы (параметры типов) для одного или нескольких типов, которые они хранят или используют. Класс универсальной коллекции может использовать параметр типа в качестве заполнителя для типа объектов, которые в нем хранятся. Параметры типа отображаются как типы его полей и типы параметров его методов. Универсальный метод может использовать параметр типа в качестве типа возвращаемого значения или как тип одного из своих формальных параметров. Следующий код иллюстрирует определение простого универсального класса.  
  
 [!code-cpp[Conceptual.Generics.Overview#2](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#2)]
 [!code-csharp[Conceptual.Generics.Overview#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#2)]
 [!code-vb[Conceptual.Generics.Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#2)]  
  
 При создании экземпляра универсального класса необходимо указать фактические типы для замены параметров типа. При этом создается новый универсальный класс, называемый сконструированным универсальным классом, с выбранными типами, заменяющими все параметры типа. Результатом является типобезопасный класс, соответствующий вашему выбору типов, как показано в следующем коде.  
  
 [!code-cpp[Conceptual.Generics.Overview#3](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#3)]
 [!code-csharp[Conceptual.Generics.Overview#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#3)]
 [!code-vb[Conceptual.Generics.Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#3)]  

### <a name="generics-terminology"></a>Терминология универсальных шаблонов  
 В контексте универсальных шаблонов в .NET используются следующие термины:  
  
- *Определение универсального типа* — это объявление класса, структуры или интерфейса, которое работает в качестве шаблона с прототипами для типов, которые он может содержать или использовать. Например, класс <xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType> может содержать два типа: ключи и значения. Поскольку определение универсального типа — это только шаблон, создавать экземпляры класса, структуры или интерфейса, являющиеся определением универсального типа, нельзя.  
  
- *Параметры универсального типа* или *параметры типа* являются прототипами в определении универсального типа или метода. Универсальный тип <xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType> имеет два параметра типа `TKey` и `TValue`, которые представляют типы его ключей и значений.  
  
- *Сконструированный универсальный тип* или *сконструированный тип* является результатом указания типов для параметров универсального типа в определении универсального типа.  
  
- *Аргумент универсального типа* является любым типом, заменяемым на параметр универсального типа.  
  
- Общий термин *универсальный тип* описывает определения как сконструированных типов, так и универсальных типов.  
  
- *Ковариация* и *контравариация* параметров универсального типа позволяют использовать сконструированные универсальные типы, аргументы типов которых находятся на более высоком (в случае ковариации) или низком (в случае контравариации) уровне иерархии наследования, чем у целевого сконструированного типа. Вместе ковариантность и контрвариантность называются *вариацией*. Дополнительные сведения см. в разделе [Ковариация и контравариантность](covariance-and-contravariance.md).  
  
- *Ограничения* — это пределы, наложенные на параметры универсального типа. Например, можно ограничить параметр типа типами, реализующими универсальный интерфейс <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> , чтобы обеспечить упорядочивание экземпляров типа. Можно также ограничить параметры типа типами, имеющими определенный базовый класс, который содержит конструктор без параметров, или типами, являющимися ссылочными типами или типами значений. Пользователи универсального типа не могут подставить аргументы типа, которые не удовлетворяют ограничениям.  
  
- *Определение универсального метода* — это метод с двумя списками параметров: списком параметров универсальных типов и списком формальных параметров. Параметры типа могут отображаться в качестве возвращаемого типа или в качестве типов формальных параметров, как показано в следующем коде.  
  
 [!code-cpp[Conceptual.Generics.Overview#4](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#4)]
 [!code-csharp[Conceptual.Generics.Overview#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#4)]
 [!code-vb[Conceptual.Generics.Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#4)]  
  
 Универсальные методы могут присутствовать в универсальных и неуниверсальных типах. Важно отметить, что метод не является универсальным только потому, что он принадлежит универсальному типу или даже в том случае, если он имеет формальные параметры, типы которых являются универсальными параметрами для включающего их типа. Метод является универсальным только в том случае, если он имеет свой собственный список параметров типа. В следующем коде только метод `G` является универсальным.  
  
 [!code-cpp[Conceptual.Generics.Overview#5](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#5)]
 [!code-csharp[Conceptual.Generics.Overview#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#5)]
 [!code-vb[Conceptual.Generics.Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#5)]  
  
## <a name="advantages-and-disadvantages-of-generics"></a>Преимущества и недостатки универсальных шаблонов
 Использование универсальных коллекций и делегатов предоставляет целый ряд преимуществ.  
  
- Типобезопасность. Универсальные шаблоны позволяют передать компилятору обязанности обеспечения типовой безопасности. Нет необходимости написания кода для проверки правильности типа данных, так как проверка происходит во время компиляции. Уменьшается потребность приведения типов и вероятность ошибок во время выполнения.  
  
- Объем кода уменьшен и поддерживает многократную реализацию. Нет необходимости наследования базового типа и преобладающих членов. Например, <xref:System.Collections.Generic.LinkedList%601> готов к немедленному использованию. Например, можно создать связанный список строк со следующим объявлением переменной:  
  
     [!code-cpp[HowToGeneric#24](../../../samples/snippets/cpp/VS_Snippets_CLR/HowToGeneric/cpp/source2.cpp#24)]
     [!code-csharp[HowToGeneric#24](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToGeneric/CS/source2.cs#24)]
     [!code-vb[HowToGeneric#24](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToGeneric/VB/source2.vb#24)]  
  
- Повышенная производительность. Универсальные типы коллекций имеют более высокую производительность при хранении и управлении типами значений, поскольку отсутствует необходимость их упаковки.  
  
- Универсальные делегаты поддерживают типобезопасные обратные вызовы без необходимости создания нескольких классов делегатов. Например, универсальный делегат <xref:System.Predicate%601> позволяет создать метод, который реализует собственные условия поиска для определенного типа, и использовать ваш метод с методами типа <xref:System.Array> , такими как <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>и <xref:System.Array.FindAll%2A>.  
  
- Универсальные шаблоны упрощают динамически создаваемый код. Универсальные делегаты можно также использовать в динамически создаваемом коде без необходимости создания типа делегата. Это увеличивает количество ситуаций, в которых можно использовать облегченные динамические методы вместо создания целых сборок. Дополнительные сведения см. в разделе [Практическое руководство. Определение и выполнение динамических методов ](../../framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md) и <xref:System.Reflection.Emit.DynamicMethod>.  
  
 Ниже перечислены некоторые ограничения универсальных шаблонов.  
  
- Универсальные типы могут быть наследованы от большинства базовых классов, таких как <xref:System.MarshalByRefObject> (а ограничения могут использоваться для обеспечения того, чтобы параметры универсальных типов наследовались от базовых классов, таких как <xref:System.MarshalByRefObject>). Тем не менее, .NET не поддерживает контекстно-связанные универсальные типы. Универсальный тип может быть производным от <xref:System.ContextBoundObject>, но при попытке создать экземпляр этого типа будет создано исключение <xref:System.TypeLoadException>.  
  
- Перечисления не могут иметь параметров универсального типа. Перечисление может быть универсальным только случайно (например, если оно является вложенным в универсальный тип, который определен с помощью Visual Basic, C# или C++). Дополнительные сведения см. в разделе "Перечисления" статьи [Система общих типов CTS](../base-types/common-type-system.md).  
  
- Облегченные динамические методы не могут быть универсальными.  
  
- В Visual Basic, C# и C++ вложенный тип, заключенный в универсальном типе, не может быть использован для создания объекта, кроме тех случаев, когда типы были назначены параметрам типа всех заключенных типов. Другими словами, вложенный тип, который определен с помощью этих языков, включает параметры типов всех его заключенных типов. Это позволяет использовать параметры типа заключающих типов в определениях членов вложенного типа. Дополнительные сведения см. в подразделе "Вложенные типы" раздела <xref:System.Type.MakeGenericType%2A>.  
  
    > [!NOTE]
    > Вложенный тип, который определяется путем создания кода в динамической сборке или с помощью [ассемблера IL (Ilasm.exe)](../../framework/tools/ilasm-exe-il-assembler.md), не обязательно должен включать параметры его заключающих типов. Тем не менее, если он их не включает, параметры типов находятся вне области вложенного класса.  
  
     Дополнительные сведения см. в подразделе "Вложенные типы" раздела <xref:System.Type.MakeGenericType%2A>.  

## <a name="class-library-and-language-support"></a>Библиотека классов и языковая поддержка  
 .NET предоставляет ряд универсальных классов коллекций в следующих пространствах имен:  
  
- В пространстве имен <xref:System.Collections.Generic> содержится большинство типов универсальных коллекций, предоставляемых в составе .NET, например универсальные классы <xref:System.Collections.Generic.List%601> и <xref:System.Collections.Generic.Dictionary%602> .  
  
- В пространстве имен <xref:System.Collections.ObjectModel> содержатся дополнительные типы универсальных коллекций (например, универсальный класс <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>), которые удобно использовать для предоставления объектных моделей пользователям классов.  
  
 Универсальные интерфейсы для реализации сортировки и сравнений на равенство предоставляются в пространстве имен <xref:System> вместе с универсальными типами делегатов для обработчиков событий, преобразований и предикатов поиска.  
  
 В пространство имен <xref:System.Reflection> добавлена поддержка универсальных шаблонов для обеспечения возможности проверки универсальных типов и универсальных методов, в пространство имен <xref:System.Reflection.Emit> добавлена поддержка шаблонов для создания динамических сборок, содержащих универсальные типы и методы, в пространство имен <xref:System.CodeDom> добавлена поддержка шаблонов для создания графов исходного кода, включающих универсальные шаблоны.  
  
 Среда CLR предоставляет новые коды операций и префиксы для поддержки универсальных типов в языке MSIL, включая <xref:System.Reflection.Emit.OpCodes.Stelem>, <xref:System.Reflection.Emit.OpCodes.Ldelem>, <xref:System.Reflection.Emit.OpCodes.Unbox_Any>, <xref:System.Reflection.Emit.OpCodes.Constrained>и <xref:System.Reflection.Emit.OpCodes.Readonly>.  
  
 В языках Visual C++, C# и Visual Basic обеспечивается полноценная поддержка определения и использования универсальных шаблонов. Дополнительные сведения о поддержке языков см. в статьях [Универсальные типы в Visual Basic](../../visual-basic/programming-guide/language-features/data-types/generic-types.md), [Введение в универсальные шаблоны](../../csharp/programming-guide/generics/index.md) и [Обзор универсальных типов в Visual C++](/cpp/windows/overview-of-generics-in-visual-cpp).

## <a name="nested-types-and-generics"></a>Вложенные типы и универсальные шаблоны  
 Тип, вложенный в универсальный тип, может зависеть от параметров типа этого универсального типа. Среда CLR рассматривает вложенные типы как универсальные, даже если они не имеют своих собственных параметров универсального типа. При создании экземпляра вложенного типа необходимо задать аргументы типа для всех включающих его универсальных типов.  

## <a name="related-topics"></a>См. также  
  
|Заголовок|Описание|  
|-----------|-----------------|  
|[Универсальные коллекции в .NET](collections.md)|Описание классов универсальных коллекций и других универсальных типов в составе .NET.|  
|[Универсальные методы-делегаты для управления массивами и списками](delegates-for-manipulating-arrays-and-lists.md)|Описание универсальных делегатов для преобразований, предикатов поиска и действий, осуществляемых с элементами массива или коллекции.|  
|[Универсальные интерфейсы](interfaces.md)|Описание универсальных интерфейсов, которые предоставляют общие функции для различных семейств универсальных типов.|  
|[Ковариация и контрвариантность](covariance-and-contravariance.md)|Описание ковариации и контравариации в параметрах универсальных типов.|  
|[Часто используемые типы коллекций](../collections/commonly-used-collection-types.md)|Предоставление сводных данных о характеристиках и сценариях использования типов коллекций в составе .NET, включая универсальные типы.|  
|[Когда следует использовать универсальные коллекции](../collections/when-to-use-generic-collections.md)|Описание общих правил для определения ситуаций, когда следует использовать универсальные типы коллекций.|  
|[Практическое руководство. Определение универсального типа с порождаемым отражением](../../framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md)|Описание способов создания динамических сборок, содержащих универсальные типы и методы.|  
|[Generic Types in Visual Basic](../../visual-basic/programming-guide/language-features/data-types/generic-types.md)|Описание универсальных шаблонов для пользователей Visual Basic, включая практические руководства об использовании и определении универсальных типов.|  
|[Введение в универсальные шаблоны](../../csharp/programming-guide/generics/index.md)|Общие сведения об определении и использовании универсальных типов для пользователей C#.|  
|[Обзор универсальных типов в Visual C++](/cpp/windows/overview-of-generics-in-visual-cpp)|Описание универсальных шаблонов для пользователей C++, включая описание различий между шаблонами и универсальными шаблонами.|  

## <a name="reference"></a>Справочник  
 <xref:System.Collections.Generic>  
  
 <xref:System.Collections.ObjectModel>  
  
 <xref:System.Reflection.Emit.OpCodes?displayProperty=nameWithType>  
