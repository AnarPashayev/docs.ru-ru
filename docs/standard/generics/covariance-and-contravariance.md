---
title: Ковариантность и контрвариантность в универсальных шаблонах
description: Сведения о ковариантности, которая позволяет использовать тип с большей степенью наследования, и контрвариантности, которая позволяет использовать тип с меньшей степенью наследования в универсальных шаблонах .NET.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- generics, covariance and contravariance
- generics, variance
- covariance and contravariance in generics
- generic type parameters
ms.assetid: 2678dc63-c7f9-4590-9ddc-0a4df684d42e
ms.openlocfilehash: 1606238b22bd355b997b54cf94e0c28d16ec5cac
ms.sourcegitcommit: b1442669f1982d3a1cb18ea35b5acfb0fc7d93e4
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/30/2020
ms.locfileid: "93063180"
---
# <a name="covariance-and-contravariance-in-generics"></a><span data-ttu-id="e8e13-103">Ковариантность и контрвариантность в универсальных шаблонах</span><span class="sxs-lookup"><span data-stu-id="e8e13-103">Covariance and contravariance in generics</span></span>

<span data-ttu-id="e8e13-104">Термины *ковариантность* и *контрвариантность* относятся к возможности использовать более производный (более конкретный) или менее производный (менее конкретный) тип, чем задано изначально.</span><span class="sxs-lookup"><span data-stu-id="e8e13-104">*Covariance* and *contravariance* are terms that refer to the ability to use a more derived type (more specific) or a less derived type (less specific) than originally specified.</span></span> <span data-ttu-id="e8e13-105">Параметры универсальных типов поддерживают ковариантность и контрвариантность и обеспечивают большую гибкость в назначении и использовании универсальных типов.</span><span class="sxs-lookup"><span data-stu-id="e8e13-105">Generic type parameters support covariance and contravariance to provide greater flexibility in assigning and using generic types.</span></span>

<span data-ttu-id="e8e13-106">Ниже приведены определения терминов "ковариантность", "контрвариантность" и "инвариантность" в контексте системы типов.</span><span class="sxs-lookup"><span data-stu-id="e8e13-106">When you're referring to a type system, covariance, contravariance, and invariance have the following definitions.</span></span> <span data-ttu-id="e8e13-107">В этих примерах предполагается наличие базового класса с именем `Base` и производного класса с именем `Derived`.</span><span class="sxs-lookup"><span data-stu-id="e8e13-107">The examples assume a base class named `Base` and a derived class named `Derived`.</span></span>  
  
- `Covariance`  
  
     <span data-ttu-id="e8e13-108">Позволяет использовать тип с большей глубиной наследования, чем задано изначально.</span><span class="sxs-lookup"><span data-stu-id="e8e13-108">Enables you to use a more derived type than originally specified.</span></span>  
  
     <span data-ttu-id="e8e13-109">Экземпляр `IEnumerable<Derived>` можно присвоить переменной типа `IEnumerable<Base>`.</span><span class="sxs-lookup"><span data-stu-id="e8e13-109">You can assign an instance of `IEnumerable<Derived>` to a variable of type `IEnumerable<Base>`.</span></span>  
  
- `Contravariance`  
  
     <span data-ttu-id="e8e13-110">Позволяет использовать более универсальный тип (с меньшей глубиной наследования), чем заданный изначально.</span><span class="sxs-lookup"><span data-stu-id="e8e13-110">Enables you to use a more generic (less derived) type than originally specified.</span></span>  
  
     <span data-ttu-id="e8e13-111">Экземпляр `Action<Base>` можно присвоить переменной типа `Action<Derived>`.</span><span class="sxs-lookup"><span data-stu-id="e8e13-111">You can assign an instance of `Action<Base>` to a variable of type `Action<Derived>`.</span></span>  
  
- `Invariance`  
  
     <span data-ttu-id="e8e13-112">Это означает, что можно использовать только изначально указанный тип.</span><span class="sxs-lookup"><span data-stu-id="e8e13-112">Means that you can use only the type originally specified.</span></span> <span data-ttu-id="e8e13-113">Таким образом, параметр инвариантного универсального типа не является ни ковариантным, ни контрвариантным.</span><span class="sxs-lookup"><span data-stu-id="e8e13-113">An invariant generic type parameter is neither covariant nor contravariant.</span></span>  
  
     <span data-ttu-id="e8e13-114">Экземпляр `List<Base>` нельзя присвоить переменной типа `List<Derived>` (и наоборот).</span><span class="sxs-lookup"><span data-stu-id="e8e13-114">You cannot assign an instance of `List<Base>` to a variable of type `List<Derived>` or vice versa.</span></span>  
  
 <span data-ttu-id="e8e13-115">Параметры ковариантного типа позволяют создавать назначения, которые выглядят очень похоже на обычный [полиморфизм](../../csharp/programming-guide/classes-and-structs/polymorphism.md), как показывает следующий код.</span><span class="sxs-lookup"><span data-stu-id="e8e13-115">Covariant type parameters enable you to make assignments that look much like ordinary [Polymorphism](../../csharp/programming-guide/classes-and-structs/polymorphism.md), as shown in the following code.</span></span>  
  
 [!code-csharp[CoContraSimpleIEnum#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleienum/cs/example.cs#1)]
 [!code-vb[CoContraSimpleIEnum#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleienum/vb/example.vb#1)]  
  
 <span data-ttu-id="e8e13-116">Класс <xref:System.Collections.Generic.List%601> реализует интерфейс <xref:System.Collections.Generic.IEnumerable%601> , поэтому `List<Derived>` (`List(Of Derived)` в Visual Basic) реализует `IEnumerable<Derived>`.</span><span class="sxs-lookup"><span data-stu-id="e8e13-116">The <xref:System.Collections.Generic.List%601> class implements the <xref:System.Collections.Generic.IEnumerable%601> interface, so `List<Derived>` (`List(Of Derived)` in Visual Basic) implements `IEnumerable<Derived>`.</span></span> <span data-ttu-id="e8e13-117">Параметр ковариантного типа делает все остальное.</span><span class="sxs-lookup"><span data-stu-id="e8e13-117">The covariant type parameter does the rest.</span></span>  
  
 <span data-ttu-id="e8e13-118">Контрвариантность, с другой стороны, выглядит нелогичной.</span><span class="sxs-lookup"><span data-stu-id="e8e13-118">Contravariance, on the other hand, seems counterintuitive.</span></span> <span data-ttu-id="e8e13-119">Следующий пример создает делегат типа `Action<Base>` (`Action(Of Base)` в Visual Basic), а затем назначает этот делегат переменной типа `Action<Derived>`.</span><span class="sxs-lookup"><span data-stu-id="e8e13-119">The following example creates a delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic), and then assigns that delegate to a variable of type `Action<Derived>`.</span></span>  
  
 [!code-csharp[CoContraSimpleAction#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleaction/cs/example.cs#1)]
 [!code-vb[CoContraSimpleAction#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleaction/vb/example.vb#1)]  
  
 <span data-ttu-id="e8e13-120">Это может показаться шагом назад, но это типобезопасный код, который компилируется и выполняется.</span><span class="sxs-lookup"><span data-stu-id="e8e13-120">This seems backward, but it is type-safe code that compiles and runs.</span></span> <span data-ttu-id="e8e13-121">Лямбда-выражение соответствует делегату, которому присвоено, и определяет метод, который принимает один параметр типа `Base` и не имеет возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="e8e13-121">The lambda expression matches the delegate it's assigned to, so it defines a method that takes one parameter of type `Base` and that has no return value.</span></span> <span data-ttu-id="e8e13-122">Результирующий делегат может быть присвоен переменной типа `Action<Derived>` , так как параметр типа `T` делегата <xref:System.Action%601> является контравариантным.</span><span class="sxs-lookup"><span data-stu-id="e8e13-122">The resulting delegate can be assigned to a variable of type `Action<Derived>` because the type parameter `T` of the <xref:System.Action%601> delegate is contravariant.</span></span> <span data-ttu-id="e8e13-123">Код является типобезопасным, потому что `T` задает тип параметра.</span><span class="sxs-lookup"><span data-stu-id="e8e13-123">The code is type-safe because `T` specifies a parameter type.</span></span> <span data-ttu-id="e8e13-124">Когда делегат типа `Action<Base>` вызван так, как если бы он был делегатом типа `Action<Derived>`, его аргумент должен быть аргументом типа `Derived`.</span><span class="sxs-lookup"><span data-stu-id="e8e13-124">When the delegate of type `Action<Base>` is invoked as if it were a delegate of type `Action<Derived>`, its argument must be of type `Derived`.</span></span> <span data-ttu-id="e8e13-125">Этот аргумент всегда может быть безопасно передан базовому методу, потому что параметр метода является параметром типа `Base`.</span><span class="sxs-lookup"><span data-stu-id="e8e13-125">This argument can always be passed safely to the underlying method, because the method's parameter is of type `Base`.</span></span>  
  
 <span data-ttu-id="e8e13-126">В общем случае, параметр ковариантного типа может быть использован в качестве возвращаемого типа делегата, и параметры контравариантного типа могут быть использованы в качестве типов параметра.</span><span class="sxs-lookup"><span data-stu-id="e8e13-126">In general, a covariant type parameter can be used as the return type of a delegate, and contravariant type parameters can be used as parameter types.</span></span> <span data-ttu-id="e8e13-127">Для интерфейса параметры ковариантного типа могут быть использованы в качестве возвращаемых типов методов интерфейса, и параметры контравариантного типа могут быть использованы как типы параметра методов интерфейса.</span><span class="sxs-lookup"><span data-stu-id="e8e13-127">For an interface, covariant type parameters can be used as the return types of the interface's methods, and contravariant type parameters can be used as the parameter types of the interface's methods.</span></span>  
  
 <span data-ttu-id="e8e13-128">Вместе ковариантность и контравариантность называются *вариацией*.</span><span class="sxs-lookup"><span data-stu-id="e8e13-128">Covariance and contravariance are collectively referred to as *variance*.</span></span> <span data-ttu-id="e8e13-129">Параметр универсального типа, который не отмечен как ковариантный или контравариантный, называется *инвариантным*.</span><span class="sxs-lookup"><span data-stu-id="e8e13-129">A generic type parameter that is not marked covariant or contravariant is referred to as *invariant*.</span></span> <span data-ttu-id="e8e13-130">Краткие сведения о вариативности в общеязыковой среде выполнения:</span><span class="sxs-lookup"><span data-stu-id="e8e13-130">A brief summary of facts about variance in the common language runtime:</span></span>  
  
- <span data-ttu-id="e8e13-131">Параметры вариантного типа ограничены типами универсального интерфейса и универсального метода-делегата.</span><span class="sxs-lookup"><span data-stu-id="e8e13-131">Variant type parameters are restricted to generic interface and generic delegate types.</span></span>  
  
- <span data-ttu-id="e8e13-132">Тип универсального интерфейса или универсального метода-делегата может иметь как ковариантные, так и контравариантные параметры типа.</span><span class="sxs-lookup"><span data-stu-id="e8e13-132">A generic interface or generic delegate type can have both covariant and contravariant type parameters.</span></span>  
  
- <span data-ttu-id="e8e13-133">Вариативность применяется только к ссылочным типам; если указать тип значения для параметра вариантного типа, этот параметр типа является инвариантным для типа, созданного в результате.</span><span class="sxs-lookup"><span data-stu-id="e8e13-133">Variance applies only to reference types; if you specify a value type for a variant type parameter, that type parameter is invariant for the resulting constructed type.</span></span>  
  
- <span data-ttu-id="e8e13-134">Вариативность не применима к объединению делегатов.</span><span class="sxs-lookup"><span data-stu-id="e8e13-134">Variance does not apply to delegate combination.</span></span> <span data-ttu-id="e8e13-135">Поэтому для заданных двух делегатов типов `Action<Derived>` и `Action<Base>` (`Action(Of Derived)` и `Action(Of Base)` в Visual Basic) нельзя объединять первый делегат со вторым, несмотря на то что результат будет безопасным типом.</span><span class="sxs-lookup"><span data-stu-id="e8e13-135">That is, given two delegates of types `Action<Derived>` and `Action<Base>` (`Action(Of Derived)` and `Action(Of Base)` in Visual Basic), you cannot combine the second delegate with the first although the result would be type safe.</span></span> <span data-ttu-id="e8e13-136">Вариативность позволяет присвоить второй делегат переменной типа `Action<Derived>`, но делегаты можно объединять, только если их типы точно совпадают.</span><span class="sxs-lookup"><span data-stu-id="e8e13-136">Variance allows the second delegate to be assigned to a variable of type `Action<Derived>`, but delegates can combine only if their types match exactly.</span></span>

- <span data-ttu-id="e8e13-137">Начиная с C# 9, поддерживаются ковариантные типы возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="e8e13-137">Starting in C# 9, covariant return types are supported.</span></span> <span data-ttu-id="e8e13-138">В переопределяющем методе может объявляться более производный тип возвращаемого значения, чем в переопределяемом, и для переопределяющего доступного только для чтения свойства может объявляться более производный тип.</span><span class="sxs-lookup"><span data-stu-id="e8e13-138">An overriding method can declare a more derived return type the method it overrides, and an overriding, read-only property can declare a more derived type.</span></span>

<a name="InterfaceCovariantTypeParameters"></a>
## <a name="generic-interfaces-with-covariant-type-parameters"></a><span data-ttu-id="e8e13-139">Универсальные интерфейсы с ковариантными параметрами типа</span><span class="sxs-lookup"><span data-stu-id="e8e13-139">Generic interfaces with covariant type parameters</span></span>

<span data-ttu-id="e8e13-140">Несколько универсальных интерфейсов имеют ковариантные параметры типа, например <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Linq.IQueryable%601> и <xref:System.Linq.IGrouping%602>.</span><span class="sxs-lookup"><span data-stu-id="e8e13-140">Several generic interfaces have covariant type parameters, for example, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Linq.IQueryable%601>, and <xref:System.Linq.IGrouping%602>.</span></span> <span data-ttu-id="e8e13-141">Эти интерфейсы имеют только параметры ковариантного типа. Таким образом, параметры типа используются только для возвращаемых типов в членах.</span><span class="sxs-lookup"><span data-stu-id="e8e13-141">All the type parameters of these interfaces are covariant, so the type parameters are used only for the return types of the members.</span></span>  
  
 <span data-ttu-id="e8e13-142">В следующем примере демонстрируются ковариантные параметры типа.</span><span class="sxs-lookup"><span data-stu-id="e8e13-142">The following example illustrates covariant type parameters.</span></span> <span data-ttu-id="e8e13-143">В примере определяются два типа: `Base` имеет статический метод с именем `PrintBases` , принимающий `IEnumerable<Base>` (`IEnumerable(Of Base)` в Visual Basic) и выводящий эти элементы.</span><span class="sxs-lookup"><span data-stu-id="e8e13-143">The example defines two types: `Base` has a static method named `PrintBases` that takes an `IEnumerable<Base>` (`IEnumerable(Of Base)` in Visual Basic) and prints the elements.</span></span> <span data-ttu-id="e8e13-144">Тип `Derived` наследуется от типа `Base`.</span><span class="sxs-lookup"><span data-stu-id="e8e13-144">`Derived` inherits from `Base`.</span></span> <span data-ttu-id="e8e13-145">В примере создается пустой список `List<Derived>` (`List(Of Derived)` в Visual Basic) и показывается, что этот тип может быть передан методу `PrintBases` и назначен переменной типа `IEnumerable<Base>` без приведения.</span><span class="sxs-lookup"><span data-stu-id="e8e13-145">The example creates an empty `List<Derived>` (`List(Of Derived)` in Visual Basic) and demonstrates that this type can be passed to `PrintBases` and assigned to a variable of type `IEnumerable<Base>` without casting.</span></span> <span data-ttu-id="e8e13-146">Класс<xref:System.Collections.Generic.List%601> реализует интерфейс <xref:System.Collections.Generic.IEnumerable%601>, который имеет единственный параметр ковариантного типа.</span><span class="sxs-lookup"><span data-stu-id="e8e13-146"><xref:System.Collections.Generic.List%601> implements <xref:System.Collections.Generic.IEnumerable%601>, which has a single covariant type parameter.</span></span> <span data-ttu-id="e8e13-147">Параметр ковариантного типа — это причина, по которой экземпляр `IEnumerable<Derived>` может быть использован вместо `IEnumerable<Base>`.</span><span class="sxs-lookup"><span data-stu-id="e8e13-147">The covariant type parameter is the reason why an instance of `IEnumerable<Derived>` can be used instead of `IEnumerable<Base>`.</span></span>  
  
 [!code-csharp[CoContravarianceInClrGenericI#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici/cs/example.cs#1)]
 [!code-vb[CoContravarianceInClrGenericI#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici/vb/example.vb#1)]  
  
## <a name="generic-interfaces-with-contravariant-type-parameters"></a><span data-ttu-id="e8e13-148">Универсальные интерфейсы с контрвариантными параметрами типа</span><span class="sxs-lookup"><span data-stu-id="e8e13-148">Generic interfaces with contravariant type parameters</span></span>

<span data-ttu-id="e8e13-149">Несколько универсальных интерфейсов имеют контрвариантные параметры типа, например <xref:System.Collections.Generic.IComparer%601>, <xref:System.IComparable%601> и <xref:System.Collections.Generic.IEqualityComparer%601>.</span><span class="sxs-lookup"><span data-stu-id="e8e13-149">Several generic interfaces have contravariant type parameters; for example: <xref:System.Collections.Generic.IComparer%601>, <xref:System.IComparable%601>, and <xref:System.Collections.Generic.IEqualityComparer%601>.</span></span> <span data-ttu-id="e8e13-150">Эти интерфейсы имеют только параметры контравариантного типа, таким образом, параметры типа используются только как типы параметра в членах интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="e8e13-150">These interfaces have only contravariant type parameters, so the type parameters are used only as parameter types in the members of the interfaces.</span></span>  
  
 <span data-ttu-id="e8e13-151">В следующем примере демонстрируются контравариантные параметры типа.</span><span class="sxs-lookup"><span data-stu-id="e8e13-151">The following example illustrates contravariant type parameters.</span></span> <span data-ttu-id="e8e13-152">В примере определяется абстрактный (`MustInherit` в Visual Basic) класс `Shape` со свойством `Area` .</span><span class="sxs-lookup"><span data-stu-id="e8e13-152">The example defines an abstract (`MustInherit` in Visual Basic) `Shape` class with an `Area` property.</span></span> <span data-ttu-id="e8e13-153">В примере также определяется класс `ShapeAreaComparer` , реализующий `IComparer<Shape>` (`IComparer(Of Shape)` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="e8e13-153">The example also defines a `ShapeAreaComparer` class that implements `IComparer<Shape>` (`IComparer(Of Shape)` in Visual Basic).</span></span> <span data-ttu-id="e8e13-154">Реализация метода <xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=nameWithType> основывается на значении свойства `Area` , поэтому с помощью `ShapeAreaComparer` можно сортировать объекты `Shape` по областям.</span><span class="sxs-lookup"><span data-stu-id="e8e13-154">The implementation of the <xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=nameWithType> method is based on the value of the `Area` property, so `ShapeAreaComparer` can be used to sort `Shape` objects by area.</span></span>  
  
 <span data-ttu-id="e8e13-155">Класс `Circle` наследует `Shape` и переопределяет `Area`.</span><span class="sxs-lookup"><span data-stu-id="e8e13-155">The `Circle` class inherits `Shape` and overrides `Area`.</span></span> <span data-ttu-id="e8e13-156">В примере создается набор <xref:System.Collections.Generic.SortedSet%601> объектов `Circle` с помощью конструктора, принимающего `IComparer<Circle>` (`IComparer(Of Circle)` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="e8e13-156">The example creates a <xref:System.Collections.Generic.SortedSet%601> of `Circle` objects, using a constructor that takes an `IComparer<Circle>` (`IComparer(Of Circle)` in Visual Basic).</span></span> <span data-ttu-id="e8e13-157">Однако вместо передачи `IComparer<Circle>`, в примере передается объект `ShapeAreaComparer` , реализующий `IComparer<Shape>`.</span><span class="sxs-lookup"><span data-stu-id="e8e13-157">However, instead of passing an `IComparer<Circle>`, the example passes a `ShapeAreaComparer` object, which implements `IComparer<Shape>`.</span></span> <span data-ttu-id="e8e13-158">В примере может передаваться компаратор типа меньшей глубины наследования (`Shape`), когда код вызывает компаратор типа большей глубины наследования (`Circle`), поскольку параметр типа универсального интерфейса <xref:System.Collections.Generic.IComparer%601> контрвариантен.</span><span class="sxs-lookup"><span data-stu-id="e8e13-158">The example can pass a comparer of a less derived type (`Shape`) when the code calls for a comparer of a more derived type (`Circle`), because the type parameter of the <xref:System.Collections.Generic.IComparer%601> generic interface is contravariant.</span></span>  
  
 <span data-ttu-id="e8e13-159">При добавлении нового объекта `Circle` в `SortedSet<Circle>` метод `IComparer<Shape>.Compare` (метод`IComparer(Of Shape).Compare` в Visual Basic) объекта `ShapeAreaComparer` вызывается всякий раз, когда новый элемент сравнивается с существующим элементом.</span><span class="sxs-lookup"><span data-stu-id="e8e13-159">When a new `Circle` object is added to the `SortedSet<Circle>`, the `IComparer<Shape>.Compare` method (`IComparer(Of Shape).Compare` method in Visual Basic) of the `ShapeAreaComparer` object is called each time the new element is compared to an existing element.</span></span> <span data-ttu-id="e8e13-160">Тип параметра метода (`Shape`) является менее производным, чем передаваемый тип (`Circle`), поэтому этот вызов является типобезопасным.</span><span class="sxs-lookup"><span data-stu-id="e8e13-160">The parameter type of the method (`Shape`) is less derived than the type that is being passed (`Circle`), so the call is type safe.</span></span> <span data-ttu-id="e8e13-161">Контрвариантность позволяет объекту `ShapeAreaComparer` сортировать коллекцию какого-либо одного типа, а также смешанную коллекцию типов, унаследованных от `Shape`.</span><span class="sxs-lookup"><span data-stu-id="e8e13-161">Contravariance enables `ShapeAreaComparer` to sort a collection of any single type, as well as a mixed collection of types, that derive from `Shape`.</span></span>  
  
 [!code-csharp[CoContravarianceInClrGenericI2#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici2/cs/example.cs#1)]
 [!code-vb[CoContravarianceInClrGenericI2#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici2/vb/example.vb#1)]  

## <a name="generic-delegates-with-variant-type-parameters"></a><span data-ttu-id="e8e13-162">Универсальные делегаты с параметрами вариантного типа</span><span class="sxs-lookup"><span data-stu-id="e8e13-162">Generic delegates with variant type parameters</span></span>

<span data-ttu-id="e8e13-163">Универсальные методы-делегаты `Func`, такие как <xref:System.Func%602>, имеют ковариантные типы возвращаемого значения и контрвариантные типы параметров.</span><span class="sxs-lookup"><span data-stu-id="e8e13-163">The `Func` generic delegates, such as <xref:System.Func%602>, have covariant return types and contravariant parameter types.</span></span> <span data-ttu-id="e8e13-164">Универсальные методы-делегаты `Action` , такие как <xref:System.Action%602>, имеют контравариантные типы параметров.</span><span class="sxs-lookup"><span data-stu-id="e8e13-164">The `Action` generic delegates, such as <xref:System.Action%602>, have contravariant parameter types.</span></span> <span data-ttu-id="e8e13-165">Это означает, что делегаты можно присваивать переменным, имеющим более производные типы параметров и (в случае универсальных методов-делегатов `Func` ) менее производные возвращаемые типы.</span><span class="sxs-lookup"><span data-stu-id="e8e13-165">This means that the delegates can be assigned to variables that have more derived parameter types and (in the case of the `Func` generic delegates) less derived return types.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e8e13-166">Последний параметр универсального типа универсальных методов-делегатов `Func` указывает тип возвращаемого значения в сигнатуре делегата.</span><span class="sxs-lookup"><span data-stu-id="e8e13-166">The last generic type parameter of the `Func` generic delegates specifies the type of the return value in the delegate signature.</span></span> <span data-ttu-id="e8e13-167">Он является ковариантным (ключевое слово`out` ), в то время как остальные параметры универсального типа являются контравариантными (ключевое слово`in` ).</span><span class="sxs-lookup"><span data-stu-id="e8e13-167">It is covariant (`out` keyword), whereas the other generic type parameters are contravariant (`in` keyword).</span></span>  
  
 <span data-ttu-id="e8e13-168">Это проиллюстрировано в следующем коде.</span><span class="sxs-lookup"><span data-stu-id="e8e13-168">The following code illustrates this.</span></span> <span data-ttu-id="e8e13-169">Первая часть кода определяет класс с именем `Base`, класс с именем `Derived` , наследующий от класса `Base`, и еще один класс с методом типа `static` (`Shared` в Visual Basic) и именем `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="e8e13-169">The first piece of code defines a class named `Base`, a class named `Derived` that inherits `Base`, and another class with a `static` method (`Shared` in Visual Basic) named `MyMethod`.</span></span> <span data-ttu-id="e8e13-170">Этот метод принимает экземпляр класса `Base` и возвращает экземпляр класса `Derived`.</span><span class="sxs-lookup"><span data-stu-id="e8e13-170">The method takes an instance of `Base` and returns an instance of `Derived`.</span></span> <span data-ttu-id="e8e13-171">(Если аргумент является экземпляром класса `Derived`, метод `MyMethod` возвращает его; если аргумент является экземпляром класса `Base`, метод `MyMethod` возвращает новый экземпляр класса `Derived`.) В функции `Main()` примера создается экземпляр `Func<Base, Derived>` (`Func(Of Base, Derived)` в Visual Basic), представляющий метод `MyMethod`, и он сохраняется в переменной `f1`.</span><span class="sxs-lookup"><span data-stu-id="e8e13-171">(If the argument is an instance of `Derived`, `MyMethod` returns it; if the argument is an instance of `Base`, `MyMethod` returns a new instance of `Derived`.) In `Main()`, the example creates an instance of `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic) that represents `MyMethod`, and stores it in the variable `f1`.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#2](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#2)]
 [!code-vb[CoContravarianceDelegates#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#2)]  
  
 <span data-ttu-id="e8e13-172">Вторая часть кода показывает, что делегат может быть присвоен переменной типа `Func<Base, Base>` (`Func(Of Base, Base)` в Visual Basic), так как возвращаемый тип является ковариантным.</span><span class="sxs-lookup"><span data-stu-id="e8e13-172">The second piece of code shows that the delegate can be assigned to a variable of type `Func<Base, Base>` (`Func(Of Base, Base)` in Visual Basic), because the return type is covariant.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#3](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#3)]
 [!code-vb[CoContravarianceDelegates#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#3)]  
  
 <span data-ttu-id="e8e13-173">Третья часть кода показывает, что делегат может быть присвоен переменной типа `Func<Derived, Derived>` (`Func(Of Derived, Derived)` в Visual Basic), так как тип параметра является контравариантным.</span><span class="sxs-lookup"><span data-stu-id="e8e13-173">The third piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Derived>` (`Func(Of Derived, Derived)` in Visual Basic), because the parameter type is contravariant.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#4](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#4)]
 [!code-vb[CoContravarianceDelegates#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#4)]  
  
 <span data-ttu-id="e8e13-174">Заключительная часть кода показывает, что делегат может быть присвоен переменной типа `Func<Derived, Base>` (`Func(Of Derived, Base)` в Visual Basic), объединяя эффекты контравариантного параметра типа и ковариантного возвращаемого типа.</span><span class="sxs-lookup"><span data-stu-id="e8e13-174">The final piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Base>` (`Func(Of Derived, Base)` in Visual Basic), combining the effects of the contravariant parameter type and the covariant return type.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#5](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#5)]
 [!code-vb[CoContravarianceDelegates#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#5)]  
  
### <a name="variance-in-non-generic-delegates"></a><span data-ttu-id="e8e13-175">Вариативность в неуниверсальных делегатах</span><span class="sxs-lookup"><span data-stu-id="e8e13-175">Variance in non-generic delegates</span></span>

 <span data-ttu-id="e8e13-176">В предыдущем коде сигнатура метода `MyMethod` точно соответствует сигнатуре сконструированного универсального делегата: `Func<Base, Derived>` (`Func(Of Base, Derived)` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="e8e13-176">In the preceding code, the signature of `MyMethod` exactly matches the signature of the constructed generic delegate: `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic).</span></span> <span data-ttu-id="e8e13-177">Пример показывает, что этот универсальный делегат может храниться в параметрах переменных или метода, имеющих более производные типы параметров и менее производные возвращаемые типы, при условии, что все типы делегата сконструированы из универсального типа делегата <xref:System.Func%602>.</span><span class="sxs-lookup"><span data-stu-id="e8e13-177">The example shows that this generic delegate can be stored in variables or method parameters that have more derived parameter types and less derived return types, as long as all the delegate types are constructed from the generic delegate type <xref:System.Func%602>.</span></span>  
  
 <span data-ttu-id="e8e13-178">Это важное правило.</span><span class="sxs-lookup"><span data-stu-id="e8e13-178">This is an important point.</span></span> <span data-ttu-id="e8e13-179">Влияние ковариантности и контрвариантности в параметрах типа универсального делегата аналогично влиянию ковариантности и контрвариантности в обыкновенной привязке делегата (см. статьи [Вариативность в делегатах (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md) и [Вариативность в делегатах (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)).</span><span class="sxs-lookup"><span data-stu-id="e8e13-179">The effects of covariance and contravariance in the type parameters of generic delegates are similar to the effects of covariance and contravariance in ordinary delegate binding (see [Variance in Delegates (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md) and [Variance in Delegates (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)).</span></span> <span data-ttu-id="e8e13-180">Однако вариативность в привязке делегата работает для всех типов делегата, а не только с типами универсального метода-делегата, имеющего вариантные параметры типа.</span><span class="sxs-lookup"><span data-stu-id="e8e13-180">However, variance in delegate binding works with all delegate types, not just with generic delegate types that have variant type parameters.</span></span> <span data-ttu-id="e8e13-181">Более того, вариативность в привязке делегата допускает привязку метода к любому делегату, имеющему более строгие типы параметров и менее строгий возвращаемый тип, в то время как назначение универсальных делегатов работает только в том случае, если оба типа делегата сконструированы из одного определения универсального типа.</span><span class="sxs-lookup"><span data-stu-id="e8e13-181">Furthermore, variance in delegate binding enables a method to be bound to any delegate that has more restrictive parameter types and a less restrictive return type, whereas the assignment of generic delegates works only if both delegate types are constructed from the same generic type definition.</span></span>  
  
 <span data-ttu-id="e8e13-182">В следующем примере показан суммарный эффект вариантности в привязке делегата и в параметрах универсального типа.</span><span class="sxs-lookup"><span data-stu-id="e8e13-182">The following example shows the combined effects of variance in delegate binding and variance in generic type parameters.</span></span> <span data-ttu-id="e8e13-183">В примере определяется иерархия типов, содержащая три типа, от наименее производного (`Type1`) до наиболее производного (`Type3`).</span><span class="sxs-lookup"><span data-stu-id="e8e13-183">The example defines a type hierarchy that includes three types, from least derived (`Type1`) to most derived (`Type3`).</span></span> <span data-ttu-id="e8e13-184">Вариантность в обычной привязке делегата используется для привязки метода с типом параметра `Type1` и возвращаемым типом `Type3` к универсальному делегату с типом параметра `Type2` и возвращаемым типом `Type2`.</span><span class="sxs-lookup"><span data-stu-id="e8e13-184">Variance in ordinary delegate binding is used to bind a method with a parameter type of `Type1` and a return type of `Type3` to a generic delegate with a parameter type of `Type2` and a return type of `Type2`.</span></span> <span data-ttu-id="e8e13-185">Получившийся универсальный метод-делегат затем присваивается другой переменной, тип универсального метода-делегата которой имеет тип параметра `Type3` и тип возвращаемого значения `Type1`, с использованием ковариантности и контрвариантности параметров универсального типа.</span><span class="sxs-lookup"><span data-stu-id="e8e13-185">The resulting generic delegate is then assigned to another variable whose generic delegate type has a parameter of type `Type3` and a return type of `Type1`, using the covariance and contravariance of generic type parameters.</span></span> <span data-ttu-id="e8e13-186">Для второго присваивания требуется, чтобы тип переменной и тип делегата были сконструированы из одного определения универсального типа, в данном случае — <xref:System.Func%602>.</span><span class="sxs-lookup"><span data-stu-id="e8e13-186">The second assignment requires both the variable type and the delegate type to be constructed from the same generic type definition, in this case, <xref:System.Func%602>.</span></span>  
  
 [!code-csharp[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/cs/example.cs#1)]
 [!code-vb[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/vb/example.vb#1)]  

## <a name="define-variant-generic-interfaces-and-delegates"></a><span data-ttu-id="e8e13-187">Определение вариантных универсальных интерфейсов и делегатов</span><span class="sxs-lookup"><span data-stu-id="e8e13-187">Define variant generic interfaces and delegates</span></span>

<span data-ttu-id="e8e13-188">Языки Visual Basic и C# содержат ключевые слова, позволяющие помечать параметры универсального типа для интерфейсов и делегатов как ковариантные или контрвариантные.</span><span class="sxs-lookup"><span data-stu-id="e8e13-188">Visual Basic and C# have keywords that enable you to mark the generic type parameters of interfaces and delegates as covariant or contravariant.</span></span>
  
 <span data-ttu-id="e8e13-189">Параметр ковариантного типа помечается ключевым словом `out` (ключевым словом `Out` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="e8e13-189">A covariant type parameter is marked with the `out` keyword (`Out` keyword in Visual Basic).</span></span> <span data-ttu-id="e8e13-190">Параметр ковариантного типа можно использовать как возвращаемое значение метода, принадлежащего интерфейсу, или как возвращаемый тип делегата.</span><span class="sxs-lookup"><span data-stu-id="e8e13-190">You can use a covariant type parameter as the return value of a method that belongs to an interface, or as the return type of a delegate.</span></span> <span data-ttu-id="e8e13-191">Параметр ковариантного типа нельзя использовать как ограничение универсального типа для методов интерфейса.</span><span class="sxs-lookup"><span data-stu-id="e8e13-191">You cannot use a covariant type parameter as a generic type constraint for interface methods.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e8e13-192">Если метод интерфейса имеет параметр с типом универсального метода-делегата, параметр ковариантного типа этого типа интерфейса может использоваться для указания параметра контравариантного типа этого типа делегата.</span><span class="sxs-lookup"><span data-stu-id="e8e13-192">If a method of an interface has a parameter that is a generic delegate type, a covariant type parameter of the interface type can be used to specify a contravariant type parameter of the delegate type.</span></span>  
  
 <span data-ttu-id="e8e13-193">Параметр контрвариантного типа помечается ключевым словом `in` (ключевым словом `In` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="e8e13-193">A contravariant type parameter is marked with the `in` keyword (`In` keyword in Visual Basic).</span></span> <span data-ttu-id="e8e13-194">Параметр контравариантного типа можно использовать как тип параметра метода, принадлежащего интерфейсу, или как тип параметра делегата.</span><span class="sxs-lookup"><span data-stu-id="e8e13-194">You can use a contravariant type parameter as the type of a parameter of a method that belongs to an interface, or as the type of a parameter of a delegate.</span></span> <span data-ttu-id="e8e13-195">Параметр контравариантного типа можно использовать как ограничение универсального типа для метода интерфейса.</span><span class="sxs-lookup"><span data-stu-id="e8e13-195">You can use a contravariant type parameter as a generic type constraint for an interface method.</span></span>  
  
 <span data-ttu-id="e8e13-196">Параметры вариантного типа могут иметь только типы интерфейса и типы делегата.</span><span class="sxs-lookup"><span data-stu-id="e8e13-196">Only interface types and delegate types can have variant type parameters.</span></span> <span data-ttu-id="e8e13-197">Тип интерфейса или тип делегата может иметь как ковариантные, так и контравариантные параметры типа.</span><span class="sxs-lookup"><span data-stu-id="e8e13-197">An interface or delegate type can have both covariant and contravariant type parameters.</span></span>  
  
 <span data-ttu-id="e8e13-198">Языки Visual Basic и C# не позволяют нарушать правила использования параметров ковариантного и контравариантного типов или добавлять заметки ковариантности или контрвариантности в параметры типа, имеющие тип, отличный от интерфейсов и делегатов.</span><span class="sxs-lookup"><span data-stu-id="e8e13-198">Visual Basic and C# do not allow you to violate the rules for using covariant and contravariant type parameters, or to add covariance and contravariance annotations to the type parameters of types other than interfaces and delegates.</span></span>
  
 <span data-ttu-id="e8e13-199">Дополнительные сведения и пример кода см. в разделах [Вариативность в универсальных интерфейсах (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md) и [Вариативность в универсальных интерфейсах (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md).</span><span class="sxs-lookup"><span data-stu-id="e8e13-199">For information and example code, see [Variance in Generic Interfaces (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md) and [Variance in Generic Interfaces (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md).</span></span>  

## <a name="list-of-types"></a><span data-ttu-id="e8e13-200">Список типов</span><span class="sxs-lookup"><span data-stu-id="e8e13-200">List of types</span></span>

<span data-ttu-id="e8e13-201">Перечисленные ниже типы интерфейсов и делегатов имеют параметры ковариантного и/или контрвариантного типа.</span><span class="sxs-lookup"><span data-stu-id="e8e13-201">The following interface and delegate types have covariant and/or contravariant type parameters.</span></span>  
  
|<span data-ttu-id="e8e13-202">Type</span><span class="sxs-lookup"><span data-stu-id="e8e13-202">Type</span></span>|<span data-ttu-id="e8e13-203">Параметры ковариантного типа</span><span class="sxs-lookup"><span data-stu-id="e8e13-203">Covariant type parameters</span></span>|<span data-ttu-id="e8e13-204">Параметры контравариантного типа</span><span class="sxs-lookup"><span data-stu-id="e8e13-204">Contravariant type parameters</span></span>|  
|----------|-------------------------------|-----------------------------------|  
|<span data-ttu-id="e8e13-205"><xref:System.Action%601> — <xref:System.Action%6016></span><span class="sxs-lookup"><span data-stu-id="e8e13-205"><xref:System.Action%601> to <xref:System.Action%6016></span></span>||<span data-ttu-id="e8e13-206">Да</span><span class="sxs-lookup"><span data-stu-id="e8e13-206">Yes</span></span>|  
|<xref:System.Comparison%601>||<span data-ttu-id="e8e13-207">Да</span><span class="sxs-lookup"><span data-stu-id="e8e13-207">Yes</span></span>|  
|<xref:System.Converter%602>|<span data-ttu-id="e8e13-208">Да</span><span class="sxs-lookup"><span data-stu-id="e8e13-208">Yes</span></span>|<span data-ttu-id="e8e13-209">Да</span><span class="sxs-lookup"><span data-stu-id="e8e13-209">Yes</span></span>|  
|<xref:System.Func%601>|<span data-ttu-id="e8e13-210">Да</span><span class="sxs-lookup"><span data-stu-id="e8e13-210">Yes</span></span>||  
|<span data-ttu-id="e8e13-211"><xref:System.Func%602> — <xref:System.Func%6017></span><span class="sxs-lookup"><span data-stu-id="e8e13-211"><xref:System.Func%602> to <xref:System.Func%6017></span></span>|<span data-ttu-id="e8e13-212">Да</span><span class="sxs-lookup"><span data-stu-id="e8e13-212">Yes</span></span>|<span data-ttu-id="e8e13-213">Да</span><span class="sxs-lookup"><span data-stu-id="e8e13-213">Yes</span></span>|  
|<xref:System.IComparable%601>||<span data-ttu-id="e8e13-214">Да</span><span class="sxs-lookup"><span data-stu-id="e8e13-214">Yes</span></span>|  
|<xref:System.Predicate%601>||<span data-ttu-id="e8e13-215">Да</span><span class="sxs-lookup"><span data-stu-id="e8e13-215">Yes</span></span>|  
|<xref:System.Collections.Generic.IComparer%601>||<span data-ttu-id="e8e13-216">Да</span><span class="sxs-lookup"><span data-stu-id="e8e13-216">Yes</span></span>|  
|<xref:System.Collections.Generic.IEnumerable%601>|<span data-ttu-id="e8e13-217">Да</span><span class="sxs-lookup"><span data-stu-id="e8e13-217">Yes</span></span>||  
|<xref:System.Collections.Generic.IEnumerator%601>|<span data-ttu-id="e8e13-218">Да</span><span class="sxs-lookup"><span data-stu-id="e8e13-218">Yes</span></span>||  
|<xref:System.Collections.Generic.IEqualityComparer%601>||<span data-ttu-id="e8e13-219">Да</span><span class="sxs-lookup"><span data-stu-id="e8e13-219">Yes</span></span>|  
|<xref:System.Linq.IGrouping%602>|<span data-ttu-id="e8e13-220">Да</span><span class="sxs-lookup"><span data-stu-id="e8e13-220">Yes</span></span>||  
|<xref:System.Linq.IOrderedEnumerable%601>|<span data-ttu-id="e8e13-221">Да</span><span class="sxs-lookup"><span data-stu-id="e8e13-221">Yes</span></span>||  
|<xref:System.Linq.IOrderedQueryable%601>|<span data-ttu-id="e8e13-222">Да</span><span class="sxs-lookup"><span data-stu-id="e8e13-222">Yes</span></span>||  
|<xref:System.Linq.IQueryable%601>|<span data-ttu-id="e8e13-223">Да</span><span class="sxs-lookup"><span data-stu-id="e8e13-223">Yes</span></span>||  
  
## <a name="see-also"></a><span data-ttu-id="e8e13-224">См. также</span><span class="sxs-lookup"><span data-stu-id="e8e13-224">See also</span></span>

- [<span data-ttu-id="e8e13-225">Ковариация и контрвариантность (C#)</span><span class="sxs-lookup"><span data-stu-id="e8e13-225">Covariance and Contravariance (C#)</span></span>](../../csharp/programming-guide/concepts/covariance-contravariance/index.md)
- [<span data-ttu-id="e8e13-226">Ковариация и контрвариантность (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="e8e13-226">Covariance and Contravariance (Visual Basic)</span></span>](../../visual-basic/programming-guide/concepts/covariance-contravariance/index.md)
- [<span data-ttu-id="e8e13-227">Вариативность в делегатах (C#)</span><span class="sxs-lookup"><span data-stu-id="e8e13-227">Variance in Delegates (C#)</span></span>](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)
- [<span data-ttu-id="e8e13-228">Вариативность в делегатах (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="e8e13-228">Variance in Delegates (Visual Basic)</span></span>](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)
