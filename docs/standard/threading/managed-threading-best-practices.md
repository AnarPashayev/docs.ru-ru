---
title: Рекомендации по работе с потоками
description: Ознакомьтесь с рекомендациями по работе с управляемыми потоками в .NET. Реализуйте сложные ситуации, такие как координация работы нескольких потоков или обработка потоков, вызывающих блокировку.
ms.date: 10/15/2018
dev_langs:
- csharp
- vb
helpviewer_keywords:
- threading [.NET], design guidelines
- threading [.NET], best practices
- managed threading
ms.assetid: e51988e7-7f4b-4646-a06d-1416cee8d557
ms.openlocfilehash: b2a3f2efc12392316f6d90242ef0a9224e7d13a4
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/18/2020
ms.locfileid: "94826317"
---
# <a name="managed-threading-best-practices"></a>Рекомендации по работе с потоками

Многопоточность требует тщательного программирования. Большинство задач можно упростить, поместив запросы на выполнение в очередь по потокам пулов потоков. В этом разделе рассматриваются более сложные ситуации, такие как координация работы нескольких потоков или обработка потоков, вызывающих блокировку.  
  
> [!NOTE]
> Начиная с версии .NET Framework 4, библиотека параллельных задач и PLINQ предоставляют интерфейсы API, которые несколько снижают сложность и риски многопоточного программирования. Дополнительные сведения см. в статье [Параллельное программирование в .NET](../parallel-programming/index.md).  
  
## <a name="deadlocks-and-race-conditions"></a>Взаимоблокировки и состояние гонки  
 Многопоточность позволяет решить проблемы с пропускной способностью и скоростью реагирования, но при этом возникают новые проблемы: взаимоблокировки и конфликты.  
  
### <a name="deadlocks"></a>Взаимоблокировки  
 Взаимоблокировка происходит, когда каждый из двух потоков пытается заблокировать ресурс, уже заблокированный другим потоком. Ни один из потоков не может продолжить работу.  
  
 Многие методы классов управляемых потоков предоставляют значения времени ожидания для обнаружения взаимоблокировок. Например, следующий код пытается получить блокировку для объекта с именем `lockObject`. Если блокировка не будет получена в течение 300 миллисекунд, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> возвратит `false`.  
  
```vb  
If Monitor.TryEnter(lockObject, 300) Then  
    Try  
        ' Place code protected by the Monitor here.  
    Finally  
        Monitor.Exit(lockObject)  
    End Try  
Else  
    ' Code to execute if the attempt times out.  
End If  
```  
  
```csharp  
if (Monitor.TryEnter(lockObject, 300)) {  
    try {  
        // Place code protected by the Monitor here.  
    }  
    finally {  
        Monitor.Exit(lockObject);  
    }  
}  
else {  
    // Code to execute if the attempt times out.  
}  
```  
  
### <a name="race-conditions"></a>Состояние гонки  
 Конфликт — это ошибка, которая возникает, когда результат программы зависит от того, какой из двух или более потоков первым достигнет определенного блока кода. Выполнение программы часто дает различные результаты, и предсказать результат выполнения конкретного запуска невозможно.  
  
 Простой пример состояния гонки — увеличение поля. Предположим, что класс содержит закрытое поле **static** (**Shared** в Visual Basic), которое увеличивается всякий раз при создании класса с помощью кода, например `objCt++;` (в C#) или `objCt += 1` (в Visual Basic). Для этой операции необходимо загрузить значение из `objCt` в регистр, увеличить или уменьшить это значение и сохранить его в `objCt`.  
  
 В многопоточных приложениях поток, загружающий и увеличивающий значение, может быть вытеснен другим потоком, который выполняет все три эти действия; если первый поток возобновляет выполнение и сохраняет его значение, он переопределяет `objCt`, не принимая во внимание тот факт, что в промежутке значение изменилось.  
  
 Конкретно этого состояния гонки можно легко избежать, применяя методы класса <xref:System.Threading.Interlocked>, например <xref:System.Threading.Interlocked.Increment%2A?displayProperty=nameWithType>. Сведения о других технологиях синхронизации данных между несколькими потоками см. в разделе [Синхронизация данных для многопоточности](synchronizing-data-for-multithreading.md).  
  
 Конфликты могут также возникать при синхронизации действий различных потоков. При написании каждой строки кода необходимо учитывать, что может произойти, если поток будет вытеснен другим потоком до ее выполнения (или до одной из индивидуальных машинных команд, составляющих эту строку).  
  
## <a name="static-members-and-static-constructors"></a>Статические члены и статические конструкторы  
 Класс не инициализируется, пока не завершится выполнение его конструктора (конструктор `static` в C# `Shared Sub New` в Visual Basic). Чтобы предотвратить выполнение кода в еще не инициализированном типе, CLR блокирует все вызовы из других потоков для членов класса `static` (члены `Shared` в Visual Basic) до тех пор, пока выполнение конструктора класса не будет завершено.  
  
 Например, если конструктор класса запускает новый поток, а процедура потока вызывает член `static` класса, новый поток блокируется до завершения конструктора класса.  
  
 Это относится к любому типу, который может иметь конструктор `static`.  

## <a name="number-of-processors"></a>Число процессоров

Наличие нескольких процессоров или только одного процессора в системе может повлиять на многопоточную архитектуру. Дополнительные сведения см. в разделе [Количество процессоров](/previous-versions/dotnet/netframework-1.1/1c9txz50(v=vs.71)#number-of-processors).

Используйте свойство <xref:System.Environment.ProcessorCount?displayProperty=nameWithType>, чтобы определить количество процессоров, доступных во время выполнения.
  
## <a name="general-recommendations"></a>Основные рекомендации  
 При использовании нескольких потоков соблюдайте следующие рекомендации:  
  
- Не используйте <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> для завершения других потоков. Вызов метода **Abort** для другого потока аналогичен вызову исключения в этом потоке, когда неизвестно, на каком этапе находится обработка этого потока.  
  
- Не используйте <xref:System.Threading.Thread.Suspend%2A?displayProperty=nameWithType> и <xref:System.Threading.Thread.Resume%2A?displayProperty=nameWithType> для синхронизации действий между потоками. Используйте вместо этого <xref:System.Threading.Mutex>, <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent> и <xref:System.Threading.Monitor>.  
  
- Не контролируйте выполнение рабочих потоков из основной программы (например, с помощью событий). Вместо этого составьте программу так, чтобы рабочие потоки ожидали доступности задания, выполняли его и оповещали другие части программы о его завершении. Если рабочие потоки не блокируются, можно использовать потоки из пула потоков. <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> можно использовать в ситуациях, когда рабочие потоки блокируются.  
  
- Не используйте типы как объекты блокировки. Это означает, что следует избегать кода `lock(typeof(X))` в C# или `SyncLock(GetType(X))` в Visual Basic, а также использования <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> с объектами <xref:System.Type>. Для каждого конкретного типа существует только один экземпляр <xref:System.Type?displayProperty=nameWithType> в каждом домене приложения. Если блокируемый тип является открытым, его может заблокировать чужой код, вызвав тем самым взаимоблокировку. Дополнительные вопросы см. [Рекомендации по обеспечению надежности](../../framework/performance/reliability-best-practices.md).  
  
- Будьте внимательны при блокировке экземпляров, например `lock(this)` в C# или `SyncLock(Me)` в Visual Basic. Если другой код в приложении, который является внешним для типа, заблокирует объект, может возникнуть взаимоблокировка.  
  
- Следите за тем, чтобы каждый поток, который входит в монитор, обязательно вышел из этого монитора, даже если за время, пока поток находится в мониторе, возникает исключение. Оператор C# [lock](../../csharp/language-reference/keywords/lock-statement.md) и оператор Visual Basic [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) делают это автоматически, обеспечивая вызов метода <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> с помощью блока **finally**. Если вы не можете проконтролировать вызов метода **Exit**, включите в свое приложение **мьютекс**. Мьютекс автоматически освобождается, как только прекращается выполнение владеющего им потока.  
  
- Для задач, которые требуют различных ресурсов, используйте несколько потоков и старайтесь не назначать несколько потоков одному ресурсу. Например, любая задача с использованием ввода-вывода выигрывает от наличия собственного потока, поскольку во время операций ввода-вывода этот поток блокируется и, таким образом, разрешает выполнение других потоков. Входные данные пользователя — еще один ресурс, которому пойдет на пользу выделенный поток. На однопроцессорном компьютере задача, требующая активных вычислений, сосуществует с входными данными пользователя и задачами, которые предусматривают операции ввода-вывода, однако несколько ресурсоемких задач могут конкурировать друг с другом.  
  
- Вместо оператора `lock` (`SyncLock` в Visual Basic) для простого изменения состояния лучше использовать методы класса <xref:System.Threading.Interlocked>. Оператор `lock` — хороший универсальный инструмент, но класс <xref:System.Threading.Interlocked> обеспечивает высокую производительность для обновлений, которые должны быть атомарными. Если конкуренции нет, он выполняет внутри единственный префикс lock. При проверке кода ищите код, похожий на показанный в следующих примерах. В первом примере увеличивается переменная состояния:  
  
    ```vb  
    SyncLock lockObject  
        myField += 1  
    End SyncLock  
    ```  
  
    ```csharp  
    lock(lockObject)
    {  
        myField++;  
    }  
    ```  
  
     Вы можете повысить производительность, применяя метод <xref:System.Threading.Interlocked.Increment%2A> вместо оператора `lock`, как показано ниже.  
  
    ```vb  
    System.Threading.Interlocked.Increment(myField)  
    ```  
  
    ```csharp  
    System.Threading.Interlocked.Increment(myField);  
    ```  
  
    > [!NOTE]
    > Используйте метод <xref:System.Threading.Interlocked.Add%2A> для атомарных приращений более 1.  
  
     Во втором примере переменная ссылочного типа обновляется только в том случае, если она является пустой ссылкой (`Nothing` в Visual Basic).  
  
    ```vb  
    If x Is Nothing Then  
        SyncLock lockObject  
            If x Is Nothing Then  
                x = y  
            End If  
        End SyncLock  
    End If  
    ```  
  
    ```csharp  
    if (x == null)  
    {  
        lock (lockObject)  
        {  
            x ??= y;
        }  
    }  
    ```  
  
     Чтобы повысить производительность, применяйте вместо этого метод <xref:System.Threading.Interlocked.CompareExchange%2A>, как показано ниже.  
  
    ```vb  
    System.Threading.Interlocked.CompareExchange(x, y, Nothing)  
    ```  
  
    ```csharp  
    System.Threading.Interlocked.CompareExchange(ref x, y, null);  
    ```  
  
    > [!NOTE]
    > Перегрузка метода <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> предоставляет типобезопасную альтернативу для ссылочных типов.
  
## <a name="recommendations-for-class-libraries"></a>Рекомендации для библиотек классов  
 При разработке библиотек классов для многопоточности необходимо учитывать следующие рекомендации.  
  
- Старайтесь не создавать потребность в синхронизации. Особенно это относится к коду, который используется наиболее часто. Например, алгоритм можно скорректировать таким образом, чтобы он допускал конфликты, а не устранял их. Ненужная синхронизация снижает производительность и может привести к взаимоблокировке и конфликтам.  
  
- Сделайте статические данные (`Shared` в Visual Basic) по умолчанию потокобезопасными.  
  
- Данные экземпляров не должны быть потокобезопасными по умолчанию. Добавление блокировок для создания потокобезопасного кода снижает производительность, увеличивает конфликт блокировки и создает условия для возникновения взаимоблокировок. В обычных моделях приложений пользовательский код одновременно выполняется только одним потоком, что уменьшает необходимость потокобезопасности. По этой причине библиотеки классов .NET не являются потокобезопасными по умолчанию.  
  
- Не предоставляйте статические методы, изменяющие статическое состояние. В обычных сценариях сервера статическое состояние используется запросами совместно, а значит, код одновременно могут выполнять сразу несколько потоков. Это открывает возможность для появления потоковых ошибок. Попробуйте применить конструктивный шаблон, инкапсулирующий данные в экземпляры, которые не являются общими для запросов. Кроме того, если статические данные синхронизируются, вызовы между статическими методами, изменяющие состояние, могут приводить к взаимоблокировкам или избыточной синхронизации, что, в свою очередь, снижает производительность.  
  
## <a name="see-also"></a>См. также

- [Работа с потоками](index.md)
- [Потоки и работа с потоками](threads-and-threading.md)
