---
title: Отмена в управляемых потоках
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- cancellation in .NET, overview
ms.assetid: eea11fe5-d8b0-4314-bb5d-8a58166fb1c3
ms.openlocfilehash: d4bbf30923d65ad7aeced80efa626136ae27491b
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/15/2020
ms.locfileid: "73138139"
---
# <a name="cancellation-in-managed-threads"></a><span data-ttu-id="98345-102">Отмена в управляемых потоках</span><span class="sxs-lookup"><span data-stu-id="98345-102">Cancellation in Managed Threads</span></span>
<span data-ttu-id="98345-103">В .NET Framework 4 введена новая универсальная модель совместной отмены асинхронных или долго выполняющихся синхронных операций.</span><span class="sxs-lookup"><span data-stu-id="98345-103">Starting with the .NET Framework 4, the .NET Framework uses a unified model for cooperative cancellation of asynchronous or long-running synchronous operations.</span></span> <span data-ttu-id="98345-104">Эта модель построена на простом объекте, называемом токеном отмены.</span><span class="sxs-lookup"><span data-stu-id="98345-104">This model is based on a lightweight object called a cancellation token.</span></span> <span data-ttu-id="98345-105">Объект, который вызывает одну или несколько отменяемых операций, например, путем создания новых потоков или задач, передает этот токен в каждую операцию.</span><span class="sxs-lookup"><span data-stu-id="98345-105">The object that invokes one or more cancelable operations, for example by creating new threads or tasks, passes the token to each operation.</span></span> <span data-ttu-id="98345-106">Операция, в свою очередь, передает копии этого токена в другие операции.</span><span class="sxs-lookup"><span data-stu-id="98345-106">Individual operations can in turn pass copies of the token to other operations.</span></span> <span data-ttu-id="98345-107">Некоторое время спустя объект, создавший токен, может использовать его для запроса остановки выполнения операции.</span><span class="sxs-lookup"><span data-stu-id="98345-107">At some later time, the object that created the token can use it to request that the operations stop what they are doing.</span></span> <span data-ttu-id="98345-108">Запрос на отмену может создавать только запрашивающий объект, и каждый прослушиватель должен обнаружить этот запрос, чтобы правильно и своевременно отреагировать на него.</span><span class="sxs-lookup"><span data-stu-id="98345-108">Only the requesting object can issue the cancellation request, and each listener is responsible for noticing the request and responding to it in an appropriate and timely manner.</span></span>  
  
 <span data-ttu-id="98345-109">Общая схема реализации модели совместной отмены выглядит следующим образом:</span><span class="sxs-lookup"><span data-stu-id="98345-109">The general pattern for implementing the cooperative cancellation model is:</span></span>  
  
- <span data-ttu-id="98345-110">Создается экземпляр объекта <xref:System.Threading.CancellationTokenSource>, который управляет уведомлениями об отмене и передает их отдельным токенам отмены.</span><span class="sxs-lookup"><span data-stu-id="98345-110">Instantiate a <xref:System.Threading.CancellationTokenSource> object, which manages and sends cancellation notification to the individual cancellation tokens.</span></span>  
  
- <span data-ttu-id="98345-111">В каждую задачу или поток, ожидающий отмены, передается токен, возвращенный свойством <xref:System.Threading.CancellationTokenSource.Token%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="98345-111">Pass the token returned by the <xref:System.Threading.CancellationTokenSource.Token%2A?displayProperty=nameWithType> property to each task or thread that listens for cancellation.</span></span>  
  
- <span data-ttu-id="98345-112">Каждой задачи или каждому потоку предоставляется механизм реагирования на отмену.</span><span class="sxs-lookup"><span data-stu-id="98345-112">Provide a mechanism for each task or thread to respond to cancellation.</span></span>  
  
- <span data-ttu-id="98345-113">Вызывается метод <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> для предоставления уведомления об отмене.</span><span class="sxs-lookup"><span data-stu-id="98345-113">Call the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method to provide notification of cancellation.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="98345-114">Класс <xref:System.Threading.CancellationTokenSource> реализует интерфейс <xref:System.IDisposable>.</span><span class="sxs-lookup"><span data-stu-id="98345-114">The <xref:System.Threading.CancellationTokenSource> class implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="98345-115">По завершении использования источника токена отмены обязательно вызовите метод <xref:System.Threading.CancellationTokenSource.Dispose%2A?displayProperty=nameWithType>, чтобы освободить все занятые неуправляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="98345-115">You should be sure to call the <xref:System.Threading.CancellationTokenSource.Dispose%2A?displayProperty=nameWithType> method when you have finished using the cancellation token source to free any unmanaged resources it holds.</span></span>  
  
 <span data-ttu-id="98345-116">На рисунке ниже показана связь между источником токена и всеми копиями токена.</span><span class="sxs-lookup"><span data-stu-id="98345-116">The following illustration shows the relationship between a token source and all the copies of its token.</span></span>  
  
 <span data-ttu-id="98345-117">![CancellationTokenSource и токены отмены](../../../docs/standard/threading/media/vs-cancellationtoken.png "VS_CancellationToken")</span><span class="sxs-lookup"><span data-stu-id="98345-117">![CancellationTokenSource and cancellation tokens](../../../docs/standard/threading/media/vs-cancellationtoken.png "VS_CancellationToken")</span></span>  
  
 <span data-ttu-id="98345-118">Новая модель отмены упрощает создание приложений и библиотек, поддерживающих отмену. Она также поддерживает перечисленные ниже возможности.</span><span class="sxs-lookup"><span data-stu-id="98345-118">The new cancellation model makes it easier to create cancellation-aware applications and libraries, and it supports the following features:</span></span>  
  
- <span data-ttu-id="98345-119">Отмена является совместной и не осуществляется принудительно на прослушивателе.</span><span class="sxs-lookup"><span data-stu-id="98345-119">Cancellation is cooperative and is not forced on the listener.</span></span> <span data-ttu-id="98345-120">Прослушиватель сам определяет порядок корректного завершения в ответ на запрос отмены.</span><span class="sxs-lookup"><span data-stu-id="98345-120">The listener determines how to gracefully terminate in response to a cancellation request.</span></span>  
  
- <span data-ttu-id="98345-121">Запрос осуществляется отдельно от прослушивания.</span><span class="sxs-lookup"><span data-stu-id="98345-121">Requesting is distinct from listening.</span></span> <span data-ttu-id="98345-122">Объект, который вызывает отменяемую операцию, может управлять временем создания запроса отмены (а также самим фактом создания подобного запроса).</span><span class="sxs-lookup"><span data-stu-id="98345-122">An object that invokes a cancelable operation can control when (if ever) cancellation is requested.</span></span>  
  
- <span data-ttu-id="98345-123">Запрашивающий объект создает запрос на отмену для всех копий токена, используя только один вызов метода.</span><span class="sxs-lookup"><span data-stu-id="98345-123">The requesting object issues the cancellation request to all copies of the token by using just one method call.</span></span>  
  
- <span data-ttu-id="98345-124">Прослушиватель может одновременно ожидать несколько маркеров, объединив их в один *связанный маркер*.</span><span class="sxs-lookup"><span data-stu-id="98345-124">A listener can listen to multiple tokens simultaneously by joining them into one *linked token*.</span></span>  
  
- <span data-ttu-id="98345-125">Пользовательский код может отслеживать запросы на отмену из кода библиотеки и реагировать на них, а код библиотеки, в свою очередь, может отслеживать запросы на отмену из пользовательского кода и реагировать на них.</span><span class="sxs-lookup"><span data-stu-id="98345-125">User code can notice and respond to cancellation requests from library code, and library code can notice and respond to cancellation requests from user code.</span></span>  
  
- <span data-ttu-id="98345-126">Для уведомления прослушивателей о запросах на отмену может использоваться опрос, регистрация обратных вызовов или ожидание дескрипторов ожидания.</span><span class="sxs-lookup"><span data-stu-id="98345-126">Listeners can be notified of cancellation requests by polling, callback registration, or waiting on wait handles.</span></span>  
  
## <a name="cancellation-types"></a><span data-ttu-id="98345-127">Типы отмены</span><span class="sxs-lookup"><span data-stu-id="98345-127">Cancellation Types</span></span>  
 <span data-ttu-id="98345-128">Инфраструктура отмены реализована в виде набора связанных типов, приведенных в таблице ниже.</span><span class="sxs-lookup"><span data-stu-id="98345-128">The cancellation framework is implemented as a set of related types, which are listed in the following table.</span></span>  
  
|<span data-ttu-id="98345-129">Имя типа</span><span class="sxs-lookup"><span data-stu-id="98345-129">Type name</span></span>|<span data-ttu-id="98345-130">Описание</span><span class="sxs-lookup"><span data-stu-id="98345-130">Description</span></span>|  
|---------------|-----------------|  
|<xref:System.Threading.CancellationTokenSource>|<span data-ttu-id="98345-131">Объект, который создает токен отмены и запрос на отмену для всех копий этого токена.</span><span class="sxs-lookup"><span data-stu-id="98345-131">Object that creates a cancellation token, and also issues the cancellation request for all copies of that token.</span></span>|  
|<xref:System.Threading.CancellationToken>|<span data-ttu-id="98345-132">Простой тип значения, передаваемый одному или нескольким прослушивателям, обычно в виде параметра метода.</span><span class="sxs-lookup"><span data-stu-id="98345-132">Lightweight value type passed to one or more listeners, typically as a method parameter.</span></span> <span data-ttu-id="98345-133">Прослушиватели отслеживают значение свойства `IsCancellationRequested` токена посредством опроса, обратного вызова или дескриптора ожидания.</span><span class="sxs-lookup"><span data-stu-id="98345-133">Listeners monitor the value of the `IsCancellationRequested` property of the token by polling, callback, or wait handle.</span></span>|  
|<xref:System.OperationCanceledException>|<span data-ttu-id="98345-134">Перегрузки конструктора этого исключения принимают <xref:System.Threading.CancellationToken> в качестве параметра.</span><span class="sxs-lookup"><span data-stu-id="98345-134">Overloads of this exception's constructor accept a <xref:System.Threading.CancellationToken> as a parameter.</span></span> <span data-ttu-id="98345-135">Прослушиватели могут также создавать это исключение для проверки источника отмены и уведомления остальных прослушивателей об ответе на запрос отмены.</span><span class="sxs-lookup"><span data-stu-id="98345-135">Listeners can optionally throw this exception to verify the source of the cancellation and notify others that it has responded to a cancellation request.</span></span>|  
  
 <span data-ttu-id="98345-136">Новая модель отмены интегрирована в несколько типов .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="98345-136">The new cancellation model is integrated into the .NET Framework in several types.</span></span> <span data-ttu-id="98345-137">Наиболее важные из них — <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> и <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="98345-137">The most important ones are <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> and <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType>.</span></span> <span data-ttu-id="98345-138">Мы рекомендуем использовать именно эту новую модель отмены в коде всех новых библиотек и приложений.</span><span class="sxs-lookup"><span data-stu-id="98345-138">We recommend that you use this new cancellation model for all new library and application code.</span></span>  
  
## <a name="code-example"></a><span data-ttu-id="98345-139">Пример кода</span><span class="sxs-lookup"><span data-stu-id="98345-139">Code Example</span></span>  
 <span data-ttu-id="98345-140">В примере ниже запрашивающий объект создает объект <xref:System.Threading.CancellationTokenSource>, а затем передает его свойство <xref:System.Threading.CancellationTokenSource.Token%2A> в отменяемую операцию.</span><span class="sxs-lookup"><span data-stu-id="98345-140">In the following example, the requesting object creates a <xref:System.Threading.CancellationTokenSource> object, and then passes its <xref:System.Threading.CancellationTokenSource.Token%2A> property to the cancelable operation.</span></span> <span data-ttu-id="98345-141">Операция, получающая запрос, отслеживает значение свойства <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> токена путем опроса.</span><span class="sxs-lookup"><span data-stu-id="98345-141">The operation that receives the request monitors the value of the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property of the token by polling.</span></span> <span data-ttu-id="98345-142">Когда свойство принимает значение `true`, прослушиватель может завершить операцию любым приемлемым способом.</span><span class="sxs-lookup"><span data-stu-id="98345-142">When the value becomes `true`, the listener can terminate in whatever manner is appropriate.</span></span> <span data-ttu-id="98345-143">В этом примере просто выполняется выход из метода. Во многих случаях этого достаточно.</span><span class="sxs-lookup"><span data-stu-id="98345-143">In this example, the method just exits, which is all that is required in many cases.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="98345-144">В этом примере метод <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> используется для демонстрации совместимости новой инфраструктуры отмены с устаревшими интерфейсами API.</span><span class="sxs-lookup"><span data-stu-id="98345-144">The example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to demonstrate that the new cancellation framework is compatible with legacy APIs.</span></span> <span data-ttu-id="98345-145">Пример, в котором используется новый предпочтительный тип <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>, см. в разделе [Руководство. Отмена задачи и ее дочерних элементов](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).</span><span class="sxs-lookup"><span data-stu-id="98345-145">For an example that uses the new, preferred <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> type, see [How to: Cancel a Task and Its Children](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).</span></span>  
  
 [!code-csharp[Cancellation#1](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex1.cs#1)]
 [!code-vb[Cancellation#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex1.vb#1)]  
  
## <a name="operation-cancellation-versus-object-cancellation"></a><span data-ttu-id="98345-146">Отмена операции и отмена объекта</span><span class="sxs-lookup"><span data-stu-id="98345-146">Operation Cancellation Versus Object Cancellation</span></span>  
 <span data-ttu-id="98345-147">В рамках новой инфраструктуры отмены осуществляется отмена операций, а не объектов.</span><span class="sxs-lookup"><span data-stu-id="98345-147">In the new cancellation framework, cancellation refers to operations, not objects.</span></span> <span data-ttu-id="98345-148">Запрос на отмену означает, что операция должна быть остановлена как можно скорее после выполнения всех необходимых очисток.</span><span class="sxs-lookup"><span data-stu-id="98345-148">The cancellation request means that the operation should stop as soon as possible after any required cleanup is performed.</span></span> <span data-ttu-id="98345-149">Один токен отмены должен относиться к одной отменяемой операции, однако эта операция может быть реализована в программе.</span><span class="sxs-lookup"><span data-stu-id="98345-149">One cancellation token should refer to one "cancelable operation," however that operation may be implemented in your program.</span></span> <span data-ttu-id="98345-150">После того как свойство <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> токена примет значение `true`, для него невозможно будет восстановить значение `false`.</span><span class="sxs-lookup"><span data-stu-id="98345-150">After the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property of the token has been set to `true`, it cannot be reset to `false`.</span></span> <span data-ttu-id="98345-151">Поэтому токены отмены нельзя использовать повторно после отмены.</span><span class="sxs-lookup"><span data-stu-id="98345-151">Therefore, cancellation tokens cannot be reused after they have been canceled.</span></span>  
  
 <span data-ttu-id="98345-152">Если вам необходим механизм отмены объектов, его можно построить на основе механизма отмены операций путем вызова метода <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType>, как показано в примере ниже.</span><span class="sxs-lookup"><span data-stu-id="98345-152">If you require an object cancellation mechanism, you can base it on the operation cancellation mechanism by calling the <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> method, as shown in the following example.</span></span>  
  
 [!code-csharp[Cancellation#2](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/objectcancellation1.cs#2)]
 [!code-vb[Cancellation#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/objectcancellation1.vb#2)]  
  
 <span data-ttu-id="98345-153">Если объект поддерживает несколько параллельных отменяемых операций, в каждую отменяемую операцию следует передавать отдельный токен.</span><span class="sxs-lookup"><span data-stu-id="98345-153">If an object supports more than one concurrent cancelable operation, pass a separate token as input to each distinct cancelable operation.</span></span> <span data-ttu-id="98345-154">Это позволяет отменить одну операцию, не затрагивая при этом остальные.</span><span class="sxs-lookup"><span data-stu-id="98345-154">That way, one operation can be cancelled without affecting the others.</span></span>  
  
## <a name="listening-and-responding-to-cancellation-requests"></a><span data-ttu-id="98345-155">Прослушивание запросов на отмену и ответ на них</span><span class="sxs-lookup"><span data-stu-id="98345-155">Listening and Responding to Cancellation Requests</span></span>  
 <span data-ttu-id="98345-156">Объект, реализующий отменяемую операцию, в пользовательском делегате определяет способ завершения операции в ответ на запрос отмены.</span><span class="sxs-lookup"><span data-stu-id="98345-156">In the user delegate, the implementer of a cancelable operation determines how to terminate the operation in response to a cancellation request.</span></span> <span data-ttu-id="98345-157">Во многих случаях пользовательский делегат может выполнить необходимую очистку, а затем немедленный возврат.</span><span class="sxs-lookup"><span data-stu-id="98345-157">In many cases, the user delegate can just perform any required cleanup and then return immediately.</span></span>  
  
 <span data-ttu-id="98345-158">Однако в более сложных случаях может потребоваться, чтобы пользовательский делегат уведомлял код библиотеки об отмене.</span><span class="sxs-lookup"><span data-stu-id="98345-158">However, in more complex cases, it might be necessary for the user delegate to notify library code that cancellation has occurred.</span></span> <span data-ttu-id="98345-159">В таких случаях, чтобы правильно завершить операцию, следует вызвать из делегата метод <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A>, который создает исключение <xref:System.OperationCanceledException>.</span><span class="sxs-lookup"><span data-stu-id="98345-159">In such cases, the correct way to terminate the operation is for the delegate to call the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A>, method, which will cause an <xref:System.OperationCanceledException> to be thrown.</span></span> <span data-ttu-id="98345-160">Код библиотеки может перехватить это исключение в потоке пользовательского делегата и проверить токен исключения, чтобы определить, указывает ли исключение на совместную отмену или возникновение другой исключительной ситуации.</span><span class="sxs-lookup"><span data-stu-id="98345-160">Library code can catch this exception on the user delegate thread and examine the exception's token to determine whether the exception indicates cooperative cancellation or some other exceptional situation.</span></span>  
  
 <span data-ttu-id="98345-161">Класс <xref:System.Threading.Tasks.Task> обрабатывает <xref:System.OperationCanceledException> таким образом.</span><span class="sxs-lookup"><span data-stu-id="98345-161">The <xref:System.Threading.Tasks.Task> class handles <xref:System.OperationCanceledException> in this way.</span></span> <span data-ttu-id="98345-162">Дополнительные сведения см. в разделе [Отмена задач](../../../docs/standard/parallel-programming/task-cancellation.md).</span><span class="sxs-lookup"><span data-stu-id="98345-162">For more information, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md).</span></span>  
  
### <a name="listening-by-polling"></a><span data-ttu-id="98345-163">Прослушивание с помощью опросов</span><span class="sxs-lookup"><span data-stu-id="98345-163">Listening by Polling</span></span>  
 <span data-ttu-id="98345-164">Для длительных циклических или рекурсивных вычислений можно прослушивать запрос на отмену путем периодического опроса значения свойства <xref:System.Threading.CancellationToken.IsCancellationRequested%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="98345-164">For long-running computations that loop or recurse, you can listen for a cancellation request by periodically polling the value of the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="98345-165">Если его значение равно `true`, метод должен максимально быстро выполнить очистку и завершение.</span><span class="sxs-lookup"><span data-stu-id="98345-165">If its value is `true`, the method should clean up and terminate as quickly as possible.</span></span> <span data-ttu-id="98345-166">Оптимальная частота опроса зависит от типа приложения.</span><span class="sxs-lookup"><span data-stu-id="98345-166">The optimal frequency of polling depends on the type of application.</span></span> <span data-ttu-id="98345-167">Разработчик должен определить оптимальную частоту опроса для конкретной программы.</span><span class="sxs-lookup"><span data-stu-id="98345-167">It is up to the developer to determine the best polling frequency for any given program.</span></span> <span data-ttu-id="98345-168">Сам по себе опрос не оказывает значительного влияния на производительность.</span><span class="sxs-lookup"><span data-stu-id="98345-168">Polling itself does not significantly impact performance.</span></span> <span data-ttu-id="98345-169">В примере ниже показан один из возможных способов опроса.</span><span class="sxs-lookup"><span data-stu-id="98345-169">The following example shows one possible way to poll.</span></span>  
  
 [!code-csharp[Cancellation#3](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex11.cs#3)]
 [!code-vb[Cancellation#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex11.vb#3)]  
  
 <span data-ttu-id="98345-170">Более полный пример см. в подразделе [Практическое руководство. Прослушивание запросов на отмену посредством опросов](../../../docs/standard/threading/how-to-listen-for-cancellation-requests-by-polling.md).</span><span class="sxs-lookup"><span data-stu-id="98345-170">For a more complete example, see [How to: Listen for Cancellation Requests by Polling](../../../docs/standard/threading/how-to-listen-for-cancellation-requests-by-polling.md).</span></span>  
  
### <a name="listening-by-registering-a-callback"></a><span data-ttu-id="98345-171">Прослушивание путем регистрации обратного вызова</span><span class="sxs-lookup"><span data-stu-id="98345-171">Listening by Registering a Callback</span></span>  
 <span data-ttu-id="98345-172">Некоторые операции могут быть заблокированы таким образом, при котором невозможно своевременно проверить значение токена отмены.</span><span class="sxs-lookup"><span data-stu-id="98345-172">Some operations can become blocked in such a way that they cannot check the value of the cancellation token in a timely manner.</span></span> <span data-ttu-id="98345-173">В этих случаях можно зарегистрировать метод обратного вызова, который разблокирует метод при получении запроса на отмену.</span><span class="sxs-lookup"><span data-stu-id="98345-173">For these cases, you can register a callback method that unblocks the method when a cancellation request is received.</span></span>  
  
 <span data-ttu-id="98345-174">Метод <xref:System.Threading.CancellationToken.Register%2A> возвращает объект <xref:System.Threading.CancellationTokenRegistration>, который используется специально в этих целях.</span><span class="sxs-lookup"><span data-stu-id="98345-174">The <xref:System.Threading.CancellationToken.Register%2A> method returns a <xref:System.Threading.CancellationTokenRegistration> object that is used specifically for this purpose.</span></span> <span data-ttu-id="98345-175">В примере ниже показано, как использовать метод <xref:System.Threading.CancellationToken.Register%2A> для отмены асинхронного веб-запроса.</span><span class="sxs-lookup"><span data-stu-id="98345-175">The following example shows how to use the <xref:System.Threading.CancellationToken.Register%2A> method to cancel an asynchronous Web request.</span></span>  
  
 [!code-csharp[Cancellation#4](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex4.cs#4)]
 [!code-vb[Cancellation#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex4.vb#4)]  
  
 <span data-ttu-id="98345-176">Объект <xref:System.Threading.CancellationTokenRegistration> управляет синхронизацией потока и обеспечивает прекращение выполнения обратного вызова в определенный момент времени.</span><span class="sxs-lookup"><span data-stu-id="98345-176">The <xref:System.Threading.CancellationTokenRegistration> object manages thread synchronization and ensures that the callback will stop executing at a precise point in time.</span></span>  
  
 <span data-ttu-id="98345-177">Чтобы обеспечить отклик системы и предотвратить взаимоблокировки, при регистрации обратных вызовов необходимо следовать приведенным ниже рекомендациям.</span><span class="sxs-lookup"><span data-stu-id="98345-177">In order to ensure system responsiveness and to avoid deadlocks, the following guidelines must be followed when registering callbacks:</span></span>  
  
- <span data-ttu-id="98345-178">Метод обратного вызова должен быть быстрым, так как он вызывается синхронно и поэтому возврат вызова <xref:System.Threading.CancellationTokenSource.Cancel%2A> будет выполнен после возврата из функции обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="98345-178">The callback method should be fast because it is called synchronously and therefore the call to <xref:System.Threading.CancellationTokenSource.Cancel%2A> does not return until the callback returns.</span></span>  
  
- <span data-ttu-id="98345-179">Если вы вызываете <xref:System.Threading.CancellationTokenRegistration.Dispose%2A> во время выполнения обратного вызова и удерживаете блокировку, которую ожидает функция обратного вызова, в программе может произойти взаимоблокировка.</span><span class="sxs-lookup"><span data-stu-id="98345-179">If you call <xref:System.Threading.CancellationTokenRegistration.Dispose%2A> while the callback is running, and you hold a lock that the callback is waiting on, your program can deadlock.</span></span> <span data-ttu-id="98345-180">После завершения работы метода `Dispose` можно освобождать любые ресурсы, которые необходимы для обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="98345-180">After `Dispose` returns, you can free any resources required by the callback.</span></span>  
  
- <span data-ttu-id="98345-181">Обратные вызовы не должны обрабатывать какие-либо ручные потоки или использовать <xref:System.Threading.SynchronizationContext> в обратном вызове.</span><span class="sxs-lookup"><span data-stu-id="98345-181">Callbacks should not perform any manual thread or <xref:System.Threading.SynchronizationContext> usage in a callback.</span></span> <span data-ttu-id="98345-182">Если обратный вызов должен выполняться в определенном потоке, используйте конструктор <xref:System.Threading.CancellationTokenRegistration?displayProperty=nameWithType>, который позволяет задать активный объект <xref:System.Threading.SynchronizationContext.Current%2A?displayProperty=nameWithType> в качестве целевого объекта syncContext.</span><span class="sxs-lookup"><span data-stu-id="98345-182">If a callback must run on a particular thread, use the <xref:System.Threading.CancellationTokenRegistration?displayProperty=nameWithType> constructor that enables you to specify that the target syncContext is the active <xref:System.Threading.SynchronizationContext.Current%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="98345-183">Выполнение ручного потока в обратном вызове может привести к взаимоблокировке.</span><span class="sxs-lookup"><span data-stu-id="98345-183">Performing manual threading in a callback can cause deadlock.</span></span>  
  
 <span data-ttu-id="98345-184">Более полный пример см. в подразделе [Практическое руководство. Регистрация обратных вызовов для запросов на отмену](../../../docs/standard/threading/how-to-register-callbacks-for-cancellation-requests.md).</span><span class="sxs-lookup"><span data-stu-id="98345-184">For a more complete example, see [How to: Register Callbacks for Cancellation Requests](../../../docs/standard/threading/how-to-register-callbacks-for-cancellation-requests.md).</span></span>  
  
### <a name="listening-by-using-a-wait-handle"></a><span data-ttu-id="98345-185">Прослушивание с помощью дескриптора ожидания</span><span class="sxs-lookup"><span data-stu-id="98345-185">Listening by Using a Wait Handle</span></span>  
 <span data-ttu-id="98345-186">В случаях, когда отменяемая операция может блокироваться на время ожидания примитива синхронизации, такого как <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> или <xref:System.Threading.Semaphore?displayProperty=nameWithType>, можно с помощью свойства <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType> включить ожидание операцией как этого события, так и запроса на отмену.</span><span class="sxs-lookup"><span data-stu-id="98345-186">When a cancelable operation can block while it waits on a synchronization primitive such as a <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> or <xref:System.Threading.Semaphore?displayProperty=nameWithType>, you can use the <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType> property to enable the operation to wait on both the event and the cancellation request.</span></span> <span data-ttu-id="98345-187">Дескриптору ожидания токена отмены будет отправлен сигнал в ответ на запрос отмены, и метод сможет с помощью возвращаемого значения метода <xref:System.Threading.WaitHandle.WaitAny%2A> определить, был ли этот сигнал отправлен токеном отмены.</span><span class="sxs-lookup"><span data-stu-id="98345-187">The wait handle of the cancellation token will become signaled in response to a cancellation request, and the method can use the return value of the <xref:System.Threading.WaitHandle.WaitAny%2A> method to determine whether it was the cancellation token that signaled.</span></span> <span data-ttu-id="98345-188">Затем операция может выполнить выход или создать исключение <xref:System.OperationCanceledException> в зависимости от ситуации.</span><span class="sxs-lookup"><span data-stu-id="98345-188">The operation can then just exit, or throw a <xref:System.OperationCanceledException>, as appropriate.</span></span>  
  
 [!code-csharp[Cancellation#5](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex9.cs#5)]
 [!code-vb[Cancellation#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex9.vb#5)]  
  
 <span data-ttu-id="98345-189">В новом коде, предназначенном для .NET Framework 4, классы <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> и <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> обеспечивают поддержку новой инфраструктуры отмены в методах `Wait`.</span><span class="sxs-lookup"><span data-stu-id="98345-189">In new code that targets the .NET Framework 4, <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> and <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> both support the new cancellation framework in their `Wait` methods.</span></span> <span data-ttu-id="98345-190">Вы можете передать этому методу <xref:System.Threading.CancellationToken>, и тогда это событие активируется и создает исключение <xref:System.OperationCanceledException>, когда поступает запрос на отмену.</span><span class="sxs-lookup"><span data-stu-id="98345-190">You can pass the <xref:System.Threading.CancellationToken> to the method, and when the cancellation is requested, the event wakes up and throws an <xref:System.OperationCanceledException>.</span></span>  
  
 [!code-csharp[Cancellation#6](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex10.cs#6)]
 [!code-vb[Cancellation#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex10.vb#6)]  
  
 <span data-ttu-id="98345-191">Более полный пример см. в подразделе [Практическое руководство. Прослушивание запросов на отмену, содержащих дескрипторы ожидания](../../../docs/standard/threading/how-to-listen-for-cancellation-requests-that-have-wait-handles.md).</span><span class="sxs-lookup"><span data-stu-id="98345-191">For a more complete example, see [How to: Listen for Cancellation Requests That Have Wait Handles](../../../docs/standard/threading/how-to-listen-for-cancellation-requests-that-have-wait-handles.md).</span></span>  
  
### <a name="listening-to-multiple-tokens-simultaneously"></a><span data-ttu-id="98345-192">Одновременное прослушивание нескольких токенов</span><span class="sxs-lookup"><span data-stu-id="98345-192">Listening to Multiple Tokens Simultaneously</span></span>  
 <span data-ttu-id="98345-193">В некоторых случаях прослушивателю может требоваться одновременного прослушивать несколько токенов отмены.</span><span class="sxs-lookup"><span data-stu-id="98345-193">In some cases, a listener may have to listen to multiple cancellation tokens simultaneously.</span></span> <span data-ttu-id="98345-194">Например, отменяемая операция может в дополнение к токену отмены, переданному извне в качестве аргумента в параметр метода, отслеживать также внутренний токен отмены.</span><span class="sxs-lookup"><span data-stu-id="98345-194">For example, a cancelable operation may have to monitor an internal cancellation token in addition to a token passed in externally as an argument to a method parameter.</span></span> <span data-ttu-id="98345-195">Для этого создайте источник связанных токенов, который может объединять два или более токенов в один, как показано в примере ниже.</span><span class="sxs-lookup"><span data-stu-id="98345-195">To accomplish this, create a linked token source that can join two or more tokens into one token, as shown in the following example.</span></span>  
  
 [!code-csharp[Cancellation#7](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex13.cs#7)]
 [!code-vb[Cancellation#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex13.vb#7)]  
  
 <span data-ttu-id="98345-196">Следует отметить, что после выполнения источником связанных токенов всех возложенных на него функций необходимо вызвать для него метод `Dispose`.</span><span class="sxs-lookup"><span data-stu-id="98345-196">Notice that you must call `Dispose` on the linked token source when you are done with it.</span></span> <span data-ttu-id="98345-197">Более полный пример см. в подразделе [Практическое руководство. Прослушивание нескольких запросов на отмену](../../../docs/standard/threading/how-to-listen-for-multiple-cancellation-requests.md).</span><span class="sxs-lookup"><span data-stu-id="98345-197">For a more complete example, see [How to: Listen for Multiple Cancellation Requests](../../../docs/standard/threading/how-to-listen-for-multiple-cancellation-requests.md).</span></span>  
  
## <a name="cooperation-between-library-code-and-user-code"></a><span data-ttu-id="98345-198">Совместная работа кода библиотеки и пользовательского кода</span><span class="sxs-lookup"><span data-stu-id="98345-198">Cooperation Between Library Code and User Code</span></span>  
 <span data-ttu-id="98345-199">Унифицированная инфраструктура отмены позволяет коду библиотеки отменять пользовательский код, а пользовательскому коду — отменять код библиотеки по принципу совместной работы.</span><span class="sxs-lookup"><span data-stu-id="98345-199">The unified cancellation framework makes it possible for library code to cancel user code, and for user code to cancel library code in a cooperative manner.</span></span> <span data-ttu-id="98345-200">Успешная совместная работа зависит от соблюдения каждой стороной перечисленных ниже рекомендаций.</span><span class="sxs-lookup"><span data-stu-id="98345-200">Smooth cooperation depends on each side following these guidelines:</span></span>  
  
- <span data-ttu-id="98345-201">Если код библиотеки предоставляет отменяемые операции, он также должен предоставить общие методы, принимающие внешний токен отмены, чтобы пользовательский код мог запрашивать отмену.</span><span class="sxs-lookup"><span data-stu-id="98345-201">If library code provides cancelable operations, it should also provide public methods that accept an external cancellation token so that user code can request cancellation.</span></span>  
  
- <span data-ttu-id="98345-202">Если код библиотеки вызывает пользовательский код, он должен уметь обрабатывать исключение OperationCanceledException(externalToken) как *совместную отмену*, а не только как исключение сбоя.</span><span class="sxs-lookup"><span data-stu-id="98345-202">If library code calls into user code, the library code should interpret an OperationCanceledException(externalToken) as *cooperative cancellation*, and not necessarily as a failure exception.</span></span>  
  
- <span data-ttu-id="98345-203">Пользовательские делегаты должны пытаться своевременно отвечать на запросы отмены от кода библиотеки.</span><span class="sxs-lookup"><span data-stu-id="98345-203">User-delegates should attempt to respond to cancellation requests from library code in a timely manner.</span></span>  
  
 <span data-ttu-id="98345-204"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> и <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> — примеры классов, соответствующих этим рекомендациям.</span><span class="sxs-lookup"><span data-stu-id="98345-204"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> are examples of classes that follow these guidelines.</span></span> <span data-ttu-id="98345-205">Дополнительные сведения см. в разделах [Отмена задач](../../../docs/standard/parallel-programming/task-cancellation.md) и [Практическое руководство. Отмена запроса PLINQ](../../../docs/standard/parallel-programming/how-to-cancel-a-plinq-query.md).</span><span class="sxs-lookup"><span data-stu-id="98345-205">For more information, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md) and [How to: Cancel a PLINQ Query](../../../docs/standard/parallel-programming/how-to-cancel-a-plinq-query.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="98345-206">См. также</span><span class="sxs-lookup"><span data-stu-id="98345-206">See also</span></span>

- [<span data-ttu-id="98345-207">Основы управляемых потоков</span><span class="sxs-lookup"><span data-stu-id="98345-207">Managed Threading Basics</span></span>](../../../docs/standard/threading/managed-threading-basics.md)
