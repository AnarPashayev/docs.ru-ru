---
title: Общие сведения о примитивах синхронизации
description: Узнайте о том, как с помощью примитивов синхронизации потоков .NET синхронизировать доступ к общему ресурсу или управлять взаимодействием потоков
ms.date: 10/01/2018
ms.technology: dotnet-standard
helpviewer_keywords:
- synchronization, threads
- threading [.NET],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
ms.openlocfilehash: 43f78c914b7cb01f9b0de4c258d5882548e52790
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/15/2020
ms.locfileid: "73106596"
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="508fd-103">Общие сведения о примитивах синхронизации</span><span class="sxs-lookup"><span data-stu-id="508fd-103">Overview of synchronization primitives</span></span>

<span data-ttu-id="508fd-104">Платформа .NET предоставляет ряд типов для синхронизации доступа к общему ресурсу или координации взаимодействия потоков.</span><span class="sxs-lookup"><span data-stu-id="508fd-104">.NET provides a range of types that you can use to synchronize access to a shared resource or coordinate thread interaction.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="508fd-105">С помощью одного экземпляра примитива синхронизации можно обеспечить защиту при обращении к общему ресурсу.</span><span class="sxs-lookup"><span data-stu-id="508fd-105">Use the same synchronization primitive instance to protect access of a shared resource.</span></span> <span data-ttu-id="508fd-106">Если для защиты одного и того же ресурса используются разные экземпляры примитива синхронизации, то защита, предоставляемая примитивом синхронизации, будет обходиться.</span><span class="sxs-lookup"><span data-stu-id="508fd-106">If you use different synchronization primitive instances to protect the same resource, you'll circumvent the protection provided by a synchronization primitive.</span></span>

## <a name="waithandle-class-and-lightweight-synchronization-types"></a><span data-ttu-id="508fd-107">Класс WaitHandle и типы упрощенной синхронизации</span><span class="sxs-lookup"><span data-stu-id="508fd-107">WaitHandle class and lightweight synchronization types</span></span>

<span data-ttu-id="508fd-108">Несколько примитивов синхронизации .NET являются производными от класса <xref:System.Threading.WaitHandle?displayProperty=nameWithType>, который инкапсулирует собственный дескриптор операционной системы синхронизации и использует механизм сигнализации для взаимодействия потоков.</span><span class="sxs-lookup"><span data-stu-id="508fd-108">Multiple .NET synchronization primitives derive from the <xref:System.Threading.WaitHandle?displayProperty=nameWithType> class, which encapsulates a native operating system synchronization handle and uses a signaling mechanism for thread interaction.</span></span> <span data-ttu-id="508fd-109">К ним относятся такие классы:</span><span class="sxs-lookup"><span data-stu-id="508fd-109">Those classes include:</span></span>

- <span data-ttu-id="508fd-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, который предоставляет монопольный доступ к общему ресурсу.</span><span class="sxs-lookup"><span data-stu-id="508fd-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, which grants exclusive access to a shared resource.</span></span> <span data-ttu-id="508fd-111">Если мьютексом не владеет ни один поток, сообщается состояние мьютекса.</span><span class="sxs-lookup"><span data-stu-id="508fd-111">The state of a mutex is signaled if no thread owns it.</span></span>
- <span data-ttu-id="508fd-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, ограничивающий число потоков, которые могут одновременно обращаться к ресурсу или пулу ресурсов.</span><span class="sxs-lookup"><span data-stu-id="508fd-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, which limits the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="508fd-113">Состояние семафора становится сигнальным, когда это число становится больше нуля, и несигнальным, когда равно нулю.</span><span class="sxs-lookup"><span data-stu-id="508fd-113">The state of a semaphore is set to signaled when its count is greater than zero, and nonsignaled when its count is zero.</span></span>
- <span data-ttu-id="508fd-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, который представляет событие синхронизации потоков и может быть в сигнальном или несигнальном состоянии.</span><span class="sxs-lookup"><span data-stu-id="508fd-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, which represents a thread synchronization event and can be either in a signaled or unsignaled state.</span></span>
- <span data-ttu-id="508fd-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, который является производным от <xref:System.Threading.EventWaitHandle> и при получении сигнала автоматически сбрасывается в сигнальное состояние после освобождения одиночного потока в состоянии ожидания.</span><span class="sxs-lookup"><span data-stu-id="508fd-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, resets automatically to an unsignaled state after releasing a single waiting thread.</span></span>
- <span data-ttu-id="508fd-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, который является производным от <xref:System.Threading.EventWaitHandle> и при получении сигнала остается в сигнальном состоянии до вызова метода <xref:System.Threading.EventWaitHandle.Reset%2A>.</span><span class="sxs-lookup"><span data-stu-id="508fd-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, stays in a signaled state until the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>

<span data-ttu-id="508fd-117">Так как <xref:System.Threading.WaitHandle> наследует <xref:System.MarshalByRefObject?displayProperty=nameWithType>, в .NET Framework эти типы можно использовать для синхронизации действий потоков за пределами доменов приложений.</span><span class="sxs-lookup"><span data-stu-id="508fd-117">In the .NET Framework, because <xref:System.Threading.WaitHandle> derives from <xref:System.MarshalByRefObject?displayProperty=nameWithType>, these types can be used to synchronize the activities of threads across application domain boundaries.</span></span>

<span data-ttu-id="508fd-118">В .NET Framework и .NET Core некоторые из этих типов могут быть именованными дескрипторами синхронизации системы, которые видны в операционной системе и могут использоваться для синхронизации между процессами:</span><span class="sxs-lookup"><span data-stu-id="508fd-118">In the .NET Framework and .NET Core, some of these types can represent named system synchronization handles, which are visible throughout the operating system and can be used for the inter-process synchronization:</span></span>

- <span data-ttu-id="508fd-119"><xref:System.Threading.Mutex> (.NET Framework и .NET Core);</span><span class="sxs-lookup"><span data-stu-id="508fd-119"><xref:System.Threading.Mutex> (.NET Framework and .NET Core),</span></span>
- <span data-ttu-id="508fd-120"><xref:System.Threading.Semaphore> (.NET Framework и .NET Core в Windows);</span><span class="sxs-lookup"><span data-stu-id="508fd-120"><xref:System.Threading.Semaphore> (.NET Framework and .NET Core on Windows),</span></span>
- <span data-ttu-id="508fd-121"><xref:System.Threading.EventWaitHandle> (.NET Framework и .NET Core в Windows).</span><span class="sxs-lookup"><span data-stu-id="508fd-121"><xref:System.Threading.EventWaitHandle> (.NET Framework and .NET Core on Windows).</span></span>

<span data-ttu-id="508fd-122">Дополнительные сведения см. в справочной документации по API <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="508fd-122">For more information, see the <xref:System.Threading.WaitHandle> API reference.</span></span>

<span data-ttu-id="508fd-123">Типы упрощенной синхронизации не основаны на дескрипторах базовой операционной системы и обычно обеспечивают лучшее быстродействие.</span><span class="sxs-lookup"><span data-stu-id="508fd-123">Lightweight synchronization types don't rely on underlying operating system handles and typically provide better performance.</span></span> <span data-ttu-id="508fd-124">Тем не менее они не могут использоваться для внутрипроцессной синхронизации.</span><span class="sxs-lookup"><span data-stu-id="508fd-124">However, they cannot be used for the inter-process synchronization.</span></span> <span data-ttu-id="508fd-125">Эти типы можно использовать для синхронизации потоков в одном приложении.</span><span class="sxs-lookup"><span data-stu-id="508fd-125">Use those types for thread synchronization within one application.</span></span>

<span data-ttu-id="508fd-126">Некоторые из них являются альтернативой типам, производным от <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="508fd-126">Some of those types are alternatives to the types derived from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="508fd-127">Например, <xref:System.Threading.SemaphoreSlim> является упрощенной альтернативой <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="508fd-127">For example, <xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore>.</span></span>

## <a name="synchronization-of-access-to-a-shared-resource"></a><span data-ttu-id="508fd-128">Синхронизация доступа к общему ресурсу</span><span class="sxs-lookup"><span data-stu-id="508fd-128">Synchronization of access to a shared resource</span></span>

<span data-ttu-id="508fd-129">Платформа .NET предоставляет ряд примитивов синхронизации для управления доступом нескольких потоков к общему ресурсу.</span><span class="sxs-lookup"><span data-stu-id="508fd-129">.NET provides a range of synchronization primitives to control access to a shared resource by multiple threads.</span></span>

### <a name="monitor-class"></a><span data-ttu-id="508fd-130">Monitor - класс</span><span class="sxs-lookup"><span data-stu-id="508fd-130">Monitor class</span></span>

<span data-ttu-id="508fd-131">Класс <xref:System.Threading.Monitor?displayProperty=nameWithType> предоставляет монопольный доступ к общему ресурсу, блокируя или разблокируя объект, определяющий ресурс.</span><span class="sxs-lookup"><span data-stu-id="508fd-131">The <xref:System.Threading.Monitor?displayProperty=nameWithType> class grants mutually exclusive access to a shared resource by acquiring or releasing a lock on the object that identifies the resource.</span></span> <span data-ttu-id="508fd-132">Во время блокировки поток, удерживающий блокировку, может снова поставить и снять блокировку.</span><span class="sxs-lookup"><span data-stu-id="508fd-132">While a lock is held, the thread that holds the lock can again acquire and release the lock.</span></span> <span data-ttu-id="508fd-133">Любой другой поток не может получить блокировку, и метод <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> ожидает снятия блокировки.</span><span class="sxs-lookup"><span data-stu-id="508fd-133">Any other thread is blocked from acquiring the lock and the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method waits until the lock is released.</span></span> <span data-ttu-id="508fd-134">Метод <xref:System.Threading.Monitor.Enter%2A> получает снятую блокировку.</span><span class="sxs-lookup"><span data-stu-id="508fd-134">The <xref:System.Threading.Monitor.Enter%2A> method acquires a released lock.</span></span> <span data-ttu-id="508fd-135">Можно также использовать метод <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, чтобы задать количество времени, в течение которого поток пытается получить блокировку.</span><span class="sxs-lookup"><span data-stu-id="508fd-135">You can also use the <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> method to specify the amount of time during which a thread attempts to acquire a lock.</span></span> <span data-ttu-id="508fd-136">Так как класс <xref:System.Threading.Monitor> реализует привязку потока, поток, который получил блокировку, должен снять ее, вызвав метод <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="508fd-136">Because the <xref:System.Threading.Monitor> class has thread affinity, the thread that acquired a lock must release the lock by calling the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="508fd-137">Можно координировать взаимодействие потоков, которые получают блокировку для одного и того же объекта, с помощью методов <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> и <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="508fd-137">You can coordinate the interaction of threads that acquire a lock on the same object by using the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.</span></span>

<span data-ttu-id="508fd-138">Дополнительные сведения см. в справочной документации по API <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="508fd-138">For more information, see the <xref:System.Threading.Monitor> API reference.</span></span>

> [!NOTE]
> <span data-ttu-id="508fd-139">С помощью операторов [lock](../../csharp/language-reference/keywords/lock-statement.md) в C# и [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) в Visual Basic можно синхронизировать доступ к общему ресурсу вместо использования класса <xref:System.Threading.Monitor> напрямую.</span><span class="sxs-lookup"><span data-stu-id="508fd-139">Use the [lock](../../csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic to synchronize access to a shared resource instead of using the <xref:System.Threading.Monitor> class directly.</span></span> <span data-ttu-id="508fd-140">Эти операторы реализуются с помощью методов <xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.Exit%2A> и блока `try…finally`, обеспечивающих постоянное снятие полученной блокировки.</span><span class="sxs-lookup"><span data-stu-id="508fd-140">Those statements are implemented by using the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods and a `try…finally` block to ensure that the acquired lock is always released.</span></span>

### <a name="mutex-class"></a><span data-ttu-id="508fd-141">Mutex - класс</span><span class="sxs-lookup"><span data-stu-id="508fd-141">Mutex class</span></span>

<span data-ttu-id="508fd-142">Как и <xref:System.Threading.Mutex?displayProperty=nameWithType>, класс <xref:System.Threading.Monitor> предоставляет монопольный доступ к общему ресурсу.</span><span class="sxs-lookup"><span data-stu-id="508fd-142">The <xref:System.Threading.Mutex?displayProperty=nameWithType> class, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource.</span></span> <span data-ttu-id="508fd-143">С помощью вызова одной из перегрузок метода [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) можно запросить владение мьютексом.</span><span class="sxs-lookup"><span data-stu-id="508fd-143">Use one of the [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) method overloads to request the ownership of a mutex.</span></span> <span data-ttu-id="508fd-144">Как и <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex>реализует привязку потока, и поток, который получил мьютекс, должен освободить его, вызвав метод <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="508fd-144">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity and the thread that acquired a mutex must release it by calling the <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="508fd-145">В отличие от <xref:System.Threading.Monitor>, класс <xref:System.Threading.Mutex> может использоваться для межпроцессной синхронизации.</span><span class="sxs-lookup"><span data-stu-id="508fd-145">Unlike <xref:System.Threading.Monitor>, the <xref:System.Threading.Mutex> class can be used for inter-process synchronization.</span></span> <span data-ttu-id="508fd-146">Для этого нужно использовать именованный мьютекс, который виден в операционной системе.</span><span class="sxs-lookup"><span data-stu-id="508fd-146">To do that, use a named mutex, which is visible throughout the operating system.</span></span> <span data-ttu-id="508fd-147">Чтобы создать экземпляр именованного мьютекса, используйте [конструктор Mutex](<xref:System.Threading.Mutex.%23ctor%2A>), который задает имя.</span><span class="sxs-lookup"><span data-stu-id="508fd-147">To create a named mutex instance, use a [Mutex constructor](<xref:System.Threading.Mutex.%23ctor%2A>) that specifies a name.</span></span> <span data-ttu-id="508fd-148">Также можно вызвать метод <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType>, чтобы открыть существующий именованный системный мьютекс.</span><span class="sxs-lookup"><span data-stu-id="508fd-148">You also can call the <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> method to open an existing named system mutex.</span></span>
  
<span data-ttu-id="508fd-149">Дополнительные сведения см. в статье о [мьютексах](mutexes.md) и справочной документации по API <xref:System.Threading.Mutex>.</span><span class="sxs-lookup"><span data-stu-id="508fd-149">For more information, see the [Mutexes](mutexes.md) article and the <xref:System.Threading.Mutex> API reference.</span></span>

### <a name="spinlock-structure"></a><span data-ttu-id="508fd-150">Структура SpinLock</span><span class="sxs-lookup"><span data-stu-id="508fd-150">SpinLock structure</span></span>

<span data-ttu-id="508fd-151">Структура <xref:System.Threading.SpinLock?displayProperty=nameWithType>, как и <xref:System.Threading.Monitor>, предоставляет монопольный доступ к общему ресурсу на основе доступности блокировки.</span><span class="sxs-lookup"><span data-stu-id="508fd-151">The <xref:System.Threading.SpinLock?displayProperty=nameWithType> structure, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource based on the availability of a lock.</span></span> <span data-ttu-id="508fd-152">Когда <xref:System.Threading.SpinLock> пытается получить блокировку, которая недоступна, этот примитив будет ожидать в цикле, постоянно проверяя возможность получения блокировки.</span><span class="sxs-lookup"><span data-stu-id="508fd-152">When <xref:System.Threading.SpinLock> attempts to acquire a lock that is unavailable, it waits in a loop, repeatedly checking until the lock becomes available.</span></span>

<span data-ttu-id="508fd-153">Дополнительные сведения о преимуществах и недостатках использования SpinLock см. в статье о [SpinLock](spinlock.md) и справочной документации по API <xref:System.Threading.SpinLock>.</span><span class="sxs-lookup"><span data-stu-id="508fd-153">For more information about the benefits and drawbacks of using spin lock, see the [SpinLock](spinlock.md) article and the <xref:System.Threading.SpinLock> API reference.</span></span>

### <a name="readerwriterlockslim-class"></a><span data-ttu-id="508fd-154">Класс ReaderWriterLockSlim</span><span class="sxs-lookup"><span data-stu-id="508fd-154">ReaderWriterLockSlim class</span></span>

<span data-ttu-id="508fd-155">Класс <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> предоставляет монопольный доступ к общему ресурсу для записи и обеспечивает одновременный доступ к ресурсу для чтения нескольким потокам.</span><span class="sxs-lookup"><span data-stu-id="508fd-155">The <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> class grants exclusive access to a shared resource for writing and allows multiple threads to access the resource simultaneously for reading.</span></span> <span data-ttu-id="508fd-156">Можно использовать <xref:System.Threading.ReaderWriterLockSlim> для синхронизации доступа к общей структуре данных, поддерживающей потокобезопасные операции чтения, но требующей монопольного доступа для выполнения операции записи.</span><span class="sxs-lookup"><span data-stu-id="508fd-156">You might want to use <xref:System.Threading.ReaderWriterLockSlim> to synchronize access to a shared data structure that supports thread-safe read operations, but requires exclusive access to perform write operation.</span></span> <span data-ttu-id="508fd-157">Если поток запрашивает монопольный доступ (например, путем вызова метода <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType>), последующие запросы модуля чтения и записи блокируются, пока все существующие модули чтения не освободят блокировку, а модуль записи не получит и не снимет блокировку.</span><span class="sxs-lookup"><span data-stu-id="508fd-157">When a thread requests exclusive access (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType> method), subsequent reader and writer requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>
  
<span data-ttu-id="508fd-158">Дополнительные сведения см. в справочной документации по API <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="508fd-158">For more information, see the <xref:System.Threading.ReaderWriterLockSlim> API reference.</span></span>

### <a name="semaphore-and-semaphoreslim-classes"></a><span data-ttu-id="508fd-159">Классы Semaphore и SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="508fd-159">Semaphore and SemaphoreSlim classes</span></span>

<span data-ttu-id="508fd-160">Классы <xref:System.Threading.Semaphore?displayProperty=nameWithType> и <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> ограничивают число потоков, которые могут одновременно обращаться к ресурсу или пулу ресурсов.</span><span class="sxs-lookup"><span data-stu-id="508fd-160">The <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> classes limit the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="508fd-161">Дополнительные потоки, запрашивающие ресурс, ожидают освобождения семафора любым из потоков.</span><span class="sxs-lookup"><span data-stu-id="508fd-161">Additional threads that request the resource wait until any thread releases the semaphore.</span></span> <span data-ttu-id="508fd-162">Так как семафор не реализует привязку потока, поток может занять семафор, а другой поток может его освободить.</span><span class="sxs-lookup"><span data-stu-id="508fd-162">Because the semaphore doesn't have thread affinity, a thread can acquire the semaphore and another one can release it.</span></span>

<span data-ttu-id="508fd-163"><xref:System.Threading.SemaphoreSlim> — это упрощенная альтернатива <xref:System.Threading.Semaphore>, которую можно использовать для синхронизации в рамках одного процесса.</span><span class="sxs-lookup"><span data-stu-id="508fd-163"><xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore> and can be used only for synchronization within a single process boundary.</span></span>

<span data-ttu-id="508fd-164">В Windows можно использовать <xref:System.Threading.Semaphore> для внутрипроцессной синхронизации.</span><span class="sxs-lookup"><span data-stu-id="508fd-164">On Windows, you can use <xref:System.Threading.Semaphore> for the inter-process synchronization.</span></span> <span data-ttu-id="508fd-165">Для этого необходимо создать экземпляр <xref:System.Threading.Semaphore>, выполняющий роль именованного системного семафора. Это можно сделать с помощью [конструкторов Semaphore](<xref:System.Threading.Semaphore.%23ctor%2A>), которые задают имя или метод <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="508fd-165">To do that, create a <xref:System.Threading.Semaphore> instance that represents a named system semaphore by using one of the [Semaphore constructors](<xref:System.Threading.Semaphore.%23ctor%2A>) that specifies a name or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="508fd-166"><xref:System.Threading.SemaphoreSlim> не поддерживает именованные системные семафоры.</span><span class="sxs-lookup"><span data-stu-id="508fd-166"><xref:System.Threading.SemaphoreSlim> doesn't support named system semaphores.</span></span>

<span data-ttu-id="508fd-167">Дополнительные сведения см. в статье о [классах Semaphore и SemaphoreSlim](semaphore-and-semaphoreslim.md) и справочной документации по API <xref:System.Threading.Semaphore> или <xref:System.Threading.SemaphoreSlim>.</span><span class="sxs-lookup"><span data-stu-id="508fd-167">For more information, see the [Semaphore and SemaphoreSlim](semaphore-and-semaphoreslim.md) article and the <xref:System.Threading.Semaphore> or <xref:System.Threading.SemaphoreSlim> API reference.</span></span>

## <a name="thread-interaction-or-signaling"></a><span data-ttu-id="508fd-168">Взаимодействие потоков или сигнализация</span><span class="sxs-lookup"><span data-stu-id="508fd-168">Thread interaction, or signaling</span></span>

<span data-ttu-id="508fd-169">Взаимодействие потоков (или сигнализация потоков) означает, что поток должен ждать уведомления или сигнала от одного или нескольких потоков, чтобы продолжить.</span><span class="sxs-lookup"><span data-stu-id="508fd-169">Thread interaction (or thread signaling) means that a thread must wait for notification, or a signal, from one or more threads in order to proceed.</span></span> <span data-ttu-id="508fd-170">Например, если поток A вызывает метод <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> потока B, поток А блокируется до завершения потока B.</span><span class="sxs-lookup"><span data-stu-id="508fd-170">For example, if thread A calls the <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> method of thread B, thread A is blocked until thread B completes.</span></span> <span data-ttu-id="508fd-171">Примитивы синхронизации, описанные в предыдущем разделе, реализуют другой механизм сигнализации: снятие блокировки потоком является сигналом другому потоку о возможности продолжать исполнение, получив блокировку.</span><span class="sxs-lookup"><span data-stu-id="508fd-171">The synchronization primitives described in the preceding section provide a different mechanism for signaling: by releasing a lock, a thread notifies another thread that it can proceed by acquiring the lock.</span></span>

<span data-ttu-id="508fd-172">В этом разделе описываются дополнительные сигнальные конструкции, предоставляемые .NET.</span><span class="sxs-lookup"><span data-stu-id="508fd-172">This section describes additional signaling constructs provided by .NET.</span></span>

### <a name="eventwaithandle-autoresetevent-manualresetevent-and-manualreseteventslim-classes"></a><span data-ttu-id="508fd-173">Классы EventWaitHandle, AutoResetEvent и ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="508fd-173">EventWaitHandle, AutoResetEvent, ManualResetEvent, and ManualResetEventSlim classes</span></span>

<span data-ttu-id="508fd-174">Класс <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> представляет событие синхронизации потока.</span><span class="sxs-lookup"><span data-stu-id="508fd-174">The <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> class represents a thread synchronization event.</span></span>

<span data-ttu-id="508fd-175">Событие синхронизации может находиться в сигнальном или несигнальном состоянии.</span><span class="sxs-lookup"><span data-stu-id="508fd-175">A synchronization event can be either in an unsignaled or signaled state.</span></span> <span data-ttu-id="508fd-176">Если состояние события несигнальное, поток, который вызывает перегрузку события <xref:System.Threading.WaitHandle.WaitOne%2A?>, будет заблокирован, пока состояние события не станет сигнальным.</span><span class="sxs-lookup"><span data-stu-id="508fd-176">When the state of an event is unsignaled, a thread that calls the event's <xref:System.Threading.WaitHandle.WaitOne%2A?> overload is blocked until an event is signaled.</span></span> <span data-ttu-id="508fd-177">Метод <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> задает сигнальное состояние события.</span><span class="sxs-lookup"><span data-stu-id="508fd-177">The <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method sets the state of an event to signaled.</span></span>

<span data-ttu-id="508fd-178">Поведение <xref:System.Threading.EventWaitHandle> после получения сигнала зависит от его режима сброса:</span><span class="sxs-lookup"><span data-stu-id="508fd-178">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode:</span></span>

- <span data-ttu-id="508fd-179"><xref:System.Threading.EventWaitHandle>, созданный с помощью флага <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>, автоматически сбрасывается после освобождения одного потока в состоянии ожидания.</span><span class="sxs-lookup"><span data-stu-id="508fd-179">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically after releasing a single waiting thread.</span></span> <span data-ttu-id="508fd-180">Это похоже на турникет, пропускающий только один поток каждый раз, когда он переводится в сигнальное состояние.</span><span class="sxs-lookup"><span data-stu-id="508fd-180">It's like a turnstile that allows only one thread through each time it's signaled.</span></span> <span data-ttu-id="508fd-181">Такое поведение характерно для класса <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, наследующего <xref:System.Threading.EventWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="508fd-181">The <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span>
- <span data-ttu-id="508fd-182"><xref:System.Threading.EventWaitHandle>, созданный с помощью флага <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>, находится в сигнальном состоянии, пока не будет вызван его метод <xref:System.Threading.EventWaitHandle.Reset%2A>.</span><span class="sxs-lookup"><span data-stu-id="508fd-182">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="508fd-183">Это как ворота, которые закрыты до получения сигнала и остающиеся затем открытыми, пока кто-нибудь их не закроет.</span><span class="sxs-lookup"><span data-stu-id="508fd-183">It's like a gate that is closed until signaled and then stays open until someone closes it.</span></span> <span data-ttu-id="508fd-184">Такое поведение характерно для класса <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, наследующего <xref:System.Threading.EventWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="508fd-184">The <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span> <span data-ttu-id="508fd-185">Класс <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> является упрощенной альтернативой <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="508fd-185">The <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> class is a lightweight alternative to <xref:System.Threading.ManualResetEvent>.</span></span>

<span data-ttu-id="508fd-186">В Windows можно использовать <xref:System.Threading.EventWaitHandle> для внутрипроцессной синхронизации.</span><span class="sxs-lookup"><span data-stu-id="508fd-186">On Windows, you can use <xref:System.Threading.EventWaitHandle> for the inter-process synchronization.</span></span> <span data-ttu-id="508fd-187">Для этого необходимо создать экземпляр <xref:System.Threading.EventWaitHandle>, выполняющий роль именованного системного события синхронизации. Это можно сделать с помощью [конструкторов EventWaitHandle](<xref:System.Threading.EventWaitHandle.%23ctor%2A>), которые задают имя или метод <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="508fd-187">To do that, create a <xref:System.Threading.EventWaitHandle> instance that represents a named system synchronization event by using one of the [EventWaitHandle constructors](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) that specifies a name or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="508fd-188">Дополнительные сведения см. в статье о [EventWaitHandle](eventwaithandle.md).</span><span class="sxs-lookup"><span data-stu-id="508fd-188">For more information, see the [EventWaitHandle](eventwaithandle.md) article.</span></span> <span data-ttu-id="508fd-189">Справочные сведения об API см. здесь: <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent> и <xref:System.Threading.ManualResetEventSlim>.</span><span class="sxs-lookup"><span data-stu-id="508fd-189">For the API reference, see <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent>, and <xref:System.Threading.ManualResetEventSlim>.</span></span>

### <a name="countdownevent-class"></a><span data-ttu-id="508fd-190">Класс CountdownEvent</span><span class="sxs-lookup"><span data-stu-id="508fd-190">CountdownEvent class</span></span>

<span data-ttu-id="508fd-191">Класс <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> представляет событие, возникающее, когда его счетчик имеет значение ноль.</span><span class="sxs-lookup"><span data-stu-id="508fd-191">The <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> class represents an event that becomes set when its count is zero.</span></span> <span data-ttu-id="508fd-192">Когда <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> не равен нулю, поток, который вызывает <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType>, блокируется.</span><span class="sxs-lookup"><span data-stu-id="508fd-192">While <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> is greater than zero, a thread that calls <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> is blocked.</span></span> <span data-ttu-id="508fd-193">Вызовите <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType>, чтобы уменьшить значение счетчика события.</span><span class="sxs-lookup"><span data-stu-id="508fd-193">Call <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> to decrement an event's count.</span></span>

<span data-ttu-id="508fd-194">В отличие от <xref:System.Threading.ManualResetEvent> или <xref:System.Threading.ManualResetEventSlim>, которые позволяют разблокировать несколько потоков с помощью сигнала от одного потока, <xref:System.Threading.CountdownEvent> может разблокировать один или несколько потоков с помощью сигналов от нескольких потоков.</span><span class="sxs-lookup"><span data-stu-id="508fd-194">In contrast to <xref:System.Threading.ManualResetEvent> or <xref:System.Threading.ManualResetEventSlim>, which you can use to unblock multiple threads with a signal from one thread, you can use <xref:System.Threading.CountdownEvent> to unblock one or more threads with signals from multiple threads.</span></span>

<span data-ttu-id="508fd-195">Дополнительные сведения см. в статье о [CountdownEvent](countdownevent.md) и справочной документации по API <xref:System.Threading.CountdownEvent>.</span><span class="sxs-lookup"><span data-stu-id="508fd-195">For more information, see the [CountdownEvent](countdownevent.md) article and the <xref:System.Threading.CountdownEvent> API reference.</span></span>

### <a name="barrier-class"></a><span data-ttu-id="508fd-196">Класс Barrier</span><span class="sxs-lookup"><span data-stu-id="508fd-196">Barrier class</span></span>

<span data-ttu-id="508fd-197">Класс <xref:System.Threading.Barrier?displayProperty=nameWithType> представляет барьер выполнения потоков.</span><span class="sxs-lookup"><span data-stu-id="508fd-197">The <xref:System.Threading.Barrier?displayProperty=nameWithType> class represents a thread execution barrier.</span></span> <span data-ttu-id="508fd-198">Поток, который вызывает метод <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType>, сообщает, что он достиг барьера и ожидает, пока другие участвующие потоки не достигнут барьера.</span><span class="sxs-lookup"><span data-stu-id="508fd-198">A thread that calls the <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> method signals that it reached the barrier and waits until other participant threads reach the barrier.</span></span> <span data-ttu-id="508fd-199">Когда все участвующие потоки достигают барьера, их выполнение продолжается, а барьер сбрасывается и может использоваться повторно.</span><span class="sxs-lookup"><span data-stu-id="508fd-199">When all participant threads reach the barrier, they proceed and the barrier is reset and can be used again.</span></span>

<span data-ttu-id="508fd-200">Можно использовать <xref:System.Threading.Barrier>, если одному или нескольким потокам требуются результаты других потоков для перехода к следующему этапу вычисления.</span><span class="sxs-lookup"><span data-stu-id="508fd-200">You might use <xref:System.Threading.Barrier> when one or more threads require the results of other threads before proceeding to the next computation phase.</span></span>

<span data-ttu-id="508fd-201">Дополнительные сведения см. в статье о [Barrier](barrier.md) и справочной документации по API <xref:System.Threading.Barrier>.</span><span class="sxs-lookup"><span data-stu-id="508fd-201">For more information, see the [Barrier](barrier.md) article and the <xref:System.Threading.Barrier> API reference.</span></span>

## <a name="interlocked-class"></a><span data-ttu-id="508fd-202">Interlocked - класс</span><span class="sxs-lookup"><span data-stu-id="508fd-202">Interlocked class</span></span>

<span data-ttu-id="508fd-203">Класс <xref:System.Threading.Interlocked?displayProperty=nameWithType> предоставляет статические методы, которые выполняют простые атомарные операции над переменной.</span><span class="sxs-lookup"><span data-stu-id="508fd-203">The <xref:System.Threading.Interlocked?displayProperty=nameWithType> class provides static methods that perform simple atomic operations on a variable.</span></span> <span data-ttu-id="508fd-204">К этим атомарным операциям относится добавление, инкремент и декремент, обмен и условный обмен, зависящий от сравнения, а также операция чтения 64-разрядного целого числа.</span><span class="sxs-lookup"><span data-stu-id="508fd-204">Those atomic operations include addition, increment and decrement, exchange and conditional exchange that depends on a comparison, and read operation of a 64-bit integer value.</span></span>

<span data-ttu-id="508fd-205">Дополнительные сведения см. в справочной документации по API <xref:System.Threading.Interlocked>.</span><span class="sxs-lookup"><span data-stu-id="508fd-205">For more information, see the <xref:System.Threading.Interlocked> API reference.</span></span>

## <a name="spinwait-structure"></a><span data-ttu-id="508fd-206">Структура SpinWait</span><span class="sxs-lookup"><span data-stu-id="508fd-206">SpinWait structure</span></span>

<span data-ttu-id="508fd-207">Структура <xref:System.Threading.SpinWait?displayProperty=nameWithType> обеспечивает поддержку ожидания спин-блокировки.</span><span class="sxs-lookup"><span data-stu-id="508fd-207">The <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure provides support for spin-based waiting.</span></span> <span data-ttu-id="508fd-208">Ее можно использовать, когда потоку нужно дождаться возникновения события или выполнения условия, но фактическое время ожидания будет меньше периода, требуемого для применения дескриптора ожидания или других способов блокировки потока.</span><span class="sxs-lookup"><span data-stu-id="508fd-208">You might want to use it when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the thread.</span></span> <span data-ttu-id="508fd-209">Используя <xref:System.Threading.SpinWait>, можно задать короткий интервал времени для цикла ожидания, а затем вернуть управление (например, с помощью ожидания или спящего режима), только если условие не было выполнено в течение заданного времени.</span><span class="sxs-lookup"><span data-stu-id="508fd-209">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>

<span data-ttu-id="508fd-210">Дополнительные сведения см. в статье о [SpinWait](spinwait.md) и справочной документации по API <xref:System.Threading.SpinWait>.</span><span class="sxs-lookup"><span data-stu-id="508fd-210">For more information, see the [SpinWait](spinwait.md) article and the <xref:System.Threading.SpinWait> API reference.</span></span>

## <a name="see-also"></a><span data-ttu-id="508fd-211">См. также раздел</span><span class="sxs-lookup"><span data-stu-id="508fd-211">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="508fd-212">Потокобезопасные коллекции</span><span class="sxs-lookup"><span data-stu-id="508fd-212">Thread-safe collections</span></span>](../collections/thread-safe/index.md)
- [<span data-ttu-id="508fd-213">Объекты и функциональные возможности работы с потоками</span><span class="sxs-lookup"><span data-stu-id="508fd-213">Threading objects and features</span></span>](threading-objects-and-features.md)
