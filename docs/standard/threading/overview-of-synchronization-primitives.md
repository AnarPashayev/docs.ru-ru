---
title: Общие сведения о примитивах синхронизации
description: Узнайте о том, как с помощью примитивов синхронизации потоков .NET синхронизировать доступ к общему ресурсу или управлять взаимодействием потоков
ms.date: 10/01/2018
ms.technology: dotnet-standard
helpviewer_keywords:
- synchronization, threads
- threading [.NET],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
ms.openlocfilehash: d5ae0fe5813952742950582a4282cd1c6ab6a870
ms.sourcegitcommit: 7588b1f16b7608bc6833c05f91ae670c22ef56f8
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/02/2020
ms.locfileid: "93188982"
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="2c386-103">Общие сведения о примитивах синхронизации</span><span class="sxs-lookup"><span data-stu-id="2c386-103">Overview of synchronization primitives</span></span>

<span data-ttu-id="2c386-104">Платформа .NET предоставляет ряд типов для синхронизации доступа к общему ресурсу или координации взаимодействия потоков.</span><span class="sxs-lookup"><span data-stu-id="2c386-104">.NET provides a range of types that you can use to synchronize access to a shared resource or coordinate thread interaction.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="2c386-105">С помощью одного экземпляра примитива синхронизации можно обеспечить защиту при обращении к общему ресурсу.</span><span class="sxs-lookup"><span data-stu-id="2c386-105">Use the same synchronization primitive instance to protect access of a shared resource.</span></span> <span data-ttu-id="2c386-106">Если для защиты одного и того же ресурса используются разные экземпляры примитива синхронизации, то защита, предоставляемая примитивом синхронизации, будет обходиться.</span><span class="sxs-lookup"><span data-stu-id="2c386-106">If you use different synchronization primitive instances to protect the same resource, you'll circumvent the protection provided by a synchronization primitive.</span></span>

## <a name="waithandle-class-and-lightweight-synchronization-types"></a><span data-ttu-id="2c386-107">Класс WaitHandle и типы упрощенной синхронизации</span><span class="sxs-lookup"><span data-stu-id="2c386-107">WaitHandle class and lightweight synchronization types</span></span>

<span data-ttu-id="2c386-108">Несколько примитивов синхронизации .NET являются производными от класса <xref:System.Threading.WaitHandle?displayProperty=nameWithType>, который инкапсулирует собственный дескриптор операционной системы синхронизации и использует механизм сигнализации для взаимодействия потоков.</span><span class="sxs-lookup"><span data-stu-id="2c386-108">Multiple .NET synchronization primitives derive from the <xref:System.Threading.WaitHandle?displayProperty=nameWithType> class, which encapsulates a native operating system synchronization handle and uses a signaling mechanism for thread interaction.</span></span> <span data-ttu-id="2c386-109">К ним относятся такие классы:</span><span class="sxs-lookup"><span data-stu-id="2c386-109">Those classes include:</span></span>

- <span data-ttu-id="2c386-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, который предоставляет монопольный доступ к общему ресурсу.</span><span class="sxs-lookup"><span data-stu-id="2c386-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, which grants exclusive access to a shared resource.</span></span> <span data-ttu-id="2c386-111">Если мьютексом не владеет ни один поток, сообщается состояние мьютекса.</span><span class="sxs-lookup"><span data-stu-id="2c386-111">The state of a mutex is signaled if no thread owns it.</span></span>
- <span data-ttu-id="2c386-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, ограничивающий число потоков, которые могут одновременно обращаться к ресурсу или пулу ресурсов.</span><span class="sxs-lookup"><span data-stu-id="2c386-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, which limits the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="2c386-113">Состояние семафора становится сигнальным, когда это число становится больше нуля, и несигнальным, когда равно нулю.</span><span class="sxs-lookup"><span data-stu-id="2c386-113">The state of a semaphore is set to signaled when its count is greater than zero, and nonsignaled when its count is zero.</span></span>
- <span data-ttu-id="2c386-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, который представляет событие синхронизации потоков и может быть в сигнальном или несигнальном состоянии.</span><span class="sxs-lookup"><span data-stu-id="2c386-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, which represents a thread synchronization event and can be either in a signaled or unsignaled state.</span></span>
- <span data-ttu-id="2c386-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, который является производным от <xref:System.Threading.EventWaitHandle> и при получении сигнала автоматически сбрасывается в сигнальное состояние после освобождения одиночного потока в состоянии ожидания.</span><span class="sxs-lookup"><span data-stu-id="2c386-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, resets automatically to an unsignaled state after releasing a single waiting thread.</span></span>
- <span data-ttu-id="2c386-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, который является производным от <xref:System.Threading.EventWaitHandle> и при получении сигнала остается в сигнальном состоянии до вызова метода <xref:System.Threading.EventWaitHandle.Reset%2A>.</span><span class="sxs-lookup"><span data-stu-id="2c386-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, stays in a signaled state until the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>

<span data-ttu-id="2c386-117">Так как <xref:System.Threading.WaitHandle> наследует <xref:System.MarshalByRefObject?displayProperty=nameWithType>, в .NET Framework эти типы можно использовать для синхронизации действий потоков за пределами доменов приложений.</span><span class="sxs-lookup"><span data-stu-id="2c386-117">In .NET Framework, because <xref:System.Threading.WaitHandle> derives from <xref:System.MarshalByRefObject?displayProperty=nameWithType>, these types can be used to synchronize the activities of threads across application domain boundaries.</span></span>

<span data-ttu-id="2c386-118">В .NET Framework, .NET Core и .NET 5 или более поздней версии некоторые из этих типов могут быть именованными дескрипторами синхронизации системы, которые видны в операционной системе и могут использоваться для синхронизации между процессами.</span><span class="sxs-lookup"><span data-stu-id="2c386-118">In .NET Framework, .NET Core, and .NET 5+, some of these types can represent named system synchronization handles, which are visible throughout the operating system and can be used for the inter-process synchronization:</span></span>

- <xref:System.Threading.Mutex>
- <span data-ttu-id="2c386-119"><xref:System.Threading.Semaphore> (в Windows)</span><span class="sxs-lookup"><span data-stu-id="2c386-119"><xref:System.Threading.Semaphore> (on Windows)</span></span>
- <span data-ttu-id="2c386-120"><xref:System.Threading.EventWaitHandle> (в Windows)</span><span class="sxs-lookup"><span data-stu-id="2c386-120"><xref:System.Threading.EventWaitHandle> (on Windows)</span></span>

<span data-ttu-id="2c386-121">Дополнительные сведения см. в справочной документации по API <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="2c386-121">For more information, see the <xref:System.Threading.WaitHandle> API reference.</span></span>

<span data-ttu-id="2c386-122">Типы упрощенной синхронизации не основаны на дескрипторах базовой операционной системы и обычно обеспечивают лучшее быстродействие.</span><span class="sxs-lookup"><span data-stu-id="2c386-122">Lightweight synchronization types don't rely on underlying operating system handles and typically provide better performance.</span></span> <span data-ttu-id="2c386-123">Тем не менее они не могут использоваться для внутрипроцессной синхронизации.</span><span class="sxs-lookup"><span data-stu-id="2c386-123">However, they cannot be used for the inter-process synchronization.</span></span> <span data-ttu-id="2c386-124">Эти типы можно использовать для синхронизации потоков в одном приложении.</span><span class="sxs-lookup"><span data-stu-id="2c386-124">Use those types for thread synchronization within one application.</span></span>

<span data-ttu-id="2c386-125">Некоторые из них являются альтернативой типам, производным от <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="2c386-125">Some of those types are alternatives to the types derived from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="2c386-126">Например, <xref:System.Threading.SemaphoreSlim> является упрощенной альтернативой <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="2c386-126">For example, <xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore>.</span></span>

## <a name="synchronization-of-access-to-a-shared-resource"></a><span data-ttu-id="2c386-127">Синхронизация доступа к общему ресурсу</span><span class="sxs-lookup"><span data-stu-id="2c386-127">Synchronization of access to a shared resource</span></span>

<span data-ttu-id="2c386-128">Платформа .NET предоставляет ряд примитивов синхронизации для управления доступом нескольких потоков к общему ресурсу.</span><span class="sxs-lookup"><span data-stu-id="2c386-128">.NET provides a range of synchronization primitives to control access to a shared resource by multiple threads.</span></span>

### <a name="monitor-class"></a><span data-ttu-id="2c386-129">Monitor класс</span><span class="sxs-lookup"><span data-stu-id="2c386-129">Monitor class</span></span>

<span data-ttu-id="2c386-130">Класс <xref:System.Threading.Monitor?displayProperty=nameWithType> предоставляет монопольный доступ к общему ресурсу, блокируя или разблокируя объект, определяющий ресурс.</span><span class="sxs-lookup"><span data-stu-id="2c386-130">The <xref:System.Threading.Monitor?displayProperty=nameWithType> class grants mutually exclusive access to a shared resource by acquiring or releasing a lock on the object that identifies the resource.</span></span> <span data-ttu-id="2c386-131">Во время блокировки поток, удерживающий блокировку, может снова поставить и снять блокировку.</span><span class="sxs-lookup"><span data-stu-id="2c386-131">While a lock is held, the thread that holds the lock can again acquire and release the lock.</span></span> <span data-ttu-id="2c386-132">Любой другой поток не может получить блокировку, и метод <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> ожидает снятия блокировки.</span><span class="sxs-lookup"><span data-stu-id="2c386-132">Any other thread is blocked from acquiring the lock and the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method waits until the lock is released.</span></span> <span data-ttu-id="2c386-133">Метод <xref:System.Threading.Monitor.Enter%2A> получает снятую блокировку.</span><span class="sxs-lookup"><span data-stu-id="2c386-133">The <xref:System.Threading.Monitor.Enter%2A> method acquires a released lock.</span></span> <span data-ttu-id="2c386-134">Можно также использовать метод <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, чтобы задать количество времени, в течение которого поток пытается получить блокировку.</span><span class="sxs-lookup"><span data-stu-id="2c386-134">You can also use the <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> method to specify the amount of time during which a thread attempts to acquire a lock.</span></span> <span data-ttu-id="2c386-135">Так как класс <xref:System.Threading.Monitor> реализует привязку потока, поток, который получил блокировку, должен снять ее, вызвав метод <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2c386-135">Because the <xref:System.Threading.Monitor> class has thread affinity, the thread that acquired a lock must release the lock by calling the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="2c386-136">Можно координировать взаимодействие потоков, которые получают блокировку для одного и того же объекта, с помощью методов <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> и <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2c386-136">You can coordinate the interaction of threads that acquire a lock on the same object by using the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.</span></span>

<span data-ttu-id="2c386-137">Дополнительные сведения см. в справочной документации по API <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="2c386-137">For more information, see the <xref:System.Threading.Monitor> API reference.</span></span>

> [!NOTE]
> <span data-ttu-id="2c386-138">С помощью операторов [lock](../../csharp/language-reference/keywords/lock-statement.md) в C# и [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) в Visual Basic можно синхронизировать доступ к общему ресурсу вместо использования класса <xref:System.Threading.Monitor> напрямую.</span><span class="sxs-lookup"><span data-stu-id="2c386-138">Use the [lock](../../csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic to synchronize access to a shared resource instead of using the <xref:System.Threading.Monitor> class directly.</span></span> <span data-ttu-id="2c386-139">Эти операторы реализуются с помощью методов <xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.Exit%2A> и блока `try…finally`, обеспечивающих постоянное снятие полученной блокировки.</span><span class="sxs-lookup"><span data-stu-id="2c386-139">Those statements are implemented by using the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods and a `try…finally` block to ensure that the acquired lock is always released.</span></span>

### <a name="mutex-class"></a><span data-ttu-id="2c386-140">Mutex класс</span><span class="sxs-lookup"><span data-stu-id="2c386-140">Mutex class</span></span>

<span data-ttu-id="2c386-141">Класс <xref:System.Threading.Mutex?displayProperty=nameWithType>, как и <xref:System.Threading.Monitor>, предоставляет монопольный доступ к общему ресурсу.</span><span class="sxs-lookup"><span data-stu-id="2c386-141">The <xref:System.Threading.Mutex?displayProperty=nameWithType> class, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource.</span></span> <span data-ttu-id="2c386-142">С помощью вызова одной из перегрузок метода [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) можно запросить владение мьютексом.</span><span class="sxs-lookup"><span data-stu-id="2c386-142">Use one of the [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) method overloads to request the ownership of a mutex.</span></span> <span data-ttu-id="2c386-143">Как и <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex>реализует привязку потока, и поток, который получил мьютекс, должен освободить его, вызвав метод <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2c386-143">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity and the thread that acquired a mutex must release it by calling the <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="2c386-144">В отличие от <xref:System.Threading.Monitor>, класс <xref:System.Threading.Mutex> может использоваться для межпроцессной синхронизации.</span><span class="sxs-lookup"><span data-stu-id="2c386-144">Unlike <xref:System.Threading.Monitor>, the <xref:System.Threading.Mutex> class can be used for inter-process synchronization.</span></span> <span data-ttu-id="2c386-145">Для этого нужно использовать именованный мьютекс, который виден в операционной системе.</span><span class="sxs-lookup"><span data-stu-id="2c386-145">To do that, use a named mutex, which is visible throughout the operating system.</span></span> <span data-ttu-id="2c386-146">Чтобы создать экземпляр именованного мьютекса, используйте [конструктор Mutex](<xref:System.Threading.Mutex.%23ctor%2A>), который задает имя.</span><span class="sxs-lookup"><span data-stu-id="2c386-146">To create a named mutex instance, use a [Mutex constructor](<xref:System.Threading.Mutex.%23ctor%2A>) that specifies a name.</span></span> <span data-ttu-id="2c386-147">Также можно вызвать метод <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType>, чтобы открыть существующий именованный системный мьютекс.</span><span class="sxs-lookup"><span data-stu-id="2c386-147">You can also call the <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> method to open an existing named system mutex.</span></span>
  
<span data-ttu-id="2c386-148">Дополнительные сведения см. в статье о [мьютексах](mutexes.md) и справочной документации по API <xref:System.Threading.Mutex>.</span><span class="sxs-lookup"><span data-stu-id="2c386-148">For more information, see the [Mutexes](mutexes.md) article and the <xref:System.Threading.Mutex> API reference.</span></span>

### <a name="spinlock-structure"></a><span data-ttu-id="2c386-149">Структура SpinLock</span><span class="sxs-lookup"><span data-stu-id="2c386-149">SpinLock structure</span></span>

<span data-ttu-id="2c386-150">Структура <xref:System.Threading.SpinLock?displayProperty=nameWithType>, как и <xref:System.Threading.Monitor>, предоставляет монопольный доступ к общему ресурсу на основе доступности блокировки.</span><span class="sxs-lookup"><span data-stu-id="2c386-150">The <xref:System.Threading.SpinLock?displayProperty=nameWithType> structure, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource based on the availability of a lock.</span></span> <span data-ttu-id="2c386-151">Когда <xref:System.Threading.SpinLock> пытается получить блокировку, которая недоступна, этот примитив будет ожидать в цикле, постоянно проверяя возможность получения блокировки.</span><span class="sxs-lookup"><span data-stu-id="2c386-151">When <xref:System.Threading.SpinLock> attempts to acquire a lock that is unavailable, it waits in a loop, repeatedly checking until the lock becomes available.</span></span>

<span data-ttu-id="2c386-152">Дополнительные сведения о преимуществах и недостатках использования SpinLock см. в статье о [SpinLock](spinlock.md) и справочной документации по API <xref:System.Threading.SpinLock>.</span><span class="sxs-lookup"><span data-stu-id="2c386-152">For more information about the benefits and drawbacks of using spin lock, see the [SpinLock](spinlock.md) article and the <xref:System.Threading.SpinLock> API reference.</span></span>

### <a name="readerwriterlockslim-class"></a><span data-ttu-id="2c386-153">Класс ReaderWriterLockSlim</span><span class="sxs-lookup"><span data-stu-id="2c386-153">ReaderWriterLockSlim class</span></span>

<span data-ttu-id="2c386-154">Класс <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> предоставляет монопольный доступ к общему ресурсу для записи и обеспечивает одновременный доступ к ресурсу для чтения нескольким потокам.</span><span class="sxs-lookup"><span data-stu-id="2c386-154">The <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> class grants exclusive access to a shared resource for writing and allows multiple threads to access the resource simultaneously for reading.</span></span> <span data-ttu-id="2c386-155">Можно использовать <xref:System.Threading.ReaderWriterLockSlim> для синхронизации доступа к общей структуре данных, поддерживающей потокобезопасные операции чтения, но требующей монопольного доступа для выполнения операции записи.</span><span class="sxs-lookup"><span data-stu-id="2c386-155">You might want to use <xref:System.Threading.ReaderWriterLockSlim> to synchronize access to a shared data structure that supports thread-safe read operations, but requires exclusive access to perform write operation.</span></span> <span data-ttu-id="2c386-156">Если поток запрашивает монопольный доступ (например, путем вызова метода <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType>), последующие запросы модуля чтения и записи блокируются, пока все существующие модули чтения не освободят блокировку, а модуль записи не получит и не снимет блокировку.</span><span class="sxs-lookup"><span data-stu-id="2c386-156">When a thread requests exclusive access (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType> method), subsequent reader and writer requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>
  
<span data-ttu-id="2c386-157">Дополнительные сведения см. в справочной документации по API <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="2c386-157">For more information, see the <xref:System.Threading.ReaderWriterLockSlim> API reference.</span></span>

### <a name="semaphore-and-semaphoreslim-classes"></a><span data-ttu-id="2c386-158">Классы Semaphore и SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="2c386-158">Semaphore and SemaphoreSlim classes</span></span>

<span data-ttu-id="2c386-159">Классы <xref:System.Threading.Semaphore?displayProperty=nameWithType> и <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> ограничивают число потоков, которые могут одновременно обращаться к ресурсу или пулу ресурсов.</span><span class="sxs-lookup"><span data-stu-id="2c386-159">The <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> classes limit the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="2c386-160">Дополнительные потоки, запрашивающие ресурс, ожидают освобождения семафора любым из потоков.</span><span class="sxs-lookup"><span data-stu-id="2c386-160">Additional threads that request the resource wait until any thread releases the semaphore.</span></span> <span data-ttu-id="2c386-161">Так как семафор не реализует привязку потока, поток может занять семафор, а другой поток может его освободить.</span><span class="sxs-lookup"><span data-stu-id="2c386-161">Because the semaphore doesn't have thread affinity, a thread can acquire the semaphore and another one can release it.</span></span>

<span data-ttu-id="2c386-162"><xref:System.Threading.SemaphoreSlim> — это упрощенная альтернатива <xref:System.Threading.Semaphore>, которую можно использовать для синхронизации в рамках одного процесса.</span><span class="sxs-lookup"><span data-stu-id="2c386-162"><xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore> and can be used only for synchronization within a single process boundary.</span></span>

<span data-ttu-id="2c386-163">В Windows можно использовать <xref:System.Threading.Semaphore> для внутрипроцессной синхронизации.</span><span class="sxs-lookup"><span data-stu-id="2c386-163">On Windows, you can use <xref:System.Threading.Semaphore> for the inter-process synchronization.</span></span> <span data-ttu-id="2c386-164">Для этого необходимо создать экземпляр <xref:System.Threading.Semaphore>, выполняющий роль именованного системного семафора. Это можно сделать с помощью [конструкторов Semaphore](<xref:System.Threading.Semaphore.%23ctor%2A>), которые задают имя или метод <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2c386-164">To do that, create a <xref:System.Threading.Semaphore> instance that represents a named system semaphore by using one of the [Semaphore constructors](<xref:System.Threading.Semaphore.%23ctor%2A>) that specifies a name or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="2c386-165"><xref:System.Threading.SemaphoreSlim> не поддерживает именованные системные семафоры.</span><span class="sxs-lookup"><span data-stu-id="2c386-165"><xref:System.Threading.SemaphoreSlim> doesn't support named system semaphores.</span></span>

<span data-ttu-id="2c386-166">Дополнительные сведения см. в статье о [классах Semaphore и SemaphoreSlim](semaphore-and-semaphoreslim.md) и справочной документации по API <xref:System.Threading.Semaphore> или <xref:System.Threading.SemaphoreSlim>.</span><span class="sxs-lookup"><span data-stu-id="2c386-166">For more information, see the [Semaphore and SemaphoreSlim](semaphore-and-semaphoreslim.md) article and the <xref:System.Threading.Semaphore> or <xref:System.Threading.SemaphoreSlim> API reference.</span></span>

## <a name="thread-interaction-or-signaling"></a><span data-ttu-id="2c386-167">Взаимодействие потоков или сигнализация</span><span class="sxs-lookup"><span data-stu-id="2c386-167">Thread interaction, or signaling</span></span>

<span data-ttu-id="2c386-168">Взаимодействие потоков (или сигнализация потоков) означает, что поток должен ждать уведомления или сигнала от одного или нескольких потоков, чтобы продолжить.</span><span class="sxs-lookup"><span data-stu-id="2c386-168">Thread interaction (or thread signaling) means that a thread must wait for notification, or a signal, from one or more threads in order to proceed.</span></span> <span data-ttu-id="2c386-169">Например, если поток A вызывает метод <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> потока B, поток А блокируется до завершения потока B.</span><span class="sxs-lookup"><span data-stu-id="2c386-169">For example, if thread A calls the <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> method of thread B, thread A is blocked until thread B completes.</span></span> <span data-ttu-id="2c386-170">Примитивы синхронизации, описанные в предыдущем разделе, реализуют другой механизм сигнализации: снятие блокировки потоком является сигналом другому потоку о возможности продолжать исполнение, получив блокировку.</span><span class="sxs-lookup"><span data-stu-id="2c386-170">The synchronization primitives described in the preceding section provide a different mechanism for signaling: by releasing a lock, a thread notifies another thread that it can proceed by acquiring the lock.</span></span>

<span data-ttu-id="2c386-171">В этом разделе описываются дополнительные сигнальные конструкции, предоставляемые .NET.</span><span class="sxs-lookup"><span data-stu-id="2c386-171">This section describes additional signaling constructs provided by .NET.</span></span>

### <a name="eventwaithandle-autoresetevent-manualresetevent-and-manualreseteventslim-classes"></a><span data-ttu-id="2c386-172">Классы EventWaitHandle, AutoResetEvent и ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="2c386-172">EventWaitHandle, AutoResetEvent, ManualResetEvent, and ManualResetEventSlim classes</span></span>

<span data-ttu-id="2c386-173">Класс <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> представляет событие синхронизации потока.</span><span class="sxs-lookup"><span data-stu-id="2c386-173">The <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> class represents a thread synchronization event.</span></span>

<span data-ttu-id="2c386-174">Событие синхронизации может находиться в сигнальном или несигнальном состоянии.</span><span class="sxs-lookup"><span data-stu-id="2c386-174">A synchronization event can be either in an unsignaled or signaled state.</span></span> <span data-ttu-id="2c386-175">Если состояние события несигнальное, поток, который вызывает перегрузку события <xref:System.Threading.WaitHandle.WaitOne%2A?>, будет заблокирован, пока состояние события не станет сигнальным.</span><span class="sxs-lookup"><span data-stu-id="2c386-175">When the state of an event is unsignaled, a thread that calls the event's <xref:System.Threading.WaitHandle.WaitOne%2A?> overload is blocked until an event is signaled.</span></span> <span data-ttu-id="2c386-176">Метод <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> задает сигнальное состояние события.</span><span class="sxs-lookup"><span data-stu-id="2c386-176">The <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method sets the state of an event to signaled.</span></span>

<span data-ttu-id="2c386-177">Поведение <xref:System.Threading.EventWaitHandle> после получения сигнала зависит от его режима сброса:</span><span class="sxs-lookup"><span data-stu-id="2c386-177">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode:</span></span>

- <span data-ttu-id="2c386-178"><xref:System.Threading.EventWaitHandle>, созданный с помощью флага <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>, автоматически сбрасывается после освобождения одного потока в состоянии ожидания.</span><span class="sxs-lookup"><span data-stu-id="2c386-178">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically after releasing a single waiting thread.</span></span> <span data-ttu-id="2c386-179">Это похоже на турникет, пропускающий только один поток каждый раз, когда он переводится в сигнальное состояние.</span><span class="sxs-lookup"><span data-stu-id="2c386-179">It's like a turnstile that allows only one thread through each time it's signaled.</span></span> <span data-ttu-id="2c386-180">Такое поведение характерно для класса <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, наследующего <xref:System.Threading.EventWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="2c386-180">The <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span>
- <span data-ttu-id="2c386-181"><xref:System.Threading.EventWaitHandle>, созданный с помощью флага <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>, находится в сигнальном состоянии, пока не будет вызван его метод <xref:System.Threading.EventWaitHandle.Reset%2A>.</span><span class="sxs-lookup"><span data-stu-id="2c386-181">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="2c386-182">Это как ворота, которые закрыты до получения сигнала и остающиеся затем открытыми, пока кто-нибудь их не закроет.</span><span class="sxs-lookup"><span data-stu-id="2c386-182">It's like a gate that is closed until signaled and then stays open until someone closes it.</span></span> <span data-ttu-id="2c386-183">Такое поведение характерно для класса <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, наследующего <xref:System.Threading.EventWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="2c386-183">The <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span> <span data-ttu-id="2c386-184">Класс <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> является упрощенной альтернативой <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="2c386-184">The <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> class is a lightweight alternative to <xref:System.Threading.ManualResetEvent>.</span></span>

<span data-ttu-id="2c386-185">В Windows можно использовать <xref:System.Threading.EventWaitHandle> для синхронизации между процессами.</span><span class="sxs-lookup"><span data-stu-id="2c386-185">On Windows, you can use <xref:System.Threading.EventWaitHandle> for the inter-process synchronization.</span></span> <span data-ttu-id="2c386-186">Для этого необходимо создать экземпляр <xref:System.Threading.EventWaitHandle>, выполняющий роль именованного системного события синхронизации. Это можно сделать с помощью [конструкторов EventWaitHandle](<xref:System.Threading.EventWaitHandle.%23ctor%2A>), которые задают имя или метод <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2c386-186">To do that, create a <xref:System.Threading.EventWaitHandle> instance that represents a named system synchronization event by using one of the [EventWaitHandle constructors](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) that specifies a name or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="2c386-187">Дополнительные сведения см. в статье о [EventWaitHandle](eventwaithandle.md).</span><span class="sxs-lookup"><span data-stu-id="2c386-187">For more information, see the [EventWaitHandle](eventwaithandle.md) article.</span></span> <span data-ttu-id="2c386-188">Справочные сведения об API см. здесь: <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent> и <xref:System.Threading.ManualResetEventSlim>.</span><span class="sxs-lookup"><span data-stu-id="2c386-188">For the API reference, see <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent>, and <xref:System.Threading.ManualResetEventSlim>.</span></span>

### <a name="countdownevent-class"></a><span data-ttu-id="2c386-189">Класс CountdownEvent</span><span class="sxs-lookup"><span data-stu-id="2c386-189">CountdownEvent class</span></span>

<span data-ttu-id="2c386-190">Класс <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> представляет событие, возникающее, когда его счетчик имеет значение ноль.</span><span class="sxs-lookup"><span data-stu-id="2c386-190">The <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> class represents an event that becomes set when its count is zero.</span></span> <span data-ttu-id="2c386-191">Когда <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> не равен нулю, поток, который вызывает <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType>, блокируется.</span><span class="sxs-lookup"><span data-stu-id="2c386-191">While <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> is greater than zero, a thread that calls <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> is blocked.</span></span> <span data-ttu-id="2c386-192">Вызовите <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType>, чтобы уменьшить значение счетчика события.</span><span class="sxs-lookup"><span data-stu-id="2c386-192">Call <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> to decrement an event's count.</span></span>

<span data-ttu-id="2c386-193">В отличие от <xref:System.Threading.ManualResetEvent> или <xref:System.Threading.ManualResetEventSlim>, которые позволяют разблокировать несколько потоков с помощью сигнала от одного потока, <xref:System.Threading.CountdownEvent> может разблокировать один или несколько потоков с помощью сигналов от нескольких потоков.</span><span class="sxs-lookup"><span data-stu-id="2c386-193">In contrast to <xref:System.Threading.ManualResetEvent> or <xref:System.Threading.ManualResetEventSlim>, which you can use to unblock multiple threads with a signal from one thread, you can use <xref:System.Threading.CountdownEvent> to unblock one or more threads with signals from multiple threads.</span></span>

<span data-ttu-id="2c386-194">Дополнительные сведения см. в статье о [CountdownEvent](countdownevent.md) и справочной документации по API <xref:System.Threading.CountdownEvent>.</span><span class="sxs-lookup"><span data-stu-id="2c386-194">For more information, see the [CountdownEvent](countdownevent.md) article and the <xref:System.Threading.CountdownEvent> API reference.</span></span>

### <a name="barrier-class"></a><span data-ttu-id="2c386-195">Класс Barrier</span><span class="sxs-lookup"><span data-stu-id="2c386-195">Barrier class</span></span>

<span data-ttu-id="2c386-196">Класс <xref:System.Threading.Barrier?displayProperty=nameWithType> представляет барьер выполнения потоков.</span><span class="sxs-lookup"><span data-stu-id="2c386-196">The <xref:System.Threading.Barrier?displayProperty=nameWithType> class represents a thread execution barrier.</span></span> <span data-ttu-id="2c386-197">Поток, который вызывает метод <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType>, сообщает, что он достиг барьера и ожидает, пока другие участвующие потоки не достигнут барьера.</span><span class="sxs-lookup"><span data-stu-id="2c386-197">A thread that calls the <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> method signals that it reached the barrier and waits until other participant threads reach the barrier.</span></span> <span data-ttu-id="2c386-198">Когда все участвующие потоки достигают барьера, их выполнение продолжается, а барьер сбрасывается и может использоваться повторно.</span><span class="sxs-lookup"><span data-stu-id="2c386-198">When all participant threads reach the barrier, they proceed and the barrier is reset and can be used again.</span></span>

<span data-ttu-id="2c386-199">Можно использовать <xref:System.Threading.Barrier>, если одному или нескольким потокам требуются результаты других потоков для перехода к следующему этапу вычисления.</span><span class="sxs-lookup"><span data-stu-id="2c386-199">You might use <xref:System.Threading.Barrier> when one or more threads require the results of other threads before proceeding to the next computation phase.</span></span>

<span data-ttu-id="2c386-200">Дополнительные сведения см. в статье о [Barrier](barrier.md) и справочной документации по API <xref:System.Threading.Barrier>.</span><span class="sxs-lookup"><span data-stu-id="2c386-200">For more information, see the [Barrier](barrier.md) article and the <xref:System.Threading.Barrier> API reference.</span></span>

## <a name="interlocked-class"></a><span data-ttu-id="2c386-201">Interlocked класс</span><span class="sxs-lookup"><span data-stu-id="2c386-201">Interlocked class</span></span>

<span data-ttu-id="2c386-202">Класс <xref:System.Threading.Interlocked?displayProperty=nameWithType> предоставляет статические методы, которые выполняют простые атомарные операции над переменной.</span><span class="sxs-lookup"><span data-stu-id="2c386-202">The <xref:System.Threading.Interlocked?displayProperty=nameWithType> class provides static methods that perform simple atomic operations on a variable.</span></span> <span data-ttu-id="2c386-203">К этим атомарным операциям относится добавление, инкремент и декремент, обмен и условный обмен, зависящий от сравнения, а также операция чтения 64-разрядного целого числа.</span><span class="sxs-lookup"><span data-stu-id="2c386-203">Those atomic operations include addition, increment and decrement, exchange and conditional exchange that depends on a comparison, and read operation of a 64-bit integer value.</span></span>

<span data-ttu-id="2c386-204">Дополнительные сведения см. в справочной документации по API <xref:System.Threading.Interlocked>.</span><span class="sxs-lookup"><span data-stu-id="2c386-204">For more information, see the <xref:System.Threading.Interlocked> API reference.</span></span>

## <a name="spinwait-structure"></a><span data-ttu-id="2c386-205">Структура SpinWait</span><span class="sxs-lookup"><span data-stu-id="2c386-205">SpinWait structure</span></span>

<span data-ttu-id="2c386-206">Структура <xref:System.Threading.SpinWait?displayProperty=nameWithType> обеспечивает поддержку ожидания спин-блокировки.</span><span class="sxs-lookup"><span data-stu-id="2c386-206">The <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure provides support for spin-based waiting.</span></span> <span data-ttu-id="2c386-207">Ее можно использовать, когда потоку нужно дождаться возникновения события или выполнения условия, но фактическое время ожидания будет меньше периода, требуемого для применения дескриптора ожидания или других способов блокировки потока.</span><span class="sxs-lookup"><span data-stu-id="2c386-207">You might want to use it when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the thread.</span></span> <span data-ttu-id="2c386-208">Используя <xref:System.Threading.SpinWait>, можно задать короткий интервал времени для цикла ожидания, а затем вернуть управление (например, с помощью ожидания или спящего режима), только если условие не было выполнено в течение заданного времени.</span><span class="sxs-lookup"><span data-stu-id="2c386-208">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>

<span data-ttu-id="2c386-209">Дополнительные сведения см. в статье о [SpinWait](spinwait.md) и справочной документации по API <xref:System.Threading.SpinWait>.</span><span class="sxs-lookup"><span data-stu-id="2c386-209">For more information, see the [SpinWait](spinwait.md) article and the <xref:System.Threading.SpinWait> API reference.</span></span>

## <a name="see-also"></a><span data-ttu-id="2c386-210">См. также</span><span class="sxs-lookup"><span data-stu-id="2c386-210">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="2c386-211">Потокобезопасные коллекции</span><span class="sxs-lookup"><span data-stu-id="2c386-211">Thread-safe collections</span></span>](../collections/thread-safe/index.md)
- [<span data-ttu-id="2c386-212">Объекты и функциональные возможности работы с потоками</span><span class="sxs-lookup"><span data-stu-id="2c386-212">Threading objects and features</span></span>](threading-objects-and-features.md)
