---
title: EventWaitHandle
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- threading [.NET Framework], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET Framework]
- threading [.NET Framework], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
ms.openlocfilehash: 80c90254978495a58d228c4302eda84d6165c800
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/15/2020
ms.locfileid: "73138077"
---
# <a name="eventwaithandle"></a><span data-ttu-id="32482-102">EventWaitHandle</span><span class="sxs-lookup"><span data-stu-id="32482-102">EventWaitHandle</span></span>
<span data-ttu-id="32482-103">Класс <xref:System.Threading.EventWaitHandle> позволяет потокам взаимодействовать друг с другом, передавая и ожидая передачи сигналов.</span><span class="sxs-lookup"><span data-stu-id="32482-103">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling and by waiting for signals.</span></span> <span data-ttu-id="32482-104">Дескрипторы ожидания событий (часто их называют просто "события") — это дескрипторы ожидания, которые можно создавать для освобождения одного или нескольких потоков в состоянии ожидания.</span><span class="sxs-lookup"><span data-stu-id="32482-104">Event wait handles (also referred to simply as events) are wait handles that can be signaled in order to release one or more waiting threads.</span></span> <span data-ttu-id="32482-105">Созданное событие (дескриптор ожидания) затем сбрасывается вручную или автоматически.</span><span class="sxs-lookup"><span data-stu-id="32482-105">After it is signaled, an event wait handle is reset either manually or automatically.</span></span> <span data-ttu-id="32482-106">Класс <xref:System.Threading.EventWaitHandle> может представлять любой локальный дескриптор ожидания событий (локальное событие) или именованный системный дескриптор ожидания событий (именованное событие), который доступен для всех процессов.</span><span class="sxs-lookup"><span data-stu-id="32482-106">The <xref:System.Threading.EventWaitHandle> class can represent either a local event wait handle (local event) or a named system event wait handle (named event or system event, visible to all processes).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="32482-107">Дескрипторы ожидания событий не являются [событиями](../events/index.md) .NET.</span><span class="sxs-lookup"><span data-stu-id="32482-107">Event wait handles are not .NET [events](../events/index.md).</span></span> <span data-ttu-id="32482-108">Для них не существует делегатов или обработчиков.</span><span class="sxs-lookup"><span data-stu-id="32482-108">There are no delegates or event handlers involved.</span></span> <span data-ttu-id="32482-109">Слово "событие" здесь используется лишь потому, что такие дескрипторы традиционно именовались событиями операционной системы, а при создании дескриптора ожидания и потоков в состоянии ожидания передаются сведения о том, что произошло событие.</span><span class="sxs-lookup"><span data-stu-id="32482-109">The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.</span></span>  
  
 <span data-ttu-id="32482-110">Как локальные, так и именованные дескрипторы ожидания событий используют системные объекты синхронизации, защищенные оболочками <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> для правильного освобождения ресурсов.</span><span class="sxs-lookup"><span data-stu-id="32482-110">Both local and named event wait handles use system synchronization objects, which are protected by <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers to ensure that the resources are released.</span></span> <span data-ttu-id="32482-111">Вы можете использовать метод <xref:System.Threading.WaitHandle.Dispose%2A>, чтобы освободить ресурсы, как только закончите работу с объектом.</span><span class="sxs-lookup"><span data-stu-id="32482-111">You can use the <xref:System.Threading.WaitHandle.Dispose%2A> method to free the resources immediately when you have finished using the object.</span></span>  
  
## <a name="event-wait-handles-that-reset-automatically"></a><span data-ttu-id="32482-112">Дескрипторы ожидания событий, которые сбрасываются автоматически</span><span class="sxs-lookup"><span data-stu-id="32482-112">Event Wait Handles That Reset Automatically</span></span>  
 <span data-ttu-id="32482-113">Чтобы создать событие с автоматическим сбросом, укажите <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> при создании объекта <xref:System.Threading.EventWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="32482-113">You create an automatic reset event by specifying <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="32482-114">Как можно понять по имени, это событие синхронизации после создания освобождает один поток в состоянии ожидания и автоматически сбрасывается.</span><span class="sxs-lookup"><span data-stu-id="32482-114">As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="32482-115">Чтобы создать событие, вызовите его метод <xref:System.Threading.EventWaitHandle.Set%2A>.</span><span class="sxs-lookup"><span data-stu-id="32482-115">Signal the event by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method.</span></span>  
  
 <span data-ttu-id="32482-116">События с автоматическим сбросом обычно используются, чтобы поочередно предоставлять монопольный доступ к ресурсу для одного потока из нескольких.</span><span class="sxs-lookup"><span data-stu-id="32482-116">Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</span></span> <span data-ttu-id="32482-117">В потоке подается запрос на ресурс. Для этого вызывается метод <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="32482-117">A thread requests the resource by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="32482-118">Если в этот момент ни один поток не удерживает дескриптор ожидания, метод возвращает `true` и предоставляет вызывающему потоку управление ресурсом.</span><span class="sxs-lookup"><span data-stu-id="32482-118">If no other thread is holding the wait handle, the method returns `true` and the calling thread has control of the resource.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="32482-119">Как и для всех механизмов синхронизации, необходимо гарантировать во всех ветвях кода правильное ожидание дескриптора перед осуществлением доступа к защищенному ресурсу.</span><span class="sxs-lookup"><span data-stu-id="32482-119">As with all synchronization mechanisms, you must ensure that all code paths wait on the appropriate wait handle before accessing a protected resource.</span></span> <span data-ttu-id="32482-120">Синхронизация потоков выполняется совместно.</span><span class="sxs-lookup"><span data-stu-id="32482-120">Thread synchronization is cooperative.</span></span>  
  
 <span data-ttu-id="32482-121">Если событие с автоматическим сбросом создается при отсутствии потоков в состоянии ожидания, оно сохраняет свой статус, пока не получит обращение от потока.</span><span class="sxs-lookup"><span data-stu-id="32482-121">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="32482-122">Тогда событие освобождает поток и немедленно сбрасывается, блокируя следующие потоки.</span><span class="sxs-lookup"><span data-stu-id="32482-122">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
## <a name="event-wait-handles-that-reset-manually"></a><span data-ttu-id="32482-123">Дескрипторы ожидания событий, которые сбрасываются вручную</span><span class="sxs-lookup"><span data-stu-id="32482-123">Event Wait Handles That Reset Manually</span></span>  
 <span data-ttu-id="32482-124">Чтобы создать событие со сбросом вручную, укажите <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> при создании объекта <xref:System.Threading.EventWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="32482-124">You create a manual reset event by specifying <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="32482-125">Как можно понять по имени, это событие синхронизации после создания сбрасывается вручную.</span><span class="sxs-lookup"><span data-stu-id="32482-125">As its name implies, this synchronization event must be reset manually after it has been signaled.</span></span> <span data-ttu-id="32482-126">Пока не будет вызван метод <xref:System.Threading.EventWaitHandle.Reset%2A> для сброса события, все потоки, ожидающие этот дескриптор события, продолжают работу немедленно и без блокировки.</span><span class="sxs-lookup"><span data-stu-id="32482-126">Until it is reset, by calling its <xref:System.Threading.EventWaitHandle.Reset%2A> method, threads that wait on the event handle proceed immediately without blocking.</span></span>  
  
 <span data-ttu-id="32482-127">Событие со сбросом вручную действует как ворота загона.</span><span class="sxs-lookup"><span data-stu-id="32482-127">A manual reset event acts like the gate of a corral.</span></span> <span data-ttu-id="32482-128">Пока событие не создано, потоки ожидают его, как стадо лошадей в загоне.</span><span class="sxs-lookup"><span data-stu-id="32482-128">When the event is not signaled, threads that wait on it block, like horses in a corral.</span></span> <span data-ttu-id="32482-129">Сразу после создания события путем вызова метода <xref:System.Threading.EventWaitHandle.Set%2A> все потоки в состоянии ожидания освобождаются и могут продолжать работу.</span><span class="sxs-lookup"><span data-stu-id="32482-129">When the event is signaled, by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, all waiting threads are free to proceed.</span></span> <span data-ttu-id="32482-130">Событие сохраняет статус созданного, пока не будет вызван его метод <xref:System.Threading.EventWaitHandle.Reset%2A>.</span><span class="sxs-lookup"><span data-stu-id="32482-130">The event remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="32482-131">Благодаря этому свойству событие со сбросом вручную идеально подходит для ситуации, когда нужно удерживать несколько потоков в ожидании завершения конкретной задачи.</span><span class="sxs-lookup"><span data-stu-id="32482-131">This makes the manual reset event an ideal way to hold up threads that need to wait until one thread finishes a task.</span></span>  
  
 <span data-ttu-id="32482-132">Как и лошадям, выходящим из загона, освобожденным потокам потребуется некоторое время, пока операционная система сможет возобновить их выполнение.</span><span class="sxs-lookup"><span data-stu-id="32482-132">Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</span></span> <span data-ttu-id="32482-133">Если метод <xref:System.Threading.EventWaitHandle.Reset%2A> будет вызван раньше, чем все эти потоки возобновят выполнение, оставшиеся в ожидании потоки снова будут заблокированы.</span><span class="sxs-lookup"><span data-stu-id="32482-133">If the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called before all the threads have resumed execution, the remaining threads once again block.</span></span> <span data-ttu-id="32482-134">Какие конкретно потоки начнут работу, а какие снова останутся ожидать, зависит от многих случайных факторов, таких как загрузка системы, количество ожидающих выполнения потоков и т. д.</span><span class="sxs-lookup"><span data-stu-id="32482-134">Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</span></span> <span data-ttu-id="32482-135">Не возникнет никаких проблем, если поток, в котором создается событие, завершится сразу после его создания. Это самый распространенный вариант использования этого подхода.</span><span class="sxs-lookup"><span data-stu-id="32482-135">This is not a problem if the thread that signals the event ends after signaling, which is the most common usage pattern.</span></span> <span data-ttu-id="32482-136">Если нужно, чтобы создающий событие поток начал выполнение новой задачи только после того, как все потоки в состоянии ожидания возобновят работу, заблокируйте его.</span><span class="sxs-lookup"><span data-stu-id="32482-136">If you want the thread that signaled the event to begin a new task after all the waiting threads have resumed, you must block it until all the waiting threads have resumed.</span></span> <span data-ttu-id="32482-137">Иначе возникнет состояние гонки и поведение кода будет непредсказуемым.</span><span class="sxs-lookup"><span data-stu-id="32482-137">Otherwise, you have a race condition, and the behavior of your code is unpredictable.</span></span>  
  
## <a name="features-common-to-automatic-and-manual-events"></a><span data-ttu-id="32482-138">Общие свойства событий с автоматическим сбросом и сбросом вручную</span><span class="sxs-lookup"><span data-stu-id="32482-138">Features Common to Automatic and Manual Events</span></span>  
 <span data-ttu-id="32482-139">Как правило, <xref:System.Threading.EventWaitHandle> блокирует один или несколько потоков, пока незаблокированный поток не вызовет метод <xref:System.Threading.EventWaitHandle.Set%2A>, который освобождает один из потоков в состоянии ожидания (если это событие с автоматическим сбросом) или все потоки сразу (если это событие со сбросом вручную).</span><span class="sxs-lookup"><span data-stu-id="32482-139">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, which releases one of the waiting threads (in the case of automatic reset events) or all of them (in the case of manual reset events).</span></span> <span data-ttu-id="32482-140">Поток может создать событие <xref:System.Threading.EventWaitHandle> и заблокироваться в ожидании этого же события в рамках одной атомарной операции, вызвав статический метод <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="32482-140">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, as an atomic operation, by calling the static <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="32482-141">В статических методах <xref:System.Threading.EventWaitHandle> и <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> можно использовать объекты <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="32482-141"><xref:System.Threading.EventWaitHandle> objects can be used with the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="32482-142">Так как классы <xref:System.Threading.EventWaitHandle> и <xref:System.Threading.Mutex> являются производными от <xref:System.Threading.WaitHandle>, вы можете использовать оба этих класса с этими методами.</span><span class="sxs-lookup"><span data-stu-id="32482-142">Because the <xref:System.Threading.EventWaitHandle> and <xref:System.Threading.Mutex> classes both derive from <xref:System.Threading.WaitHandle>, you can use both classes with these methods.</span></span>  
  
### <a name="named-events"></a><span data-ttu-id="32482-143">Именованные события</span><span class="sxs-lookup"><span data-stu-id="32482-143">Named Events</span></span>  
 <span data-ttu-id="32482-144">Операционная система Windows позволяет присваивать имена дескрипторам ожидания.</span><span class="sxs-lookup"><span data-stu-id="32482-144">The Windows operating system allows event wait handles to have names.</span></span> <span data-ttu-id="32482-145">Именованное событие применяется во всей системе.</span><span class="sxs-lookup"><span data-stu-id="32482-145">A named event is system wide.</span></span> <span data-ttu-id="32482-146">Это означает, что после создания именованное событие будет видимым для всех потоков во всех процессах.</span><span class="sxs-lookup"><span data-stu-id="32482-146">That is, once the named event is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="32482-147">Таким образом, именованное событие можно использовать для синхронизации действий в разных процессах и потоках.</span><span class="sxs-lookup"><span data-stu-id="32482-147">Thus, named events can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="32482-148">Вы можете создать объект <xref:System.Threading.EventWaitHandle>, который представляет именованное системное событие, с помощью любого из конструкторов, использующих имя события.</span><span class="sxs-lookup"><span data-stu-id="32482-148">You can create an <xref:System.Threading.EventWaitHandle> object that represents a named system event by using one of the constructors that specifies an event name.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="32482-149">Так как именованные события доступны во всей системе, может существовать несколько объектов <xref:System.Threading.EventWaitHandle>, представляющих одно и то же именованное событие.</span><span class="sxs-lookup"><span data-stu-id="32482-149">Because named events are system wide, it is possible to have multiple <xref:System.Threading.EventWaitHandle> objects that represent the same named event.</span></span> <span data-ttu-id="32482-150">При каждом вызове конструктора или метода <xref:System.Threading.EventWaitHandle.OpenExisting%2A> создается новый объект <xref:System.Threading.EventWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="32482-150">Each time you call a constructor, or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, a new <xref:System.Threading.EventWaitHandle> object is created.</span></span> <span data-ttu-id="32482-151">Если указать одно и то же имя несколько раз, создается несколько объектов, представляющих одно и то же именованное событие.</span><span class="sxs-lookup"><span data-stu-id="32482-151">Specifying the same name repeatedly creates multiple objects that represent the same named event.</span></span>  
  
 <span data-ttu-id="32482-152">При использовании именованных событий следует соблюдать осторожность.</span><span class="sxs-lookup"><span data-stu-id="32482-152">Caution is advised in using named events.</span></span> <span data-ttu-id="32482-153">Поскольку они доступны во всей системе, другой процесс может использовать это же имя события и случайно заблокировать все ваши потоки.</span><span class="sxs-lookup"><span data-stu-id="32482-153">Because they are system wide, another process that uses the same name can block your threads unexpectedly.</span></span> <span data-ttu-id="32482-154">Вредоносный код, выполняемый на одном компьютере может использовать это как основу для атак типа "отказ в обслуживании".</span><span class="sxs-lookup"><span data-stu-id="32482-154">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="32482-155">Чтобы защитить объект <xref:System.Threading.EventWaitHandle>, представляющий именованное событие, примените механизм безопасности управления доступом. Лучше всего использовать конструктор, который определяет объект <xref:System.Security.AccessControl.EventWaitHandleSecurity>.</span><span class="sxs-lookup"><span data-stu-id="32482-155">Use access control security to protect an <xref:System.Threading.EventWaitHandle> object that represents a named event, preferably by using a constructor that specifies an <xref:System.Security.AccessControl.EventWaitHandleSecurity> object.</span></span> <span data-ttu-id="32482-156">Метод <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> тоже обеспечит безопасность управления доступом, но такой подход оставит систему уязвимой в период между созданием и защитой дескриптора ожидания.</span><span class="sxs-lookup"><span data-stu-id="32482-156">You can also apply access control security using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, but this leaves a window of vulnerability between the time the event wait handle is created and the time it is protected.</span></span> <span data-ttu-id="32482-157">Защита событий с помощью безопасности управления доступом предотвращает атаки злоумышленников, но не решает проблемы непреднамеренного конфликта имен.</span><span class="sxs-lookup"><span data-stu-id="32482-157">Protecting events with access control security helps prevent malicious attacks, but it does not solve the problem of unintentional name collisions.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="32482-158">В отличие от класса <xref:System.Threading.EventWaitHandle>, производные классы <xref:System.Threading.AutoResetEvent> и <xref:System.Threading.ManualResetEvent> могут представлять только локальные дескрипторы ожидания.</span><span class="sxs-lookup"><span data-stu-id="32482-158">Unlike the <xref:System.Threading.EventWaitHandle> class, the derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> can represent only local wait handles.</span></span> <span data-ttu-id="32482-159">Они не могут представлять именованные системные события.</span><span class="sxs-lookup"><span data-stu-id="32482-159">They cannot represent named system events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="32482-160">См. также раздел</span><span class="sxs-lookup"><span data-stu-id="32482-160">See also</span></span>

- <xref:System.Threading.EventWaitHandle>
- <xref:System.Threading.WaitHandle>
- <xref:System.Threading.AutoResetEvent>
- <xref:System.Threading.ManualResetEvent>
