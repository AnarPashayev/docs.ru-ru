---
title: Управляемые и неуправляемые потоки в Windows
ms.date: 10/24/2018
elpviewer_keywords:
- threading [.NET], unmanaged
- threading [.NET], managed
- threading [.NET], managed
- threads and fibers [.NET]
- managed threading
ms.assetid: 4fb6452f-c071-420d-9e71-da16dee7a1eb
ms.openlocfilehash: 67d8fdb5f2e49930b25328c1dfd30a6105fd636f
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/18/2020
ms.locfileid: "94826330"
---
# <a name="managed-and-unmanaged-threading-in-windows"></a><span data-ttu-id="bb47f-102">Управляемые и неуправляемые потоки в Windows</span><span class="sxs-lookup"><span data-stu-id="bb47f-102">Managed and unmanaged threading in Windows</span></span>

<span data-ttu-id="bb47f-103">Управление всеми потоками осуществляется посредством класса <xref:System.Threading.Thread> , включая потоки, созданные средой CLR или созданные за пределами среды выполнения и входящие в управляемую среду для выполнения кода.</span><span class="sxs-lookup"><span data-stu-id="bb47f-103">Management of all threads is done through the <xref:System.Threading.Thread> class, including threads created by the common language runtime and those created outside the runtime that enter the managed environment to execute code.</span></span> <span data-ttu-id="bb47f-104">Среда выполнения отслеживает в своем процессе все потоки, которые когда-либо выполняли код в управляемой среде.</span><span class="sxs-lookup"><span data-stu-id="bb47f-104">The runtime monitors all the threads in its process that have ever executed code within the managed execution environment.</span></span> <span data-ttu-id="bb47f-105">Другие потоки она не отслеживает.</span><span class="sxs-lookup"><span data-stu-id="bb47f-105">It does not track any other threads.</span></span> <span data-ttu-id="bb47f-106">Потоки могут входить в управляемую среду выполнения посредством COM-взаимодействия (так как среда выполнения предоставляет управляемые объекты неуправляемой среде в качестве COM-объектов), функции COM [DllGetClassObject](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) и вызова неуправляемого кода.</span><span class="sxs-lookup"><span data-stu-id="bb47f-106">Threads can enter the managed execution environment through COM interop (because the runtime exposes managed objects as COM objects to the unmanaged world), the COM [DllGetClassObject](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) function, and platform invoke.</span></span>  
  
 <span data-ttu-id="bb47f-107">Когда неуправляемый поток входит в среду выполнения, например, посредством вызываемой оболочки COM, система проверяет локальное хранилище потока данного потока для поиска внутреннего управляемого объекта <xref:System.Threading.Thread> .</span><span class="sxs-lookup"><span data-stu-id="bb47f-107">When an unmanaged thread enters the runtime through, for example, a COM callable wrapper, the system checks the thread-local store of that thread to look for an internal managed <xref:System.Threading.Thread> object.</span></span> <span data-ttu-id="bb47f-108">Если он найден, среда выполнения уже оповещена об этом потоке.</span><span class="sxs-lookup"><span data-stu-id="bb47f-108">If one is found, the runtime is already aware of this thread.</span></span> <span data-ttu-id="bb47f-109">Если найти объект не удается, среда выполнения создает новый объект <xref:System.Threading.Thread> и устанавливает его в локальном хранилище потока данного потока.</span><span class="sxs-lookup"><span data-stu-id="bb47f-109">If it cannot find one, however, the runtime builds a new <xref:System.Threading.Thread> object and installs it in the thread-local store of that thread.</span></span>  
  
 <span data-ttu-id="bb47f-110">При использовании управляемых потоков <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> является стабильным средством идентификации управляемого потока.</span><span class="sxs-lookup"><span data-stu-id="bb47f-110">In managed threading, <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> is the stable managed thread identification.</span></span> <span data-ttu-id="bb47f-111">В течение времени существования вашего потока он не будет конфликтовать со значением из любого другого потока независимо от того, из какого домена приложения вы получили это значение.</span><span class="sxs-lookup"><span data-stu-id="bb47f-111">For the lifetime of your thread, it will not collide with the value from any other thread, regardless of the application domain from which you obtain this value.</span></span>  
  
## <a name="mapping-from-win32-threading-to-managed-threading"></a><span data-ttu-id="bb47f-112">Сопоставление потоков Win32 с управляемыми потоками</span><span class="sxs-lookup"><span data-stu-id="bb47f-112">Mapping from Win32 threading to managed threading</span></span>

 <span data-ttu-id="bb47f-113">В следующей таблице элементы потоков Win32 сопоставляются со своими ближайшими аналогами из среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="bb47f-113">The following table maps Win32 threading elements to their approximate runtime equivalent.</span></span> <span data-ttu-id="bb47f-114">Обратите внимание, что такое сопоставление не означает идентичную функциональность.</span><span class="sxs-lookup"><span data-stu-id="bb47f-114">Note that this mapping does not represent identical functionality.</span></span> <span data-ttu-id="bb47f-115">Например, **TerminateThread** не выполняет предложения **finally** , не освобождает ресурсы и не может быть запрещен.</span><span class="sxs-lookup"><span data-stu-id="bb47f-115">For example, **TerminateThread** does not execute **finally** clauses or free up resources, and cannot be prevented.</span></span> <span data-ttu-id="bb47f-116">Однако <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> выполняет весь ваш код отката, освобождает все ресурсы и может быть отменен с помощью <xref:System.Threading.Thread.ResetAbort%2A>.</span><span class="sxs-lookup"><span data-stu-id="bb47f-116">However, <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> executes all your rollback code, reclaims all the resources, and can be denied using <xref:System.Threading.Thread.ResetAbort%2A>.</span></span> <span data-ttu-id="bb47f-117">Прежде чем делать предположения о функциональности, тщательно изучите документацию.</span><span class="sxs-lookup"><span data-stu-id="bb47f-117">Be sure to read the documentation closely before making assumptions about functionality.</span></span>  
  
|<span data-ttu-id="bb47f-118">В Win32</span><span class="sxs-lookup"><span data-stu-id="bb47f-118">In Win32</span></span>|<span data-ttu-id="bb47f-119">В среде CLR</span><span class="sxs-lookup"><span data-stu-id="bb47f-119">In the common language runtime</span></span>|  
|--------------|------------------------------------|  
|<span data-ttu-id="bb47f-120">**CreateThread**</span><span class="sxs-lookup"><span data-stu-id="bb47f-120">**CreateThread**</span></span>|<span data-ttu-id="bb47f-121">Сочетание **Thread** и <xref:System.Threading.ThreadStart></span><span class="sxs-lookup"><span data-stu-id="bb47f-121">Combination of **Thread** and <xref:System.Threading.ThreadStart></span></span>|  
|<span data-ttu-id="bb47f-122">**TerminateThread**</span><span class="sxs-lookup"><span data-stu-id="bb47f-122">**TerminateThread**</span></span>|<xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="bb47f-123">**SuspendThread**</span><span class="sxs-lookup"><span data-stu-id="bb47f-123">**SuspendThread**</span></span>|<xref:System.Threading.Thread.Suspend%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="bb47f-124">**ResumeThread**</span><span class="sxs-lookup"><span data-stu-id="bb47f-124">**ResumeThread**</span></span>|<xref:System.Threading.Thread.Resume%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="bb47f-125">**Sleep**</span><span class="sxs-lookup"><span data-stu-id="bb47f-125">**Sleep**</span></span>|<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="bb47f-126">**WaitForSingleObject** в дескрипторе потока</span><span class="sxs-lookup"><span data-stu-id="bb47f-126">**WaitForSingleObject** on the thread handle</span></span>|<xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="bb47f-127">**ExitThread**</span><span class="sxs-lookup"><span data-stu-id="bb47f-127">**ExitThread**</span></span>|<span data-ttu-id="bb47f-128">Эквивалент отсутствует</span><span class="sxs-lookup"><span data-stu-id="bb47f-128">No equivalent</span></span>|  
|<span data-ttu-id="bb47f-129">**GetCurrentThread**</span><span class="sxs-lookup"><span data-stu-id="bb47f-129">**GetCurrentThread**</span></span>|<xref:System.Threading.Thread.CurrentThread%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="bb47f-130">**SetThreadPriority**</span><span class="sxs-lookup"><span data-stu-id="bb47f-130">**SetThreadPriority**</span></span>|<xref:System.Threading.Thread.Priority%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="bb47f-131">Эквивалент отсутствует</span><span class="sxs-lookup"><span data-stu-id="bb47f-131">No equivalent</span></span>|<xref:System.Threading.Thread.Name%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="bb47f-132">Эквивалент отсутствует</span><span class="sxs-lookup"><span data-stu-id="bb47f-132">No equivalent</span></span>|<xref:System.Threading.Thread.IsBackground%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="bb47f-133">Близко к **CoInitializeEx** (OLE32.DLL)</span><span class="sxs-lookup"><span data-stu-id="bb47f-133">Close to **CoInitializeEx** (OLE32.DLL)</span></span>|<xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>|  
  
## <a name="managed-threads-and-com-apartments"></a><span data-ttu-id="bb47f-134">Управляемые потоки и подразделения COM</span><span class="sxs-lookup"><span data-stu-id="bb47f-134">Managed threads and COM apartments</span></span>

<span data-ttu-id="bb47f-135">Управляемый поток может быть отмечен для указания того, что в нем будет размещаться [однопотоковое](/windows/desktop/com/single-threaded-apartments) или [многопотоковое](/windows/desktop/com/multithreaded-apartments) подразделение.</span><span class="sxs-lookup"><span data-stu-id="bb47f-135">A managed thread can be marked to indicate that it will host a [single-threaded](/windows/desktop/com/single-threaded-apartments) or [multithreaded](/windows/desktop/com/multithreaded-apartments) apartment.</span></span> <span data-ttu-id="bb47f-136">(Дополнительные сведения об архитектуре потоков COM см. в статье [Processes, Threads, and Apartments](/windows/desktop/com/processes--threads--and-apartments) (Процессы, потоки и подразделения)). Методы <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A> и <xref:System.Threading.Thread.TrySetApartmentState%2A> класса <xref:System.Threading.Thread> возвращают и назначают состояние подразделения потока.</span><span class="sxs-lookup"><span data-stu-id="bb47f-136">(For more information on the COM threading architecture, see [Processes, Threads, and Apartments](/windows/desktop/com/processes--threads--and-apartments).) The <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods of the <xref:System.Threading.Thread> class return and assign the apartment state of a thread.</span></span> <span data-ttu-id="bb47f-137">Если состояние не задано, <xref:System.Threading.Thread.GetApartmentState%2A> возвращает <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bb47f-137">If the state has not been set, <xref:System.Threading.Thread.GetApartmentState%2A> returns <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="bb47f-138">Свойство можно задать, только когда поток находится в состоянии <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> ; его можно задать только один раз для потока.</span><span class="sxs-lookup"><span data-stu-id="bb47f-138">The property can be set only when the thread is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state; it can be set only once for a thread.</span></span>  
  
 <span data-ttu-id="bb47f-139">Если состояние подразделения не задано до запуска потока, этот поток инициализируется в качестве многопотокового подразделения (MTA).</span><span class="sxs-lookup"><span data-stu-id="bb47f-139">If the apartment state is not set before the thread is started, the thread is initialized as a multithreaded apartment (MTA).</span></span> <span data-ttu-id="bb47f-140">Поток метода завершения и все потоки, управляемые <xref:System.Threading.ThreadPool> , являются многопотоковыми подразделениями.</span><span class="sxs-lookup"><span data-stu-id="bb47f-140">The finalizer thread and all threads controlled by <xref:System.Threading.ThreadPool> are MTA.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="bb47f-141">Для кода запуска приложения единственный способ управления состоянием подразделения заключается в применении <xref:System.MTAThreadAttribute> или <xref:System.STAThreadAttribute> к процедуре точки входа.</span><span class="sxs-lookup"><span data-stu-id="bb47f-141">For application startup code, the only way to control apartment state is to apply the <xref:System.MTAThreadAttribute> or the <xref:System.STAThreadAttribute> to the entry point procedure.</span></span>
  
 <span data-ttu-id="bb47f-142">Управляемые объекты, предоставляемые интерфейсу COM, работают так, как если бы они агрегировали упаковщик в режиме свободного потока.</span><span class="sxs-lookup"><span data-stu-id="bb47f-142">Managed objects that are exposed to COM behave as if they had aggregated the free-threaded marshaler.</span></span> <span data-ttu-id="bb47f-143">Другими словами, их можно вызвать из любого подразделения COM в режиме свободного потока.</span><span class="sxs-lookup"><span data-stu-id="bb47f-143">In other words, they can be called from any COM apartment in a free-threaded manner.</span></span> <span data-ttu-id="bb47f-144">В таком режиме не работают только управляемые объекты, производные от <xref:System.EnterpriseServices.ServicedComponent> или <xref:System.Runtime.InteropServices.StandardOleMarshalObject>.</span><span class="sxs-lookup"><span data-stu-id="bb47f-144">The only managed objects that do not exhibit this free-threaded behavior are those objects that derive from <xref:System.EnterpriseServices.ServicedComponent> or <xref:System.Runtime.InteropServices.StandardOleMarshalObject>.</span></span>  
  
 <span data-ttu-id="bb47f-145">В управляемом коде отсутствует поддержка <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> , если только вы не используете контексты и контекстно-привязанные управляемые экземпляры.</span><span class="sxs-lookup"><span data-stu-id="bb47f-145">In the managed world, there is no support for the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> unless you use contexts and context-bound managed instances.</span></span> <span data-ttu-id="bb47f-146">Если вы используете корпоративные службы, ваш объект должен быть производным от <xref:System.EnterpriseServices.ServicedComponent> (который сам является производным от <xref:System.ContextBoundObject>).</span><span class="sxs-lookup"><span data-stu-id="bb47f-146">If you are using Enterprise Services, then your object must derive from <xref:System.EnterpriseServices.ServicedComponent> (which is itself derived from <xref:System.ContextBoundObject>).</span></span>  
  
 <span data-ttu-id="bb47f-147">Когда управляемый код вызывает COM-объекты, он всегда следует правилам COM.</span><span class="sxs-lookup"><span data-stu-id="bb47f-147">When managed code calls out to COM objects, it always follows COM rules.</span></span> <span data-ttu-id="bb47f-148">Другими словами, он выполняет вызов через прокси-серверы подразделения COM и оболочки контекста COM+ 1.0, как того требует OLE32.</span><span class="sxs-lookup"><span data-stu-id="bb47f-148">In other words, it calls through COM apartment proxies and COM+ 1.0 context wrappers as dictated by OLE32.</span></span>  
  
## <a name="blocking-issues"></a><span data-ttu-id="bb47f-149">Блокирующие проблемы</span><span class="sxs-lookup"><span data-stu-id="bb47f-149">Blocking issues</span></span>  

<span data-ttu-id="bb47f-150">Если поток выполняет неуправляемый вызов для операционной системы, которая заблокировала этот поток в неуправляемом коде, среда выполнения не берет на себя управление им для <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> или <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bb47f-150">If a thread makes an unmanaged call into the operating system that has blocked the thread in unmanaged code, the runtime will not take control of it for <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> or <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bb47f-151">В случае с <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>среда выполнения помечает поток как **Abort** и берет управление, когда он повторно входит в управляемый код.</span><span class="sxs-lookup"><span data-stu-id="bb47f-151">In the case of <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>, the runtime marks the thread for **Abort** and takes control of it when it re-enters managed code.</span></span> <span data-ttu-id="bb47f-152">Вместо неуправляемой блокировки рекомендуется использовать управляемую блокировку.</span><span class="sxs-lookup"><span data-stu-id="bb47f-152">It is preferable for you to use managed blocking rather than unmanaged blocking.</span></span> <span data-ttu-id="bb47f-153"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>,<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType> и др. реагируют на <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> и <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bb47f-153"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>,<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType>, and so on are all responsive to <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> and to <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bb47f-154">Кроме того, если ваш поток находится в однопотоковом подразделении, все эти операции управляемой блокировки будут корректно выдавать сообщения в ваше подразделение, пока поток находится в заблокированном состоянии.</span><span class="sxs-lookup"><span data-stu-id="bb47f-154">Also, if your thread is in a single-threaded apartment, all these managed blocking operations will correctly pump messages in your apartment while your thread is blocked.</span></span>  

## <a name="threads-and-fibers"></a><span data-ttu-id="bb47f-155">Потоки и волокна</span><span class="sxs-lookup"><span data-stu-id="bb47f-155">Threads and fibers</span></span>

<span data-ttu-id="bb47f-156">Потоковая модель .NET не поддерживает [волокна](/windows/desktop/procthread/fibers).</span><span class="sxs-lookup"><span data-stu-id="bb47f-156">The .NET threading model does not support [fibers](/windows/desktop/procthread/fibers).</span></span> <span data-ttu-id="bb47f-157">Не следует вызывать неуправляемые функции, которые реализуется с использованием волокон.</span><span class="sxs-lookup"><span data-stu-id="bb47f-157">You should not call into any unmanaged function that is implemented by using fibers.</span></span> <span data-ttu-id="bb47f-158">Такие вызовы могут привести к сбою среды выполнения .NET.</span><span class="sxs-lookup"><span data-stu-id="bb47f-158">Such calls may result in a crash of the .NET runtime.</span></span>

## <a name="see-also"></a><span data-ttu-id="bb47f-159">См. также раздел</span><span class="sxs-lookup"><span data-stu-id="bb47f-159">See also</span></span>

- <xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>
- <xref:System.Threading.ThreadState>
- <xref:System.EnterpriseServices.ServicedComponent>
- <xref:System.Threading.Thread>
- <xref:System.Threading.Monitor>
