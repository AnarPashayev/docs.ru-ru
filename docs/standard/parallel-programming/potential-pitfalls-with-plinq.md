---
title: Потенциальные ошибки, связанные с PLINQ
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- PLINQ queries, pitfalls
ms.assetid: 75a38b55-4bc4-488a-87d5-89dbdbdc76a2
ms.openlocfilehash: 85098a0d10b4c05de52cd33d30ec5c4f4bbc594d
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/30/2019
ms.locfileid: "73139998"
---
# <a name="potential-pitfalls-with-plinq"></a>Потенциальные ошибки, связанные с PLINQ

Во многих случаях PLINQ может значительно повысить производительность по сравнению с последовательным выполнением запросов LINQ to Objects. Но сам процесс параллелизации запроса может оказаться сложным и вызвать дополнительные проблемы, которые в последовательном коде не типичны или совсем не встречаются. В этом разделе перечислены некоторые рекомендации по составлению запросов PLINQ.

## <a name="do-not-assume-that-parallel-is-always-faster"></a>Не считайте, что параллельные процессы всегда быстрее.

Иногда параллелизация приводит к тому, что запрос PLINQ выполняется медленнее, чем его эквивалент в LINQ to Objects. Главное правило заключается в том, что запросы с небольшим числом исходных элементов и быстрыми пользовательскими делегатами обычно не дают большого ускорения. Но на производительность влияет множество разных факторов, поэтому мы рекомендуем всегда оценивать фактические результаты при принятии решения об использовании PLINQ. Дополнительные сведения см. в разделе [Общее представление об ускорении выполнения в PLINQ](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md).

## <a name="avoid-writing-to-shared-memory-locations"></a>Избегайте размещения в общей памяти.

В последовательном коде для чтения и записи часто используются статические переменные и поля классов. Но всякий раз, когда к таким переменным обращаются сразу несколько потоков, может возникать состояние гонки. Несмотря на то что для синхронизации доступа к переменной можно использовать блокировки, связанные с нею затраты ресурсов могут снизить производительность. В связи с этим рекомендуем не использовать или хотя бы максимально ограничить обращение к общему состоянию в запросах PLINQ.

## <a name="avoid-over-parallelization"></a>Избегайте излишней параллелизации.

Использование оператора `AsParallel` приводит к накладным расходам на секционирование исходной коллекции и синхронизацию рабочих потоков. Преимущества параллелизации также ограничивает число процессоров на компьютере. Выполнение сразу нескольких потоков с большим количеством вычислений на одном и том же процессоре не повысит производительность. В связи с этим излишней параллелизации запроса следует избегать.

Параллелизация чаще всего становится излишней во вложенных запросах, как показано в следующем фрагменте кода.

[!code-csharp[PLINQ#20](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#20)]
[!code-vb[PLINQ#20](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#20)]

В этом примере выгоднее параллелизовать только внешний источник данных (клиенты), если не выполняется хотя бы одно из следующих условий:

- Внутренний источник данных (пользовательские заказы) содержит заведомо огромное число элементов.

- С каждым заказом вы выполняете дорогостоящие вычисления. (Операция, показанная в примере, не является дорогостоящей.)

- Целевая система имеет достаточно процессоров для обработки того количества потоков, которое будет создано при параллелизации запроса в `cust.Orders`.

В любом случае лучший способ определения оптимальной формы запроса — это проверка и измерение. Дополнительные сведения см. в разделе [Практическое руководство. Измерение производительности запросов PLINQ](../../../docs/standard/parallel-programming/how-to-measure-plinq-query-performance.md).

## <a name="avoid-calls-to-non-thread-safe-methods"></a>Избегайте вызова методов, небезопасных для потоков.

Запись из запроса PLINQ в методы экземпляров, не являющиеся потокобезопасными, может привести к повреждению данных. Такое изменение даже может остаться незамеченным в программе. Кроме того, она может вызывать исключения. В следующем примере несколько потоков одновременно пытаются вызвать метод `FileStream.Write`, но этот класс не поддерживает такое поведение.

```vb
Dim fs As FileStream = File.OpenWrite(…)
a.AsParallel().Where(...).OrderBy(...).Select(...).ForAll(Sub(x) fs.Write(x))
```

```csharp
FileStream fs = File.OpenWrite(...);
a.AsParallel().Where(...).OrderBy(...).Select(...).ForAll(x => fs.Write(x));
```

## <a name="limit-calls-to-thread-safe-methods"></a>Ограничение вызовов потокобезопасных методов

Большинство статических методов на платформе .NET Framework безопасны для потоков и могут вызываться из нескольких потоков одновременно. Но даже в этих случаях соответствующая синхронизация может значительно замедлить запрос.

> [!NOTE]
> Вы можете проверить это самостоятельно, добавив в запросы несколько вызовов <xref:System.Console.WriteLine%2A>. Несмотря на то, что этот метод часто приводится в демонстрационных примерах, его не следует использовать в запросах PLINQ.

## <a name="avoid-unnecessary-ordering-operations"></a>Избегайте ненужных операций упорядочения

Если PLINQ выполняет запрос параллельно, исходная последовательность разделяется на секции, которые могут обрабатываться одновременно в нескольких потоках. По умолчанию порядок обработки этих секций и порядок получения результатов не является прогнозируемым (за исключением отдельных операторов, например `OrderBy`). Вы можете сообщить PLINQ, что нужно сохранить порядок всех исходных последовательностей, но это снизит производительность. Везде, где это возможно, мы рекомендуем структурировать запросы так, чтобы они не полагались на сохранение порядка. Дополнительные сведения см. в разделе [Сохранение порядка в PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).

## <a name="prefer-forall-to-foreach-when-it-is-possible"></a>Выбирайте ForAll вместо ForEach везде, где это возможно

Несмотря на то, что PLINQ выполняет запрос в нескольких потоках, результаты придется собрать в один поток, если используется цикл `foreach` (`For Each` в Visual Basic), чтобы перечислитель обращался к ним последовательно. В некоторых случаях это неизбежно. Но если возможно, всегда используйте метод `ForAll`, чтобы каждый поток мог выводить свои результаты независимо от других. Например, выполняйте запись в потокобезопасную коллекцию типа <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType>.

Такая же проблема распространяется на <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>. Другими словами, вариант `source.AsParallel().Where().ForAll(...)` должен быть более предпочтительным, чем

`Parallel.ForEach(source.AsParallel().Where(), ...)`.

## <a name="be-aware-of-thread-affinity-issues"></a>Помните о проблемах сходства потоков.

Некоторые технологии, например COM-взаимодействие для компонентов однопотокового подразделения (STA), Windows Forms и Windows Presentation Foundation (WPF), накладывают ограничения на сходство потоков, требующие, чтобы код выполнялся в определенном потоке. Например, и в Windows Forms, и в WPF элемент управления может быть доступен только в том потоке, в котором он был создан. Если при выполнении запроса PLINQ попытаться получить доступ к общему состоянию элемента управления Windows Forms, в отладчике произойдет исключение. (Этот параметр можно отключить.) Но если запрос обрабатывается в потоке пользовательского интерфейса, элемент управления можно вызвать из цикла `foreach`, который перечисляет результаты запроса, так как этот код выполняется только в одном потоке.

## <a name="do-not-assume-that-iterations-of-foreach-for-and-forall-always-execute-in-parallel"></a>Не считайте, что итерации операторов ForEach, For и ForAll всегда выполняются параллельно.

Важно помнить, что отдельные итерации цикла <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> или <xref:System.Linq.ParallelEnumerable.ForAll%2A> иногда могут выполняться параллельно, но это не гарантируется. В связи с этим старайтесь не писать код, который будет зависеть от правильности параллельного выполнения итераций или от выполнения итераций в определенном порядке.

Например, этот код может вызвать взаимоблокировку:

```vb
Dim mre = New ManualResetEventSlim()
Enumerable.Range(0, Environment.ProcessorCount * 100).AsParallel().ForAll(Sub(j)
   If j = Environment.ProcessorCount Then
       Console.WriteLine("Set on {0} with value of {1}", Thread.CurrentThread.ManagedThreadId, j)
       mre.Set()
   Else
       Console.WriteLine("Waiting on {0} with value of {1}", Thread.CurrentThread.ManagedThreadId, j)
       mre.Wait()
   End If
End Sub) ' deadlocks
```

```csharp
ManualResetEventSlim mre = new ManualResetEventSlim();
Enumerable.Range(0, Environment.ProcessorCount * 100).AsParallel().ForAll((j) =>
{
    if (j == Environment.ProcessorCount)
    {
        Console.WriteLine("Set on {0} with value of {1}", Thread.CurrentThread.ManagedThreadId, j);
        mre.Set();
    }
    else
    {
        Console.WriteLine("Waiting on {0} with value of {1}", Thread.CurrentThread.ManagedThreadId, j);
        mre.Wait();
    }
}); //deadlocks
```

В этом примере одна итерация задает событие, а все остальные его ожидают. Ни одна из ожидающих итераций не может быть завершена, пока не завершится итерация, задающая событие. При этом ожидающие итерации способны заблокировать все потоки, которые используются для выполнения параллельного цикла, прежде чем будет выполнена итерация, задающая событие. Это приведет к взаимоблокировке — итерация, задающая событие, никогда не будет выполнена, а ожидающие итерации никогда не активизируются.

Таким образом, для выполнения работы необходимо, чтобы ни одна итерация параллельного цикла не ожидала другой итерации цикла. Если параллельный цикл решит запланировать итерации последовательно, но в обратном порядке, может возникнуть взаимоблокировка.

## <a name="see-also"></a>См. также

- [Parallel LINQ (PLINQ)](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)
