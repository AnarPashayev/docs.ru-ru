---
title: Поток данных (библиотека параллельных задач)
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Task Parallel Library, dataflows
- TPL dataflow library
ms.assetid: 643575d0-d26d-4c35-8de7-a9c403e97dd6
ms.openlocfilehash: 7f5969bc6f73b2260ae1ffa4b0026d5b4119ff88
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/30/2019
ms.locfileid: "73134261"
---
# <a name="dataflow-task-parallel-library"></a>Поток данных (библиотека параллельных задач)
<a name="top"></a> Библиотека параллельных задач (TPL) предоставляет компоненты потока данных, что позволяет повысить надежность приложений с включенным параллелизмом. Эти компоненты потока данных вместе называются *Библиотекой потоков данных TPL*. Эта модель потоков данных поддерживает программирование на основе субъектов путем обеспечения внутрипроцессной передачи сообщений для недетализированного потока данных и задач по конвейеризации. Компоненты потоков данных строятся на типах и инфраструктуре планирования TPL и интегрированы с языковой поддержкой асинхронного программирования на C#, Visual Basic и F#. Эти компоненты потоков данных полезны при наличии нескольких операций, которые должны асинхронно взаимодействовать друг с другом, или при необходимости обрабатывать данные по мере того, как они становятся доступными. Например, рассмотрим приложение, которое обрабатывает данные, поступающие с веб-камеры. С помощью модели потока данных приложение может обрабатывать кадры, как только они становятся доступными. Если приложение повышает качество изображений на кадрах, например, выполняя коррекцию освещенности или удаление "красных глаз", можно создать *конвейер* компонентов потока данных. Каждый этап конвейера может использовать функциональность с более грубым параллелизмом, например функцию, предоставляемую библиотекой TPL, для преобразования изображения.  
  
 В этом документе содержатся общие сведения о библиотеке потоков данных TPL. Здесь описывается модель программирования, предопределенные типы блоков потоков данных и способы настройки блоков потоков данных для соответствия требованиям вашего приложения.  

[!INCLUDE [tpl-install-instructions](../../../includes/tpl-install-instructions.md)]
  
 Этот документ содержит следующие разделы.  
  
- [Модель программирования](#model)  
  
- [Предопределенные типы блоков потоков данных](#predefined_types)  
  
- [Настройка поведения блоков потоков данных](#behavior)  
  
- [Пользовательские блоки потоков данных](#custom)  
  
<a name="model"></a>   
## <a name="programming-model"></a>Модель программирования  
 Библиотека потоков данных TPL обеспечивает основу для передачи сообщений и параллелизации приложений, создающих большую нагрузку на ЦПУ и ввод-вывод, которые имеют высокую пропускную способность и низкую задержку. Она также предоставляет явный контроль над тем, как данные буферизуются и перемещаются по системе. Чтобы лучше понять модель программирования потоков данных, рассмотрим приложение, асинхронно загружающее изображения с диска и создающее из них композитное изображение. Традиционные модели программирования обычно требуют использования обратных вызовов и объектов синхронизации, например блокировок, для координации задач и доступа к общим данным. С помощью модели программирования потоков данных можно создавать объекты потоков данных, которые обрабатывают изображения по мере считывания их с диска. В модели потоков данных объявляется, как обрабатываются данные, когда они становятся доступными, а также объявляются любые зависимости между данными. Поскольку среда выполнения управляет зависимостями между данными, часто можно избежать необходимости синхронизировать доступ к общим данным. Кроме того, поскольку планирование в среде выполнения основано на асинхронном прибытии данных, поток данных может увеличить пропускную способность и ускорить время ответа, эффективно управляя лежащими в основе потоками. Пример, использующий модель программирования потоков данных для реализации обработки изображений в приложении Windows Forms, см. в статье [Пошаговое руководство. Использование потока данных в приложении Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)  
  
### <a name="sources-and-targets"></a>Источники и целевые блоки  
 Библиотека потоков данных TPL состоит из *блоков потоков данных*, которые представляют собой структуры данных, буферизующие и обрабатывающие данные. В TPL определено три типа блоков потоков данных: *блоки источника*, *целевые блоки* и *блоки передачи*. Блок источника выступает в качестве источника данных, из которого можно считать данные. Целевой блок выступает в качестве получателя данных, в который можно писать. Блок передачи действует и как блок источника, и как целевой блок: из него можно читать и в него можно писать. TPL определяет интерфейс <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=nameWithType> для представления источников, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=nameWithType> для представления целевых объектов и <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=nameWithType> для представления передающих. <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> наследуется и от <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, и от <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 Библиотека потоков данных TPL предоставляет несколько предопределенных типов блоков потоков данных, которые реализуют интерфейсы <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> и <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602>. Эти типы блоков потоков данных описаны в настоящем документе в разделе [Предопределенные типы блоков потоков данных](#predefined_types).  
  
### <a name="connecting-blocks"></a>Соединение блоков  
 Можно также соединять блоки потоков данных для создания *конвейеров*, которые являются линейными последовательностями блоков потоков данных, или *сетей*, являющихся графами блоков потоков данных. Конвейер является одним из видов сетей. Конвейеры или сети асинхронно распространяют исходные данные целевым объектам, когда данные становятся доступны. Метод <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> связывает блок потока данных источника и целевой блок. Источник может быть связан с несколькими целевыми объектами или не связан ни с одним; целевые объекты могут иметь связь с несколькими источниками или не иметь связей. Можно добавлять или удалять блоки потока данных из конвейера или сети одновременно. Предопределенные типы блоков потоков данных отвечают за все аспекты потокобезопасности установки и удаления связей.  
  
 Пример, в котором блоки потоков данных соединяются в простой конвейер, см. в статье [Пошаговое руководство. Создание конвейера потока данных](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md). Пример, в котором блоки потоков данных формируют более сложную сеть, см. в статье [Пошаговое руководство. Использование потока данных в приложении Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md) Пример, в котором происходит удаление связи между источником и целевым объектом после того, как источник отправляет целевому объекту сообщение, см. в статье [Руководство. Удаление связей с блоками потоков данных](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  
  
#### <a name="filtering"></a>Фильтрация  
 При вызове метода <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=nameWithType> для связывания источника с целевым объектом, можно указать делегат, который определяет, принимает или отклоняет целевой блок сообщение в зависимости от содержания этого сообщения. Механизм фильтрации позволяет гарантировать, что блок потока данных будет получать только определенные значения. Для большинства стандартных типов блока потока данных, если блок источника подключен к нескольким целевым блокам, когда один из целевых блоков отвергает сообщение, это сообщение отправляется следующему целевому объекту. Порядок, в котором источник отправляет сообщения целевым объектам, определяется источником и может различаться в зависимости от типа источника. Большинство типов блоков источников перестают отправлять сообщение после того, как один из целевых объектов его принимает. Единственным исключением из этого правила является класс <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>, который предлагает каждое сообщение всем целевым объектам, даже если некоторые из целевых объектов отклоняют это сообщение. Пример, в котором при помощи фильтрации обрабатываются только определенные сообщения, см. в статье [Пошаговое руководство. Использование потока данных в приложении Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)  
  
> [!IMPORTANT]
> Поскольку все стандартные типы блоков потоков данных источника гарантируют, что сообщения передаются в том порядке, в каком они поступают, каждое сообщение должно быть считано из блока источника, чтобы блок источника мог обработать следующее сообщение. Поэтому при использовании фильтрации для подключения нескольких целевых объектов к источнику, убедитесь, что хотя бы один целевой блок получит все сообщения. В противном случае в приложении может возникнуть взаимоблокировка.  
  
### <a name="message-passing"></a>Передача сообщений  
 Модель программирования на основе потоков данных связана с понятием *передача сообщений*, так как в этой модели независимые компоненты программы взаимодействуют друг с другом посредством отправки сообщений. Один из способов передавать сообщения между компонентами приложения — вызвать методы <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> и <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=nameWithType> для отправки сообщений целевым блокам потоков данных (<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> работает синхронно, а <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> — асинхронно) и методы <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A> и <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> для получения сообщений от блоков источника. Можно объединять эти методы с конвейерами потоков данных или сетями, отправляя входные данные в ведущий узел (целевой блок) и принимая выходные данные из терминального узла конвейера или терминальных узлов сети (один или несколько блоков источника). Можно также использовать метод <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A> для чтения данных из первого из имеющихся источников, где доступны данные, и выполнения действий с этими данными.  
  
 Блоки источника предлагают данные целевым блокам, вызывая метод <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=nameWithType>. Целевой блок отвечает на предложенное сообщение одним из трех способов: он может принять сообщение, отклонить сообщение или отложить сообщение. Если целевой объект принимает сообщение, метод <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> возвращает <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted>. Если целевой объект отклоняет сообщение, метод <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> возвращает <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined>. Если целевой объект сообщает, что больше не будет получать сообщений от этого источника, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> возвращает <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently>. Стандартные типы блоков источника не предлагают связанным целевым объектам сообщения после получения такого значения, и они автоматически удаляют связи с этим целевым объектом.  
  
 Когда целевой блок откладывает сообщение для последующего использования, метод <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> возвращает <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed>. Целевой блок, откладывающий сообщение, может позднее вызвать метод <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=nameWithType>, чтобы попытаться зарезервировать предложенное сообщение. На этом этапе сообщение либо по-прежнему доступно и может быть использовано целевым блоком, либо было принято другим целевым объектом. Если целевой блок пытается получить сообщение позже, он вызывает метод <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType>, а когда сообщение больше не нужно — метод <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A>. Резервирование сообщений обычно используется типами блоков потоков данных, которые работают в нежадном режиме. Нежадный режим описан далее в этом документе. Вместо резервирования отложенного сообщения целевой блок может также использовать метод <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=nameWithType>, чтобы попытаться напрямую использовать отложенное сообщение.  
  
### <a name="dataflow-block-completion"></a>Завершение блока потока данных  
 Блоки потоков данных также поддерживают понятие *завершения*. Блок потока данных, находящийся в состоянии завершения, не будет далее выполнять никакой работы. С каждым блоком потока данных связан объект <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>, который называется *задачей завершения* и представляет состояние завершенности блока. Поскольку можно дождаться завершения для объекта <xref:System.Threading.Tasks.Task>, с помощью задачи завершения, можно дождаться завершения одного или нескольких терминальных узлов сети потоков данных. Интерфейс <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> определяет метод <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A>, который уведомляет блок потока данных о запросе завершения, и свойство <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A>, возвращающее задачу завершения для блока потока данных. Интерфейсы <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> и <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> наследуются от <xref:System.Threading.Tasks.Dataflow.IDataflowBlock>.  
  
 Существует два способа определить, завершился ли блок потока данных без ошибки, с одной или несколькими ошибками или был отменен. Первый способ — вызвать метод <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> для задачи завершения в блоке `try`-`catch` (`Try`-`Catch` в Visual Basic). В следующем примере создается объект <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, создающий исключение <xref:System.ArgumentOutOfRangeException>, если его входное значение меньше нуля. <xref:System.AggregateException> возникает, когда в данном примере вызывается <xref:System.Threading.Tasks.Task.Wait%2A> для задачи завершения. Доступ к объекту <xref:System.ArgumentOutOfRangeException> обеспечивается с помощью свойства <xref:System.AggregateException.InnerExceptions%2A> объекта <xref:System.AggregateException>.  
  
 [!code-csharp[TPLDataflow_Overview#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#10)]
 [!code-vb[TPLDataflow_Overview#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#10)]  
  
 В этом примере показан случай, в котором необработанное исключение передается в делегат блока выполнения потока данных. Рекомендуется обрабатывать исключения в телах таких блоков. Однако, если возможности сделать это нет, блок ведет себя, как если бы он был отменен, и не обрабатывает входящие сообщения.  
  
 Если блок потока данных отменяется явно, объект <xref:System.AggregateException> содержит <xref:System.OperationCanceledException> в свойстве <xref:System.AggregateException.InnerExceptions%2A>. Дополнительные сведения об отмене потока данных см. в разделе [Выполнение отмены](#enabling-cancellation).  
  
 Второй способ определить состояние завершения блока потока данных — использовать продолжение задачи завершения или использовать асинхронные функции языка C# и Visual Basic, чтобы асинхронно ожидать завершения задачи. Делегат, который предоставляется методу <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType>, принимает объект <xref:System.Threading.Tasks.Task>, представляющий предшествующую задачу. В случае со свойством <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> делегат для продолжения принимает саму задачу завершения. Следующий пример похож на предыдущий, но в нем используется метод <xref:System.Threading.Tasks.Task.ContinueWith%2A> для создания задачи завершения, которая выводит на печать общее состояние операции потока данных.  
  
 [!code-csharp[TPLDataflow_Overview#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#11)]
 [!code-vb[TPLDataflow_Overview#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#11)]  
  
 Можно также использовать такие свойства, как <xref:System.Threading.Tasks.Task.IsCanceled%2A>, в теле задачи продолжения, чтобы определить дополнительные сведения о состоянии выполнения блока потока данных. Дополнительные сведения о задачах продолжения и о том, как они связаны с отменой и обработкой ошибок, см. в разделах [Создание цепочки задач с помощью задач продолжения](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md), [Отмена задач](../../../docs/standard/parallel-programming/task-cancellation.md) и [Обработка исключений](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 [[в начало](#top)]  
  
<a name="predefined_types"></a>   
## <a name="predefined-dataflow-block-types"></a>Предопределенные типы блоков потоков данных  
 Библиотека потоков данных TPL предоставляет несколько предопределенных типов блоков потоков данных. Эти типы делятся на три категории: *блоки буферизации*, *блоки выполнения* и *блоки группировки*. В следующих подразделах описаны типы блоков, составляющие эти категории.  
  
### <a name="buffering-blocks"></a>Блоки буферизации  
 Блоки буферизации хранят данные для их использования объектами-потребителями данных. Библиотека потоков данных TPL предоставляет три типа блоков буферизации: <xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=nameWithType> и <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=nameWithType>.  
  
#### <a name="bufferblockt"></a>BufferBlock(T)  
 Класс <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> представляет структуру общего назначения для асинхронного обмена сообщениями. В этом классе хранится очередь сообщений типа «первым вошел — первым вышел» (FIFO), в которую могут записывать данные несколько источников и из которой могут читать данные несколько целевых объектов. Если целевой объект получает сообщение от объекта <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>, это сообщение удаляется из очереди сообщений. Поэтому, хотя объект <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> может иметь несколько целевых объектов, каждое сообщение может быть получено только одним из них. Класс <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> удобен, если нужно передать несколько сообщений другому компоненту и этот компонент должен принять каждое сообщение.  
  
 Следующий пример отправляет несколько значений <xref:System.Int32> объекту <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>, а затем эти значения считываются из этого объекта.  
  
 [!code-csharp[TPLDataflow_Overview#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#1)]
 [!code-vb[TPLDataflow_Overview#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#1)]  
  
 Полный пример, в котором демонстрируется способ записи сообщений в объект <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> и их чтения из него, см. в статье [Руководство. Запись и чтение сообщений в блоке потока данных](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md).  
  
#### <a name="broadcastblockt"></a>BroadcastBlock(T)  
 Класс <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> удобен, если необходимо передать несколько сообщений другому компоненту, но этому компоненту нужно только самое последнее значение. Этот класс также может оказаться полезным при необходимости широковещательной передачи сообщения нескольким компонентам.  
  
 В следующем примере значение <xref:System.Double> отправляется объекту <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>, а затем это значение считывается обратно из объекта несколько раз. Поскольку значения не удаляются из объектов <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> после их прочтения, одно и то же значение доступно каждый раз.  
  
 [!code-csharp[TPLDataflow_Overview#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#2)]
 [!code-vb[TPLDataflow_Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#2)]  
  
 Полный пример, демонстрирующий способ использования <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> для передачи сообщения нескольким целевым блокам, см. в статье [Руководство. Указание планировщика задач в блоке потока данных](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md).  
  
#### <a name="writeonceblockt"></a>WriteOnceBlock(T)  
 Класс <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> похож на класс <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>, но объект <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> допускает только однократную запись. Можно рассматривать <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> как аналог ключевого слова [readonly](../../csharp/language-reference/keywords/readonly.md) в C# ([ReadOnly](../../visual-basic/language-reference/modifiers/readonly.md) в Visual Basic), но объект <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> становится неизменяемым после того, как он получает значение, а не в момент создания. Как и в случае с классом <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>, когда целевой объект получает сообщение от объекта <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>, это сообщение не удаляется. Поэтому копию сообщения могут получить несколько целевых объектов. Класс <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> полезен, если требуется передать только первое из нескольких сообщений.  
  
 В следующем примере несколько значений <xref:System.String> отправляется объекту <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>, а затем это значение считывается обратно из этого объекта. Поскольку в объект <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> можно сделать запись только один раз, после того, как объект <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> получает сообщение, он отклоняет последующие сообщения.  
  
 [!code-csharp[TPLDataflow_Overview#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#3)]
 [!code-vb[TPLDataflow_Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#3)]  
  
 Полный пример, демонстрирующий способ использования <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> для получения значения первой завершенной операции, см. в статье [Руководство. Удаление связей с блоками потоков данных](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  
  
### <a name="execution-blocks"></a>Блоки выполнения  
 Блоки выполнения вызывают предоставленный пользователем делегат для каждого элемента полученных данных. Библиотека потоков данных TPL предоставляет три типа блоков выполнения: <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=nameWithType> и <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=nameWithType>.  
  
#### <a name="actionblockt"></a>ActionBlock(T)  
 Класс <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> — целевой блок, который вызывает делегат при получении данных. Можно рассматривать объект <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> как делегат, который выполняется асинхронно, когда данные становятся доступными. Делегат, который предоставляется объекту <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, может быть типа <xref:System.Action%601> или типа `System.Func<TInput, Task>`. При использовании объекта <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> с <xref:System.Action%601> обработка каждого входного элемента считается завершенной, когда возвращается делегат. При использовании объекта <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> с `System.Func<TInput, Task>` обработка каждого входного элемента считается завершенной, только если возвращенный объект <xref:System.Threading.Tasks.Task> завершен. С помощью двух этих механизмов можно использовать <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> как для синхронной, так и для асинхронной обработки каждого входного элемента.  
  
 В следующем примере несколько значений <xref:System.Int32> отправляется объекту <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>. Объект <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> выводит эти значения на консоль. Затем в этом примере производится установка блока в завершенное состояние, и происходит ожидание завершения всех задач потока данных.  
  
 [!code-csharp[TPLDataflow_Overview#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#4)]
 [!code-vb[TPLDataflow_Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#4)]  
  
 Полные примеры, демонстрирующие способы использования делегатов с классом <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, см. в статье [Руководство. Выполнение действий при получении данных блоком потоков данных](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
#### <a name="transformblocktinput-toutput"></a>TransformBlock(TInput, TOutput)  
 Класс <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> похож на класс <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> за исключением того, что он работает и как источник, и как целевой объект. Делегат, который передается объекту <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, возвращает значение типа `TOutput`. Делегат, который предоставляется объекту <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, может относиться к типу `System.Func<TInput, TOutput>` или типу `System.Func<TInput, Task<TOutput>>`. При использовании объекта <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> с `System.Func<TInput, TOutput>` обработка каждого входного элемента считается завершенной, когда делегат возвращается. При использовании объекта <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> с `System.Func<TInput, Task<TOutput>>` обработка каждого входного элемента считается завершенной, только если возвращаемый объект <xref:System.Threading.Tasks.Task%601> завершен. Как и в случае с <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, с помощью двух этих механизмов можно использовать <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> как для синхронной, так и для асинхронной обработки каждого входного элемента.  
  
 В следующем примере создается объект <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, который вычисляет квадратный корень введенного значения. Объект <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> принимает значения <xref:System.Int32> на входе и создает значения <xref:System.Double> на выходе.  
  
 [!code-csharp[TPLDataflow_Overview#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#5)]
 [!code-vb[TPLDataflow_Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#5)]  
  
 Полный пример использования <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> в сети блоков потоков данных, в котором выполняется обработка изображений в приложении Windows Forms, см. в статье [Пошаговое руководство. Использование потока данных в приложении Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)  
  
#### <a name="transformmanyblocktinput-toutput"></a>TransformManyBlock(TInput, TOutput)  
 Класс <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> похож на класс <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> за исключением того, что для каждого входного значения <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> создает ноль или более выходных значений вместо только одного значения. Делегат, который предоставляется объекту <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>, может относиться к типу `System.Func<TInput, IEnumerable<TOutput>>` или типу `System.Func<TInput, Task<IEnumerable<TOutput>>>`. При использовании объекта <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> с `System.Func<TInput, IEnumerable<TOutput>>` обработка каждого входного элемента считается завершенной, когда делегат возвращается. При использовании объекта <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> с `System.Func<TInput, Task<IEnumerable<TOutput>>>` обработка каждого входного элемента считается завершенной, только если возвращаемый объект `System.Threading.Tasks.Task<IEnumerable<TOutput>>` завершен.  
  
 В следующем примере создается объект <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>, который разделяет строки на отдельные цепочки символов. Объект <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> принимает значения <xref:System.String> на входе и создает значения <xref:System.Char> на выходе.  
  
 [!code-csharp[TPLDataflow_Overview#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#6)]
 [!code-vb[TPLDataflow_Overview#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#6)]  
  
 Полные примеры, в которых используется <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> для создания нескольких независимых выходных значений для каждого входного элемента в конвейере потока данных, см. в статье [Пошаговое руководство. Создание конвейера потока данных](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md).  
  
#### <a name="degree-of-parallelism"></a>Степень параллелизма  
 Каждый из объектов <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> и <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> буферизует входные сообщения до тех пор, пока блок не будет готов их обработать. По умолчанию эти классы обрабатывают сообщения в том порядке, в котором они поступают, по одному. Можно также указать степень параллелизма для включения объектов <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> и <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> для одновременной обработки нескольких сообщений. Дополнительные сведения о параллельном выполнении см. в разделе "Определение степени параллелизма" далее в этом документе. Пример, в котором задается степень параллелизма для обеспечения обработки блоком потока данных более одного сообщения одновременно, см. в статье [Пошаговое руководство. Указание степени параллелизма в блоке потока данных](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
#### <a name="summary-of-delegate-types"></a>Сводка по типам делегатов  
 В следующей таблице перечислены типы делегатов, которые можно передать объектам <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> и <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>. В этой таблице также указано, работает ли делегат данного типа синхронно или асинхронно.  
  
|Тип|Синхронный тип делегата|Асинхронный тип делегата|  
|----------|-------------------------------|--------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|`System.Action`|`System.Func<TInput, Task>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|`System.Func<TInput, TOutput>`|`System.Func<TInput, Task<TOutput>>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|`System.Func<TInput, IEnumerable<TOutput>>`|`System.Func<TInput, Task<IEnumerable<TOutput>>>`|  
  
 Можно также использовать лямбда-выражения при работе с типами блоков выполнения. Пример, демонстрирующий способ использования лямбда-выражения с блоком выполнения, см. в статье [Руководство. Выполнение действий при получении данных блоком потоков данных](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
### <a name="grouping-blocks"></a>Группирующие блоки  
 Группирующие блоки объединяют данные из одного или более источников с различными ограничениями. Библиотека потоков данных TPL предоставляет три типа блоков объединения: <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> и <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>.  
  
#### <a name="batchblockt"></a>BatchBlock(T)  
 Класс <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> объединяет наборы входных данных, называемые пакетами, в массивы выходных данных. Укажите размер каждого пакета при создании объекта <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>. Когда объект <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> получает указанное число входных элементов, он асинхронно передает массив, содержащий эти элементы. Если объект <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> переведен в состояние завершения, но не содержит достаточно элементов для формирования пакета, он формирует и передает конечный массив, который содержит оставшиеся входные элементы.  
  
 Класс <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> работает либо в *жадном*, либо в *нежадном* режиме. В жадном режиме, используемом по умолчанию, объект <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> принимает каждое предлагаемое ему сообщение и передает массив, как только получит указанное количество элементов. В нежадном режиме объект <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> откладывает все входящие сообщения до тех пор, пока достаточное количество источников не предложит сообщения блоку для формирования пакета. Жадный режим обычно работает быстрее, чем нежадный режим, поскольку он требует меньше дополнительной нагрузки для обработки. Однако можно использовать нежадный режим, если необходимо координировать получение от нескольких источников атомарным образом. Определите нежадный режим, установив свойству <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> значение `False` в параметре `dataflowBlockOptions` в конструкторе <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A>.  
  
 Следующий пример отправляет несколько значений <xref:System.Int32> объекту <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, содержащему десять элементов в пакете. Для обеспечения передачи всех значений из <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> в этом примере вызывается метод <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A>. Метод <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> переводит объект <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> в состояние завершения, и поэтому объект <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> передает все оставшиеся элементы в качестве последнего пакета.  
  
 [!code-csharp[TPLDataflow_Overview#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#7)]
 [!code-vb[TPLDataflow_Overview#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#7)]  
  
 Полный пример использования <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> для увеличения эффективности операций вставки в базу данных см. в статье [Пошаговое руководство. Повышение эффективности с помощью BatchBlock и BatchedJoinBlock](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  
  
#### <a name="joinblockt1-t2-"></a>JoinBlock(T1, T2, ...)  
 Классы <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> и <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> собирают входные элементы и распространяют объекты <xref:System.Tuple%602?displayProperty=nameWithType> или <xref:System.Tuple%603?displayProperty=nameWithType>, содержащие эти элементы. Классы <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> и <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> не наследуются от <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>. Вместо этого они предоставляют свойства <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A> и <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A>, которые реализуют <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 Как <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> и <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> работают либо в жадном, либо в нежадном режиме. В жадном режиме, используемом по умолчанию, объект <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> или <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> принимает каждое предлагаемое ему сообщение и распространяет кортеж после того, как каждый из его целевых объектов получает по меньшей мере одно сообщение. В нежадном режиме объект <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> или <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> откладывает все входящие сообщения, пока всем целевым объектам не будут предложены данные, необходимые для создания кортежа. В этот момент блок использует протокол двухфазной фиксации для атомарного извлечения всех необходимых элементов из источника. Эта задержка дает возможность другой сущности в это же время получать эти данные, что позволяет системе в целом продолжать работу.  
  
 В следующем примере описан случай, в котором объект <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> требует нескольких элементов данных для вычисления значения. В этом примере создается объект <xref:System.Threading.Tasks.Dataflow.JoinBlock%603>, который требует два значения <xref:System.Int32> и <xref:System.Char> для выполнения арифметической операции.  
  
 [!code-csharp[TPLDataflow_Overview#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#8)]
 [!code-vb[TPLDataflow_Overview#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#8)]  
  
 Полный пример использования объектов <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> в нежадном режиме для совместного использования ресурса см. в статье [Руководство. Использование JoinBlock для чтения данных из нескольких источников](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).  
  
#### <a name="batchedjoinblockt1-t2-"></a>BatchedJoinBlock(T1, T2, ...)  
 Классы <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> и <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> собирают пакеты входных элементов и распространяют объекты `System.Tuple(IList(T1), IList(T2))` или `System.Tuple(IList(T1), IList(T2), IList(T3))`, содержащие эти элементы. Класс <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> можно рассматривать как сочетание <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> и <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>. Укажите размер каждого пакета во время создания объекта <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>. <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> также предоставляет свойства, <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> и <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A>, которые реализуют <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>. Если указанное число входных элементов получено от всех целевых объектов, объект <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> асинхронно распространяет объект `System.Tuple(IList(T1), IList(T2))`, содержащий эти элементы.  
  
 В следующем примере создается объект <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>, содержащий результаты, значения <xref:System.Int32> и ошибки, представленные объектами <xref:System.Exception>. В этом примере выполняется несколько операций, результаты записываются в свойство <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A>, а ошибки — в свойство <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> объекта <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>. Поскольку число успешных и неудачных операций не известно заранее, объекты <xref:System.Collections.Generic.IList%601> позволяют каждому целевому объекту получать ноль и более значений.  
  
 [!code-csharp[TPLDataflow_Overview#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#9)]
 [!code-vb[TPLDataflow_Overview#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#9)]  
  
 Полный пример использования <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> для захвата как результатов, так и всех возможных исключений, которые могут возникнуть при выполнении считывания данных из базы данных, см. в статье [Пошаговое руководство. Повышение эффективности с помощью BatchBlock и BatchedJoinBlock](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  
  
 [[в начало](#top)]  
  
<a name="behavior"></a>   
## <a name="configuring-dataflow--block-behavior"></a>Настройка поведения блоков потоков данных  
 Можно включить дополнительные параметры, предоставив объект <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType> конструктору типов блоков потоков данных. Эти параметры управляют таким поведением, как у планировщика, который управляет основной задачей и степенью параллелизма. <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> также содержит производные типы, которые задают поведение, характерное для некоторых типов блоков потоков данных. В следующей таблице перечислено, какие типы параметров связаны с каждым из типов блоков потоков данных.  
  
|Тип блока потока данных|Тип <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.BufferBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchBlock%601>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.JoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
  
 В следующих разделах приведены дополнительные сведения о важных типах параметров блоков потоков данных, доступных с помощью классов <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=nameWithType> и <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=nameWithType>.  
  
### <a name="specifying-the-task-scheduler"></a>Определение планировщика заданий  
 Все стандартные блоки потоков данных используют механизм планирования задач TPL для выполнения таких действий, как передача данных целевому объекту, получение данных из источника и выполнение определенных пользователем делегатов, когда данные становятся доступны. <xref:System.Threading.Tasks.TaskScheduler> — абстрактный класс, представляющий планировщик заданий, ставящий задачи в очередь потоков. Планировщик заданий по умолчанию, <xref:System.Threading.Tasks.TaskScheduler.Default%2A>, использует класс <xref:System.Threading.ThreadPool> для постановки в очередь и выполнения работы. Можно переопределить планировщик заданий по умолчанию, установив свойство <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> при создании объекта блока потока данных.  
  
 Если один и тот же планировщик заданий управляет несколькими блоками потока данных, он может применять к ним определенные политики. Например, если каждый из нескольких блоков потока данных настроен для отдельного планировщика заданий одного объекта <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair>, вся работа, выполняемая в этих блоках, сериализуется. Аналогично, если эти блоки настроены для параллельного планировщика заданий одного объекта <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> и этот планировщик настроен так, чтобы иметь максимальный уровень параллелизма, вся работа из этих блоков ограничивается заданным числом одновременных операций. Пример, использующий класс <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair>, чтобы обеспечить параллельное выполнение операций чтения, а во время операций записи исключать выполнение любых других операций, см. в статье [Руководство. Указание планировщика задач в блоке потока данных](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md). Дополнительные сведения о планировщиках задач в TPL см. в разделе <xref:System.Threading.Tasks.TaskScheduler>.  
  
### <a name="specifying-the-degree-of-parallelism"></a>Определение степени параллелизма  
 По умолчанию библиотека потоков данных TPL предоставляет три типа блоков выполнения: <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> и <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>, которые обрабатывают одно сообщение за раз. Эти типы блоков потоков данных также обрабатывают сообщения в порядке их поступления. Чтобы обеспечить возможность обработки одновременно нескольких сообщений этими блоками потоков данных, задайте свойство <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=nameWithType> при создании объекта блока потока данных.  
  
 Значение по умолчанию у <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> — 1, оно гарантирует, что блок потока данных единовременно обрабатывает одно сообщение. Присвоение этому свойству значения более 1 активирует обработку блоком потока данных нескольких сообщений одновременно. Присвоение этому свойству значения <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType> позволяет основному планировщику задач управлять максимальной степенью параллелизма.  
  
> [!IMPORTANT]
> При максимальной степени параллелизма, превышающей 1, несколько сообщений обрабатываются одновременно, поэтому сообщения не могут обрабатываться в порядке их получения. Однако порядок, в котором сообщения выводятся из блока, соответствует порядку, в котором они поступают в блок.  
  
 Поскольку свойство <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> представляет максимальную степень параллелизма, блок потока данных может выполняться с меньшей степенью параллелизма, чем задано. Блок потока данных может использовать меньшую степень параллелизма для удовлетворения функциональных требований или при нехватке доступных системных ресурсов. Блок потока данных никогда не выбирает степень параллелизма больше заданной.  
  
 Значение свойства <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> уникально для каждого объекта блока потока данных. Например, если для четырех объектов блока потока данных задана 1 как максимальная степень параллелизма, все четыре объекта блока потока данных потенциально могут выполняться параллельно.  
  
 Пример, который задает максимальную степень параллелизма для обеспечения параллельного выполнения продолжительных операций, см. в статье [Руководство. Указание степени параллелизма в блоке потока данных](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
### <a name="specifying-the-number-of-messages-per-task"></a>Определение количества сообщений на задачу  
 Предопределенные типы блоков потока данных используют задачи для обработки нескольких входных элементов. Это позволяет минимизировать число объектов задачи, необходимых для обработки данных, из-за чего приложения выполняются более эффективно. Однако если задачи из одного набора блоков потока данных обрабатывают данные, задачи из других блоков потока данных быть вынуждены ожидать в течение времени, необходимого для обработки данных, добавляя сообщения в очередь. Чтобы обеспечить улучшенное распределение ресурсов между задачами потока данных, задайте значение для свойства <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A>. Если свойству <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> задано значение <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=nameWithType>, которое используется по умолчанию, задача, используемая блоком потока данных, обрабатывает столько сообщений, сколько их доступно. Если свойству <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> задано значение, отличное от <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded>, блок потока данных обрабатывает не больше этого количества сообщений на объект <xref:System.Threading.Tasks.Task>. Хотя настройка свойства <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> может улучшить распределение ресурсов между задачами, это может привести к созданию в системе количества задач, превышающего необходимое количество, что может снизить производительность.  
  
### <a name="enabling-cancellation"></a>Включение отмены  
 TPL предоставляет механизм, который позволяет задачам координировать отмены согласованным образом. Чтобы позволить блокам потока данных участвовать в этом механизме отмены, задайте значение для свойства <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A>. Если объект <xref:System.Threading.CancellationToken> переводится в состояние отмены, все блоки потока данных, которые отслеживают выполнение этого токена, завершат выполнение текущего элемента, но не начнут обрабатывать последующие. Эти блоки потока данных также очищают все буферизованные сообщения, прекращают подключения ко всем блокам источников и целевых объектов, и переходят в состояние отмены. Путем перехода в состояние отмены у свойства <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> свойству <xref:System.Threading.Tasks.Task.Status%2A> присваивается значение <xref:System.Threading.Tasks.TaskStatus.Canceled>, если во время обработки не возникает исключения. В таком случае свойству <xref:System.Threading.Tasks.Task.Status%2A> присваивается значение <xref:System.Threading.Tasks.TaskStatus.Faulted>.  
  
 Пример использования отмены в приложении Windows Forms см. в статье [Руководство. Отмена блока потока данных](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md). Подробнее об отмене в TPL читайте в разделе [Отмена задач](../../../docs/standard/parallel-programming/task-cancellation.md).  
  
### <a name="specifying-greedy-versus-non-greedy-behavior"></a>Определение жадного и нежадного поведения  
 Несколько группирующих типов блоков потоков данных могут работать либо в *жадном*, либо в *нежадном* режиме. По умолчанию стандартные типы блоков потоков данных работают в жадном режиме.  
  
 Для типов блоков соединения, таких как <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, жадный режим означает, что блок сразу принимает данные, даже если соответствующие данные, с которыми нужно выполнить объединение, еще недоступны. Нежадный режим означает, что блок откладывает все входящие сообщения до тех пор, пока сообщение не будет доступно на каждом из его целевых объектов для завершения объединения. Если любое из отложенных сообщений больше недоступно, блоки соединения освобождают все отложенные сообщения и перезапускают процесс. Для класса <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> жадный и нежадный режим работают одинаково за исключением того, что в нежадном режиме объект <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> откладывает все входящие сообщения до тех пор, пока достаточное их количество не будет доступно из различных источников для заполнения пакета.  
  
 Для определения нежадного режима для блока потока данных задайте свойству <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> значение `False`. Пример использования нежадного режима для обеспечения более эффективного совместного использования источника данных несколькими блоками соединения см. в статье [Руководство. Использование JoinBlock для чтения данных из нескольких источников](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).  
  
 [[в начало](#top)]  
  
<a name="custom"></a>   
## <a name="custom-dataflow-blocks"></a>Пользовательские блоки потоков данных  
 Хотя библиотека потоков данных TPL предоставляет множество стандартных типов блоков, можно создавать дополнительные типы блоков, которые выполняют устанавливаемые пользователем функции. Реализуйте интерфейсы <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> или <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> непосредственно или используйте метод <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> для сборки сложных блоков, которые инкапсулируют поведение существующих типов блоков. Примеры, в которых демонстрируются способы нестандартной реализации функциональности блоков потока данных, см. в статье [Пошаговое руководство. Создание пользовательского типа блока потока данных](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md).  
  
 [[в начало](#top)]  
  
## <a name="related-topics"></a>См. также  
  
|Заголовок|Описание|  
|-----------|-----------------|  
|[Практическое руководство. Запись и чтение сообщений в блоке потока данных](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)|Здесь показано, как писать и считывать сообщения из объекта <xref:System.Threading.Tasks.Dataflow.BufferBlock%601>.|  
|[Практическое руководство. Реализация шаблона потока данных "производитель — получатель"](../../../docs/standard/parallel-programming/how-to-implement-a-producer-consumer-dataflow-pattern.md)|Здесь приводится описания способов использования модели потока данных для реализации шаблона производитель-потребитель, где производитель отправляет сообщения в блок потока данных, а потребитель считывает сообщения из этого блока.|  
|[Практическое руководство. Выполнение действий при получении данных блоком потоков данных](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md)|Здесь приводится описание способов предоставления делегатов типам блоков выполнения потока данных, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> и <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>.|  
|[Пошаговое руководство: Создание конвейера потока данных](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)|Здесь приводится способ создания конвейера потока данных, который загружает текст из Интернета и выполняет над ним операции.|  
|[Практическое руководство. Удаление связей с блоками потоков данных](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)|Здесь показано, как с помощью метода <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A> удалить связь между целевым блоком и его источником после того, как источник отправил сообщение целевому объекту.|  
|[Пошаговое руководство: Использование потока данных в приложении Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)|Здесь демонстрируется, как создавать сеть блоков потока данных, которые выполняют обработку изображений в приложении Windows Forms.|  
|[Практическое руководство. Отмена блока потока данных](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md)|Здесь демонстрируется способ использования отмены в приложении Windows Forms.|  
|[Практическое руководство. Использование JoinBlock для чтения данных из нескольких источников](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)|Здесь описывается способ использования класса <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> для выполнения операции, когда данные доступны из нескольких источников, и использования нежадного режима, чтобы позволить нескольким блокам объединения использовать общий источник данных более эффективно.|  
|[Практическое руководство. Указание степени параллелизма в блоке потока данных](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)|Здесь описывается, как задать свойство <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A>, чтобы позволить блоку выполнения потока данных обрабатывать более одного сообщения единовременно.|  
|[Практическое руководство. Указание планировщика задач в блоке потока данных](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)|Здесь демонстрируется, как связать определенный планировщик задач при использовании потока данных в приложении.|  
|[Пошаговое руководство: Повышение эффективности с помощью BatchBlock и BatchedJoinBlock](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)|Здесь описывается, как использовать класс <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> для увеличения эффективности операций вставки в базу данных, а также как использовать класс <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> для получения как результата, так и всех исключений, возникающих при чтении данных из базы.|  
|[Пошаговое руководство: Создание пользовательского типа блока потока данных](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md)|Здесь приводятся два способа создания типа блока потока данных, который реализует пользовательские функции.|  
|[Библиотека параллельных задач (TPL)](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)|Здесь приводится описание TPL — библиотеки, упрощающей параллельное и одновременное программирование в приложениях .NET Framework.|
