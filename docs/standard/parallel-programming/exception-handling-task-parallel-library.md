---
title: Обработка исключений (библиотека параллельных задач)
description: Сведения об обработке исключений с помощью библиотеки параллельных задач (TPL) в .NET. Просматривайте вложенные агрегатные исключения, внутренние исключения, незамеченные исключения задач и многое другое.
ms.date: 04/20/2020
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, exceptions
ms.assetid: beb51e50-9061-4d3d-908c-56a4f7c2e8c1
ms.openlocfilehash: fd16fd4263c092f8678589e1a8dd9544955e798a
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/18/2020
ms.locfileid: "94827338"
---
# <a name="exception-handling-task-parallel-library"></a><span data-ttu-id="d3ab0-104">Обработка исключений (библиотека параллельных задач)</span><span class="sxs-lookup"><span data-stu-id="d3ab0-104">Exception handling (Task Parallel Library)</span></span>

<span data-ttu-id="d3ab0-105">Необработанные исключения, создаваемые пользовательским кодом, который выполняется в задаче, распространяются обратно в вызывающий поток, за исключением отдельных сценариев, описанных далее в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-105">Unhandled exceptions that are thrown by user code that is running inside a task are propagated back to the calling thread, except in certain scenarios that are described later in this topic.</span></span> <span data-ttu-id="d3ab0-106">Исключения распространяются, если вы вызываете один из статических или методов экземпляра <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> и заключаете этот вызов в инструкцию `try`/`catch`.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-106">Exceptions are propagated when you use one of the static or instance <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> methods, and you handle them by enclosing the call in a `try`/`catch` statement.</span></span> <span data-ttu-id="d3ab0-107">Если задача является родительской для присоединенных дочерних задач или если вы ожидаете несколько задач, может быть создано несколько исключений.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-107">If a task is the parent of attached child tasks, or if you are waiting on multiple tasks, multiple exceptions could be thrown.</span></span>

<span data-ttu-id="d3ab0-108">Чтобы распространить все исключения обратно в вызывающий поток, инфраструктура задач заключает их в экземпляр <xref:System.AggregateException> .</span><span class="sxs-lookup"><span data-stu-id="d3ab0-108">To propagate all the exceptions back to the calling thread, the Task infrastructure wraps them in an <xref:System.AggregateException> instance.</span></span> <span data-ttu-id="d3ab0-109">Исключение <xref:System.AggregateException> имеет свойство <xref:System.AggregateException.InnerExceptions%2A> , которое может быть перечислимым для проверки всех созданных исходных исключений и обработки (или отказа от обработки) каждого исключения по отдельности.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-109">The <xref:System.AggregateException> exception has an <xref:System.AggregateException.InnerExceptions%2A> property that can be enumerated to examine all the original exceptions that were thrown, and handle (or not handle) each one individually.</span></span> <span data-ttu-id="d3ab0-110">Вы также можете обрабатывать исходные исключения с помощью метода <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d3ab0-110">You can also handle the original exceptions by using the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="d3ab0-111">Даже если возникает только одно исключение, оно по-прежнему заключается в исключение <xref:System.AggregateException> , как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-111">Even if only one exception is thrown, it is still wrapped in an <xref:System.AggregateException> exception, as the following example shows.</span></span>

[!code-csharp[TPL_Exceptions#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handling21.cs#21)]
[!code-vb[TPL_Exceptions#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handling21.vb#21)]

<span data-ttu-id="d3ab0-112">Чтобы избежать необработанного исключения, достаточно перехватить <xref:System.AggregateException> и не просматривать какие-либо внутренние исключения.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-112">You could avoid an unhandled exception by just catching the <xref:System.AggregateException> and not observing any of the inner exceptions.</span></span> <span data-ttu-id="d3ab0-113">Однако рекомендуется этого не делать, так как это аналог перехвату базового типа <xref:System.Exception> в непараллельных сценариях.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-113">However, we recommend that you do not do this because it is analogous to catching the base <xref:System.Exception> type in non-parallel scenarios.</span></span> <span data-ttu-id="d3ab0-114">Чтобы перехватить исключение без выполнения определенных действий для восстановления из него можно оставить программу в неопределенном состоянии.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-114">To catch an exception without taking specific actions to recover from it can leave your program in an indeterminate state.</span></span>

<span data-ttu-id="d3ab0-115">Если вы не хотите вызывать метод <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> для ожидания завершения задачи, можно извлечь исключение <xref:System.AggregateException> из свойства <xref:System.Threading.Tasks.Task.Exception%2A> задачи, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-115">If you do not want to call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to wait for a task's completion, you can also retrieve the <xref:System.AggregateException> exception from the task's <xref:System.Threading.Tasks.Task.Exception%2A> property, as the following example shows.</span></span> <span data-ttu-id="d3ab0-116">Дополнительные сведения см. в разделе [Выявление исключения с помощью свойства Task.Exception](#observing-exceptions-by-using-the-taskexception-property) в этой статье.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-116">For more information, see the [Observing exceptions by using the Task.Exception property](#observing-exceptions-by-using-the-taskexception-property) section in this topic.</span></span>

[!code-csharp[TPL_Exceptions#29](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handling22.cs#29)]
[!code-vb[TPL_Exceptions#29](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handling22.vb#29)]

<span data-ttu-id="d3ab0-117">Если вы не ожидаете задачу, распространяющую исключение, или доступа к его свойству <xref:System.Threading.Tasks.Task.Exception%2A> , исключение распространяется согласно политике исключений .NET после удаления задачи сборкой мусора.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-117">If you do not wait on a task that propagates an exception, or access its <xref:System.Threading.Tasks.Task.Exception%2A> property, the exception is escalated according to the .NET exception policy when the task is garbage-collected.</span></span>

<span data-ttu-id="d3ab0-118">Если исключения могут всплывать обратно в присоединяемый поток, задача может продолжить обработку некоторых элементов после создания исключения.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-118">When exceptions are allowed to bubble up back to the joining thread, it is possible that a task may continue to process some items after the exception is raised.</span></span>

> [!NOTE]
> <span data-ttu-id="d3ab0-119">Если включен режим "Только мой код", Visual Studio иногда прерывает выполнение программы на строке, в которой создается исключение, и выводит сообщение об ошибке "Исключение, которое не может быть обработано пользовательским кодом".</span><span class="sxs-lookup"><span data-stu-id="d3ab0-119">When "Just My Code" is enabled, Visual Studio in some cases will break on the line that throws the exception and display an error message that says "exception not handled by user code."</span></span> <span data-ttu-id="d3ab0-120">Эта ошибка не является критической.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-120">This error is benign.</span></span> <span data-ttu-id="d3ab0-121">Вы можете нажать клавишу F5 для продолжения и увидеть поведение обработки исключения, которое демонстрируется в примерах ниже.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-121">You can press F5 to continue and see the exception-handling behavior that is demonstrated in these examples.</span></span> <span data-ttu-id="d3ab0-122">Чтобы предотвратить прерывание выполнения после первой ошибки в Visual Studio, необходимо снять флажок **Включить только мой код** в меню **Сервис, Параметры, Отладка, Общие**.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-122">To prevent Visual Studio from breaking on the first error, just uncheck the **Enable Just My Code** checkbox under **Tools, Options, Debugging, General**.</span></span>

## <a name="attached-child-tasks-and-nested-aggregateexceptions"></a><span data-ttu-id="d3ab0-123">Присоединенные дочерние задачи и вложенные исключения AggregateException</span><span class="sxs-lookup"><span data-stu-id="d3ab0-123">Attached child tasks and nested AggregateExceptions</span></span>

<span data-ttu-id="d3ab0-124">Если задача имеет присоединенную дочернюю задачу, которая создает исключение, это исключение заключается в <xref:System.AggregateException> перед распространением в родительскую задачу, которая заключает его в собственное исключение <xref:System.AggregateException> перед распространением обратно в вызывающий поток.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-124">If a task has an attached child task that throws an exception, that exception is wrapped in an <xref:System.AggregateException> before it is propagated to the parent task, which wraps that exception in its own <xref:System.AggregateException> before it propagates it back to the calling thread.</span></span> <span data-ttu-id="d3ab0-125">В таких случаях свойство <xref:System.AggregateException.InnerExceptions%2A> исключения <xref:System.AggregateException>, перехватываемого в методе <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task.WaitAny%2A> или <xref:System.Threading.Tasks.Task.WaitAll%2A>, содержит один или несколько экземпляров <xref:System.AggregateException>, а не исходные исключения, которые вызвали сбой.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-125">In such cases, the <xref:System.AggregateException.InnerExceptions%2A> property of the <xref:System.AggregateException> exception that is caught at the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task.WaitAny%2A>, or <xref:System.Threading.Tasks.Task.WaitAll%2A> method contains one or more <xref:System.AggregateException> instances, not the original exceptions that caused the fault.</span></span> <span data-ttu-id="d3ab0-126">Чтобы не перебирать все вложенные исключения <xref:System.AggregateException>, можно с помощью метода <xref:System.AggregateException.Flatten%2A> удалить все вложенные исключения <xref:System.AggregateException>, чтобы свойство <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> содержало только исходные исключения.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-126">To avoid having to iterate over nested <xref:System.AggregateException> exceptions, you can use the <xref:System.AggregateException.Flatten%2A> method to remove all the nested <xref:System.AggregateException> exceptions, so that the <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains the original exceptions.</span></span> <span data-ttu-id="d3ab0-127">В следующем примере вложенные экземпляры <xref:System.AggregateException> сглаживаются и обрабатываются всего в одном цикле.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-127">In the following example, nested <xref:System.AggregateException> instances are flattened and handled in just one loop.</span></span>

[!code-csharp[TPL_Exceptions#22](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/flatten2.cs#22)]
[!code-vb[TPL_Exceptions#22](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/flatten2.vb#22)]

<span data-ttu-id="d3ab0-128">Вы также можете использовать метод <xref:System.AggregateException.Flatten%2A?displayProperty=nameWithType>, чтобы повторно создать в одном экземпляре <xref:System.AggregateException> все вложенные исключения, полученные в нескольких экземплярах <xref:System.AggregateException> от нескольких задач, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-128">You can also use the <xref:System.AggregateException.Flatten%2A?displayProperty=nameWithType> method to rethrow the inner exceptions from multiple <xref:System.AggregateException> instances thrown by multiple tasks in a single <xref:System.AggregateException> instance, as the following example shows.</span></span>

[!code-csharp[TPL_Exceptions#13](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/taskexceptions2.cs#13)]
[!code-vb[TPL_Exceptions#13](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/taskexceptions2.vb#13)]

## <a name="exceptions-from-detached-child-tasks"></a><span data-ttu-id="d3ab0-129">Исключения из отсоединенных дочерних задач</span><span class="sxs-lookup"><span data-stu-id="d3ab0-129">Exceptions from detached child tasks</span></span>

<span data-ttu-id="d3ab0-130">По умолчанию дочерние задачи создаются отсоединенными.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-130">By default, child tasks are created as detached.</span></span> <span data-ttu-id="d3ab0-131">Исключения, создаваемые отсоединенными задачами, должны обрабатываться или повторно создаваться в непосредственной родительской задаче; они не распространяются обратно в вызывающий поток тем же способом, как распространяются обратно присоединенные дочерние задачи.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-131">Exceptions thrown from detached tasks must be handled or rethrown in the immediate parent task; they are not propagated back to the calling thread in the same way as attached child tasks propagated back.</span></span> <span data-ttu-id="d3ab0-132">Самая верхняя родительская задача может вручную повторно создавать исключение из отсоединенной дочерней задачи, чтобы вызвать его заключение в <xref:System.AggregateException> и распространение обратно в вызывающий поток.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-132">The topmost parent can manually rethrow an exception from a detached child to cause it to be wrapped in an <xref:System.AggregateException> and propagated back to the calling thread.</span></span>

[!code-csharp[TPL_Exceptions#23](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/detached21.cs#23)]
[!code-vb[TPL_Exceptions#23](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/detached21.vb#23)]

<span data-ttu-id="d3ab0-133">Даже если для выявления исключения в дочерней задаче используется продолжение, исключение по-прежнему должно выявляться родительской задачей.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-133">Even if you use a continuation to observe an exception in a child task, the exception still must be observed by the parent task.</span></span>

## <a name="exceptions-that-indicate-cooperative-cancellation"></a><span data-ttu-id="d3ab0-134">Исключения, указывающие координированную отмену</span><span class="sxs-lookup"><span data-stu-id="d3ab0-134">Exceptions that indicate cooperative cancellation</span></span>

<span data-ttu-id="d3ab0-135">Когда пользовательский код в задаче отвечает на запрос отмены, правильной процедурой будет создание исключения <xref:System.OperationCanceledException> , передаваемого в токен отмены, с помощью которого был передан запрос.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-135">When user code in a task responds to a cancellation request, the correct procedure is to throw an <xref:System.OperationCanceledException> passing in the cancellation token on which the request was communicated.</span></span> <span data-ttu-id="d3ab0-136">Перед попыткой распространить исключение экземпляр задачи сравнивает токен в исключении с токеном, переданным в него при его создании.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-136">Before it attempts to propagate the exception, the task instance compares the token in the exception to the one that was passed to it when it was created.</span></span> <span data-ttu-id="d3ab0-137">Если они совпадают, задача распространяет <xref:System.Threading.Tasks.TaskCanceledException> , заключенное в <xref:System.AggregateException>, и можно увидеть, когда проверяются внутренние исключения.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-137">If they are the same, the task propagates a <xref:System.Threading.Tasks.TaskCanceledException> wrapped in the <xref:System.AggregateException>, and it can be seen when the inner exceptions are examined.</span></span> <span data-ttu-id="d3ab0-138">Однако если вызывающий поток не ожидает задачу, это конкретное исключение не будет распространяться.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-138">However, if the calling thread is not waiting on the task, this specific exception will not be propagated.</span></span> <span data-ttu-id="d3ab0-139">Дополнительные сведения см. в разделе [Отмена задач](task-cancellation.md).</span><span class="sxs-lookup"><span data-stu-id="d3ab0-139">For more information, see [Task Cancellation](task-cancellation.md).</span></span>

[!code-csharp[TPL_Exceptions#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/exceptions.cs#4)]
[!code-vb[TPL_Exceptions#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/tpl_exceptions.vb#4)]

## <a name="using-the-handle-method-to-filter-inner-exceptions"></a><span data-ttu-id="d3ab0-140">Использование метода дескриптора для фильтрации внутренних исключений</span><span class="sxs-lookup"><span data-stu-id="d3ab0-140">Using the handle method to filter inner exceptions</span></span>

<span data-ttu-id="d3ab0-141">Метод <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> позволяет отфильтровать исключения, которые вы считаете уже обработанными, не применяя к ним никаких дополнительных действий.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-141">You can use the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method to filter out exceptions that you can treat as "handled" without using any further logic.</span></span> <span data-ttu-id="d3ab0-142">В пользовательском делегате, предоставленном в метод <xref:System.AggregateException.Handle%28System.Func%7BSystem.Exception%2CSystem.Boolean%7D%29?displayProperty=nameWithType>, можно проверить тип исключения, его свойство <xref:System.Exception.Message%2A> или другие сведения о нем, которые позволят проверить его безопасность.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-142">In the user delegate that is supplied to the <xref:System.AggregateException.Handle%28System.Func%7BSystem.Exception%2CSystem.Boolean%7D%29?displayProperty=nameWithType> method, you can examine the exception type, its <xref:System.Exception.Message%2A> property, or any other information about it that will let you determine whether it is benign.</span></span> <span data-ttu-id="d3ab0-143">Любые исключения, для которых делегат возвращает значение `false`, повторно создаются в новом экземпляре <xref:System.AggregateException> сразу после завершения метода <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-143">Any exceptions for which the delegate returns `false` are rethrown in a new <xref:System.AggregateException> instance immediately after the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method returns.</span></span>

<span data-ttu-id="d3ab0-144">Следующий пример выполняет ту же функцию, что и первый пример в этой статье, то есть проверяет каждое исключение в коллекции <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-144">The following example is functionally equivalent to the first example in this topic, which examines each exception in the <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> collection.</span></span>  <span data-ttu-id="d3ab0-145">Но этот обработчик исключений вызывает объект метода <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> для каждого исключения и создает повторно только те исключения, которые не являются экземплярами `CustomException`.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-145">Instead, this exception handler calls the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method object for each exception, and only rethrows exceptions that are not `CustomException` instances.</span></span>

[!code-csharp[TPL_Exceptions#26](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handlemethod21.cs#26)]
[!code-vb[TPL_Exceptions#26](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handlemethod21.vb#26)]

<span data-ttu-id="d3ab0-146">Ниже приведен более полный пример, в котором метод <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> используется для специальной обработки исключения <xref:System.UnauthorizedAccessException> при перечислении файлов.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-146">The following is a more complete example that uses the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method to provide special handling for an <xref:System.UnauthorizedAccessException> exception when enumerating files.</span></span>

[!code-csharp[TPL_Exceptions#12](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/taskexceptions.cs#12)]
[!code-vb[TPL_Exceptions#12](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/taskexceptions.vb#12)]

## <a name="observing-exceptions-by-using-the-taskexception-property"></a><span data-ttu-id="d3ab0-147">Выявление исключения с помощью свойства Task.Exception</span><span class="sxs-lookup"><span data-stu-id="d3ab0-147">Observing exceptions by using the Task.Exception property</span></span>

<span data-ttu-id="d3ab0-148">Если задача завершается в состоянии <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType>, ее свойство <xref:System.Threading.Tasks.Task.Exception%2A> позволяет узнать, какое именно исключение вызвало сбой.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-148">If a task completes in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state, its <xref:System.Threading.Tasks.Task.Exception%2A> property can be examined to discover which specific exception caused the fault.</span></span> <span data-ttu-id="d3ab0-149">Хороший способ исследования свойства <xref:System.Threading.Tasks.Task.Exception%2A> заключается в использовании продолжения, которое выполняется только в том случае, если происходит сбой предшествующей задачи, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-149">A good way to observe the <xref:System.Threading.Tasks.Task.Exception%2A> property is to use a continuation that runs only if the antecedent task faults, as shown in the following example.</span></span>

[!code-csharp[TPL_Exceptions#27](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/exceptionprop21.cs#27)]
[!code-vb[TPL_Exceptions#27](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/exceptionprop21.vb#27)]

<span data-ttu-id="d3ab0-150">В критически важном приложении делегат продолжения может записать в журнал подробные сведения об исключении и возможно создать новые задачи для восстановления из исключения.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-150">In a meaningful application, the continuation delegate could log detailed information about the exception and possibly spawn new tasks to recover from the exception.</span></span> <span data-ttu-id="d3ab0-151">В случае сбоя задачи следующие выражения создают исключение:</span><span class="sxs-lookup"><span data-stu-id="d3ab0-151">If a task faults, the following expressions throw the exception:</span></span>

- `await task`
- `task.Wait()`
- `task.Result`
- `task.GetAwaiter().GetResult()`

<span data-ttu-id="d3ab0-152">Используйте инструкцию [`try-catch`](../../csharp/language-reference/keywords/try-catch.md) для обработки и отслеживания исключений.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-152">Use a [`try-catch`](../../csharp/language-reference/keywords/try-catch.md) statement to handle and observe thrown exceptions.</span></span> <span data-ttu-id="d3ab0-153">Исключения также можно отслеживать, обращаясь к свойству <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-153">Alternatively, observe the exception by accessing the <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> property.</span></span>

## <a name="unobservedtaskexception-event"></a><span data-ttu-id="d3ab0-154">Событие UnobservedTaskException</span><span class="sxs-lookup"><span data-stu-id="d3ab0-154">UnobservedTaskException event</span></span>

<span data-ttu-id="d3ab0-155">В некоторых сценариях, например при размещении недоверенных подключаемых модулей, неопасные исключения могут быть общими, и может оказаться слишком сложно вручную выявить их все.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-155">In some scenarios, such as when hosting untrusted plug-ins, benign exceptions might be common, and it might be too difficult to manually observe them all.</span></span> <span data-ttu-id="d3ab0-156">В таких случаях можно обрабатывать событие <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d3ab0-156">In these cases, you can handle the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="d3ab0-157">Экземпляр <xref:System.Threading.Tasks.UnobservedTaskExceptionEventArgs?displayProperty=nameWithType>, который передается в обработчик, не позволяет незамеченным исключениям бесконтрольно распространяться обратно в присоединяемый поток.</span><span class="sxs-lookup"><span data-stu-id="d3ab0-157">The <xref:System.Threading.Tasks.UnobservedTaskExceptionEventArgs?displayProperty=nameWithType> instance that is passed to your handler can be used to prevent the unobserved exception from being propagated back to the joining thread.</span></span>

## <a name="see-also"></a><span data-ttu-id="d3ab0-158">См. также</span><span class="sxs-lookup"><span data-stu-id="d3ab0-158">See also</span></span>

- [<span data-ttu-id="d3ab0-159">Библиотека параллельных задач (TPL)</span><span class="sxs-lookup"><span data-stu-id="d3ab0-159">Task Parallel Library (TPL)</span></span>](task-parallel-library-tpl.md)
