---
title: Асинхронное программирование на основе задач — .NET
description: В этой статье описывается асинхронное программировании на основе задач с использованием библиотеки параллельных задач (TPL) в .NET.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- parallelism, task
ms.assetid: 458b5e69-5210-45e5-bc44-3888f86abd6f
ms.openlocfilehash: 968da880fc7e0e811f5e8712ccb43726426a019e
ms.sourcegitcommit: ef86c24c418439b8bb5e3e7d64bbdbe5e11c3e9c
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/21/2020
ms.locfileid: "88720167"
---
# <a name="task-based-asynchronous-programming"></a><span data-ttu-id="978c2-103">Асинхронное программирование на основе задач</span><span class="sxs-lookup"><span data-stu-id="978c2-103">Task-based asynchronous programming</span></span>

<span data-ttu-id="978c2-104">Библиотека параллельных задач (TPL) основана на концепции *задач*, представляющих асинхронные операции.</span><span class="sxs-lookup"><span data-stu-id="978c2-104">The Task Parallel Library (TPL) is based on the concept of a *task*, which represents an asynchronous operation.</span></span> <span data-ttu-id="978c2-105">В некотором смысле задача похожа на поток или рабочий элемент <xref:System.Threading.ThreadPool>, но на более высоком уровне абстракции.</span><span class="sxs-lookup"><span data-stu-id="978c2-105">In some ways, a task resembles a thread or <xref:System.Threading.ThreadPool> work item, but at a higher level of abstraction.</span></span> <span data-ttu-id="978c2-106">Термин *параллелизм задач* означает одновременное выполнение одной или нескольких разных задач.</span><span class="sxs-lookup"><span data-stu-id="978c2-106">The term *task parallelism* refers to one or more independent tasks running concurrently.</span></span> <span data-ttu-id="978c2-107">Задачи предоставляют два основных преимущества.</span><span class="sxs-lookup"><span data-stu-id="978c2-107">Tasks provide two primary benefits:</span></span>

- <span data-ttu-id="978c2-108">Более эффективное и масштабируемое использование системных ресурсов.</span><span class="sxs-lookup"><span data-stu-id="978c2-108">More efficient and more scalable use of system resources.</span></span>

     <span data-ttu-id="978c2-109">В фоновом режиме задачи помещаются в очередь <xref:System.Threading.ThreadPool>, усовершенствованную с помощью алгоритмов, которые определяют и настраивают количество потоков и обеспечивают балансировку нагрузки для повышения производительности.</span><span class="sxs-lookup"><span data-stu-id="978c2-109">Behind the scenes, tasks are queued to the <xref:System.Threading.ThreadPool>, which has been enhanced with algorithms  that determine and adjust to the number of threads and that provide load balancing to maximize throughput.</span></span> <span data-ttu-id="978c2-110">Это делает задачи относительно простыми и позволяет создавать множество задач для использования точного параллелизма.</span><span class="sxs-lookup"><span data-stu-id="978c2-110">This makes tasks relatively lightweight, and you can create many of them to enable fine-grained parallelism.</span></span>

- <span data-ttu-id="978c2-111">Больший программный контроль по сравнению с потоком или рабочим элементом.</span><span class="sxs-lookup"><span data-stu-id="978c2-111">More programmatic control than is possible with a thread or work item.</span></span>

     <span data-ttu-id="978c2-112">Задачи и построение платформы на их основе предоставляют богатый набор интерфейсов API, которые поддерживают ожидание, отмену, продолжения, надежную обработку исключений, подробные состояния, пользовательское планирование и многое другое.</span><span class="sxs-lookup"><span data-stu-id="978c2-112">Tasks and the framework built around them provide a rich set of APIs that support waiting, cancellation, continuations, robust exception handling, detailed status, custom scheduling, and more.</span></span>

<span data-ttu-id="978c2-113">По этим причинам TPL в .NET Framework — предпочтительный API для написания многопоточного асинхронного параллельного кода.</span><span class="sxs-lookup"><span data-stu-id="978c2-113">For both of these reasons, in the .NET Framework, TPL is the preferred API for writing multi-threaded, asynchronous, and parallel code.</span></span>

## <a name="creating-and-running-tasks-implicitly"></a><span data-ttu-id="978c2-114">Неявное создание и запуск задач</span><span class="sxs-lookup"><span data-stu-id="978c2-114">Creating and running tasks implicitly</span></span>

<span data-ttu-id="978c2-115">Метод <xref:System.Threading.Tasks.Parallel.Invoke%2A?displayProperty=nameWithType> предоставляет удобный способ одновременного запуска любого числа произвольных операторов.</span><span class="sxs-lookup"><span data-stu-id="978c2-115">The <xref:System.Threading.Tasks.Parallel.Invoke%2A?displayProperty=nameWithType> method provides a convenient way to run any number of arbitrary statements concurrently.</span></span> <span data-ttu-id="978c2-116">Достаточно передать в делегат <xref:System.Action> для каждого рабочего элемента.</span><span class="sxs-lookup"><span data-stu-id="978c2-116">Just pass in an <xref:System.Action> delegate for each item of work.</span></span> <span data-ttu-id="978c2-117">Самым простым способом создания этих делегатов является использование лямбда-выражений.</span><span class="sxs-lookup"><span data-stu-id="978c2-117">The easiest way to create these delegates is to use lambda expressions.</span></span> <span data-ttu-id="978c2-118">Лямбда-выражение может вызвать именованный метод или предоставить встроенный код.</span><span class="sxs-lookup"><span data-stu-id="978c2-118">The lambda expression can either call a named method or provide the code inline.</span></span> <span data-ttu-id="978c2-119">В следующем примере показан вызов базового метода <xref:System.Threading.Tasks.Parallel.Invoke%2A>, который создает и запускается две задачи, выполняемые параллельно.</span><span class="sxs-lookup"><span data-stu-id="978c2-119">The following example shows a basic <xref:System.Threading.Tasks.Parallel.Invoke%2A> call that creates and starts two tasks that run concurrently.</span></span> <span data-ttu-id="978c2-120">Первая задача представляется лямбда-выражением, вызывающим метод `DoSomeWork`, а вторая — лямбда-выражением, вызывающим метод `DoSomeOtherWork`.</span><span class="sxs-lookup"><span data-stu-id="978c2-120">The first task is represented by a lambda expression that calls a method named `DoSomeWork`, and the second task is represented by a lambda expression that calls a method named `DoSomeOtherWork`.</span></span>

> [!NOTE]
> <span data-ttu-id="978c2-121">В этой документации для определения делегатов в библиотеке параллельных задач используются лямбда-выражения.</span><span class="sxs-lookup"><span data-stu-id="978c2-121">This documentation uses lambda expressions to define delegates in TPL.</span></span> <span data-ttu-id="978c2-122">Если вы не знакомы с лямбда-выражениями в C# или Visual Basic, см. раздел [Лямбда-выражения в PLINQ и TPL](lambda-expressions-in-plinq-and-tpl.md).</span><span class="sxs-lookup"><span data-stu-id="978c2-122">If you are not familiar with lambda expressions in C# or Visual Basic, see [Lambda Expressions in PLINQ and TPL](lambda-expressions-in-plinq-and-tpl.md).</span></span>

[!code-csharp[TPL#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl/cs/tpl.cs#21)]
[!code-vb[TPL#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl/vb/tpl_vb.vb#21)]

> [!NOTE]
> <span data-ttu-id="978c2-123">Число экземпляров <xref:System.Threading.Tasks.Task>, созданных <xref:System.Threading.Tasks.Parallel.Invoke%2A> в фоновом режиме, не обязательно равно числу предоставленных делегатов.</span><span class="sxs-lookup"><span data-stu-id="978c2-123">The number of <xref:System.Threading.Tasks.Task> instances that are created behind the scenes by <xref:System.Threading.Tasks.Parallel.Invoke%2A> is not necessarily equal to the number of delegates that are provided.</span></span> <span data-ttu-id="978c2-124">Библиотека параллельных задач может применять различные оптимизации, особенно с большим количеством делегатов.</span><span class="sxs-lookup"><span data-stu-id="978c2-124">The TPL may employ various optimizations, especially with large numbers of delegates.</span></span>

<span data-ttu-id="978c2-125">Дополнительные сведения см. в разделе [Практическое руководство. Использование функции Parallel.Invoke для выполнения параллельных операций](how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span><span class="sxs-lookup"><span data-stu-id="978c2-125">For more information, see [How to: Use Parallel.Invoke to Execute Parallel Operations](how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span></span>

<span data-ttu-id="978c2-126">Для большего контроля над выполнением задач или возврата значения из задачи необходимо более явно работать с объектами <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="978c2-126">For greater control over task execution or to return a value from the task, you have to work with <xref:System.Threading.Tasks.Task> objects more explicitly.</span></span>

## <a name="creating-and-running-tasks-explicitly"></a><span data-ttu-id="978c2-127">Явное создание и запуск задач</span><span class="sxs-lookup"><span data-stu-id="978c2-127">Creating and running tasks explicitly</span></span>

<span data-ttu-id="978c2-128">Задача, не возвращающая значение, представляется классом <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="978c2-128">A task that does not return a value is represented by the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="978c2-129">Задача, возвращающая значение, представляется классом <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, унаследованным от <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="978c2-129">A task that returns a value is represented by the <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> class, which inherits from <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="978c2-130">Объект задачи обрабатывает сведения инфраструктуры и предоставляет методы и свойства, доступные из вызывающего потока в течение времени существования задачи.</span><span class="sxs-lookup"><span data-stu-id="978c2-130">The task object handles the infrastructure details and provides methods and properties that are accessible from the calling thread throughout the lifetime of the task.</span></span> <span data-ttu-id="978c2-131">Например, можно получить доступ к свойству <xref:System.Threading.Tasks.Task.Status%2A> задачи в любое время для определения того, было ли начато ее выполнение, завершилась ли она, была ли отменена или создала исключение.</span><span class="sxs-lookup"><span data-stu-id="978c2-131">For example, you can access the <xref:System.Threading.Tasks.Task.Status%2A> property of a task at any time to determine whether it has started running, ran to completion, was canceled, or has thrown an exception.</span></span> <span data-ttu-id="978c2-132">Состояние представлено перечислением <xref:System.Threading.Tasks.TaskStatus>.</span><span class="sxs-lookup"><span data-stu-id="978c2-132">The status is represented by a <xref:System.Threading.Tasks.TaskStatus> enumeration.</span></span>

<span data-ttu-id="978c2-133">При создании задачи ей передается пользовательский делегат, инкапсулирующий код, который будет выполнять задача.</span><span class="sxs-lookup"><span data-stu-id="978c2-133">When you create a task, you give it a user delegate that encapsulates the code that the task will execute.</span></span> <span data-ttu-id="978c2-134">Делегат может быть выражен как именованный делегат, анонимный метод или лямбда-выражение.</span><span class="sxs-lookup"><span data-stu-id="978c2-134">The delegate can be expressed as a named delegate, an anonymous method, or a lambda expression.</span></span> <span data-ttu-id="978c2-135">Лямбда-выражения могут содержать вызов именованного метода, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="978c2-135">Lambda expressions can contain a call to a named method, as shown in the following example.</span></span> <span data-ttu-id="978c2-136">Обратите внимание, что в пример включен вызов метода <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>, чтобы убедиться в окончании выполнения задачи до завершения работы приложения консольного режима.</span><span class="sxs-lookup"><span data-stu-id="978c2-136">Note that the example includes a call to the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to ensure that the task completes execution before the console mode application ends.</span></span>

[!code-csharp[TPL_TaskIntro#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/lambda1.cs#1)]
[!code-vb[TPL_TaskIntro#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/lambda1.vb#1)]

<span data-ttu-id="978c2-137">Для создания и запуска задачи в одной операции можно также использовать методы <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="978c2-137">You can also use the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> methods to create and start a task in one operation.</span></span> <span data-ttu-id="978c2-138">Для управления задачей методы <xref:System.Threading.Tasks.Task.Run%2A> используют планировщик задач по умолчанию независимо от того, какой планировщик связан с текущим потоком.</span><span class="sxs-lookup"><span data-stu-id="978c2-138">To manage the task, the <xref:System.Threading.Tasks.Task.Run%2A> methods use the default  task scheduler, regardless of which task scheduler is associated with the current thread.</span></span> <span data-ttu-id="978c2-139">Методы <xref:System.Threading.Tasks.Task.Run%2A> — предпочтительный способ создания и запуска задач, если не требуется более жесткий контроль над созданием и планированием задачи.</span><span class="sxs-lookup"><span data-stu-id="978c2-139">The <xref:System.Threading.Tasks.Task.Run%2A> methods are the preferred way to create and start tasks when more control over the creation and scheduling of the task is not needed.</span></span>

[!code-csharp[TPL_TaskIntro#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/run1.cs#2)]
[!code-vb[TPL_TaskIntro#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/run1.vb#2)]

<span data-ttu-id="978c2-140">Для создания и запуска задачи в одной операции можно также использовать метод <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="978c2-140">You can also use the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method to create and start a task in one operation.</span></span> <span data-ttu-id="978c2-141">Используйте этот метод, если нет необходимости разделять создание и планирование и требуются дополнительные параметры создания задач или использование определенного планировщика, а также при необходимости передачи дополнительного состояния задаче, которое можно получить через ее свойство <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType>, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="978c2-141">Use this method when creation and scheduling do not have to be separated and you require additional task creation options or the use of a specific scheduler, or when you need to pass additional state into the task that you can retrieve through its <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property, as shown in the following example.</span></span>

[!code-csharp[TPL_TaskIntro#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/asyncstate.cs#23)]
[!code-vb[TPL_TaskIntro#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/asyncstate.vb#23)]

<span data-ttu-id="978c2-142">Задачи <xref:System.Threading.Tasks.Task> и <xref:System.Threading.Tasks.Task%601> предоставляют статическое свойство <xref:System.Threading.Tasks.Task.Factory%2A>, возвращающее экземпляр по умолчанию объекта <xref:System.Threading.Tasks.TaskFactory>, чтобы можно было вызвать метод как `Task.Factory.StartNew()`.</span><span class="sxs-lookup"><span data-stu-id="978c2-142"><xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> each expose a static <xref:System.Threading.Tasks.Task.Factory%2A> property that returns a default instance of <xref:System.Threading.Tasks.TaskFactory>, so that you can call the method as `Task.Factory.StartNew()`.</span></span> <span data-ttu-id="978c2-143">Кроме того, поскольку в следующем примере задачи относятся к типу <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, каждая из них имеет открытое свойство <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>, содержащее результат вычисления.</span><span class="sxs-lookup"><span data-stu-id="978c2-143">Also, in the following example, because the tasks are of type <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, they each have a public <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property that contains the result of the computation.</span></span> <span data-ttu-id="978c2-144">Задачи выполняются асинхронно и могут завершиться в любом порядке.</span><span class="sxs-lookup"><span data-stu-id="978c2-144">The tasks run asynchronously and may complete in any order.</span></span> <span data-ttu-id="978c2-145">При обращении к свойству <xref:System.Threading.Tasks.Task%601.Result%2A> до завершения вычисления оно блокирует вызывающий поток до тех пор, пока значение не станет доступно.</span><span class="sxs-lookup"><span data-stu-id="978c2-145">If the <xref:System.Threading.Tasks.Task%601.Result%2A> property is accessed before the computation finishes, the property blocks the calling thread until the value is available.</span></span>

[!code-csharp[TPL_TaskIntro#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/result1.cs#4)]
[!code-vb[TPL_TaskIntro#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/result1.vb#4)]

<span data-ttu-id="978c2-146">Дополнительные сведения см. в разделе [Практическое руководство. Возвращение значения из задачи](how-to-return-a-value-from-a-task.md).</span><span class="sxs-lookup"><span data-stu-id="978c2-146">For more information, see [How to: Return a Value from a Task](how-to-return-a-value-from-a-task.md).</span></span>

<span data-ttu-id="978c2-147">При использовании лямбда-выражения для создания делегата имеется доступ ко всем переменным, видимым на этом этапе в исходном коде.</span><span class="sxs-lookup"><span data-stu-id="978c2-147">When you use a lambda expression to create a delegate, you have access to all the variables that are visible at that point in your source code.</span></span> <span data-ttu-id="978c2-148">Однако в некоторых случаях, особенно в циклах, лямбда-выражение не перехватывает переменную, как можно было бы ожидать.</span><span class="sxs-lookup"><span data-stu-id="978c2-148">However, in some cases, most notably within loops, a lambda doesn't capture the variable as expected.</span></span> <span data-ttu-id="978c2-149">Оно только перехватывает окончательное значение, а не значение, изменяющееся после каждой итерации.</span><span class="sxs-lookup"><span data-stu-id="978c2-149">It only captures the final value, not the value as it mutates after each iteration.</span></span> <span data-ttu-id="978c2-150">В следующем примере показана эта проблема.</span><span class="sxs-lookup"><span data-stu-id="978c2-150">The following example illustrates the problem.</span></span> <span data-ttu-id="978c2-151">В нем счетчик цикла передается лямбда-выражению, создающему экземпляр объекта `CustomData`, и используется в качестве идентификатора объекта.</span><span class="sxs-lookup"><span data-stu-id="978c2-151">It passes a loop counter to a lambda expression that instantiates a `CustomData` object and uses the loop counter as the object's identifier.</span></span> <span data-ttu-id="978c2-152">Как видно из выходных данных примера, все объекты `CustomData` имеют одинаковые идентификаторы.</span><span class="sxs-lookup"><span data-stu-id="978c2-152">As the output from the example shows, each `CustomData` object has an identical identifier.</span></span>

[!code-csharp[TPL_TaskIntro#22](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/iteration1b.cs#22)]
[!code-vb[TPL_TaskIntro#22](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/iteration1b.vb#22)]

<span data-ttu-id="978c2-153">Доступ к значению для каждой итерации можно получить, предоставив объект состояния задаче через ее конструктор.</span><span class="sxs-lookup"><span data-stu-id="978c2-153">You can access the value on each iteration by providing a state object to a task through its constructor.</span></span> <span data-ttu-id="978c2-154">В следующем примере предыдущий пример изменяется путем использования счетчика цикла при создании объекта `CustomData`, который, в свою очередь, передается лямбда-выражению.</span><span class="sxs-lookup"><span data-stu-id="978c2-154">The following example modifies the previous example by using the loop counter when creating the `CustomData` object, which, in turn, is passed to the lambda expression.</span></span>  <span data-ttu-id="978c2-155">Как видно из выходных данных примера, каждый объект `CustomData` теперь имеет уникальный идентификатор, основанный на значении счетчика цикла в момент создания экземпляра объекта.</span><span class="sxs-lookup"><span data-stu-id="978c2-155">As the output from the example shows, each `CustomData` object now has a unique identifier based on the value of the loop counter at the time the object was instantiated.</span></span>

[!code-csharp[TPL_TaskIntro#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/iteration1a.cs#21)]
[!code-vb[TPL_TaskIntro#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/iteration1a.vb#21)]

<span data-ttu-id="978c2-156">Это состояние передается в качестве аргумента делегату задачи, и доступ к нему можно получить из объекта задачи с помощью свойства <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="978c2-156">This state is passed as an argument to the task delegate, and it can be accessed from the task object by using the <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property.</span></span>  <span data-ttu-id="978c2-157">В следующем примере представлен вариант предыдущего примера.</span><span class="sxs-lookup"><span data-stu-id="978c2-157">The following example is a variation on the previous example.</span></span> <span data-ttu-id="978c2-158">В нем используется свойство <xref:System.Threading.Tasks.Task.AsyncState%2A> для отображения сведений об объектах `CustomData`, переданных лямбда-выражению.</span><span class="sxs-lookup"><span data-stu-id="978c2-158">It uses the <xref:System.Threading.Tasks.Task.AsyncState%2A> property to display information about the `CustomData` objects passed to the lambda expression.</span></span>

[!code-csharp[TPL_TaskIntro#23](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/asyncstate.cs#23)]
[!code-vb[TPL_TaskIntro#23](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/asyncstate.vb#23)]

## <a name="task-id"></a><span data-ttu-id="978c2-159">Идентификатор задачи</span><span class="sxs-lookup"><span data-stu-id="978c2-159">Task ID</span></span>

<span data-ttu-id="978c2-160">Каждая задача получает целочисленный идентификатор, уникально определяющий ее в домене приложения. Доступ к нему можно получить с помощью свойства <xref:System.Threading.Tasks.Task.Id%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="978c2-160">Every task receives an integer ID that uniquely identifies it in an application domain and can be accessed by using the <xref:System.Threading.Tasks.Task.Id%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="978c2-161">Этот идентификатор полезен для просмотра сведений о задаче в окнах **Параллельные стеки** и **Задачи** отладчика Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="978c2-161">The ID is useful for viewing task information in the Visual Studio debugger **Parallel Stacks** and **Tasks** windows.</span></span> <span data-ttu-id="978c2-162">Он создается только после того, как запрашивается. Поэтому при каждом запуске программы задача может иметь разные идентификаторы.</span><span class="sxs-lookup"><span data-stu-id="978c2-162">The ID is lazily created, which means that it isn't created until it is requested; therefore, a task may have a different ID every time the program is run.</span></span> <span data-ttu-id="978c2-163">Дополнительные сведения о том, как просматривать идентификаторы задач в отладчике, см. в разделах [Использование окна задач](/visualstudio/debugger/using-the-tasks-window) и [Использование окна "Параллельные стеки"](/visualstudio/debugger/using-the-parallel-stacks-window).</span><span class="sxs-lookup"><span data-stu-id="978c2-163">For more information about how to view task IDs in the debugger, see [Using the Tasks Window](/visualstudio/debugger/using-the-tasks-window) and [Using the Parallel Stacks Window](/visualstudio/debugger/using-the-parallel-stacks-window).</span></span>

## <a name="task-creation-options"></a><span data-ttu-id="978c2-164">Параметры создания задачи</span><span class="sxs-lookup"><span data-stu-id="978c2-164">Task creation options</span></span>

<span data-ttu-id="978c2-165">Большинство интерфейсов API, в которых создаются задачи, предоставляют перегрузки, принимающие параметр <xref:System.Threading.Tasks.TaskCreationOptions>.</span><span class="sxs-lookup"><span data-stu-id="978c2-165">Most APIs that create tasks provide overloads that accept a <xref:System.Threading.Tasks.TaskCreationOptions> parameter.</span></span> <span data-ttu-id="978c2-166">Указывая один из этих параметров, пользователь задает планировщику задач способ планирования задачи в пуле потоков.</span><span class="sxs-lookup"><span data-stu-id="978c2-166">By specifying one of these options, you tell the task scheduler how to schedule the task on the thread pool.</span></span> <span data-ttu-id="978c2-167">В следующей таблице перечислены различные параметры создания задач.</span><span class="sxs-lookup"><span data-stu-id="978c2-167">The following table lists the various task creation options.</span></span>

|<span data-ttu-id="978c2-168">Значение параметра <xref:System.Threading.Tasks.TaskCreationOptions></span><span class="sxs-lookup"><span data-stu-id="978c2-168"><xref:System.Threading.Tasks.TaskCreationOptions> parameter value</span></span>|<span data-ttu-id="978c2-169">Описание</span><span class="sxs-lookup"><span data-stu-id="978c2-169">Description</span></span>|
|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------|
|<xref:System.Threading.Tasks.TaskCreationOptions.None>|<span data-ttu-id="978c2-170">Значение по умолчанию, если параметр не задан.</span><span class="sxs-lookup"><span data-stu-id="978c2-170">The default when no option is specified.</span></span> <span data-ttu-id="978c2-171">Планировщик использует его эвристику по умолчанию для планирования задачи.</span><span class="sxs-lookup"><span data-stu-id="978c2-171">The scheduler uses its default heuristics to schedule the task.</span></span>|
|<xref:System.Threading.Tasks.TaskCreationOptions.PreferFairness>|<span data-ttu-id="978c2-172">Указывает, что задачу необходимо планировать так, чтобы созданные раньше задачи выполнялись раньше, а более поздние задачи — позже.</span><span class="sxs-lookup"><span data-stu-id="978c2-172">Specifies that the task should be scheduled so that tasks created sooner will be more likely to be executed sooner, and tasks created later will be more likely to execute later.</span></span>|
|<xref:System.Threading.Tasks.TaskCreationOptions.LongRunning>|<span data-ttu-id="978c2-173">Указывает, что задача представляет длительную операцию.</span><span class="sxs-lookup"><span data-stu-id="978c2-173">Specifies that the task represents a long-running operation.</span></span>|
|<xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent>|<span data-ttu-id="978c2-174">Указывает, что задача должна быть создана как вложенная дочерняя задача текущей задачи, если таковая существует.</span><span class="sxs-lookup"><span data-stu-id="978c2-174">Specifies that a task should be created as an attached child of the current task, if one exists.</span></span> <span data-ttu-id="978c2-175">Дополнительные сведения см. в разделе [Присоединенные и отсоединенные дочерние задачи](attached-and-detached-child-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="978c2-175">For more information, see [Attached and Detached Child Tasks](attached-and-detached-child-tasks.md).</span></span>|
|<xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach>|<span data-ttu-id="978c2-176">Указывает, что, если внутренняя задача определяет параметр `AttachedToParent`, эта задача не станет дочерней присоединенной задачей.</span><span class="sxs-lookup"><span data-stu-id="978c2-176">Specifies that if an inner task specifies the `AttachedToParent` option, that task will not become an attached child task.</span></span>|
|<xref:System.Threading.Tasks.TaskCreationOptions.HideScheduler>|<span data-ttu-id="978c2-177">Указывает, что планировщик задач для задач, созданных вызывающими методами (например, <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> или <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType>) из определенной задачи, — это планировщик по умолчанию, а не планировщик, в котором выполняется эта задача.</span><span class="sxs-lookup"><span data-stu-id="978c2-177">Specifies that the task scheduler for tasks created by calling methods like <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> or <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> from within a particular task is the default scheduler instead of the scheduler on which this task is running.</span></span>|

<span data-ttu-id="978c2-178">Параметры можно объединить с использованием побитовой операции **ИЛИ**.</span><span class="sxs-lookup"><span data-stu-id="978c2-178">The options may be combined by using a bitwise **OR** operation.</span></span> <span data-ttu-id="978c2-179">В следующем примере показана задача с параметрами <xref:System.Threading.Tasks.TaskCreationOptions.LongRunning> и <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness>.</span><span class="sxs-lookup"><span data-stu-id="978c2-179">The following example shows a task that has the <xref:System.Threading.Tasks.TaskCreationOptions.LongRunning> and <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness> option.</span></span>

[!code-csharp[TPL_TaskIntro#03](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/taskintro.cs#03)]
[!code-vb[TPL_TaskIntro#03](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/tpl_intro.vb#03)]

## <a name="tasks-threads-and-culture"></a><span data-ttu-id="978c2-180">Задачи, потоки и язык и региональные параметры</span><span class="sxs-lookup"><span data-stu-id="978c2-180">Tasks, threads, and culture</span></span>

<span data-ttu-id="978c2-181">Каждый поток имеет связанный язык и региональные параметры и язык и региональные параметры пользовательского интерфейса, которые определяются свойствами <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> и <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> соответственно.</span><span class="sxs-lookup"><span data-stu-id="978c2-181">Each thread has an associated culture and UI culture, which is defined by the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> properties, respectively.</span></span> <span data-ttu-id="978c2-182">Язык и региональные параметры потока используются в таких операциях, как форматирование, анализ, сортировка и сравнение строк.</span><span class="sxs-lookup"><span data-stu-id="978c2-182">A thread's culture is used in such operations as formatting, parsing, sorting, and string comparison.</span></span> <span data-ttu-id="978c2-183">Язык и региональные параметры пользовательского интерфейса потока используются при поиске ресурсов.</span><span class="sxs-lookup"><span data-stu-id="978c2-183">A thread's UI culture is used in resource lookup.</span></span> <span data-ttu-id="978c2-184">Как правило, если не заданы язык и региональные параметры по умолчанию для всех потоков в домене приложения с помощью свойств <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> и <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType>, то по умолчанию язык и региональные параметры пользовательского интерфейса потока определяется языком и региональными параметрами системы.</span><span class="sxs-lookup"><span data-stu-id="978c2-184">Ordinarily, unless you specify a default culture for all the threads in an application domain by using the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> properties, the default culture and UI culture of a thread is defined by the system culture.</span></span> <span data-ttu-id="978c2-185">Если вы явно задаете язык и региональные параметры потока и запускаете новый поток, этот новый поток не наследует язык и региональные параметры вызывающего потока; вместо них по умолчанию используется язык и региональные параметры системы.</span><span class="sxs-lookup"><span data-stu-id="978c2-185">If you explicitly set a thread's culture and launch a new thread, the new thread does not inherit the culture of the calling thread; instead, its culture is the default system culture.</span></span> <span data-ttu-id="978c2-186">Такого подхода придерживается модель программирования на основе задач для приложений, предназначенных для версий .NET Framework, предшествующих версии .NET Framework 4.6.</span><span class="sxs-lookup"><span data-stu-id="978c2-186">The task-based programming model for apps that target versions of the .NET Framework prior to .NET Framework 4.6 adhere to this practice.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="978c2-187">Обратите внимание, что язык и региональные параметры вызывающего потока как часть контекста задачи применяются к приложениям, *предназначенным* для .NET Framework 4.6, а не к приложениям, *работающим* в .NET Framework 4.6.</span><span class="sxs-lookup"><span data-stu-id="978c2-187">Note that the calling thread's culture as part of a task's context applies to apps that *target* the .NET Framework 4.6, not apps that *run under* the .NET Framework 4.6.</span></span> <span data-ttu-id="978c2-188">Вы можете ориентироваться на конкретную версию платформы .NET Framework при создании проекта в Visual Studio, выбрав ее в раскрывающемся списке в верхней части диалогового окна **Новый проект**, а вне Visual Studio можете использовать атрибут <xref:System.Runtime.Versioning.TargetFrameworkAttribute>.</span><span class="sxs-lookup"><span data-stu-id="978c2-188">You can target a particular version of the .NET Framework when you create your project in Visual Studio by selecting that version from the dropdown list at the top of the **New Project** dialog box, or outside of Visual Studio you can use the <xref:System.Runtime.Versioning.TargetFrameworkAttribute> attribute.</span></span> <span data-ttu-id="978c2-189">В приложениях, предназначенных для версий .NET Framework до .NET Framework 4.6 или не предназначенных для определенной версии .NET Framework, язык и региональные параметры задачи по-прежнему определяются языком и региональными параметрами потока, в котором она выполняется.</span><span class="sxs-lookup"><span data-stu-id="978c2-189">For apps that target versions of the .NET Framework prior to the .NET Framework 4.6, or that do not target a specific version of the .NET Framework, a task's culture continues to be determined by the culture of the thread on which it runs.</span></span>

<span data-ttu-id="978c2-190">Начиная с приложений, предназначенных для .NET Framework 4.6, язык и региональные параметры вызывающего потока наследуются каждой задачей, даже если задача выполняется асинхронно в потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="978c2-190">Starting with apps that target the .NET Framework 4.6, the calling thread's culture is inherited by each task, even if the task runs asynchronously on a thread pool thread.</span></span>

<span data-ttu-id="978c2-191">Следующий пример иллюстрирует это.</span><span class="sxs-lookup"><span data-stu-id="978c2-191">The following example provides a simple illustration.</span></span> <span data-ttu-id="978c2-192">Он использует атрибут <xref:System.Runtime.Versioning.TargetFrameworkAttribute> для указания .NET Framework 4.6 и изменяет текущий язык и региональные параметры приложения на французский (Франция), а если французский (Франция) уже является текущим языком, то изменяет его на английский (США).</span><span class="sxs-lookup"><span data-stu-id="978c2-192">It uses the <xref:System.Runtime.Versioning.TargetFrameworkAttribute> attribute to target the .NET Framework 4.6 and changes the app's current culture to either French (France) or, if French (France) is already the current culture, English (United States).</span></span> <span data-ttu-id="978c2-193">Затем он вызывает делегат с именем `formatDelegate`, который возвращает некоторые числа в виде значений валюты в новом языке и региональных параметрах.</span><span class="sxs-lookup"><span data-stu-id="978c2-193">It then invokes a delegate named `formatDelegate` that returns some numbers formatted as currency values in the new culture.</span></span> <span data-ttu-id="978c2-194">Обратите внимание, что независимо от того, действует ли делегат как синхронная или асинхронная задача, он возвращает ожидаемый результат, поскольку язык и региональные параметры вызывающего потока наследуются асинхронной задачей.</span><span class="sxs-lookup"><span data-stu-id="978c2-194">Note that whether the delegate as a task either synchronously or asynchronously, it returns the expected result because the culture of the calling thread is inherited by the asynchronous task.</span></span>

[!code-csharp[System.Globalization.CultureInfo.Class.Async#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.class.async/cs/asyncculture1.cs#5)]
[!code-vb[System.Globalization.CultureInfo.Class.Async#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.class.async/vb/asyncculture1.vb#5)]

<span data-ttu-id="978c2-195">При использовании Visual Studio можно не указывать атрибут <xref:System.Runtime.Versioning.TargetFrameworkAttribute>, выбрав вместо этого .NET Framework 4.6 в качестве целевой платформы при создании проекта в диалоговом окне **Новый проект**.</span><span class="sxs-lookup"><span data-stu-id="978c2-195">If you are using Visual Studio, you can omit the <xref:System.Runtime.Versioning.TargetFrameworkAttribute> attribute and instead select the .NET Framework 4.6 as the target when you create the project in the **New Project** dialog.</span></span>

<span data-ttu-id="978c2-196">Чтобы получить выходные данные, которые отражают поведение приложений для версий платформы .NET Framework до версии .NET Framework 4.6, удалите атрибут <xref:System.Runtime.Versioning.TargetFrameworkAttribute> из исходного кода.</span><span class="sxs-lookup"><span data-stu-id="978c2-196">For output that reflects the behavior of apps the target versions of the .NET Framework prior to .NET Framework 4.6, remove the <xref:System.Runtime.Versioning.TargetFrameworkAttribute> attribute from the source code.</span></span> <span data-ttu-id="978c2-197">Выходные данные будут отражать соглашения о форматировании языка и региональных параметров системы по умолчанию, а не языка и региональных параметров вызывающего потока.</span><span class="sxs-lookup"><span data-stu-id="978c2-197">The output will reflect the formatting conventions of the default system culture, not the culture of the calling thread.</span></span>

<span data-ttu-id="978c2-198">Дополнительные сведения об асинхронных задачах и языке и региональных параметрах см. в разделе "Язык и региональные параметры и асинхронные операции на основе задач" в описании класса <xref:System.Globalization.CultureInfo>.</span><span class="sxs-lookup"><span data-stu-id="978c2-198">For more information on asynchronous tasks and culture, see the "Culture and asynchronous task-based operations" section in the <xref:System.Globalization.CultureInfo> topic.</span></span>

## <a name="creating-task-continuations"></a><span data-ttu-id="978c2-199">Создание продолжений задач</span><span class="sxs-lookup"><span data-stu-id="978c2-199">Creating task continuations</span></span>

<span data-ttu-id="978c2-200">С помощью методов <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> и <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> можно указать задачу, которую нужно запускать по завершении *предшествующей задачи*.</span><span class="sxs-lookup"><span data-stu-id="978c2-200">The <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> methods let you specify a task to start when the *antecedent task* finishes.</span></span> <span data-ttu-id="978c2-201">Делегат задачи продолжения передается в качестве ссылки на предшествующую задачу, чтобы он мог проверить состояние предшествующей задачи и, получив значение свойства <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>, использовать выходные данные предшествующей задачи в качестве входных данных для продолжения.</span><span class="sxs-lookup"><span data-stu-id="978c2-201">The delegate of the continuation task is passed a reference to the antecedent task so that it can examine the antecedent task's status and, by retrieving the value of the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property, can use the output of the antecedent as input for the continuation.</span></span>

<span data-ttu-id="978c2-202">В следующем примере задача `getData` запускается вызовом метода <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="978c2-202">In the following example, the `getData` task is started by a call to the <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="978c2-203">Задача `processData` запускается автоматически по завершении задачи `getData`, а задача `displayData` запускается по завершении задачи `processData`.</span><span class="sxs-lookup"><span data-stu-id="978c2-203">The `processData` task is started automatically when `getData` finishes, and `displayData` is started when `processData` finishes.</span></span> <span data-ttu-id="978c2-204">Задача `getData` создает целочисленный массив, доступный задаче `processData` через свойство `getData` задачи <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="978c2-204">`getData` produces an integer array, which is accessible to the `processData` task through the `getData` task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="978c2-205">Задача `processData` обрабатывает этот массив и возвращает результат, тип которого определяется на основе типа возвращаемого значения лямбда-выражения, переданного методу <xref:System.Threading.Tasks.Task%601.ContinueWith%60%601%28System.Func%7BSystem.Threading.Tasks.Task%7B%600%7D%2C%60%600%7D%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="978c2-205">The `processData` task processes that array and returns a result whose type is inferred from the return type of the lambda expression passed to the <xref:System.Threading.Tasks.Task%601.ContinueWith%60%601%28System.Func%7BSystem.Threading.Tasks.Task%7B%600%7D%2C%60%600%7D%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="978c2-206">Задача `displayData` выполняется автоматически по завершении задачи `processData`, и объект <xref:System.Tuple%603>, возвращенный лямбда-выражением `processData`, доступен задаче `displayData` через свойство `processData` задачи <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="978c2-206">The `displayData` task executes automatically when `processData` finishes, and the <xref:System.Tuple%603> object returned by the `processData` lambda expression is accessible to the `displayData` task through the `processData` task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="978c2-207">Задача `displayData` принимает результат задачи `processData` и выдает результат, тип которого определяется аналогичным образом. Этот результат становится доступным программе в свойстве <xref:System.Threading.Tasks.Task%601.Result%2A>.</span><span class="sxs-lookup"><span data-stu-id="978c2-207">The `displayData` task takes the result of the `processData` task and produces a result whose type is inferred in a similar manner and which is made available to the program in the <xref:System.Threading.Tasks.Task%601.Result%2A> property.</span></span>

[!code-csharp[TPL_TaskIntro#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/continuations1.cs#5)]
[!code-vb[TPL_TaskIntro#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/continuations1.vb#5)]

<span data-ttu-id="978c2-208">Поскольку метод <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> является экземплярным, вызовы этого метода можно объединять в цепочку, а не создавать экземпляр объекта <xref:System.Threading.Tasks.Task%601> для каждой предшествующей задачи.</span><span class="sxs-lookup"><span data-stu-id="978c2-208">Because <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> is an instance method, you can chain method calls together instead of instantiating a <xref:System.Threading.Tasks.Task%601> object for each antecedent task.</span></span> <span data-ttu-id="978c2-209">Следующий пример функционально идентичен предыдущему, за исключением того, вызовы метода <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> в нем объединяются в цепочку.</span><span class="sxs-lookup"><span data-stu-id="978c2-209">The following example is functionally identical to the previous example, except that it chains together calls to the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="978c2-210">Обратите внимание, что объект <xref:System.Threading.Tasks.Task%601>, возвращаемый цепочкой вызовов метода, является последней задачей продолжения.</span><span class="sxs-lookup"><span data-stu-id="978c2-210">Note that the <xref:System.Threading.Tasks.Task%601> object returned by the chain of method calls is the final continuation task.</span></span>

[!code-csharp[TPL_TaskIntro#24](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/continuations2.cs#24)]
[!code-vb[TPL_TaskIntro#24](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/continuations2.vb#24)]

<span data-ttu-id="978c2-211">С помощью методов <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> и <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> можно продолжить выполнение с нескольких задач.</span><span class="sxs-lookup"><span data-stu-id="978c2-211">The <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> methods enable you to continue from multiple tasks.</span></span>

<span data-ttu-id="978c2-212">Подробнее см. в разделе [Создание цепочки задач с помощью задач продолжения](chaining-tasks-by-using-continuation-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="978c2-212">For more information, see [Chaining Tasks by Using Continuation Tasks](chaining-tasks-by-using-continuation-tasks.md).</span></span>

## <a name="creating-detached-child-tasks"></a><span data-ttu-id="978c2-213">Создание отсоединенных дочерних задач</span><span class="sxs-lookup"><span data-stu-id="978c2-213">Creating detached child tasks</span></span>

<span data-ttu-id="978c2-214">Если в пользовательском коде, выполняемом в некоторой задаче, создается новая задача и не задается параметр <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent>, новая задача не синхронизируется с родительской никаким особым способом.</span><span class="sxs-lookup"><span data-stu-id="978c2-214">When user code that is running in a task creates a new task and does not specify the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> option, the new task is not synchronized with the parent task in any special way.</span></span> <span data-ttu-id="978c2-215">Такой тип несинхронизированной задачи называется *отсоединенной вложенной задачей* или *отсоединенной дочерней задачей*.</span><span class="sxs-lookup"><span data-stu-id="978c2-215">This type of non-synchronized task is called a *detached nested task* or *detached child task*.</span></span> <span data-ttu-id="978c2-216">В следующем примере показана задача, создающая одну отсоединенную дочернюю задачу.</span><span class="sxs-lookup"><span data-stu-id="978c2-216">The following example shows a task that creates one detached child task.</span></span>

[!code-csharp[TPL_TaskIntro#07](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/taskintro.cs#07)]
[!code-vb[TPL_TaskIntro#07](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/tpl_intro.vb#07)]

<span data-ttu-id="978c2-217">Обратите внимание, что родительская задача не ожидает завершения отсоединенной дочерней задачи.</span><span class="sxs-lookup"><span data-stu-id="978c2-217">Note that the parent task does not wait for the detached child task to finish.</span></span>

## <a name="creating-child-tasks"></a><span data-ttu-id="978c2-218">Создание дочерних задач</span><span class="sxs-lookup"><span data-stu-id="978c2-218">Creating child tasks</span></span>

<span data-ttu-id="978c2-219">Если пользовательский код, который выполняется в задаче, создает новую задачу с параметром <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent>, эта новая задача считается *присоединенной дочерней задачей* родительской задачи.</span><span class="sxs-lookup"><span data-stu-id="978c2-219">When user code that is running in a task creates a task with the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> option, the new task is known as an *attached child task* of the parent task.</span></span> <span data-ttu-id="978c2-220">Параметр <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> можно использовать для выражения структурированного параллелизма задач, поскольку родительская задача неявно ожидает завершения всех присоединенных дочерних задач.</span><span class="sxs-lookup"><span data-stu-id="978c2-220">You can use the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> option to express structured task parallelism, because the parent task implicitly waits for all attached child tasks to finish.</span></span> <span data-ttu-id="978c2-221">В следующем примере показана родительская задача, создающая десять присоединенных дочерних задач.</span><span class="sxs-lookup"><span data-stu-id="978c2-221">The following example shows a parent task that creates ten attached child tasks.</span></span> <span data-ttu-id="978c2-222">Обратите внимание, что в этом примере вызывается метод <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> для ожидания завершения родительской задачи. Явное ожидание завершения присоединенных дочерних задач не требуется.</span><span class="sxs-lookup"><span data-stu-id="978c2-222">Note that although the example calls the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to wait for the parent task to finish, it does not have to explicitly wait for the attached child tasks to complete.</span></span>

[!code-csharp[TPL_TaskIntro#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/child1.cs#8)]
[!code-vb[TPL_TaskIntro#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/child1.vb#8)]

<span data-ttu-id="978c2-223">В родительской задаче может использоваться параметр <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>, не позволяющий другим задачам присоединяться к ней.</span><span class="sxs-lookup"><span data-stu-id="978c2-223">A parent task can use the <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> option to prevent other tasks from attaching to the parent task.</span></span> <span data-ttu-id="978c2-224">Дополнительные сведения см. в разделе [Присоединенные и отсоединенные дочерние задачи](attached-and-detached-child-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="978c2-224">For more information, see [Attached and Detached Child Tasks](attached-and-detached-child-tasks.md).</span></span>

## <a name="waiting-for-tasks-to-finish"></a><span data-ttu-id="978c2-225">Ожидание завершения задач</span><span class="sxs-lookup"><span data-stu-id="978c2-225">Waiting for tasks to finish</span></span>

<span data-ttu-id="978c2-226">Типы <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> и <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> предоставляют несколько перегрузок методов <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>, которые позволяют ожидать завершения задачи.</span><span class="sxs-lookup"><span data-stu-id="978c2-226">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> types provide several overloads of the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> methods that enable you to wait for a task to finish.</span></span> <span data-ttu-id="978c2-227">Кроме того, перегрузки статических методов <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> и <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> позволяют ожидать завершения какого-либо или всех массивов задач.</span><span class="sxs-lookup"><span data-stu-id="978c2-227">In addition, overloads of the static <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> methods let you wait for any or all of an array of tasks to finish.</span></span>

<span data-ttu-id="978c2-228">Как правило, ожидание задачи выполняется по одной из следующих причин.</span><span class="sxs-lookup"><span data-stu-id="978c2-228">Typically, you would wait for a task for one of these reasons:</span></span>

- <span data-ttu-id="978c2-229">Основной поток зависит от конечного результата, вычисленного задачей.</span><span class="sxs-lookup"><span data-stu-id="978c2-229">The main thread depends on the final result computed by a task.</span></span>

- <span data-ttu-id="978c2-230">Необходимо обрабатывать исключения, которые могут быть созданы из задачи.</span><span class="sxs-lookup"><span data-stu-id="978c2-230">You have to handle exceptions that might be thrown from the task.</span></span>

- <span data-ttu-id="978c2-231">Приложение может завершиться до окончания выполнения всех задач.</span><span class="sxs-lookup"><span data-stu-id="978c2-231">The application may terminate before all tasks have completed execution.</span></span> <span data-ttu-id="978c2-232">Например, выполнение консольных приложений завершается после выполнения всего синхронного кода в `Main` (точке входа приложения).</span><span class="sxs-lookup"><span data-stu-id="978c2-232">For example, console applications will terminate as soon as all synchronous code in `Main` (the application entry point) has executed.</span></span>

<span data-ttu-id="978c2-233">В следующем примере показан базовый шаблон, в котором не указана обработка исключений.</span><span class="sxs-lookup"><span data-stu-id="978c2-233">The following example shows the basic pattern that does not involve exception handling.</span></span>

[!code-csharp[TPL_TaskIntro#06](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/taskintro.cs#06)]
[!code-vb[TPL_TaskIntro#06](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/tpl_intro.vb#06)]

<span data-ttu-id="978c2-234">Пример обработки исключений см. в разделе [Обработка исключений](exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="978c2-234">For an example that shows exception handling, see [Exception Handling](exception-handling-task-parallel-library.md).</span></span>

<span data-ttu-id="978c2-235">Некоторые перегрузки позволяют задать время ожидания, а другие принимают дополнительный объект <xref:System.Threading.CancellationToken> в качестве входного параметра, чтобы ожидание можно было отменить либо программно, либо в ответ на введенные пользователем данные.</span><span class="sxs-lookup"><span data-stu-id="978c2-235">Some overloads let you specify a time-out, and others take an additional <xref:System.Threading.CancellationToken> as an input parameter, so that the wait itself can be canceled either programmatically or in response to user input.</span></span>

<span data-ttu-id="978c2-236">При ожидании задачи неявно ожидаются все ее дочерние задачи, созданные с помощью параметра <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="978c2-236">When you wait for a task, you implicitly wait for all children of that task that were created by using the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="978c2-237"><xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> выполняет возврат немедленно, если задача уже завершена.</span><span class="sxs-lookup"><span data-stu-id="978c2-237"><xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> returns immediately if the task has already completed.</span></span> <span data-ttu-id="978c2-238">Любые исключения, вызванные задачей, будут созданы методом <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>, даже если метод <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> был вызван после завершения задачи.</span><span class="sxs-lookup"><span data-stu-id="978c2-238">Any exceptions raised by a task will be thrown by a <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method, even if the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method was called after the task completed.</span></span>

## <a name="composing-tasks"></a><span data-ttu-id="978c2-239">Составление задач</span><span class="sxs-lookup"><span data-stu-id="978c2-239">Composing tasks</span></span>

<span data-ttu-id="978c2-240">Классы <xref:System.Threading.Tasks.Task> и <xref:System.Threading.Tasks.Task%601> предоставляют несколько методов, позволяющих создать ряд задач для реализации общих шаблонов и более эффективного использования асинхронных возможностей языка, предусмотренных в языках C#, Visual Basic и F#.</span><span class="sxs-lookup"><span data-stu-id="978c2-240">The <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes provide several methods that can help you compose multiple tasks to implement common patterns and to better use the asynchronous language features that are provided by C#, Visual Basic, and F#.</span></span> <span data-ttu-id="978c2-241">В этом подразделе описаны методы <xref:System.Threading.Tasks.Task.WhenAll%2A>, <xref:System.Threading.Tasks.Task.WhenAny%2A>, <xref:System.Threading.Tasks.Task.Delay%2A> и <xref:System.Threading.Tasks.Task.FromResult%2A>.</span><span class="sxs-lookup"><span data-stu-id="978c2-241">This section describes the <xref:System.Threading.Tasks.Task.WhenAll%2A>, <xref:System.Threading.Tasks.Task.WhenAny%2A>, <xref:System.Threading.Tasks.Task.Delay%2A>, and <xref:System.Threading.Tasks.Task.FromResult%2A> methods.</span></span>

### <a name="taskwhenall"></a><span data-ttu-id="978c2-242">Task.WhenAll</span><span class="sxs-lookup"><span data-stu-id="978c2-242">Task.WhenAll</span></span>

<span data-ttu-id="978c2-243">Метод <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> асинхронно ожидает завершения выполнения нескольких объектов <xref:System.Threading.Tasks.Task> или <xref:System.Threading.Tasks.Task%601>.</span><span class="sxs-lookup"><span data-stu-id="978c2-243">The <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method asynchronously waits for multiple <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> objects to finish.</span></span> <span data-ttu-id="978c2-244">Он предоставляет перегруженные версии, позволяющие ожидать неединобразные наборы задач.</span><span class="sxs-lookup"><span data-stu-id="978c2-244">It provides overloaded versions that enable you to wait for non-uniform sets of tasks.</span></span> <span data-ttu-id="978c2-245">Например, можно ожидать завершения выполнения нескольких объектов <xref:System.Threading.Tasks.Task> и <xref:System.Threading.Tasks.Task%601> от одного вызова метода.</span><span class="sxs-lookup"><span data-stu-id="978c2-245">For example, you can wait for multiple <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> objects to complete from one method call.</span></span>

### <a name="taskwhenany"></a><span data-ttu-id="978c2-246">Task.WhenAny</span><span class="sxs-lookup"><span data-stu-id="978c2-246">Task.WhenAny</span></span>

<span data-ttu-id="978c2-247">Метод <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> асинхронно ожидает завершения выполнения одного из нескольких объектов <xref:System.Threading.Tasks.Task> или <xref:System.Threading.Tasks.Task%601>.</span><span class="sxs-lookup"><span data-stu-id="978c2-247">The <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> method asynchronously waits for one of multiple <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> objects to finish.</span></span> <span data-ttu-id="978c2-248">Как и метод <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType>, этот метод предоставляет перегруженные версии, позволяющие ожидать неединобразные наборы задач.</span><span class="sxs-lookup"><span data-stu-id="978c2-248">As in the <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method, this method provides overloaded versions that enable you to wait for non-uniform sets of tasks.</span></span> <span data-ttu-id="978c2-249">Метод <xref:System.Threading.Tasks.Task.WhenAny%2A> особенно полезен в следующих ситуациях.</span><span class="sxs-lookup"><span data-stu-id="978c2-249">The <xref:System.Threading.Tasks.Task.WhenAny%2A> method is especially useful in the following scenarios.</span></span>

- <span data-ttu-id="978c2-250">Избыточные операции.</span><span class="sxs-lookup"><span data-stu-id="978c2-250">Redundant operations.</span></span> <span data-ttu-id="978c2-251">Рассмотрим алгоритм или операцию, которые можно выполнить несколькими способами.</span><span class="sxs-lookup"><span data-stu-id="978c2-251">Consider an algorithm or operation that can be performed in many ways.</span></span> <span data-ttu-id="978c2-252">Метод <xref:System.Threading.Tasks.Task.WhenAny%2A> можно использовать для выбора операции, завершающейся первой, и последующей отмены оставшихся операций.</span><span class="sxs-lookup"><span data-stu-id="978c2-252">You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to select the operation that finishes first and then cancel the remaining operations.</span></span>

- <span data-ttu-id="978c2-253">Операции с чередованием.</span><span class="sxs-lookup"><span data-stu-id="978c2-253">Interleaved operations.</span></span> <span data-ttu-id="978c2-254">Можно запустить несколько операций, которые все должны завершиться, и использовать метод <xref:System.Threading.Tasks.Task.WhenAny%2A> для обработки результатов при завершении каждой операции.</span><span class="sxs-lookup"><span data-stu-id="978c2-254">You can start multiple operations that must all finish and use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to process results as each operation finishes.</span></span> <span data-ttu-id="978c2-255">После завершения одной операции можно запустить одну или несколько дополнительных задач.</span><span class="sxs-lookup"><span data-stu-id="978c2-255">After one operation finishes, you can start one or more additional tasks.</span></span>

- <span data-ttu-id="978c2-256">Регулируемые операции.</span><span class="sxs-lookup"><span data-stu-id="978c2-256">Throttled operations.</span></span> <span data-ttu-id="978c2-257">Метод <xref:System.Threading.Tasks.Task.WhenAny%2A> можно использовать для расширения предыдущего сценария путем ограничения количества одновременно выполняемых операций.</span><span class="sxs-lookup"><span data-stu-id="978c2-257">You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to extend the previous scenario by limiting the number of concurrent operations.</span></span>

- <span data-ttu-id="978c2-258">Операции с истекшим сроком действия.</span><span class="sxs-lookup"><span data-stu-id="978c2-258">Expired operations.</span></span> <span data-ttu-id="978c2-259">Метод <xref:System.Threading.Tasks.Task.WhenAny%2A> можно использовать, чтобы сделать выбор между одной или несколькими задачами и задачей, завершающейся после определенного времени, например задачей, возвращаемой методом <xref:System.Threading.Tasks.Task.Delay%2A>.</span><span class="sxs-lookup"><span data-stu-id="978c2-259">You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to select between one or more tasks and a task that finishes after a specific time, such as a task that is returned by the <xref:System.Threading.Tasks.Task.Delay%2A> method.</span></span> <span data-ttu-id="978c2-260">Метод <xref:System.Threading.Tasks.Task.Delay%2A> описан в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="978c2-260">The <xref:System.Threading.Tasks.Task.Delay%2A> method is described in the following section.</span></span>

### <a name="taskdelay"></a><span data-ttu-id="978c2-261">Task.Delay</span><span class="sxs-lookup"><span data-stu-id="978c2-261">Task.Delay</span></span>

<span data-ttu-id="978c2-262">Метод <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> создает объект <xref:System.Threading.Tasks.Task>, завершающийся после определенного времени.</span><span class="sxs-lookup"><span data-stu-id="978c2-262">The <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method produces a <xref:System.Threading.Tasks.Task> object that finishes after the specified time.</span></span> <span data-ttu-id="978c2-263">Этот метод можно использовать для создания циклов, которые иногда запрашивают данные, вводят тайм-ауты, задерживают обработку вводимых пользователем данных на заранее определенное время и т. д.</span><span class="sxs-lookup"><span data-stu-id="978c2-263">You can use this method to build loops that occasionally poll for data, introduce time-outs, delay the handling of user input for a predetermined time, and so on.</span></span>

### <a name="tasktfromresult"></a><span data-ttu-id="978c2-264">Task(T).FromResult</span><span class="sxs-lookup"><span data-stu-id="978c2-264">Task(T).FromResult</span></span>

<span data-ttu-id="978c2-265">С помощью метода <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> можно создать объект <xref:System.Threading.Tasks.Task%601>, содержащий предварительно вычисленный результат.</span><span class="sxs-lookup"><span data-stu-id="978c2-265">By using the <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> method, you can create a <xref:System.Threading.Tasks.Task%601> object that holds a pre-computed result.</span></span> <span data-ttu-id="978c2-266">Этот метод полезен тогда, когда выполняется асинхронная операция, возвращающая объект <xref:System.Threading.Tasks.Task%601>, и результат этого объекта <xref:System.Threading.Tasks.Task%601> уже вычислен.</span><span class="sxs-lookup"><span data-stu-id="978c2-266">This method is useful when you perform an asynchronous operation that returns a <xref:System.Threading.Tasks.Task%601> object, and the result of that <xref:System.Threading.Tasks.Task%601> object is already computed.</span></span> <span data-ttu-id="978c2-267">Пример использования метода <xref:System.Threading.Tasks.Task.FromResult%2A> для получения результатов асинхронных операций загрузки, удерживаемых в кэше, см. в разделе [Практическое руководство. Создание предварительно вычисляемых задач](how-to-create-pre-computed-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="978c2-267">For an example that uses <xref:System.Threading.Tasks.Task.FromResult%2A> to retrieve the results of asynchronous download operations that are held in a cache, see [How to: Create Pre-Computed Tasks](how-to-create-pre-computed-tasks.md).</span></span>

## <a name="handling-exceptions-in-tasks"></a><span data-ttu-id="978c2-268">Обработка исключений в задачах</span><span class="sxs-lookup"><span data-stu-id="978c2-268">Handling exceptions in tasks</span></span>

<span data-ttu-id="978c2-269">Если задача создает одно или несколько исключений, они заключаются в исключение <xref:System.AggregateException>.</span><span class="sxs-lookup"><span data-stu-id="978c2-269">When a task throws one or more exceptions, the exceptions are wrapped in an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="978c2-270">Это исключение распространяется обратно в поток, который соединяется с задачей и обычно является потоком, ожидающим завершения задачи или обращающимся к свойству <xref:System.Threading.Tasks.Task%601.Result%2A>.</span><span class="sxs-lookup"><span data-stu-id="978c2-270">That exception is propagated back to the thread that joins with the task, which is typically the thread that is waiting for the task to finish or the thread that accesses the <xref:System.Threading.Tasks.Task%601.Result%2A> property.</span></span> <span data-ttu-id="978c2-271">Такое поведение служит для принудительного выполнения политики .NET Framework, согласно которой все необработанные исключения по умолчанию должны завершать процесс.</span><span class="sxs-lookup"><span data-stu-id="978c2-271">This behavior serves to enforce the .NET Framework policy that all unhandled exceptions by default should terminate the process.</span></span> <span data-ttu-id="978c2-272">Ниже указаны элементы блока `try`/`catch`, с помощью любого из которых вызывающий код может обрабатывать исключения:</span><span class="sxs-lookup"><span data-stu-id="978c2-272">The calling code can handle the exceptions by using any of the following in a `try`/`catch` block:</span></span>

- <span data-ttu-id="978c2-273">метод <xref:System.Threading.Tasks.Task.Wait%2A> ;</span><span class="sxs-lookup"><span data-stu-id="978c2-273">The <xref:System.Threading.Tasks.Task.Wait%2A> method</span></span>

- <span data-ttu-id="978c2-274">метод <xref:System.Threading.Tasks.Task.WaitAll%2A> ;</span><span class="sxs-lookup"><span data-stu-id="978c2-274">The <xref:System.Threading.Tasks.Task.WaitAll%2A> method</span></span>

- <span data-ttu-id="978c2-275">метод <xref:System.Threading.Tasks.Task.WaitAny%2A> ;</span><span class="sxs-lookup"><span data-stu-id="978c2-275">The <xref:System.Threading.Tasks.Task.WaitAny%2A> method</span></span>

- <span data-ttu-id="978c2-276">Свойство <xref:System.Threading.Tasks.Task%601.Result%2A>.</span><span class="sxs-lookup"><span data-stu-id="978c2-276">The <xref:System.Threading.Tasks.Task%601.Result%2A> property</span></span>

<span data-ttu-id="978c2-277">Присоединяемый поток также может обрабатывать исключения, обращаясь к свойству <xref:System.Threading.Tasks.Task.Exception%2A> до того, как задача будет собрана сборщиком мусора.</span><span class="sxs-lookup"><span data-stu-id="978c2-277">The joining thread can also handle exceptions by accessing the <xref:System.Threading.Tasks.Task.Exception%2A> property before the task is garbage-collected.</span></span> <span data-ttu-id="978c2-278">Обращаясь к этому свойству, вы не позволяете необработанному исключению запустить поведение распространения исключений, которое завершает процесс по окончании работы объекта.</span><span class="sxs-lookup"><span data-stu-id="978c2-278">By accessing this property, you prevent the unhandled exception from triggering the exception propagation behavior that terminates the process when the object is finalized.</span></span>

<span data-ttu-id="978c2-279">Дополнительные сведения об исключениях и задачах см. в разделе [Обработка исключений](exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="978c2-279">For more information about exceptions and tasks, see [Exception Handling](exception-handling-task-parallel-library.md).</span></span>

## <a name="canceling-tasks"></a><span data-ttu-id="978c2-280">Отмена задач</span><span class="sxs-lookup"><span data-stu-id="978c2-280">Canceling tasks</span></span>

<span data-ttu-id="978c2-281">Класс <xref:System.Threading.Tasks.Task> поддерживает совместную отмену и полностью интегрирован с классами <xref:System.Threading.CancellationTokenSource?displayProperty=nameWithType> и <xref:System.Threading.CancellationToken?displayProperty=nameWithType>, появившимися в .NET Framework 4.</span><span class="sxs-lookup"><span data-stu-id="978c2-281">The <xref:System.Threading.Tasks.Task> class supports cooperative cancellation and is fully integrated with the <xref:System.Threading.CancellationTokenSource?displayProperty=nameWithType> and <xref:System.Threading.CancellationToken?displayProperty=nameWithType> classes, which were introduced in the .NET Framework 4.</span></span> <span data-ttu-id="978c2-282">Большинство конструкторов в классе <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> принимают объект <xref:System.Threading.CancellationToken> в качестве входного параметра.</span><span class="sxs-lookup"><span data-stu-id="978c2-282">Many of the constructors in the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class take a <xref:System.Threading.CancellationToken> object as an input parameter.</span></span> <span data-ttu-id="978c2-283">Многие из перегрузок <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> и <xref:System.Threading.Tasks.Task.Run%2A> также содержат параметр <xref:System.Threading.CancellationToken>.</span><span class="sxs-lookup"><span data-stu-id="978c2-283">Many of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> and <xref:System.Threading.Tasks.Task.Run%2A> overloads also include a <xref:System.Threading.CancellationToken> parameter.</span></span>

<span data-ttu-id="978c2-284">Можно создать токен и выдать запрос отмены позднее с помощью класса <xref:System.Threading.CancellationTokenSource>.</span><span class="sxs-lookup"><span data-stu-id="978c2-284">You can create the token, and issue the cancellation request at some later time, by using the <xref:System.Threading.CancellationTokenSource> class.</span></span> <span data-ttu-id="978c2-285">Передайте токен <xref:System.Threading.Tasks.Task> в качестве аргумента и ссылайтесь на тот же токен в пользовательском делегате, который не отвечает на запрос отмены.</span><span class="sxs-lookup"><span data-stu-id="978c2-285">Pass the token to the <xref:System.Threading.Tasks.Task> as an argument, and also reference the same token in your user delegate, which does the work of responding to a cancellation request.</span></span>

<span data-ttu-id="978c2-286">Дополнительные сведения см. в разделах [Отмена задач](task-cancellation.md) и [Практическое руководство. Отмена задачи и ее дочерних элементов](how-to-cancel-a-task-and-its-children.md).</span><span class="sxs-lookup"><span data-stu-id="978c2-286">For more information, see [Task Cancellation](task-cancellation.md) and [How to: Cancel a Task and Its Children](how-to-cancel-a-task-and-its-children.md).</span></span>

## <a name="the-taskfactory-class"></a><span data-ttu-id="978c2-287">Класс TaskFactory</span><span class="sxs-lookup"><span data-stu-id="978c2-287">The TaskFactory class</span></span>

<span data-ttu-id="978c2-288">Класс <xref:System.Threading.Tasks.TaskFactory> предоставляет статические методы, которые инкапсулируют некоторые распространенные шаблоны для создания и запуска задач и задач продолжения.</span><span class="sxs-lookup"><span data-stu-id="978c2-288">The <xref:System.Threading.Tasks.TaskFactory> class provides static methods that encapsulate some common patterns for creating and starting tasks and continuation tasks.</span></span>

- <span data-ttu-id="978c2-289">Наиболее распространенным шаблоном является <xref:System.Threading.Tasks.TaskFactory.StartNew%2A>, который создает и запускает задачу в одном операторе.</span><span class="sxs-lookup"><span data-stu-id="978c2-289">The most common pattern is <xref:System.Threading.Tasks.TaskFactory.StartNew%2A>, which creates and starts a task in one statement.</span></span>

- <span data-ttu-id="978c2-290">Для создания задач продолжения из нескольких предшествующих задач используйте метод <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A>, метод <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> или их аналоги из класса <xref:System.Threading.Tasks.Task%601>.</span><span class="sxs-lookup"><span data-stu-id="978c2-290">When you create continuation tasks from multiple antecedents, use the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> method or <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> method or their equivalents in the <xref:System.Threading.Tasks.Task%601> class.</span></span> <span data-ttu-id="978c2-291">Подробнее см. в разделе [Создание цепочки задач с помощью задач продолжения](chaining-tasks-by-using-continuation-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="978c2-291">For more information, see [Chaining Tasks by Using Continuation Tasks](chaining-tasks-by-using-continuation-tasks.md).</span></span>

- <span data-ttu-id="978c2-292">Чтобы инкапсулировать методы `BeginX` и `EndX` модели асинхронного программирования в экземпляре <xref:System.Threading.Tasks.Task> или <xref:System.Threading.Tasks.Task%601>, используйте методы <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="978c2-292">To encapsulate Asynchronous Programming Model `BeginX` and `EndX` methods in a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> instance, use the <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> methods.</span></span> <span data-ttu-id="978c2-293">Дополнительные сведения см. в разделе [Библиотека параллельных задач и традиционное асинхронное программирование .NET Framework](tpl-and-traditional-async-programming.md).</span><span class="sxs-lookup"><span data-stu-id="978c2-293">For more information, see [TPL and Traditional .NET Framework Asynchronous Programming](tpl-and-traditional-async-programming.md).</span></span>

<span data-ttu-id="978c2-294">Класс <xref:System.Threading.Tasks.TaskFactory> доступен как статическое свойство класса <xref:System.Threading.Tasks.Task> или <xref:System.Threading.Tasks.Task%601>.</span><span class="sxs-lookup"><span data-stu-id="978c2-294">The default <xref:System.Threading.Tasks.TaskFactory> can be accessed as a static property on the <xref:System.Threading.Tasks.Task> class or <xref:System.Threading.Tasks.Task%601> class.</span></span> <span data-ttu-id="978c2-295">Кроме того, класс <xref:System.Threading.Tasks.TaskFactory> можно создать напрямую и указать различные параметры, включающие <xref:System.Threading.CancellationToken>, параметр <xref:System.Threading.Tasks.TaskCreationOptions>, параметр <xref:System.Threading.Tasks.TaskContinuationOptions> или <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="978c2-295">You can also instantiate a <xref:System.Threading.Tasks.TaskFactory> directly and specify various options that include a <xref:System.Threading.CancellationToken>, a <xref:System.Threading.Tasks.TaskCreationOptions> option, a <xref:System.Threading.Tasks.TaskContinuationOptions> option, or a <xref:System.Threading.Tasks.TaskScheduler>.</span></span> <span data-ttu-id="978c2-296">Любые параметры, задаваемые при создании фабрики задач, будут применяться ко всем созданным задачам, если задача <xref:System.Threading.Tasks.Task> не создана с помощью перечисления <xref:System.Threading.Tasks.TaskCreationOptions>. В этом случае параметры задачи переопределяют параметры фабрики задач.</span><span class="sxs-lookup"><span data-stu-id="978c2-296">Whatever options are specified when you create the task factory will be applied to all tasks that it creates, unless the <xref:System.Threading.Tasks.Task> is created by using the <xref:System.Threading.Tasks.TaskCreationOptions> enumeration, in which case the task's options override those of the task factory.</span></span>

## <a name="tasks-without-delegates"></a><span data-ttu-id="978c2-297">Задачи без делегатов</span><span class="sxs-lookup"><span data-stu-id="978c2-297">Tasks without delegates</span></span>

<span data-ttu-id="978c2-298">В некоторых случаях может потребоваться использовать <xref:System.Threading.Tasks.Task> для инкапсуляции некоторой асинхронной операции, которая выполняется внешним компонентом, а не собственным пользовательским делегатом.</span><span class="sxs-lookup"><span data-stu-id="978c2-298">In some cases, you may want to use a <xref:System.Threading.Tasks.Task> to encapsulate some asynchronous operation that is performed by an external component instead of your own user delegate.</span></span> <span data-ttu-id="978c2-299">Если операция основана на шаблоне Begin/End модели асинхронного программирования, можно использовать методы <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="978c2-299">If the operation is based on the Asynchronous Programming Model Begin/End pattern, you can use the <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> methods.</span></span> <span data-ttu-id="978c2-300">В противном случае можно использовать объект <xref:System.Threading.Tasks.TaskCompletionSource%601> для заключения операции в задачу, чтобы получить некоторые преимущества программирования <xref:System.Threading.Tasks.Task>, например поддержку распространения исключений и продолжений.</span><span class="sxs-lookup"><span data-stu-id="978c2-300">If that is not the case, you can use the <xref:System.Threading.Tasks.TaskCompletionSource%601> object to wrap the operation in a task and thereby gain some of the benefits of <xref:System.Threading.Tasks.Task> programmability, for example, support for exception propagation and continuations.</span></span> <span data-ttu-id="978c2-301">Для получения дополнительной информации см. <xref:System.Threading.Tasks.TaskCompletionSource%601>.</span><span class="sxs-lookup"><span data-stu-id="978c2-301">For more information, see <xref:System.Threading.Tasks.TaskCompletionSource%601>.</span></span>

## <a name="custom-schedulers"></a><span data-ttu-id="978c2-302">Пользовательские планировщики</span><span class="sxs-lookup"><span data-stu-id="978c2-302">Custom schedulers</span></span>

<span data-ttu-id="978c2-303">Большинство разработчиков приложений или библиотек не обращают внимания на то, на каком процессоре запускается задача, как она синхронизирует свою работу с другими задачами или как она планируется в <xref:System.Threading.ThreadPool?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="978c2-303">Most application or library developers do not care which processor the task runs on, how it synchronizes its work with other tasks, or how it is scheduled on the <xref:System.Threading.ThreadPool?displayProperty=nameWithType>.</span></span> <span data-ttu-id="978c2-304">Им только требуется, чтобы она выполнялась максимально эффективно на главном компьютере.</span><span class="sxs-lookup"><span data-stu-id="978c2-304">They only require that it execute as efficiently as possible on the host computer.</span></span> <span data-ttu-id="978c2-305">Если требуется более точное управление сведениями планирования, библиотека параллельных задач позволяет настроить некоторые параметры в планировщике задач по умолчанию и даже предоставить пользовательский планировщик.</span><span class="sxs-lookup"><span data-stu-id="978c2-305">If you require more fine-grained control over the scheduling details, the Task Parallel Library lets you configure some settings on the default task scheduler, and even lets you supply a custom scheduler.</span></span> <span data-ttu-id="978c2-306">Для получения дополнительной информации см. <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="978c2-306">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>

## <a name="related-data-structures"></a><span data-ttu-id="978c2-307">Структуры связанных данных</span><span class="sxs-lookup"><span data-stu-id="978c2-307">Related data structures</span></span>

<span data-ttu-id="978c2-308">Библиотека параллельных задач имеет несколько новых открытых типов, которые полезны в параллельных и последовательных сценариях.</span><span class="sxs-lookup"><span data-stu-id="978c2-308">The TPL has several new public types that are useful in both parallel and sequential scenarios.</span></span> <span data-ttu-id="978c2-309">Они включают несколько потокобезопасных, быстрых и масштабируемых классов коллекций в пространстве имен <xref:System.Collections.Concurrent?displayProperty=nameWithType> и несколько новых типов синхронизации, например <xref:System.Threading.Semaphore?displayProperty=nameWithType> и <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>, которые более эффективны, чем их предшественники для определенных типов рабочих нагрузок.</span><span class="sxs-lookup"><span data-stu-id="978c2-309">These include several thread-safe, fast and scalable collection classes in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, and several new synchronization types, for example, <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>, which are more efficient than their predecessors for specific kinds of workloads.</span></span> <span data-ttu-id="978c2-310">Другие новые типы в .NET Framework 4, например <xref:System.Threading.Barrier?displayProperty=nameWithType> и <xref:System.Threading.SpinLock?displayProperty=nameWithType>, предоставляют функциональные возможности, которые не были доступны в более ранних выпусках.</span><span class="sxs-lookup"><span data-stu-id="978c2-310">Other new types in the .NET Framework 4, for example, <xref:System.Threading.Barrier?displayProperty=nameWithType> and <xref:System.Threading.SpinLock?displayProperty=nameWithType>, provide functionality that was not available in earlier releases.</span></span> <span data-ttu-id="978c2-311">Дополнительные сведения см. в разделе [Структуры данных для параллельного программирования](data-structures-for-parallel-programming.md).</span><span class="sxs-lookup"><span data-stu-id="978c2-311">For more information, see [Data Structures for Parallel Programming](data-structures-for-parallel-programming.md).</span></span>

## <a name="custom-task-types"></a><span data-ttu-id="978c2-312">Настраиваемые типы задач</span><span class="sxs-lookup"><span data-stu-id="978c2-312">Custom task types</span></span>

<span data-ttu-id="978c2-313">Наследование из <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> или <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="978c2-313">We recommend that you do not inherit from <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="978c2-314">Вместо этого рекомендуется с помощью свойства <xref:System.Threading.Tasks.Task.AsyncState%2A> связать дополнительные данные или состояние с объектом <xref:System.Threading.Tasks.Task> или <xref:System.Threading.Tasks.Task%601>.</span><span class="sxs-lookup"><span data-stu-id="978c2-314">Instead, we recommend that you use the <xref:System.Threading.Tasks.Task.AsyncState%2A> property to associate additional data or state with a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object.</span></span> <span data-ttu-id="978c2-315">Можно также использовать методы расширения для расширения функциональных возможностей классов <xref:System.Threading.Tasks.Task> и <xref:System.Threading.Tasks.Task%601>.</span><span class="sxs-lookup"><span data-stu-id="978c2-315">You can also use extension methods to extend the functionality of the <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes.</span></span> <span data-ttu-id="978c2-316">Дополнительные сведения о методах расширения см. в разделах [Методы расширения](../../csharp/programming-guide/classes-and-structs/extension-methods.md) и [Методы расширения](../../visual-basic/programming-guide/language-features/procedures/extension-methods.md).</span><span class="sxs-lookup"><span data-stu-id="978c2-316">For more information about extension methods, see [Extension Methods](../../csharp/programming-guide/classes-and-structs/extension-methods.md) and [Extension Methods](../../visual-basic/programming-guide/language-features/procedures/extension-methods.md).</span></span>

<span data-ttu-id="978c2-317">Если необходимо наследовать от <xref:System.Threading.Tasks.Task> или <xref:System.Threading.Tasks.Task%601>, классы <xref:System.Threading.Tasks.Task.Run%2A>, <xref:System.Threading.Tasks.TaskFactory?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskFactory%601?displayProperty=nameWithType> и <xref:System.Threading.Tasks.TaskCompletionSource%601?displayProperty=nameWithType> нельзя использовать для создания экземпляров настраиваемого типа задач, так как эти механизмы создают только объекты <xref:System.Threading.Tasks.Task> и <xref:System.Threading.Tasks.Task%601>.</span><span class="sxs-lookup"><span data-stu-id="978c2-317">If you must inherit from <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601>, you cannot use <xref:System.Threading.Tasks.Task.Run%2A>, or the <xref:System.Threading.Tasks.TaskFactory?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskFactory%601?displayProperty=nameWithType>, or <xref:System.Threading.Tasks.TaskCompletionSource%601?displayProperty=nameWithType> classes to create instances of your custom task type because these mechanisms create only <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> objects.</span></span> <span data-ttu-id="978c2-318">Кроме того, механизмы продолжения задачи, работу которых обеспечивают <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.TaskFactory> и <xref:System.Threading.Tasks.TaskFactory%601>, нельзя использовать для создания экземпляров настраиваемого типа задач, поскольку эти механизмы также создают только объекты <xref:System.Threading.Tasks.Task> и <xref:System.Threading.Tasks.Task%601>.</span><span class="sxs-lookup"><span data-stu-id="978c2-318">In addition, you cannot use the task continuation mechanisms that are provided by <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.TaskFactory>, and  <xref:System.Threading.Tasks.TaskFactory%601> to create instances of your custom task type because these mechanisms also create only <xref:System.Threading.Tasks.Task> and  <xref:System.Threading.Tasks.Task%601> objects.</span></span>

## <a name="related-topics"></a><span data-ttu-id="978c2-319">См. также</span><span class="sxs-lookup"><span data-stu-id="978c2-319">Related topics</span></span>

|<span data-ttu-id="978c2-320">Заголовок</span><span class="sxs-lookup"><span data-stu-id="978c2-320">Title</span></span>|<span data-ttu-id="978c2-321">Описание</span><span class="sxs-lookup"><span data-stu-id="978c2-321">Description</span></span>|
|-|-|
|[<span data-ttu-id="978c2-322">Создание цепочки задач с помощью задач продолжения</span><span class="sxs-lookup"><span data-stu-id="978c2-322">Chaining Tasks by Using Continuation Tasks</span></span>](chaining-tasks-by-using-continuation-tasks.md)|<span data-ttu-id="978c2-323">Описание работы продолжений.</span><span class="sxs-lookup"><span data-stu-id="978c2-323">Describes how continuations work.</span></span>|
|[<span data-ttu-id="978c2-324">Присоединенные и отсоединенные дочерние задачи</span><span class="sxs-lookup"><span data-stu-id="978c2-324">Attached and Detached Child Tasks</span></span>](attached-and-detached-child-tasks.md)|<span data-ttu-id="978c2-325">Описание различий между присоединенными и отсоединенными дочерними задачами.</span><span class="sxs-lookup"><span data-stu-id="978c2-325">Describes the difference between attached and detached child tasks.</span></span>|
|[<span data-ttu-id="978c2-326">Отмена задач</span><span class="sxs-lookup"><span data-stu-id="978c2-326">Task Cancellation</span></span>](task-cancellation.md)|<span data-ttu-id="978c2-327">Описание поддержки отмены, встроенной в объект <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="978c2-327">Describes the cancellation support that is built into the <xref:System.Threading.Tasks.Task> object.</span></span>|
|[<span data-ttu-id="978c2-328">Обработка исключений</span><span class="sxs-lookup"><span data-stu-id="978c2-328">Exception Handling</span></span>](exception-handling-task-parallel-library.md)|<span data-ttu-id="978c2-329">Описание обработки исключений в параллельных потоках.</span><span class="sxs-lookup"><span data-stu-id="978c2-329">Describes how exceptions on concurrent threads are handled.</span></span>|
|[<span data-ttu-id="978c2-330">Практическое руководство. Использование функции Parallel.Invoke для выполнения параллельных операций</span><span class="sxs-lookup"><span data-stu-id="978c2-330">How to: Use Parallel.Invoke to Execute Parallel Operations</span></span>](how-to-use-parallel-invoke-to-execute-parallel-operations.md)|<span data-ttu-id="978c2-331">Описание использования <xref:System.Threading.Tasks.Parallel.Invoke%2A>.</span><span class="sxs-lookup"><span data-stu-id="978c2-331">Describes how to use <xref:System.Threading.Tasks.Parallel.Invoke%2A>.</span></span>|
|[<span data-ttu-id="978c2-332">Практическое руководство. Возвращение значения из задачи</span><span class="sxs-lookup"><span data-stu-id="978c2-332">How to: Return a Value from a Task</span></span>](how-to-return-a-value-from-a-task.md)|<span data-ttu-id="978c2-333">Описание возврата значений из задач.</span><span class="sxs-lookup"><span data-stu-id="978c2-333">Describes how to return values from tasks.</span></span>|
|[<span data-ttu-id="978c2-334">Практическое руководство. Отмена задачи и ее дочерних элементов</span><span class="sxs-lookup"><span data-stu-id="978c2-334">How to: Cancel a Task and Its Children</span></span>](how-to-cancel-a-task-and-its-children.md)|<span data-ttu-id="978c2-335">Описание отмены задач.</span><span class="sxs-lookup"><span data-stu-id="978c2-335">Describes how to cancel tasks.</span></span>|
|[<span data-ttu-id="978c2-336">Практическое руководство. Создание предварительно вычисляемых задач</span><span class="sxs-lookup"><span data-stu-id="978c2-336">How to: Create Pre-Computed Tasks</span></span>](how-to-create-pre-computed-tasks.md)|<span data-ttu-id="978c2-337">Описание использования метода <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> для получения результатов асинхронных операций загрузки, удерживаемых в кэше.</span><span class="sxs-lookup"><span data-stu-id="978c2-337">Describes how to use the <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> method to retrieve the results of asynchronous download operations that are held in a cache.</span></span>|
|[<span data-ttu-id="978c2-338">Практическое руководство. Переход по двоичному дереву с помощью параллельных задач</span><span class="sxs-lookup"><span data-stu-id="978c2-338">How to: Traverse a Binary Tree with Parallel Tasks</span></span>](how-to-traverse-a-binary-tree-with-parallel-tasks.md)|<span data-ttu-id="978c2-339">Описание использования задач для прохождения двоичного дерева.</span><span class="sxs-lookup"><span data-stu-id="978c2-339">Describes how to use tasks to traverse a binary tree.</span></span>|
|[<span data-ttu-id="978c2-340">Практическое руководство. Извлечение вложенной задачи из оболочки</span><span class="sxs-lookup"><span data-stu-id="978c2-340">How to: Unwrap a Nested Task</span></span>](how-to-unwrap-a-nested-task.md)|<span data-ttu-id="978c2-341">Демонстрация использования метода расширения <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A>.</span><span class="sxs-lookup"><span data-stu-id="978c2-341">Demonstrates how to use the <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> extension method.</span></span>|
|[<span data-ttu-id="978c2-342">Параллелизм данных</span><span class="sxs-lookup"><span data-stu-id="978c2-342">Data Parallelism</span></span>](data-parallelism-task-parallel-library.md)|<span data-ttu-id="978c2-343">Описывает способы использования методов <xref:System.Threading.Tasks.Parallel.For%2A> и <xref:System.Threading.Tasks.Parallel.ForEach%2A> для создания параллельных циклов для данных.</span><span class="sxs-lookup"><span data-stu-id="978c2-343">Describes how to use <xref:System.Threading.Tasks.Parallel.For%2A> and <xref:System.Threading.Tasks.Parallel.ForEach%2A> to create parallel loops over data.</span></span>|
|[<span data-ttu-id="978c2-344">Параллельное программирование</span><span class="sxs-lookup"><span data-stu-id="978c2-344">Parallel Programming</span></span>](index.md)|<span data-ttu-id="978c2-345">Узел верхнего уровня для параллельного программирования в .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="978c2-345">Top level node for .NET Framework parallel programming.</span></span>|

## <a name="see-also"></a><span data-ttu-id="978c2-346">См. также</span><span class="sxs-lookup"><span data-stu-id="978c2-346">See also</span></span>

- [<span data-ttu-id="978c2-347">Параллельное программирование</span><span class="sxs-lookup"><span data-stu-id="978c2-347">Parallel Programming</span></span>](index.md)
- [<span data-ttu-id="978c2-348">Примеры параллельного программирования в .NET Core и .NET Standard</span><span class="sxs-lookup"><span data-stu-id="978c2-348">Samples for Parallel Programming with the .NET Core & .NET Standard</span></span>](/samples/browse/?products=dotnet-core%2Cdotnet-standard&term=parallel)
