---
title: Пользовательские разделители для PLINQ и TPL
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, partitioners
ms.assetid: 96153688-9a01-47c4-8430-909cee9a2887
ms.openlocfilehash: 8caea6d8a97b8c0daf7c59718479ea2e12a52d78
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/15/2020
ms.locfileid: "73141568"
---
# <a name="custom-partitioners-for-plinq-and-tpl"></a><span data-ttu-id="1d672-102">Пользовательские разделители для PLINQ и TPL</span><span class="sxs-lookup"><span data-stu-id="1d672-102">Custom Partitioners for PLINQ and TPL</span></span>

<span data-ttu-id="1d672-103">Одним из основных шагов при распараллеливании операции над источником данных является *секционирование* источника, чтобы несколько потоков могли параллельно обращаться к нескольким секциям.</span><span class="sxs-lookup"><span data-stu-id="1d672-103">To parallelize an operation on a data source, one of the essential steps is to *partition* the source into multiple sections that can be accessed concurrently by multiple threads.</span></span> <span data-ttu-id="1d672-104">PLINQ и библиотека параллельных задач (TPL) предоставляют стандартные средства секционирования, которые прозрачно работают при создании параллельного запроса или цикла <xref:System.Threading.Tasks.Parallel.ForEach%2A>.</span><span class="sxs-lookup"><span data-stu-id="1d672-104">PLINQ and the Task Parallel Library (TPL) provide default partitioners that work transparently when you write a parallel query or <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span> <span data-ttu-id="1d672-105">Для более сложных сценариев вы можете подключить собственное средство секционирования.</span><span class="sxs-lookup"><span data-stu-id="1d672-105">For more advanced scenarios, you can plug in your own partitioner.</span></span>

## <a name="kinds-of-partitioning"></a><span data-ttu-id="1d672-106">Виды секционирования</span><span class="sxs-lookup"><span data-stu-id="1d672-106">Kinds of Partitioning</span></span>

<span data-ttu-id="1d672-107">Есть много разных способов секционировать источник данных.</span><span class="sxs-lookup"><span data-stu-id="1d672-107">There are many ways to partition a data source.</span></span> <span data-ttu-id="1d672-108">Самые эффективные подходы позволяют нескольким потокам совместно обрабатывать исходную последовательность, не разделяя источник физически на несколько подпоследовательностей.</span><span class="sxs-lookup"><span data-stu-id="1d672-108">In the most efficient approaches, multiple threads cooperate to process the original source sequence, rather than physically separating the source into multiple subsequences.</span></span> <span data-ttu-id="1d672-109">Для массивов и других индексированных источников, например коллекций <xref:System.Collections.IList>, длина которых известна заранее, проще всего применить *секционирование по диапазонам*.</span><span class="sxs-lookup"><span data-stu-id="1d672-109">For arrays and other indexed sources such as <xref:System.Collections.IList> collections where the length is known in advance, *range partitioning* is the simplest kind of partitioning.</span></span> <span data-ttu-id="1d672-110">В этом варианте каждый поток получает уникальные индексы начала и окончания диапазона, что позволяет ему обработать свою часть данных без конфликтов с другими потоками.</span><span class="sxs-lookup"><span data-stu-id="1d672-110">Every thread receives unique beginning and ending indexes, so that it can process its range of the source without overwriting or being overwritten by any other thread.</span></span> <span data-ttu-id="1d672-111">Секционирование по диапазонам привносит только один тип накладных расходов, связанный с начальным процессом создания этих диапазонов. При дальнейшей работе никакой дополнительной синхронизации не требуется.</span><span class="sxs-lookup"><span data-stu-id="1d672-111">The only overhead involved in range partitioning is the initial work of creating the ranges; no additional synchronization is required after that.</span></span> <span data-ttu-id="1d672-112">Такой подход обеспечит хорошую производительность, если рабочую нагрузку удастся распределить равномерно.</span><span class="sxs-lookup"><span data-stu-id="1d672-112">Therefore, it can provide good performance as long as the workload is divided evenly.</span></span> <span data-ttu-id="1d672-113">Недостаток секционирования по диапазонам заключается в том, что поток, завершивший работу раньше других, не может помочь другим потокам завершить работу.</span><span class="sxs-lookup"><span data-stu-id="1d672-113">A disadvantage of range partitioning is that if one thread finishes early, it cannot help the other threads finish their work.</span></span>

<span data-ttu-id="1d672-114">Для связанных списков и других коллекций, длина которых неизвестна, можно применить *блочное секционирование*.</span><span class="sxs-lookup"><span data-stu-id="1d672-114">For linked lists or other collections whose length is not known, you can use *chunk partitioning*.</span></span> <span data-ttu-id="1d672-115">В этом варианте каждый поток, каждая задача в параллельных циклах или каждый запрос поочередно извлекает определенное количество исходных элементов в виде блока, обрабатывает их и снова обращается за дополнительным блоком элементов.</span><span class="sxs-lookup"><span data-stu-id="1d672-115">In chunk partitioning, every thread or task in a parallel loop or query consumes some number of source elements in one chunk, processes them, and then comes back to retrieve additional elements.</span></span> <span data-ttu-id="1d672-116">Средство секционирования следит за тем, чтобы все элементы были обработаны строго один раз.</span><span class="sxs-lookup"><span data-stu-id="1d672-116">The partitioner ensures that all elements are distributed and that there are no duplicates.</span></span> <span data-ttu-id="1d672-117">Могут использоваться блоки любого размера.</span><span class="sxs-lookup"><span data-stu-id="1d672-117">A chunk may be any size.</span></span> <span data-ttu-id="1d672-118">Например, средство секционирования из статьи [Практическое руководство. Реализация динамических разделов](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) создает блоки размером в один элемент.</span><span class="sxs-lookup"><span data-stu-id="1d672-118">For example, the partitioner that is demonstrated in [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) creates chunks that contain just one element.</span></span> <span data-ttu-id="1d672-119">Если размер блока не слишком велик, такой тип секционирования автоматически правильно балансирует нагрузку, так как не использует предварительное распределение элементов по потокам.</span><span class="sxs-lookup"><span data-stu-id="1d672-119">As long as the chunks are not too large, this kind of partitioning is inherently load-balancing because the assignment of elements to threads is not pre-determined.</span></span> <span data-ttu-id="1d672-120">Но средство секционирования все же добавляет определенные накладные расходы, связанные с синхронизацией, при каждом получении очередного блока для потока.</span><span class="sxs-lookup"><span data-stu-id="1d672-120">However, the partitioner does incur the synchronization overhead each time the thread needs to get another chunk.</span></span> <span data-ttu-id="1d672-121">Степень синхронизации в этом алгоритме обратно пропорциональна размеру блоков.</span><span class="sxs-lookup"><span data-stu-id="1d672-121">The amount of synchronization incurred in these cases is inversely proportional to the size of the chunks.</span></span>

<span data-ttu-id="1d672-122">В целом секционирование по диапазонам выполняется быстрее только в том случае, если делегат выполняется за малый или средний период времени, а источник имеет большое количество элементов и трудозатраты на каждую секцию примерно одинаковы.</span><span class="sxs-lookup"><span data-stu-id="1d672-122">In general, range partitioning is only faster when the execution time of the delegate is small to moderate, and the source has a large number of elements, and the total work of each partition is roughly equivalent.</span></span> <span data-ttu-id="1d672-123">Соответственно, блочное секционирование в большинстве случаев работает быстрее.</span><span class="sxs-lookup"><span data-stu-id="1d672-123">Chunk partitioning is therefore generally faster in most cases.</span></span> <span data-ttu-id="1d672-124">Для источников с небольшим числом элементов или для делегатов с продолжительным временем выполнения производительность этих двух типов секционирования примерно равна.</span><span class="sxs-lookup"><span data-stu-id="1d672-124">On sources with a small number of elements or longer execution times for the delegate, then the performance of chunk and range partitioning is about equal.</span></span>

<span data-ttu-id="1d672-125">Средства секционирования библиотеки TPL также поддерживают динамическое количество секций.</span><span class="sxs-lookup"><span data-stu-id="1d672-125">The TPL partitioners also support a dynamic number of partitions.</span></span> <span data-ttu-id="1d672-126">Такой подход означает создание секций "на лету", например при создании новой задачи в цикле <xref:System.Threading.Tasks.Parallel.ForEach%2A>.</span><span class="sxs-lookup"><span data-stu-id="1d672-126">This means they can create partitions on-the-fly, for example, when the <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop spawns a new task.</span></span> <span data-ttu-id="1d672-127">Эта функция позволяет средству секционирования масштабироваться синхронно с циклом.</span><span class="sxs-lookup"><span data-stu-id="1d672-127">This feature enables the partitioner to scale together with the loop itself.</span></span> <span data-ttu-id="1d672-128">Динамические средства секционирования также автоматически балансируют нагрузку.</span><span class="sxs-lookup"><span data-stu-id="1d672-128">Dynamic partitioners are also inherently load-balancing.</span></span> <span data-ttu-id="1d672-129">Если вы создаете собственное средство секционирования, обязательно обеспечьте поддержку динамического секционирования из цикла <xref:System.Threading.Tasks.Parallel.ForEach%2A>.</span><span class="sxs-lookup"><span data-stu-id="1d672-129">When you create a custom partitioner, you must support dynamic partitioning to be consumable from a <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span>

### <a name="configuring-load-balancing-partitioners-for-plinq"></a><span data-ttu-id="1d672-130">Настройка средств секционирования с балансировкой нагрузки для PLINQ</span><span class="sxs-lookup"><span data-stu-id="1d672-130">Configuring Load Balancing Partitioners for PLINQ</span></span>

<span data-ttu-id="1d672-131">Некоторые перегрузки метода <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> позволяют создать средство секционирования для массива или источника <xref:System.Collections.IList> и выбрать, будет ли он распределять рабочую нагрузку между потоками.</span><span class="sxs-lookup"><span data-stu-id="1d672-131">Some overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> method let you create a partitioner for an array or <xref:System.Collections.IList> source and specify whether it should attempt to balance the workload among the threads.</span></span> <span data-ttu-id="1d672-132">Если средство секционирования поддерживает балансировку нагрузки, используется блочное секционирование и элементы распределяются небольшими блоками по мере запрашивания.</span><span class="sxs-lookup"><span data-stu-id="1d672-132">When the partitioner is configured to load-balance, chunk partitioning is used, and the elements are handed off to each partition in small chunks as they are requested.</span></span> <span data-ttu-id="1d672-133">Такой подход нужен для того, чтобы все секции содержали элементы для обработки до полного завершения цикла или запроса.</span><span class="sxs-lookup"><span data-stu-id="1d672-133">This approach helps ensure that all partitions have elements to process until the entire loop or query is completed.</span></span> <span data-ttu-id="1d672-134">Можно использовать дополнительные перегрузки, чтобы реализовать балансировку нагрузки для любого источника <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="1d672-134">An additional overload can be used to provide load-balancing partitioning of any <xref:System.Collections.IEnumerable> source.</span></span>

<span data-ttu-id="1d672-135">Обычно для балансировки нагрузки важно, чтобы секции относительно часто запрашивали новые элементы у средства секционирования.</span><span class="sxs-lookup"><span data-stu-id="1d672-135">In general, load balancing requires the partitions to request elements relatively frequently from the partitioner.</span></span> <span data-ttu-id="1d672-136">Напротив, средство статического секционирования может распределить все элементы единовременно, используя секционирование по диапазонам или блочное секционирование.</span><span class="sxs-lookup"><span data-stu-id="1d672-136">By contrast, a partitioner that does static partitioning can assign the elements to each partitioner all at once by using either range or chunk partitioning.</span></span> <span data-ttu-id="1d672-137">Накладные расходы в этом случае будут ниже, чем при балансировке нагрузки, но выполнение может занять больше времени, если одному из потоков достанется существенно больше работы, чем остальным.</span><span class="sxs-lookup"><span data-stu-id="1d672-137">This requires less overhead than load balancing, but it might take longer to execute if one thread ends up with significantly more work than the others.</span></span> <span data-ttu-id="1d672-138">По умолчанию PLINQ всегда использует секционирование по диапазонам без балансировки нагрузки, когда получает на вход ILIst или массив.</span><span class="sxs-lookup"><span data-stu-id="1d672-138">By default when it is passed an IList or an array, PLINQ always uses range partitioning without load balancing.</span></span> <span data-ttu-id="1d672-139">Чтобы включить в PLINQ балансировку нагрузки, используйте метод `Partitioner.Create`, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="1d672-139">To enable load balancing for PLINQ, use the `Partitioner.Create` method, as shown in the following example.</span></span>

[!code-csharp[TPL_Partitioners#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioners.cs#02)]
[!code-vb[TPL_Partitioners#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionsnippets_vb.vb#02)]

<span data-ttu-id="1d672-140">Самый надежный способ определиться с применением балансировки нагрузки для конкретного сценария — выполнить эксперименты и замерить длительность выполнения операций при типичных нагрузках и разных конфигурациях компьютера.</span><span class="sxs-lookup"><span data-stu-id="1d672-140">The best way to determine whether to use load balancing in any given scenario is to experiment and measure how long it takes operations to complete under representative loads and computer configurations.</span></span> <span data-ttu-id="1d672-141">Например статическое секционирование может значительно ускорить работу на компьютере с небольшим количеством ядер, но привести к замедлению работы на компьютерах с относительно большим количеством ядер.</span><span class="sxs-lookup"><span data-stu-id="1d672-141">For example, static partitioning might provide significant speedup on a multi-core computer that has only a few cores, but it might result in slowdowns on computers that have relatively many cores.</span></span>

<span data-ttu-id="1d672-142">В следующей таблице перечислены все доступные перегрузки метода <xref:System.Collections.Concurrent.Partitioner.Create%2A>.</span><span class="sxs-lookup"><span data-stu-id="1d672-142">The following table lists the available overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> method.</span></span> <span data-ttu-id="1d672-143">Эти средства секционирования можно использовать не только с PLINQ или <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="1d672-143">These partitioners are not limited to use only with PLINQ or <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="1d672-144">Они пригодны для любой пользовательской конструкции с параллельной обработкой.</span><span class="sxs-lookup"><span data-stu-id="1d672-144">They can also be used with any custom parallel construct.</span></span>

|<span data-ttu-id="1d672-145">Перегрузка</span><span class="sxs-lookup"><span data-stu-id="1d672-145">Overload</span></span>|<span data-ttu-id="1d672-146">Использование балансировки нагрузки</span><span class="sxs-lookup"><span data-stu-id="1d672-146">Uses load balancing</span></span>|
|--------------|-------------------------|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>|<span data-ttu-id="1d672-147">Всегда</span><span class="sxs-lookup"><span data-stu-id="1d672-147">Always</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28%60%600%5B%5D%2CSystem.Boolean%29>|<span data-ttu-id="1d672-148">Если передан логический аргумент со значением true</span><span class="sxs-lookup"><span data-stu-id="1d672-148">When the Boolean argument is specified as true</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IList%7B%60%600%7D%2CSystem.Boolean%29>|<span data-ttu-id="1d672-149">Если передан логический аргумент со значением true</span><span class="sxs-lookup"><span data-stu-id="1d672-149">When the Boolean argument is specified as true</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%29>|<span data-ttu-id="1d672-150">Никогда</span><span class="sxs-lookup"><span data-stu-id="1d672-150">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%2CSystem.Int32%29>|<span data-ttu-id="1d672-151">Никогда</span><span class="sxs-lookup"><span data-stu-id="1d672-151">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%29>|<span data-ttu-id="1d672-152">Никогда</span><span class="sxs-lookup"><span data-stu-id="1d672-152">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%2CSystem.Int64%29>|<span data-ttu-id="1d672-153">Никогда</span><span class="sxs-lookup"><span data-stu-id="1d672-153">Never</span></span>|

### <a name="configuring-static-range-partitioners-for-parallelforeach"></a><span data-ttu-id="1d672-154">Настройка средств статического секционирования по диапазонам для Parallel.ForEach</span><span class="sxs-lookup"><span data-stu-id="1d672-154">Configuring Static Range Partitioners for Parallel.ForEach</span></span>

<span data-ttu-id="1d672-155">Когда используется цикл <xref:System.Threading.Tasks.Parallel.For%2A>, тело этого цикла передается методу в качестве делегата.</span><span class="sxs-lookup"><span data-stu-id="1d672-155">In a <xref:System.Threading.Tasks.Parallel.For%2A> loop, the body of the loop is provided to the method as a delegate.</span></span> <span data-ttu-id="1d672-156">Затраты на вызов этого делегата будут примерно такими же, как на вызов виртуального метода.</span><span class="sxs-lookup"><span data-stu-id="1d672-156">The cost of invoking that delegate is about the same as a virtual method call.</span></span> <span data-ttu-id="1d672-157">В некоторых сценариях тело цикла параллельной обработки будет настолько небольшим, что затраты на вызов делегата при каждой итерации цикла составят значительную часть нагрузки.</span><span class="sxs-lookup"><span data-stu-id="1d672-157">In some scenarios, the body of a parallel loop might be small enough that the cost of the delegate invocation on each loop iteration becomes significant.</span></span> <span data-ttu-id="1d672-158">В такой ситуации вы можете применить одну из перегрузок <xref:System.Collections.Concurrent.Partitioner.Create%2A>, чтобы создать <xref:System.Collections.Generic.IEnumerable%601> для секций диапазонов, распределив по ним исходные элементы.</span><span class="sxs-lookup"><span data-stu-id="1d672-158">In such situations, you can use one of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads to create an <xref:System.Collections.Generic.IEnumerable%601> of range partitions over the source elements.</span></span> <span data-ttu-id="1d672-159">Эта коллекция диапазонов затем передается в метод <xref:System.Threading.Tasks.Parallel.ForEach%2A>, тело которого состоит из стандартного цикла `for`.</span><span class="sxs-lookup"><span data-stu-id="1d672-159">Then, you can pass this collection of ranges to a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method whose body consists of a regular `for` loop.</span></span> <span data-ttu-id="1d672-160">Преимущество этого подхода заключается в том, что затраты на вызов делегата применяются только один раз для каждого диапазона, а не для каждого элемента.</span><span class="sxs-lookup"><span data-stu-id="1d672-160">The benefit of this approach is that the delegate invocation cost is incurred only once per range, rather than once per element.</span></span> <span data-ttu-id="1d672-161">В следующем примере показан базовый шаблон.</span><span class="sxs-lookup"><span data-stu-id="1d672-161">The following example demonstrates the basic pattern.</span></span>

[!code-csharp[TPL_Partitioners#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioner01.cs#01)]
[!code-vb[TPL_Partitioners#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionercreate01.vb#01)]

<span data-ttu-id="1d672-162">Каждый поток в цикле получает собственный класс <xref:System.Tuple%602>, который содержит начальное и конечное значения индекса для назначенного ему поддиапазона.</span><span class="sxs-lookup"><span data-stu-id="1d672-162">Every thread in the loop receives its own <xref:System.Tuple%602> that contains the starting and ending index values in the specified sub-range.</span></span> <span data-ttu-id="1d672-163">Внутренний цикл `for` использует значения `fromInclusive` и `toExclusive`, напрямую перебирая массив или <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="1d672-163">The inner `for` loop uses the `fromInclusive` and `toExclusive` values to loop over the array or the <xref:System.Collections.IList> directly.</span></span>

<span data-ttu-id="1d672-164">Одна из перегрузок <xref:System.Collections.Concurrent.Partitioner.Create%2A> позволяет указать размер и количество секций.</span><span class="sxs-lookup"><span data-stu-id="1d672-164">One of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads lets you specify the size of the partitions, and the number of partitions.</span></span> <span data-ttu-id="1d672-165">Эта перегрузка удобна для тех ситуаций, в которых обработка каждого элемента требует так мало работы, что даже один вызов виртуального метода для каждого элемента существенно снизит производительность.</span><span class="sxs-lookup"><span data-stu-id="1d672-165">This overload can be used in scenarios where the work per element is so low that even one virtual method call per element has a noticeable impact on performance.</span></span>

## <a name="custom-partitioners"></a><span data-ttu-id="1d672-166">Пользовательские разделители</span><span class="sxs-lookup"><span data-stu-id="1d672-166">Custom Partitioners</span></span>

<span data-ttu-id="1d672-167">В некоторых случаях будет оправданно или даже необходимо реализовать пользовательское средство секционирования.</span><span class="sxs-lookup"><span data-stu-id="1d672-167">In some scenarios, it might be worthwhile or even required to implement your own partitioner.</span></span> <span data-ttu-id="1d672-168">Например, если у вас есть пользовательский класс коллекции и знание его внутренней структуры позволяет вам секционировать его более эффективно, чем это делают стандартные средства секционирования.</span><span class="sxs-lookup"><span data-stu-id="1d672-168">For example, you might have a custom collection class that you can partition more efficiently than the default partitioners can, based on your knowledge of the internal structure of the class.</span></span> <span data-ttu-id="1d672-169">Или же вы знаете, что на обработку элементов, расположенных в разных местах исходной коллекции, потребуется разное и прогнозируемое время, а значит можете создать секции с диапазонами разных размеров.</span><span class="sxs-lookup"><span data-stu-id="1d672-169">Or, you may want to create range partitions of varying sizes based on your knowledge of how long it will take to process elements at different locations in the source collection.</span></span>

<span data-ttu-id="1d672-170">Чтобы создать простое пользовательское средство секционирования, наследуйте класс от <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> и переопределите для него виртуальные методы, которые описаны в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="1d672-170">To create a basic custom partitioner, derive a class from <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> and override the virtual methods, as described in the following table.</span></span>

|||
|-|-|
|<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>|<span data-ttu-id="1d672-171">Этот метод вызывается основным потоком один раз и возвращает IList(IEnumerator(TSource)).</span><span class="sxs-lookup"><span data-stu-id="1d672-171">This method is called once by the main thread and returns an IList(IEnumerator(TSource)).</span></span> <span data-ttu-id="1d672-172">Каждый рабочий поток в цикле или запросе может вызвать `GetEnumerator` для списка, чтобы получить <xref:System.Collections.Generic.IEnumerator%601> по конкретной секции.</span><span class="sxs-lookup"><span data-stu-id="1d672-172">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="1d672-173">Возвращайте `true`, если вы реализовали <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, в противном случае — `false`.</span><span class="sxs-lookup"><span data-stu-id="1d672-173">Return `true` if you implement <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, otherwise, `false`.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="1d672-174">Если <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> имеет значение `true`, можно (но не обязательно) вызвать этот метод вместо <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="1d672-174">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|

<span data-ttu-id="1d672-175">Если результаты требуют сортировки или вам нужен доступ к элементам по индексам, наследуйте класс от <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> и переопределите его виртуальные методы, как описано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="1d672-175">If the results must be sortable or you require indexed access into the elements, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> and override its virtual methods as described in the following table.</span></span>

|||
|-|-|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetPartitions%2A>|<span data-ttu-id="1d672-176">Этот метод вызывается основным потоком один раз и возвращает `IList(IEnumerator(TSource))`.</span><span class="sxs-lookup"><span data-stu-id="1d672-176">This method is called once by the main thread and returns an `IList(IEnumerator(TSource))`.</span></span> <span data-ttu-id="1d672-177">Каждый рабочий поток в цикле или запросе может вызвать `GetEnumerator` для списка, чтобы получить <xref:System.Collections.Generic.IEnumerator%601> по конкретной секции.</span><span class="sxs-lookup"><span data-stu-id="1d672-177">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="1d672-178">Возвращайте `true`, если вы реализовали <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>, или FALSE в противном случае.</span><span class="sxs-lookup"><span data-stu-id="1d672-178">Return `true` if you implement <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; otherwise, false.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="1d672-179">Как правило, он просто вызывает <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="1d672-179">Typically, this just calls <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>|<span data-ttu-id="1d672-180">Если <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> имеет значение `true`, можно (но не обязательно) вызвать этот метод вместо <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="1d672-180">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|

<span data-ttu-id="1d672-181">В следующей таблице приведены дополнительные сведения о том, как реализован класс <xref:System.Collections.Concurrent.OrderablePartitioner%601> в трех типах средств секционирования с балансировкой нагрузки.</span><span class="sxs-lookup"><span data-stu-id="1d672-181">The following table provides additional details about how the three kinds of load-balancing partitioners implement the <xref:System.Collections.Concurrent.OrderablePartitioner%601> class.</span></span>

|<span data-ttu-id="1d672-182">Метод или свойство</span><span class="sxs-lookup"><span data-stu-id="1d672-182">Method/Property</span></span>|<span data-ttu-id="1d672-183">IList или массив без балансировки нагрузки</span><span class="sxs-lookup"><span data-stu-id="1d672-183">IList / Array without Load Balancing</span></span>|<span data-ttu-id="1d672-184">IList или массив с балансировкой нагрузки</span><span class="sxs-lookup"><span data-stu-id="1d672-184">IList / Array with Load Balancing</span></span>|<span data-ttu-id="1d672-185">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="1d672-185">IEnumerable</span></span>|
|----------------------|-------------------------------------------|----------------------------------------|-----------------|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>|<span data-ttu-id="1d672-186">Использует секционирование по диапазонам</span><span class="sxs-lookup"><span data-stu-id="1d672-186">Uses range partitioning</span></span>|<span data-ttu-id="1d672-187">Использует блочное секционирование, оптимизированное для списков с указанным значением partitionCount</span><span class="sxs-lookup"><span data-stu-id="1d672-187">Uses chunk partitioning optimized for Lists for the partitionCount specified</span></span>|<span data-ttu-id="1d672-188">Использует блочное секционирование, создавая статическое количество секций.</span><span class="sxs-lookup"><span data-stu-id="1d672-188">Uses chunk partitioning by creating a static number of partitions.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A?displayProperty=nameWithType>|<span data-ttu-id="1d672-189">Создает неподдерживаемое исключение</span><span class="sxs-lookup"><span data-stu-id="1d672-189">Throws not-supported exception</span></span>|<span data-ttu-id="1d672-190">Использует блочное секционирование для списков и динамических секций</span><span class="sxs-lookup"><span data-stu-id="1d672-190">Uses chunk partitioning optimized for Lists and dynamic partitions</span></span>|<span data-ttu-id="1d672-191">Использует блочное секционирование, создавая динамическое количество секций.</span><span class="sxs-lookup"><span data-stu-id="1d672-191">Uses chunk partitioning by creating a dynamic number of partitions.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedInEachPartition%2A>|<span data-ttu-id="1d672-192">Возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="1d672-192">Returns `true`</span></span>|<span data-ttu-id="1d672-193">Возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="1d672-193">Returns `true`</span></span>|<span data-ttu-id="1d672-194">Возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="1d672-194">Returns `true`</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedAcrossPartitions%2A>|<span data-ttu-id="1d672-195">Возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="1d672-195">Returns `true`</span></span>|<span data-ttu-id="1d672-196">Возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="1d672-196">Returns `false`</span></span>|<span data-ttu-id="1d672-197">Возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="1d672-197">Returns `false`</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysNormalized%2A>|<span data-ttu-id="1d672-198">Возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="1d672-198">Returns `true`</span></span>|<span data-ttu-id="1d672-199">Возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="1d672-199">Returns `true`</span></span>|<span data-ttu-id="1d672-200">Возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="1d672-200">Returns `true`</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="1d672-201">Возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="1d672-201">Returns `false`</span></span>|<span data-ttu-id="1d672-202">Возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="1d672-202">Returns `true`</span></span>|<span data-ttu-id="1d672-203">Возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="1d672-203">Returns `true`</span></span>|

### <a name="dynamic-partitions"></a><span data-ttu-id="1d672-204">Динамические секции</span><span class="sxs-lookup"><span data-stu-id="1d672-204">Dynamic Partitions</span></span>

<span data-ttu-id="1d672-205">Если ваше средство секционирования будет использоваться в методе <xref:System.Threading.Tasks.Parallel.ForEach%2A>, нужно поддерживать создание динамического количества секций.</span><span class="sxs-lookup"><span data-stu-id="1d672-205">If you intend the partitioner to be used in a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method, you must be able to return a dynamic number of partitions.</span></span> <span data-ttu-id="1d672-206">Это означает, что средство секционирования в любой момент обработки цикла может передать перечислитель для создания новой секции по требованию.</span><span class="sxs-lookup"><span data-stu-id="1d672-206">This means that the partitioner can supply an enumerator for a new partition on-demand at any time during loop execution.</span></span> <span data-ttu-id="1d672-207">Обычно цикл запрашивает новую секцию для каждой новой параллельной задачи, которую он создает.</span><span class="sxs-lookup"><span data-stu-id="1d672-207">Basically, whenever the loop adds a new parallel task, it requests a new partition for that task.</span></span> <span data-ttu-id="1d672-208">Если вам важно поддерживать упорядочение данных, наследуйте класс от <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType>, чтобы присваивать уникальный индекс каждому элементу в каждой секции.</span><span class="sxs-lookup"><span data-stu-id="1d672-208">If you require the data to be orderable, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> so that each item in each partition is assigned a unique index.</span></span>

<span data-ttu-id="1d672-209">Дополнительные сведения и пример см. в статье [Практическое руководство. Реализация динамических разделов](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="1d672-209">For more information, and an example, see [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>

### <a name="contract-for-partitioners"></a><span data-ttu-id="1d672-210">Контракт для средств секционирования</span><span class="sxs-lookup"><span data-stu-id="1d672-210">Contract for Partitioners</span></span>

<span data-ttu-id="1d672-211">Если вы реализуете пользовательское средство секционирования, придерживайтесь следующих рекомендаций для корректного взаимодействия с PLINQ и <xref:System.Threading.Tasks.Parallel.ForEach%2A> в TPL:</span><span class="sxs-lookup"><span data-stu-id="1d672-211">When you implement a custom partitioner, follow these guidelines to help ensure correct interaction with PLINQ and <xref:System.Threading.Tasks.Parallel.ForEach%2A> in the TPL:</span></span>

- <span data-ttu-id="1d672-212">Если <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> вызывается с аргументом `partitionsCount`, значение которого равно нулю или меньше, создавайте исключение <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="1d672-212">If <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> is called with an argument of zero or less for `partitionsCount`, throw <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="1d672-213">Несмотря на то, что PLINQ и TPL никогда не передают для `partitionCount` значение 0, мы рекомендуем подстраховаться от такой ситуации.</span><span class="sxs-lookup"><span data-stu-id="1d672-213">Although PLINQ and TPL will never pass in a `partitionCount` equal to 0, we nevertheless recommend that you guard against the possibility.</span></span>

- <span data-ttu-id="1d672-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> и <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> должны всегда возвращать число секций (`partitionsCount`).</span><span class="sxs-lookup"><span data-stu-id="1d672-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> should always return `partitionsCount` number of partitions.</span></span> <span data-ttu-id="1d672-215">Если у средства секционирования недостаточно данных, чтобы создать требуемое число секций, метод должен возвращать пустой перечислитель для всех остальных секций.</span><span class="sxs-lookup"><span data-stu-id="1d672-215">If the partitioner runs out of data and cannot create as many partitions as requested, then the method should return an empty enumerator for each of the remaining partitions.</span></span> <span data-ttu-id="1d672-216">В противном случае PLINQ и TPL создадут исключение <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="1d672-216">Otherwise, both PLINQ and TPL will throw an <xref:System.InvalidOperationException>.</span></span>

- <span data-ttu-id="1d672-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A> и <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> никогда не должны возвращать `null` (`Nothing` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="1d672-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> should never return `null` (`Nothing` in Visual Basic).</span></span> <span data-ttu-id="1d672-218">В противном случае PLINQ и (или) TPL создадут исключение <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="1d672-218">If they do, PLINQ / TPL will throw an <xref:System.InvalidOperationException>.</span></span>

- <span data-ttu-id="1d672-219">Методы, которые возвращают секции, должны всегда возвращать секции, которые способны полностью и однозначно перечислить данные из источника.</span><span class="sxs-lookup"><span data-stu-id="1d672-219">Methods that return partitions should always return partitions that can fully and uniquely enumerate the data source.</span></span> <span data-ttu-id="1d672-220">Не допускайте дублирования или пропуска элементов в источнике данных, если такое поведение не требуется от средства секционирования для конкретных целей.</span><span class="sxs-lookup"><span data-stu-id="1d672-220">There should be no duplication in the data source or skipped items unless specifically required by the design of the partitioner.</span></span> <span data-ttu-id="1d672-221">Если вы не будете соблюдать это правило, может быть нарушен порядок выходных данных.</span><span class="sxs-lookup"><span data-stu-id="1d672-221">If this rule is not followed, then the output order may be scrambled.</span></span>

- <span data-ttu-id="1d672-222">Следующие методы получения логических значений должны всегда точно возвращать следующие значения, чтобы не нарушать порядок выходных данных:</span><span class="sxs-lookup"><span data-stu-id="1d672-222">The following Boolean getters must always accurately return the following values so that the output order is not scrambled:</span></span>

  - <span data-ttu-id="1d672-223">`KeysOrderedInEachPartition`. Каждая секция возвращает элементы в порядке увеличения индексов ключа.</span><span class="sxs-lookup"><span data-stu-id="1d672-223">`KeysOrderedInEachPartition`: Each partition returns elements with increasing key indices.</span></span>

  - <span data-ttu-id="1d672-224">`KeysOrderedAcrossPartitions`. Для всех возвращаемых секций соблюдается условие, что все индексы ключа в секции *i* выше, чем все индексы ключа в секции *i*–1.</span><span class="sxs-lookup"><span data-stu-id="1d672-224">`KeysOrderedAcrossPartitions`: For all partitions that are returned, the key indices in partition *i* are higher than the key indices in partition *i*-1.</span></span>

  - <span data-ttu-id="1d672-225">`KeysNormalized`. Все индексы ключа возрастают монотонно и без промежутков, начиная с нуля.</span><span class="sxs-lookup"><span data-stu-id="1d672-225">`KeysNormalized`: All key indices are monotonically increasing without gaps, starting from zero.</span></span>

- <span data-ttu-id="1d672-226">Все индексы должны быть уникальными.</span><span class="sxs-lookup"><span data-stu-id="1d672-226">All indices must be unique.</span></span> <span data-ttu-id="1d672-227">Не допускается повторение индексов.</span><span class="sxs-lookup"><span data-stu-id="1d672-227">There may not be duplicate indices.</span></span> <span data-ttu-id="1d672-228">Если вы не будете соблюдать это правило, может быть нарушен порядок выходных данных.</span><span class="sxs-lookup"><span data-stu-id="1d672-228">If this rule is not followed, then the output order may be scrambled.</span></span>

- <span data-ttu-id="1d672-229">Все индексы должны быть неотрицательными.</span><span class="sxs-lookup"><span data-stu-id="1d672-229">All indices must be nonnegative.</span></span> <span data-ttu-id="1d672-230">Если это правило не соблюдается, PLINQ и (или) TPL могут создавать исключения.</span><span class="sxs-lookup"><span data-stu-id="1d672-230">If this rule is not followed, then PLINQ/TPL may throw exceptions.</span></span>

## <a name="see-also"></a><span data-ttu-id="1d672-231">См. также раздел</span><span class="sxs-lookup"><span data-stu-id="1d672-231">See also</span></span>

- [<span data-ttu-id="1d672-232">Параллельное программирование</span><span class="sxs-lookup"><span data-stu-id="1d672-232">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)
- [<span data-ttu-id="1d672-233">Практическое руководство. Реализация динамических секций</span><span class="sxs-lookup"><span data-stu-id="1d672-233">How to: Implement Dynamic Partitions</span></span>](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)
- [<span data-ttu-id="1d672-234">Практическое руководство. Реализация разделителя для статического секционирования</span><span class="sxs-lookup"><span data-stu-id="1d672-234">How to: Implement a Partitioner for Static Partitioning</span></span>](../../../docs/standard/parallel-programming/how-to-implement-a-partitioner-for-static-partitioning.md)
