---
title: Пошаговое руководство. Внедрение типов из управляемых сборок в Visual Studio
ms.date: 08/19/2019
ms.assetid: 55ed13c9-c5bb-4bc2-bcd8-0587eb568864
dev_langs:
- csharp
- vb
ms.openlocfilehash: 1f32bd840efa97b62097a2d051c25d519785b381
ms.sourcegitcommit: 7b1ce327e8c84f115f007be4728d29a89efe11ef
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/13/2019
ms.locfileid: "70972735"
---
# <a name="walkthrough-embed-types-from-managed-assemblies-in-visual-studio"></a>Пошаговое руководство. Внедрение типов из управляемых сборок в Visual Studio

Внедряя сведения о типе из управляемой сборки со строгим именем, можно свободно объединять типы в приложении, делая версию независимой. Это означает, что в программе можно использовать типы из любой версии управляемой библиотеки, т. е. необходимость компиляции для каждой новой версии отпадает.

Внедрение типов часто используется с COM-взаимодействием, например в приложениях, использующих объекты автоматизации из Microsoft Office. Сведения о типе внедрения позволяют одной и той же сборке программы работать с различными версиями Microsoft Office на разных компьютерах. Тем не менее внедрение типа можно также использовать с полностью управляемыми решениями.

После указания открытых интерфейсов, доступных для внедрения, создайте реализующие их классы среды выполнения. Во время разработки клиентская программа встраивает сведения о типе для интерфейсов, ссылаясь на сборку, содержащую открытые интерфейсы, и присваивая свойству `Embed Interop Types` ссылки значение `True`. После этого клиентская программа может загружать экземпляры объектов среды выполнения, типизированные как указанные интерфейсы. Это эквивалентно использованию компилятора командной строки и ссылки на сборку с помощью параметра компилятора `/link`. 

При создании новой версии сборки среды выполнения со строгим именем повторная компиляция клиентской программы не требуется. Клиентская программа продолжает работать с той версией сборки среды выполнения, которая ей доступна, используя сведения о внедренном типе для открытых интерфейсов.

В этом пошаговом руководстве описаны следующие операции:

1. Создайте сборку со строгим именем и открытым интерфейсом, содержащим сведения о типе, который может быть внедрен.
1. Создайте сборку среды выполнения со строгим именем, реализующую открытый интерфейс.
1. Создайте клиентскую программу, внедряющую сведения о типе из открытого интерфейса и создающую экземпляр класса из сборки среды выполнения.
1. Внесите изменения и создайте сборку среды выполнения заново.
1. Запустите клиентскую программу, чтобы увидеть, что новая версия сборки среды выполнения используется без повторной компиляции.

[!INCLUDE[note_settings_general](../../../includes/note-settings-general-md.md)]

## <a name="conditions-and-limitations"></a>Условия и ограничения

Вы можете внедрить информацию о типах из сборки при следующих условиях: 

- Сборка предоставляет по крайней мере один открытый интерфейс.
- Внедренные интерфейсы снабжаются аннотацией с указанием атрибутов `ComImport` и `Guid` с уникальными GUID.
- Сборка снабжается аннотацией с указанием атрибута `ImportedFromTypeLib` или атрибута `PrimaryInteropAssembly`, а также атрибута сборки `Guid`. По умолчанию шаблоны проектов Visual C# и Visual Basic включают атрибут сборки `Guid`.

Так как основной функцией внедрения типа является поддержка внедрения сборок COM-взаимодействия, при внедрении сведений о типе в полностью управляемое решение применяются следующие ограничения:

- Внедряются только атрибуты, характерные для COM-взаимодействия. Другие атрибуты игнорируются.
- Если тип включает универсальные параметры внедренного типа, использовать этот тип за границей сборки невозможно. Граница сборки пересекается, например, при вызове метода из другой сборки или выведении типа из типа, определенного в другой сборке.
- Константы не внедряются.
- Класс <xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType> не поддерживает использование внедренного типа в качестве ключа. Для поддержки внедренного типа в качестве ключа можно реализовать свой собственный тип словаря.

## <a name="create-an-interface"></a>Создание интерфейса

Первый шаг заключается в создании сборки интерфейса для эквивалентности типов. 

1. В Visual Studio последовательно выберите **Файл** > **Создать** > **Проект**.
   
1. В диалоговом окне **Создание проекта** введите *библиотека классов* в поле **Поиск шаблонов**. Выберите шаблон **Библиотека классов (.NET Framework)** для C# или VB в списке и нажмите кнопку **Далее**. 
   
1. В диалоговом окне **Настроить новый проект** в поле **Имя проекта** введите *TypeEquivalenceInterface* и нажмите кнопку **Создать**. Проект создан.
   
1. В **обозревателе решений** щелкните правой кнопкой мыши файл *Class1.cs* или *Class1.vb*, выберите пункт **Переименовать** и переименуйте файл с *Class1* на *ISampleInterface*. Ответьте **Да** на запрос, чтобы также переименовать класс на `ISampleInterface`. Этот класс представляет открытый интерфейс для класса.
   
1. В **обозревателе решений** щелкните правой кнопкой мыши проект **TypeEquivalenceInterface** и выберите пункт **Свойства**. 
   
1. Выберите элемент **Сборка** в левой области экрана **Свойства** и задайте в поле **Путь вывода** расположение на компьютере, например *C:\TypeEquivalenceSample*. Данное расположение используется в рамках всего этого пошагового руководства. 
   
1. Выберите **Подписывание** в левой области экрана **Свойства** и установите флажок **Подписать сборку**. В раскрывающемся списке **Выберите файл ключа строгого имени** выберите **Создать**. 
   
1. В диалоговом окне **Создание ключа строгого имени** в разделе **Имя файла ключа** введите *key.snk*. Снимите флажок **Защитить мой файл ключей паролем** и нажмите кнопку **ОК**.
   
1. Откройте файл класса *ISampleInterface* в редакторе кода и замените его содержимое следующим кодом, чтобы создать интерфейс `ISampleInterface`:
   
   ```csharp
   using System;
   using System.Runtime.InteropServices;
   
   namespace TypeEquivalenceInterface
   {
       [ComImport]
       [Guid("8DA56996-A151-4136-B474-32784559F6DF")]
       public interface ISampleInterface
       {
           void GetUserInput();
           string UserInput { get; }
       }
   }
   ```
   
   ```vb
   Imports System.Runtime.InteropServices
   
   <ComImport()>
   <Guid("8DA56996-A151-4136-B474-32784559F6DF")>
   Public Interface ISampleInterface
       Sub GetUserInput()
       ReadOnly Property UserInput As String
   End Interface
   ```
   
1. В меню **Сервис** выберите пункт **Создать GUID** и в диалоговом окне **Создание GUID** выберите **Формат реестра**. Выберите **Копировать**, а затем **Выход**.
   
1. В атрибуте `Guid` кода замените пример GUID на скопированный GUID и удалите фигурные скобки ( **{ }** ).
   
1. В **обозревателе решений** разверните папку **Свойства** и выберите файл *AssemblyInfo.cs* или *AssemblyInfo.vb* file. В редакторе кода добавьте в файл следующий атрибут:
   
   ```csharp
   [assembly: ImportedFromTypeLib("")]
   ```
   
   ```vb
   <Assembly: ImportedFromTypeLib("")>
   ```
   
1. Выберите **Файл** > **Сохранить все** или нажмите клавиши **CTRL**+**SHIFT**+**S** для сохранения файлов и проекта.
   
1. В **обозревателе решений** щелкните правой кнопкой мыши проект **TypeEquivalenceInterface** и выберите пункт **Сборка**. DLL-файл библиотеки классов компилируется и сохраняется по указанному пути вывода сборки, например *C:\TypeEquivalenceSample*.

## <a name="create-a-runtime-class"></a>Создание класса среды выполнения

Далее создайте класс среды выполнения для эквивалентности типов.

1. В Visual Studio последовательно выберите **Файл** > **Создать** > **Проект**.
   
1. В диалоговом окне **Создание проекта** введите *библиотека классов* в поле **Поиск шаблонов**. Выберите шаблон **Библиотека классов (.NET Framework)** для C# или VB в списке и нажмите кнопку **Далее**. 
   
1. В диалоговом окне **Настроить новый проект** в поле **Имя проекта** введите *TypeEquivalenceRuntime* и нажмите кнопку **Создать**. Проект создан.
   
1. В **обозревателе решений** щелкните правой кнопкой мыши файл *Class1.cs* или *Class1.vb*, выберите пункт **Переименовать** и переименуйте файл с *Class1* на *SampleClass*. Ответьте **Да** на запрос, чтобы также переименовать класс на `SampleClass`. Этот класс реализует интерфейс `ISampleInterface` .
   
1. В **обозревателе решений** щелкните правой кнопкой мыши проект **TypeEquivalenceInterface** и выберите пункт **Свойства**. 
   
1. Выберите элемент **Сборка** в левой области экрана **Свойства** и задайте в поле **Путь вывода** то же расположение, которое использовали для проекта TypeEquivalenceInterface, например, *C:\TypeEquivalenceSample*.
   
1. Выберите **Подписывание** в левой области экрана **Свойства** и установите флажок **Подписать сборку**. В раскрывающемся списке **Выберите файл ключа строгого имени** выберите **Создать**. 
   
1. В диалоговом окне **Создание ключа строгого имени** в разделе **Имя файла ключа** введите *key.snk*. Снимите флажок **Защитить мой файл ключей паролем** и нажмите кнопку **ОК**.
   
1. В **обозревателе решений** щелкните проект **TypeEquivalenceRuntime** правой кнопкой мыши и выберите **Добавить** > **Ссылка**. 
   
1. В диалоговом окне **Диспетчер ссылок** выберите **Обзор** и перейдите к папке пути вывода. Выберите файл *TypeEquivalenceInterface.dll*, нажмите кнопку **Добавить** и затем кнопку **ОК**.
   
1. В **обозревателе решений** разверните папку **Ссылки** и выберите ссылку **TypeEquivalenceInterface**. В области **Свойства** задайте для параметра **Определенная версия** значение **False**, если оно еще не установлено.
   
1. Откройте файл класса *SampleClass* в редакторе кода и замените его содержимое следующим кодом, чтобы создать класс `SampleClass`:
   
   ```csharp
   using System;
   using System.Collections.Generic;
   using System.Linq;
   using System.Text;
   using TypeEquivalenceInterface;
   
   namespace TypeEquivalenceRuntime
   {
       public class SampleClass : ISampleInterface
       {
           private string p_UserInput;
           public string UserInput { get { return p_UserInput; } }
   
           public void GetUserInput()
           {
               Console.WriteLine("Please enter a value:");
               p_UserInput = Console.ReadLine();
           }
       }
   }
   ```
   
   ```vb
   Imports TypeEquivalenceInterface
   
   Public Class SampleClass
       Implements ISampleInterface
   
       Private p_UserInput As String
       Public ReadOnly Property UserInput() As String Implements ISampleInterface.UserInput
           Get
               Return p_UserInput
           End Get
       End Property
   
       Public Sub GetUserInput() Implements ISampleInterface.GetUserInput
           Console.WriteLine("Please enter a value:")
           p_UserInput = Console.ReadLine()
       End Sub
   End Class
   ```
   
1. Выберите **Файл** > **Сохранить все** или нажмите клавиши **CTRL**+**SHIFT**+**S** для сохранения файлов и проекта.
   
1. В **обозревателе решений** щелкните проект **TypeEquivalenceRuntime** правой кнопкой мыши и выберите **Сборка**. DLL-файл библиотеки классов компилируется и сохраняется по указанному пути вывода сборки.

## <a name="create-a-client-project"></a>Создание клиентского проекта

Наконец, создайте клиентскую программу эквивалентности типов, которая ссылается на сборку интерфейса.

1. В Visual Studio последовательно выберите **Файл** > **Создать** > **Проект**.
   
1. В диалоговом окне **Создание проекта** введите *консоль* в поле **Поиск шаблонов**. Выберите шаблон **Консольное приложение (.NET Framework)** для C# или VB в списке и нажмите кнопку **Далее**. 
   
1. В диалоговом окне **Настроить новый проект** в поле **Имя проекта** введите *TypeEquivalenceClient* и нажмите кнопку **Создать**. Проект создан.
   
1. В **обозревателе решений** щелкните правой кнопкой мыши проект **TypeEquivalenceClient** и выберите пункт **Свойства**. 
   
1. Выберите элемент **Сборка** в левой области экрана **Свойства** и задайте в поле **Путь вывода** то же расположение, которое использовали для проекта TypeEquivalenceInterface, например, *C:\TypeEquivalenceSample*.
   
1. В **обозревателе решений** щелкните правой кнопкой мыши проект **TypeEquivalenceClient** и выберите **Добавить** > **Ссылка**. 
   
1. В диалоговом окне **Диспетчер ссылок** выберите файл **TypeEquivalenceInterface.dll**, если он уже присутствует в списке. В противном случае выберите **Обзор**, перейдите к папке пути вывода, выберите файл *TypeEquivalenceInterface.dll* (а не *TypeEquivalenceRuntime.dll*) и нажмите кнопку **Добавить**. Нажмите кнопку **ОК**.
   
1. В **обозревателе решений** разверните папку **Ссылки** и выберите ссылку **TypeEquivalenceInterface**. В области **Свойства** установите для параметра **Внедрить типы взаимодействия** значение **True**.
   
1. Откройте файл *Program.cs* или *Module1.vb* в редакторе кода и замените его содержимое следующим кодом, чтобы создать клиентскую программу:
   
   ```csharp
   using System;
   using System.Collections.Generic;
   using System.Linq;
   using System.Text;
   using TypeEquivalenceInterface;
   using System.Reflection;
   
   namespace TypeEquivalenceClient
   {
       class Program
       {
           static void Main(string[] args)
           {
               Assembly sampleAssembly = Assembly.Load("TypeEquivalenceRuntime");
               ISampleInterface sampleClass =
                   (ISampleInterface)sampleAssembly.CreateInstance("TypeEquivalenceRuntime.SampleClass");
               sampleClass.GetUserInput();
               Console.WriteLine(sampleClass.UserInput);
               Console.WriteLine(sampleAssembly.GetName().Version.ToString());
               Console.ReadLine();
           }
       }
   }
   ```
   
   ```vb
   Imports TypeEquivalenceInterface
   Imports System.Reflection
   
   Module Module1
   
       Sub Main()
           Dim sampleAssembly = Assembly.Load("TypeEquivalenceRuntime")
           Dim sampleClass As ISampleInterface = CType( _
               sampleAssembly.CreateInstance("TypeEquivalenceRuntime.SampleClass"), ISampleInterface)
           sampleClass.GetUserInput()
           Console.WriteLine(sampleClass.UserInput)
           Console.WriteLine(sampleAssembly.GetName().Version)
           Console.ReadLine()
       End Sub
   
   End Module
   ```
   
1. Выберите **Файл** > **Сохранить все** или нажмите клавиши **CTRL**+**SHIFT**+**S** для сохранения файлов и проекта.
   
1. Нажмите клавиши **CTRL**+**F5**, чтобы собрать и запустить программу. Обратите внимание, что выходные данные консоли возвращают версию сборки **1.0.0.0**. 
   
## <a name="modify-the-interface"></a>Изменение интерфейса

Теперь измените сборку интерфейса и смените ее версию. 

1. В Visual Studio выберите **Файл** > **Открыть** > **Проект/решение** и откройте проект **TypeEquivalenceInterface**.
   
1. В **обозревателе решений** щелкните правой кнопкой мыши проект **TypeEquivalenceInterface** и выберите пункт **Свойства**. 
   
1. Выберите **Приложение** в левой области экрана **Свойства** и элемент **Сведения о сборке**. 
   
1. В диалоговом окне **Сведения о сборке** измените значения **Версия сборки** и **Версия файла** на *2.0.0.0* и нажмите кнопку **ОК**.
   
1. Откройте файл *SampleInterface.cs* или *SampleInterface.vb* и добавьте в интерфейс `ISampleInterface` следующую строку кода:
   
   ```csharp
   DateTime GetDate();
   ```
   
   ```vb
   Function GetDate() As Date
   ```
   
1. Выберите **Файл** > **Сохранить все** или нажмите клавиши **CTRL**+**SHIFT**+**S** для сохранения файлов и проекта.
   
1. В **обозревателе решений** щелкните правой кнопкой мыши проект **TypeEquivalenceInterface** и выберите пункт **Сборка**. Новая версия DLL-файла библиотеки классов компилируется и сохраняется по пути вывода сборки.

## <a name="modify-the-runtime-class"></a>Изменение класса среды выполнения

Также измените класс среды выполнения и обновите его версию. 

1. В Visual Studio выберите **Файл** > **Открыть** > **Проект/решение** и откройте проект **TypeEquivalenceRuntime**.
   
1. В **обозревателе решений** щелкните проект **TypeEquivalenceRuntime** правой кнопкой мыши и выберите **Свойства**. 
   
1. Выберите **Приложение** в левой области экрана **Свойства** и элемент **Сведения о сборке**. 
   
1. В диалоговом окне **Сведения о сборке** измените значения **Версия сборки** и **Версия файла** на *2.0.0.0* и нажмите кнопку **ОК**.
   
1. Откройте файл *SampleClass.cs* или *SampleClass.vb* и добавьте в класс `SampleClass` следующий код:
   
   ```csharp
    public DateTime GetDate()
    {
        return DateTime.Now;
    }
   ```
   
   ```vb
   Public Function GetDate() As DateTime Implements ISampleInterface.GetDate
       Return Now
   End Function
   ```
   
1. Выберите **Файл** > **Сохранить все** или нажмите клавиши **CTRL**+**SHIFT**+**S** для сохранения файлов и проекта.
   
1. В **обозревателе решений** щелкните проект **TypeEquivalenceRuntime** правой кнопкой мыши и выберите **Сборка**. Новая версия DLL-файла библиотеки классов компилируется и сохраняется по пути вывода сборки.

## <a name="run-the-updated-client-program"></a>Запуск обновленной клиентской программы 

Перейдите в папку вывода сборки и запустите *TypeEquivalenceClient.exe*. Обратите внимание, что выходные данные консоли теперь отражают новую версию сборки `TypeEquivalenceRuntime` — *2.0.0.0* — без повторной компиляции программы.

## <a name="see-also"></a>См. также

- [/link (параметры компилятора C#)](../../csharp/language-reference/compiler-options/link-compiler-option.md)
- [/link (Visual Basic)](../../visual-basic/reference/command-line-compiler/link.md)
- [Руководство по программированию на C#](../../csharp/programming-guide/index.md)
- [Основные понятия программирования (Visual Basic)](../../visual-basic/programming-guide/concepts/index.md)
- [Программирование с использованием сборок](program.md)
- [Сборки в .NET](index.md)
