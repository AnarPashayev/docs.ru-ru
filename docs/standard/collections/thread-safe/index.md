---
title: Потокобезопасные коллекции
description: Начало работы с потокобезопасными коллекциями с использованием пространства имен System.Collections.Concurrent в .NET, включая потокобезопасные и масштабируемые классы коллекций.
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- thread-safe collections, overview
ms.assetid: 2e7ca21f-786c-4367-96be-0cf3f3dcc6bd
ms.openlocfilehash: 27b0e887d7dcff6a6c792cf2dfab6a449f59646f
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/15/2020
ms.locfileid: "90547692"
---
# <a name="thread-safe-collections"></a><span data-ttu-id="de012-103">Потокобезопасные коллекции</span><span class="sxs-lookup"><span data-stu-id="de012-103">Thread-Safe Collections</span></span>
<span data-ttu-id="de012-104">В .NET Framework 4 введено пространство имен <xref:System.Collections.Concurrent?displayProperty=nameWithType>, включающее несколько потокобезопасных и масштабируемых классов коллекций.</span><span class="sxs-lookup"><span data-stu-id="de012-104">The .NET Framework 4 introduces the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, which includes several collection classes that are both thread-safe and scalable.</span></span> <span data-ttu-id="de012-105">Несколько потоков могут безопасно и эффективно добавлять и удалять элементы из таких коллекций, не требуя при этом дополнительной синхронизации в пользовательском коде.</span><span class="sxs-lookup"><span data-stu-id="de012-105">Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code.</span></span> <span data-ttu-id="de012-106">При написании нового кода пользуйтесь классами параллельных коллекций, когда множество потоков будет вести в коллекцию запись параллельно.</span><span class="sxs-lookup"><span data-stu-id="de012-106">When you write new code, use the concurrent collection classes whenever multiple threads will write to the collection concurrently.</span></span> <span data-ttu-id="de012-107">Если выполняется только чтение из общей коллекции, вы можете использовать классы в пространстве имен <xref:System.Collections.Generic?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="de012-107">If you are only reading from a shared collection, then you can use the classes in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="de012-108">Мы рекомендуем использовать классы коллекций версии 1.0 только в том случае, если вам нужна среда выполнения .NET Framework до версии 1.1 включительно.</span><span class="sxs-lookup"><span data-stu-id="de012-108">We recommend that you do not use 1.0 collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime.</span></span>  
  
## <a name="thread-synchronization-in-the-net-framework-10-and-20-collections"></a><span data-ttu-id="de012-109">Синхронизация потоков в коллекциях .NET Framework версий 1.0 и 2.0</span><span class="sxs-lookup"><span data-stu-id="de012-109">Thread Synchronization in the .NET Framework 1.0 and 2.0 Collections</span></span>  
 <span data-ttu-id="de012-110">Коллекции, представленные в .NET Framework 1.0, находятся в пространстве имен <xref:System.Collections?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="de012-110">The collections introduced in the .NET Framework 1.0 are found in the <xref:System.Collections?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="de012-111">Эти коллекции, которые содержат часто используемые классы <xref:System.Collections.ArrayList> и <xref:System.Collections.Hashtable>, обеспечивают определенную степень потокобезопасности посредством свойства `Synchronized`, которое создает для коллекции потокобезопасную программу-оболочку.</span><span class="sxs-lookup"><span data-stu-id="de012-111">These collections, which include the commonly used <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>, provide some thread-safety through the `Synchronized` property, which returns a thread-safe wrapper around the collection.</span></span> <span data-ttu-id="de012-112">Работа программы оболочки заключается в блокировке всей коллекции при каждой операции добавления или удаления.</span><span class="sxs-lookup"><span data-stu-id="de012-112">The wrapper works by locking the entire collection on every add or remove operation.</span></span> <span data-ttu-id="de012-113">Поэтому каждый поток, который пытается получить доступ к коллекции, должен ждать своей очереди для получения блокировки.</span><span class="sxs-lookup"><span data-stu-id="de012-113">Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock.</span></span> <span data-ttu-id="de012-114">Такой подход не является масштабируемым и может привести к значительному снижению производительности для больших коллекций.</span><span class="sxs-lookup"><span data-stu-id="de012-114">This is not scalable and can cause significant performance degradation for large collections.</span></span> <span data-ttu-id="de012-115">Также такой подход не защищен полностью от состояния гонки.</span><span class="sxs-lookup"><span data-stu-id="de012-115">Also, the design is not completely protected from race conditions.</span></span> <span data-ttu-id="de012-116">Дополнительные сведения см. в статье [Синхронизация в универсальных коллекциях](/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer).</span><span class="sxs-lookup"><span data-stu-id="de012-116">For more information, see [Synchronization in Generic Collections](/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer).</span></span>  
  
 <span data-ttu-id="de012-117">Классы коллекций, представленные в .NET Framework 2.0, находятся в пространстве имен <xref:System.Collections.Generic?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="de012-117">The collection classes introduced in the .NET Framework 2.0 are found in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="de012-118">К ним относятся <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602> и др.</span><span class="sxs-lookup"><span data-stu-id="de012-118">These include <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602>, and so on.</span></span> <span data-ttu-id="de012-119">Эти классы отличаются улучшенной безопасностью типа и производительностью по сравнению с классами .NET Framework 1.0.</span><span class="sxs-lookup"><span data-stu-id="de012-119">These classes provide improved type safety and performance compared to the .NET Framework 1.0 classes.</span></span> <span data-ttu-id="de012-120">Однако классы коллекций .NET Framework 2.0 не обеспечивают синхронизацию потоков. Пользовательский код должен обеспечивать всю синхронизацию при параллельном добавлении элементов в несколько потоков или удалении элементов из них.</span><span class="sxs-lookup"><span data-stu-id="de012-120">However, the .NET Framework 2.0 collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently.</span></span>  
  
 <span data-ttu-id="de012-121">Рекомендуем использовать классы многопоточных коллекций .NET Framework 4, так как они обеспечивают не только безопасность типа, как у классов .NET Framework 2.0, но и большую эффективность и более полную потокобезопасность по сравнению с коллекциями .NET Framework 1.0.</span><span class="sxs-lookup"><span data-stu-id="de012-121">We recommend the concurrent collections classes in the .NET Framework 4 because they provide not only the type safety of the .NET Framework 2.0 collection classes, but also more efficient and more complete thread safety than the .NET Framework 1.0 collections provide.</span></span>  
  
## <a name="fine-grained-locking-and-lock-free-mechanisms"></a><span data-ttu-id="de012-122">Механизм блокировки мелких фрагментов данных и механизм, свободный от блокировки</span><span class="sxs-lookup"><span data-stu-id="de012-122">Fine-Grained Locking and Lock-Free Mechanisms</span></span>  
 <span data-ttu-id="de012-123">Некоторые типы многопоточных коллекций используют упрощенные механизмы синхронизации, например <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim> и <xref:System.Threading.CountdownEvent>, которые впервые введены в .NET Framework 4.</span><span class="sxs-lookup"><span data-stu-id="de012-123">Some of the concurrent collection types use lightweight synchronization mechanisms such as <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim>, and <xref:System.Threading.CountdownEvent>, which are new in the .NET Framework 4.</span></span> <span data-ttu-id="de012-124">Эти типы синхронизации обычно используют *цикличную работу* для коротких промежутков перед помещением потока в фактическое состояние ожидания.</span><span class="sxs-lookup"><span data-stu-id="de012-124">These synchronization types typically use *busy spinning* for brief periods before they put the thread into a true Wait state.</span></span> <span data-ttu-id="de012-125">При условии, что время ожидания предполагается очень коротким, цикличность требует значительно меньших затрат компьютерных ресурсов, чем ожидание, которое включает в себя переход в режим ядра, требующий больших затрат компьютерных ресурсов.</span><span class="sxs-lookup"><span data-stu-id="de012-125">When wait times are expected to be very short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition.</span></span> <span data-ttu-id="de012-126">Для классов коллекций, которые используют цикличность, эта эффективность означает, что множество потоков могут добавлять и удалять большое количество элементов.</span><span class="sxs-lookup"><span data-stu-id="de012-126">For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a very high rate.</span></span> <span data-ttu-id="de012-127">Дополнительные сведения о цикличности и блокировках см. в статья [SpinLock](../../threading/spinlock.md) и [SpinWait](../../threading/spinwait.md).</span><span class="sxs-lookup"><span data-stu-id="de012-127">For more information about spinning vs. blocking, see [SpinLock](../../threading/spinlock.md) and [SpinWait](../../threading/spinwait.md).</span></span>  
  
 <span data-ttu-id="de012-128">Классы <xref:System.Collections.Concurrent.ConcurrentQueue%601> и <xref:System.Collections.Concurrent.ConcurrentStack%601> не используют блокировку.</span><span class="sxs-lookup"><span data-stu-id="de012-128">The <xref:System.Collections.Concurrent.ConcurrentQueue%601> and <xref:System.Collections.Concurrent.ConcurrentStack%601> classes do not use locks at all.</span></span> <span data-ttu-id="de012-129">Вместо этого они используют операции класса <xref:System.Threading.Interlocked> для обеспечения потокобезопасности.</span><span class="sxs-lookup"><span data-stu-id="de012-129">Instead, they rely on <xref:System.Threading.Interlocked> operations to achieve thread-safety.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="de012-130">Так как классы многопоточных коллекций поддерживают интерфейс <xref:System.Collections.ICollection>, они включают реализации для свойств <xref:System.Collections.ICollection.IsSynchronized%2A> и <xref:System.Collections.ICollection.SyncRoot%2A>, даже хотя эти свойства никак не используются.</span><span class="sxs-lookup"><span data-stu-id="de012-130">Because the concurrent collections classes support <xref:System.Collections.ICollection>, they provide implementations for the <xref:System.Collections.ICollection.IsSynchronized%2A> and <xref:System.Collections.ICollection.SyncRoot%2A> properties, even though these properties are irrelevant.</span></span> <span data-ttu-id="de012-131">`IsSynchronized` всегда возвращает `false`, а `SyncRoot` всегда имеет значение `null` (`Nothing` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="de012-131">`IsSynchronized` always returns `false` and `SyncRoot` is always `null` (`Nothing` in Visual Basic).</span></span>  
  
 <span data-ttu-id="de012-132">В следующей таблице перечислены типы коллекций в пространстве имен <xref:System.Collections.Concurrent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="de012-132">The following table lists the collection types in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace.</span></span>  
  
|<span data-ttu-id="de012-133">Type</span><span class="sxs-lookup"><span data-stu-id="de012-133">Type</span></span>|<span data-ttu-id="de012-134">Описание</span><span class="sxs-lookup"><span data-stu-id="de012-134">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601>|<span data-ttu-id="de012-135">Предоставляет возможности блокировки и ограничения для всех типов, реализующих интерфейс <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="de012-135">Provides bounding and blocking functionality for any type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span></span> <span data-ttu-id="de012-136">Дополнительные сведения см. в разделе [Общие сведения о коллекции BlockingCollection](blockingcollection-overview.md).</span><span class="sxs-lookup"><span data-stu-id="de012-136">For more information, see [BlockingCollection Overview](blockingcollection-overview.md).</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602>|<span data-ttu-id="de012-137">Потокобезопасная реализация словаря пар "ключ-значение".</span><span class="sxs-lookup"><span data-stu-id="de012-137">Thread-safe implementation of a dictionary of key-value pairs.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601>|<span data-ttu-id="de012-138">Потокобезопасная реализация очереди с типом "первым поступил — первым обслужен" (FIFO).</span><span class="sxs-lookup"><span data-stu-id="de012-138">Thread-safe implementation of a FIFO (first-in, first-out) queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601>|<span data-ttu-id="de012-139">Потокобезопасная реализация стека с типом "последним поступил — первым обслужен" (LIFO).</span><span class="sxs-lookup"><span data-stu-id="de012-139">Thread-safe implementation of a LIFO (last-in, first-out) stack.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601>|<span data-ttu-id="de012-140">Потокобезопасная реализация неупорядоченной коллекции элементов.</span><span class="sxs-lookup"><span data-stu-id="de012-140">Thread-safe implementation of an unordered collection of elements.</span></span>|  
|<xref:System.Collections.Concurrent.IProducerConsumerCollection%601>|<span data-ttu-id="de012-141">Это интерфейс, тип которого должен быть реализован для использования в классе `BlockingCollection`.</span><span class="sxs-lookup"><span data-stu-id="de012-141">The interface that a type must implement to be used in a `BlockingCollection`.</span></span>|  
  
## <a name="related-topics"></a><span data-ttu-id="de012-142">См. также</span><span class="sxs-lookup"><span data-stu-id="de012-142">Related Topics</span></span>  
  
|<span data-ttu-id="de012-143">Заголовок</span><span class="sxs-lookup"><span data-stu-id="de012-143">Title</span></span>|<span data-ttu-id="de012-144">Описание</span><span class="sxs-lookup"><span data-stu-id="de012-144">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="de012-145">Общие сведения о коллекции BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="de012-145">BlockingCollection Overview</span></span>](blockingcollection-overview.md)|<span data-ttu-id="de012-146">Приводится описание функциональных возможностей, которые предоставляются типом <xref:System.Collections.Concurrent.BlockingCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="de012-146">Describes the functionality provided by the <xref:System.Collections.Concurrent.BlockingCollection%601> type.</span></span>|  
|[<span data-ttu-id="de012-147">Практическое руководство. Добавление элементов в коллекцию ConcurrentDictionary и их удаление из этой коллекции</span><span class="sxs-lookup"><span data-stu-id="de012-147">How to: Add and Remove Items from a ConcurrentDictionary</span></span>](how-to-add-and-remove-items.md)|<span data-ttu-id="de012-148">Приводится описание добавления и удаления элементов в классе <xref:System.Collections.Concurrent.ConcurrentDictionary%602></span><span class="sxs-lookup"><span data-stu-id="de012-148">Describes how to add and remove elements from a <xref:System.Collections.Concurrent.ConcurrentDictionary%602></span></span>|  
|[<span data-ttu-id="de012-149">Практическое руководство. Добавление и удаление отдельных элементов коллекции BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="de012-149">How to: Add and Take Items Individually from a BlockingCollection</span></span>](how-to-add-and-take-items.md)|<span data-ttu-id="de012-150">Приводится описание порядка добавления и получения элементов из заблокированной коллекции без использования перечислителя, доступного только для чтения.</span><span class="sxs-lookup"><span data-stu-id="de012-150">Describes how to add and retrieve items from a blocking collection without using the read-only enumerator.</span></span>|  
|[<span data-ttu-id="de012-151">Практическое руководство. Добавление функций границы и блокировки в коллекцию</span><span class="sxs-lookup"><span data-stu-id="de012-151">How to: Add Bounding and Blocking Functionality to a Collection</span></span>](how-to-add-bounding-and-blocking.md)|<span data-ttu-id="de012-152">Приводится описание порядка использования всех классов коллекций в качестве базового механизма хранения для коллекции <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="de012-152">Describes how to use any collection class as the underlying storage mechanism for an <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> collection.</span></span>|  
|[<span data-ttu-id="de012-153">Практическое руководство. Использование оператора ForEach для удаления элементов в коллекции BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="de012-153">How to: Use ForEach to Remove Items in a BlockingCollection</span></span>](how-to-use-foreach-to-remove.md)|<span data-ttu-id="de012-154">Описание порядка использования `foreach` (`For Each` в Visual Basic) для удаления всех элементов в заблокированной коллекции.</span><span class="sxs-lookup"><span data-stu-id="de012-154">Describes how to use `foreach`, (`For Each` in Visual Basic) to remove all items in a blocking collection.</span></span>|  
|[<span data-ttu-id="de012-155">Практическое руководство. Использование массивов для блокировки коллекций в конвейере</span><span class="sxs-lookup"><span data-stu-id="de012-155">How to: Use Arrays of Blocking Collections in a Pipeline</span></span>](how-to-use-arrays-of-blockingcollections.md)|<span data-ttu-id="de012-156">Приводится описание порядка одновременного использования нескольких заблокированных коллекций для реализации конвейера.</span><span class="sxs-lookup"><span data-stu-id="de012-156">Describes how to use multiple blocking collections at the same time to implement a pipeline.</span></span>|  
|[<span data-ttu-id="de012-157">Практическое руководство. Создание пула объектов с помощью класса ConcurrentBag</span><span class="sxs-lookup"><span data-stu-id="de012-157">How to: Create an Object Pool by Using a ConcurrentBag</span></span>](how-to-create-an-object-pool.md)|<span data-ttu-id="de012-158">Показано, как применить параллельный контейнер для повышения производительности в сценариях, где можно повторно использовать объекты вместо постоянного создания новых.</span><span class="sxs-lookup"><span data-stu-id="de012-158">Shows how to use a concurrent bag to improve performance in scenarios where you can reuse objects instead of continually creating new ones.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="de012-159">Справочник</span><span class="sxs-lookup"><span data-stu-id="de012-159">Reference</span></span>  
 <xref:System.Collections.Concurrent?displayProperty=nameWithType>
