---
title: Преимущества использования потокобезопасных коллекций
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- thread-safe collections, when to upgrade
ms.assetid: a9babe97-e457-4ff3-b528-a1bc940d5320
ms.openlocfilehash: 5a0abef6de9f932f44fc7e3239b98c3a27846580
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2020
ms.locfileid: "75711224"
---
# <a name="when-to-use-a-thread-safe-collection"></a><span data-ttu-id="d4c42-102">Преимущества использования потокобезопасных коллекций</span><span class="sxs-lookup"><span data-stu-id="d4c42-102">When to Use a Thread-Safe Collection</span></span>
<span data-ttu-id="d4c42-103">В .NET Framework 4 представлено пять новых типов коллекций, специально разработанных для поддержки многопотоковых операций добавления и удаления.</span><span class="sxs-lookup"><span data-stu-id="d4c42-103">The .NET Framework 4 introduces five new collection types that are specially designed to support multi-threaded add and remove operations.</span></span> <span data-ttu-id="d4c42-104">Для достижения потокобезопасности эти новые типы используют различные типы эффективных механизмов синхронизации с блокировкой и без блокировки.</span><span class="sxs-lookup"><span data-stu-id="d4c42-104">To achieve thread-safety, these new types use various kinds of efficient locking and lock-free synchronization mechanisms.</span></span> <span data-ttu-id="d4c42-105">Синхронизация добавляет к операции издержки.</span><span class="sxs-lookup"><span data-stu-id="d4c42-105">Synchronization adds overhead to an operation.</span></span> <span data-ttu-id="d4c42-106">Значения издержек зависят от используемого типа синхронизации, выполняемого типа операции и других факторов, например количества потоков, которые одновременно пытаются получить доступ к коллекции.</span><span class="sxs-lookup"><span data-stu-id="d4c42-106">The amount of overhead depends on the kind of synchronization that is used, the kind of operations that are performed, and other factors such as the number of threads that are trying to concurrently access the collection.</span></span>  
  
 <span data-ttu-id="d4c42-107">В некоторых сценариях издержки синхронизации незначительны и позволяют многопотоковым вариантам выполняться значительно быстрее и обеспечивают лучшую масштабируемость, чем в случае потоконебезопасного эквивалента при защите с помощью внешней блокировки.</span><span class="sxs-lookup"><span data-stu-id="d4c42-107">In some scenarios, synchronization overhead is negligible and enables the multi-threaded type to perform significantly faster and scale far better than its non-thread-safe equivalent when protected by an external lock.</span></span> <span data-ttu-id="d4c42-108">В других сценариях издержки могут вызвать ситуацию, когда потокобезопасный вариант выполняется и масштабируется примерно так же и даже более медленно, чем потоконебезопасная версия типа с внешней блокировкой.</span><span class="sxs-lookup"><span data-stu-id="d4c42-108">In other scenarios, the overhead can cause the thread-safe type to perform and scale about the same or even more slowly than the externally-locked, non-thread-safe version of the type.</span></span>  
  
 <span data-ttu-id="d4c42-109">В следующих подразделах приводятся общие рекомендации по использованию потокобезопасной коллекции и потоконебезопасного эквивалента, который содержит заданную пользователем блокировку для операций чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="d4c42-109">The following sections provide general guidance about when to use a thread-safe collection versus its non-thread-safe equivalent that has a user-provided lock around its read and write operations.</span></span> <span data-ttu-id="d4c42-110">Так как производительность может зависеть от множества факторов, рекомендации нехарактерны и необязательно являются допустимыми во всех обстоятельствах.</span><span class="sxs-lookup"><span data-stu-id="d4c42-110">Because performance may vary depending on many factors, the guidance is not specific and is not necessarily valid in all circumstances.</span></span> <span data-ttu-id="d4c42-111">Если производительность имеет важное значение, то лучшим способом для определения используемого типа коллекции является измерение производительности на основе обычной конфигурации компьютера и нагрузке.</span><span class="sxs-lookup"><span data-stu-id="d4c42-111">If performance is very important, then the best way to determine which collection type to use is to measure performance based on representative computer configurations and loads.</span></span> <span data-ttu-id="d4c42-112">В данном документе используются следующие термины.</span><span class="sxs-lookup"><span data-stu-id="d4c42-112">This document uses the following terms:</span></span>  
  
 <span data-ttu-id="d4c42-113">*Чистый сценарий "производитель — потребитель"*</span><span class="sxs-lookup"><span data-stu-id="d4c42-113">*Pure producer-consumer scenario*</span></span>  
 <span data-ttu-id="d4c42-114">Все заданные потоки либо добавляют элементы, либо удаляют их, но не то и другое одновременно.</span><span class="sxs-lookup"><span data-stu-id="d4c42-114">Any given thread is either adding or removing elements, but not both.</span></span>  
  
 <span data-ttu-id="d4c42-115">*Смешанный сценарий "производитель — потребитель"*</span><span class="sxs-lookup"><span data-stu-id="d4c42-115">*Mixed producer-consumer scenario*</span></span>  
 <span data-ttu-id="d4c42-116">Все заданные потоки как добавляют элементы, так и удаляют их.</span><span class="sxs-lookup"><span data-stu-id="d4c42-116">Any given thread is both adding and removing elements.</span></span>  
  
 <span data-ttu-id="d4c42-117">*Ускорение*</span><span class="sxs-lookup"><span data-stu-id="d4c42-117">*Speedup*</span></span>  
 <span data-ttu-id="d4c42-118">Ускорение производительности алгоритма одного типа относительно другого типа в рамках одного сценария.</span><span class="sxs-lookup"><span data-stu-id="d4c42-118">Faster algorithmic performance relative to another type in the same scenario.</span></span>  
  
 <span data-ttu-id="d4c42-119">*Масштабируемость*</span><span class="sxs-lookup"><span data-stu-id="d4c42-119">*Scalability*</span></span>  
 <span data-ttu-id="d4c42-120">Увеличение в производительности, которое пропорционально числу ядер в компьютере.</span><span class="sxs-lookup"><span data-stu-id="d4c42-120">The increase in performance that is proportional to the number of cores on the computer.</span></span> <span data-ttu-id="d4c42-121">Масштабируемый алгоритм выполняется быстрее на компьютере, у которого восемь ядер, чем на компьютере, у которого два ядра.</span><span class="sxs-lookup"><span data-stu-id="d4c42-121">An algorithm that scales performs faster on eight cores than it does on two cores.</span></span>  
  
## <a name="concurrentqueuet-vs-queuet"></a><span data-ttu-id="d4c42-122">ConcurrentQueue(T) и Queue(T)</span><span class="sxs-lookup"><span data-stu-id="d4c42-122">ConcurrentQueue(T) vs. Queue(T)</span></span>  
 <span data-ttu-id="d4c42-123">В чистых сценариях "производитель-получатель", когда время обработки каждого элемента очень мало (несколько инструкций), класс <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> может дать незначительный рост производительности по сравнению с классом <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType>, который использует внешнюю блокировку.</span><span class="sxs-lookup"><span data-stu-id="d4c42-123">In pure producer-consumer scenarios, where the processing time for each element is very small (a few instructions), then <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> can offer modest performance benefits over a <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> that has an external lock.</span></span> <span data-ttu-id="d4c42-124">В этом сценарии класс <xref:System.Collections.Concurrent.ConcurrentQueue%601> выполняется лучше, когда один выделенный поток помещается в очередь, а другой выделенный поток удаляется из очереди.</span><span class="sxs-lookup"><span data-stu-id="d4c42-124">In this scenario, <xref:System.Collections.Concurrent.ConcurrentQueue%601> performs best when one dedicated thread is queuing and one dedicated thread is de-queuing.</span></span> <span data-ttu-id="d4c42-125">Если это правило не применяется, класс <xref:System.Collections.Generic.Queue%601> может даже выполняться немного быстрее, чем класс <xref:System.Collections.Concurrent.ConcurrentQueue%601> на компьютерах с многоядерными процессорами.</span><span class="sxs-lookup"><span data-stu-id="d4c42-125">If you do not enforce this rule, then <xref:System.Collections.Generic.Queue%601> might even perform slightly faster than <xref:System.Collections.Concurrent.ConcurrentQueue%601> on computers that have multiple cores.</span></span>  
  
 <span data-ttu-id="d4c42-126">Когда время обработки составляет 500 FLOPS (операций с плавающей запятой) или больше, то правило двух потоков не применяется к классу <xref:System.Collections.Concurrent.ConcurrentQueue%601>, который имеет очень хорошую масштабируемость.</span><span class="sxs-lookup"><span data-stu-id="d4c42-126">When processing time is around 500 FLOPS (floating point operations) or more, then the two-thread rule does not apply to <xref:System.Collections.Concurrent.ConcurrentQueue%601>, which then has very good scalability.</span></span> <span data-ttu-id="d4c42-127"><xref:System.Collections.Generic.Queue%601> в этой ситуации не обладает хорошей масштабируемостью.</span><span class="sxs-lookup"><span data-stu-id="d4c42-127"><xref:System.Collections.Generic.Queue%601> does not scale well in this scenario.</span></span>  
  
 <span data-ttu-id="d4c42-128">В смешанных сценариях "производитель-получатель", когда время обработки очень мало, класс <xref:System.Collections.Generic.Queue%601>, который имеет внешнюю блокировку, масштабируется лучше, чем класс<xref:System.Collections.Concurrent.ConcurrentQueue%601>.</span><span class="sxs-lookup"><span data-stu-id="d4c42-128">In mixed producer-consumer scenarios, when the processing time is very small, a <xref:System.Collections.Generic.Queue%601> that has an external lock scales better than <xref:System.Collections.Concurrent.ConcurrentQueue%601> does.</span></span> <span data-ttu-id="d4c42-129">Однако, если время обработки имеет значение приблизительно равное 500 FLOPS и выше, то класс <xref:System.Collections.Concurrent.ConcurrentQueue%601> масштабируется лучше.</span><span class="sxs-lookup"><span data-stu-id="d4c42-129">However, when processing time is around 500 FLOPS or more, then the <xref:System.Collections.Concurrent.ConcurrentQueue%601> scales better.</span></span>  
  
## <a name="concurrentstack-vs-stack"></a><span data-ttu-id="d4c42-130">ConcurrentStack и Стек</span><span class="sxs-lookup"><span data-stu-id="d4c42-130">ConcurrentStack vs. Stack</span></span>  
 <span data-ttu-id="d4c42-131">В чистых сценариях "производитель-получатель", когда время обработки каждого элемента очень мало, класс <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> и класс <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType>, который использует внешнюю блокировку, обычно выполняются с одинаковой скоростью при одном выделенном потоке на добавление и одном выделенном потоке на извлечение.</span><span class="sxs-lookup"><span data-stu-id="d4c42-131">In pure producer-consumer scenarios, when processing time is very small, then <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> and <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> that has an external lock will probably perform about the same with one dedicated pushing thread and one dedicated popping thread.</span></span> <span data-ttu-id="d4c42-132">Однако по мере увеличения числа потоков производительность снижается у обоих типов, так как увеличивается число конфликтных ситуаций, и класс <xref:System.Collections.Generic.Stack%601> может выполняться лучше, чем класс <xref:System.Collections.Concurrent.ConcurrentStack%601>.</span><span class="sxs-lookup"><span data-stu-id="d4c42-132">However, as the number of threads increases, both types slow down because of increased contention, and <xref:System.Collections.Generic.Stack%601> might perform better than <xref:System.Collections.Concurrent.ConcurrentStack%601>.</span></span> <span data-ttu-id="d4c42-133">Если время обработки имеет значение приблизительно равное 500 FLOPS и выше, то оба типа масштабируются примерно одинаково.</span><span class="sxs-lookup"><span data-stu-id="d4c42-133">When processing time is around 500 FLOPS or more, then both types scale at about the same rate.</span></span>  
  
 <span data-ttu-id="d4c42-134">В смешанных сценариях "производитель-получатель" класс <xref:System.Collections.Concurrent.ConcurrentStack%601> имеет большее ускорение для небольших и больших рабочих нагрузок.</span><span class="sxs-lookup"><span data-stu-id="d4c42-134">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentStack%601> is faster for both small and large workloads.</span></span>  
  
 <span data-ttu-id="d4c42-135">Использование методов <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> и <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> может значительно снизить время доступа.</span><span class="sxs-lookup"><span data-stu-id="d4c42-135">The use of the <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> and <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> may greatly speed up access times.</span></span>  
  
## <a name="concurrentdictionary-vs-dictionary"></a><span data-ttu-id="d4c42-136">ConcurrentDictionary и Словарь</span><span class="sxs-lookup"><span data-stu-id="d4c42-136">ConcurrentDictionary vs. Dictionary</span></span>  
 <span data-ttu-id="d4c42-137">Как правило, лучше использовать класс <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> в любой ситуации, когда вы одновременно добавляете и обновляете ключи или значения из множества потоков.</span><span class="sxs-lookup"><span data-stu-id="d4c42-137">In general, use a <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> in any scenario where you are adding and updating keys or values concurrently from multiple threads.</span></span> <span data-ttu-id="d4c42-138">В сценариях, которые включают частные операции обновления и относительно редкие операции чтения, класс <xref:System.Collections.Concurrent.ConcurrentDictionary%602>, в общем случае, обеспечивает немного лучшую производительность.</span><span class="sxs-lookup"><span data-stu-id="d4c42-138">In scenarios that involve frequent updates and relatively few reads, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally offers modest benefits.</span></span> <span data-ttu-id="d4c42-139">В сценариях, которые включают частные операции чтения и относительно редкие операции обновления, класс <xref:System.Collections.Concurrent.ConcurrentDictionary%602>, в общем случае, имеет значительно большее ускорение на компьютерах с многоядерными процессорами.</span><span class="sxs-lookup"><span data-stu-id="d4c42-139">In scenarios that involve many reads and many updates, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally is significantly faster on computers that have any number of cores.</span></span>  
  
 <span data-ttu-id="d4c42-140">В сценариях, которые включают частые обновления, можно увеличить степень параллелизма в классе <xref:System.Collections.Concurrent.ConcurrentDictionary%602> и затем провести оценку, чтобы увидеть, увеличилась ли производительность на компьютерах с многоядерными процессорами.</span><span class="sxs-lookup"><span data-stu-id="d4c42-140">In scenarios that involve frequent updates, you can increase the degree of concurrency in the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> and then measure to see whether performance increases on computers that have more cores.</span></span> <span data-ttu-id="d4c42-141">При изменении уровня параллелизма исключите, насколько это возможно, глобальные операции.</span><span class="sxs-lookup"><span data-stu-id="d4c42-141">If you change the concurrency level, avoid global operations as much as possible.</span></span>  
  
 <span data-ttu-id="d4c42-142">Если выполняются только операции чтения ключа или значений, класс <xref:System.Collections.Generic.Dictionary%602> работает быстрее, так как он не требует синхронизации, пока словарь не изменяется каким-либо потоком.</span><span class="sxs-lookup"><span data-stu-id="d4c42-142">If you are only reading key or values, the <xref:System.Collections.Generic.Dictionary%602> is faster because no synchronization is required if the dictionary is not being modified by any threads.</span></span>  
  
## <a name="concurrentbag"></a><span data-ttu-id="d4c42-143">ConcurrentBag</span><span class="sxs-lookup"><span data-stu-id="d4c42-143">ConcurrentBag</span></span>  
 <span data-ttu-id="d4c42-144">В чистых сценариях "производитель — получатель" класс <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> может выполняться более медленно, чем другие типы параллельных коллекций.</span><span class="sxs-lookup"><span data-stu-id="d4c42-144">In pure producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> will probably perform more slowly than the other concurrent collection types.</span></span>  
  
 <span data-ttu-id="d4c42-145">В смешанных сценариях "производитель-получатель" класс <xref:System.Collections.Concurrent.ConcurrentBag%601> в общем случае имеет большее ускорение и большую масштабируемость, чем все остальные типы параллельных коллекций для небольших и больших рабочих нагрузок.</span><span class="sxs-lookup"><span data-stu-id="d4c42-145">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601> is generally much faster and more scalable than any other concurrent collection type for both large and small workloads.</span></span>  
  
## <a name="blockingcollection"></a><span data-ttu-id="d4c42-146">BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="d4c42-146">BlockingCollection</span></span>  
 <span data-ttu-id="d4c42-147">Если вы хотите использовать семантику границ и блокировок, класс <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> может работать быстрее, чем любые пользовательские реализации.</span><span class="sxs-lookup"><span data-stu-id="d4c42-147">When bounding and blocking semantics are required, <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> will probably perform faster than any custom implementation.</span></span> <span data-ttu-id="d4c42-148">Он также поддерживает гибкую обработку исключений и операций отмены, перечисления.</span><span class="sxs-lookup"><span data-stu-id="d4c42-148">It also supports rich cancellation, enumeration, and exception handling.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d4c42-149">См. также</span><span class="sxs-lookup"><span data-stu-id="d4c42-149">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="d4c42-150">Потокобезопасные коллекции</span><span class="sxs-lookup"><span data-stu-id="d4c42-150">Thread-Safe Collections</span></span>](../../../../docs/standard/collections/thread-safe/index.md)
- [<span data-ttu-id="d4c42-151">Параллельное программирование</span><span class="sxs-lookup"><span data-stu-id="d4c42-151">Parallel Programming</span></span>](../../../../docs/standard/parallel-programming/index.md)
