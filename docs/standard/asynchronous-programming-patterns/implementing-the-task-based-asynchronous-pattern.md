---
title: Реализация асинхронного шаблона, основанного на задачах
ms.date: 06/14/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework, and TAP
- asynchronous design patterns, .NET Framework
- TAP, .NET Framework support for
- Task-based Asynchronous Pattern, .NET Framework support for
- .NET Framework, asynchronous design patterns
ms.assetid: fab6bd41-91bd-44ad-86f9-d8319988aa78
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 670cdb369920663ffa62e224bdd5aa495fc7e622
ms.sourcegitcommit: 4735bb7741555bcb870d7b42964d3774f4897a6e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/30/2019
ms.locfileid: "66377701"
---
# <a name="implementing-the-task-based-asynchronous-pattern"></a><span data-ttu-id="dfcee-102">Реализация асинхронного шаблона, основанного на задачах</span><span class="sxs-lookup"><span data-stu-id="dfcee-102">Implementing the Task-based Asynchronous Pattern</span></span>
<span data-ttu-id="dfcee-103">Можно реализовать асинхронную модель на основе задач (TAP) тремя способами: с помощью компиляторов C# и Visual Basic в Visual Studio, вручную или путем сочетания этих методов.</span><span class="sxs-lookup"><span data-stu-id="dfcee-103">You can implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span> <span data-ttu-id="dfcee-104">Каждый метод подробно обсуждается в следующих разделах.</span><span class="sxs-lookup"><span data-stu-id="dfcee-104">The following sections discuss each method in detail.</span></span> <span data-ttu-id="dfcee-105">Модель TAP можно применять для создания асинхронных операций, связанных с операциями ввода-вывода и ограниченных по скорости вычислений.</span><span class="sxs-lookup"><span data-stu-id="dfcee-105">You can use the TAP pattern to implement both compute-bound and I/O-bound asynchronous operations.</span></span> <span data-ttu-id="dfcee-106">В разделе [Рабочие нагрузки](#workloads) рассматриваются операции каждого типа.</span><span class="sxs-lookup"><span data-stu-id="dfcee-106">The [Workloads](#workloads) section discusses each type of operation.</span></span>

## <a name="generating-tap-methods"></a><span data-ttu-id="dfcee-107">Создание методов TAP</span><span class="sxs-lookup"><span data-stu-id="dfcee-107">Generating TAP methods</span></span>

### <a name="using-the-compilers"></a><span data-ttu-id="dfcee-108">С помощью компиляторов</span><span class="sxs-lookup"><span data-stu-id="dfcee-108">Using the compilers</span></span>
<span data-ttu-id="dfcee-109">Начиная с версии .NET Framework 4.5 любой метод, который помечен ключевым словом `async` (`Async` в Visual Basic), считается асинхронным, и компиляторы C# и Visual Basic применяют к нему преобразования, необходимые для асинхронной реализации метода по модели TAP.</span><span class="sxs-lookup"><span data-stu-id="dfcee-109">Starting with .NET Framework 4.5, any method that is attributed with the `async` keyword (`Async` in Visual Basic) is considered an asynchronous method, and the C# and Visual Basic compilers perform the necessary transformations to implement the method asynchronously by using TAP.</span></span> <span data-ttu-id="dfcee-110">Асинхронный метод должен возвращать объект  <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> или <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dfcee-110">An asynchronous method should return either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="dfcee-111">Во втором случае функция должна возвращать `TResult`, а компилятор обеспечивает доступность этого результата через создаваемый объект задачи.</span><span class="sxs-lookup"><span data-stu-id="dfcee-111">For the latter, the body of the function should return a `TResult`, and the compiler ensures that this result is made available through the resulting task object.</span></span> <span data-ttu-id="dfcee-112">Аналогичным образом любые исключения, которые не обрабатываться в теле метода маршалируются в выходную задачу и вызывают окончание результирующей задачи в состоянии <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dfcee-112">Similarly, any exceptions that go unhandled within the body of the method are marshaled to the output task and cause the resulting task to end in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state.</span></span> <span data-ttu-id="dfcee-113">Исключение возникает, когда <xref:System.OperationCanceledException> (или производный тип) остаются необработанными. В этом случае результирующая задача заканчивается в состоянии <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dfcee-113">The exception is when an <xref:System.OperationCanceledException> (or derived type) goes unhandled, in which case the resulting task ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state.</span></span>

### <a name="generating-tap-methods-manually"></a><span data-ttu-id="dfcee-114">Создание методов TAP вручную</span><span class="sxs-lookup"><span data-stu-id="dfcee-114">Generating TAP methods manually</span></span>
<span data-ttu-id="dfcee-115">Можно реализовать шаблон TAP для улучшения контроля над реализацией вручную.</span><span class="sxs-lookup"><span data-stu-id="dfcee-115">You may implement the TAP pattern manually for better control over implementation.</span></span> <span data-ttu-id="dfcee-116">Компилятор использует общую контактную зону, предоставленную из пространства имен <xref:System.Threading.Tasks?displayProperty=nameWithType>, и вспомогательные типы в пространстве имен <xref:System.Runtime.CompilerServices?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dfcee-116">The compiler relies on the public surface area exposed from the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace and supporting types in the <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="dfcee-117">Чтобы реализовать шаблон TAP самостоятельно, необходимо создать объект <xref:System.Threading.Tasks.TaskCompletionSource%601>, выполнить асинхронную операцию и после ее завершения вызвать метод <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A> или <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>, или версии одного из этих методов `Try`.</span><span class="sxs-lookup"><span data-stu-id="dfcee-117">To implement the TAP yourself, you create a <xref:System.Threading.Tasks.TaskCompletionSource%601> object, perform the asynchronous operation, and when it completes, call the <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, or <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> method, or the `Try` version of one of these methods.</span></span> <span data-ttu-id="dfcee-118">При реализации метода TAP вручную необходимо выполнить результирующую задачу после завершения представленной асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="dfcee-118">When you implement a TAP method manually, you must complete the resulting task when the represented asynchronous operation completes.</span></span> <span data-ttu-id="dfcee-119">Например:</span><span class="sxs-lookup"><span data-stu-id="dfcee-119">For example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#1)]
[!code-vb[Conceptual.TAP_Patterns#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#1)]

### <a name="hybrid-approach"></a><span data-ttu-id="dfcee-120">Гибридный подход</span><span class="sxs-lookup"><span data-stu-id="dfcee-120">Hybrid approach</span></span>
 <span data-ttu-id="dfcee-121">Может оказаться полезным реализовать шаблон TAР вручную, но делегировать основную логику для реализации компилятору.</span><span class="sxs-lookup"><span data-stu-id="dfcee-121">You may find it useful to implement the TAP pattern manually but to delegate the core logic for the implementation to the compiler.</span></span> <span data-ttu-id="dfcee-122">Например, может использовать гибридный подход, когда требуется проверить аргументы за пределами асинхронного метода, созданного компилятором, для того, чтобы исключения могли переходить к непосредственному вызывающему объекту метода, а не предоставлялись через объект <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="dfcee-122">For example, you may want to use the hybrid approach when you want to verify arguments outside a compiler-generated asynchronous method so that exceptions can escape to the method’s direct caller rather than being exposed through the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object:</span></span>

 [!code-csharp[Conceptual.TAP_Patterns#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#2)]
 [!code-vb[Conceptual.TAP_Patterns#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#2)]

 <span data-ttu-id="dfcee-123">Другой случай, когда такое делегирование полезно, связан с реализацией оптимизации быстрого перехода при необходимости вернуть кэшированную задачу.</span><span class="sxs-lookup"><span data-stu-id="dfcee-123">Another case where such delegation is useful is when you're implementing fast-path optimization and want to return a cached task.</span></span>

## <a name="workloads"></a><span data-ttu-id="dfcee-124">Рабочие нагрузки</span><span class="sxs-lookup"><span data-stu-id="dfcee-124">Workloads</span></span>
<span data-ttu-id="dfcee-125">Реализацию асинхронных операций, связанных с вводом-выводом и ограниченных по скорости вычислений, можно выполнить как методы TAP.</span><span class="sxs-lookup"><span data-stu-id="dfcee-125">You may implement both compute-bound and I/O-bound asynchronous operations as TAP methods.</span></span> <span data-ttu-id="dfcee-126">Тем не менее, когда методы TAP предоставляются открыто из библиотеки, они должны быть предоставлены только для рабочих нагрузок, связанных с операциями ввода-вывода (они также могут включать в себя вычисления, но не должны быть исключительно вычислительными).</span><span class="sxs-lookup"><span data-stu-id="dfcee-126">However, when TAP methods are exposed publicly from a library, they should be provided only for workloads that involve I/O-bound operations (they may also involve computation, but should not be purely computational).</span></span> <span data-ttu-id="dfcee-127">Если метод ограничен только по скорости вычислений, его следует предоставлять только в синхронной реализации.</span><span class="sxs-lookup"><span data-stu-id="dfcee-127">If a method is purely compute-bound, it should be exposed only as a synchronous implementation.</span></span> <span data-ttu-id="dfcee-128">При использовании этого метода в коде можно заключить вызов этого синхронного метода в отдельную задачу, чтобы передать часть задач в другой поток или выполнять их параллельно.</span><span class="sxs-lookup"><span data-stu-id="dfcee-128">The code that consumes it may then choose whether to wrap an invocation of that synchronous method into a task to offload the work to another thread or to achieve parallelism.</span></span> <span data-ttu-id="dfcee-129">Если метод имеет привязку к операциям ввода-вывода, его следует предоставлять только в асинхронной реализации.</span><span class="sxs-lookup"><span data-stu-id="dfcee-129">And if a method is I/O-bound, it should be exposed only as an asynchronous implementation.</span></span>

### <a name="compute-bound-tasks"></a><span data-ttu-id="dfcee-130">Задачи, ограниченные по скорости вычислений</span><span class="sxs-lookup"><span data-stu-id="dfcee-130">Compute-bound tasks</span></span>
<span data-ttu-id="dfcee-131">Класс <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> идеально подходит для представления ресурсоемких вычислительных операций.</span><span class="sxs-lookup"><span data-stu-id="dfcee-131">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class is ideally suited for representing computationally intensive operations.</span></span> <span data-ttu-id="dfcee-132">По умолчанию он использует специальную поддержку в классе <xref:System.Threading.ThreadPool>, чтобы обеспечить эффективное выполнение, а также обеспечивает значительный контроль над тем, когда, где и как выполнять асинхронные вычисления.</span><span class="sxs-lookup"><span data-stu-id="dfcee-132">By default, it takes advantage of special support within the <xref:System.Threading.ThreadPool> class to provide efficient execution, and it also provides significant control over when, where, and how asynchronous computations execute.</span></span>

<span data-ttu-id="dfcee-133">Задачи ограниченных по скорости вычислений можно создать одним из следующих способов:</span><span class="sxs-lookup"><span data-stu-id="dfcee-133">You can generate compute-bound tasks in the following ways:</span></span>

- <span data-ttu-id="dfcee-134">В платформе .NET Framework 4 используйте метод <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>, который принимает делегат (обыкновенно <xref:System.Action%601> или <xref:System.Func%601>) для асинхронного выполнения.</span><span class="sxs-lookup"><span data-stu-id="dfcee-134">In the .NET Framework 4, use the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, which accepts a delegate (typically an <xref:System.Action%601> or a <xref:System.Func%601>) to be executed asynchronously.</span></span> <span data-ttu-id="dfcee-135">Если предоставить делегат <xref:System.Action%601>, этот метод возвращает объект <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>, представляющий асинхронное выполнение этого делегата.</span><span class="sxs-lookup"><span data-stu-id="dfcee-135">If you provide an <xref:System.Action%601> delegate, the method returns a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object that represents the asynchronous execution of that delegate.</span></span> <span data-ttu-id="dfcee-136">Если предоставить делегат <xref:System.Func%601>, этот метод возвращает объект <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dfcee-136">If you provide a <xref:System.Func%601> delegate, the method returns a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="dfcee-137">Перегрузки метода <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> принимают маркер отмены (<xref:System.Threading.CancellationToken>), параметры создания задач (<xref:System.Threading.Tasks.TaskCreationOptions>) и планировщик заданий (<xref:System.Threading.Tasks.TaskScheduler>), которые обеспечивают точное управление планированием и выполнением задачи.</span><span class="sxs-lookup"><span data-stu-id="dfcee-137">Overloads of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method accept a cancellation token (<xref:System.Threading.CancellationToken>), task creation options (<xref:System.Threading.Tasks.TaskCreationOptions>), and a task scheduler (<xref:System.Threading.Tasks.TaskScheduler>), all of which provide fine-grained control over the scheduling and execution of the task.</span></span> <span data-ttu-id="dfcee-138">Экземпляр фабрики, предназначенный для текущего планировщика задач доступен как статическое свойство (<xref:System.Threading.Tasks.Task.Factory%2A>) из класса <xref:System.Threading.Tasks.Task>; Например: `Task.Factory.StartNew(…)`.</span><span class="sxs-lookup"><span data-stu-id="dfcee-138">A factory instance that targets the current task scheduler is available as a static property (<xref:System.Threading.Tasks.Task.Factory%2A>) of the <xref:System.Threading.Tasks.Task> class; for example: `Task.Factory.StartNew(…)`.</span></span>

- <span data-ttu-id="dfcee-139">В .NET Framework 4.5 и более поздних версиях (включая .NET Core и .NET Standard) используйте статический метод <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> в качестве псевдонима для <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dfcee-139">In the .NET Framework 4.5 and later versions (including .NET Core and .NET Standard), use the static <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method as a shortcut to <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="dfcee-140">Вы можете использовать <xref:System.Threading.Tasks.Task.Run%2A> для простого запуска ограниченных по скорости вычислений задач, предназначенных для пула потоков.</span><span class="sxs-lookup"><span data-stu-id="dfcee-140">You may use <xref:System.Threading.Tasks.Task.Run%2A> to easily launch a compute-bound task that targets the thread pool.</span></span> <span data-ttu-id="dfcee-141">В .NET Framework 4.5 и более поздних версиях этот механизм является предпочтительным для запуска задачи, ограниченной по скорости вычислений.</span><span class="sxs-lookup"><span data-stu-id="dfcee-141">In the .NET Framework 4.5 and later versions, this is the preferred mechanism for launching a compute-bound task.</span></span> <span data-ttu-id="dfcee-142">Используйте `StartNew` непосредственно, только когда требуется более точный контроль над задачей.</span><span class="sxs-lookup"><span data-stu-id="dfcee-142">Use `StartNew` directly only when you want more fine-grained control over the task.</span></span>

- <span data-ttu-id="dfcee-143">Используйте конструкторы типа `Task` или метод `Start`, если требуется создать и запланировать задачу отдельно.</span><span class="sxs-lookup"><span data-stu-id="dfcee-143">Use the constructors of the `Task` type or the `Start` method if you want to generate and schedule the task separately.</span></span> <span data-ttu-id="dfcee-144">Открытые методы должны возвращать только задачи, которые уже были начаты.</span><span class="sxs-lookup"><span data-stu-id="dfcee-144">Public methods must only return tasks that have already been started.</span></span>

- <span data-ttu-id="dfcee-145">Можно использовать перегрузки метода <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dfcee-145">Use the overloads of the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="dfcee-146">Этот метод создает новую задачу, которая запланирована после завершения другой задачи.</span><span class="sxs-lookup"><span data-stu-id="dfcee-146">This method creates a new task that is scheduled when another task completes.</span></span> <span data-ttu-id="dfcee-147">Некоторые перегрузки <xref:System.Threading.Tasks.Task.ContinueWith%2A> принимают токен отмены, параметры продолжения и планировщик задач для улучшения контроля над планированием и выполнением задачи продолжения.</span><span class="sxs-lookup"><span data-stu-id="dfcee-147">Some of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> overloads accept a cancellation token, continuation options, and a task scheduler for better control over the scheduling and execution of the continuation task.</span></span>

- <span data-ttu-id="dfcee-148">Используйте методы <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> и <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dfcee-148">Use the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="dfcee-149">Эти методы создают новую задачу, которая планируется по завершении всех или какой-либо из предоставленного набора задач.</span><span class="sxs-lookup"><span data-stu-id="dfcee-149">These methods create a new task that is scheduled when all or any of a supplied set of tasks completes.</span></span> <span data-ttu-id="dfcee-150">Эти методы также предоставляют перегрузки для управления планированием и исполнением этих задач.</span><span class="sxs-lookup"><span data-stu-id="dfcee-150">These methods also provide overloads to control the scheduling and execution of these tasks.</span></span>

<span data-ttu-id="dfcee-151">В задачах, ограниченных по скорости вычислений, система может предотвратить выполнение запланированной задачи при получении запроса отмены до запуска задачи.</span><span class="sxs-lookup"><span data-stu-id="dfcee-151">In compute-bound tasks, the system can prevent the execution of a scheduled task if it receives a cancellation request before it starts running the task.</span></span> <span data-ttu-id="dfcee-152">Таким образом, если предоставить токен отмены (объект<xref:System.Threading.CancellationToken>), можно передать его асинхронному коду, который следит за токеном.</span><span class="sxs-lookup"><span data-stu-id="dfcee-152">As such, if you provide a cancellation token (<xref:System.Threading.CancellationToken> object), you can pass that token to the asynchronous code that monitors the token.</span></span> <span data-ttu-id="dfcee-153">Можно также предоставить токен для одного из вышеупомянутых методов таких, как `StartNew` или `Run` для того, чтобы среда выполнения , `Task` могла также осуществлять его мониторинг.</span><span class="sxs-lookup"><span data-stu-id="dfcee-153">You can also provide the token to one of the previously mentioned methods such as `StartNew` or `Run` so that the `Task` runtime may also monitor the token.</span></span>

<span data-ttu-id="dfcee-154">Например, рассмотрим асинхронный метод, который выводит изображение на экран.</span><span class="sxs-lookup"><span data-stu-id="dfcee-154">For example, consider an asynchronous method that renders an image.</span></span> <span data-ttu-id="dfcee-155">Тело задачи может выполнять опрос токена отмены для того, чтобы код мог завершиться раньше при получении запроса отмены во время отрисовки.</span><span class="sxs-lookup"><span data-stu-id="dfcee-155">The body of the task can poll the cancellation token so that the code may exit early if a cancellation request arrives during rendering.</span></span> <span data-ttu-id="dfcee-156">Кроме того, если перед началом отрисовки поступает запрос на отмену, можно запретить операцию визуализации:</span><span class="sxs-lookup"><span data-stu-id="dfcee-156">In addition, if the cancellation request arrives before rendering starts, you'll want to prevent the rendering operation:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#3)]
[!code-vb[Conceptual.TAP_Patterns#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#3)]

<span data-ttu-id="dfcee-157">Задача, ограниченная по скорости вычислений, завершается в состоянии <xref:System.Threading.Tasks.TaskStatus.Canceled>, если хотя бы одно из следующих условий верно:</span><span class="sxs-lookup"><span data-stu-id="dfcee-157">Compute-bound tasks end in a <xref:System.Threading.Tasks.TaskStatus.Canceled> state if at least one of the following conditions is true:</span></span>

- <span data-ttu-id="dfcee-158">запрос отмены поступает через объект <xref:System.Threading.CancellationToken>, который предоставляется как аргумент метода создания (например, `StartNew` или `Run`) до того, как задача переходит в состояние <xref:System.Threading.Tasks.TaskStatus.Running>.</span><span class="sxs-lookup"><span data-stu-id="dfcee-158">A cancellation request arrives through the <xref:System.Threading.CancellationToken> object, which is provided as an argument to the creation method (for example, `StartNew` or `Run`) before the task transitions to the <xref:System.Threading.Tasks.TaskStatus.Running> state.</span></span>

- <span data-ttu-id="dfcee-159">исключение <xref:System.OperationCanceledException> остается необработанным в теле такой задачи, исключение содержит тот же токен отмены <xref:System.Threading.CancellationToken>, который передается задаче, а токен указывает на наличие запроса отмены.</span><span class="sxs-lookup"><span data-stu-id="dfcee-159">An <xref:System.OperationCanceledException> exception goes unhandled within the body of such a task, that exception contains the same <xref:System.Threading.CancellationToken> that is passed to the task, and that token shows that cancellation is requested.</span></span>

<span data-ttu-id="dfcee-160">Если другое исключение останется необработанным в теле задачи, задача завершается в состояние <xref:System.Threading.Tasks.TaskStatus.Faulted>, и любые попытки ожидания для задачи или доступа к ее результату вызывает исключение.</span><span class="sxs-lookup"><span data-stu-id="dfcee-160">If another exception goes unhandled within the body of the task, the task ends in the <xref:System.Threading.Tasks.TaskStatus.Faulted> state, and any attempts to wait on the task or access its result causes an exception to be thrown.</span></span>

### <a name="io-bound-tasks"></a><span data-ttu-id="dfcee-161">Задачи с привязкой к операциям ввода-вывода</span><span class="sxs-lookup"><span data-stu-id="dfcee-161">I/O-bound tasks</span></span>
<span data-ttu-id="dfcee-162">Чтобы создать задачу, которое не должно непосредственно поддерживаться потоком во время всего его выполнения, используйте тип <xref:System.Threading.Tasks.TaskCompletionSource%601>.</span><span class="sxs-lookup"><span data-stu-id="dfcee-162">To create a task that should not be directly backed by a thread for the entirety of its execution, use the <xref:System.Threading.Tasks.TaskCompletionSource%601> type.</span></span> <span data-ttu-id="dfcee-163">Этот тип предоставляет свойство <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A>, которое возвращает связанный экземпляр <xref:System.Threading.Tasks.Task%601>.</span><span class="sxs-lookup"><span data-stu-id="dfcee-163">This type exposes a <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> property that returns an associated <xref:System.Threading.Tasks.Task%601> instance.</span></span> <span data-ttu-id="dfcee-164">Жизненный цикл этой задачи управляется методами <xref:System.Threading.Tasks.TaskCompletionSource%601>, такими как <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>, и их вариантами `TrySet`.</span><span class="sxs-lookup"><span data-stu-id="dfcee-164">The life cycle of this task is controlled by <xref:System.Threading.Tasks.TaskCompletionSource%601> methods such as <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>, and their `TrySet` variants.</span></span>

<span data-ttu-id="dfcee-165">Предположим, что вы хотите создать задачу, которая будет завершена после указанного периода времени.</span><span class="sxs-lookup"><span data-stu-id="dfcee-165">Let's say that you want to create a task that will complete after a specified period of time.</span></span> <span data-ttu-id="dfcee-166">Например, можно отложить выполнение в пользовательском интерфейсе.</span><span class="sxs-lookup"><span data-stu-id="dfcee-166">For example, you may want to delay an activity in the user interface.</span></span> <span data-ttu-id="dfcee-167">Класс <xref:System.Threading.Timer?displayProperty=nameWithType> обеспечивает возможность асинхронного вызова делегат после определенного периода времени, а используя <xref:System.Threading.Tasks.TaskCompletionSource%601>, можно установить начало <xref:System.Threading.Tasks.Task%601> на таймере, например:</span><span class="sxs-lookup"><span data-stu-id="dfcee-167">The <xref:System.Threading.Timer?displayProperty=nameWithType> class already provides the ability to asynchronously invoke a delegate after a specified period of time, and by using <xref:System.Threading.Tasks.TaskCompletionSource%601> you can put a <xref:System.Threading.Tasks.Task%601> front on the timer, for example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#4)]
[!code-vb[Conceptual.TAP_Patterns#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#4)]

<span data-ttu-id="dfcee-168">Начиная с .NET Framework 4.5 метод <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> предоставляется для этой цели, и можно использовать его внутри другого асинхронного метода, например для реализации асинхронного цикла опроса:</span><span class="sxs-lookup"><span data-stu-id="dfcee-168">Starting with the .NET Framework 4.5, the <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method is provided for this purpose, and you can use it inside another asynchronous method, for example, to implement an asynchronous polling loop:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#5)]
[!code-vb[Conceptual.TAP_Patterns#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#5)]

<span data-ttu-id="dfcee-169">Класс <xref:System.Threading.Tasks.TaskCompletionSource%601> не имеет неуниверсального эквивалента.</span><span class="sxs-lookup"><span data-stu-id="dfcee-169">The <xref:System.Threading.Tasks.TaskCompletionSource%601> class doesn't have a non-generic counterpart.</span></span> <span data-ttu-id="dfcee-170">Теме не менее, <xref:System.Threading.Tasks.Task%601> является производным от <xref:System.Threading.Tasks.Task> и это дает возможность использовать универсальный объект <xref:System.Threading.Tasks.TaskCompletionSource%601> для связанных с вводом-выводом методов, которые просто возвращают задачу.</span><span class="sxs-lookup"><span data-stu-id="dfcee-170">However, <xref:System.Threading.Tasks.Task%601> derives from <xref:System.Threading.Tasks.Task>, so you can use the generic <xref:System.Threading.Tasks.TaskCompletionSource%601> object for I/O-bound methods that simply return a task.</span></span> <span data-ttu-id="dfcee-171">Чтобы это сделать, можно использовать источник с фиктивным `TResult` (<xref:System.Boolean> — неплохой выбор по умолчанию, однако, если вас беспокоит пользователь <xref:System.Threading.Tasks.Task>, приводящие его к <xref:System.Threading.Tasks.Task%601>, можно вместо этого использовать частный тип `TResult`).</span><span class="sxs-lookup"><span data-stu-id="dfcee-171">To do this, you can use a source with a dummy `TResult` (<xref:System.Boolean> is a good default choice, but if you're concerned about the user of the <xref:System.Threading.Tasks.Task> downcasting it to a <xref:System.Threading.Tasks.Task%601>, you can use a private `TResult` type instead).</span></span> <span data-ttu-id="dfcee-172">Например, метод `Delay` в предыдущем примере возвращает текущее значение времени и конечного смещения (`Task<DateTimeOffset>`).</span><span class="sxs-lookup"><span data-stu-id="dfcee-172">For example, the `Delay` method in the previous example returns the current time along with the resulting offset (`Task<DateTimeOffset>`).</span></span> <span data-ttu-id="dfcee-173">Если значение результата не нужно, метод можно вместо этого построить следующим образом (Обратите внимание на изменение типа возвращаемого значения и изменения аргумент для <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>):</span><span class="sxs-lookup"><span data-stu-id="dfcee-173">If such a result value is unnecessary, the method could instead be coded as follows (note the change of return type and the change of argument to <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>):</span></span>

[!code-csharp[Conceptual.TAP_Patterns#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#6)]
[!code-vb[Conceptual.TAP_Patterns#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#6)]

### <a name="mixed-compute-bound-and-io-bound-tasks"></a><span data-ttu-id="dfcee-174">Смешанные задачи с привязкой к операциям ввода-вывода и ограниченные по скорости вычислений</span><span class="sxs-lookup"><span data-stu-id="dfcee-174">Mixed compute-bound and I/O-bound tasks</span></span>
<span data-ttu-id="dfcee-175">Асинхронные методы не ограничиваются только операциями, связанными с вводом-выводом или ограниченными по скорости вычислений, а могут представлять собой их комбинацию.</span><span class="sxs-lookup"><span data-stu-id="dfcee-175">Asynchronous methods are not limited to just compute-bound or I/O-bound operations but may represent a mixture of the two.</span></span> <span data-ttu-id="dfcee-176">На практике несколько асинхронных операций часто объединяются в большие по размеру смешанные операции.</span><span class="sxs-lookup"><span data-stu-id="dfcee-176">In fact, multiple asynchronous operations are often combined into larger mixed operations.</span></span> <span data-ttu-id="dfcee-177">Например, метод `RenderAsync` в предыдущем примере выполнил операцию с большим количеством вычислений, чтобы отобразить изображение, зависящее от некоторых входных данных `imageData`.</span><span class="sxs-lookup"><span data-stu-id="dfcee-177">For example, the `RenderAsync` method in a previous example performed a computationally intensive operation to render an image based on some input `imageData`.</span></span> <span data-ttu-id="dfcee-178">Это изображение `imageData` могло бы быть получено из веб-службы, к которой осуществляется асинхронный доступ:</span><span class="sxs-lookup"><span data-stu-id="dfcee-178">This `imageData` could come from a web service that you asynchronously access:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#7)]
[!code-vb[Conceptual.TAP_Patterns#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#7)]

<span data-ttu-id="dfcee-179">Этот пример также демонстрирует, как один токен отмены может направляться через несколько асинхронных операций.</span><span class="sxs-lookup"><span data-stu-id="dfcee-179">This example also demonstrates how a single cancellation token may be threaded through multiple asynchronous operations.</span></span> <span data-ttu-id="dfcee-180">Дополнительные сведения см. в разделе об отмене операции в статье [Использование асинхронного шаблона, основанного на задачах](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="dfcee-180">For more information, see the cancellation usage section in [Consuming the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="dfcee-181">См. также</span><span class="sxs-lookup"><span data-stu-id="dfcee-181">See also</span></span>

- <span data-ttu-id="dfcee-182">[Task-based Asynchronous Pattern (TAP)](../../../docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) (Асинхронный шаблон, основанный на задачах (TAP))</span><span class="sxs-lookup"><span data-stu-id="dfcee-182">[Task-based Asynchronous Pattern (TAP)](../../../docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)</span></span>
- [<span data-ttu-id="dfcee-183">Consuming the Task-based Asynchronous Pattern</span><span class="sxs-lookup"><span data-stu-id="dfcee-183">Consuming the Task-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)
- [<span data-ttu-id="dfcee-184">Взаимодействие с другими асинхронными шаблонами и типами</span><span class="sxs-lookup"><span data-stu-id="dfcee-184">Interop with Other Asynchronous Patterns and Types</span></span>](../../../docs/standard/asynchronous-programming-patterns/interop-with-other-asynchronous-patterns-and-types.md)
