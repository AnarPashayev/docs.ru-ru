---
title: Асинхронный шаблон, основанный на задачах (TAP)
ms.date: 02/26/2019
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework, and TAP
- asynchronous design patterns, .NET Framework
- TAP, .NET Framework support for
- Task-based Asynchronous Pattern, .NET Framework support for
- .NET Framework, asynchronous design patterns
ms.assetid: 8cef1fcf-6f9f-417c-b21f-3fd8bac75007
ms.openlocfilehash: 4a08c8a72116ea509f559e412c5f270f3471bf1c
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/02/2020
ms.locfileid: "84276443"
---
# <a name="task-based-asynchronous-pattern-tap"></a><span data-ttu-id="3f9fd-102">Асинхронный шаблон, основанный на задачах (TAP)</span><span class="sxs-lookup"><span data-stu-id="3f9fd-102">Task-based asynchronous pattern (TAP)</span></span>
<span data-ttu-id="3f9fd-103">Асинхронная модель на основе задач (TAP) основана на типах <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> и <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> пространства имен <xref:System.Threading.Tasks?displayProperty=nameWithType>, которые используются для представления произвольных асинхронных операций.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-103">The Task-based Asynchronous Pattern (TAP) is based on the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> types in the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace, which are used to represent arbitrary asynchronous operations.</span></span> <span data-ttu-id="3f9fd-104">TAP — это рекомендуемый асинхронный шаблон для разработки новых компонентов.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-104">TAP is the recommended asynchronous design pattern for new development.</span></span>  
  
## <a name="naming-parameters-and-return-types"></a><span data-ttu-id="3f9fd-105">Именование, параметры и возвращаемые типы</span><span class="sxs-lookup"><span data-stu-id="3f9fd-105">Naming, parameters, and return types</span></span>

<span data-ttu-id="3f9fd-106">TAP использует один метод для представления инициализации и завершения асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-106">TAP uses a single method to represent the initiation and completion of an asynchronous operation.</span></span> <span data-ttu-id="3f9fd-107">Это отличается от шаблона модели асинхронного программирования (APM или `IAsyncResult`) и асинхронного шаблона, основанного на событиях (EAP).</span><span class="sxs-lookup"><span data-stu-id="3f9fd-107">This contrasts with both the Asynchronous Programming Model (APM or `IAsyncResult`) pattern and the Event-based Asynchronous Pattern (EAP).</span></span> <span data-ttu-id="3f9fd-108">Для APM требуется метод `Begin` и `End`.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-108">APM requires `Begin` and `End` methods.</span></span> <span data-ttu-id="3f9fd-109">Для EAP требуется метод с суффиксом `Async`, а также одно или несколько событий, типов делегата обработчика событий и производные от `EventArg` типы.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-109">EAP requires a method that has the `Async` suffix and also requires one or more events, event handler delegate types, and `EventArg`-derived types.</span></span> <span data-ttu-id="3f9fd-110">В асинхронных методах TAP после имени операции используется суффикс `Async` — для методов, возвращающих типы с поддержкой ожидания, например <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.ValueTask> и <xref:System.Threading.Tasks.ValueTask%601>.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-110">Asynchronous methods in TAP include the `Async` suffix after the operation name for methods that return awaitable types, such as <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.ValueTask>, and <xref:System.Threading.Tasks.ValueTask%601>.</span></span> <span data-ttu-id="3f9fd-111">Синхронные операции `Get`, возвращающие `Task<String>`, могут называться `GetAsync`.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-111">For example, an asynchronous `Get` operation that returns a `Task<String>` can be named `GetAsync`.</span></span> <span data-ttu-id="3f9fd-112">Если вы добавляете к классу, который уже содержит имя метода EAP с суффиксом `Async`, метод TAP, используйте вместо него суффикс `TaskAsync`.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-112">If you're adding a TAP method to a class that already contains an EAP method name with the `Async` suffix, use the suffix `TaskAsync` instead.</span></span> <span data-ttu-id="3f9fd-113">Например, класс уже содержит метод `GetAsync`, используйте имя `GetTaskAsync`.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-113">For example, if the class already has a `GetAsync` method, use the name `GetTaskAsync`.</span></span> <span data-ttu-id="3f9fd-114">Если метод запускает асинхронную операцию, но не возвращает ожидаемый тип, его имя должно начинаться с `Begin`, `Start` или другого глагола, который указывает на то, что этот метод не возвращает или не выдает результат операции.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-114">If a method starts an asynchronous operation but does not return an awaitable type, its name should start with `Begin`, `Start`, or some other verb to suggest that this method does not return or throw the result of the operation.</span></span>  
  
 <span data-ttu-id="3f9fd-115">Метод TAP возвращает <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> или <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> в зависимости от того, возвращает ли соответствующий синхронный метод значение void или тип `TResult`.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-115">A TAP method returns either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, based on whether the corresponding synchronous method returns void or a type `TResult`.</span></span>  
  
 <span data-ttu-id="3f9fd-116">Параметры метода TAP должны соответствовать параметрам его синхронного аналога и предоставляться в том же порядке.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-116">The parameters of a TAP method should match the parameters of its synchronous counterpart and should be provided in the same order.</span></span>  <span data-ttu-id="3f9fd-117">Однако параметры `out` и `ref` исключены из этого правила, их следует избегать полностью.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-117">However, `out` and `ref` parameters are exempt from this rule and should be avoided entirely.</span></span> <span data-ttu-id="3f9fd-118">Все данные, которые были бы возвращены параметром `out` или `ref`, должны вместо этого возвращаться как часть результата `TResult`, возвращаемого <xref:System.Threading.Tasks.Task%601>, и должны использовать кортеж или пользовательскую структуру данных, чтобы вместить несколько значений.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-118">Any data that would have been returned through an `out` or `ref` parameter should instead be returned as part of the `TResult` returned by <xref:System.Threading.Tasks.Task%601>, and should use a tuple or a custom data structure to accommodate multiple values.</span></span> <span data-ttu-id="3f9fd-119">Попробуйте добавить параметр <xref:System.Threading.CancellationToken>, даже если в аналогичном синхронном методе TAP этот параметр не применяется.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-119">You should also consider adding a <xref:System.Threading.CancellationToken> parameter even if the TAP method's synchronous counterpart does not offer one.</span></span>

 <span data-ttu-id="3f9fd-120">К методам, которые предназначены исключительно для создания, обработки или сочетания задач (где асинхронная природа метода очевидна из имени метода или имени типа, к которому относится метод), эта схема именования не применяется. Такие методы часто называются *методами объединения*.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-120">Methods that are devoted exclusively to the creation, manipulation, or combination of tasks (where the asynchronous intent of the method is clear in the method name or in the name of the type to which the method belongs) need not follow this naming pattern; such methods are often referred to as *combinators*.</span></span> <span data-ttu-id="3f9fd-121">К таким методам относятся <xref:System.Threading.Tasks.Task.WhenAll%2A> и <xref:System.Threading.Tasks.Task.WhenAny%2A>, которые рассматриваются в разделе [Использование внутренних блоков объединения задач](consuming-the-task-based-asynchronous-pattern.md#combinators) статьи [Использование асинхронного шаблона, основанного на задачах](consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="3f9fd-121">Examples of combinators include <xref:System.Threading.Tasks.Task.WhenAll%2A> and <xref:System.Threading.Tasks.Task.WhenAny%2A>, and are discussed in the [Using the Built-in Task-based Combinators](consuming-the-task-based-asynchronous-pattern.md#combinators) section of the article [Consuming the Task-based Asynchronous Pattern](consuming-the-task-based-asynchronous-pattern.md).</span></span>  
  
 <span data-ttu-id="3f9fd-122">Примеры отличий синтаксиса TAP от синтаксиса, используемого в устаревших асинхронных моделях, таких как асинхронная модель программирования (APM) и асинхронная модель на основе событий (EAP), вы найдете в статье [Шаблоны асинхронного программирования](index.md).</span><span class="sxs-lookup"><span data-stu-id="3f9fd-122">For examples of how the TAP syntax differs from the syntax used in legacy asynchronous programming patterns such as the Asynchronous Programming Model (APM) and the Event-based Asynchronous Pattern (EAP), see [Asynchronous Programming Patterns](index.md).</span></span>  
  
## <a name="initiating-an-asynchronous-operation"></a><span data-ttu-id="3f9fd-123">Инициализация асинхронной операции</span><span class="sxs-lookup"><span data-stu-id="3f9fd-123">Initiating an asynchronous operation</span></span>  
 <span data-ttu-id="3f9fd-124">Асинхронный метод, основанный на TAP, может выполнить небольшой объем работы синхронно, например проверить аргументы и инициировать асинхронную операцию, прежде чем вернуть результирующую задачу.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-124">An asynchronous method that is based on TAP can do a small amount of work synchronously, such as validating arguments and initiating the asynchronous operation, before it returns the resulting task.</span></span> <span data-ttu-id="3f9fd-125">Синхронная работа должна быть сведена к минимуму, чтобы асинхронный метод мог быстро вернуть значение.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-125">Synchronous work should be kept to the minimum so the asynchronous method can return quickly.</span></span> <span data-ttu-id="3f9fd-126">Причины быстрого возвращения указаны ниже.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-126">Reasons for a quick return include the following:</span></span>  
  
- <span data-ttu-id="3f9fd-127">Асинхронные методы могут вызываться из потоков пользовательского интерфейса, и любые продолжительные синхронные задачи могут негативно сказаться на скорости реагирования приложения.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-127">Asynchronous methods may be invoked from user interface (UI) threads, and any long-running synchronous work could harm the responsiveness of the application.</span></span>  
  
- <span data-ttu-id="3f9fd-128">Одновременно можно запускать несколько асинхронных методов.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-128">Multiple asynchronous methods may be launched concurrently.</span></span> <span data-ttu-id="3f9fd-129">Таким образом, любые длительные синхронные фрагменты асинхронного метода могут отложить запуск других асинхронных операций, тем самым сводя к минимуму преимущества параллельности.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-129">Therefore, any long-running work in the synchronous portion of an asynchronous method could delay the initiation of other asynchronous operations, thereby decreasing the benefits of concurrency.</span></span>  
  
 <span data-ttu-id="3f9fd-130">В некоторых случаях объем работы, необходимый для выполнения операции, меньше объема работы, необходимого для асинхронного запуска операции.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-130">In some cases, the amount of work required to complete the operation is less than the amount of work required to launch the operation asynchronously.</span></span> <span data-ttu-id="3f9fd-131">Примером такой ситуации является чтение из потока, в котором операция чтения может быть выполнена с использованием данных, которые уже сохранены в памяти.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-131">Reading from a stream where the read operation can be satisfied by data that is already buffered in memory is an example of such a scenario.</span></span> <span data-ttu-id="3f9fd-132">В таких случаях операция может выполняться синхронно и может возвращать задачу, которая уже была завершена.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-132">In such cases, the operation may complete synchronously, and may return a task that has already been completed.</span></span>  
  
## <a name="exceptions"></a><span data-ttu-id="3f9fd-133">Исключения</span><span class="sxs-lookup"><span data-stu-id="3f9fd-133">Exceptions</span></span>  
 <span data-ttu-id="3f9fd-134">Асинхронный метод должен вызывать исключение, которое должно создаваться вызовом асинхронного метода только в ответ на ошибку использования.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-134">An asynchronous method should raise an exception to be thrown out of the asynchronous method call only in response to a usage error.</span></span> <span data-ttu-id="3f9fd-135">Ошибки использования никогда не должны происходить в рабочем коде.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-135">Usage errors should never occur in production code.</span></span> <span data-ttu-id="3f9fd-136">Например, если передача пустой ссылки (`Nothing` в Visual Basic) в виде одного из аргументов метода вызывает ошибочное состояние (как правило, представляется исключением <xref:System.ArgumentNullException> ), можно изменить вызывающий код, чтобы убедиться, что пустая ссылка никогда не передается.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-136">For example, if passing a null reference (`Nothing` in Visual Basic) as one of the method’s arguments causes an error state (usually represented by an <xref:System.ArgumentNullException> exception), you can modify the calling code to ensure that a null reference is never passed.</span></span> <span data-ttu-id="3f9fd-137">Для всех остальных ошибок исключения, возникающие во время исполнения асинхронного метода, должны относиться к возвращаемой задаче, даже если асинхронный метод выполняется синхронно перед возвращением задачи.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-137">For all other errors, exceptions that occur when an asynchronous method is running should be assigned to the returned task, even if the asynchronous method happens to complete synchronously before the task is returned.</span></span> <span data-ttu-id="3f9fd-138">Как правило, задача содержит не более одного исключения.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-138">Typically, a task contains at most one exception.</span></span> <span data-ttu-id="3f9fd-139">Однако если задача представляет множественные операции (например, <xref:System.Threading.Tasks.Task.WhenAll%2A>), с одной задачей может быть связано несколько исключений.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-139">However, if the task represents multiple operations (for example, <xref:System.Threading.Tasks.Task.WhenAll%2A>), multiple exceptions may be associated with a single task.</span></span>  
  
## <a name="target-environment"></a><span data-ttu-id="3f9fd-140">Целевая среда</span><span class="sxs-lookup"><span data-stu-id="3f9fd-140">Target environment</span></span>  
 <span data-ttu-id="3f9fd-141">При реализации метода TAP можно определить, где происходит асинхронное выполнение.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-141">When you implement a TAP method, you can determine where asynchronous execution occurs.</span></span> <span data-ttu-id="3f9fd-142">Можно выполнить рабочую нагрузку в пуле потоков, реализовать ее с помощью асинхронного ввода-вывода (без привязки к потоку в большей части выполнения операции), выполнить ее в определенном потоке (например, в потоке пользовательского интерфейса) или использовать любое количество потенциальных контекстов.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-142">You may choose to execute the workload on the thread pool, implement it by using asynchronous I/O (without being bound to a thread for the majority of the operation’s execution), run it on a specific thread (such as the UI thread), or use any number of potential contexts.</span></span> <span data-ttu-id="3f9fd-143">Возможно, у метода TAP не будет задач для выполнения, тогда он просто возвратит <xref:System.Threading.Tasks.Task>, представляющий вхождение условия в другом месте системы (например, задачу с представлением данных, поступающих в структуру данных на основе очереди).</span><span class="sxs-lookup"><span data-stu-id="3f9fd-143">A TAP method may even have nothing to execute, and may just return a <xref:System.Threading.Tasks.Task> that represents the occurrence of a condition elsewhere in the system (for example, a task that represents data arriving at a queued data structure).</span></span>

 <span data-ttu-id="3f9fd-144">Вызывающий метода TAP может приостановить работу, ожидая завершения метода TAP путем синхронного ожидания результирующей задачи, или выполнять дополнительный код, продолжающий работу после завершения асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-144">The caller of the TAP method may block waiting for the TAP method to complete by synchronously waiting on the resulting task, or may run additional (continuation) code when the asynchronous operation completes.</span></span> <span data-ttu-id="3f9fd-145">Автор кода продолжения имеет контроль над местом исполнения кода.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-145">The creator of the continuation code has control over where that code executes.</span></span> <span data-ttu-id="3f9fd-146">Можно создать код продолжения явным образом с помощью методов в классе <xref:System.Threading.Tasks.Task> (например, <xref:System.Threading.Tasks.Task.ContinueWith%2A>) или неявно путем поддержки языка на основе продолжений (например, `await` в C#, `Await` в Visual Basic, `AwaitValue` в F#).</span><span class="sxs-lookup"><span data-stu-id="3f9fd-146">You may create the continuation code either explicitly, through methods on the <xref:System.Threading.Tasks.Task> class (for example, <xref:System.Threading.Tasks.Task.ContinueWith%2A>) or implicitly, by using language support built on top of continuations (for example, `await` in C#, `Await` in Visual Basic, `AwaitValue` in F#).</span></span>  
  
## <a name="task-status"></a><span data-ttu-id="3f9fd-147">Состояние задачи</span><span class="sxs-lookup"><span data-stu-id="3f9fd-147">Task status</span></span>  
 <span data-ttu-id="3f9fd-148">Класс <xref:System.Threading.Tasks.Task> обеспечивает жизненный цикл для асинхронных операций, и этот цикл представлен перечислением <xref:System.Threading.Tasks.TaskStatus>.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-148">The <xref:System.Threading.Tasks.Task> class provides a life cycle for asynchronous operations, and that cycle is represented by the <xref:System.Threading.Tasks.TaskStatus> enumeration.</span></span> <span data-ttu-id="3f9fd-149">Для поддержки угловых случаев типов, производных от <xref:System.Threading.Tasks.Task> и <xref:System.Threading.Tasks.Task%601>, и чтобы обеспечить разделение построения и планирования, класс <xref:System.Threading.Tasks.Task> предоставляет метод <xref:System.Threading.Tasks.Task.Start%2A>.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-149">To support corner cases of types that derive from <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601>,  and to support the separation of construction from scheduling, the <xref:System.Threading.Tasks.Task> class exposes a <xref:System.Threading.Tasks.Task.Start%2A> method.</span></span> <span data-ttu-id="3f9fd-150">Задачи, созданные открытыми конструкторами <xref:System.Threading.Tasks.Task>, называются *холодными задачами*, так как они начинают свой жизненный цикл в незапланированном состоянии <xref:System.Threading.Tasks.TaskStatus.Created>, а их планирование осуществляется только тогда, когда в этих экземплярах вызывается метод <xref:System.Threading.Tasks.Task.Start%2A>.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-150">Tasks that are created by the public <xref:System.Threading.Tasks.Task> constructors are referred to as *cold tasks*, because they begin their life cycle in the non-scheduled <xref:System.Threading.Tasks.TaskStatus.Created> state and are scheduled only when <xref:System.Threading.Tasks.Task.Start%2A> is called on these instances.</span></span>

 <span data-ttu-id="3f9fd-151">Все другие задачи начинают свой жизненный цикл в активном состоянии, то есть асинхронные операции, которые они представляют, уже были инициированы и их статус задачи — это значение перечисления, отличное от <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-151">All other tasks begin their life cycle in a hot state, which means that the asynchronous operations they represent have already been initiated and their task status is an enumeration value other than <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3f9fd-152">Необходимо активировать все задачи, возвращаемые методами TAP.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-152">All tasks that are returned from TAP methods must be activated.</span></span> <span data-ttu-id="3f9fd-153">**Если внутри метода TAP используется конструктор задачи, создающий экземпляр возвращаемой задачи, метод TAP перед ее возвращением должен вызвать метод <xref:System.Threading.Tasks.Task.Start%2A> для объекта <xref:System.Threading.Tasks.Task>.**</span><span class="sxs-lookup"><span data-stu-id="3f9fd-153">**If a TAP method internally uses a task’s constructor to instantiate the task to be returned, the TAP method must call <xref:System.Threading.Tasks.Task.Start%2A> on the <xref:System.Threading.Tasks.Task> object before returning it.**</span></span> <span data-ttu-id="3f9fd-154">Объекты-получатели метода TAP могут с уверенностью допускать, что возвращаемая задача активна, и не пытаться вызвать метод <xref:System.Threading.Tasks.Task.Start%2A> для любого объекта <xref:System.Threading.Tasks.Task>, который возвращается из метода TAP.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-154">Consumers of a TAP method may safely assume that the returned task is active and should not try to call <xref:System.Threading.Tasks.Task.Start%2A> on any <xref:System.Threading.Tasks.Task> that is returned from a TAP method.</span></span> <span data-ttu-id="3f9fd-155">Вызов метода <xref:System.Threading.Tasks.Task.Start%2A> в активной задаче приводит к исключению <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-155">Calling <xref:System.Threading.Tasks.Task.Start%2A> on an active task results in an <xref:System.InvalidOperationException> exception.</span></span>  
  
## <a name="cancellation-optional"></a><span data-ttu-id="3f9fd-156">Отмена (необязательно)</span><span class="sxs-lookup"><span data-stu-id="3f9fd-156">Cancellation (optional)</span></span>  
 <span data-ttu-id="3f9fd-157">В TAP отмена является необязательной как для асинхронной реализации метода, так и для асинхронных объектов-получателей метода.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-157">In TAP, cancellation is optional for both asynchronous method implementers and asynchronous method consumers.</span></span> <span data-ttu-id="3f9fd-158">Если операция позволяет выполнить отмену, она предоставляет перезагрузку асинхронного метода, принимающую токен отмены (экземпляр <xref:System.Threading.CancellationToken>).</span><span class="sxs-lookup"><span data-stu-id="3f9fd-158">If an operation allows cancellation, it exposes an overload of the asynchronous method that accepts a cancellation token (<xref:System.Threading.CancellationToken> instance).</span></span> <span data-ttu-id="3f9fd-159">По правилам этот параметр называется `cancellationToken`.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-159">By convention, the parameter is named `cancellationToken`.</span></span>  
  
 [!code-csharp[Conceptual.TAP#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#1)]
 [!code-vb[Conceptual.TAP#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#1)]  
  
 <span data-ttu-id="3f9fd-160">Асинхронная операция отслеживает этот токен на наличие запросов на отмену.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-160">The asynchronous operation monitors this token for cancellation requests.</span></span> <span data-ttu-id="3f9fd-161">Если операция получает запрос на отмену, системой может быть принято решение об удовлетворении запроса и отмене операции.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-161">If it receives a cancellation request, it may choose to honor that request and cancel the operation.</span></span> <span data-ttu-id="3f9fd-162">Если запрос на отмену приводит к преждевременному завершению работы, метод TAP возвращает задачу, которая завершается в состоянии <xref:System.Threading.Tasks.TaskStatus.Canceled>; в этом случае отсутствует результат и исключение не создается.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-162">If the cancellation request results in work being ended prematurely, the TAP method returns a task that ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state; there is no available result and no exception is thrown.</span></span>  <span data-ttu-id="3f9fd-163">Состояние <xref:System.Threading.Tasks.TaskStatus.Canceled> считается конечным состоянием для задачи, наравне с состояниями <xref:System.Threading.Tasks.TaskStatus.Faulted> и <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-163">The <xref:System.Threading.Tasks.TaskStatus.Canceled> state is considered to be a final (completed) state for a task, along with the <xref:System.Threading.Tasks.TaskStatus.Faulted> and <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> states.</span></span> <span data-ttu-id="3f9fd-164">Таким образом, если задача находится в состоянии <xref:System.Threading.Tasks.TaskStatus.Canceled>, ее свойство <xref:System.Threading.Tasks.Task.IsCompleted%2A> возвращает значение `true`.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-164">Therefore, if a task is in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, its <xref:System.Threading.Tasks.Task.IsCompleted%2A> property returns `true`.</span></span> <span data-ttu-id="3f9fd-165">Если задача завершается в состоянии <xref:System.Threading.Tasks.TaskStatus.Canceled>, любые продолжения, зарегистрированные для задачи, планируются или исполняются, если только не был выбран параметр отказа от продолжения, такой как <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled>.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-165">When a task completes in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, any continuations registered with the task are scheduled or executed, unless a continuation option such as <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled> was specified to opt out of continuation.</span></span> <span data-ttu-id="3f9fd-166">Любой код, который асинхронно ожидает отмененной задачи с использованием языковых возможностей, продолжает выполняться, но получает исключение <xref:System.OperationCanceledException> или производное от него исключение.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-166">Any code that is asynchronously waiting for a canceled task through use of language features continues to run but receives an <xref:System.OperationCanceledException> or an exception derived from it.</span></span> <span data-ttu-id="3f9fd-167">Код, который блокируется во время синхронного ожидания задачи с использованием методов <xref:System.Threading.Tasks.Task.Wait%2A> и <xref:System.Threading.Tasks.Task.WaitAll%2A> также продолжает выполняться с исключением.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-167">Code that is blocked synchronously waiting on the task through methods such as <xref:System.Threading.Tasks.Task.Wait%2A> and <xref:System.Threading.Tasks.Task.WaitAll%2A> also continue to run with an exception.</span></span>  
  
 <span data-ttu-id="3f9fd-168">Если токен отмены запросил отмену до вызова метода TAP, принявшего этот токен, метод TAP должен вернуть задачу <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-168">If a cancellation token has requested cancellation before the TAP method that accepts that token is called, the TAP method should return a <xref:System.Threading.Tasks.TaskStatus.Canceled> task.</span></span>  <span data-ttu-id="3f9fd-169">Однако если отмена запрошена во время выполнения асинхронной операции, последней не обязательно принимать запрос на отмену.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-169">However, if cancellation is requested while the asynchronous operation is running, the asynchronous operation need not accept the cancellation request.</span></span>  <span data-ttu-id="3f9fd-170">Возвращаемая задача должна завершиться в состоянии <xref:System.Threading.Tasks.TaskStatus.Canceled>, только если операция завершается в результате запроса отмены.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-170">The returned task should end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state only if the operation ends as a result of the cancellation request.</span></span> <span data-ttu-id="3f9fd-171">Если отмена запрошена, но результат или исключение по-прежнему создаются, задача должна завершиться в состоянии <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> или <xref:System.Threading.Tasks.TaskStatus.Faulted>.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-171">If cancellation is requested but a result or an exception is still produced, the task should end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> or <xref:System.Threading.Tasks.TaskStatus.Faulted> state.</span></span>

 <span data-ttu-id="3f9fd-172">В асинхронных методах, для которых возможность выполнить отмену является обязательным условием, не обязательно предоставлять перегрузку, не принимающую маркер отмены.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-172">For asynchronous methods that want to expose the ability to be cancelled first and foremost, you don't have to provide an overload that doesn’t accept a cancellation token.</span></span> <span data-ttu-id="3f9fd-173">Для методов, которые не могут быть отменены, не нужно предоставлять перегрузки, принимающие токен отмены; это позволяет указать вызывающему объекту, можно ли в действительности отменить целевой метод.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-173">For methods that cannot be canceled, do not provide overloads that accept a cancellation token; this helps indicate to the caller whether the target method is actually cancelable.</span></span>  <span data-ttu-id="3f9fd-174">Код объекта-получателя, в котором отмена является нежелательной, может вызвать метод, который принимает <xref:System.Threading.CancellationToken> и предоставляет <xref:System.Threading.CancellationToken.None%2A> в качестве значения аргумента.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-174">Consumer code that does not desire cancellation may call a method that accepts a <xref:System.Threading.CancellationToken> and provide <xref:System.Threading.CancellationToken.None%2A> as the argument value.</span></span> <span data-ttu-id="3f9fd-175"><xref:System.Threading.CancellationToken.None%2A> функционально эквивалентен значению по умолчанию <xref:System.Threading.CancellationToken>.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-175"><xref:System.Threading.CancellationToken.None%2A> is functionally equivalent to the default <xref:System.Threading.CancellationToken>.</span></span>  
  
## <a name="progress-reporting-optional"></a><span data-ttu-id="3f9fd-176">Отчет о ходе выполнения (необязательно)</span><span class="sxs-lookup"><span data-stu-id="3f9fd-176">Progress reporting (optional)</span></span>  
 <span data-ttu-id="3f9fd-177">Для некоторых асинхронных операций имеет смысл предоставлять уведомления о ходе выполнения; обычно уведомления используются для обновления информации о выполнении асинхронной операции в пользовательском интерфейсе.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-177">Some asynchronous operations benefit from providing progress notifications; these are typically used to update a user interface with information about the progress of the asynchronous operation.</span></span>

 <span data-ttu-id="3f9fd-178">В TAP ход выполнения контролируется в интерфейсе <xref:System.IProgress%601>, который передается в асинхронный метод в качестве параметра, который обычно называется `progress`.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-178">In TAP, progress is handled through an <xref:System.IProgress%601> interface, which is passed to the asynchronous method as a parameter that is usually named `progress`.</span></span>  <span data-ttu-id="3f9fd-179">Предоставление интерфейса для контроля за ходом выполнения при вызове асинхронного метода позволяет избежать состояний гонки, возникающих в результате неправильного использования (т. е. когда обработчики событий, неправильно зарегистрированные после начала операции, пропускают обновления).</span><span class="sxs-lookup"><span data-stu-id="3f9fd-179">Providing the progress interface when the asynchronous method is called helps eliminate race conditions that result from incorrect usage (that is, when event handlers that are incorrectly registered after the operation starts may miss updates).</span></span>  <span data-ttu-id="3f9fd-180">Еще более важно то, что интерфейс выполнения поддерживает различные реализации хода выполнения в соответствии с определением в коде-потребителе.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-180">More importantly, the progress interface supports varying implementations of progress, as determined by the consuming code.</span></span>  <span data-ttu-id="3f9fd-181">Например, код-потребитель может запрашивать только последнее обновление хода выполнения, пытаться выполнить буферизацию всех обновлений, вызвать действие для каждого обновления или контролировать маршалирование вызова в определенный поток.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-181">For example, the consuming code may only care about the latest progress update, or may want to buffer all updates, or may want to invoke an action for each update, or may want to control whether the invocation is marshaled to a particular thread.</span></span> <span data-ttu-id="3f9fd-182">Все эти варианты могут быть реализованы с использованием иной реализации интерфейса, настроенной в соответствии с требованиями потребителя.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-182">All these options may be achieved by using a different implementation of the interface, customized to the particular consumer’s needs.</span></span>  <span data-ttu-id="3f9fd-183">Как и в случае с отменой, реализации TAP должны предоставлять параметр <xref:System.IProgress%601>, только если API поддерживает уведомления о ходе выполнения.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-183">As with cancellation, TAP implementations should provide an <xref:System.IProgress%601> parameter only if the API supports progress notifications.</span></span>

 <span data-ttu-id="3f9fd-184">Например, если метод `ReadAsync`, обсуждаемый ранее в этой статье, может информировать о ходе выполнения в виде считанного количества байтов, обратный вызов хода выполнения может быть представлен интерфейсом <xref:System.IProgress%601>:</span><span class="sxs-lookup"><span data-stu-id="3f9fd-184">For example, if the `ReadAsync` method discussed earlier in this article is able to report intermediate progress in the form of the number of bytes read thus far, the progress callback could be an <xref:System.IProgress%601> interface:</span></span>  
  
 [!code-csharp[Conceptual.TAP#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#2)]
 [!code-vb[Conceptual.TAP#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#2)]  
  
 <span data-ttu-id="3f9fd-185">Если метод `FindFilesAsync` возвращает список всех файлов, соответствующих указанному шаблону поиска, обратный вызов хода выполнения может предоставить оценку процента выполненной работы, а также текущий частичный результат.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-185">If a `FindFilesAsync` method returns a list of all files that meet a particular search pattern, the progress callback could provide an estimate of the percentage of work completed as well as the current set of partial results.</span></span>  <span data-ttu-id="3f9fd-186">Для этого может использоваться кортеж:</span><span class="sxs-lookup"><span data-stu-id="3f9fd-186">It could do this either with a tuple:</span></span>  
  
 [!code-csharp[Conceptual.TAP#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#3)]
 [!code-vb[Conceptual.TAP#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#3)]  
  
 <span data-ttu-id="3f9fd-187">или тип данных, соответствующий данному API.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-187">or with a data type that is specific to the API:</span></span>  
  
 [!code-csharp[Conceptual.TAP#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#4)]
 [!code-vb[Conceptual.TAP#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#4)]  
  
 <span data-ttu-id="3f9fd-188">В последнем случае к специальному типу данных добавляется суффикс `ProgressInfo`.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-188">In the latter case, the special data type is usually suffixed with `ProgressInfo`.</span></span>  
  
 <span data-ttu-id="3f9fd-189">Если реализации TAP предоставляют перегрузки, принимающие параметр `progress`, они должны разрешать значение `null` для аргумента. В этом случае о ходе выполнения не сообщается.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-189">If TAP implementations provide overloads that accept a `progress` parameter, they must allow the argument to be `null`, in which case no progress will be reported.</span></span> <span data-ttu-id="3f9fd-190">В реализации TAP необходимо синхронно сообщать информацию о ходе выполнения объекту <xref:System.Progress%601>, что позволит асинхронному методу быстро предоставлять сведения о ходе выполнения, а объекту-получателю этой информации определять, как и где лучше обрабатывать эти данные.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-190">TAP implementations should report the progress to the <xref:System.Progress%601> object synchronously, which enables the asynchronous method to quickly provide progress, and allow the consumer of the progress to determine how and where best to handle the information.</span></span> <span data-ttu-id="3f9fd-191">Например, экземпляр хода выполнения может маршалировать обратные вызовы и инициировать события для захваченного контекста синхронизации.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-191">For example, the progress instance could choose to marshal callbacks and raise events on a captured synchronization context.</span></span>  
  
## <a name="iprogresst-implementations"></a><span data-ttu-id="3f9fd-192">Реализации IProgress\<T></span><span class="sxs-lookup"><span data-stu-id="3f9fd-192">IProgress\<T> implementations</span></span>  
 <span data-ttu-id="3f9fd-193">.NET Framework 4.5 предоставляет одну реализацию <xref:System.IProgress%601>: <xref:System.Progress%601>.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-193">The .NET Framework 4.5 provides a single <xref:System.IProgress%601> implementation: <xref:System.Progress%601>.</span></span> <span data-ttu-id="3f9fd-194">Класс <xref:System.Progress%601>объявляется следующим образом:</span><span class="sxs-lookup"><span data-stu-id="3f9fd-194">The <xref:System.Progress%601> class is declared as follows:</span></span>  
  
```csharp  
public class Progress<T> : IProgress<T>  
{  
    public Progress();  
    public Progress(Action<T> handler);  
    protected virtual void OnReport(T value);  
    public event EventHandler<T> ProgressChanged;  
}  
```  
  
```vb  
Public Class Progress(Of T) : Inherits IProgress(Of T)  
    Public Sub New()  
    Public Sub New(handler As Action(Of T))  
    Protected Overridable Sub OnReport(value As T)  
    Public Event ProgressChanged As EventHandler(Of T>  
End Class  
```  
  
 <span data-ttu-id="3f9fd-195">Экземпляр <xref:System.Progress%601> предоставляет событие <xref:System.Progress%601.ProgressChanged>, которое вызывается каждый раз, когда асинхронная операция сообщает об обновлении хода выполнения.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-195">An instance of <xref:System.Progress%601> exposes a <xref:System.Progress%601.ProgressChanged> event, which is raised every time the asynchronous operation reports a progress update.</span></span> <span data-ttu-id="3f9fd-196">Событие <xref:System.Progress%601.ProgressChanged> вызывается для объекта <xref:System.Threading.SynchronizationContext>, который был захвачен при создании экземпляра <xref:System.Progress%601>.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-196">The <xref:System.Progress%601.ProgressChanged> event is raised on the <xref:System.Threading.SynchronizationContext> object that was captured when the <xref:System.Progress%601> instance was instantiated.</span></span> <span data-ttu-id="3f9fd-197">Если контекст синхронизации не был доступен, то используется контекст по умолчанию, предназначенный для пула потоков.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-197">If no synchronization context was available, a default context that targets the thread pool is used.</span></span> <span data-ttu-id="3f9fd-198">Обработчики могут быть зарегистрированы при помощи этого события.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-198">Handlers may be registered with this event.</span></span> <span data-ttu-id="3f9fd-199">Один обработчик также может предоставляться конструктору <xref:System.Progress%601> для удобства. Он работает точно так же, как обработчик события <xref:System.Progress%601.ProgressChanged>.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-199">A single handler may also be provided to the <xref:System.Progress%601> constructor for convenience, and behaves just like an event handler for the <xref:System.Progress%601.ProgressChanged> event.</span></span> <span data-ttu-id="3f9fd-200">Обновления хода выполнения вызываются асинхронно, чтобы избежать задержки асинхронной операции при выполнении обработчиков событий.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-200">Progress updates are raised asynchronously to avoid delaying the asynchronous operation while event handlers are executing.</span></span> <span data-ttu-id="3f9fd-201">В другой реализации <xref:System.IProgress%601> может применяться другая семантика.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-201">Another <xref:System.IProgress%601> implementation could choose to apply different semantics.</span></span>  
  
## <a name="choosing-the-overloads-to-provide"></a><span data-ttu-id="3f9fd-202">Выбор перегрузок для предоставления</span><span class="sxs-lookup"><span data-stu-id="3f9fd-202">Choosing the overloads to provide</span></span>  
 <span data-ttu-id="3f9fd-203">Если реализация TAP использует необязательные параметры <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> и <xref:System.IProgress%601>, потенциально может потребоваться до четырех перегрузок:</span><span class="sxs-lookup"><span data-stu-id="3f9fd-203">If a TAP implementation uses both the optional <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> and optional <xref:System.IProgress%601> parameters, it could potentially require up to four overloads:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, CancellationToken cancellationToken);  
public Task MethodNameAsync(…, IProgress<T> progress);
public Task MethodNameAsync(…,
    CancellationToken cancellationToken, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken cancellationToken) As Task  
Public MethodNameAsync(…, progress As IProgress(Of T)) As Task
Public MethodNameAsync(…, cancellationToken As CancellationToken,
                       progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="3f9fd-204">Однако многие реализации TAP не поддерживают ни отмену, ни просмотр информации о ходе выполнения, поэтому им требуется единственный метод:</span><span class="sxs-lookup"><span data-stu-id="3f9fd-204">However, many TAP implementations provide neither cancellation or progress capabilities, so they require a single method:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
```  
  
 <span data-ttu-id="3f9fd-205">Если реализация TAP поддерживает либо отмену, либо просмотр хода выполнения, но не одновременно, то она может предоставлять две перегрузки:</span><span class="sxs-lookup"><span data-stu-id="3f9fd-205">If a TAP implementation supports either cancellation or progress but not both, it may provide two overloads:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, CancellationToken cancellationToken);  
  
// … or …  
  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken) As Task  
  
' … or …  
  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="3f9fd-206">Если реализация TAP поддерживает отмену и просмотр хода выполнения, то она может предоставить все четыре перегруженные версии.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-206">If a TAP implementation supports both cancellation and progress, it may expose all four overloads.</span></span> <span data-ttu-id="3f9fd-207">С другой стороны, она может предоставить только следующие две:</span><span class="sxs-lookup"><span data-stu-id="3f9fd-207">However, it may provide only the following two:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…,
    CancellationToken cancellationToken, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken,
                       progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="3f9fd-208">Чтобы возместить два отсутствующих промежуточных сочетания, разработчик может передать значение <xref:System.Threading.CancellationToken.None%2A> или значение по умолчанию <xref:System.Threading.CancellationToken> для параметра `cancellationToken` и `null` для параметра `progress`.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-208">To compensate for the two missing intermediate combinations, developers may pass <xref:System.Threading.CancellationToken.None%2A> or a default <xref:System.Threading.CancellationToken> for the `cancellationToken` parameter and `null` for the `progress` parameter.</span></span>  
  
 <span data-ttu-id="3f9fd-209">Если ожидается, что каждое использование метода TAP поддерживает отмену или отслеживание хода выполнения, то можно опустить перегрузки, которые не принимают соответствующих параметров.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-209">If you expect every usage of the TAP method to support cancellation or progress, you may omit the overloads that don’t accept the relevant parameter.</span></span>  
  
 <span data-ttu-id="3f9fd-210">Если необходимо предоставить несколько перегрузок, чтобы сделать необязательной отмену или отслеживание хода выполнения, то перегруженные варианты, которые не поддерживают отмену или отслеживание хода выполнения, должны работать так, будто они передали <xref:System.Threading.CancellationToken.None%2A> для отмены или `null` для отслеживания хода выполнения в перегрузку, которая их поддерживает.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-210">If you decide to expose multiple overloads to make cancellation or progress optional, the overloads that don’t support cancellation or progress should behave as if they passed <xref:System.Threading.CancellationToken.None%2A> for cancellation or `null` for progress to the overload that does support these.</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="3f9fd-211">См. также</span><span class="sxs-lookup"><span data-stu-id="3f9fd-211">Related topics</span></span>  
  
|<span data-ttu-id="3f9fd-212">Заголовок</span><span class="sxs-lookup"><span data-stu-id="3f9fd-212">Title</span></span>|<span data-ttu-id="3f9fd-213">Описание</span><span class="sxs-lookup"><span data-stu-id="3f9fd-213">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="3f9fd-214">Модели асинхронного программирования</span><span class="sxs-lookup"><span data-stu-id="3f9fd-214">Asynchronous Programming Patterns</span></span>](index.md)|<span data-ttu-id="3f9fd-215">Представляет три шаблона для выполнения асинхронных операций: асинхронную модель на основе задач (TAP), асинхронную модель программирования (APM) и асинхронную модель на основе событий (EAP).</span><span class="sxs-lookup"><span data-stu-id="3f9fd-215">Introduces the three patterns for performing asynchronous operations: the Task-based Asynchronous Pattern (TAP), the Asynchronous Programming Model (APM), and the Event-based Asynchronous Pattern (EAP).</span></span>|  
|[<span data-ttu-id="3f9fd-216">Реализация асинхронной модели на основе задач</span><span class="sxs-lookup"><span data-stu-id="3f9fd-216">Implementing the Task-based Asynchronous Pattern</span></span>](implementing-the-task-based-asynchronous-pattern.md)|<span data-ttu-id="3f9fd-217">Описывает три способа реализации асинхронной модели на основе задач (TAP): с помощью компиляторов C# и Visual Basic в Visual Studio, вручную или путем сочетания этих методов.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-217">Describes how to implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span>|  
|[<span data-ttu-id="3f9fd-218">Consuming the Task-based Asynchronous Pattern</span><span class="sxs-lookup"><span data-stu-id="3f9fd-218">Consuming the Task-based Asynchronous Pattern</span></span>](consuming-the-task-based-asynchronous-pattern.md)|<span data-ttu-id="3f9fd-219">Описывает, как можно использовать задачи и обратные вызовы для реализации неблокирующего ожидания.</span><span class="sxs-lookup"><span data-stu-id="3f9fd-219">Describes how you can use tasks and callbacks to achieve waiting without blocking.</span></span>|  
|[<span data-ttu-id="3f9fd-220">Взаимодействие с другими асинхронными шаблонами и типами</span><span class="sxs-lookup"><span data-stu-id="3f9fd-220">Interop with Other Asynchronous Patterns and Types</span></span>](interop-with-other-asynchronous-patterns-and-types.md)|<span data-ttu-id="3f9fd-221">Описывает, как использовать асинхронную модель на основе задач (TAP) для реализации асинхронной модели программирования (APM) и асинхронной модели на основе событий (EAP).</span><span class="sxs-lookup"><span data-stu-id="3f9fd-221">Describes how to use the Task-based Asynchronous Pattern (TAP) to implement the Asynchronous Programming Model (APM) and Event-based Asynchronous Pattern (EAP).</span></span>|
