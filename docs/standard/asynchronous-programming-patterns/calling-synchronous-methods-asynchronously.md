---
title: Асинхронный вызов синхронных методов
description: Сведения об асинхронном вызове синхронных методов в .NET с использованием методов BeginInvoke и EndInvoke.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
- cpp
helpviewer_keywords:
- asynchronous programming, delegates
- asynchronous delegates
- AsyncWaitHandle property
- callback methods
- calling synchronous methods in asynchronous manner
- WaitHandle class, code examples
- asynchronous programming, status polling
- polling asynchronous operation status
- delegates [.NET], asynchronous
- synchronous calling in asynchronous manner
- waiting for asynchronous calls
- status information [.NET], asynchronous operations
ms.assetid: 41972034-92ed-450a-9664-ab93fcc6f1fb
ms.openlocfilehash: d518e5f64096fde5c9b14222dc4fe0634e6bb7b1
ms.sourcegitcommit: 4a938327bad8b2e20cabd0f46a9dc50882596f13
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/28/2020
ms.locfileid: "92888897"
---
# <a name="calling-synchronous-methods-asynchronously"></a><span data-ttu-id="426e5-103">Асинхронный вызов синхронных методов</span><span class="sxs-lookup"><span data-stu-id="426e5-103">Calling Synchronous Methods Asynchronously</span></span>

<span data-ttu-id="426e5-104">В .NET можно асинхронно вызывать любой метод.</span><span class="sxs-lookup"><span data-stu-id="426e5-104">.NET enables you to call any method asynchronously.</span></span> <span data-ttu-id="426e5-105">Для этого необходимо определить делегат с той же сигнатурой, что и у вызываемого метода.</span><span class="sxs-lookup"><span data-stu-id="426e5-105">To do this, you define a delegate with the same signature as the method you want to call.</span></span> <span data-ttu-id="426e5-106">Среда CLR автоматически определяет для этого делегата методы `BeginInvoke` и `EndInvoke` с нужными сигнатурами.</span><span class="sxs-lookup"><span data-stu-id="426e5-106">The common language runtime automatically defines `BeginInvoke` and `EndInvoke` methods for this delegate, with the appropriate signatures.</span></span>

> [!NOTE]
> <span data-ttu-id="426e5-107">Асинхронные вызовы делегатов, в частности методы `BeginInvoke` и `EndInvoke` , не поддерживаются в платформе .NET Compact Framework.</span><span class="sxs-lookup"><span data-stu-id="426e5-107">Asynchronous delegate calls, specifically the `BeginInvoke` and `EndInvoke` methods, are not supported in the .NET Compact Framework.</span></span>

<span data-ttu-id="426e5-108">Асинхронный вызов инициируется с помощью метода `BeginInvoke` .</span><span class="sxs-lookup"><span data-stu-id="426e5-108">The `BeginInvoke` method initiates the asynchronous call.</span></span> <span data-ttu-id="426e5-109">Он имеет все те же параметры, что и метод, который нужно выполнить асинхронно, а также два дополнительных необязательных параметра.</span><span class="sxs-lookup"><span data-stu-id="426e5-109">It has the same parameters as the method that you want to execute asynchronously, plus two additional optional parameters.</span></span> <span data-ttu-id="426e5-110">Первый параметр является делегатом <xref:System.AsyncCallback> , который ссылается на метод, вызываемый при завершении асинхронного вызова.</span><span class="sxs-lookup"><span data-stu-id="426e5-110">The first parameter is an <xref:System.AsyncCallback> delegate that references a method to be called when the asynchronous call completes.</span></span> <span data-ttu-id="426e5-111">Второй параметр — это определяемый пользователем объект, который передает данные в метод обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="426e5-111">The second parameter is a user-defined object that passes information into the callback method.</span></span> <span data-ttu-id="426e5-112">Метод`BeginInvoke` выполняет возврат данных немедленно, без ожидания завершения асинхронного вызова.</span><span class="sxs-lookup"><span data-stu-id="426e5-112">`BeginInvoke` returns immediately and does not wait for the asynchronous call to complete.</span></span> <span data-ttu-id="426e5-113">Метод`BeginInvoke` возвращает объект <xref:System.IAsyncResult>, который можно использовать для отслеживания выполнения асинхронного вызова.</span><span class="sxs-lookup"><span data-stu-id="426e5-113">`BeginInvoke` returns an <xref:System.IAsyncResult>, which can be used to monitor the progress of the asynchronous call.</span></span>

<span data-ttu-id="426e5-114">Метод `EndInvoke` извлекает результаты асинхронного вызова.</span><span class="sxs-lookup"><span data-stu-id="426e5-114">The `EndInvoke` method retrieves the results of the asynchronous call.</span></span> <span data-ttu-id="426e5-115">Его можно вызвать в любое время после вызова метода `BeginInvoke`.</span><span class="sxs-lookup"><span data-stu-id="426e5-115">It can be called any time after `BeginInvoke`.</span></span> <span data-ttu-id="426e5-116">Если асинхронный вызов не завершен, метод `EndInvoke` блокирует вызывающий поток до завершения вызова.</span><span class="sxs-lookup"><span data-stu-id="426e5-116">If the asynchronous call has not completed, `EndInvoke` blocks the calling thread until it completes.</span></span> <span data-ttu-id="426e5-117">Список параметров метода `EndInvoke` включает параметры `out` и `ref` (`<Out>` `ByRef` и `ByRef` в Visual Basic) метода, который требуется вызвать асинхронно, а также значение <xref:System.IAsyncResult>, возвращаемое методом `BeginInvoke`.</span><span class="sxs-lookup"><span data-stu-id="426e5-117">The parameters of `EndInvoke` include the `out` and `ref` parameters (`<Out>` `ByRef` and `ByRef` in Visual Basic) of the method that you want to execute asynchronously, plus the <xref:System.IAsyncResult> returned by `BeginInvoke`.</span></span>

> [!NOTE]
> <span data-ttu-id="426e5-118">Функция IntelliSense в Visual Studio показывает параметры `BeginInvoke` и `EndInvoke`.</span><span class="sxs-lookup"><span data-stu-id="426e5-118">The IntelliSense feature in Visual Studio displays the parameters of `BeginInvoke` and `EndInvoke`.</span></span> <span data-ttu-id="426e5-119">Если вы не используете Visual Studio или похожий инструмент либо если используется C# вместе с Studio, см. статью [Асинхронная модель программирования (APM)](asynchronous-programming-model-apm.md) с описанием параметров, определенных для этих методов.</span><span class="sxs-lookup"><span data-stu-id="426e5-119">If you're not using Visual Studio or a similar tool, or if you're using C# with Visual Studio, see [Asynchronous Programming Model (APM)](asynchronous-programming-model-apm.md) for a description of the parameters defined for these methods.</span></span>

<span data-ttu-id="426e5-120">В приведенных в этой статье примерах кода демонстрируется четыре основных способа использования методов `BeginInvoke` и `EndInvoke` для выполнения асинхронных вызовов.</span><span class="sxs-lookup"><span data-stu-id="426e5-120">The code examples in this topic demonstrate four common ways to use `BeginInvoke` and `EndInvoke` to make asynchronous calls.</span></span> <span data-ttu-id="426e5-121">После вызова метода `BeginInvoke` можно выполнять следующие действия.</span><span class="sxs-lookup"><span data-stu-id="426e5-121">After calling `BeginInvoke` you can do the following:</span></span>

- <span data-ttu-id="426e5-122">Выполнить какие-либо операции, а затем вызвать метод `EndInvoke` для блокировки потока, пока не будет завершен вызов.</span><span class="sxs-lookup"><span data-stu-id="426e5-122">Do some work and then call `EndInvoke` to block until the call completes.</span></span>

- <span data-ttu-id="426e5-123">Получить объект <xref:System.Threading.WaitHandle> с помощью свойства <xref:System.IAsyncResult.AsyncWaitHandle%2A?displayProperty=nameWithType> , использовать метод <xref:System.Threading.WaitHandle.WaitOne%2A> для блокировки выполнения до получения сигнала <xref:System.Threading.WaitHandle> , а затем вызвать метод `EndInvoke`.</span><span class="sxs-lookup"><span data-stu-id="426e5-123">Obtain a <xref:System.Threading.WaitHandle> using the <xref:System.IAsyncResult.AsyncWaitHandle%2A?displayProperty=nameWithType> property, use its <xref:System.Threading.WaitHandle.WaitOne%2A> method to block execution until the <xref:System.Threading.WaitHandle> is signaled, and then call `EndInvoke`.</span></span>

- <span data-ttu-id="426e5-124">Периодически опрашивать интерфейс <xref:System.IAsyncResult> , возвращаемый методом `BeginInvoke` , для определения момента завершения асинхронного вызова, а затем вызвать метод `EndInvoke`.</span><span class="sxs-lookup"><span data-stu-id="426e5-124">Poll the <xref:System.IAsyncResult> returned by `BeginInvoke` to determine when the asynchronous call has completed, and then call `EndInvoke`.</span></span>

- <span data-ttu-id="426e5-125">Передать в метод `BeginInvoke`делегат для метода обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="426e5-125">Pass a delegate for a callback method to `BeginInvoke`.</span></span> <span data-ttu-id="426e5-126">Этот метод выполняется для потока <xref:System.Threading.ThreadPool> после завершения асинхронного вызова.</span><span class="sxs-lookup"><span data-stu-id="426e5-126">The method is executed on a <xref:System.Threading.ThreadPool> thread when the asynchronous call completes.</span></span> <span data-ttu-id="426e5-127">Метод обратного вызова вызывает метод `EndInvoke`.</span><span class="sxs-lookup"><span data-stu-id="426e5-127">The callback method calls `EndInvoke`.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="426e5-128">Независимо от выбранного варианта необходимо всегда использовать для завершения асинхронного вызова метод `EndInvoke` .</span><span class="sxs-lookup"><span data-stu-id="426e5-128">No matter which technique you use, always call `EndInvoke` to complete your asynchronous call.</span></span>

## <a name="defining-the-test-method-and-asynchronous-delegate"></a><span data-ttu-id="426e5-129">Определение метода проверки и асинхронного делегата</span><span class="sxs-lookup"><span data-stu-id="426e5-129">Defining the Test Method and Asynchronous Delegate</span></span>
 <span data-ttu-id="426e5-130">В приведенных ниже примерах кода показаны различные способы асинхронного вызова одного и того же длительно выполняющегося метода `TestMethod`.</span><span class="sxs-lookup"><span data-stu-id="426e5-130">The code examples that follow demonstrate various ways of calling the same long-running method, `TestMethod`, asynchronously.</span></span> <span data-ttu-id="426e5-131">Метод `TestMethod` отображает сообщение в консоли, указывающее на начало выполнения, бездействует в течение нескольких секунд и завершается.</span><span class="sxs-lookup"><span data-stu-id="426e5-131">The `TestMethod` method displays a console message to show that it has begun processing, sleeps for a few seconds, and then ends.</span></span> <span data-ttu-id="426e5-132">В методе`TestMethod` имеется параметр `out` для демонстрации порядка добавления таких параметров в сигнатуры методов `BeginInvoke` и `EndInvoke`.</span><span class="sxs-lookup"><span data-stu-id="426e5-132">`TestMethod` has an `out` parameter to demonstrate the way such parameters are added to the signatures of `BeginInvoke` and `EndInvoke`.</span></span> <span data-ttu-id="426e5-133">Таким же способом можно обрабатывать параметры `ref` .</span><span class="sxs-lookup"><span data-stu-id="426e5-133">You can handle `ref` parameters similarly.</span></span>

 <span data-ttu-id="426e5-134">В следующем примере кода показано определение `TestMethod` и делегата `AsyncMethodCaller` , который может использоваться для асинхронного вызова `TestMethod` .</span><span class="sxs-lookup"><span data-stu-id="426e5-134">The following code example shows the definition of `TestMethod` and the delegate named `AsyncMethodCaller` that can be used to call `TestMethod` asynchronously.</span></span> <span data-ttu-id="426e5-135">Чтобы скомпилировать эти примеры кода, необходимо включить определения для метода `TestMethod` и делегата `AsyncMethodCaller` .</span><span class="sxs-lookup"><span data-stu-id="426e5-135">To compile the code examples, you must include the definitions for `TestMethod` and the `AsyncMethodCaller` delegate.</span></span>

 [!code-cpp[AsyncDelegateExamples#1](../../../samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](../../../samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]

## <a name="waiting-for-an-asynchronous-call-with-endinvoke"></a><span data-ttu-id="426e5-136">Ожидание асинхронного вызова с использованием EndInvoke</span><span class="sxs-lookup"><span data-stu-id="426e5-136">Waiting for an Asynchronous Call with EndInvoke</span></span>
 <span data-ttu-id="426e5-137">Самым простым способом асинхронного вызова метода является запуск выполнения метода посредством вызова метода `BeginInvoke` делегата, выполнения каких-либо действий в основном потоке и последующего вызова метода `EndInvoke` .</span><span class="sxs-lookup"><span data-stu-id="426e5-137">The simplest way to execute a method asynchronously is to start executing the method by calling the delegate's `BeginInvoke` method, do some work on the main thread, and then call the delegate's `EndInvoke` method.</span></span> <span data-ttu-id="426e5-138">Метод`EndInvoke` может блокировать вызывающий поток, поскольку он не возвращает значение до завершения асинхронного вызова.</span><span class="sxs-lookup"><span data-stu-id="426e5-138">`EndInvoke` might block the calling thread because it does not return until the asynchronous call completes.</span></span> <span data-ttu-id="426e5-139">Этот подход хорошо использовать с файловыми и сетевыми операциями.</span><span class="sxs-lookup"><span data-stu-id="426e5-139">This is a good technique to use with file or network operations.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="426e5-140">Поскольку метод `EndInvoke` может заблокировать поток, его ни в коем случае нельзя вызывать из потоков, обслуживающих пользовательский интерфейс.</span><span class="sxs-lookup"><span data-stu-id="426e5-140">Because `EndInvoke` might block, you should never call it from threads that service the user interface.</span></span>

 [!code-cpp[AsyncDelegateExamples#2](../../../samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/EndInvoke.cpp#2)]
 [!code-csharp[AsyncDelegateExamples#2](../../../samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/EndInvoke.cs#2)]
 [!code-vb[AsyncDelegateExamples#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/EndInvoke.vb#2)]

## <a name="waiting-for-an-asynchronous-call-with-waithandle"></a><span data-ttu-id="426e5-141">Ожидание асинхронного вызова с использованием WaitHandle</span><span class="sxs-lookup"><span data-stu-id="426e5-141">Waiting for an Asynchronous Call with WaitHandle</span></span>
 <span data-ttu-id="426e5-142">Объект <xref:System.Threading.WaitHandle> можно получить с помощью свойства <xref:System.IAsyncResult.AsyncWaitHandle%2A> объекта <xref:System.IAsyncResult> , возвращаемого методом `BeginInvoke`.</span><span class="sxs-lookup"><span data-stu-id="426e5-142">You can obtain a <xref:System.Threading.WaitHandle> by using the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> returned by `BeginInvoke`.</span></span> <span data-ttu-id="426e5-143">Объект <xref:System.Threading.WaitHandle> получает сигнал после завершения асинхронного вызова; его можно дождаться путем вызова метода <xref:System.Threading.WaitHandle.WaitOne%2A> .</span><span class="sxs-lookup"><span data-stu-id="426e5-143">The <xref:System.Threading.WaitHandle> is signaled when the asynchronous call completes, and you can wait for it by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span>

 <span data-ttu-id="426e5-144">При использовании объекта <xref:System.Threading.WaitHandle>можно выполнять дополнительные операции до или после завершения асинхронного вызова, но до вызова метода `EndInvoke` для получения результатов.</span><span class="sxs-lookup"><span data-stu-id="426e5-144">If you use a <xref:System.Threading.WaitHandle>, you can perform additional processing before or after the asynchronous call completes, but before calling `EndInvoke` to retrieve the results.</span></span>

> [!NOTE]
> <span data-ttu-id="426e5-145">При вызове метода `EndInvoke`дескриптор ожидания не закрывается автоматически.</span><span class="sxs-lookup"><span data-stu-id="426e5-145">The wait handle is not closed automatically when you call `EndInvoke`.</span></span> <span data-ttu-id="426e5-146">Если удалить все ссылки на дескриптор ожидания, системные ресурсы будут освобождены при удалении дескриптора ожидания сборщиком мусора.</span><span class="sxs-lookup"><span data-stu-id="426e5-146">If you release all references to the wait handle, system resources are freed when garbage collection reclaims the wait handle.</span></span> <span data-ttu-id="426e5-147">Чтобы освободить системные ресурсы сразу после завершения использования дескриптора ожидания, удалите его, вызвав метод <xref:System.Threading.WaitHandle.Close%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="426e5-147">To free the system resources as soon as you are finished using the wait handle, dispose of it by calling the <xref:System.Threading.WaitHandle.Close%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="426e5-148">При явном удалении ненужных объектов сборщик мусора работает более эффективно.</span><span class="sxs-lookup"><span data-stu-id="426e5-148">Garbage collection works more efficiently when disposable objects are explicitly disposed.</span></span>

 [!code-cpp[AsyncDelegateExamples#3](../../../samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/waithandle.cpp#3)]
 [!code-csharp[AsyncDelegateExamples#3](../../../samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/waithandle.cs#3)]
 [!code-vb[AsyncDelegateExamples#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/WaitHandle.vb#3)]

## <a name="polling-for-asynchronous-call-completion"></a><span data-ttu-id="426e5-149">Опрос завершения асинхронного вызова</span><span class="sxs-lookup"><span data-stu-id="426e5-149">Polling for Asynchronous Call Completion</span></span>
 <span data-ttu-id="426e5-150">Свойство <xref:System.IAsyncResult.IsCompleted%2A> объекта <xref:System.IAsyncResult> , возвращаемого методом `BeginInvoke` , можно использовать для отслеживания завершения асинхронного вызова.</span><span class="sxs-lookup"><span data-stu-id="426e5-150">You can use the <xref:System.IAsyncResult.IsCompleted%2A> property of the <xref:System.IAsyncResult> returned by `BeginInvoke` to discover when the asynchronous call completes.</span></span> <span data-ttu-id="426e5-151">Это можно делать, когда асинхронный вызов выполнен из потока, обслуживающего пользовательский интерфейс.</span><span class="sxs-lookup"><span data-stu-id="426e5-151">You might do this when making the asynchronous call from a thread that services the user interface.</span></span> <span data-ttu-id="426e5-152">Опрос завершения позволяет вызывающему потоку продолжить выполнение при асинхронном вызове для потока <xref:System.Threading.ThreadPool> .</span><span class="sxs-lookup"><span data-stu-id="426e5-152">Polling for completion allows the calling thread to continue executing while the asynchronous call executes on a <xref:System.Threading.ThreadPool> thread.</span></span>

 [!code-cpp[AsyncDelegateExamples#4](../../../samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/polling.cpp#4)]
 [!code-csharp[AsyncDelegateExamples#4](../../../samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/polling.cs#4)]
 [!code-vb[AsyncDelegateExamples#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/polling.vb#4)]

## <a name="executing-a-callback-method-when-an-asynchronous-call-completes"></a><span data-ttu-id="426e5-153">Выполнение метода обратного вызова при завершении асинхронного вызова</span><span class="sxs-lookup"><span data-stu-id="426e5-153">Executing a Callback Method When an Asynchronous Call Completes</span></span>
 <span data-ttu-id="426e5-154">Если поток, инициировавший асинхронный вызов, не обязательно должен быть потоком, обрабатывающим результаты вызова, после завершения асинхронного вызова можно выполнить метод обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="426e5-154">If the thread that initiates the asynchronous call does not need to be the thread that processes the results, you can execute a callback method when the call completes.</span></span> <span data-ttu-id="426e5-155">Метод обратного вызова выполняется для потока <xref:System.Threading.ThreadPool> .</span><span class="sxs-lookup"><span data-stu-id="426e5-155">The callback method is executed on a <xref:System.Threading.ThreadPool> thread.</span></span>

 <span data-ttu-id="426e5-156">Чтобы использовать метод обратного вызова, необходимо передать в метод `BeginInvoke` делегат <xref:System.AsyncCallback> , который представляет метод обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="426e5-156">To use a callback method, you must pass `BeginInvoke` an <xref:System.AsyncCallback> delegate that represents the callback method.</span></span> <span data-ttu-id="426e5-157">Кроме того, можно передать объект, содержащий данные, которые будут использоваться методом обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="426e5-157">You can also pass an object that contains information to be used by the callback method.</span></span> <span data-ttu-id="426e5-158">В методе обратного вызова параметр <xref:System.IAsyncResult>, который является единственным параметром метода обратного вызова, можно привести к типу объекта <xref:System.Runtime.Remoting.Messaging.AsyncResult> .</span><span class="sxs-lookup"><span data-stu-id="426e5-158">In the callback method, you can cast the <xref:System.IAsyncResult>, which is the only parameter of the callback method, to an <xref:System.Runtime.Remoting.Messaging.AsyncResult> object.</span></span> <span data-ttu-id="426e5-159">После этого свойство <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate%2A?displayProperty=nameWithType> можно будет использовать для получения делегата, с помощью которого инициирован вызов, чтобы можно было вызвать метод `EndInvoke`.</span><span class="sxs-lookup"><span data-stu-id="426e5-159">You can then use the <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate%2A?displayProperty=nameWithType> property to get the delegate that was used to initiate the call so that you can call `EndInvoke`.</span></span>

 <span data-ttu-id="426e5-160">Примечания к примеру.</span><span class="sxs-lookup"><span data-stu-id="426e5-160">Notes on the example:</span></span>

- <span data-ttu-id="426e5-161">Параметр `threadId` метода `TestMethod` является параметром `out` (`<Out>` `ByRef` в Visual Basic), поэтому его входные значения никогда не используются методом `TestMethod`.</span><span class="sxs-lookup"><span data-stu-id="426e5-161">The `threadId` parameter of `TestMethod` is an `out` parameter ([`<Out>` `ByRef` in Visual Basic), so its input value is never used by `TestMethod`.</span></span> <span data-ttu-id="426e5-162">При вызове метода `BeginInvoke` ему передается фиктивная переменная.</span><span class="sxs-lookup"><span data-stu-id="426e5-162">A dummy variable is passed to the `BeginInvoke` call.</span></span> <span data-ttu-id="426e5-163">Если параметр `threadId` является параметром `ref` (`ByRef` в Visual Basic), переменная должна быть полем уровня класса, чтобы ее можно было передавать методам `BeginInvoke` и `EndInvoke`.</span><span class="sxs-lookup"><span data-stu-id="426e5-163">If the `threadId` parameter were a `ref` parameter (`ByRef` in Visual Basic), the variable would have to be a class-level field so that it could be passed to both `BeginInvoke` and `EndInvoke`.</span></span>

- <span data-ttu-id="426e5-164">Данные о состоянии передаются методу `BeginInvoke` в виде строки форматирования, используемой методом обратного вызова для форматирования выходного сообщения.</span><span class="sxs-lookup"><span data-stu-id="426e5-164">The state information that is passed to `BeginInvoke` is a format string, which the callback method uses to format an output message.</span></span> <span data-ttu-id="426e5-165">Поскольку данные о состоянии передаются в виде типа <xref:System.Object>, перед использованием их необходимо привести к нужному типу.</span><span class="sxs-lookup"><span data-stu-id="426e5-165">Because it is passed as type <xref:System.Object>, the state information must be cast to its proper type before it can be used.</span></span>

- <span data-ttu-id="426e5-166">Обратный вызов выполняется в потоке <xref:System.Threading.ThreadPool> .</span><span class="sxs-lookup"><span data-stu-id="426e5-166">The callback is made on a <xref:System.Threading.ThreadPool> thread.</span></span> <span data-ttu-id="426e5-167">Потоки<xref:System.Threading.ThreadPool> — это фоновые потоки, которые не смогут обеспечить работоспособность приложения при завершении основного потока, поэтому основной поток в приведенном примере должен дождаться завершения обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="426e5-167"><xref:System.Threading.ThreadPool> threads are background threads, which do not keep the application running if the main thread ends, so the main thread of the example has to sleep long enough for the callback to finish.</span></span>

 [!code-cpp[AsyncDelegateExamples#5](../../../samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/callback.cpp#5)]
 [!code-csharp[AsyncDelegateExamples#5](../../../samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/callback.cs#5)]
 [!code-vb[AsyncDelegateExamples#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/callback.vb#5)]

## <a name="see-also"></a><span data-ttu-id="426e5-168">См. также</span><span class="sxs-lookup"><span data-stu-id="426e5-168">See also</span></span>

- <xref:System.Delegate>
- [<span data-ttu-id="426e5-169">Асинхронная модель на основе событий (EAP)</span><span class="sxs-lookup"><span data-stu-id="426e5-169">Event-based Asynchronous Pattern (EAP)</span></span>](event-based-asynchronous-pattern-eap.md)
