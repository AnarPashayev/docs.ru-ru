---
title: Рекомендации по реализации асинхронной модели, основанной на событиях
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- Event-based Asynchronous Pattern
- ProgressChangedEventArgs class
- BackgroundWorker component
- events [.NET Framework], asynchronous
- AsyncOperationManager class
- threading [.NET Framework], asynchronous features
- AsyncOperation class
- AsyncCompletedEventArgs class
ms.assetid: 4acd2094-4f46-4eff-9190-92d0d9ff47db
ms.openlocfilehash: 66979415f2951acc78dc4eb7b2aafe3c84e85397
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/02/2020
ms.locfileid: "84289945"
---
# <a name="best-practices-for-implementing-the-event-based-asynchronous-pattern"></a><span data-ttu-id="7be3a-102">Рекомендации по реализации асинхронной модели, основанной на событиях</span><span class="sxs-lookup"><span data-stu-id="7be3a-102">Best Practices for Implementing the Event-based Asynchronous Pattern</span></span>
<span data-ttu-id="7be3a-103">Асинхронная модель на основе событий является эффективным средством для обеспечения асинхронной работы в классах на базе привычной семантики делегатов и событий.</span><span class="sxs-lookup"><span data-stu-id="7be3a-103">The Event-based Asynchronous Pattern provides you with an effective way to expose asynchronous behavior in classes, with familiar event and delegate semantics.</span></span> <span data-ttu-id="7be3a-104">Чтобы внедрить асинхронную модель на основе событий, необходимо выполнить определенные требования относительно поведения.</span><span class="sxs-lookup"><span data-stu-id="7be3a-104">To implement Event-based Asynchronous Pattern, you need to follow some specific behavioral requirements.</span></span> <span data-ttu-id="7be3a-105">В следующих разделах описываются требования и рекомендации, которые следует учитывать при реализации класса, поддерживающего асинхронную модель на основе событий.</span><span class="sxs-lookup"><span data-stu-id="7be3a-105">The following sections describe requirements and guidelines you should consider when you implement a class that follows the Event-based Asynchronous Pattern.</span></span>  
  
 <span data-ttu-id="7be3a-106">Общие сведения см. в разделе [Рекомендации по реализации асинхронной модели, основанной на событиях](implementing-the-event-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="7be3a-106">For an overview, see [Implementing the Event-based Asynchronous Pattern](implementing-the-event-based-asynchronous-pattern.md).</span></span>  
  
## <a name="required-behavioral-guarantees"></a><span data-ttu-id="7be3a-107">Обеспечение требуемого поведения</span><span class="sxs-lookup"><span data-stu-id="7be3a-107">Required Behavioral Guarantees</span></span>  
 <span data-ttu-id="7be3a-108">Если вы внедряете асинхронную модель на основе событий, необходимо выполнить несколько условий, чтобы класс работал правильно, а клиенты вашего класса могли положиться на его работу.</span><span class="sxs-lookup"><span data-stu-id="7be3a-108">If you implement the Event-based Asynchronous Pattern, you must provide a number of guarantees to ensure that your class will behave properly and clients of your class can rely on such behavior.</span></span>  
  
### <a name="completion"></a><span data-ttu-id="7be3a-109">Завершение</span><span class="sxs-lookup"><span data-stu-id="7be3a-109">Completion</span></span>  
 <span data-ttu-id="7be3a-110">После успешного завершения, отмены или в случае ошибки всегда вызывайте обработчик событий <em>имя_метода</em>**Completed**.</span><span class="sxs-lookup"><span data-stu-id="7be3a-110">Always invoke the <em>MethodName</em>**Completed** event handler when you have successful completion, an error, or a cancellation.</span></span> <span data-ttu-id="7be3a-111">Приложения никогда не должны попадать в ситуацию, в которой они остаются неактивными, а завершение не выполняется.</span><span class="sxs-lookup"><span data-stu-id="7be3a-111">Applications should never encounter a situation where they remain idle and completion never occurs.</span></span> <span data-ttu-id="7be3a-112">Единственным исключением из этого правила является такая асинхронная операция, которая намеренно разработана таким образом, чтобы никогда не завершаться.</span><span class="sxs-lookup"><span data-stu-id="7be3a-112">One exception to this rule is if the asynchronous operation itself is designed so that it never completes.</span></span>  
  
### <a name="completed-event-and-eventargs"></a><span data-ttu-id="7be3a-113">Событие Completed и EventArgs</span><span class="sxs-lookup"><span data-stu-id="7be3a-113">Completed Event and EventArgs</span></span>  
 <span data-ttu-id="7be3a-114">Для каждого отдельного метода <em>имя_метода</em>**Async** придерживайтесь следующих требований:</span><span class="sxs-lookup"><span data-stu-id="7be3a-114">For each separate <em>MethodName</em>**Async** method, apply the following design requirements:</span></span>  
  
- <span data-ttu-id="7be3a-115">Определите событие <em>имя_метода</em>**Completed** в том же классе, что и этот метод.</span><span class="sxs-lookup"><span data-stu-id="7be3a-115">Define a <em>MethodName</em>**Completed** event on the same class as the method.</span></span>  
  
- <span data-ttu-id="7be3a-116">Определите класс <xref:System.EventArgs> и сопроводительный делегат для события <em>имя_метода</em>**Completed**, наследованного от класса <xref:System.ComponentModel.AsyncCompletedEventArgs>.</span><span class="sxs-lookup"><span data-stu-id="7be3a-116">Define an <xref:System.EventArgs> class and accompanying delegate for the <em>MethodName</em>**Completed** event that derives from the <xref:System.ComponentModel.AsyncCompletedEventArgs> class.</span></span> <span data-ttu-id="7be3a-117">Имя класса по умолчанию должно быть представлено в таком формате: <em>имя_метода</em>**CompletedEventArgs**.</span><span class="sxs-lookup"><span data-stu-id="7be3a-117">The default class name should be of the form <em>MethodName</em>**CompletedEventArgs**.</span></span>  
  
- <span data-ttu-id="7be3a-118">Убедитесь, что класс <xref:System.EventArgs> связан с возвращаемыми значениями метода <em>имя_метода</em>.</span><span class="sxs-lookup"><span data-stu-id="7be3a-118">Ensure that the <xref:System.EventArgs> class is specific to the return values of the <em>MethodName</em> method.</span></span> <span data-ttu-id="7be3a-119">При использовании класса <xref:System.EventArgs> вы никогда не должны требовать от разработчиков выполнить приведение результата.</span><span class="sxs-lookup"><span data-stu-id="7be3a-119">When you use the <xref:System.EventArgs> class, you should never require developers to cast the result.</span></span>  
  
     <span data-ttu-id="7be3a-120">В следующем примере кода показана хорошая и плохая реализация этого требования к разработке.</span><span class="sxs-lookup"><span data-stu-id="7be3a-120">The following code example shows good and bad implementation of this design requirement respectively.</span></span>  
  
```csharp  
// Good design  
private void Form1_MethodNameCompleted(object sender, xxxCompletedEventArgs e)
{
    DemoType result = e.Result;  
}  
  
// Bad design  
private void Form1_MethodNameCompleted(object sender, MethodNameCompletedEventArgs e)
{
    DemoType result = (DemoType)(e.Result);  
}  
```  
  
- <span data-ttu-id="7be3a-121">Не определяйте класс <xref:System.EventArgs> для возвратных методов, которые возвращают `void`.</span><span class="sxs-lookup"><span data-stu-id="7be3a-121">Do not define an <xref:System.EventArgs> class for returning methods that return `void`.</span></span> <span data-ttu-id="7be3a-122">Вместо этого следует использовать экземпляр класса <xref:System.ComponentModel.AsyncCompletedEventArgs>.</span><span class="sxs-lookup"><span data-stu-id="7be3a-122">Instead, use an instance of the <xref:System.ComponentModel.AsyncCompletedEventArgs> class.</span></span>  
  
- <span data-ttu-id="7be3a-123">Следите за тем, чтобы всегда создавалось событие <em>имя_метода</em>**Completed**.</span><span class="sxs-lookup"><span data-stu-id="7be3a-123">Ensure that you always raise the <em>MethodName</em>**Completed** event.</span></span> <span data-ttu-id="7be3a-124">Это событие должно возникать при успешном завершении, ошибке или отмене.</span><span class="sxs-lookup"><span data-stu-id="7be3a-124">This event should be raised on successful completion, on an error, or on cancellation.</span></span> <span data-ttu-id="7be3a-125">Приложения никогда не должны попадать в ситуацию, в которой они остаются неактивными, а завершение не выполняется.</span><span class="sxs-lookup"><span data-stu-id="7be3a-125">Applications should never encounter a situation where they remain idle and completion never occurs.</span></span>  
  
- <span data-ttu-id="7be3a-126">Обязательно перехватывайте любые исключения, возникающие в асинхронной операции, и назначайте их свойству <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>.</span><span class="sxs-lookup"><span data-stu-id="7be3a-126">Ensure that you catch any exceptions that occur in the asynchronous operation and assign the caught exception to the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property.</span></span>  
  
- <span data-ttu-id="7be3a-127">Если при выполнении задачи возникла ошибка, результаты должны быть недоступны.</span><span class="sxs-lookup"><span data-stu-id="7be3a-127">If there was an error completing the task, the results should not be accessible.</span></span> <span data-ttu-id="7be3a-128">Когда свойство <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> имеет значение, отличное от `null`, убедитесь, что обращение к любому свойству в структуре <xref:System.EventArgs> вызывает исключение.</span><span class="sxs-lookup"><span data-stu-id="7be3a-128">When the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property is not `null`, ensure that accessing any property in the <xref:System.EventArgs> structure raises an exception.</span></span> <span data-ttu-id="7be3a-129">Для выполнения этой проверки используйте метод <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A>.</span><span class="sxs-lookup"><span data-stu-id="7be3a-129">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> method to perform this verification.</span></span>  
  
- <span data-ttu-id="7be3a-130">Смоделируйте истечение времени ожидания в качестве ошибки.</span><span class="sxs-lookup"><span data-stu-id="7be3a-130">Model a time out as an error.</span></span> <span data-ttu-id="7be3a-131">Когда время ожидания истечет, вызовите событие <em>имя_метода</em>**Completed** и назначьте свойству <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> значение <xref:System.TimeoutException>.</span><span class="sxs-lookup"><span data-stu-id="7be3a-131">When a time out occurs, raise the <em>MethodName</em>**Completed** event and assign a <xref:System.TimeoutException> to the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property.</span></span>  
  
- <span data-ttu-id="7be3a-132">Если класс поддерживает несколько одновременных вызовов, убедитесь, что событие <em>имя_метода</em>**Completed** содержит соответствующий объект `userSuppliedState`.</span><span class="sxs-lookup"><span data-stu-id="7be3a-132">If your class supports multiple concurrent invocations, ensure that the <em>MethodName</em>**Completed** event contains the appropriate `userSuppliedState` object.</span></span>  
  
- <span data-ttu-id="7be3a-133">Убедитесь, что событие <em>имя_метода</em>**Completed** создается в правильном потоке и в правильном периоде жизненного цикла приложения.</span><span class="sxs-lookup"><span data-stu-id="7be3a-133">Ensure that the <em>MethodName</em>**Completed** event is raised on the appropriate thread and at the appropriate time in the application lifecycle.</span></span> <span data-ttu-id="7be3a-134">Дополнительные сведения см. в разделе "Потоки и контексты".</span><span class="sxs-lookup"><span data-stu-id="7be3a-134">For more information, see the Threading and Contexts section.</span></span>  
  
### <a name="simultaneously-executing-operations"></a><span data-ttu-id="7be3a-135">Одновременное выполнение операций</span><span class="sxs-lookup"><span data-stu-id="7be3a-135">Simultaneously Executing Operations</span></span>  
  
- <span data-ttu-id="7be3a-136">Если класс поддерживает несколько одновременных вызовов, предоставьте разработчику возможность отслеживать каждый вызов по отдельности, определив перегрузку <em>имя_метода</em>**Async**, которая принимает объект состояния или идентификатор задачи в параметре с именем `userSuppliedState`.</span><span class="sxs-lookup"><span data-stu-id="7be3a-136">If your class supports multiple concurrent invocations, enable the developer to track each invocation separately by defining the <em>MethodName</em>**Async** overload that takes an object-valued state parameter, or task ID, called `userSuppliedState`.</span></span> <span data-ttu-id="7be3a-137">Этот параметр должен всегда стоять последним в сигнатуре метода <em>имя_метода</em>**Async**.</span><span class="sxs-lookup"><span data-stu-id="7be3a-137">This parameter should always be the last parameter in the <em>MethodName</em>**Async** method's signature.</span></span>  
  
- <span data-ttu-id="7be3a-138">Если класс определяет перегрузку <em>имя_метода</em>**Async**, которая принимает параметр с объектом состояния или идентификатором задачи, обязательно отслеживайте время существования операции с этим идентификатором задачи и возвращайте его в завершающий обработчик.</span><span class="sxs-lookup"><span data-stu-id="7be3a-138">If your class defines the <em>MethodName</em>**Async** overload that takes an object-valued state parameter, or task ID, be sure to track the lifetime of the operation with that task ID, and be sure to provide it back into the completion handler.</span></span> <span data-ttu-id="7be3a-139">Можно использовать доступные вспомогательные классы.</span><span class="sxs-lookup"><span data-stu-id="7be3a-139">There are helper classes available to assist.</span></span> <span data-ttu-id="7be3a-140">Дополнительные сведения об управлении параллелизмом см. в разделе [Практическое руководство. Реализация компонента, поддерживающего асинхронную модель на основе событий](component-that-supports-the-event-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="7be3a-140">For more information on concurrency management, see [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](component-that-supports-the-event-based-asynchronous-pattern.md).</span></span>  
  
- <span data-ttu-id="7be3a-141">Если класс определяет метод <em>имя_метода</em>**Async** без параметра состояния и не поддерживает несколько одновременных вызовов, обязательно создавайте исключение <xref:System.InvalidOperationException> при любой попытке вызова <em>имя_метода</em>**Async** до завершения предыдущего вызова <em>имя_метода</em>**Async**.</span><span class="sxs-lookup"><span data-stu-id="7be3a-141">If your class defines the <em>MethodName</em>**Async** method without the state parameter, and it does not support multiple concurrent invocations, ensure that any attempt to invoke <em>MethodName</em>**Async** before the prior <em>MethodName</em>**Async** invocation has completed raises an <xref:System.InvalidOperationException>.</span></span>  
  
- <span data-ttu-id="7be3a-142">Обычно не нужно создавать исключение, если метод <em>имя_метода</em>**Async** вызывается несколько раз без параметра `userSuppliedState`, то есть создает несколько операций, ожидающих выполнения.</span><span class="sxs-lookup"><span data-stu-id="7be3a-142">In general, do not raise an exception if the <em>MethodName</em>**Async** method without the `userSuppliedState` parameter is invoked multiple times so that there are multiple outstanding operations.</span></span> <span data-ttu-id="7be3a-143">Вы можете создать исключение, когда ваш класс явным образом не может разрешить возникшую ситуацию, но вы предполагаете, что разработчики могут обработать несколько этих неразличимых обратных вызовов.</span><span class="sxs-lookup"><span data-stu-id="7be3a-143">You can raise an exception when your class explicitly cannot handle that situation, but assume that developers can handle these multiple indistinguishable callbacks</span></span>  
  
### <a name="accessing-results"></a><span data-ttu-id="7be3a-144">Доступ к результатам</span><span class="sxs-lookup"><span data-stu-id="7be3a-144">Accessing Results</span></span>  
  
- <span data-ttu-id="7be3a-145">Если во время выполнения асинхронной операции возникла ошибка, результаты должны быть недоступны.</span><span class="sxs-lookup"><span data-stu-id="7be3a-145">If there was an error during execution of the asynchronous operation, the results should not be accessible.</span></span> <span data-ttu-id="7be3a-146">Убедитесь, что при обращении к любому свойству в <xref:System.ComponentModel.AsyncCompletedEventArgs>, когда <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> имеет значение, отличное от `null`, возникает исключение, на которое ссылается <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>.</span><span class="sxs-lookup"><span data-stu-id="7be3a-146">Ensure that accessing any property in the <xref:System.ComponentModel.AsyncCompletedEventArgs> when <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> is not `null` raises the exception referenced by <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>.</span></span> <span data-ttu-id="7be3a-147">Для этой цели класс <xref:System.ComponentModel.AsyncCompletedEventArgs> предоставляет метод <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A>.</span><span class="sxs-lookup"><span data-stu-id="7be3a-147">The <xref:System.ComponentModel.AsyncCompletedEventArgs> class provides the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> method for this purpose.</span></span>  
  
- <span data-ttu-id="7be3a-148">Убедитесь, что любая попытка доступа к результату вызывает исключение <xref:System.InvalidOperationException>, указывающее на отмену операции.</span><span class="sxs-lookup"><span data-stu-id="7be3a-148">Ensure that any attempt to access the result raises an <xref:System.InvalidOperationException> stating that the operation was canceled.</span></span> <span data-ttu-id="7be3a-149">Для выполнения этой проверки используйте метод <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7be3a-149">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> method to perform this verification.</span></span>  
  
### <a name="progress-reporting"></a><span data-ttu-id="7be3a-150">Отчет о ходе выполнения</span><span class="sxs-lookup"><span data-stu-id="7be3a-150">Progress Reporting</span></span>  
  
- <span data-ttu-id="7be3a-151">По возможности реализуйте поддержку отчетов о ходе выполнения.</span><span class="sxs-lookup"><span data-stu-id="7be3a-151">Support progress reporting, if possible.</span></span> <span data-ttu-id="7be3a-152">Это позволяет разработчикам улучшить взаимодействие приложения с пользователем при использовании вашего класса.</span><span class="sxs-lookup"><span data-stu-id="7be3a-152">This enables developers to provide a better application user experience when they use your class.</span></span>  
  
- <span data-ttu-id="7be3a-153">Если вы реализуете событие **ProgressChanged** или <em>имя_метода</em>**ProgressChanged**, убедитесь, что такие события не создаются для конкретной асинхронной операции после того, как было создано событие <em>имя_метода</em>**Completed**.</span><span class="sxs-lookup"><span data-stu-id="7be3a-153">If you implement a **ProgressChanged** or <em>MethodName</em>**ProgressChanged** event, ensure that there are no such events raised for a particular asynchronous operation after that operation's <em>MethodName</em>**Completed** event has been raised.</span></span>  
  
- <span data-ttu-id="7be3a-154">Если выполняется заполнение стандартного <xref:System.ComponentModel.ProgressChangedEventArgs>, убедитесь, что <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> всегда можно интерпретировать как процент.</span><span class="sxs-lookup"><span data-stu-id="7be3a-154">If the standard <xref:System.ComponentModel.ProgressChangedEventArgs> is being populated, ensure that the <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> can always be interpreted as a percentage.</span></span> <span data-ttu-id="7be3a-155">Этот процент может быть неточным, однако он всегда должен представлять именно процент.</span><span class="sxs-lookup"><span data-stu-id="7be3a-155">The percentage does not need to be accurate, but it should represent a percentage.</span></span> <span data-ttu-id="7be3a-156">Если ваша метрика отчетов о ходе выполнения должна отличаться от процента, создайте производный класс от класса <xref:System.ComponentModel.ProgressChangedEventArgs> и оставьте для <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> значение 0.</span><span class="sxs-lookup"><span data-stu-id="7be3a-156">If your progress reporting metric must be something other than a percentage, derive a class from the <xref:System.ComponentModel.ProgressChangedEventArgs> class and leave <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> at 0.</span></span> <span data-ttu-id="7be3a-157">Старайтесь не использовать метрику отчетов, отличную от процента.</span><span class="sxs-lookup"><span data-stu-id="7be3a-157">Avoid using a reporting metric other than a percentage.</span></span>  
  
- <span data-ttu-id="7be3a-158">Убедитесь, что событие `ProgressChanged` возникает в соответствующем потоке и в соответствующее время жизненного цикла приложения.</span><span class="sxs-lookup"><span data-stu-id="7be3a-158">Ensure that the `ProgressChanged` event is raised on the appropriate thread and at the appropriate time in the application lifecycle.</span></span> <span data-ttu-id="7be3a-159">Дополнительные сведения см. в разделе "Потоки и контексты".</span><span class="sxs-lookup"><span data-stu-id="7be3a-159">For more information, see the Threading and Contexts section.</span></span>  
  
### <a name="isbusy-implementation"></a><span data-ttu-id="7be3a-160">Реализация IsBusy</span><span class="sxs-lookup"><span data-stu-id="7be3a-160">IsBusy Implementation</span></span>  
  
- <span data-ttu-id="7be3a-161">Не предоставляйте свойство `IsBusy`, если ваш класс поддерживает несколько одновременных вызовов.</span><span class="sxs-lookup"><span data-stu-id="7be3a-161">Do not expose an `IsBusy` property if your class supports multiple concurrent invocations.</span></span> <span data-ttu-id="7be3a-162">Например, прокси-серверы XML-веб-службы не предоставляют свойство `IsBusy`, так как поддерживают несколько одновременных вызовов асинхронных методов.</span><span class="sxs-lookup"><span data-stu-id="7be3a-162">For example, XML Web service proxies do not expose an `IsBusy` property because they support multiple concurrent invocations of asynchronous methods.</span></span>  
  
- <span data-ttu-id="7be3a-163">Свойство `IsBusy` должно возвращать `true` после того, как был вызван метод <em>имя_метода</em>**Async**, но еще не было создано событие <em>имя_метода</em>**Completed**.</span><span class="sxs-lookup"><span data-stu-id="7be3a-163">The `IsBusy` property should return `true` after the <em>MethodName</em>**Async** method has been called and before the <em>MethodName</em>**Completed** event has been raised.</span></span> <span data-ttu-id="7be3a-164">В противном случае оно должно возвратить `false`.</span><span class="sxs-lookup"><span data-stu-id="7be3a-164">Otherwise it should return `false`.</span></span> <span data-ttu-id="7be3a-165">Компоненты <xref:System.ComponentModel.BackgroundWorker> и <xref:System.Net.WebClient> являются примерами классов, которые предоставляют свойство `IsBusy`.</span><span class="sxs-lookup"><span data-stu-id="7be3a-165">The <xref:System.ComponentModel.BackgroundWorker> and <xref:System.Net.WebClient> components are examples of classes that expose an `IsBusy` property.</span></span>  
  
### <a name="cancellation"></a><span data-ttu-id="7be3a-166">Отмена</span><span class="sxs-lookup"><span data-stu-id="7be3a-166">Cancellation</span></span>  
  
- <span data-ttu-id="7be3a-167">По возможности реализуйте поддержку отмены.</span><span class="sxs-lookup"><span data-stu-id="7be3a-167">Support cancellation, if possible.</span></span> <span data-ttu-id="7be3a-168">Это позволяет разработчикам улучшить взаимодействие приложения с пользователем при использовании вашего класса.</span><span class="sxs-lookup"><span data-stu-id="7be3a-168">This enables developers to provide a better application user experience when they use your class.</span></span>  
  
- <span data-ttu-id="7be3a-169">В случае отмены установите флаг <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> в объекте <xref:System.ComponentModel.AsyncCompletedEventArgs>.</span><span class="sxs-lookup"><span data-stu-id="7be3a-169">In the case of cancellation, set the <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> flag in the <xref:System.ComponentModel.AsyncCompletedEventArgs> object.</span></span>  
  
- <span data-ttu-id="7be3a-170">Убедитесь, что любая попытка доступа к результату вызывает исключение <xref:System.InvalidOperationException>, указывающее на отмену операции.</span><span class="sxs-lookup"><span data-stu-id="7be3a-170">Ensure that any attempt to access the result raises an <xref:System.InvalidOperationException> stating that the operation was canceled.</span></span> <span data-ttu-id="7be3a-171">Для выполнения этой проверки используйте метод <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7be3a-171">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> method to perform this verification.</span></span>  
  
- <span data-ttu-id="7be3a-172">Убедитесь, что вызовы метода отмены всегда возвращаются и никогда не вызывают исключение.</span><span class="sxs-lookup"><span data-stu-id="7be3a-172">Ensure that calls to a cancellation method always return successfully, and never raise an exception.</span></span> <span data-ttu-id="7be3a-173">В общем случае клиент не получает уведомление о том, можно ли отменить операцию в любой заданный момент времени и была ли успешной выданная ранее команда отмены.</span><span class="sxs-lookup"><span data-stu-id="7be3a-173">In general, a client is not notified as to whether an operation is truly cancelable at any given time, and is not notified as to whether a previously issued cancellation has succeeded.</span></span> <span data-ttu-id="7be3a-174">Однако приложение всегда получает уведомление об успешной отмене, так как оно принимает участие в установке состояния завершения.</span><span class="sxs-lookup"><span data-stu-id="7be3a-174">However, the application will always be given notification when a cancellation succeeded, because the application takes part in the completion status.</span></span>  
  
- <span data-ttu-id="7be3a-175">При отмене операции создайте событие <em>имя_метода</em>**Completed**.</span><span class="sxs-lookup"><span data-stu-id="7be3a-175">Raise the <em>MethodName</em>**Completed** event when the operation is canceled.</span></span>  
  
### <a name="errors-and-exceptions"></a><span data-ttu-id="7be3a-176">Ошибки и исключения</span><span class="sxs-lookup"><span data-stu-id="7be3a-176">Errors and Exceptions</span></span>  
  
- <span data-ttu-id="7be3a-177">Перехватывайте любые исключения, возникающие в асинхронной операции, и назначайте их в качестве значения свойства <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7be3a-177">Catch any exceptions that occur in the asynchronous operation and set the value of the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> property to that exception.</span></span>  
  
### <a name="threading-and-contexts"></a><span data-ttu-id="7be3a-178">Потоки и контексты</span><span class="sxs-lookup"><span data-stu-id="7be3a-178">Threading and Contexts</span></span>  
 <span data-ttu-id="7be3a-179">Для правильной работы вашего класса крайне важно, чтобы обработчики событий клиента вызывались в правильном потоке или контексте для заданной модели приложения, включая приложения Windows Forms и ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="7be3a-179">For correct operation of your class, it is critical that the client's event handlers are invoked on the proper thread or context for the given application model, including ASP.NET and Windows Forms applications.</span></span> <span data-ttu-id="7be3a-180">Доступно два важных вспомогательных класса, позволяющих проверить, правильно ли себя ведет ваш асинхронный класс при любой модели приложения: <xref:System.ComponentModel.AsyncOperation> и <xref:System.ComponentModel.AsyncOperationManager>.</span><span class="sxs-lookup"><span data-stu-id="7be3a-180">Two important helper classes are provided to ensure that your asynchronous class behaves correctly under any application model: <xref:System.ComponentModel.AsyncOperation> and <xref:System.ComponentModel.AsyncOperationManager>.</span></span>  
  
 <span data-ttu-id="7be3a-181"><xref:System.ComponentModel.AsyncOperationManager> предоставляет один метод <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>, который возвращает <xref:System.ComponentModel.AsyncOperation>.</span><span class="sxs-lookup"><span data-stu-id="7be3a-181"><xref:System.ComponentModel.AsyncOperationManager> provides one method, <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>, which returns an <xref:System.ComponentModel.AsyncOperation>.</span></span> <span data-ttu-id="7be3a-182">Метод <em>имя_метода</em>**Async** вызывает <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>, а класс использует возвращенное значение <xref:System.ComponentModel.AsyncOperation>, чтобы отследить время существования асинхронной задачи.</span><span class="sxs-lookup"><span data-stu-id="7be3a-182">Your <em>MethodName</em>**Async** method calls <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A> and your class uses the returned <xref:System.ComponentModel.AsyncOperation> to track the lifetime of the asynchronous task.</span></span>  
  
 <span data-ttu-id="7be3a-183">Чтобы сообщить клиенту о ходе выполнения, добавочных результатах и завершении, выполните вызов методов <xref:System.ComponentModel.AsyncOperation.Post%2A> и <xref:System.ComponentModel.AsyncOperation.OperationCompleted%2A> для <xref:System.ComponentModel.AsyncOperation>.</span><span class="sxs-lookup"><span data-stu-id="7be3a-183">To report progress, incremental results, and completion to the client, call the <xref:System.ComponentModel.AsyncOperation.Post%2A> and <xref:System.ComponentModel.AsyncOperation.OperationCompleted%2A> methods on the <xref:System.ComponentModel.AsyncOperation>.</span></span> <span data-ttu-id="7be3a-184"><xref:System.ComponentModel.AsyncOperation> отвечает за маршалинг вызовов обработчиков событий клиента в подходящий поток или контекст.</span><span class="sxs-lookup"><span data-stu-id="7be3a-184"><xref:System.ComponentModel.AsyncOperation> is responsible for marshaling calls to the client's event handlers to the proper thread or context.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="7be3a-185">Вы можете не соблюдать эти правила, если хотите явно нарушить политику модели приложения, но при этом воспользоваться другими преимуществами асинхронной модели на основе событий.</span><span class="sxs-lookup"><span data-stu-id="7be3a-185">You can circumvent these rules if you explicitly want to go against the policy of the application model, but still benefit from the other advantages of using the Event-based Asynchronous Pattern.</span></span> <span data-ttu-id="7be3a-186">Например, вам может понадобиться, чтобы класс, работающий в Windows Forms, был со свободным потоком.</span><span class="sxs-lookup"><span data-stu-id="7be3a-186">For example, you may want a class operating in Windows Forms to be free threaded.</span></span> <span data-ttu-id="7be3a-187">Вы можете создать класс со свободным потоком, если разработчики осознают накладываемые этим ограничения.</span><span class="sxs-lookup"><span data-stu-id="7be3a-187">You can create a free threaded class, as long as developers understand the implied restrictions.</span></span> <span data-ttu-id="7be3a-188">Консольные приложения не синхронизируют выполнение вызовов <xref:System.ComponentModel.AsyncOperation.Post%2A>.</span><span class="sxs-lookup"><span data-stu-id="7be3a-188">Console applications do not synchronize the execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls.</span></span> <span data-ttu-id="7be3a-189">Это может вызвать беспорядочное возникновение событий `ProgressChanged`.</span><span class="sxs-lookup"><span data-stu-id="7be3a-189">This can cause `ProgressChanged` events to be raised out of order.</span></span> <span data-ttu-id="7be3a-190">Если вы хотите получить сериализованное выполнение вызовов <xref:System.ComponentModel.AsyncOperation.Post%2A>, реализуйте и установите класс <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7be3a-190">If you wish to have serialized execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls, implement and install a <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType> class.</span></span>  
  
 <span data-ttu-id="7be3a-191">Дополнительные сведения об использовании <xref:System.ComponentModel.AsyncOperation> и <xref:System.ComponentModel.AsyncOperationManager> для включения асинхронных операций см. в разделе [Практическое руководство. Реализация компонента, поддерживающего асинхронную модель на основе событий](component-that-supports-the-event-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="7be3a-191">For more information about using <xref:System.ComponentModel.AsyncOperation> and <xref:System.ComponentModel.AsyncOperationManager> to enable your asynchronous operations, see [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](component-that-supports-the-event-based-asynchronous-pattern.md).</span></span>  
  
## <a name="guidelines"></a><span data-ttu-id="7be3a-192">Рекомендации</span><span class="sxs-lookup"><span data-stu-id="7be3a-192">Guidelines</span></span>  
  
- <span data-ttu-id="7be3a-193">В идеале каждый вызов метода должен быть независимым от остальных.</span><span class="sxs-lookup"><span data-stu-id="7be3a-193">Ideally, each method invocation should be independent of others.</span></span> <span data-ttu-id="7be3a-194">Вам следует избегать установления взаимозависимости вызовов посредством общих ресурсов.</span><span class="sxs-lookup"><span data-stu-id="7be3a-194">You should avoid coupling invocations with shared resources.</span></span> <span data-ttu-id="7be3a-195">Если требуется общий доступ вызовов к ресурсам, в реализации необходимо обеспечить подходящий механизм синхронизации.</span><span class="sxs-lookup"><span data-stu-id="7be3a-195">If resources are to be shared among invocations, you will need to provide a proper synchronization mechanism in your implementation.</span></span>  
  
- <span data-ttu-id="7be3a-196">Варианты, в которых клиенту требуется реализовать синхронизацию, использовать не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="7be3a-196">Designs that require the client to implement synchronization are discouraged.</span></span> <span data-ttu-id="7be3a-197">Например, у вас может быть асинхронный метод, принимающий в качестве параметра глобальный статический объект; несколько одновременных вызовов такого метода могут привести к повреждению данных или взаимоблокировкам.</span><span class="sxs-lookup"><span data-stu-id="7be3a-197">For example, you could have an asynchronous method that receives a global static object as a parameter; multiple concurrent invocations of such a method could result in data corruption or deadlocks.</span></span>  
  
- <span data-ttu-id="7be3a-198">Если вы реализуете метод с перегрузкой с несколькими вызовами (`userState` в сигнатуре), вашему классу потребуется управлять коллекцией пользовательских состояний (или идентификаторов задачи) и соответствующих им ожидающих операций.</span><span class="sxs-lookup"><span data-stu-id="7be3a-198">If you implement a method with the multiple-invocation overload (`userState` in the signature), your class will need to manage a collection of user states, or task IDs, and their corresponding pending operations.</span></span> <span data-ttu-id="7be3a-199">Эту коллекцию следует защитить областями `lock`, так как различные вызовы добавляют и удаляют объекты `userState` в ней.</span><span class="sxs-lookup"><span data-stu-id="7be3a-199">This collection should be protected with `lock` regions, because the various invocations add and remove `userState` objects in the collection.</span></span>  
  
- <span data-ttu-id="7be3a-200">Рекомендуется повторно использовать классы `CompletedEventArgs`, когда это возможно и уместно.</span><span class="sxs-lookup"><span data-stu-id="7be3a-200">Consider reusing `CompletedEventArgs` classes where feasible and appropriate.</span></span> <span data-ttu-id="7be3a-201">В этом случае именование не соответствует имени метода, так как заданный делегат и тип <xref:System.EventArgs> не привязаны к одному методу.</span><span class="sxs-lookup"><span data-stu-id="7be3a-201">In this case, the naming is not consistent with the method name, because a given delegate and <xref:System.EventArgs> type are not tied to a single method.</span></span> <span data-ttu-id="7be3a-202">Однако ни в коем случае нельзя принуждать разработчиков выполнить приведение значения, полученного из свойства в <xref:System.EventArgs>.</span><span class="sxs-lookup"><span data-stu-id="7be3a-202">However, forcing developers to cast the value retrieved from a property on the <xref:System.EventArgs> is never acceptable.</span></span>  
  
- <span data-ttu-id="7be3a-203">Если вы создаете класс, являющийся производным от <xref:System.ComponentModel.Component>, не реализуйте и не устанавливайте свой собственный класс <xref:System.Threading.SynchronizationContext>.</span><span class="sxs-lookup"><span data-stu-id="7be3a-203">If you are authoring a class that derives from <xref:System.ComponentModel.Component>, do not implement and install your own <xref:System.Threading.SynchronizationContext> class.</span></span> <span data-ttu-id="7be3a-204">Используемый <xref:System.Threading.SynchronizationContext> определяют модели приложения, а не компоненты.</span><span class="sxs-lookup"><span data-stu-id="7be3a-204">Application models, not components, control the <xref:System.Threading.SynchronizationContext> that is used.</span></span>  
  
- <span data-ttu-id="7be3a-205">При использовании любого вида многопоточности вы создаете условия для возникновения очень серьезных и сложных ошибок.</span><span class="sxs-lookup"><span data-stu-id="7be3a-205">When you use multithreading of any sort, you potentially expose yourself to very serious and complex bugs.</span></span> <span data-ttu-id="7be3a-206">Перед реализацией любого решения, в котором используется многопоточность, ознакомьтесь с разделом [Рекомендации по работе с потоками](../threading/managed-threading-best-practices.md).</span><span class="sxs-lookup"><span data-stu-id="7be3a-206">Before implementing any solution that uses multithreading, see [Managed Threading Best Practices](../threading/managed-threading-best-practices.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="7be3a-207">См. также</span><span class="sxs-lookup"><span data-stu-id="7be3a-207">See also</span></span>

- <xref:System.ComponentModel.AsyncOperation>
- <xref:System.ComponentModel.AsyncOperationManager>
- <xref:System.ComponentModel.AsyncCompletedEventArgs>
- <xref:System.ComponentModel.ProgressChangedEventArgs>
- <xref:System.ComponentModel.BackgroundWorker>
- [<span data-ttu-id="7be3a-208">Реализация асинхронной модели, основанной на событиях</span><span class="sxs-lookup"><span data-stu-id="7be3a-208">Implementing the Event-based Asynchronous Pattern</span></span>](implementing-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="7be3a-209">Асинхронная модель на основе событий (EAP)</span><span class="sxs-lookup"><span data-stu-id="7be3a-209">Event-based Asynchronous Pattern (EAP)</span></span>](event-based-asynchronous-pattern-eap.md)
- [<span data-ttu-id="7be3a-210">Определение, когда следует реализовать асинхронную модель, основанную на событиях</span><span class="sxs-lookup"><span data-stu-id="7be3a-210">Deciding When to Implement the Event-based Asynchronous Pattern</span></span>](deciding-when-to-implement-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="7be3a-211">Рекомендации по реализации асинхронной модели, основанной на событиях</span><span class="sxs-lookup"><span data-stu-id="7be3a-211">Best Practices for Implementing the Event-based Asynchronous Pattern</span></span>](best-practices-for-implementing-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="7be3a-212">Практическое руководство. Использование компонентов, поддерживающих асинхронную модель, основанную на событиях</span><span class="sxs-lookup"><span data-stu-id="7be3a-212">How to: Use Components That Support the Event-based Asynchronous Pattern</span></span>](how-to-use-components-that-support-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="7be3a-213">Практическое руководство. Реализация компонента, поддерживающего асинхронную модель на основе событий</span><span class="sxs-lookup"><span data-stu-id="7be3a-213">How to: Implement a Component That Supports the Event-based Asynchronous Pattern</span></span>](component-that-supports-the-event-based-asynchronous-pattern.md)
