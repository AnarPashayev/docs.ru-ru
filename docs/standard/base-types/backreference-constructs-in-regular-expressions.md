---
title: Конструкции обратных ссылок в регулярных выражениях .NET
description: В этой статье описывается, как определять повторяемые элементы текста, используя конструкции обратных ссылок в регулярном выражении.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- backreferences
- constructs, backreference
- .NET Framework regular expressions, backreference constructs
- regular expressions, backreference constructs
ms.assetid: 567a4b8d-0e79-49dc-8df9-f4b1aa376a2a
ms.custom: seodec18
ms.openlocfilehash: e41c333dc088c8f712866cb7a130c4f8e1c9722f
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/30/2019
ms.locfileid: "73140533"
---
# <a name="backreference-constructs-in-regular-expressions"></a>Конструкции обратных ссылок в регулярных выражениях

Обратные ссылки предоставляют удобный способ идентификации повторяющегося символа или подстроки в строке. Например, если входная строка содержит несколько экземпляров произвольной подстроки, можно найти первое вхождение с помощью группы записи, а затем использовать обратную ссылку для поиска последующих вхождений подстроки.

> [!NOTE]
> Для ссылки на именованные и нумерованные захватываемые группы в строках замены используется отдельный синтаксис. Для получения дополнительной информации см. [Подстановки](substitutions-in-regular-expressions.md).

.NET определяет отдельные элементы языка для ссылки на нумерованные и именованные захватываемые группы. Дополнительные сведения о группах записи см. в статье [Конструкции группирования](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).

## <a name="numbered-backreferences"></a>Нумерованные обратные ссылки

Нумерованная обратная ссылка использует следующий синтаксис:

`\` *число*

где *число* — это порядковое положение захватываемой группы в регулярном выражении. Например, `\4` соответствует содержимому четвертой захватываемой группы. Если параметр *число* не определен в шаблоне регулярного выражения, возникает ошибка синтаксического анализа, и обработчик регулярных выражений создает исключение <xref:System.ArgumentException>. Например, регулярное выражение `\b(\w+)\s\1` является допустимым, поскольку `(\w+)` — это первая и единственная захватываемая группа в выражении. С другой стороны, выражение `\b(\w+)\s\2` недопустимо и создает исключение аргумента, так как захватываемая группа с номером `\2` отсутствует. Кроме того, если *число* определяет захватываемую группу с определенным порядковым номером, но захватываемой группе назначено числовое имя, отличное от ее порядкового номера, то анализатор регулярных выражений также создает исключение <xref:System.ArgumentException>.

Следует отметить неоднозначность такой записи, которая может означать как восьмеричные escape-коды (например, `\16`), так и `\`*число* для обратных ссылок. Эта неопределенность разрешается следующим образом:

- Выражения с `\1` по `\9` всегда интерпретируются как обратные ссылки, а не как восьмеричные коды.

- Если первая цифра многоразрядного выражения — 8 или 9 (например, `\80` или `\91`), выражение интерпретируется как литерал.

- Выражения от `\10` и более считаются обратными ссылками, если имеется обратная ссылка, соответствующая этому номеру. В противном случае они интерпретируются как восьмеричные коды.

- Если регулярное выражение содержит обратную ссылку на неопределенный номер группы, возникает ошибка синтаксического анализа, и обработчик регулярных выражений создает исключение <xref:System.ArgumentException>.

Если неоднозначность представляет проблему, можно использовать однозначное представление `\k<`*name*`>`, которое невозможно спутать с восьмеричными кодами символов. Аналогичным образом шестнадцатеричные коды, например `\xdd`, однозначны, и их нельзя спутать с обратными ссылками.

В приведенном ниже примере в строке выделяются двойные словообразующие символы. Здесь определяется регулярное выражение, `(\w)\1`, которое состоит из следующих элементов.

|Элемент|ОПИСАНИЕ|
|-------------|-----------------|
|`(\w)`|Совпадение со словообразующим символом и его назначение первой захватываемой группе.|
|`\1`|Совпадение со следующим символом, значение которого совпадает с первой захватываемой группой.|

[!code-csharp[RegularExpressions.Language.Backreferences#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.backreferences/cs/backreference1.cs#1)]
[!code-vb[RegularExpressions.Language.Backreferences#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.backreferences/vb/backreference1.vb#1)]

## <a name="named-backreferences"></a>Именованные обратные ссылки

Именованная обратная ссылка задается с помощью следующего синтаксиса:

`\k<` *имя* `>`

или

`\k'` *имя* `'`

где *name*— это имя захватываемой группы, определенное в шаблоне регулярного выражения. Если параметр *имя* не определен в шаблоне регулярного выражения, возникает ошибка синтаксического анализа, и обработчик регулярных выражений создает исключение <xref:System.ArgumentException>.

В приведенном ниже примере в строке выделяются двойные словообразующие символы. Здесь определяется регулярное выражение, `(?<char>\w)\k<char>`, которое состоит из следующих элементов.

|Элемент|ОПИСАНИЕ|
|-------------|-----------------|
|`(?<char>\w)`|Сопоставляется с буквенным символом и назначает его группе записи с именем `char`.|
|`\k<char>`|Сопоставляется со следующим символом, значение которого совпадает со значением группы записи `char`.|

[!code-csharp[RegularExpressions.Language.Backreferences#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.backreferences/cs/backreference2.cs#2)]
[!code-vb[RegularExpressions.Language.Backreferences#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.backreferences/vb/backreference2.vb#2)]

## <a name="named-numeric-backreferences"></a>Именованные числовые обратные ссылки

В именованной обратной ссылке с `\k` *имя* также может быть строковым представлением числа. Например, далее используется регулярное выражение `(?<2>\w)\k<2>` для поиска в строке двойных словообразующих символов. В этом случае в примере определяется захватываемая группа, которая явно названа "2", и обратная ссылка, соответственно названная "2".

[!code-csharp[RegularExpressions.Language.Backreferences#3](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.backreferences/cs/backreference3.cs#3)]
[!code-vb[RegularExpressions.Language.Backreferences#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.backreferences/vb/backreference3.vb#3)]

Если *имя* является строковым представлением числа и не существует захватываемой группы с таким именем, то `\k<`*имя*`>` совпадает со значением обратной ссылки `\` *номер*, где *номер* — порядковый номер записи. В следующем примере существует одна захватываемая группа с именем `char`. Конструкция обратной ссылки ссылается на нее как `\k<1>`. Как видно из результата выполнения примера, вызов <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> завершается успешно, поскольку `char` является первой группой записи.

[!code-csharp[Ordinal.Backreference](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.backreferences/cs/backreference6.cs)]
[!code-vb[Ordinal.BackReference](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.backreferences/vb/backreference6.vb)]

Однако, если *имя* является строковым представлением числа и захватываемой группе на этой позиции явно назначено числовое имя, обработчик регулярных выражений не сможет идентифицировать захватываемую группу по ее порядковому номеру. Вместо этого он создаст исключение <xref:System.ArgumentException>. Единственная захватываемая группа в следующем примере имеет имя "2". Поскольку конструкция `\k` используется для определения обратных ссылок с именем "1", обработчик регулярных выражений не может идентифицировать первую группу записи и вызывает исключение.

[!code-csharp[Ordinal.Backreference](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.backreferences/cs/backreference7.cs)]
[!code-vb[Ordinal.BackReference](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.backreferences/vb/backreference7.vb)]

## <a name="what-backreferences-match"></a>С чем сопоставляются обратные ссылки

Обратная ссылка относится к самому недавнему определению группы (самому ближнему слева определению при обработке слева направо). Если из группы создается несколько шаблонов для поиска, обратная ссылка относится к самому последнему шаблону.

В примере ниже показан шаблон регулярного выражения `(?<1>a)(?<1>\1b)*`, который переопределяет именованную группу \1. В следующей таблице описывается каждый шаблон регулярного выражения.

|Шаблон|ОПИСАНИЕ|
|-------------|-----------------|
|`(?<1>a)`|Сопоставляется с символом "a" и назначает его значение группе записи с именем `1`.|
|`(?<1>\1b)*`|Сопоставляется с нулем или одним вхождением группы с именем `1` рядом с символом "b" и назначает полученное значение группе записи с именем `1`.|

[!code-csharp[RegularExpressions.Language.Backreferences#4](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.backreferences/cs/backreference4.cs#4)]
[!code-vb[RegularExpressions.Language.Backreferences#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.backreferences/vb/backreference4.vb#4)]

При сравнении регулярного выражения с входной строкой ("aababb") обработчик регулярных выражений выполняет указанные далее операции.

1. Начинается с первого символа и успешно сопоставляет "a" с выражением `(?<1>a)`. Теперь значение группы `1` будет равно "a".

2. Перемещается ко второму символу и успешно сопоставляет строку "ab" с выражением `\1b` или "ab". Затем результат "ab" присваивается `\1`.

3. Переходит к четвертому символу. Выражение `(?<1>\1b)*` должно выдать ноль или больше совпадений, поэтому он успешно сопоставляет строку "abb" с выражением `\1b`. Затем результат "abb" присваивается `\1`.

В этом примере `*` является циклическим квантификатором — он вычисляется многократно до тех пор, пока обработчик регулярных выражений не сможет обнаружить соответствие заданному им шаблону. Квантификаторы циклов не удаляют определения групп.

Если для группы не было найдено ни одной подстроки, то обратная ссылка на эту группу не определена и не работает. Это продемонстрировано в шаблоне регулярного выражения `\b(\p{Lu}{2})(\d{2})?(\p{Lu}{2})\b`, который определяется следующим образом:

|Шаблон|ОПИСАНИЕ|
|-------------|-----------------|
|`\b`|Сопоставление начинается на границе слова.|
|`(\p{Lu}{2})`|Совпадение с двумя прописными буквами. Это первая группа записи.|
|`(\d{2})?`|Совпадение с нулевым или единичным вхождением двух десятичных цифр. Это вторая группа записи.|
|`(\p{Lu}{2})`|Совпадение с двумя прописными буквами. Это третья группа записи.|
|`\b`|Сопоставление заканчивается на границе слова.|

Входная строка может соответствовать этому регулярному выражению, даже если отсутствуют две десятичные цифры, которые заданы второй захватываемой группой. В следующем примере показано, что даже несмотря на то, что сопоставление является успешным, между двумя группами успешной записи найдена пустая группа.

[!code-csharp[RegularExpressions.Language.Backreferences#5](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.backreferences/cs/backreference5.cs#5)]
[!code-vb[RegularExpressions.Language.Backreferences#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.backreferences/vb/backreference5.vb#5)]

## <a name="see-also"></a>См. также

- [Элементы языка регулярных выражений — краткий справочник](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)
