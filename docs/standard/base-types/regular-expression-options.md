---
title: Параметры регулярных выражений
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, options
- constructs, options
- .NET Framework regular expressions, options
- inline option constructs
- options parameter
ms.assetid: c82dc689-7e82-4767-a18d-cd24ce5f05e9
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 5e77fac49db4a2faadb5785c4ef15e401f340d8b
ms.sourcegitcommit: d6e27023aeaffc4b5a3cb4b88685018d6284ada4
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/09/2019
ms.locfileid: "67663981"
---
# <a name="regular-expression-options"></a><span data-ttu-id="f1adb-102">Параметры регулярных выражений</span><span class="sxs-lookup"><span data-stu-id="f1adb-102">Regular Expression Options</span></span>

<a name="Top"></a> <span data-ttu-id="f1adb-103">По умолчанию при сравнении входной строки с любыми литеральными символами в шаблоне регулярного выражения учитывается регистр, пробел в шаблоне интерпретируется как литеральный символ, а захватываемые группы в регулярном выражении именуются как явно, так и неявно.</span><span class="sxs-lookup"><span data-stu-id="f1adb-103">By default, the comparison of an input string with any literal characters in a regular expression pattern is case sensitive, white space in a regular expression pattern is interpreted as literal white-space characters, and capturing groups in a regular expression are named implicitly as well as explicitly.</span></span> <span data-ttu-id="f1adb-104">Вы можете изменить эти и некоторые другие аспекты поведения регулярного выражения по умолчанию с помощью параметров регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="f1adb-104">You can modify these and several other aspects of default regular expression behavior by specifying regular expression options.</span></span> <span data-ttu-id="f1adb-105">Эти параметры, которые представлены в следующей таблице, могут быть указаны как часть шаблона регулярного выражения или переданы конструктору класса <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> или статичному методу сопоставления шаблона как значение перечисления <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f1adb-105">These options, which are listed in the following table, can be included inline as part of the regular expression pattern, or they can be supplied to a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or static pattern matching method as a <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> enumeration value.</span></span>

|<span data-ttu-id="f1adb-106">Член RegexOptions</span><span class="sxs-lookup"><span data-stu-id="f1adb-106">RegexOptions member</span></span>|<span data-ttu-id="f1adb-107">Встроенный символ</span><span class="sxs-lookup"><span data-stu-id="f1adb-107">Inline character</span></span>|<span data-ttu-id="f1adb-108">Действие</span><span class="sxs-lookup"><span data-stu-id="f1adb-108">Effect</span></span>|
|-------------------------|----------------------|------------|
|<xref:System.Text.RegularExpressions.RegexOptions.None>|<span data-ttu-id="f1adb-109">Недоступно</span><span class="sxs-lookup"><span data-stu-id="f1adb-109">Not available</span></span>|<span data-ttu-id="f1adb-110">Использовать поведение по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f1adb-110">Use default behavior.</span></span> <span data-ttu-id="f1adb-111">Дополнительные сведения см. в разделе [Параметры по умолчанию](#Default).</span><span class="sxs-lookup"><span data-stu-id="f1adb-111">For more information, see [Default Options](#Default).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase>|`i`|<span data-ttu-id="f1adb-112">Использовать соответствие без учета регистра.</span><span class="sxs-lookup"><span data-stu-id="f1adb-112">Use case-insensitive matching.</span></span> <span data-ttu-id="f1adb-113">Дополнительные сведения см. в разделе [Сопоставление без учета регистра](#Case).</span><span class="sxs-lookup"><span data-stu-id="f1adb-113">For more information, see [Case-Insensitive Matching](#Case).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.Multiline>|`m`|<span data-ttu-id="f1adb-114">Использовать многострочный режим, где `^` и `$` соответствуют началу и концу строки текста (а не началу и концу входной строки).</span><span class="sxs-lookup"><span data-stu-id="f1adb-114">Use multiline mode, where `^` and `$` match the beginning and end of each line (instead of the beginning and end of the input string).</span></span> <span data-ttu-id="f1adb-115">Дополнительные сведения см. в разделе [Многострочный режим](#Multiline).</span><span class="sxs-lookup"><span data-stu-id="f1adb-115">For more information, see [Multiline Mode](#Multiline).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.Singleline>|`s`|<span data-ttu-id="f1adb-116">Использовать однострочный режим, где точка (.) соответствует любому символу (а не каждому символу, кроме `\n`).</span><span class="sxs-lookup"><span data-stu-id="f1adb-116">Use single-line mode, where the period (.) matches every character (instead of every character except `\n`).</span></span> <span data-ttu-id="f1adb-117">Дополнительные сведения см. в разделе [Однострочный режим](#Singleline).</span><span class="sxs-lookup"><span data-stu-id="f1adb-117">For more information, see [Singleline Mode](#Singleline).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture>|`n`|<span data-ttu-id="f1adb-118">Не захватывать неименованные группы.</span><span class="sxs-lookup"><span data-stu-id="f1adb-118">Do not capture unnamed groups.</span></span> <span data-ttu-id="f1adb-119">К допустимым захватам относятся только явно именованные или нумерованные группы в формате `(?<`*name*`>` *subexpression*`)`.</span><span class="sxs-lookup"><span data-stu-id="f1adb-119">The only valid captures are explicitly named or numbered groups of the form `(?<`*name*`>` *subexpression*`)`.</span></span> <span data-ttu-id="f1adb-120">Дополнительные сведения см. в разделе [Только явные захваты](#Explicit).</span><span class="sxs-lookup"><span data-stu-id="f1adb-120">For more information, see [Explicit Captures Only](#Explicit).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.Compiled>|<span data-ttu-id="f1adb-121">Недоступно</span><span class="sxs-lookup"><span data-stu-id="f1adb-121">Not available</span></span>|<span data-ttu-id="f1adb-122">Скомпилировать регулярное выражение в сборку.</span><span class="sxs-lookup"><span data-stu-id="f1adb-122">Compile the regular expression to an assembly.</span></span> <span data-ttu-id="f1adb-123">Дополнительные сведения см. в разделе [Скомпилированные регулярные выражения](#Compiled).</span><span class="sxs-lookup"><span data-stu-id="f1adb-123">For more information, see [Compiled Regular Expressions](#Compiled).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace>|`x`|<span data-ttu-id="f1adb-124">Исключить неэкранированные пробелы из шаблона и включить комментарии после символа решетки (`#`).</span><span class="sxs-lookup"><span data-stu-id="f1adb-124">Exclude unescaped white space from the pattern, and enable comments after a number sign (`#`).</span></span> <span data-ttu-id="f1adb-125">Дополнительные сведения см. в статье [Пропуск пробелов](#Whitespace).</span><span class="sxs-lookup"><span data-stu-id="f1adb-125">For more information, see [Ignore White Space](#Whitespace).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.RightToLeft>|<span data-ttu-id="f1adb-126">Недоступно</span><span class="sxs-lookup"><span data-stu-id="f1adb-126">Not available</span></span>|<span data-ttu-id="f1adb-127">Изменить направление поиска.</span><span class="sxs-lookup"><span data-stu-id="f1adb-127">Change the search direction.</span></span> <span data-ttu-id="f1adb-128">Поиск идет справа налево, а не слева направо.</span><span class="sxs-lookup"><span data-stu-id="f1adb-128">Search moves from right to left instead of from left to right.</span></span> <span data-ttu-id="f1adb-129">Дополнительные сведения см. в разделе [Режим "справа налево"](#RightToLeft).</span><span class="sxs-lookup"><span data-stu-id="f1adb-129">For more information, see [Right-to-Left Mode](#RightToLeft).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.ECMAScript>|<span data-ttu-id="f1adb-130">Недоступно</span><span class="sxs-lookup"><span data-stu-id="f1adb-130">Not available</span></span>|<span data-ttu-id="f1adb-131">Включить поведение, совместимое с ECMAScript, для выражения.</span><span class="sxs-lookup"><span data-stu-id="f1adb-131">Enable ECMAScript-compliant behavior for the expression.</span></span> <span data-ttu-id="f1adb-132">Дополнительные сведения см. в разделе [Поведение сопоставления ECMAScript](#ECMAScript).</span><span class="sxs-lookup"><span data-stu-id="f1adb-132">For more information, see [ECMAScript Matching Behavior](#ECMAScript).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant>|<span data-ttu-id="f1adb-133">Недоступно</span><span class="sxs-lookup"><span data-stu-id="f1adb-133">Not available</span></span>|<span data-ttu-id="f1adb-134">Игнорировать различия региональных параметров в языке.</span><span class="sxs-lookup"><span data-stu-id="f1adb-134">Ignore cultural differences in language.</span></span> <span data-ttu-id="f1adb-135">Дополнительные сведения см. в разделе [Сравнение с использованием инвариантных региональных параметров](#Invariant).</span><span class="sxs-lookup"><span data-stu-id="f1adb-135">For more information, see [Comparison Using the Invariant Culture](#Invariant).</span></span>|

## <a name="specifying-the-options"></a><span data-ttu-id="f1adb-136">Указание параметров</span><span class="sxs-lookup"><span data-stu-id="f1adb-136">Specifying the Options</span></span>

<span data-ttu-id="f1adb-137">Параметры регулярных выражений можно указать одним из трех способов:</span><span class="sxs-lookup"><span data-stu-id="f1adb-137">You can specify options for regular expressions in one of three ways:</span></span>

- <span data-ttu-id="f1adb-138">В параметре `options` конструктора класса <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> или статичного метода сопоставления шаблона (`Shared` в Visual Basic), например <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> или <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f1adb-138">In the `options` parameter of a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or static (`Shared` in Visual Basic) pattern-matching method, such as <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f1adb-139">Параметр `options` — побитовое сложение (логическое ИЛИ) значений перечисления <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f1adb-139">The `options` parameter is a bitwise OR combination of <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> enumerated values.</span></span>

  <span data-ttu-id="f1adb-140">Когда параметры передаются экземпляру <xref:System.Text.RegularExpressions.Regex> с помощью параметра `options` конструктора класса, они присваиваются свойству <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f1adb-140">When options are supplied to a <xref:System.Text.RegularExpressions.Regex> instance by using the `options` parameter of a class constructor, the options are assigned to the <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="f1adb-141">Однако свойство <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> не отражает встроенные параметры в самом шаблоне регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="f1adb-141">However, the <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> property does not reflect inline options in the regular expression pattern itself.</span></span>

  <span data-ttu-id="f1adb-142">Ниже приведен пример.</span><span class="sxs-lookup"><span data-stu-id="f1adb-142">The following example provides an illustration.</span></span> <span data-ttu-id="f1adb-143">В нем параметр `options` метода <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> используется для включения сопоставления без учета регистра и пропуска пробелов при определении слов, начинающихся с буквы "d".</span><span class="sxs-lookup"><span data-stu-id="f1adb-143">It uses the `options` parameter of the <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#6)]
  [!code-vb[Conceptual.Regex.Language.Options#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#6)]

- <span data-ttu-id="f1adb-144">Применяя встроенные параметры в шаблоне регулярного выражения с помощью синтаксиса `(?imnsx-imnsx)`.</span><span class="sxs-lookup"><span data-stu-id="f1adb-144">By applying inline options in a regular expression pattern with the syntax `(?imnsx-imnsx)`.</span></span> <span data-ttu-id="f1adb-145">Параметр применяется к шаблону от точки, в которой определен параметр, и действует либо до конца шаблона, либо до точки, в которой другая конструкция отменяет параметр.</span><span class="sxs-lookup"><span data-stu-id="f1adb-145">The option applies to the pattern from the point that the option is defined to either the end of the pattern or to the point at which the option is undefined by another inline option.</span></span> <span data-ttu-id="f1adb-146">Обратите внимание на то, что свойство <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> экземпляра <xref:System.Text.RegularExpressions.Regex> не отражает этих встроенных параметров.</span><span class="sxs-lookup"><span data-stu-id="f1adb-146">Note that the <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> property of a <xref:System.Text.RegularExpressions.Regex> instance does not reflect these inline options.</span></span> <span data-ttu-id="f1adb-147">Дополнительные сведения см. в разделе [Другие конструкции](../../../docs/standard/base-types/miscellaneous-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="f1adb-147">For more information, see the [Miscellaneous Constructs](../../../docs/standard/base-types/miscellaneous-constructs-in-regular-expressions.md) topic.</span></span>

  <span data-ttu-id="f1adb-148">Ниже приведен пример.</span><span class="sxs-lookup"><span data-stu-id="f1adb-148">The following example provides an illustration.</span></span> <span data-ttu-id="f1adb-149">В нем встроенные параметры используются для включения сопоставления без учета регистра и пропуска пробелов при определении слов, начинающихся с буквы "d".</span><span class="sxs-lookup"><span data-stu-id="f1adb-149">It uses inline options to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#7)]
  [!code-vb[Conceptual.Regex.Language.Options#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#7)]

- <span data-ttu-id="f1adb-150">Применяя встроенные параметры в определенной конструкции группировки в шаблоне регулярного выражения с помощью синтаксиса `(?imnsx-imnsx:`*часть выражения*`)`.</span><span class="sxs-lookup"><span data-stu-id="f1adb-150">By applying inline options in a particular grouping construct in a regular expression pattern with the syntax `(?imnsx-imnsx:`*subexpression*`)`.</span></span> <span data-ttu-id="f1adb-151">Если знак перед наборов параметров отсутствует, он включается. Если перед набором параметров есть знак минуса, набор отключается.</span><span class="sxs-lookup"><span data-stu-id="f1adb-151">No sign before a set of options turns the set on; a minus sign before a set of options turns the set off.</span></span> <span data-ttu-id="f1adb-152">(`?` — это фиксированная часть синтаксиса языковой конструкции, необходимая, если параметры включаются или отключаются.) Этот параметр применяется только к данной группе.</span><span class="sxs-lookup"><span data-stu-id="f1adb-152">(`?` is a fixed part of the language construct's syntax that is required whether options are enabled or disabled.) The option applies only to that group.</span></span> <span data-ttu-id="f1adb-153">Дополнительные сведения см. в разделе [Конструкции группировки](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="f1adb-153">For more information, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

  <span data-ttu-id="f1adb-154">Ниже приведен пример.</span><span class="sxs-lookup"><span data-stu-id="f1adb-154">The following example provides an illustration.</span></span> <span data-ttu-id="f1adb-155">В нем встроенные параметры в конструкции группировки используются для включения сопоставления без учета регистра и пропуска пробелов при определении слов, начинающихся с буквы "d".</span><span class="sxs-lookup"><span data-stu-id="f1adb-155">It uses inline options in a grouping construct to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#8)]
  [!code-vb[Conceptual.Regex.Language.Options#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#8)]

<span data-ttu-id="f1adb-156">Если параметры указываются в строке, знак минуса (`-`) перед параметром или набором параметров, отключает соответствующие параметры.</span><span class="sxs-lookup"><span data-stu-id="f1adb-156">If options are specified inline, a minus sign (`-`) before an option or set of options turns off those options.</span></span> <span data-ttu-id="f1adb-157">Например, встроенная конструкция `(?ix-ms)` включает параметры <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> и <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> и отключает параметры <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> и <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f1adb-157">For example, the inline construct `(?ix-ms)` turns on the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> options and turns off the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> options.</span></span> <span data-ttu-id="f1adb-158">Все параметры регулярного выражения по умолчанию отключены.</span><span class="sxs-lookup"><span data-stu-id="f1adb-158">All regular expression options are turned off by default.</span></span>

> [!NOTE]
> <span data-ttu-id="f1adb-159">Если параметры регулярного выражения, указанные в параметре `options` конструктора или вызове метода, конфликтуют со встроенными параметрами в шаблоне регулярного выражения, используются последние.</span><span class="sxs-lookup"><span data-stu-id="f1adb-159">If the regular expression options specified in the `options` parameter of a constructor or method call conflict with the options specified inline in a regular expression pattern, the inline options are used.</span></span>

<span data-ttu-id="f1adb-160">Следующие пять параметров регулярного выражения можно задавать одновременно в параметрах метода и в строке:</span><span class="sxs-lookup"><span data-stu-id="f1adb-160">The following five regular expression options can be set both with the options parameter and inline:</span></span>

- <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>

<span data-ttu-id="f1adb-161">Следующие пять параметров регулярного выражения можно задавать в параметре `options`, но не в строке:</span><span class="sxs-lookup"><span data-stu-id="f1adb-161">The following five regular expression options can be set using the `options` parameter but cannot be set inline:</span></span>

- <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType>

## <a name="determining-the-options"></a><span data-ttu-id="f1adb-162">Определение параметров</span><span class="sxs-lookup"><span data-stu-id="f1adb-162">Determining the Options</span></span>

<span data-ttu-id="f1adb-163">Вы можете определить, какие параметры были предоставлены объекту <xref:System.Text.RegularExpressions.Regex> при создании его экземпляра, получив значение свойства <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> только для чтения.</span><span class="sxs-lookup"><span data-stu-id="f1adb-163">You can determine which options were provided to a <xref:System.Text.RegularExpressions.Regex> object when it was instantiated by retrieving the value of the read-only <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="f1adb-164">Это свойство, в частности, полезно для определения параметров, заданных для скомпилированного регулярного выражения, которое было создано методом <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f1adb-164">This property is particularly useful for determining the options that are defined for a compiled regular expression created by the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="f1adb-165">Чтобы проверить наличие любого параметра, кроме <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, выполните операцию AND со значением свойства <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> и значением <xref:System.Text.RegularExpressions.RegexOptions>, которое вас интересует.</span><span class="sxs-lookup"><span data-stu-id="f1adb-165">To test for the presence of any option except <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, perform an AND operation with the value of the <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> property and the <xref:System.Text.RegularExpressions.RegexOptions> value in which you are interested.</span></span> <span data-ttu-id="f1adb-166">Затем проверьте, равен ли результат значению <xref:System.Text.RegularExpressions.RegexOptions>.</span><span class="sxs-lookup"><span data-stu-id="f1adb-166">Then test whether the result equals that <xref:System.Text.RegularExpressions.RegexOptions> value.</span></span> <span data-ttu-id="f1adb-167">Следующий пример проверяет, задан ли параметр <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f1adb-167">The following example tests whether the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option has been set.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#19](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/determine1.cs#19)]
[!code-vb[Conceptual.Regex.Language.Options#19](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/determine1.vb#19)]

<span data-ttu-id="f1adb-168">Чтобы проверить наличие параметра <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, определите, равно ли значение свойства <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> значению <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="f1adb-168">To test for <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, determine whether the value of the <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> property is equal to <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, as the following example illustrates.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#20](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/determine1.cs#20)]
[!code-vb[Conceptual.Regex.Language.Options#20](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/determine1.vb#20)]

<span data-ttu-id="f1adb-169">В следующих разделах перечислены параметры, поддерживаемые регулярными выражениями .NET.</span><span class="sxs-lookup"><span data-stu-id="f1adb-169">The following sections list the options supported by regular expression in .NET.</span></span>

<a name="Default"></a>

## <a name="default-options"></a><span data-ttu-id="f1adb-170">Параметры по умолчанию</span><span class="sxs-lookup"><span data-stu-id="f1adb-170">Default Options</span></span>

<span data-ttu-id="f1adb-171">Параметр <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> указывает, что ни один параметр не задан, а механизм регулярных выражений использует поведение по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f1adb-171">The <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> option indicates that no options have been specified, and the regular expression engine uses its default behavior.</span></span> <span data-ttu-id="f1adb-172">Это поведение характеризуется следующим образом.</span><span class="sxs-lookup"><span data-stu-id="f1adb-172">This includes the following:</span></span>

- <span data-ttu-id="f1adb-173">Шаблон интерпретируется как каноническое, а не регулярное выражение ECMAScript.</span><span class="sxs-lookup"><span data-stu-id="f1adb-173">The pattern is interpreted as a canonical rather than an ECMAScript regular expression.</span></span>

- <span data-ttu-id="f1adb-174">Шаблон регулярного выражения сопоставляется во входной строке слева направо.</span><span class="sxs-lookup"><span data-stu-id="f1adb-174">The regular expression pattern is matched in the input string from left to right.</span></span>

- <span data-ttu-id="f1adb-175">При сравнениях учитывается регистр.</span><span class="sxs-lookup"><span data-stu-id="f1adb-175">Comparisons are case-sensitive.</span></span>

- <span data-ttu-id="f1adb-176">Языковые элементы `^` и `$` сопоставляют начало и конец входной строки.</span><span class="sxs-lookup"><span data-stu-id="f1adb-176">The `^` and `$` language elements match the beginning and end of the input string.</span></span>

- <span data-ttu-id="f1adb-177">Языковой элемент `.` соответствует каждому символу, кроме `\n`.</span><span class="sxs-lookup"><span data-stu-id="f1adb-177">The `.` language element matches every character except `\n`.</span></span>

- <span data-ttu-id="f1adb-178">Любой пробел в шаблоне регулярного выражения интерпретируется как пробел-литерал.</span><span class="sxs-lookup"><span data-stu-id="f1adb-178">Any white space in a regular expression pattern is interpreted as a literal space character.</span></span>

- <span data-ttu-id="f1adb-179">При сравнении шаблона со входной строкой используются соглашения текущих региональных параметров.</span><span class="sxs-lookup"><span data-stu-id="f1adb-179">The conventions of the current culture are used when comparing the pattern to the input string.</span></span>

- <span data-ttu-id="f1adb-180">Захватываемые группы в шаблоне регулярного выражения являются неявными и явными.</span><span class="sxs-lookup"><span data-stu-id="f1adb-180">Capturing groups in the regular expression pattern are implicit as well as explicit.</span></span>

> [!NOTE]
> <span data-ttu-id="f1adb-181">Параметр <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> не имеет эквивалента среди встроенных параметров.</span><span class="sxs-lookup"><span data-stu-id="f1adb-181">The <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> option has no inline equivalent.</span></span> <span data-ttu-id="f1adb-182">Если параметры регулярного выражения применяются в строке, поведение по умолчанию восстанавливается для каждого параметра, за счет отключения того или иного параметра.</span><span class="sxs-lookup"><span data-stu-id="f1adb-182">When regular expression options are applied inline, the default behavior is restored on an option-by-option basis, by turning a particular option off.</span></span> <span data-ttu-id="f1adb-183">Например, `(?i)` включает сравнение без учета регистра, а `(?-i)` восстанавливает учет регистра при сравнении.</span><span class="sxs-lookup"><span data-stu-id="f1adb-183">For example, `(?i)` turns on case-insensitive comparison, and `(?-i)` restores the default case-sensitive comparison.</span></span>

<span data-ttu-id="f1adb-184">Так как параметр <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> представляет поведение механизма регулярных выражений по умолчанию, он редко явно указывается в вызове метода.</span><span class="sxs-lookup"><span data-stu-id="f1adb-184">Because the <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> option represents the default behavior of the regular expression engine, it is rarely explicitly specified in a method call.</span></span> <span data-ttu-id="f1adb-185">Вместо этого вызывает конструктор или статичный метод сопоставления шаблона без параметра `options`.</span><span class="sxs-lookup"><span data-stu-id="f1adb-185">A constructor or static pattern-matching method without an `options` parameter is called instead.</span></span>

[<span data-ttu-id="f1adb-186">К началу</span><span class="sxs-lookup"><span data-stu-id="f1adb-186">Back to Top</span></span>](#Top)

<a name="Case"></a>

## <a name="case-insensitive-matching"></a><span data-ttu-id="f1adb-187">Сопоставление без учета регистра</span><span class="sxs-lookup"><span data-stu-id="f1adb-187">Case-Insensitive Matching</span></span>

<span data-ttu-id="f1adb-188">Параметр <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase> или встроенный параметр `i` обеспечивает сопоставление без учета регистра.</span><span class="sxs-lookup"><span data-stu-id="f1adb-188">The <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase> option, or the `i` inline option, provides case-insensitive matching.</span></span> <span data-ttu-id="f1adb-189">По умолчанию используются соглашения о регистре текущих региональных параметров.</span><span class="sxs-lookup"><span data-stu-id="f1adb-189">By default, the casing conventions of the current culture are used.</span></span>

<span data-ttu-id="f1adb-190">Следующий пример определяет шаблон регулярного выражения, `\bthe\w*\b`, который сопоставляет все слова, начинающиеся со строки "the".</span><span class="sxs-lookup"><span data-stu-id="f1adb-190">The following example defines a regular expression pattern, `\bthe\w*\b`, that matches all words starting with "the".</span></span> <span data-ttu-id="f1adb-191">Так как первый вызов метода <xref:System.Text.RegularExpressions.Regex.Match%2A> использует сравнение с учетом регистра по умолчанию, в выходных данных указывается, что строка "The" в начале предложения, не была сопоставлена.</span><span class="sxs-lookup"><span data-stu-id="f1adb-191">Because the first call to the <xref:System.Text.RegularExpressions.Regex.Match%2A> method uses the default case-sensitive comparison, the output indicates that the string "The" that begins the sentence is not matched.</span></span> <span data-ttu-id="f1adb-192">Она выделяется, если метод <xref:System.Text.RegularExpressions.Regex.Match%2A> вызывается с параметрами <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase>.</span><span class="sxs-lookup"><span data-stu-id="f1adb-192">It is matched when the <xref:System.Text.RegularExpressions.Regex.Match%2A> method is called with options set to <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase>.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/case1.cs#1)]
[!code-vb[Conceptual.Regex.Language.Options#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/case1.vb#1)]

<span data-ttu-id="f1adb-193">Следующий пример изменяет шаблон регулярного выражения из предыдущего примера для использования встроенных параметров вместо параметра `options`, чтобы включить сравнение без учета регистра.</span><span class="sxs-lookup"><span data-stu-id="f1adb-193">The following example modifies the regular expression pattern from the previous example to use inline options instead of the `options` parameter to provide case-insensitive comparison.</span></span> <span data-ttu-id="f1adb-194">Первый шаблон определяет параметр отключения учета регистра в конструкции группировки, которая применяется только к букве "t" в строке "the".</span><span class="sxs-lookup"><span data-stu-id="f1adb-194">The first pattern defines the case-insensitive option in a grouping construct that applies only to the letter "t" in the string "the".</span></span> <span data-ttu-id="f1adb-195">Так как конструкция указана в начале шаблона, второй шаблон применяет параметр учета регистра ко всему регулярному выражению.</span><span class="sxs-lookup"><span data-stu-id="f1adb-195">Because the option construct occurs at the beginning of the pattern, the second pattern applies the case-insensitive option to the entire regular expression.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/case2.cs#2)]
[!code-vb[Conceptual.Regex.Language.Options#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/case2.vb#2)]

[<span data-ttu-id="f1adb-196">К началу</span><span class="sxs-lookup"><span data-stu-id="f1adb-196">Back to Top</span></span>](#Top)

<a name="Multiline"></a>

## <a name="multiline-mode"></a><span data-ttu-id="f1adb-197">Многострочный режим</span><span class="sxs-lookup"><span data-stu-id="f1adb-197">Multiline Mode</span></span>

<span data-ttu-id="f1adb-198">Параметр <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> или встроенный параметр `m` позволяет механизму регулярных выражений обрабатывать входную строку, которая состоит из нескольких строк.</span><span class="sxs-lookup"><span data-stu-id="f1adb-198">The <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option, or the `m` inline option, enables the regular expression engine to handle an input string that consists of multiple lines.</span></span> <span data-ttu-id="f1adb-199">Он изменяет интерпретацию языковых элементов `^` и `$`, чтобы они сопоставляли начало и конец строки текста, а не начало и строки входной строки.</span><span class="sxs-lookup"><span data-stu-id="f1adb-199">It changes the interpretation of the `^` and `$` language elements so that they match the beginning and end of a line, instead of the beginning and end of the input string.</span></span>

<span data-ttu-id="f1adb-200">По умолчанию `$` сопоставляет конец входной строки.</span><span class="sxs-lookup"><span data-stu-id="f1adb-200">By default, `$` matches only the end of the input string.</span></span> <span data-ttu-id="f1adb-201">Если указать параметр <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>, он сопоставляет символ новой строки (`\n`) или конец входной строки.</span><span class="sxs-lookup"><span data-stu-id="f1adb-201">If you specify the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option, it matches either the newline character (`\n`) or the end of the input string.</span></span> <span data-ttu-id="f1adb-202">Однако он не сопоставляет комбинацию символов возврата каретки и перевода строки.</span><span class="sxs-lookup"><span data-stu-id="f1adb-202">It does not, however, match the carriage return/line feed character combination.</span></span> <span data-ttu-id="f1adb-203">Для их успешного сопоставления используйте часть выражения `\r?$` вместо `$`.</span><span class="sxs-lookup"><span data-stu-id="f1adb-203">To successfully match them, use the subexpression `\r?$` instead of just `$`.</span></span>

<span data-ttu-id="f1adb-204">Следующий пример извлекает имена и баллы игроков в боулинг и добавляет их в коллекцию <xref:System.Collections.Generic.SortedList%602>, где они сортируются по убыванию.</span><span class="sxs-lookup"><span data-stu-id="f1adb-204">The following example extracts bowlers' names and scores and adds them to a <xref:System.Collections.Generic.SortedList%602> collection that sorts them in descending order.</span></span> <span data-ttu-id="f1adb-205">Метод <xref:System.Text.RegularExpressions.Regex.Matches%2A> вызывается два раза.</span><span class="sxs-lookup"><span data-stu-id="f1adb-205">The <xref:System.Text.RegularExpressions.Regex.Matches%2A> method is called twice.</span></span> <span data-ttu-id="f1adb-206">В первом вызове метода используется регулярное выражение `^(\w+)\s(\d+)$`, параметры не заданы.</span><span class="sxs-lookup"><span data-stu-id="f1adb-206">In the first method call, the regular expression is `^(\w+)\s(\d+)$` and no options are set.</span></span> <span data-ttu-id="f1adb-207">Как видно в результатах, совпадения не найдены, так как механизм регулярных выражений не может сопоставить входной шаблон с началом и концом входной строки.</span><span class="sxs-lookup"><span data-stu-id="f1adb-207">As the output shows, because the regular expression engine cannot match the input pattern along with the beginning and end of the input string, no matches are found.</span></span> <span data-ttu-id="f1adb-208">Во втором вызове метода регулярное выражение меняется на `^(\w+)\s(\d+)\r?$` и задаются параметры <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f1adb-208">In the second method call, the regular expression is changed to `^(\w+)\s(\d+)\r?$` and the options are set to <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f1adb-209">Как видно в результатах, имена и баллы успешно сопоставляются, а баллы отображаются по убыванию.</span><span class="sxs-lookup"><span data-stu-id="f1adb-209">As the output shows, the names and scores are successfully matched, and the scores are displayed in descending order.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/multiline1.cs#3)]
[!code-vb[Conceptual.Regex.Language.Options#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/multiline1.vb#3)]

<span data-ttu-id="f1adb-210">Шаблон регулярного выражения `^(\w+)\s(\d+)\r*$` определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="f1adb-210">The regular expression pattern `^(\w+)\s(\d+)\r*$` is defined as shown in the following table.</span></span>

|<span data-ttu-id="f1adb-211">Шаблон</span><span class="sxs-lookup"><span data-stu-id="f1adb-211">Pattern</span></span>|<span data-ttu-id="f1adb-212">ОПИСАНИЕ</span><span class="sxs-lookup"><span data-stu-id="f1adb-212">Description</span></span>|
|-------------|-----------------|
|`^`|<span data-ttu-id="f1adb-213">Начало с первого символа строки.</span><span class="sxs-lookup"><span data-stu-id="f1adb-213">Begin at the start of the line.</span></span>|
|`(\w+)`|<span data-ttu-id="f1adb-214">Совпадение с одним или несколькими символами слова.</span><span class="sxs-lookup"><span data-stu-id="f1adb-214">Match one or more word characters.</span></span> <span data-ttu-id="f1adb-215">Это первая группа записи.</span><span class="sxs-lookup"><span data-stu-id="f1adb-215">This is the first capturing group.</span></span>|
|`\s`|<span data-ttu-id="f1adb-216">Соответствует пробелу.</span><span class="sxs-lookup"><span data-stu-id="f1adb-216">Match a white-space character.</span></span>|
|`(\d+)`|<span data-ttu-id="f1adb-217">Совпадение с одной или несколькими десятичными цифрами.</span><span class="sxs-lookup"><span data-stu-id="f1adb-217">Match one or more decimal digits.</span></span> <span data-ttu-id="f1adb-218">Это вторая группа записи.</span><span class="sxs-lookup"><span data-stu-id="f1adb-218">This is the second capturing group.</span></span>|
|`\r?`|<span data-ttu-id="f1adb-219">Сопоставление нуля или одного символа возврата каретки.</span><span class="sxs-lookup"><span data-stu-id="f1adb-219">Match zero or one carriage return character.</span></span>|
|`$`|<span data-ttu-id="f1adb-220">Окончание в конце строки.</span><span class="sxs-lookup"><span data-stu-id="f1adb-220">End at the end of the line.</span></span>|

<span data-ttu-id="f1adb-221">Следующий пример аналогичен предыдущему, но он использует встроенный параметр `(?m)` для включения многострочного режима.</span><span class="sxs-lookup"><span data-stu-id="f1adb-221">The following example is equivalent to the previous one, except that it uses the inline option `(?m)` to set the multiline option.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/multiline2.cs#4)]
[!code-vb[Conceptual.Regex.Language.Options#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/multiline2.vb#4)]

[<span data-ttu-id="f1adb-222">К началу</span><span class="sxs-lookup"><span data-stu-id="f1adb-222">Back to Top</span></span>](#Top)

<a name="Singleline"></a>

## <a name="single-line-mode"></a><span data-ttu-id="f1adb-223">Однострочный режим</span><span class="sxs-lookup"><span data-stu-id="f1adb-223">Single-line Mode</span></span>

<span data-ttu-id="f1adb-224">Параметр <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> или встроенный параметр `s` позволяет механизму регулярных выражений обрабатывать входную строку так, будто она состоит из одной строки.</span><span class="sxs-lookup"><span data-stu-id="f1adb-224">The <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> option, or the `s` inline option, causes the regular expression engine to treat the input string as if it consists of a single line.</span></span> <span data-ttu-id="f1adb-225">Для этого поведение языкового элемента `.` меняется так, чтобы он сопоставлял каждый символ, а не каждый символ, кроме символа новой строки `\n` или \u000A.</span><span class="sxs-lookup"><span data-stu-id="f1adb-225">It does this by changing the behavior of the period (`.`) language element so that it matches every character, instead of matching every character except for the newline character `\n` or \u000A.</span></span>

<span data-ttu-id="f1adb-226">В следующем примере показано, как поведение языкового элемента `.` меняется при использовании параметра <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f1adb-226">The following example illustrates how the behavior of the `.` language element changes when you use the <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="f1adb-227">Регулярное выражение `^.+` начинается с начала строки и соответствует любому знаку.</span><span class="sxs-lookup"><span data-stu-id="f1adb-227">The regular expression `^.+` starts at the beginning of the string and matches every character.</span></span> <span data-ttu-id="f1adb-228">По умолчанию соответствие заканчивается в конце первой строки; шаблон регулярного выражения соответствует символу возврата каретки, `\r` или \u000D, но не соответствует `\n`.</span><span class="sxs-lookup"><span data-stu-id="f1adb-228">By default, the match ends at the end of the first line; the regular expression pattern matches the carriage return character, `\r` or \u000D, but it does not match `\n`.</span></span> <span data-ttu-id="f1adb-229">Поскольку параметр <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> интерпретирует всю входную строку как единую строку, он сопоставляет каждый символ в строке ввода, включая `\n`.</span><span class="sxs-lookup"><span data-stu-id="f1adb-229">Because the <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> option interprets the entire input string as a single line, it matches every character in the input string, including `\n`.</span></span>

[!code-csharp[Conceptual.Regex.Language.CharacterClasses#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/any2.cs#5)]
[!code-vb[Conceptual.Regex.Language.CharacterClasses#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/any2.vb#5)]

<span data-ttu-id="f1adb-230">Следующий пример аналогичен предыдущему, но он использует встроенный параметр `(?s)` для включения однострочного режима.</span><span class="sxs-lookup"><span data-stu-id="f1adb-230">The following example is equivalent to the previous one, except that it uses the inline option `(?s)` to enable single-line mode.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/singleline1.cs#5)]
[!code-vb[Conceptual.Regex.Language.Options#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/singleline1.vb#5)]

[<span data-ttu-id="f1adb-231">К началу</span><span class="sxs-lookup"><span data-stu-id="f1adb-231">Back to Top</span></span>](#Top)

<a name="Explicit"></a>

## <a name="explicit-captures-only"></a><span data-ttu-id="f1adb-232">Только явные захваты</span><span class="sxs-lookup"><span data-stu-id="f1adb-232">Explicit Captures Only</span></span>

<span data-ttu-id="f1adb-233">По умолчанию захватываемые группы определяются с помощью круглых скобок в шаблоне регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="f1adb-233">By default, capturing groups are defined by the use of parentheses in the regular expression pattern.</span></span> <span data-ttu-id="f1adb-234">Именованным группам назначается имя или номер с помощью параметра языка `(?<`*имя*`>`*часть выражения*`)`. Неименованные группы доступны по индексу.</span><span class="sxs-lookup"><span data-stu-id="f1adb-234">Named groups are assigned a name or number by the `(?<`*name*`>`*subexpression*`)` language option, whereas unnamed groups are accessible by index.</span></span> <span data-ttu-id="f1adb-235">В объекте <xref:System.Text.RegularExpressions.GroupCollection> неименованные группы идут перед именованными.</span><span class="sxs-lookup"><span data-stu-id="f1adb-235">In the <xref:System.Text.RegularExpressions.GroupCollection> object, unnamed groups precede named groups.</span></span>

<span data-ttu-id="f1adb-236">Конструкции группировки часто используются только для применения квантификаторов к нескольким языковым элементам, а захваченные подстроки не представляют интереса.</span><span class="sxs-lookup"><span data-stu-id="f1adb-236">Grouping constructs are often used only to apply quantifiers to multiple language elements, and the captured substrings are of no interest.</span></span> <span data-ttu-id="f1adb-237">Например, если следующее регулярное выражение,</span><span class="sxs-lookup"><span data-stu-id="f1adb-237">For example, if the following regular expression:</span></span>

```
\b\(?((\w+),?\s?)+[\.!?]\)?
```

<span data-ttu-id="f1adb-238">, предназначено только для извлечения предложений, которые оканчиваются на точку, восклицательный или вопросительный знак из документа, только полученное предложение (в объекте <xref:System.Text.RegularExpressions.Match>) представляет интерес,</span><span class="sxs-lookup"><span data-stu-id="f1adb-238">is intended only to extract sentences that end with a period, exclamation point, or question mark from a document, only the resulting sentence (which is represented by the <xref:System.Text.RegularExpressions.Match> object) is of interest.</span></span> <span data-ttu-id="f1adb-239">а отдельные слова в коллекции — нет.</span><span class="sxs-lookup"><span data-stu-id="f1adb-239">The individual words in the collection are not.</span></span>

<span data-ttu-id="f1adb-240">Захватываемые группы, которые не используются в последствии, могут потреблять много ресурсов, так как механизм регулярных выражений должны заполнить объекты <xref:System.Text.RegularExpressions.GroupCollection> и <xref:System.Text.RegularExpressions.CaptureCollection> коллекции.</span><span class="sxs-lookup"><span data-stu-id="f1adb-240">Capturing groups that are not subsequently used can be expensive, because the regular expression engine must populate both the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> collection objects.</span></span> <span data-ttu-id="f1adb-241">В качестве альтернативы можно использовать параметр <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> или встроенный параметр `n`, чтобы указать, что только допустимые выделения являются явно именованными или нумерованными группами, обозначенными конструкцией `(?<`*имя*`>` *часть выражения*`)`.</span><span class="sxs-lookup"><span data-stu-id="f1adb-241">As an alternative, you can use either the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> option or the `n` inline option to specify that the only valid captures are explicitly named or numbered groups that are designated by the `(?<`*name*`>` *subexpression*`)` construct.</span></span>

<span data-ttu-id="f1adb-242">Следующий пример отображает сведения о сопоставлениях, возвращаемых шаблоном регулярного выражения `\b\(?((\w+),?\s?)+[\.!?]\)?`, если метод <xref:System.Text.RegularExpressions.Regex.Match%2A> вызывается с параметром <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> или без него.</span><span class="sxs-lookup"><span data-stu-id="f1adb-242">The following example displays information about the matches returned by the `\b\(?((\w+),?\s?)+[\.!?]\)?` regular expression pattern when the <xref:System.Text.RegularExpressions.Regex.Match%2A> method is called with and without the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="f1adb-243">Как видно в результатах выполнения первого вызова метода, механизм регулярных выражений полностью заполняет объекты коллекции <xref:System.Text.RegularExpressions.GroupCollection> и <xref:System.Text.RegularExpressions.CaptureCollection> данными о выделенных подстроках.</span><span class="sxs-lookup"><span data-stu-id="f1adb-243">As the output from the first method call shows, the regular expression engine fully populates the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> collection objects with information about captured substrings.</span></span> <span data-ttu-id="f1adb-244">Так как второй метод вызывается с параметром `options`, для которого задано значение <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>, он не записывает информацию о группах.</span><span class="sxs-lookup"><span data-stu-id="f1adb-244">Because the second method is called with `options` set to <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>, it does not capture information on groups.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/explicit1.cs#9)]
[!code-vb[Conceptual.Regex.Language.Options#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/explicit1.vb#9)]

<span data-ttu-id="f1adb-245">Шаблон регулярного выражения `\b\(?((?>\w+),?\s?)+[\.!?]\)?` определяется так, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="f1adb-245">The regular expression pattern`\b\(?((?>\w+),?\s?)+[\.!?]\)?` is defined as shown in the following table.</span></span>

|<span data-ttu-id="f1adb-246">Шаблон</span><span class="sxs-lookup"><span data-stu-id="f1adb-246">Pattern</span></span>|<span data-ttu-id="f1adb-247">ОПИСАНИЕ</span><span class="sxs-lookup"><span data-stu-id="f1adb-247">Description</span></span>|
|-------------|-----------------|
|`\b`|<span data-ttu-id="f1adb-248">Начало на границе слова.</span><span class="sxs-lookup"><span data-stu-id="f1adb-248">Begin at a word boundary.</span></span>|
|`\(?`|<span data-ttu-id="f1adb-249">Сопоставляется ноль или один экземпляр открывающих круглых скобок ("(").</span><span class="sxs-lookup"><span data-stu-id="f1adb-249">Match zero or one occurrences of the opening parenthesis ("(").</span></span>|
|`(?>\w+),?`|<span data-ttu-id="f1adb-250">Сопоставляется один или несколько словообразующих символов, за которыми следует ноль или одна запятая.</span><span class="sxs-lookup"><span data-stu-id="f1adb-250">Match one or more word characters, followed by zero or one commas.</span></span> <span data-ttu-id="f1adb-251">При сопоставлении словообразующих символов обратный поиск не применяется.</span><span class="sxs-lookup"><span data-stu-id="f1adb-251">Do not backtrack when matching word characters.</span></span>|
|`\s?`|<span data-ttu-id="f1adb-252">Совпадение с нулем или одним символом пробела.</span><span class="sxs-lookup"><span data-stu-id="f1adb-252">Match zero or one white-space characters.</span></span>|
|`((\w+),?\s?)+`|<span data-ttu-id="f1adb-253">Один или несколько раз выделяет комбинацию из одного или нескольких символов, нуля или одной запятой, нуля или одного пробела.</span><span class="sxs-lookup"><span data-stu-id="f1adb-253">Match the combination of one or more word characters, zero or one commas, and zero or one white-space characters one or more times.</span></span>|
|`[\.!?]\)?`|<span data-ttu-id="f1adb-254">Сопоставляются любые из трех знаков пунктуации, за которыми следует ноль или одна закрывающая круглая скобка (")").</span><span class="sxs-lookup"><span data-stu-id="f1adb-254">Match any of the three punctuation symbols, followed by zero or one closing parentheses (")").</span></span>|

<span data-ttu-id="f1adb-255">Вы также можете использовать встроенный элемент `(?n)`, чтобы отключить автоматическое выделение.</span><span class="sxs-lookup"><span data-stu-id="f1adb-255">You can also use the `(?n)` inline element to suppress automatic captures.</span></span> <span data-ttu-id="f1adb-256">Следующий пример изменяет предыдущий шаблон регулярного выражения, чтобы использовать встроенный элемент `(?n)` вместо параметра <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f1adb-256">The following example modifies the previous regular expression pattern to use the `(?n)` inline element instead of the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> option.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/explicit2.cs#10)]
[!code-vb[Conceptual.Regex.Language.Options#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/explicit2.vb#10)]

<span data-ttu-id="f1adb-257">Наконец, вы можете использовать встроенный элемент группы `(?n:)`, чтобы отключить автоматическое выделение для отдельных групп.</span><span class="sxs-lookup"><span data-stu-id="f1adb-257">Finally, you can use the inline group element `(?n:)` to suppress automatic captures on a group-by-group basis.</span></span> <span data-ttu-id="f1adb-258">Следующий пример изменяет предыдущий шаблон, чтобы отключить неименованные выделения во внешней группе, `((?>\w+),?\s?)`.</span><span class="sxs-lookup"><span data-stu-id="f1adb-258">The following example modifies the previous pattern to suppress unnamed captures in the outer group, `((?>\w+),?\s?)`.</span></span> <span data-ttu-id="f1adb-259">Обратите внимание, что при этом подавляются неименованные выделения и во внутренней группе.</span><span class="sxs-lookup"><span data-stu-id="f1adb-259">Note that this suppresses unnamed captures in the inner group as well.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#11](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/explicit3.cs#11)]
[!code-vb[Conceptual.Regex.Language.Options#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/explicit3.vb#11)]

[<span data-ttu-id="f1adb-260">К началу</span><span class="sxs-lookup"><span data-stu-id="f1adb-260">Back to Top</span></span>](#Top)

<a name="Compiled"></a>

## <a name="compiled-regular-expressions"></a><span data-ttu-id="f1adb-261">Скомпилированные регулярные выражения</span><span class="sxs-lookup"><span data-stu-id="f1adb-261">Compiled Regular Expressions</span></span>

<span data-ttu-id="f1adb-262">По умолчанию регулярные выражения в .NET интерпретируются.</span><span class="sxs-lookup"><span data-stu-id="f1adb-262">By default, regular expressions in .NET are interpreted.</span></span> <span data-ttu-id="f1adb-263">Когда создается экземпляр объекта <xref:System.Text.RegularExpressions.Regex> или вызывается статичный метод <xref:System.Text.RegularExpressions.Regex>, шаблон регулярного выражения преобразуется в набор настраиваемых кодов операций, а интерпретатор использует их для выполнения регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="f1adb-263">When a <xref:System.Text.RegularExpressions.Regex> object is instantiated or a static <xref:System.Text.RegularExpressions.Regex> method is called, the regular expression pattern is parsed into a set of custom opcodes, and an interpreter uses these opcodes to run the regular expression.</span></span> <span data-ttu-id="f1adb-264">С этим связан компромисс: затраты на инициализацию механизма регулярных выражений уменьшаются за счет производительности во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="f1adb-264">This involves a tradeoff: The cost of initializing the regular expression engine is minimized at the expense of run-time performance.</span></span>

<span data-ttu-id="f1adb-265">Вместо интерпретируемых регулярных выражений можно использовать скомпилированные регулярные выражения, указав параметр <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f1adb-265">You can use compiled instead of interpreted regular expressions by using the <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="f1adb-266">В этом случае при передаче шаблона механизму регулярных выражений он разбивается на набор кодов операций и преобразуется в инструкции MSIL, которые можно передать напрямую среде CLR.</span><span class="sxs-lookup"><span data-stu-id="f1adb-266">In this case, when a pattern is passed to the regular expression engine, it is parsed into a set of opcodes and then converted to Microsoft intermediate language (MSIL), which can be passed directly to the common language runtime.</span></span> <span data-ttu-id="f1adb-267">Скомпилированные регулярные выражения повышают производительность во время выполнения, но за счет более длительной инициализации.</span><span class="sxs-lookup"><span data-stu-id="f1adb-267">Compiled regular expressions maximize run-time performance at the expense of initialization time.</span></span>

> [!NOTE]
> <span data-ttu-id="f1adb-268">Чтобы скомпилировать регулярное выражение, необходимо передать значение <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> параметру `options` конструктора класса <xref:System.Text.RegularExpressions.Regex> или статичного метода сопоставления шаблона.</span><span class="sxs-lookup"><span data-stu-id="f1adb-268">A regular expression can be compiled only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or a static pattern-matching method.</span></span> <span data-ttu-id="f1adb-269">Этот параметр не может быть указан как встроенный.</span><span class="sxs-lookup"><span data-stu-id="f1adb-269">It is not available as an inline option.</span></span>

<span data-ttu-id="f1adb-270">Вы можете использовать скомпилированные регулярные выражения в вызовах статичных регулярных выражений и регулярных выражений экземпляров.</span><span class="sxs-lookup"><span data-stu-id="f1adb-270">You can use compiled regular expressions in calls to both static and instance regular expressions.</span></span> <span data-ttu-id="f1adb-271">В статичных регулярных выражениях параметр <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> передается в параметр `options` метода сопоставления шаблона регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="f1adb-271">In static regular expressions, the <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> option is passed to the `options` parameter of the regular expression pattern-matching method.</span></span> <span data-ttu-id="f1adb-272">В регулярных выражениях экземпляра он передается в параметр `options` конструктора класса <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="f1adb-272">In instance regular expressions, it is passed to the `options` parameter of the <xref:System.Text.RegularExpressions.Regex> class constructor.</span></span> <span data-ttu-id="f1adb-273">В обоих случаях это повышает производительность.</span><span class="sxs-lookup"><span data-stu-id="f1adb-273">In both cases, it results in enhanced performance.</span></span>

<span data-ttu-id="f1adb-274">Однако такой рост производительности возможен только в следующих условиях:</span><span class="sxs-lookup"><span data-stu-id="f1adb-274">However, this improvement in performance occurs only under the following conditions:</span></span>

- <span data-ttu-id="f1adb-275">Объект <xref:System.Text.RegularExpressions.Regex>, представляющий определенное регулярное выражение, используется в нескольких вызовах методов сопоставления шаблона регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="f1adb-275">A <xref:System.Text.RegularExpressions.Regex> object that represents a particular regular expression is used in multiple calls to regular expression pattern-matching methods.</span></span>

- <span data-ttu-id="f1adb-276">Объект <xref:System.Text.RegularExpressions.Regex> не может выходить за область применения, поэтому его можно использовать повторно.</span><span class="sxs-lookup"><span data-stu-id="f1adb-276">The <xref:System.Text.RegularExpressions.Regex> object is not allowed to go out of scope, so it can be reused.</span></span>

- <span data-ttu-id="f1adb-277">Статичное регулярное выражение используется в нескольких вызовах методов сопоставления шаблона регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="f1adb-277">A static regular expression is used in multiple calls to regular expression pattern-matching methods.</span></span> <span data-ttu-id="f1adb-278">(Рост производительности возможен, так как регулярные выражения, используемые в вызовах статичных методов, кэшируются механизмом регулярных выражений.)</span><span class="sxs-lookup"><span data-stu-id="f1adb-278">(The performance improvement is possible because regular expressions used in static method calls are cached by the regular expression engine.)</span></span>

> [!NOTE]
> <span data-ttu-id="f1adb-279">Параметр <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> не связан с методом <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType>, который создает специальную сборку с предварительно определенными скомпилированными регулярными выражениями.</span><span class="sxs-lookup"><span data-stu-id="f1adb-279">The <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> option is unrelated to the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method, which creates a special-purpose assembly that contains predefined compiled regular expressions.</span></span>

[<span data-ttu-id="f1adb-280">К началу</span><span class="sxs-lookup"><span data-stu-id="f1adb-280">Back to Top</span></span>](#Top)

<a name="Whitespace"></a>

## <a name="ignore-white-space"></a><span data-ttu-id="f1adb-281">Пропуск пробелов</span><span class="sxs-lookup"><span data-stu-id="f1adb-281">Ignore White Space</span></span>

<span data-ttu-id="f1adb-282">По умолчанию пробел в шаблоне регулярного выражения учитывается. Он заставляет механизм регулярных выражений сопоставлять символ пробела во входной строке.</span><span class="sxs-lookup"><span data-stu-id="f1adb-282">By default, white space in a regular expression pattern is significant; it forces the regular expression engine to match a white-space character in the input string.</span></span> <span data-ttu-id="f1adb-283">Поэтому регулярные выражения "`\b\w+\s`" и "`\b\w+`" практически аналогичны.</span><span class="sxs-lookup"><span data-stu-id="f1adb-283">Because of this, the regular expression "`\b\w+\s`" and "`\b\w+` " are roughly equivalent regular expressions.</span></span> <span data-ttu-id="f1adb-284">Кроме того, если в шаблоне регулярного выражения найден символ решетки (#), он интерпретируется как литерал, который необходимо сопоставить.</span><span class="sxs-lookup"><span data-stu-id="f1adb-284">In addition, when the number sign (#) is encountered in a regular expression pattern, it is interpreted as a literal character to be matched.</span></span>

<span data-ttu-id="f1adb-285">Параметр <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> или встроенный параметр `x` меняет такое поведение следующим образом:</span><span class="sxs-lookup"><span data-stu-id="f1adb-285">The <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option, or the `x` inline option, changes this default behavior as follows:</span></span>

- <span data-ttu-id="f1adb-286">Неэкранированный пробел в шаблоне регулярного выражения игнорируется.</span><span class="sxs-lookup"><span data-stu-id="f1adb-286">Unescaped white space in the regular expression pattern is ignored.</span></span> <span data-ttu-id="f1adb-287">Чтобы включить пробелы в шаблон регулярного выражения, их необходимо экранировать (например, как `\s` или "`\`").</span><span class="sxs-lookup"><span data-stu-id="f1adb-287">To be part of a regular expression pattern, white-space characters must be escaped (for example, as `\s` or "`\` ").</span></span>

- <span data-ttu-id="f1adb-288">Символ решетки (#) интерпретируется как начало комментария, а не литерал.</span><span class="sxs-lookup"><span data-stu-id="f1adb-288">The number sign (#) is interpreted as the beginning of a comment, rather than as a literal character.</span></span> <span data-ttu-id="f1adb-289">Весь текст в шаблоне регулярного выражения с символа # до конца строки интерпретируется как комментарий.</span><span class="sxs-lookup"><span data-stu-id="f1adb-289">All text in the regular expression pattern from the # character to the end of the string is interpreted as a comment.</span></span>

<span data-ttu-id="f1adb-290">Но в следующих случаях пробелы в регулярном выражении не игнорируются, даже если указан параметр <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f1adb-290">However, in the following cases, white-space characters in a regular expression aren't ignored, even if you use the <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option:</span></span>

- <span data-ttu-id="f1adb-291">Пробел в классе символов всегда интерпретируется как литерал.</span><span class="sxs-lookup"><span data-stu-id="f1adb-291">White space within a character class is always interpreted literally.</span></span> <span data-ttu-id="f1adb-292">Например, шаблон регулярного выражения `[ .,;:]` сопоставляет любой отдельный символ пробела, точки, запятой, точки с запятой и двоеточия.</span><span class="sxs-lookup"><span data-stu-id="f1adb-292">For example, the regular expression pattern `[ .,;:]` matches any single white-space character, period, comma, semicolon, or colon.</span></span>

- <span data-ttu-id="f1adb-293">Пробел не допускается в квантификаторах, окруженных квадратными скобками, таких как `{`*n*`}`, `{`*n*`,}` и `{`*n*`,`*m*`}`.</span><span class="sxs-lookup"><span data-stu-id="f1adb-293">White space isn't allowed within a bracketed quantifier, such as `{`*n*`}`, `{`*n*`,}`, and `{`*n*`,`*m*`}`.</span></span> <span data-ttu-id="f1adb-294">Например, шаблон регулярного выражения `\d{1, 3}` не сопоставляет последовательности цифр из одной до трех цифр, так как он содержит пробел.</span><span class="sxs-lookup"><span data-stu-id="f1adb-294">For example, the regular expression pattern `\d{1, 3}` fails to match any sequences of digits from one to three digits because it contains a white-space character.</span></span>

- <span data-ttu-id="f1adb-295">Пробел не допускается в последовательности символов, предоставляющей языковой элемент.</span><span class="sxs-lookup"><span data-stu-id="f1adb-295">White space isn't allowed within a character sequence that introduces a language element.</span></span> <span data-ttu-id="f1adb-296">Например:</span><span class="sxs-lookup"><span data-stu-id="f1adb-296">For example:</span></span>

  - <span data-ttu-id="f1adb-297">Языковой элемент `(?:`*subexpression*`)` представляет незахватываемую группу, а часть `(?:` элемента не может включать пробелы.</span><span class="sxs-lookup"><span data-stu-id="f1adb-297">The language element `(?:`*subexpression*`)` represents a noncapturing group, and the `(?:` portion of the element can't have embedded spaces.</span></span> <span data-ttu-id="f1adb-298">Шаблон `(? :`*часть выражения*`)` вызывает исключение <xref:System.ArgumentException> во время выполнения, так как механизм регулярных выражений не может проанализировать шаблон, а шаблону `( ?:`*часть выражения*`)` не удается сопоставить *часть выражения*.</span><span class="sxs-lookup"><span data-stu-id="f1adb-298">The pattern `(? :`*subexpression*`)` throws an <xref:System.ArgumentException> at run time because the regular expression engine can't parse the pattern, and the pattern `( ?:`*subexpression*`)` fails to match *subexpression*.</span></span>

  - <span data-ttu-id="f1adb-299">Языковой элемент `\p{`*name*`}`, представляющий категорию Юникода или именованный блок, не может содержать пробелы в части `\p{` элемента.</span><span class="sxs-lookup"><span data-stu-id="f1adb-299">The language element `\p{`*name*`}`, which represents a Unicode category or named block, can't include embedded spaces in the `\p{` portion of the element.</span></span> <span data-ttu-id="f1adb-300">Если все-таки добавить пробел, элемент вызовет исключение <xref:System.ArgumentException> во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="f1adb-300">If you do include a white space, the element throws an <xref:System.ArgumentException> at run time.</span></span>

<span data-ttu-id="f1adb-301">Включение этого параметра позволяет упростить регулярные выражения, синтаксический анализ и понимание которых зачастую вызывают затруднения.</span><span class="sxs-lookup"><span data-stu-id="f1adb-301">Enabling this option helps simplify regular expressions that are often difficult to parse and to understand.</span></span> <span data-ttu-id="f1adb-302">Это улучшает читаемость и позволяет документировать регулярное выражение.</span><span class="sxs-lookup"><span data-stu-id="f1adb-302">It improves readability, and makes it possible to document a regular expression.</span></span>

<span data-ttu-id="f1adb-303">В этом примере определяется следующий шаблон регулярного выражения:</span><span class="sxs-lookup"><span data-stu-id="f1adb-303">The following example defines the following regular expression pattern:</span></span>

`\b \(? ( (?>\w+) ,?\s? )+  [\.!?] \)? # Matches an entire sentence.`

<span data-ttu-id="f1adb-304">Этот шаблон похож на тот, что был определен в разделе [Только явные захваты](#Explicit), но он использует параметр <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> для пропуска пробелов в шаблоне.</span><span class="sxs-lookup"><span data-stu-id="f1adb-304">This pattern is similar to the pattern defined in the [Explicit Captures Only](#Explicit) section, except that it uses the <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option to ignore pattern white space.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#12](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/whitespace1.cs#12)]
[!code-vb[Conceptual.Regex.Language.Options#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/whitespace1.vb#12)]

<span data-ttu-id="f1adb-305">Следующий пример использует встроенный параметр `(?x)` для пропуска пробелов.</span><span class="sxs-lookup"><span data-stu-id="f1adb-305">The following example uses the inline option `(?x)` to ignore pattern white space.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#13](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/whitespace2.cs#13)]
[!code-vb[Conceptual.Regex.Language.Options#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/whitespace2.vb#13)]

[<span data-ttu-id="f1adb-306">К началу</span><span class="sxs-lookup"><span data-stu-id="f1adb-306">Back to Top</span></span>](#Top)

<a name="RightToLeft"></a>

## <a name="right-to-left-mode"></a><span data-ttu-id="f1adb-307">Режим "справа налево"</span><span class="sxs-lookup"><span data-stu-id="f1adb-307">Right-to-Left Mode</span></span>

<span data-ttu-id="f1adb-308">По умолчанию механизм регулярных выражений выполняет поиска слева направо.</span><span class="sxs-lookup"><span data-stu-id="f1adb-308">By default, the regular expression engine searches from left to right.</span></span> <span data-ttu-id="f1adb-309">Направление поиска можно изменить с помощью параметра <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f1adb-309">You can reverse the search direction by using the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="f1adb-310">Поиск автоматически будет начинаться с последнего символа строки.</span><span class="sxs-lookup"><span data-stu-id="f1adb-310">The search automatically begins at the last character position of the string.</span></span> <span data-ttu-id="f1adb-311">Для методов сопоставления шаблона с параметром начальной позиции, таких как <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>, начальная позиция — это индекс самого правого символа, с которого начинается поиск.</span><span class="sxs-lookup"><span data-stu-id="f1adb-311">For pattern-matching methods that include a starting position parameter, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>, the starting position is the index of the rightmost character position at which the search is to begin.</span></span>

> [!NOTE]
> <span data-ttu-id="f1adb-312">Чтобы включить режим "справа налево", необходимо передать значение <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> параметру `options` конструктора класса <xref:System.Text.RegularExpressions.Regex> или статичного метода сопоставления шаблона.</span><span class="sxs-lookup"><span data-stu-id="f1adb-312">Right-to-left pattern mode is available only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or static pattern-matching method.</span></span> <span data-ttu-id="f1adb-313">Этот параметр не может быть указан как встроенный.</span><span class="sxs-lookup"><span data-stu-id="f1adb-313">It is not available as an inline option.</span></span>

<span data-ttu-id="f1adb-314">Параметр <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> меняет только направление поиска, а не интерпретирует шаблон регулярного выражения справа налево.</span><span class="sxs-lookup"><span data-stu-id="f1adb-314">The <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option changes the search direction only; it does not interpret the regular expression pattern from right to left.</span></span> <span data-ttu-id="f1adb-315">Например, регулярное выражение `\bb\w+\s` сопоставляет слова, которые начинаются с буквы "b" и за которыми следует пробел.</span><span class="sxs-lookup"><span data-stu-id="f1adb-315">For example, the regular expression `\bb\w+\s` matches words that begin with the letter "b" and are followed by a white-space character.</span></span> <span data-ttu-id="f1adb-316">В следующем примере входная строка состоит из трех слов, которые содержат одну или несколько букв "b".</span><span class="sxs-lookup"><span data-stu-id="f1adb-316">In the following example, the input string consists of three words that include one or more "b" characters.</span></span> <span data-ttu-id="f1adb-317">Первое слово начинается с "b", второе заканчивается на "b", а в третьем буква "b" находится в середине слова.</span><span class="sxs-lookup"><span data-stu-id="f1adb-317">The first word begins with "b", the second ends with "b", and the third includes two "b" characters in the middle of the word.</span></span> <span data-ttu-id="f1adb-318">Как видно из результата примера, только первое слово соответствует шаблону регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="f1adb-318">As the output from the example shows, only the first word matches the regular expression pattern.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#17](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/righttoleft1.cs#17)]
[!code-vb[Conceptual.Regex.Language.Options#17](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/righttoleft1.vb#17)]

<span data-ttu-id="f1adb-319">Кроме того, обратите внимание, что утверждение просмотра вперед (фрагмент языка `(?=`*subexpression*`)`) и утверждение просмотра назад (элемент языка `(?<=`*subexpression*`)`) не изменяют направление поиска.</span><span class="sxs-lookup"><span data-stu-id="f1adb-319">Also note that the lookahead assertion (the `(?=`*subexpression*`)` language element) and the lookbehind assertion (the `(?<=`*subexpression*`)` language element) do not change direction.</span></span> <span data-ttu-id="f1adb-320">Утверждения просмотра вперед выполняют поиск вправо, а утверждения просмотра назад — влево.</span><span class="sxs-lookup"><span data-stu-id="f1adb-320">The lookahead assertions look to the right; the lookbehind assertions look to the left.</span></span> <span data-ttu-id="f1adb-321">Например, регулярное выражение `(?<=\d{1,2}\s)\w+,?\s\d{4}` использует утверждения просмотра назад для проверки наличия даты, перед которой идет название месяца.</span><span class="sxs-lookup"><span data-stu-id="f1adb-321">For example, the regular expression `(?<=\d{1,2}\s)\w+,?\s\d{4}` uses the lookbehind assertion to test for a date that precedes a month name.</span></span> <span data-ttu-id="f1adb-322">Затем регулярное выражение сопоставляет месяц и год.</span><span class="sxs-lookup"><span data-stu-id="f1adb-322">The regular expression then matches the month and the year.</span></span> <span data-ttu-id="f1adb-323">Сведения об утверждениях просмотра вперед и назад см. в статье [Конструкции группировки в регулярных выражениях](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="f1adb-323">For information on lookahead and lookbehind assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#18](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/righttoleft2.cs#18)]
[!code-vb[Conceptual.Regex.Language.Options#18](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/righttoleft2.vb#18)]

<span data-ttu-id="f1adb-324">Шаблон регулярного выражения определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="f1adb-324">The regular expression pattern is defined as shown in the following table.</span></span>

|<span data-ttu-id="f1adb-325">Шаблон</span><span class="sxs-lookup"><span data-stu-id="f1adb-325">Pattern</span></span>|<span data-ttu-id="f1adb-326">ОПИСАНИЕ</span><span class="sxs-lookup"><span data-stu-id="f1adb-326">Description</span></span>|
|-------------|-----------------|
|`(?<=\d{1,2}\s)`|<span data-ttu-id="f1adb-327">Слева от начала сопоставления должна идти одна или две десятичных цифры, за которыми следует пробел.</span><span class="sxs-lookup"><span data-stu-id="f1adb-327">The beginning of the match must be preceded by one or two decimal digits followed by a space.</span></span>|
|`\w+`|<span data-ttu-id="f1adb-328">Совпадение с одним или несколькими символами слова.</span><span class="sxs-lookup"><span data-stu-id="f1adb-328">Match one or more word characters.</span></span>|
|`,?`|<span data-ttu-id="f1adb-329">Выделяется ноль или один символ запятой.</span><span class="sxs-lookup"><span data-stu-id="f1adb-329">Match zero or one comma characters.</span></span>|
|`\s`|<span data-ttu-id="f1adb-330">Соответствует пробелу.</span><span class="sxs-lookup"><span data-stu-id="f1adb-330">Match a white-space character.</span></span>|
|`\d{4}`|<span data-ttu-id="f1adb-331">Выделяются 4 десятичные цифры.</span><span class="sxs-lookup"><span data-stu-id="f1adb-331">Match four decimal digits.</span></span>|

[<span data-ttu-id="f1adb-332">К началу</span><span class="sxs-lookup"><span data-stu-id="f1adb-332">Back to Top</span></span>](#Top)

<a name="ECMAScript"></a>

## <a name="ecmascript-matching-behavior"></a><span data-ttu-id="f1adb-333">Поведение сопоставления ECMAScript</span><span class="sxs-lookup"><span data-stu-id="f1adb-333">ECMAScript Matching Behavior</span></span>

<span data-ttu-id="f1adb-334">По умолчанию механизм регулярных выражений использует каноническое поведение при сопоставлении шаблона регулярного выражения с входным текстом.</span><span class="sxs-lookup"><span data-stu-id="f1adb-334">By default, the regular expression engine uses canonical behavior when matching a regular expression pattern to input text.</span></span> <span data-ttu-id="f1adb-335">Но вы можете использовать поведение сопоставления ECMAScript, указав параметр <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f1adb-335">However, you can instruct the regular expression engine to use ECMAScript matching behavior by specifying the <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> option.</span></span>

> [!NOTE]
> <span data-ttu-id="f1adb-336">Чтобы включить поведение ECMAScript, необходимо передать значение <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> параметру `options` конструктора класса <xref:System.Text.RegularExpressions.Regex> или статичного метода сопоставления шаблона.</span><span class="sxs-lookup"><span data-stu-id="f1adb-336">ECMAScript-compliant behavior is available only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or static pattern-matching method.</span></span> <span data-ttu-id="f1adb-337">Этот параметр не может быть указан как встроенный.</span><span class="sxs-lookup"><span data-stu-id="f1adb-337">It is not available as an inline option.</span></span>

<span data-ttu-id="f1adb-338">Параметр <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> может использоваться только вместе с параметрами <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> и <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f1adb-338">The <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> option can be combined only with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> options.</span></span> <span data-ttu-id="f1adb-339">При использовании других параметров в регулярном выражении возникает исключение <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="f1adb-339">The use of any other option in a regular expression results in an <xref:System.ArgumentOutOfRangeException>.</span></span>

<span data-ttu-id="f1adb-340">Поведение регулярных выражений ECMAScript и канонических регулярных выражений отличается в трех аспектах: синтаксис класса символов, ссылающиеся на себя захватываемые группы и интерпретация восьмеричных значений и обратных ссылок.</span><span class="sxs-lookup"><span data-stu-id="f1adb-340">The behavior of ECMAScript and canonical regular expressions differs in three areas: character class syntax, self-referencing capturing groups, and octal versus backreference interpretation.</span></span>

- <span data-ttu-id="f1adb-341">Синтаксис класса символов.</span><span class="sxs-lookup"><span data-stu-id="f1adb-341">Character class syntax.</span></span> <span data-ttu-id="f1adb-342">Так как канонические регулярные выражения поддерживают Юникод, а ECMAScript — нет, синтаксис классов символов в ECMAScript более ограничен, а некоторые языковые элементы класса символов обладают другим значением.</span><span class="sxs-lookup"><span data-stu-id="f1adb-342">Because canonical regular expressions support Unicode whereas ECMAScript does not, character classes in ECMAScript have a more limited syntax, and some character class language elements have a different meaning.</span></span> <span data-ttu-id="f1adb-343">Например, ECMAScript не поддерживает такие языковые элементы, как категория Юникода или элементы блока `\p` и `\P`.</span><span class="sxs-lookup"><span data-stu-id="f1adb-343">For example, ECMAScript does not support language elements such as the Unicode category or block elements `\p` and `\P`.</span></span> <span data-ttu-id="f1adb-344">Аналогичным образом, элемент `\w`, который сопоставляет словообразующее слово, эквивалентен классу символов `[a-zA-Z_0-9]` при использовании ECMAScript и `[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]` при использовании канонического поведения.</span><span class="sxs-lookup"><span data-stu-id="f1adb-344">Similarly, the `\w` element, which matches a word character, is equivalent to the `[a-zA-Z_0-9]` character class when using ECMAScript and `[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]` when using canonical behavior.</span></span> <span data-ttu-id="f1adb-345">Дополнительные сведения см. в разделе [Классы символов](../../../docs/standard/base-types/character-classes-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="f1adb-345">For more information, see [Character Classes](../../../docs/standard/base-types/character-classes-in-regular-expressions.md).</span></span>

  <span data-ttu-id="f1adb-346">Следующий пример иллюстрирует разницу между каноническим сопоставлением шаблона и ECMAScript.</span><span class="sxs-lookup"><span data-stu-id="f1adb-346">The following example illustrates the difference between canonical and ECMAScript pattern matching.</span></span> <span data-ttu-id="f1adb-347">В нем определяется регулярное выражение, `\b(\w+\s*)+`, сопоставляющее слова, за которыми следуют пробелы.</span><span class="sxs-lookup"><span data-stu-id="f1adb-347">It defines a regular expression, `\b(\w+\s*)+`, that matches words followed by white-space characters.</span></span> <span data-ttu-id="f1adb-348">Входные данные состоят из двух строк, одна из которых использует латиницу, а другая — кириллицу.</span><span class="sxs-lookup"><span data-stu-id="f1adb-348">The input consists of two strings, one that uses the Latin character set and the other that uses the Cyrillic character set.</span></span> <span data-ttu-id="f1adb-349">Как видно из результата, при вызове метода <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>, использующего сопоставление ECMAScript, не удается сопоставить слова на кириллице, а при вызове метода, использующего каноническое сопоставление — удается.</span><span class="sxs-lookup"><span data-stu-id="f1adb-349">As the output shows, the call to the <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method that uses ECMAScript matching fails to match the Cyrillic words, whereas the method call that uses canonical matching does match these words.</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#16](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/ecmascript1.cs#16)]
  [!code-vb[Conceptual.Regex.Language.Options#16](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/ecmascript1.vb#16)]

- <span data-ttu-id="f1adb-350">Ссылающиеся на себя захватываемые группы</span><span class="sxs-lookup"><span data-stu-id="f1adb-350">Self-referencing capturing groups.</span></span> <span data-ttu-id="f1adb-351">Класс захвата регулярного выражения с обратной ссылкой на себя необходимо обновлять после каждой итерации выделения.</span><span class="sxs-lookup"><span data-stu-id="f1adb-351">A regular expression capture class with a backreference to itself must be updated with each capture iteration.</span></span> <span data-ttu-id="f1adb-352">Как показано в следующем примере, это позволяет регулярному выражению `((a+)(\1) ?)+` сопоставить входную строку " aa aaaa aaaaaa " при использовании ECMAScript, но не канонического сопоставления.</span><span class="sxs-lookup"><span data-stu-id="f1adb-352">As the following example shows, this feature enables the regular expression `((a+)(\1) ?)+` to match the input string " aa aaaa aaaaaa " when using ECMAScript, but not when using canonical matching.</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#21](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/ecmascript2.cs#21)]
  [!code-vb[Conceptual.Regex.Language.Options#21](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/ecmascript2.vb#21)]

  <span data-ttu-id="f1adb-353">Определение регулярного выражения показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="f1adb-353">The regular expression is defined as shown in the following table.</span></span>

  |<span data-ttu-id="f1adb-354">Шаблон</span><span class="sxs-lookup"><span data-stu-id="f1adb-354">Pattern</span></span>|<span data-ttu-id="f1adb-355">ОПИСАНИЕ</span><span class="sxs-lookup"><span data-stu-id="f1adb-355">Description</span></span>|
  |-------------|-----------------|
  |<span data-ttu-id="f1adb-356">(a+)</span><span class="sxs-lookup"><span data-stu-id="f1adb-356">(a+)</span></span>|<span data-ttu-id="f1adb-357">Буква "a" выделяется один или несколько раз.</span><span class="sxs-lookup"><span data-stu-id="f1adb-357">Match the letter "a" one or more times.</span></span> <span data-ttu-id="f1adb-358">Это вторая группа записи.</span><span class="sxs-lookup"><span data-stu-id="f1adb-358">This is the second capturing group.</span></span>|
  |<span data-ttu-id="f1adb-359">(\1)</span><span class="sxs-lookup"><span data-stu-id="f1adb-359">(\1)</span></span>|<span data-ttu-id="f1adb-360">Сопоставление подстроки, выделенной первой захватываемой группой.</span><span class="sxs-lookup"><span data-stu-id="f1adb-360">Match the substring captured by the first capturing group.</span></span> <span data-ttu-id="f1adb-361">Это третья группа записи.</span><span class="sxs-lookup"><span data-stu-id="f1adb-361">This is the third capturing group.</span></span>|
  |<span data-ttu-id="f1adb-362">?</span><span class="sxs-lookup"><span data-stu-id="f1adb-362">?</span></span>|<span data-ttu-id="f1adb-363">Выделяется ноль или один символ пробела.</span><span class="sxs-lookup"><span data-stu-id="f1adb-363">Match zero or one space characters.</span></span>|
  |<span data-ttu-id="f1adb-364">((a+)(\1) ?)+</span><span class="sxs-lookup"><span data-stu-id="f1adb-364">((a+)(\1) ?)+</span></span>|<span data-ttu-id="f1adb-365">Один или несколько раз выделяется шаблон из одной или нескольких букв "a", за которыми следует строка, сопоставляющая первую захватываемую группу, за которой следует ноль или один символ пробела.</span><span class="sxs-lookup"><span data-stu-id="f1adb-365">Match the pattern of one or more "a" characters followed by a string that matches the first capturing group followed by zero or one space characters one or more times.</span></span> <span data-ttu-id="f1adb-366">Это первая группа записи.</span><span class="sxs-lookup"><span data-stu-id="f1adb-366">This is the first capturing group.</span></span>|

- <span data-ttu-id="f1adb-367">Разрешение неоднозначности между восьмеричными Escape-символами и обратными ссылками.</span><span class="sxs-lookup"><span data-stu-id="f1adb-367">Resolution of ambiguities between octal escapes and backreferences.</span></span> <span data-ttu-id="f1adb-368">В следующей таблице представлены общие сведения об отличиях интерпретации восьмеричных чисел и обратных ссылок при использовании канонических регулярных выражений и ECMAScript.</span><span class="sxs-lookup"><span data-stu-id="f1adb-368">The following table summarizes the differences in octal versus backreference interpretation by canonical and ECMAScript regular expressions.</span></span>

  |<span data-ttu-id="f1adb-369">Регулярное выражение</span><span class="sxs-lookup"><span data-stu-id="f1adb-369">Regular expression</span></span>|<span data-ttu-id="f1adb-370">Каноническое поведение</span><span class="sxs-lookup"><span data-stu-id="f1adb-370">Canonical behavior</span></span>|<span data-ttu-id="f1adb-371">Поведение ECMAScript</span><span class="sxs-lookup"><span data-stu-id="f1adb-371">ECMAScript behavior</span></span>|
  |------------------------|------------------------|-------------------------|
  |<span data-ttu-id="f1adb-372">`\0` с последующими 0-2 восьмеричными цифрами</span><span class="sxs-lookup"><span data-stu-id="f1adb-372">`\0` followed by 0 to 2 octal digits</span></span>|<span data-ttu-id="f1adb-373">Интерпретируется как восьмеричное число.</span><span class="sxs-lookup"><span data-stu-id="f1adb-373">Interpret as an octal.</span></span> <span data-ttu-id="f1adb-374">Например, `\044` всегда интерпретируется как восьмеричное значение и означает "$".</span><span class="sxs-lookup"><span data-stu-id="f1adb-374">For example, `\044` is always interpreted as an octal value and means "$".</span></span>|<span data-ttu-id="f1adb-375">Такое же поведение.</span><span class="sxs-lookup"><span data-stu-id="f1adb-375">Same behavior.</span></span>|
  |<span data-ttu-id="f1adb-376">`\` с последующей цифрой от 1 до 9, за которой нет дополнительных десятичных цифр. | Интерпретировать как обратную ссылку.</span><span class="sxs-lookup"><span data-stu-id="f1adb-376">`\` followed by a digit from 1 to 9, followed by no additional decimal digits,|Interpret as a backreference.</span></span> <span data-ttu-id="f1adb-377">Например, `\9` всегда означает обратную ссылку на 9, даже если девятая захватываемая группа не существует.</span><span class="sxs-lookup"><span data-stu-id="f1adb-377">For example, `\9` always means backreference 9, even if a ninth capturing group does not exist.</span></span> <span data-ttu-id="f1adb-378">Если захватываемая группа не существует, анализатор регулярных выражений вызывает исключение <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="f1adb-378">If the capturing group does not exist, the regular expression parser throws an <xref:System.ArgumentException>.</span></span>|<span data-ttu-id="f1adb-379">Если захватываемая группа из одной десятичной цифры существует, значение интерпретируется как обратная ссылка на эту цифру.</span><span class="sxs-lookup"><span data-stu-id="f1adb-379">If a single decimal digit capturing group exists, backreference to that digit.</span></span> <span data-ttu-id="f1adb-380">В противном случае оно интерпретируется как литерал.</span><span class="sxs-lookup"><span data-stu-id="f1adb-380">Otherwise, interpret the value as a literal.</span></span>|
  |<span data-ttu-id="f1adb-381">`\` с последующей цифрой от 1 до 9, за которой нет дополнительных десятичных цифр. | Интерпретировать цифры как десятичное значение.</span><span class="sxs-lookup"><span data-stu-id="f1adb-381">`\` followed by a digit from 1 to 9, followed by additional decimal digits|Interpret the digits as a decimal value.</span></span> <span data-ttu-id="f1adb-382">Если эта захватываемая группа существует, выражение интерпретируется как обратная ссылка.</span><span class="sxs-lookup"><span data-stu-id="f1adb-382">If that capturing group exists, interpret the expression as a backreference.</span></span><br /><br /> <span data-ttu-id="f1adb-383">В противном случае интерпретируются первые восьмеричные цифры до восьмеричного числа 377, т. е. учитываются только младшие 8 разрядов значения.</span><span class="sxs-lookup"><span data-stu-id="f1adb-383">Otherwise, interpret the leading octal digits up to octal 377; that is, consider only the low 8 bits of the value.</span></span> <span data-ttu-id="f1adb-384">Оставшиеся цифры интерпретируются как литералы.</span><span class="sxs-lookup"><span data-stu-id="f1adb-384">Interpret the remaining digits as literals.</span></span> <span data-ttu-id="f1adb-385">Например, выражение `\3000`, если захватываемая группа 300 существует, интерпретируется как обратная ссылка на 300. В противном случае оно интерпретируется как восьмеричное число 300, за которым следует 0.</span><span class="sxs-lookup"><span data-stu-id="f1adb-385">For example, in the expression `\3000`, if capturing group 300 exists, interpret as backreference 300; if capturing group 300 does not exist, interpret as octal 300 followed by 0.</span></span>|<span data-ttu-id="f1adb-386">Выражение интерпретируется как обратная ссылка, для этого как можно больше цифр преобразуется в десятичное значение, которые могут указывать на выделение.</span><span class="sxs-lookup"><span data-stu-id="f1adb-386">Interpret as a backreference by converting as many digits as possible to a decimal value that can refer to a capture.</span></span> <span data-ttu-id="f1adb-387">Если цифры не могут быть преобразованы, выражение интерпретируется как восьмеричное число с использованием первых восьмеричных разрядов до восьмеричного числа 377. Оставшиеся восьмеричные цифры интерпретируются как литералы.</span><span class="sxs-lookup"><span data-stu-id="f1adb-387">If no digits can be converted, interpret as an octal by using the leading octal digits up to octal 377; interpret the remaining digits as literals.</span></span>|

[<span data-ttu-id="f1adb-388">К началу</span><span class="sxs-lookup"><span data-stu-id="f1adb-388">Back to Top</span></span>](#Top)

<a name="Invariant"></a>

## <a name="comparison-using-the-invariant-culture"></a><span data-ttu-id="f1adb-389">Сравнение с использованием инвариантных региональных параметров</span><span class="sxs-lookup"><span data-stu-id="f1adb-389">Comparison Using the Invariant Culture</span></span>

<span data-ttu-id="f1adb-390">По умолчанию, когда механизм регулярных выражений выполняет сравнения без учета регистра, соглашения о регистре текущих региональных параметров используются для определения эквивалентных прописных и строчных символов.</span><span class="sxs-lookup"><span data-stu-id="f1adb-390">By default, when the regular expression engine performs case-insensitive comparisons, it uses the casing conventions of the current culture to determine equivalent uppercase and lowercase characters.</span></span>

<span data-ttu-id="f1adb-391">Однако это недопустимо для некоторых типов сравнения, например при сравнении введенных пользователем данных с именами системных ресурсов, таких как пароли, файлы и URL-адреса.</span><span class="sxs-lookup"><span data-stu-id="f1adb-391">However, this behavior is undesirable for some types of comparisons, particularly when comparing user input to the names of system resources, such as passwords, files, or URLs.</span></span> <span data-ttu-id="f1adb-392">В следующем примере показана подобная ситуация.</span><span class="sxs-lookup"><span data-stu-id="f1adb-392">The following example illustrates such as scenario.</span></span> <span data-ttu-id="f1adb-393">Этот код предназначен для блокировки доступа к любым ресурсам, URL-адрес которых начинается с **FILE://** .</span><span class="sxs-lookup"><span data-stu-id="f1adb-393">The code is intended to block access to any resource whose URL is prefaced with **FILE://**.</span></span> <span data-ttu-id="f1adb-394">Регулярное выражение пытается выполнить сопоставление без учета регистра, используя регулярное выражение `$FILE://`.</span><span class="sxs-lookup"><span data-stu-id="f1adb-394">The regular expression attempts a case-insensitive match with the string by using the regular expression `$FILE://`.</span></span> <span data-ttu-id="f1adb-395">Но текущие региональные параметры заданы как tr-TR (Турецкий-Турция), и "I" — не является прописным эквивалентом "i".</span><span class="sxs-lookup"><span data-stu-id="f1adb-395">However, when the current system culture is tr-TR (Turkish-Turkey), "I" is not the uppercase equivalent of "i".</span></span> <span data-ttu-id="f1adb-396">В результате вызов метода <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> возвращает `false`, и предоставляется доступ к файлу.</span><span class="sxs-lookup"><span data-stu-id="f1adb-396">As a result, the call to the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method returns `false`, and access to the file is allowed.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#14](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/culture1.cs#14)]
[!code-vb[Conceptual.Regex.Language.Options#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/culture1.vb#14)]

> [!NOTE]
> <span data-ttu-id="f1adb-397">Подробнее о сравнении строк с учетом регистра и использовании инвариантных региональных параметров см. в разделе [Рекомендации по использованию строк в .NET](../../../docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="f1adb-397">For more information about string comparisons that are case-sensitive and that use the invariant culture, see [Best Practices for Using Strings](../../../docs/standard/base-types/best-practices-strings.md).</span></span>

<span data-ttu-id="f1adb-398">Вместо использования сравнений без учета регистра текущих региональных параметров, можно указать параметр <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType>, чтобы игнорировать региональные отличия в языке и использовать соглашения инвариантных региональных параметров.</span><span class="sxs-lookup"><span data-stu-id="f1adb-398">Instead of using the case-insensitive comparisons of the current culture, you can specify the <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> option to ignore cultural differences in language and to use the conventions of the invariant culture.</span></span>

> [!NOTE]
> <span data-ttu-id="f1adb-399">Чтобы включить сравнение с использованием инвариантных региональных параметров, необходимо передать значение <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> параметру `options` конструктора класса <xref:System.Text.RegularExpressions.Regex> или статичного метода сопоставления шаблона.</span><span class="sxs-lookup"><span data-stu-id="f1adb-399">Comparison using the invariant culture is available only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or static pattern-matching method.</span></span> <span data-ttu-id="f1adb-400">Этот параметр не может быть указан как встроенный.</span><span class="sxs-lookup"><span data-stu-id="f1adb-400">It is not available as an inline option.</span></span>

<span data-ttu-id="f1adb-401">Следующий пример идентичен предыдущему, но в нем статичный метод <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> вызывается с параметрами, содержащими <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f1adb-401">The following example is identical to the previous example, except that the static <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method is called with options that include <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f1adb-402">Даже если в качестве региональных параметров выбрано "Турецкий (Турция)", механизм регулярных выражений сможет успешно сопоставить строки "FILE" и "file" и заблокировать доступ к файлу.</span><span class="sxs-lookup"><span data-stu-id="f1adb-402">Even when the current culture is set to Turkish (Turkey), the regular expression engine is able to successfully match "FILE" and "file" and block access to the file resource.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#15](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/culture1.cs#15)]
[!code-vb[Conceptual.Regex.Language.Options#15](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/culture1.vb#15)]

## <a name="see-also"></a><span data-ttu-id="f1adb-403">См. также</span><span class="sxs-lookup"><span data-stu-id="f1adb-403">See also</span></span>

- [<span data-ttu-id="f1adb-404">Элементы языка регулярных выражений — краткий справочник</span><span class="sxs-lookup"><span data-stu-id="f1adb-404">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)
