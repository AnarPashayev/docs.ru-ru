---
title: Кодировка символов в .NET
description: Сведения о кодировании и декодировании символов в .NET.
ms.date: 12/22/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- encoding, understanding
- encoding, choosing
- encoding, fallback strategy
ms.assetid: bf6d9823-4c2d-48af-b280-919c5af66ae9
ms.openlocfilehash: 3cd461d8c56c3f31bf3ffe04acf239ecd32fe328
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2020
ms.locfileid: "75711445"
---
# <a name="character-encoding-in-net"></a>Кодировка символов в .NET

Символы — это абстрактные сущности, которые могут быть представлены различными способами. Кодировка — это система, где с каждым символом поддерживаемого набора символов сопоставляется значение, представляющее этот символ. Например, азбука Морзе — это кодировка, в которой каждому символу латинского алфавита соответствует набор точек и тире, которые можно передавать с помощью телеграфа. Компьютерная кодировка — это система, где с каждым символом поддерживаемого набора символов сопоставлено числовое значение, представляющее этот символ. Кодировка состоит из двух компонентов:

- кодировщик, преобразующий последовательность символов в последовательность числовых значений (байтов);

- декодер, преобразующий последовательность байтов в последовательность символов.

Кодировка описывает правила, по которым работают кодировщик и декодер. Например, класс <xref:System.Text.UTF8Encoding> описывает правила кодирования и декодирования для формата UTF-8, в котором используется от одного до четырех байтов для представления одного символа Юникода. В процессе кодирования и декодирования также может выполняться проверка. Например, класс <xref:System.Text.UnicodeEncoding> предназначен для проверки допустимости пар, составляемых всеми символами-заместителями. (Пара символов-заместителей состоит из символа с кодовой точкой в диапазоне от U+D800 до U+DBFF и символа с кодовой точкой в диапазоне от U+DC00 до U+DFFF.)  Резервная стратегия определяет, как кодировщик обрабатывает недопустимые символы или как декодер обрабатывает недопустимые байты.

> [!WARNING]
> Классы кодировок .NET позволяют хранить и преобразовывать символьные данные. Их не следует использовать для хранения двоичных данных в строковом виде. В зависимости от используемой кодировки преобразование двоичных данных в строковый формат с использованием классов кодировок может привести к неожиданному результату и неточным или поврежденным данным. Для преобразования двоичных данных в строковый формат используйте метод <xref:System.Convert.ToBase64String%2A?displayProperty=nameWithType> .

.NET использует для представления символов и строк кодировку UTF-16 (представленную классом <xref:System.Text.UnicodeEncoding>). В приложениях, предназначенных для среды CLR, кодировщики используются для сопоставления представлений символов Юникода, поддерживаемых средой CLR, с другими схемами кодирования. Декодеры служат для сопоставления символов различных кодировок с Юникодом.

В этом разделе:

- [Кодировки в .NET](../../../docs/standard/base-types/character-encoding.md#Encodings)

- [Выбор класса кодировки](../../../docs/standard/base-types/character-encoding.md#Selecting)

- [Использование объекта кодировки](../../../docs/standard/base-types/character-encoding.md#Using)

- [Выбор резервной стратегии](../../../docs/standard/base-types/character-encoding.md#FallbackStrategy)

- [Implementing a Custom Fallback Strategy](../../../docs/standard/base-types/character-encoding.md#Custom)

<a name="Encodings"></a>

## <a name="encodings-in-net"></a>Кодировки в .NET

Все классы кодировок в .NET наследуют от абстрактного класса <xref:System.Text.Encoding?displayProperty=nameWithType>, который определяет общую для всех кодировок функциональность. Для доступа к отдельным объектам кодировок, реализованным в .NET, можно сделать следующее:

- Используйте статические свойства класса <xref:System.Text.Encoding>, которые возвращают объекты, представляющие стандартные кодировки символов .NET (ASCII, UTF-7, UTF-8, UTF-16 и UTF-32). Например, свойство <xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType> возвращает объект <xref:System.Text.UnicodeEncoding> . Каждый объект использует резервную стратегию замены для обработки строк, которые он не может закодировать, и байтов, которые не может декодировать. (Дополнительные сведения см. в разделе [Replacement Fallback](../../../docs/standard/base-types/character-encoding.md#Replacement) .)

- Вызвать конструктор класса кодировки. Таким образом могут быть созданы объекты для кодировок ASCII, UTF-7, UTF-8, UTF-16 и UTF-32. По умолчанию каждый объект использует резервную стратегию замены для обработки строк, которые он не может закодировать, и байтов, которые он не может декодировать, но вы можете указать, чтобы вместо этого создавалось исключение. (Дополнительные сведения см. в разделах [Replacement Fallback](../../../docs/standard/base-types/character-encoding.md#Replacement) и [Exception Fallback](../../../docs/standard/base-types/character-encoding.md#Exception) .)

- Вызвать конструктор <xref:System.Text.Encoding.%23ctor%28System.Int32%29?displayProperty=nameWithType> и передать ему целое число, представляющее кодировку. Объекты стандартных кодировок используют резервные стратегии замены, а объекты кодовых страниц и двухбайтовых кодировок (DBCS) используют резервную стратегию наилучшего соответствия для обработки строк, которые не удается закодировать, или байтов, которые не удается декодировать. (Дополнительные сведения см. в разделе [Best-Fit Fallback](../../../docs/standard/base-types/character-encoding.md#BestFit) .)

- Вызовите метод <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType>, возвращающий любую стандартную кодировку, кодовую страницу или кодировку DBCS, доступную в .NET. Перегрузки позволяют задать резервный объект как для кодировщика, так и для декодера.

> [!NOTE]
> В стандарте Юникода каждому символу в каждом поддерживаемом символьном наборе присваивается кодовая точка (номер) и имя. Например, символ "A" представляется кодовой точкой U+0041 и именем LATIN CAPITAL LETTER A. Кодировки UTF определяют способы кодирования кодовой точки в виде последовательности из одного или нескольких байтов. Схема кодировки Юникод упрощает разработку международных приложений, так как позволяет представлять символы любых наборов символов в единой кодировке. Разработчикам приложений больше не нужно сохранять данные о схеме кодировки, которая использовалась для представления символов конкретного языка или системы письма. Передача данных между системами, использующими различные языки, может происходить без искажений.
>
> Платформа .NET поддерживает три кодировки, определенные стандартом Юникод: UTF-8, UTF-16 и UTF-32. Дополнительные сведения см. в описании стандарта Юникод на [домашней странице Юникода](https://www.unicode.org/).

Информацию обо всех доступных в .NET кодировках можно получить, вызвав метод <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>. Платформа .NET поддерживает системы кодирования символов, перечисленные в таблице ниже.

|кодировка|Класс|Описание|Преимущества и недостатки|
|--------------|-----------|-----------------|-------------------------------|
|ASCII|<xref:System.Text.ASCIIEncoding>|Кодирует ограниченный диапазон символов, используя семь младших битов байта.|Так как эта кодировка поддерживает только значения символов от U+0000 до U+007F, то в большинстве случаев она не отвечает требованиям международных приложений.|
|UTF-7|<xref:System.Text.UTF7Encoding>|Представляет символы в виде последовательностей 7-разрядных символов ASCII. Символы Юникода, не относящиеся к ASCII, представляются в виде escape-последовательности символов ASCII.|UTF-7 поддерживает протоколы, например протоколы электронной почты и группы новостей. Однако формат UTF-7 недостаточно безопасен и надежен. В некоторых случаях изменение одного бита может привести к существенному изменению интерпретации всей строки UTF-7. В других случаях для кодировки одного и того же текста могут использоваться разные строки UTF-7. В последовательностях, содержащих отличные от ASCII символы, формат UTF-7 требует больше места, чем UTF-8, а кодирование и декодирование выполняются медленнее. Поэтому по возможности лучше использовать UTF-8 вместо UTF-7.|
|UTF-8|<xref:System.Text.UTF8Encoding>|Представляет каждую кодовую точку Юникода в виде последовательности от одного до четырех байтов.|UTF-8 поддерживает 8-разрядный размер данных и хорошо работает со многими операционными системами. Для диапазона символов ASCII кодировка UTF-8 идентична кодировке ASCII и предоставляет более широкий набор символов. Однако для китайской, японской и корейской письменности UTF-8 может потребовать три байта для каждого символа, что может привести к большему объему данных по сравнению с UTF-16. Обратите внимание, что иногда увеличение размера данных для китайской, японской и корейской письменности объясняется объемом данных ASCII, например тегами HTML.|
|UTF-16|<xref:System.Text.UnicodeEncoding>|Представляет каждую кодовую точку Юникода в виде последовательности одного или двух 16-разрядных целых чисел. Наиболее распространенные символы Юникода требуют только одной кодовой точки UTF-16, хотя дополнительные символы Юникода (U+10000 и далее) требуют двух замещающих кодовых точек UTF-16. Поддерживаются оба порядка байтов: прямой и обратный.|Кодировка UTF-16 используется средой CLR для представления значений <xref:System.Char> и <xref:System.String> , а операционной системой Windows — для представления значений `WCHAR` .|
|UTF-32|<xref:System.Text.UTF32Encoding>|Представляет каждую кодовую точку Юникода в виде 32-разрядного целого числа. Поддерживаются оба порядка байтов: прямой и обратный.|Кодировка UTF-32 используется в случае, когда приложению требуется избежать поведения замещающей кодовой точки кодировки UTF-16 в операционных системах, в которых закодированное пространство имеет большое значение. Для кодирования отдельных отображаемых глифов может использоваться несколько символов UTF-32.|
|Кодировки ANSI и ISO||Предоставляет поддержку ряда кодовых страниц. В операционных системах Windows кодовые страницы используются для поддержки конкретного языка или группы языков. Таблицу кодовых страниц, поддерживаемых платформой .NET, можно найти в описании класса <xref:System.Text.Encoding>. Чтобы получить объект кодировки для конкретной кодовой страницы, можно вызвать метод <xref:System.Text.Encoding.GetEncoding%28System.Int32%29?displayProperty=nameWithType> .|Кодовая страница содержит 256 кодовых точек с отсчетом от нуля. В большинстве кодовых страниц кодовые точки от 0 до 127 представляют набор символов ASCII, а кодовые точки от 128 до 255 существенно отличаются у разных кодовых страниц. Например, кодовая страница 1252 предоставляет символы для латинских систем письма, включая английский, немецкий и французский языки. Последние 128 кодовых точек на кодовой странице 1252 содержат диакритические знаки. Кодовая страница 1253 содержит коды символов, которые требуются в греческой системе письма. Последние 128 кодовых точек на кодовой странице 1253 содержат символы греческого языка. Таким образом, в приложении, использующем кодовые страницы ANSI, нельзя хранить греческий и немецкий тексты в одном потоке, если он не содержит идентификатор, указывающий соответствующую кодовую страницу.|
|Двухбайтовые кодировки (DBCS)||Поддерживают языки, такие как китайский, японский и корейский, содержащие более 256 символов. В кодировке DBCS каждый символ представлен парой кодовых точек (два байта). Свойство <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType> возвращает значение `false` для двухбайтовых кодировок. Чтобы получить объект кодировки для конкретной кодировки DBCS, можно вызвать метод <xref:System.Text.Encoding.GetEncoding%28System.Int32%29?displayProperty=nameWithType> .|В кодировке DBCS каждый символ представлен парой кодовых точек (два байта). Когда приложение обрабатывает данные DBCS, первый байт символа DBCS (старший байт) обрабатывается в сочетании со вторым байтом, следующим непосредственно за ним. Так как одна пара двухбайтовых кодовых точек может представлять различные символы в зависимости от кодовой страницы, эта схема также не позволяет использовать в одном потоке данных два языка, например японский и китайский.|

Эти кодировки позволяют работать с символами Юникода, а также с кодировками, которые часто используются в приложениях прежних версий. Кроме того, можно создать настраиваемую кодировку, определив класс, производный от <xref:System.Text.Encoding> , и переопределив его члены.

### <a name="platform-notes-net-core"></a>Заметки о платформе: .NET Core

По умолчанию .NET Core не предоставляет доступ к кодировкам кодовых страниц, кроме кодовой страницы 28591 и кодировок Юникода, например UTF-8 и UTF-16. Но вы можете добавить в свое приложение кодировки кодовых страниц из стандартных приложений Windows, ориентированных на .NET. Подробнее см. в разделе <xref:System.Text.CodePagesEncodingProvider> .

<a name="Selecting"></a>

## <a name="selecting-an-encoding-class"></a>Выбор класса кодировки

Если у вас есть возможность выбрать кодировку для использования в приложении, следует использовать Юникод, предпочтительно <xref:System.Text.UTF8Encoding> или <xref:System.Text.UnicodeEncoding>. (Также .NET поддерживает третью кодировку Юникода: <xref:System.Text.UTF32Encoding>.)

Если вы планируете использовать кодировку ASCII (<xref:System.Text.ASCIIEncoding>), выберите вместо нее <xref:System.Text.UTF8Encoding> . Эти две кодировки идентичны для набора символов ASCII, но <xref:System.Text.UTF8Encoding> имеет указанные ниже преимущества.

- Она может представлять любой символ Юникода, тогда как <xref:System.Text.ASCIIEncoding> поддерживает только символы Юникода в диапазоне от U+0000 до U+007F.

- Она обеспечивает обнаружение ошибок и более высокий уровень безопасности.

- Она настроена для максимально быстрой работы и должна быть быстрее любых других кодировок. Даже для содержимого, имеющего только формат ASCII, выполнение операций с помощью <xref:System.Text.UTF8Encoding> происходит быстрее, чем с помощью <xref:System.Text.ASCIIEncoding>.

Кодировку <xref:System.Text.ASCIIEncoding> рекомендуется использовать только для приложений прежних версий. Однако даже для приложений прежних версий <xref:System.Text.UTF8Encoding> может быть предпочтительнее по указанным ниже причинам (при параметрах по умолчанию).

- Если содержимое приложения включает символы не только в формате ASCII, при кодировании с помощью <xref:System.Text.ASCIIEncoding>каждый символ, не относящийся к ASCII, кодируется как знак вопроса (?). При последующем декодировании эти данные утрачиваются.

- Если содержимое приложения включает символы не только в формате ASCII, при кодировании с помощью <xref:System.Text.UTF8Encoding>представление символов в формате ASCII дает непригодный для чтения результат. Однако при последующем декодировании данных с помощью декодера UTF-8 обработка данных выполняется успешно.

В веб-приложении символы, отправленные клиенту в ответ на веб-запрос, должны отражать кодировку, используемую в клиенте. Как правило, требуется задать для свойства <xref:System.Web.HttpResponse.ContentEncoding%2A?displayProperty=nameWithType> значение, возвращаемое свойством <xref:System.Web.HttpRequest.ContentEncoding%2A?displayProperty=nameWithType> , для отображения текста в той кодировке, которую ожидает пользователь.

<a name="Using"></a>

## <a name="using-an-encoding-object"></a>Использование объекта кодировки

Кодировщик преобразует строку символов (чаще всего символов Юникода) в их числовой (байтовый) эквивалент. Например, кодировщик ASCII можно использовать для преобразования символов Юникода в ASCII, чтобы они могли отображаться на консоли. Чтобы выполнить преобразование, вызовите метод <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> . Если перед выполнением кодирования нужно определить, сколько байтов потребуется для хранения закодированных символов, можно вызвать метод <xref:System.Text.Encoding.GetByteCount%2A> .

В примере ниже один массив байтов используется для кодирования строк в двух отдельных операциях. Имеется индекс, указывающий начальную позицию в массиве байтов для следующего набора байтов, закодированных с использованием ASCII. Вызывается метод <xref:System.Text.ASCIIEncoding.GetByteCount%28System.String%29?displayProperty=nameWithType> для проверки того, что массив байтов достаточно велик для хранения закодированной строки. Затем вызывается метод <xref:System.Text.ASCIIEncoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> для кодирования символов в строке.

[!code-csharp[Conceptual.Encoding#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.encoding/cs/getbytes1.cs#8)]
[!code-vb[Conceptual.Encoding#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.encoding/vb/getbytes1.vb#8)]

Декодер преобразует массив байтов, отражающий конкретную кодировку символов, в набор символов в массиве символов или в строке. Чтобы декодировать массив байтов в массив символов, вызовите метод <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> . Чтобы декодировать массив байтов в строку, вызовите метод <xref:System.Text.Encoding.GetString%2A> . Если перед декодированием нужно определить, сколько символов требуется для хранения раскодированных байтов, можно вызвать метод <xref:System.Text.Encoding.GetCharCount%2A> .

В примере ниже три строки кодируются, а затем декодируются в один массив символов. Имеется индекс, указывающий начальную позицию в массиве символов для следующего набора декодированных символов. Вызывается метод <xref:System.Text.ASCIIEncoding.GetCharCount%2A> для проверки того, что массив символов достаточно велик для хранения всех декодированных символов. Затем вызывается метод <xref:System.Text.ASCIIEncoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> для декодирования массива байтов.

[!code-csharp[Conceptual.Encoding#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.encoding/cs/getchars1.cs#9)]
[!code-vb[Conceptual.Encoding#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.encoding/vb/getchars1.vb#9)]

Методы кодирования и декодирования класса, производного от класса <xref:System.Text.Encoding> , предназначены для работы с полным набором данных. Это значит, что все данные, подлежащие кодированию или декодированию, предоставляются в одном вызове метода. Однако в некоторых случаях данные предоставляются в потоке, тогда данные для кодирования и декодирования можно получить только с помощью нескольких операций чтения. В таком случае необходимо, чтобы операция кодирования или декодирования "помнила" сохраненное после предыдущего вызова состояние. Методы классов, производных от <xref:System.Text.Encoder> и <xref:System.Text.Decoder> , могут обрабатывать операции кодирования и декодирования, охватывающие несколько вызовов методов.

Объект <xref:System.Text.Encoder> для конкретной кодировки доступен в ее свойстве <xref:System.Text.Encoding.GetEncoder%2A?displayProperty=nameWithType> . Объект <xref:System.Text.Decoder> для конкретной кодировки доступен в ее свойстве <xref:System.Text.Encoding.GetDecoder%2A?displayProperty=nameWithType> . Что касается операций декодирования, обратите внимание, что классы, производные от <xref:System.Text.Decoder> , включают метод <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> , но не имеют метода, соответствующего <xref:System.Text.Encoding.GetString%2A?displayProperty=nameWithType>.

В примере ниже показано различие между использованием методов <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> и <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> для декодирования массива байтов Юникода. В этом примере строка, содержащая несколько символов Юникода, кодируется в файл, а затем два метода декодирования используются для декодирования по десять байтов за раз. Так как замещающая пара оказывается в десятом и одиннадцатом байтах, она декодируется в отдельных вызовах метода. Как видно из выходных данных, метод <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> не может правильно декодировать байты и заменяет их символом U+FFFD (замещающим символом). С другой стороны, метод <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> может успешно декодировать массив байтов для получения исходной строки.

[!code-csharp[Conceptual.Encoding#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.encoding/cs/stream1.cs#10)]
[!code-vb[Conceptual.Encoding#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.encoding/vb/stream1.vb#10)]

<a name="FallbackStrategy"></a>

## <a name="choosing-a-fallback-strategy"></a>Выбор резервной стратегии

Когда метод пытается закодировать или декодировать символ, но не находит сопоставления, он должен использовать резервную стратегию, определяющую, как должно обрабатываться отсутствие сопоставления. Существует три типа резервных стратегий:

- Best-Fit Fallback

- Replacement Fallback

- Exception Fallback

> [!IMPORTANT]
> При операциях кодирования наиболее часто проблемы возникают, когда символ Юникода не удается сопоставить с определенной кодировкой кодовой страницы. При операциях декодирования наиболее часто проблемы возникают, когда недопустимую последовательность байтов не удается преобразовать в допустимые символы Юникода. Поэтому необходимо знать, какую резервную стратегию использует определенный объект кодировки. По возможности при создании экземпляра объекта следует указывать резервную стратегию, используемую объектом кодировки.

<a name="BestFit"></a>

### <a name="best-fit-fallback"></a>Best-Fit Fallback

Если символ не имеет точного соответствия в целевой кодировке, кодировщик может попытаться сопоставить его с похожим символом. (Стратегия наилучшего соответствия связана с проблемами, возникающими скорее при кодировании, чем при декодировании. Существует лишь небольшое число кодовых страниц, символы которых нельзя сопоставить с Юникодом.) Стратегия наилучшего соответствия является стратегией по умолчанию для кодовых страниц и двухбайтовых кодировок, извлекаемых перегрузками <xref:System.Text.Encoding.GetEncoding%28System.Int32%29?displayProperty=nameWithType> и <xref:System.Text.Encoding.GetEncoding%28System.String%29?displayProperty=nameWithType>.

> [!NOTE]
> Теоретически все классы кодировок Юникода, доступные в .NET (<xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding> и <xref:System.Text.UTF32Encoding>), поддерживают все символы всех наборов символов, поэтому при их использовании не возникает проблем со стратегией наилучшего соответствия.

Для разных кодовых страниц применяются разные стратегии наилучшего соответствия. Например, для некоторых кодовых страниц полноширинные латинские символы сопоставляются с более распространенными полуширинными символами. Для других кодовых страниц такое сопоставление не выполняется. Даже в случае применения активной стратегии наилучшего соответствия для некоторых символов некоторых кодировок отсутствует возможное сопоставление. Например, для идеографических символов китайского алфавита отсутствуют корректные сопоставления с символами кодовой страницы 1252. В этом случае используются замещающие строки. По умолчанию в качестве замещающей строки используется знак вопроса (U+003F).

> [!NOTE]
> Стратегии наилучшего соответствия не документированы подробно. Но для некоторых кодовых страниц их можно найти на веб-сайте [Unicode Consortium](https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/). Изучите файл **readme.txt** в предоставленной папке, где описаны правила интерпретации для файлов сопоставления.

В примере ниже используется кодовая страница 1252 (кодовая страница Windows для западноевропейских языков) для иллюстрации стратегии наилучшего соответствия и ее недостатков. Метод <xref:System.Text.Encoding.GetEncoding%28System.Int32%29?displayProperty=nameWithType> используется для получения объекта кодировки для кодовой страницы 1252. По умолчанию для неподдерживаемых символов Юникода используется стратегия наилучшего соответствия. В примере создается экземпляр строки, содержащий три символа, не относящихся к ASCII (прописная латинская буква S в кружке (U+24C8), надстрочный индекс 5 (U+2075) и знак бесконечности (U+221E)), разделенные пробелами. Как видно из выходных данных примера, при кодировке строки три исходных отличных от пробела символа заменяются вопросительным знаком (U+003F), цифрой пять (U+0035) и цифрой восемь (U+0038). Цифра восемь — особенно неудачная замена неподдерживаемого знака бесконечности, а вопросительный знак показывает, что для исходного символа сопоставление не найдено.

[!code-csharp[Conceptual.Encoding#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.encoding/cs/bestfit1.cs#1)]
[!code-vb[Conceptual.Encoding#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.encoding/vb/bestfit1.vb#1)]

По умолчанию для объекта <xref:System.Text.Encoding> применяется стратегия наилучшего соответствия, при которой данные в формате Юникод кодируются в формат кодовой страницы. Ряд приложений предыдущих версий построен с учетом этой стратегии. Однако в целях безопасности в большинстве новых приложений не рекомендуется применять эту стратегию. Например, приложениям не следует выполнять кодировку доменного имени в режиме наилучшего соответствия.

> [!NOTE]
> Вы также можете реализовать пользовательскую стратегию наилучшего соответствия для кодировки. Дополнительные сведения см. в разделе [Implementing a Custom Fallback Strategy](../../../docs/standard/base-types/character-encoding.md#Custom) .

Если стратегия наилучшего соответствия задана по умолчанию для объекта кодировки, вы можете выбрать другую резервную стратегию при извлечении объекта <xref:System.Text.Encoding> с помощью вызова перегрузки <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> или <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> . В следующем разделе приводится пример, в котором каждый символ, который не удается сопоставить с кодовой страницей 1252, заменяется звездочкой (*).

[!code-csharp[Conceptual.Encoding#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.encoding/cs/bestfit1a.cs#3)]
[!code-vb[Conceptual.Encoding#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.encoding/vb/bestfit1a.vb#3)]

<a name="Replacement"></a>

### <a name="replacement-fallback"></a>Replacement Fallback

Когда символ не имеет точного соответствия в целевой схеме и нет подходящего символа, с которым его можно сопоставить, приложение может использовать замещающий символ или строку. Так по умолчанию поступает декодер Юникода, заменяющий любую двухбайтовую последовательность, которую он не может декодировать, замещающим символом (U+FFFD). Кроме того, это поведение по умолчанию класса <xref:System.Text.ASCIIEncoding> , который заменяет каждый символ, который не удается кодировать или декодировать, вопросительным знаком. В примере ниже показана замена символов для строки Юникода из предыдущего примера. Как видно из выходных данных, каждый символ, который не удается декодировать в байтовое значение ASCII, заменяется 0x3F, то есть кодом ASCII для вопросительного знака.

[!code-csharp[Conceptual.Encoding#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.encoding/cs/replacementascii.cs#2)]
[!code-vb[Conceptual.Encoding#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.encoding/vb/replacementascii.vb#2)]

В .NET есть классы <xref:System.Text.EncoderReplacementFallback> и <xref:System.Text.DecoderReplacementFallback>, которые подставляют замещающую строку, если не удается точно сопоставить символ при кодировании или декодировании. По умолчанию эта замещающая строка — вопросительный знак, но вы можете вызвать перегрузку конструктора класса, чтобы выбрать другую строку. Как правило, замещающая строка — это отдельный символ, хотя это необязательно. В примере ниже поведение кодировщика кодовой страницы 1252 изменяется путем создания экземпляра объекта <xref:System.Text.EncoderReplacementFallback> , который использует символ звездочки (*) в качестве замещающей строки.

[!code-csharp[Conceptual.Encoding#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.encoding/cs/bestfit1a.cs#3)]
[!code-vb[Conceptual.Encoding#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.encoding/vb/bestfit1a.vb#3)]

> [!NOTE]
> Также можно реализовать класс замены для кодировки. Дополнительные сведения см. в разделе [Implementing a Custom Fallback Strategy](../../../docs/standard/base-types/character-encoding.md#Custom) .

Помимо вопросительного знака (U+003F) в качестве замещающей строки часто используется замещающий символ Юникода (U+FFFD), особенно при декодировании последовательностей байтов, которые не удается преобразовать в символы Юникода. Однако вы можете выбрать любую замещающую строку, в том числе из нескольких символов.

<a name="Exception"></a>

### <a name="exception-fallback"></a>Exception Fallback

Вместо подстановки наиболее подходящей или замещающей строки кодировщик может создавать исключение <xref:System.Text.EncoderFallbackException> , если не удается закодировать набор символов, а декодер — создавать исключение <xref:System.Text.DecoderFallbackException> , если не удается декодировать массив байтов. Для создания исключения в операциях кодирования и декодирования методу <xref:System.Text.EncoderExceptionFallback> необходимо предоставить объект <xref:System.Text.DecoderExceptionFallback> или <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> соответственно. В примере ниже иллюстрируется резервная стратегия исключения с классом <xref:System.Text.ASCIIEncoding> .

[!code-csharp[Conceptual.Encoding#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.encoding/cs/exceptionascii.cs#4)]
[!code-vb[Conceptual.Encoding#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.encoding/vb/exceptionascii.vb#4)]

> [!NOTE]
> Вы также можете реализовать пользовательский обработчик исключений для операции кодирования. Дополнительные сведения см. в разделе [Implementing a Custom Fallback Strategy](../../../docs/standard/base-types/character-encoding.md#Custom) .

Объекты <xref:System.Text.EncoderFallbackException> и <xref:System.Text.DecoderFallbackException> предоставляют следующую информацию о состоянии, вызвавшем исключение:

- Объект <xref:System.Text.EncoderFallbackException> включает метод <xref:System.Text.EncoderFallbackException.IsUnknownSurrogate%2A> , указывающий, представляют ли символы (или символ), которые не удается закодировать, неизвестную замещающую пару (тогда метод возвращает значение `true`) или неизвестный отдельный символ (тогда метод возвращает значение `false`). Символы замещающей пары доступны в свойствах <xref:System.Text.EncoderFallbackException.CharUnknownHigh%2A?displayProperty=nameWithType> и <xref:System.Text.EncoderFallbackException.CharUnknownLow%2A?displayProperty=nameWithType> . Неизвестный отдельный символ доступен в свойстве <xref:System.Text.EncoderFallbackException.CharUnknown%2A?displayProperty=nameWithType> . Свойство <xref:System.Text.EncoderFallbackException.Index%2A?displayProperty=nameWithType> указывает позицию первого символа, который не удалось закодировать, в строке.

- Объект <xref:System.Text.DecoderFallbackException> включает свойство <xref:System.Text.DecoderFallbackException.BytesUnknown%2A> , возвращающее массив байтов, которые не удается декодировать. Свойство <xref:System.Text.DecoderFallbackException.Index%2A?displayProperty=nameWithType> указывает начальную позицию неизвестных байтов.

Несмотря на то что объекты <xref:System.Text.EncoderFallbackException> и <xref:System.Text.DecoderFallbackException> предоставляют достаточно подробную диагностическую информацию об исключении, они не предоставляют доступ к буферу кодирования или декодирования. Поэтому они не позволяют заменять или исправлять недопустимые данные в методе кодирования или декодирования.

<a name="Custom"></a>

## <a name="implementing-a-custom-fallback-strategy"></a>Implementing a Custom Fallback Strategy

Помимо встроенной стратегии наилучшего соответствия, реализованной кодовыми страницами, платформа .NET содержит следующие классы для реализации резервной стратегии:

- — классы <xref:System.Text.EncoderReplacementFallback> и <xref:System.Text.EncoderReplacementFallbackBuffer> можно использовать для замены символов в операциях кодирования;

- — классы <xref:System.Text.DecoderReplacementFallback> и <xref:System.Text.DecoderReplacementFallbackBuffer> можно использовать для замены символов в операциях декодирования;

- — классы <xref:System.Text.EncoderExceptionFallback> и <xref:System.Text.EncoderExceptionFallbackBuffer> можно использовать для создания исключения <xref:System.Text.EncoderFallbackException> , когда символ не удается закодировать;

- — классы <xref:System.Text.DecoderExceptionFallback> и <xref:System.Text.DecoderExceptionFallbackBuffer> можно использовать для создания исключения <xref:System.Text.DecoderFallbackException> , когда символ не удается декодировать.

Кроме того, можно реализовать пользовательское решение, использующее резервную стратегию наилучшего соответствия или стратегию исключения, выполнив указанные ниже действия.

1. Создайте класс, производный от <xref:System.Text.EncoderFallback> , для операций кодирования и класс, производный от <xref:System.Text.DecoderFallback> , для операций декодирования.

2. Создайте класс, производный от <xref:System.Text.EncoderFallbackBuffer> , для операций кодирования и класс, производный от <xref:System.Text.DecoderFallbackBuffer> , для операций декодирования.

3. Для задания резервной стратегии исключения, если классы <xref:System.Text.EncoderFallbackException> и <xref:System.Text.DecoderFallbackException> не отвечают вашим требованиям, следует наследовать класс от объекта исключения, например <xref:System.Exception> или <xref:System.ArgumentException>.

### <a name="deriving-from-encoderfallback-or-decoderfallback"></a>Наследование от класса EncoderFallback или класса DecoderFallback

Для реализации пользовательской резервной стратегии необходимо создать класс, наследующий от <xref:System.Text.EncoderFallback> для операций кодирования и от класса <xref:System.Text.DecoderFallback> для операций декодирования. Экземпляры этих классов передаются в метод <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> и служат посредниками между классом кодировки и реализацией резервной стратегии.

При создании пользовательской резервной стратегии для кодировщика или декодера необходимо реализовать следующие члены:

- — свойство <xref:System.Text.EncoderFallback.MaxCharCount%2A?displayProperty=nameWithType> или <xref:System.Text.DecoderFallback.MaxCharCount%2A?displayProperty=nameWithType> , возвращающее максимально возможное число символов, которое может использоваться для замены одного символа в стратегиях наилучшего соответствия, замены или исключения. Для пользовательской резервной стратегии исключения его значение равно нулю.

- Метод <xref:System.Text.EncoderFallback.CreateFallbackBuffer%2A?displayProperty=nameWithType> или <xref:System.Text.DecoderFallback.CreateFallbackBuffer%2A?displayProperty=nameWithType> , возвращающий пользовательскую реализацию <xref:System.Text.EncoderFallbackBuffer> или <xref:System.Text.DecoderFallbackBuffer> . Метод вызывается кодировщиком, когда он встречает первый символ, который не удается закодировать, или декодером, когда он встречает первый байт, который не удается декодировать.

### <a name="deriving-from-encoderfallbackbuffer-or-decoderfallbackbuffer"></a>Наследование от класса EncoderFallbackBuffer или класса DecoderFallbackBuffer

Для реализации пользовательской резервной стратегии необходимо также создать класс, наследующий от <xref:System.Text.EncoderFallbackBuffer> для операций кодирования и от класса <xref:System.Text.DecoderFallbackBuffer> для операций декодирования. Экземпляры этих классов возвращаются методом <xref:System.Text.EncoderFallback.CreateFallbackBuffer%2A> классов <xref:System.Text.EncoderFallback> и <xref:System.Text.DecoderFallback> . Метод <xref:System.Text.EncoderFallback.CreateFallbackBuffer%2A?displayProperty=nameWithType> вызывается кодировщиком, когда он встречает первый символ, который не удается закодировать, а метод <xref:System.Text.DecoderFallback.CreateFallbackBuffer%2A?displayProperty=nameWithType> вызывается декодером, когда он встречает один или несколько байтов, которые не удается декодировать. Классы <xref:System.Text.EncoderFallbackBuffer> и <xref:System.Text.DecoderFallbackBuffer> предоставляют реализацию резервной стратегии. Каждый экземпляр представляет буфер, содержащий символы резервной стратегии, которые заменят символ, который не удалось закодировать, или последовательность байтов, которую не удалось декодировать.

При создании пользовательской резервной стратегии для кодировщика или декодера необходимо реализовать следующие члены:

- метод <xref:System.Text.EncoderFallbackBuffer.Fallback%2A?displayProperty=nameWithType> или <xref:System.Text.DecoderFallbackBuffer.Fallback%2A?displayProperty=nameWithType> . Метод<xref:System.Text.EncoderFallbackBuffer.Fallback%2A?displayProperty=nameWithType> вызывается кодировщиком, чтобы предоставить резервный буфер со сведениями о символе, который не удается кодировать. Так как символ, который требуется закодировать, может быть замещающей парой, этот метод перегружается. Одной перегрузке передается символ, который нужно закодировать, и его индекс в строке. Второй перегрузке передаются верхний и нижний замещающий знаки и их индекс в строке. Метод <xref:System.Text.DecoderFallbackBuffer.Fallback%2A?displayProperty=nameWithType> вызывается декодером, чтобы предоставить резервный буфер со сведениями о байтах, которые не удается декодировать. Этому методу передается массив байтов, которые не удалось декодировать, а также индекс первого байта. Метод резервной стратегии должен возвращать значение `true` , если резервный буфер может предоставить наилучшим образом соответствующий или замещающий символ (или символы); в противном случае он должен возвращать значение `false`. При использовании стратегии исключения метод резервной стратегии должен создавать исключение.

- Метод <xref:System.Text.EncoderFallbackBuffer.GetNextChar%2A?displayProperty=nameWithType> или <xref:System.Text.DecoderFallbackBuffer.GetNextChar%2A?displayProperty=nameWithType> , который вызывается кодировщиком или декодером многократно для получения следующего символа из резервного буфера. После возврата всех резервных символов метод должен вернуть символ U+0000.

- Свойство <xref:System.Text.EncoderFallbackBuffer.Remaining%2A?displayProperty=nameWithType> или <xref:System.Text.DecoderFallbackBuffer.Remaining%2A?displayProperty=nameWithType> , которое возвращает количество символов, оставшихся в резервном буфере.

- Метод <xref:System.Text.EncoderFallbackBuffer.MovePrevious%2A?displayProperty=nameWithType> или <xref:System.Text.DecoderFallbackBuffer.MovePrevious%2A?displayProperty=nameWithType> , который перемещает текущую позицию в резервном буфере к предыдущему символу.

- Метод <xref:System.Text.EncoderFallbackBuffer.Reset%2A?displayProperty=nameWithType> или <xref:System.Text.DecoderFallbackBuffer.Reset%2A?displayProperty=nameWithType> , повторно инициализирующий резервный буфер.

Если реализована резервная стратегия наилучшего соответствия или замены, классы, унаследованные от <xref:System.Text.EncoderFallbackBuffer> и <xref:System.Text.DecoderFallbackBuffer> , также имеют два закрытых поля экземпляра: точное число символов в буфере и индекс в буфере следующего символа, который нужно вернуть.

### <a name="an-encoderfallback-example"></a>Пример EncoderFallback

В примере выше использовалась стратегия замены для замены символов Юникода, не соответствующих символам ASCII, звездочкой (*). В примере ниже используется пользовательская резервная стратегия наилучшего соответствия для получения более удачного сопоставления символов, отсутствующих в ASCII.

В приведенном коде определяется класс с именем `CustomMapper` , производный от <xref:System.Text.EncoderFallback> , для обработки наилучшего сопоставления символов, отсутствующих в ASCII. Его метод `CreateFallbackBuffer` возвращает объект `CustomMapperFallbackBuffer` , предоставляющий реализацию <xref:System.Text.EncoderFallbackBuffer> . Класс `CustomMapper` использует объект <xref:System.Collections.Generic.Dictionary%602> для хранения сопоставлений неподдерживаемых символов Юникода (значение ключа) и соответствующих им 8-битных символов (которые хранятся в двух последовательных байтах в виде 64-разрядного целого числа). Чтобы это сопоставление было доступно резервному буферу, экземпляр `CustomMapper` передается в качестве параметра конструктору класса `CustomMapperFallbackBuffer` . Так как самое длинное сопоставление — это строка INF для символа Юникода с кодом U+221E, свойство `MaxCharCount` возвращает значение 3.

[!code-csharp[Conceptual.Encoding#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.encoding/cs/custom1.cs#5)]
[!code-vb[Conceptual.Encoding#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.encoding/vb/custom1.vb#5)]

В примере кода ниже определяется класс `CustomMapperFallbackBuffer` , производный от <xref:System.Text.EncoderFallbackBuffer>. Словарь, содержащий сопоставления наилучшего соответствия и определенный в экземпляре класса `CustomMapper` , доступен из конструктора класса. Его метод `Fallback` возвращает значение `true` , если какие-либо символы Юникода, которые не удается кодировать кодировщику ASCII, определены в словаре сопоставлений; в противном случае возвращается значение `false`. Для каждого резервного действия закрытая переменная `count` указывает число символов, которые осталось вернуть, а закрытая переменная `index` указывает позицию в буфере строк (значение `charsToReturn`) следующего символа, который нужно вернуть.

[!code-csharp[Conceptual.Encoding#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.encoding/cs/custom1.cs#6)]
[!code-vb[Conceptual.Encoding#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.encoding/vb/custom1.vb#6)]

В приведенном ниже коде создается экземпляр объекта `CustomMapper` , который передается в метод <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> . Выходные данные показывают, что реализация стратегии наилучшего соответствия успешно обрабатывает три символа исходной строки, отсутствующие в ASCII.

[!code-csharp[Conceptual.Encoding#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.encoding/cs/custom1.cs#7)]
[!code-vb[Conceptual.Encoding#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.encoding/vb/custom1.vb#7)]

## <a name="see-also"></a>См. также

- <xref:System.Text.Encoder>
- <xref:System.Text.Decoder>
- <xref:System.Text.DecoderFallback>
- <xref:System.Text.Encoding>
- <xref:System.Text.EncoderFallback>
- [Глобализация и локализация](../../../docs/standard/globalization-localization/index.md)
