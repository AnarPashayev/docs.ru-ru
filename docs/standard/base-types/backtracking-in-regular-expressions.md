---
title: Поиск с возвратом в регулярных выражениях .NET
description: Сведения об управлении поиском с возвратом в сопоставлении шаблонов регулярных выражений.
ms.date: 11/12/2018
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework regular expressions, backtracking
- alternative matching patterns
- optional matching patterns
- searching with regular expressions, backtracking
- pattern-matching with regular expressions, backtracking
- backtracking
- regular expressions [.NET Framework], backtracking
- strings [.NET Framework], regular expressions
- parsing text with regular expressions, backtracking
ms.assetid: 34df1152-0b22-4a1c-a76c-3c28c47b70d8
author: rpetrusha
ms.author: ronpet
ms.custom: seodec18
ms.openlocfilehash: 289b6997a4d17463072418fbf17f5f99874f4988
ms.sourcegitcommit: 46c68557bf6395f0ab9915f7558f2faae0097695
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/12/2019
ms.locfileid: "66378170"
---
# <a name="backtracking-in-regular-expressions"></a><span data-ttu-id="66f91-103">Поиск с возвратом в регулярных выражениях</span><span class="sxs-lookup"><span data-stu-id="66f91-103">Backtracking in Regular Expressions</span></span>
<a name="top"></a> <span data-ttu-id="66f91-104">Поиск с возвратом происходит, если шаблон регулярного выражения содержит переменные [квантификаторы](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md) или [конструкции изменения](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md), и обработчик регулярных выражений возвращается в предыдущее сохраненное состояние, чтобы продолжить поиск совпадения.</span><span class="sxs-lookup"><span data-stu-id="66f91-104">Backtracking occurs when a regular expression pattern contains optional [quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md) or [alternation constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md), and the regular expression engine returns to a previous saved state to continue its search for a match.</span></span> <span data-ttu-id="66f91-105">В поиске с возвратом заключена сила регулярных выражений. Благодаря ему выражения могут быть мощными и гибкими, а также совпадать со сложными шаблонами.</span><span class="sxs-lookup"><span data-stu-id="66f91-105">Backtracking is central to the power of regular expressions; it makes it possible for expressions to be powerful and flexible, and to match very complex patterns.</span></span> <span data-ttu-id="66f91-106">С другой стороны, эти возможности дорого обходятся.</span><span class="sxs-lookup"><span data-stu-id="66f91-106">At the same time, this power comes at a cost.</span></span> <span data-ttu-id="66f91-107">Часто именно поиск с возвратом существенно снижает производительность обработчика регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="66f91-107">Backtracking is often the single most important factor that affects the performance of the regular expression engine.</span></span> <span data-ttu-id="66f91-108">К счастью, разработчик может управлять работой обработчика регулярных выражений и тем, как он использует поиск с возвратом.</span><span class="sxs-lookup"><span data-stu-id="66f91-108">Fortunately, the developer has control over the behavior of the regular expression engine and how it uses backtracking.</span></span> <span data-ttu-id="66f91-109">В этом разделе описано, как функционирует поиск с возвратом, и как им можно управлять.</span><span class="sxs-lookup"><span data-stu-id="66f91-109">This topic explains how backtracking works and how it can be controlled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="66f91-110">В целом при использовании NFA-машины (недетерминированного конечного автомата), такой как обработчик регулярных выражений .NET, ответственность за создание эффективных и быстро выполняемых регулярных выражений лежит на разработчике.</span><span class="sxs-lookup"><span data-stu-id="66f91-110">In general, a Nondeterministic Finite Automaton (NFA) engine like .NET regular expression engine places the responsibility for crafting efficient, fast regular expressions on the developer.</span></span>  
  
 <span data-ttu-id="66f91-111">В этом разделе содержатся следующие подразделы.</span><span class="sxs-lookup"><span data-stu-id="66f91-111">This topic contains the following sections:</span></span>  
  
- [<span data-ttu-id="66f91-112">Линейное сравнение без поиска с возвратом</span><span class="sxs-lookup"><span data-stu-id="66f91-112">Linear Comparison Without Backtracking</span></span>](#linear_comparison_without_backtracking)  
  
- [<span data-ttu-id="66f91-113">Поиск с возвратом с переменными квантификаторами и конструкциями изменения</span><span class="sxs-lookup"><span data-stu-id="66f91-113">Backtracking with Optional Quantifiers or Alternation Constructs</span></span>](#backtracking_with_optional_quantifiers_or_alternation_constructs)  
  
- [<span data-ttu-id="66f91-114">Поиск с возвратом со вложенными переменными квантификаторами</span><span class="sxs-lookup"><span data-stu-id="66f91-114">Backtracking with Nested Optional Quantifiers</span></span>](#backtracking_with_nested_optional_quantifiers)  
  
- [<span data-ttu-id="66f91-115">Управление поиском с возвратом</span><span class="sxs-lookup"><span data-stu-id="66f91-115">Controlling Backtracking</span></span>](#controlling_backtracking)  
  
<a name="linear_comparison_without_backtracking"></a>   
## <a name="linear-comparison-without-backtracking"></a><span data-ttu-id="66f91-116">Линейное сравнение без поиска с возвратом</span><span class="sxs-lookup"><span data-stu-id="66f91-116">Linear Comparison Without Backtracking</span></span>  
 <span data-ttu-id="66f91-117">Если шаблон регулярного выражения не содержит переменных квантификаторов или конструкций изменения, обработчик регулярных выражений работает за линейное время.</span><span class="sxs-lookup"><span data-stu-id="66f91-117">If a regular expression pattern has no optional quantifiers or alternation constructs, the regular expression engine executes in linear time.</span></span> <span data-ttu-id="66f91-118">Это значит, что когда обработчик регулярных выражений находит совпадение с первым языковым элементом шаблона в тексте входной строки, он сопоставляет следующий языковой элемент шаблона со следующим символом или группой символов входной строки.</span><span class="sxs-lookup"><span data-stu-id="66f91-118">That is, after the regular expression engine matches the first language element in the pattern with text in the input string, it tries to match the next language element in the pattern with the next character or group of characters in the input string.</span></span> <span data-ttu-id="66f91-119">Так продолжается, пока поиск совпадения не заканчивается успешно или неуспешно.</span><span class="sxs-lookup"><span data-stu-id="66f91-119">This continues until the match either succeeds or fails.</span></span> <span data-ttu-id="66f91-120">В обоих случаях обработчик регулярных выражений продвигается вперед, обрабатывая по одному символу входной строки.</span><span class="sxs-lookup"><span data-stu-id="66f91-120">In either case, the regular expression engine advances by one character at a time in the input string.</span></span>  
  
 <span data-ttu-id="66f91-121">Ниже приведен пример.</span><span class="sxs-lookup"><span data-stu-id="66f91-121">The following example provides an illustration.</span></span> <span data-ttu-id="66f91-122">Регулярное выражение `e{2}\w\b` ищет следующую строку: два вхождения буквы «e», затем символ слова, затем граница слова.</span><span class="sxs-lookup"><span data-stu-id="66f91-122">The regular expression `e{2}\w\b` looks for two occurrences of the letter "e" followed by any word character followed by a word boundary.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking1.cs#1)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking1.vb#1)]  
  
 <span data-ttu-id="66f91-123">Несмотря на то что это регулярное выражение содержит квантификатор `{2}`, оно обрабатывается линейным образом.</span><span class="sxs-lookup"><span data-stu-id="66f91-123">Although this regular expression includes the quantifier `{2}`, it is evaluated in a linear manner.</span></span> <span data-ttu-id="66f91-124">Обработчик регулярных выражений не выполняет поиск с возвратом, поскольку квантификатор `{2}` не является переменным квантификатором; он указывает конкретное, а не переменное число вхождений предшествующей части выражения.</span><span class="sxs-lookup"><span data-stu-id="66f91-124">The regular expression engine does not backtrack because `{2}` is not an optional quantifier; it specifies an exact number and not a variable number of times that the previous subexpression must match.</span></span> <span data-ttu-id="66f91-125">В результате обработчик регулярных выражений ищет совпадение с шаблоном во входной строке, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="66f91-125">As a result, the regular expression engine tries to match the regular expression pattern with the input string as shown in the following table.</span></span>  
  
|<span data-ttu-id="66f91-126">Операция</span><span class="sxs-lookup"><span data-stu-id="66f91-126">Operation</span></span>|<span data-ttu-id="66f91-127">Положение в шаблоне</span><span class="sxs-lookup"><span data-stu-id="66f91-127">Position in pattern</span></span>|<span data-ttu-id="66f91-128">Положение в строке</span><span class="sxs-lookup"><span data-stu-id="66f91-128">Position in string</span></span>|<span data-ttu-id="66f91-129">Результат</span><span class="sxs-lookup"><span data-stu-id="66f91-129">Result</span></span>|  
|---------------|-------------------------|------------------------|------------|  
|<span data-ttu-id="66f91-130">1</span><span class="sxs-lookup"><span data-stu-id="66f91-130">1</span></span>|<span data-ttu-id="66f91-131">й</span><span class="sxs-lookup"><span data-stu-id="66f91-131">e</span></span>|<span data-ttu-id="66f91-132">"needing a reed" (позиция 0)</span><span class="sxs-lookup"><span data-stu-id="66f91-132">"needing a reed" (index 0)</span></span>|<span data-ttu-id="66f91-133">Нет совпадения.</span><span class="sxs-lookup"><span data-stu-id="66f91-133">No match.</span></span>|  
|<span data-ttu-id="66f91-134">2</span><span class="sxs-lookup"><span data-stu-id="66f91-134">2</span></span>|<span data-ttu-id="66f91-135">й</span><span class="sxs-lookup"><span data-stu-id="66f91-135">e</span></span>|<span data-ttu-id="66f91-136">"eeding a reed" (позиция 1)</span><span class="sxs-lookup"><span data-stu-id="66f91-136">"eeding a reed" (index 1)</span></span>|<span data-ttu-id="66f91-137">Возможное совпадение.</span><span class="sxs-lookup"><span data-stu-id="66f91-137">Possible match.</span></span>|  
|<span data-ttu-id="66f91-138">3</span><span class="sxs-lookup"><span data-stu-id="66f91-138">3</span></span>|<span data-ttu-id="66f91-139">e{2}</span><span class="sxs-lookup"><span data-stu-id="66f91-139">e{2}</span></span>|<span data-ttu-id="66f91-140">"eding a reed" (позиция 2)</span><span class="sxs-lookup"><span data-stu-id="66f91-140">"eding a reed" (index 2)</span></span>|<span data-ttu-id="66f91-141">Возможное совпадение.</span><span class="sxs-lookup"><span data-stu-id="66f91-141">Possible match.</span></span>|  
|<span data-ttu-id="66f91-142">4</span><span class="sxs-lookup"><span data-stu-id="66f91-142">4</span></span>|<span data-ttu-id="66f91-143">\\w</span><span class="sxs-lookup"><span data-stu-id="66f91-143">\w</span></span>|<span data-ttu-id="66f91-144">"ding a reed" (позиция 3)</span><span class="sxs-lookup"><span data-stu-id="66f91-144">"ding a reed" (index 3)</span></span>|<span data-ttu-id="66f91-145">Возможное совпадение.</span><span class="sxs-lookup"><span data-stu-id="66f91-145">Possible match.</span></span>|  
|<span data-ttu-id="66f91-146">5</span><span class="sxs-lookup"><span data-stu-id="66f91-146">5</span></span>|<span data-ttu-id="66f91-147">\b</span><span class="sxs-lookup"><span data-stu-id="66f91-147">\b</span></span>|<span data-ttu-id="66f91-148">"ing a reed" (позиция 4)</span><span class="sxs-lookup"><span data-stu-id="66f91-148">"ing a reed" (index 4)</span></span>|<span data-ttu-id="66f91-149">Совпадение не подтвердилось.</span><span class="sxs-lookup"><span data-stu-id="66f91-149">Possible match fails.</span></span>|  
|<span data-ttu-id="66f91-150">6</span><span class="sxs-lookup"><span data-stu-id="66f91-150">6</span></span>|<span data-ttu-id="66f91-151">й</span><span class="sxs-lookup"><span data-stu-id="66f91-151">e</span></span>|<span data-ttu-id="66f91-152">"eding a reed" (позиция 2)</span><span class="sxs-lookup"><span data-stu-id="66f91-152">"eding a reed" (index 2)</span></span>|<span data-ttu-id="66f91-153">Возможное совпадение.</span><span class="sxs-lookup"><span data-stu-id="66f91-153">Possible match.</span></span>|  
|<span data-ttu-id="66f91-154">7</span><span class="sxs-lookup"><span data-stu-id="66f91-154">7</span></span>|<span data-ttu-id="66f91-155">e{2}</span><span class="sxs-lookup"><span data-stu-id="66f91-155">e{2}</span></span>|<span data-ttu-id="66f91-156">"ding a reed" (позиция 3)</span><span class="sxs-lookup"><span data-stu-id="66f91-156">"ding a reed" (index 3)</span></span>|<span data-ttu-id="66f91-157">Совпадение не подтвердилось.</span><span class="sxs-lookup"><span data-stu-id="66f91-157">Possible match fails.</span></span>|  
|<span data-ttu-id="66f91-158">8</span><span class="sxs-lookup"><span data-stu-id="66f91-158">8</span></span>|<span data-ttu-id="66f91-159">й</span><span class="sxs-lookup"><span data-stu-id="66f91-159">e</span></span>|<span data-ttu-id="66f91-160">"ding a reed" (позиция 3)</span><span class="sxs-lookup"><span data-stu-id="66f91-160">"ding a reed" (index 3)</span></span>|<span data-ttu-id="66f91-161">Совпадение отсутствует.</span><span class="sxs-lookup"><span data-stu-id="66f91-161">Match fails.</span></span>|  
|<span data-ttu-id="66f91-162">9</span><span class="sxs-lookup"><span data-stu-id="66f91-162">9</span></span>|<span data-ttu-id="66f91-163">й</span><span class="sxs-lookup"><span data-stu-id="66f91-163">e</span></span>|<span data-ttu-id="66f91-164">"ing a reed" (позиция 4)</span><span class="sxs-lookup"><span data-stu-id="66f91-164">"ing a reed" (index 4)</span></span>|<span data-ttu-id="66f91-165">Нет совпадения.</span><span class="sxs-lookup"><span data-stu-id="66f91-165">No match.</span></span>|  
|<span data-ttu-id="66f91-166">10</span><span class="sxs-lookup"><span data-stu-id="66f91-166">10</span></span>|<span data-ttu-id="66f91-167">й</span><span class="sxs-lookup"><span data-stu-id="66f91-167">e</span></span>|<span data-ttu-id="66f91-168">"ng a reed" (позиция 5)</span><span class="sxs-lookup"><span data-stu-id="66f91-168">"ng a reed" (index 5)</span></span>|<span data-ttu-id="66f91-169">Нет совпадения.</span><span class="sxs-lookup"><span data-stu-id="66f91-169">No match.</span></span>|  
|<span data-ttu-id="66f91-170">11</span><span class="sxs-lookup"><span data-stu-id="66f91-170">11</span></span>|<span data-ttu-id="66f91-171">й</span><span class="sxs-lookup"><span data-stu-id="66f91-171">e</span></span>|<span data-ttu-id="66f91-172">"g a reed" (позиция 6)</span><span class="sxs-lookup"><span data-stu-id="66f91-172">"g a reed" (index 6)</span></span>|<span data-ttu-id="66f91-173">Нет совпадения.</span><span class="sxs-lookup"><span data-stu-id="66f91-173">No match.</span></span>|  
|<span data-ttu-id="66f91-174">12</span><span class="sxs-lookup"><span data-stu-id="66f91-174">12</span></span>|<span data-ttu-id="66f91-175">й</span><span class="sxs-lookup"><span data-stu-id="66f91-175">e</span></span>|<span data-ttu-id="66f91-176">" a reed" (позиция 7)</span><span class="sxs-lookup"><span data-stu-id="66f91-176">" a reed" (index 7)</span></span>|<span data-ttu-id="66f91-177">Нет совпадения.</span><span class="sxs-lookup"><span data-stu-id="66f91-177">No match.</span></span>|  
|<span data-ttu-id="66f91-178">13</span><span class="sxs-lookup"><span data-stu-id="66f91-178">13</span></span>|<span data-ttu-id="66f91-179">й</span><span class="sxs-lookup"><span data-stu-id="66f91-179">e</span></span>|<span data-ttu-id="66f91-180">a reed (позиция 8)</span><span class="sxs-lookup"><span data-stu-id="66f91-180">"a reed" (index 8)</span></span>|<span data-ttu-id="66f91-181">Нет совпадения.</span><span class="sxs-lookup"><span data-stu-id="66f91-181">No match.</span></span>|  
|<span data-ttu-id="66f91-182">14</span><span class="sxs-lookup"><span data-stu-id="66f91-182">14</span></span>|<span data-ttu-id="66f91-183">й</span><span class="sxs-lookup"><span data-stu-id="66f91-183">e</span></span>|<span data-ttu-id="66f91-184">" reed" (позиция 9)</span><span class="sxs-lookup"><span data-stu-id="66f91-184">" reed" (index 9)</span></span>|<span data-ttu-id="66f91-185">Нет совпадения.</span><span class="sxs-lookup"><span data-stu-id="66f91-185">No match.</span></span>|  
|<span data-ttu-id="66f91-186">15</span><span class="sxs-lookup"><span data-stu-id="66f91-186">15</span></span>|<span data-ttu-id="66f91-187">й</span><span class="sxs-lookup"><span data-stu-id="66f91-187">e</span></span>|<span data-ttu-id="66f91-188">reed (позиция 10)</span><span class="sxs-lookup"><span data-stu-id="66f91-188">"reed" (index 10)</span></span>|<span data-ttu-id="66f91-189">Нет совпадения.</span><span class="sxs-lookup"><span data-stu-id="66f91-189">No match</span></span>|  
|<span data-ttu-id="66f91-190">16</span><span class="sxs-lookup"><span data-stu-id="66f91-190">16</span></span>|<span data-ttu-id="66f91-191">й</span><span class="sxs-lookup"><span data-stu-id="66f91-191">e</span></span>|<span data-ttu-id="66f91-192">"eed" (позиция 11)</span><span class="sxs-lookup"><span data-stu-id="66f91-192">"eed" (index 11)</span></span>|<span data-ttu-id="66f91-193">Возможное совпадение.</span><span class="sxs-lookup"><span data-stu-id="66f91-193">Possible match.</span></span>|  
|<span data-ttu-id="66f91-194">17</span><span class="sxs-lookup"><span data-stu-id="66f91-194">17</span></span>|<span data-ttu-id="66f91-195">e{2}</span><span class="sxs-lookup"><span data-stu-id="66f91-195">e{2}</span></span>|<span data-ttu-id="66f91-196">"ed" (позиция 12)</span><span class="sxs-lookup"><span data-stu-id="66f91-196">"ed" (index 12)</span></span>|<span data-ttu-id="66f91-197">Возможное совпадение.</span><span class="sxs-lookup"><span data-stu-id="66f91-197">Possible match.</span></span>|  
|<span data-ttu-id="66f91-198">18</span><span class="sxs-lookup"><span data-stu-id="66f91-198">18</span></span>|<span data-ttu-id="66f91-199">\\w</span><span class="sxs-lookup"><span data-stu-id="66f91-199">\w</span></span>|<span data-ttu-id="66f91-200">"d" (позиция 13)</span><span class="sxs-lookup"><span data-stu-id="66f91-200">"d" (index 13)</span></span>|<span data-ttu-id="66f91-201">Возможное совпадение.</span><span class="sxs-lookup"><span data-stu-id="66f91-201">Possible match.</span></span>|  
|<span data-ttu-id="66f91-202">19</span><span class="sxs-lookup"><span data-stu-id="66f91-202">19</span></span>|<span data-ttu-id="66f91-203">\b</span><span class="sxs-lookup"><span data-stu-id="66f91-203">\b</span></span>|<span data-ttu-id="66f91-204">"" (позиция 14)</span><span class="sxs-lookup"><span data-stu-id="66f91-204">"" (index 14)</span></span>|<span data-ttu-id="66f91-205">Совпадение.</span><span class="sxs-lookup"><span data-stu-id="66f91-205">Match.</span></span>|  
  
 <span data-ttu-id="66f91-206">Если в шаблоне регулярного выражения нет переменных квантификаторов или конструкций изменения, максимальное число сравнений, необходимое для поиска во входной строке совпадения с шаблоном регулярного выражения, примерно равно числу символов во входной строке.</span><span class="sxs-lookup"><span data-stu-id="66f91-206">If a regular expression pattern includes no optional quantifiers or alternation constructs, the maximum number of comparisons required to match the regular expression pattern with the input string is roughly equivalent to the number of characters in the input string.</span></span> <span data-ttu-id="66f91-207">В этом случае обработчик регулярных выражений использует 19 сравнений, чтобы определить возможные совпадения в этой 13-значной строке.</span><span class="sxs-lookup"><span data-stu-id="66f91-207">In this case, the regular expression engine uses 19 comparisons to identify possible matches in this 13-character string.</span></span>  <span data-ttu-id="66f91-208">Другими словами, обработчик регулярных выражений работает почти за линейное время, если отсутствуют переменные квантификаторы или конструкции изменения.</span><span class="sxs-lookup"><span data-stu-id="66f91-208">In other words, the regular expression engine runs in near-linear time if it contains no optional quantifiers or alternation constructs.</span></span>  
  
 [<span data-ttu-id="66f91-209">К началу</span><span class="sxs-lookup"><span data-stu-id="66f91-209">Back to top</span></span>](#top)  
  
<a name="backtracking_with_optional_quantifiers_or_alternation_constructs"></a>   
## <a name="backtracking-with-optional-quantifiers-or-alternation-constructs"></a><span data-ttu-id="66f91-210">Поиск с возвратом с переменными квантификаторами и конструкциями изменения</span><span class="sxs-lookup"><span data-stu-id="66f91-210">Backtracking with Optional Quantifiers or Alternation Constructs</span></span>  
 <span data-ttu-id="66f91-211">Если регулярное выражение содержит переменные квантификаторы или конструкции изменения, оценка входной строки уже не может быть линейной.</span><span class="sxs-lookup"><span data-stu-id="66f91-211">When a regular expression includes optional quantifiers or alternation constructs, the evaluation of the input string is no longer linear.</span></span> <span data-ttu-id="66f91-212">При использовании NFA-машины сопоставление шаблонов определяется языковыми элементами регулярного выражения, а не символами входной строки.</span><span class="sxs-lookup"><span data-stu-id="66f91-212">Pattern matching with an NFA engine is driven by the language elements in the regular expression and not by the characters to be matched in the input string.</span></span> <span data-ttu-id="66f91-213">Поэтому обработчик регулярных выражений пытается найти полное совпадение для переменных подвыражений или подвыражений выбора.</span><span class="sxs-lookup"><span data-stu-id="66f91-213">Therefore, the regular expression engine tries to fully match optional or alternative subexpressions.</span></span> <span data-ttu-id="66f91-214">При переходе к следующему языковому элементу подвыражения и нарушении совпадения обработчик регулярных выражений отбрасывает совпавшую часть и возвращается к ранее сохраненному состоянию; ему снова требуется найти во входной строке совпадение с регулярным выражением целиком.</span><span class="sxs-lookup"><span data-stu-id="66f91-214">When it advances to the next language element in the subexpression and the match is unsuccessful, the regular expression engine can abandon a portion of its successful match and return to an earlier saved state in the interest of matching the regular expression as a whole with the input string.</span></span> <span data-ttu-id="66f91-215">Процесс возвращения к ранее сохраненному состоянию для поиска совпадения называется "поиск с возвратом".</span><span class="sxs-lookup"><span data-stu-id="66f91-215">This process of returning to a previous saved state to find a match is known as backtracking.</span></span>  
  
 <span data-ttu-id="66f91-216">Например, рассмотрим шаблон регулярного выражения `.*(es)`, совпадающий с символами "es" и любыми предшествующими символам.</span><span class="sxs-lookup"><span data-stu-id="66f91-216">For example, consider the regular expression pattern `.*(es)`, which matches the characters "es" and all the characters that precede it.</span></span> <span data-ttu-id="66f91-217">Как показано в следующем примере, если взять входную строку "Essential services are provided by regular expressions.", совпадать с шаблоном будет вся строка до букв "es" в слове "expressions" включительно.</span><span class="sxs-lookup"><span data-stu-id="66f91-217">As the following example shows, if the input string is "Essential services are provided by regular expressions.", the pattern matches the whole string up to and including the "es" in "expressions".</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking2.cs#2)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking2.vb#2)]  
  
 <span data-ttu-id="66f91-218">В этом случае обработчик регулярных выражений использует поиск с возвратом следующим образом.</span><span class="sxs-lookup"><span data-stu-id="66f91-218">To do this, the regular expression engine uses backtracking as follows:</span></span>  
  
- <span data-ttu-id="66f91-219">Обработчик обнаруживает совпадение части выражения `.*` (что соответствует любому числу любых символов) со всей входной строкой.</span><span class="sxs-lookup"><span data-stu-id="66f91-219">It matches the `.*` (which matches zero, one, or more occurrences of any character) with the whole input string.</span></span>  
  
- <span data-ttu-id="66f91-220">Затем обработчик ищет совпадение для символа "e" шаблона регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="66f91-220">It attempts to match "e" in the regular expression pattern.</span></span> <span data-ttu-id="66f91-221">Однако во входной строке нет больше символов для поиска совпадения.</span><span class="sxs-lookup"><span data-stu-id="66f91-221">However, the input string has no remaining characters available to match.</span></span>  
  
- <span data-ttu-id="66f91-222">Обработчик возвращается к месту последнего успешного совпадения, "Essential services are provided by regular expressions", и сравнивает символ "e" с точкой в конце предложения.</span><span class="sxs-lookup"><span data-stu-id="66f91-222">It backtracks to its last successful match, "Essential services are provided by regular expressions", and attempts to match "e" with the period at the end of the sentence.</span></span> <span data-ttu-id="66f91-223">Совпадение отсутствует.</span><span class="sxs-lookup"><span data-stu-id="66f91-223">The match fails.</span></span>  
  
- <span data-ttu-id="66f91-224">Обработчик продолжает возвращаться к предыдущим успешным совпадениям, отступая по одному символу, пока предположительно подходящей подстрокой не становится подстрока "Essential services are provided by regular expr".</span><span class="sxs-lookup"><span data-stu-id="66f91-224">It continues to backtrack to a previous successful match one character at a time until the tentatively matched substring is "Essential services are provided by regular expr".</span></span> <span data-ttu-id="66f91-225">Затем обработчик сравнивает символ "e" шаблона со второй буквой "e" в слове "expressions" и обнаруживает совпадение.</span><span class="sxs-lookup"><span data-stu-id="66f91-225">It then compares the "e" in the pattern to the second "e" in "expressions" and finds a match.</span></span>  
  
- <span data-ttu-id="66f91-226">Затем он сравнивает символ "s" шаблона с символом "s" после символа "e" в строке (первая буква "s" в слове "expressions").</span><span class="sxs-lookup"><span data-stu-id="66f91-226">It compares "s" in the pattern to the "s" that follows the matched "e" character (the first "s" in "expressions").</span></span> <span data-ttu-id="66f91-227">Совпадение успешно.</span><span class="sxs-lookup"><span data-stu-id="66f91-227">The match is successful.</span></span>  
  
 <span data-ttu-id="66f91-228">При использовании поиска с возвратом поиск совпадения шаблона регулярного выражения со входной строкой длиной 55 символов требует 67 операций сравнения.</span><span class="sxs-lookup"><span data-stu-id="66f91-228">When you use backtracking, matching the regular expression pattern with the input string, which is 55 characters long, requires 67 comparison operations.</span></span> <span data-ttu-id="66f91-229">Как правило, если в шаблоне регулярного выражения есть один переменный квантификатор или одна конструкция изменения, число сравнений, необходимых для поиска во входной строке совпадения с шаблоном регулярного выражения, более чем вдвое превышает число символов во входной строке.</span><span class="sxs-lookup"><span data-stu-id="66f91-229">Generally, if a regular expression pattern has a single alternation construct or a single optional quantifier, the number of comparison operations required to match the pattern is more than twice the number of characters in the input string.</span></span>  
  
 [<span data-ttu-id="66f91-230">К началу</span><span class="sxs-lookup"><span data-stu-id="66f91-230">Back to top</span></span>](#top)  
  
<a name="backtracking_with_nested_optional_quantifiers"></a>   
## <a name="backtracking-with-nested-optional-quantifiers"></a><span data-ttu-id="66f91-231">Поиск с возвратом со вложенными переменными квантификаторами</span><span class="sxs-lookup"><span data-stu-id="66f91-231">Backtracking with Nested Optional Quantifiers</span></span>  
 <span data-ttu-id="66f91-232">Количество сравнений, необходимое для поиска во входной строке совпадения с шаблоном регулярного выражения, может увеличиваться экспоненциально, если шаблон включает большое количество конструкций изменения или вложенные конструкции изменения, или, что случается чаще, вложенные переменные квантификаторы.</span><span class="sxs-lookup"><span data-stu-id="66f91-232">The number of comparison operations required to match a regular expression pattern can increase exponentially if the pattern includes a large number of alternation constructs, if it includes nested alternation constructs, or, most commonly, if it includes nested optional quantifiers.</span></span> <span data-ttu-id="66f91-233">Например, шаблон регулярного выражения `^(a+)+$` должен совпадать со строкой, состоящей из одного и более символов "a".</span><span class="sxs-lookup"><span data-stu-id="66f91-233">For example, the regular expression pattern `^(a+)+$` is designed to match a complete string that contains one or more "a" characters.</span></span> <span data-ttu-id="66f91-234">В примере показаны две входные строки одинаковой длины, только одна из которых совпадает с шаблоном.</span><span class="sxs-lookup"><span data-stu-id="66f91-234">The example provides two input strings of identical length, but only the first string matches the pattern.</span></span> <span data-ttu-id="66f91-235">Класс <xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> используется для определения времени выполнения операции поиска совпадения.</span><span class="sxs-lookup"><span data-stu-id="66f91-235">The <xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> class is used to determine how long the match operation takes.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking3.cs#3)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking3.vb#3)]  
  
 <span data-ttu-id="66f91-236">Как показывают выходные данные примера, у обработчика регулярных выражений установление отсутствия совпадения с шаблоном занимает в два раза больше времени, чем нахождение совпадения.</span><span class="sxs-lookup"><span data-stu-id="66f91-236">As the output from the example shows, the regular expression engine took about twice as long to find that an input string did not match the pattern as it did to identify a matching string.</span></span> <span data-ttu-id="66f91-237">Неуспешное совпадение — худший сценарий.</span><span class="sxs-lookup"><span data-stu-id="66f91-237">This is because an unsuccessful match always represents a worst-case scenario.</span></span> <span data-ttu-id="66f91-238">Обработчик регулярных выражений должен использовать регулярное выражение для проверки всех возможных путей в данных, чтобы заключить, что совпадения нет, а вложенные скобки сильно увеличивают количество таких путей.</span><span class="sxs-lookup"><span data-stu-id="66f91-238">The regular expression engine must use the regular expression to follow all possible paths through the data before it can conclude that the match is unsuccessful, and the nested parentheses create many additional paths through the data.</span></span> <span data-ttu-id="66f91-239">Чтобы установить, что вторая строка не совпадает с шаблоном, обработчику регулярных выражений нужно выполнить следующие действия:</span><span class="sxs-lookup"><span data-stu-id="66f91-239">The regular expression engine concludes that the second string did not match the pattern by doing the following:</span></span>  
  
- <span data-ttu-id="66f91-240">Он проверяет, что находится в начале строки, после чего проверяет первые пять символов строки на совпадение с шаблоном `a+`.</span><span class="sxs-lookup"><span data-stu-id="66f91-240">It checks that it was at the beginning of the string, and then matches the first five characters in the string with the pattern `a+`.</span></span> <span data-ttu-id="66f91-241">Затем проверяет, что в строке нет других групп символов "a".</span><span class="sxs-lookup"><span data-stu-id="66f91-241">It then determines that there are no additional groups of "a" characters in the string.</span></span> <span data-ttu-id="66f91-242">Затем выполняется проверка до конца строки.</span><span class="sxs-lookup"><span data-stu-id="66f91-242">Finally, it tests for the end of the string.</span></span> <span data-ttu-id="66f91-243">Поскольку в строке содержится один дополнительный символ, проверка оказывается неудачной.</span><span class="sxs-lookup"><span data-stu-id="66f91-243">Because one additional character remains in the string, the match fails.</span></span> <span data-ttu-id="66f91-244">Этот отрицательный результат требует 9 сравнений.</span><span class="sxs-lookup"><span data-stu-id="66f91-244">This failed match requires 9 comparisons.</span></span> <span data-ttu-id="66f91-245">Обработчик регулярных выражений также сохраняет информацию о состоянии при совпадениях "a" (совпадение 1), "aa" (совпадение 2), "aaa" (совпадение 3) и "aaaa" (совпадение 4).</span><span class="sxs-lookup"><span data-stu-id="66f91-245">The regular expression engine also saves state information from its matches of "a" (which we will call match 1), "aa" (match 2), "aaa" (match 3), and "aaaa" (match 4).</span></span>  
  
- <span data-ttu-id="66f91-246">Затем он возвращается к предварительно сохраненному совпадению 4.</span><span class="sxs-lookup"><span data-stu-id="66f91-246">It returns to the previously saved match 4.</span></span> <span data-ttu-id="66f91-247">Далее устанавливается наличие дополнительного символа "a", который назначается дополнительной захваченной группе.</span><span class="sxs-lookup"><span data-stu-id="66f91-247">It determines that there is one additional "a" character to assign to an additional captured group.</span></span> <span data-ttu-id="66f91-248">Затем выполняется проверка до конца строки.</span><span class="sxs-lookup"><span data-stu-id="66f91-248">Finally, it tests for the end of the string.</span></span> <span data-ttu-id="66f91-249">Поскольку в строке содержится один дополнительный символ, проверка оказывается неудачной.</span><span class="sxs-lookup"><span data-stu-id="66f91-249">Because one additional character remains in the string, the match fails.</span></span> <span data-ttu-id="66f91-250">Этот отрицательный результат требует 4 сравнений.</span><span class="sxs-lookup"><span data-stu-id="66f91-250">This failed match requires 4 comparisons.</span></span> <span data-ttu-id="66f91-251">Таким образом, всего выполнено 13 сравнений.</span><span class="sxs-lookup"><span data-stu-id="66f91-251">So far, a total of 13 comparisons have been performed.</span></span>  
  
- <span data-ttu-id="66f91-252">Затем он возвращается к предварительно сохраненному совпадению 3.</span><span class="sxs-lookup"><span data-stu-id="66f91-252">It returns to the previously saved match 3.</span></span> <span data-ttu-id="66f91-253">Он устанавливает наличие двух дополнительных символов "a", которые назначаются дополнительной захваченной группе.</span><span class="sxs-lookup"><span data-stu-id="66f91-253">It determines that there are two additional "a" characters to assign to an additional captured group.</span></span> <span data-ttu-id="66f91-254">Однако проверка на наличие окончания строки не проходит.</span><span class="sxs-lookup"><span data-stu-id="66f91-254">However, the end-of-string test fails.</span></span> <span data-ttu-id="66f91-255">Обработчик возвращается к совпадению 3 и пытается сопоставить два дополнительных символа "a" с двумя дополнительными захваченными группами.</span><span class="sxs-lookup"><span data-stu-id="66f91-255">It then returns to match3 and tries to match the two additional "a" characters in two additional captured groups.</span></span> <span data-ttu-id="66f91-256">Проверка на наличие окончания строки не проходит.</span><span class="sxs-lookup"><span data-stu-id="66f91-256">The end-of-string test still fails.</span></span> <span data-ttu-id="66f91-257">Для получения этих неуспешных совпадений потребовалось 12 сравнений.</span><span class="sxs-lookup"><span data-stu-id="66f91-257">These failed matches require 12 comparisons.</span></span> <span data-ttu-id="66f91-258">Таким образом, всего выполнено 25 сравнений.</span><span class="sxs-lookup"><span data-stu-id="66f91-258">So far, a total of 25 comparisons have been performed.</span></span>  
  
 <span data-ttu-id="66f91-259">Сравнение входной строки с регулярным выражением продолжается таким же образом, пока обработчик регулярных выражений не переберет все возможные комбинации совпадений, заключив, что совпадений нет.</span><span class="sxs-lookup"><span data-stu-id="66f91-259">Comparison of the input string with the regular expression continues in this way until the regular expression engine has tried all possible combinations of matches, and then concludes that there is no match.</span></span> <span data-ttu-id="66f91-260">Из-за наличия вложенных квантификаторов это сравнение представляет собой операцию экспоненциальной сложности O(2<sup>n</sup>), где *n* — количество символов входной строки.</span><span class="sxs-lookup"><span data-stu-id="66f91-260">Because of the nested quantifiers, this comparison is an O(2<sup>n</sup>) or an exponential operation, where *n* is the number of characters in the input string.</span></span> <span data-ttu-id="66f91-261">Это значит, что в худшем случае входная строка, состоящая из 30 символов, требует по примерным подсчетам 1 073 741 824 сравнений, а входная строка длиной 40 символов — 1 099 511 627 776 сравнений.</span><span class="sxs-lookup"><span data-stu-id="66f91-261">This means that in the worst case, an input string of 30 characters requires approximately 1,073,741,824 comparisons, and an input string of 40 characters requires approximately 1,099,511,627,776 comparisons.</span></span> <span data-ttu-id="66f91-262">При использовании строк такого или большего размера методы, выполняющие регулярные выражения, могут выполняться очень долго, прежде чем будет установлено, что входная строка не совпадает с шаблоном регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="66f91-262">If you use strings of these or even greater lengths, regular expression methods can take an extremely long time to complete when they process input that does not match the regular expression pattern.</span></span>  
  
 [<span data-ttu-id="66f91-263">К началу</span><span class="sxs-lookup"><span data-stu-id="66f91-263">Back to top</span></span>](#top)  
  
<a name="controlling_backtracking"></a>   
## <a name="controlling-backtracking"></a><span data-ttu-id="66f91-264">Управление поиском с возвратом</span><span class="sxs-lookup"><span data-stu-id="66f91-264">Controlling Backtracking</span></span>  
 <span data-ttu-id="66f91-265">Поиск с возвратом позволяет создавать мощные и гибкие регулярные выражения.</span><span class="sxs-lookup"><span data-stu-id="66f91-265">Backtracking lets you create powerful, flexible regular expressions.</span></span> <span data-ttu-id="66f91-266">Однако, как было показано в предыдущем разделе, эти преимущества могут сопровождаться неприемлемо низкой производительностью.</span><span class="sxs-lookup"><span data-stu-id="66f91-266">However, as the previous section showed, these benefits may be coupled with unacceptably poor performance.</span></span> <span data-ttu-id="66f91-267">Чтобы предотвратить излишнее использование поиска с возвратом, необходимо указать интервал времени ожидания при создании экземпляра объекта <xref:System.Text.RegularExpressions.Regex> или вызвать соответствующий метод статического регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="66f91-267">To prevent excessive backtracking, you should define a time-out interval when you instantiate a <xref:System.Text.RegularExpressions.Regex> object or call a static regular expression matching method.</span></span> <span data-ttu-id="66f91-268">Этот метод будет рассмотрен в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="66f91-268">This is discussed in the next section.</span></span> <span data-ttu-id="66f91-269">Кроме того, в .NET Core поддерживаются три элемента языка регулярных выражений, ограничивающих или подавляющих поиск с возвратом, что позволяет выполнять сложные регулярные выражения, не теряя или почти не теряя в производительности: [невозвращающиеся части выражения](#Nonbacktracking), [утверждения просмотра назад](#Lookbehind) и [утверждения просмотра вперед](#Lookahead).</span><span class="sxs-lookup"><span data-stu-id="66f91-269">In addition, .NET supports three regular expression language elements that limit or suppress backtracking and that support complex regular expressions with little or no performance penalty: [nonbacktracking subexpressions](#Nonbacktracking), [lookbehind assertions](#Lookbehind), and [lookahead assertions](#Lookahead).</span></span> <span data-ttu-id="66f91-270">Дополнительные сведения об этих элементах языка см. в разделе [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="66f91-270">For more information about each language element, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
<a name="Timeout"></a>   
### <a name="defining-a-time-out-interval"></a><span data-ttu-id="66f91-271">Определение интервала времени ожидания</span><span class="sxs-lookup"><span data-stu-id="66f91-271">Defining a Time-out Interval</span></span>  
 <span data-ttu-id="66f91-272">Начиная с .NET Framework 4.5 можно задавать значение времени ожидания, которое равняется значению самого длинного интервала, необходимого обработчику регулярных выражений для выполнения поиска до первого совпадения, пока он не приостановит попытки найти соответствие и не вызовет исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>.</span><span class="sxs-lookup"><span data-stu-id="66f91-272">Starting with the .NET Framework 4.5, you can set a time-out value that represents the longest interval the regular expression engine will search for a single match before it abandons the attempt and throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="66f91-273">Чтобы задать интервал ожидания, укажите значение <xref:System.TimeSpan> в конструкторе <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> регулярных выражений экземпляра.</span><span class="sxs-lookup"><span data-stu-id="66f91-273">You specify the time-out interval by supplying a <xref:System.TimeSpan> value to the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor for instance regular expressions.</span></span> <span data-ttu-id="66f91-274">Кроме того, каждый статический метод сравнения с шаблоном имеет перегруженную версию с параметром <xref:System.TimeSpan> , который позволяет указать значение времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="66f91-274">In addition, each static pattern matching method has an overload with a <xref:System.TimeSpan> parameter that allows you to specify a time-out value.</span></span> <span data-ttu-id="66f91-275">По умолчанию интервал времени ожидания задается в <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> и время ожидания обработчика регулярных выражений не истекает.</span><span class="sxs-lookup"><span data-stu-id="66f91-275">By default, the time-out interval is set to <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> and the regular expression engine does not time out.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="66f91-276">Рекомендуется всегда устанавливать интервал времени ожидания, если регулярное выражение использует поиск с возвратом.</span><span class="sxs-lookup"><span data-stu-id="66f91-276">We recommend that you always set a time-out interval if your regular expression relies on backtracking.</span></span>  
  
 <span data-ttu-id="66f91-277">Выражение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> указывает на то, что обработчику регулярных выражений не удалось найти совпадение в пределах заданного интервала времени ожидания, но не указывает причину создания исключения.</span><span class="sxs-lookup"><span data-stu-id="66f91-277">A <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception indicates that the regular expression engine was unable to find a match within the specified time-out interval but does not indicate why the exception was thrown.</span></span> <span data-ttu-id="66f91-278">Причина может быть как в излишнем поиске с возвратом, так и в недостаточном значении интервала времени ожидания для текущей загруженности системы на момент создания исключения.</span><span class="sxs-lookup"><span data-stu-id="66f91-278">The reason might be excessive backtracking, but it is also possible that the time-out interval was set too low given the system load at the time the exception was thrown.</span></span> <span data-ttu-id="66f91-279">При обработке исключения можно прервать дальнейший поиск совпадений входной строки или увеличить интервал времени ожидания и повторно выполнить операцию поиска.</span><span class="sxs-lookup"><span data-stu-id="66f91-279">When you handle the exception, you can choose to abandon further matches with the input string or increase the time-out interval and retry the matching operation.</span></span>  
  
 <span data-ttu-id="66f91-280">Например, следующий код вызывает конструктор <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> для создания экземпляра объекта <xref:System.Text.RegularExpressions.Regex> со значением времени ожидания, равным одной секунде.</span><span class="sxs-lookup"><span data-stu-id="66f91-280">For example, the following code calls the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor to instantiate a <xref:System.Text.RegularExpressions.Regex> object with a time-out value of one second.</span></span> <span data-ttu-id="66f91-281">Шаблон регулярного выражения `(a+)+$`, который сопоставляется с последовательностью из одного или нескольких символов "a" в конце строки, относится к шаблонам с чрезмерным использованием поиска с возвратом.</span><span class="sxs-lookup"><span data-stu-id="66f91-281">The regular expression pattern `(a+)+$`, which matches one or more sequences of one or more "a" characters at the end of a line, is subject to excessive backtracking.</span></span> <span data-ttu-id="66f91-282">Если создается исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> , то интервал времени ожидания в данном примере увеличивается до максимального значения, равного трем секундам.</span><span class="sxs-lookup"><span data-stu-id="66f91-282">If a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> is thrown, the example increases the time-out value up to a maximum interval of three seconds.</span></span> <span data-ttu-id="66f91-283">После этого попытки найти соответствие шаблону будут прерваны.</span><span class="sxs-lookup"><span data-stu-id="66f91-283">After that, it abandons the attempt to match the pattern.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
<a name="Nonbacktracking"></a>   
### <a name="nonbacktracking-subexpression"></a><span data-ttu-id="66f91-284">Невозвращающиеся подвыражения</span><span class="sxs-lookup"><span data-stu-id="66f91-284">Nonbacktracking Subexpression</span></span>  
 <span data-ttu-id="66f91-285">Элемент языка `(?>` *subexpression*`)` подавляет поиск с возвратом в подвыражении.</span><span class="sxs-lookup"><span data-stu-id="66f91-285">The `(?>` *subexpression*`)` language element suppresses backtracking in a subexpression.</span></span> <span data-ttu-id="66f91-286">Это полезно для предотвращения проблем с производительностью, связанных с неуспешным совпадением.</span><span class="sxs-lookup"><span data-stu-id="66f91-286">It is useful for preventing the performance problems associated with failed matches.</span></span>  
  
 <span data-ttu-id="66f91-287">В следующем примере показано, как подавление поиска с возвратом улучшает производительность при использовании вложенных квантификаторов.</span><span class="sxs-lookup"><span data-stu-id="66f91-287">The following example illustrates how suppressing backtracking improves performance when using nested quantifiers.</span></span> <span data-ttu-id="66f91-288">В нем измеряется время, которое требуется обработчику регулярных выражений, чтобы определить, что входная строка не совпадает с двумя регулярными выражениями.</span><span class="sxs-lookup"><span data-stu-id="66f91-288">It measures the time required for the regular expression engine to determine that an input string does not match two regular expressions.</span></span> <span data-ttu-id="66f91-289">В первом регулярном выражении поиск с возвратом используется для поиска строки, содержащей последовательно одну и более шестнадцатеричных цифр, двоеточие, одну и более шестнадцатеричных цифр и два двоеточия.</span><span class="sxs-lookup"><span data-stu-id="66f91-289">The first regular expression uses backtracking to attempt to match a string that contains one or more occurrences of one or more hexadecimal digits, followed by a colon, followed by one or more hexadecimal digits, followed by two colons.</span></span> <span data-ttu-id="66f91-290">Второе регулярное выражение аналогично первому, но в нем отключен поиск с возвратом.</span><span class="sxs-lookup"><span data-stu-id="66f91-290">The second regular expression is identical to the first, except that it disables backtracking.</span></span> <span data-ttu-id="66f91-291">Как показывают выходные данные примера, отключение поиска с возвратом приводит к существенному росту производительности.</span><span class="sxs-lookup"><span data-stu-id="66f91-291">As the output from the example shows, the performance improvement from disabling backtracking is significant.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking4.cs#4)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking4.vb#4)]  
  
<a name="Lookbehind"></a>   
### <a name="lookbehind-assertions"></a><span data-ttu-id="66f91-292">утверждения просмотра назад</span><span class="sxs-lookup"><span data-stu-id="66f91-292">Lookbehind Assertions</span></span>  
 <span data-ttu-id="66f91-293">В платформу .NET входят два элемента языка, `(?<=`*часть_выражения*`)` и `(?<!`*часть_выражения*`)`, которые сопоставляются с одним или несколькими предшествующими символами во входной строке.</span><span class="sxs-lookup"><span data-stu-id="66f91-293">.NET includes two language elements, `(?<=`*subexpression*`)` and `(?<!`*subexpression*`)`, that match the previous character or characters in the input string.</span></span> <span data-ttu-id="66f91-294">Оба элемента языка являются утверждениями нулевой ширины; они определяют, должны ли символы, непосредственно предшествующие текущему, соответствовать *subexpression*. Смещения или поиска с возвратом не происходит.</span><span class="sxs-lookup"><span data-stu-id="66f91-294">Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately precede the current character can be matched by *subexpression*, without advancing or backtracking.</span></span>  
  
 <span data-ttu-id="66f91-295">`(?<=` *subexpression* `)` — это утверждение положительного просмотра назад; символы, непосредственно предшествующие текущему, должны соответствовать *subexpression*.</span><span class="sxs-lookup"><span data-stu-id="66f91-295">`(?<=` *subexpression* `)` is a positive lookbehind assertion; that is, the character or characters before the current position must match *subexpression*.</span></span> <span data-ttu-id="66f91-296">`(?<!`*subexpression*`)` — это утверждение отрицательного просмотра назад; символы, непосредственно предшествующие текущему, не должны соответствовать *subexpression*.</span><span class="sxs-lookup"><span data-stu-id="66f91-296">`(?<!`*subexpression*`)` is a negative lookbehind assertion; that is, the character or characters before the current position must not match *subexpression*.</span></span> <span data-ttu-id="66f91-297">Утверждения положительного и отрицательного просмотра назад наиболее полезны, если *subexpression* является подмножеством предыдущего подвыражения.</span><span class="sxs-lookup"><span data-stu-id="66f91-297">Both positive and negative lookbehind assertions are most useful when *subexpression* is a subset of the previous subexpression.</span></span>  
  
 <span data-ttu-id="66f91-298">В следующем примере используются два равнозначных шаблона регулярных выражений, которые проверяют имя пользователя в адресе электронной почты.</span><span class="sxs-lookup"><span data-stu-id="66f91-298">The following example uses two equivalent regular expression patterns that validate the user name in an email address.</span></span> <span data-ttu-id="66f91-299">Первый шаблон демонстрирует низкую производительность из-за неоправданного использования поиска с возвратом.</span><span class="sxs-lookup"><span data-stu-id="66f91-299">The first pattern is subject to poor performance because of excessive backtracking.</span></span> <span data-ttu-id="66f91-300">Во втором шаблоне то же самое регулярное выражение изменено. Вложенный квантификатор заменен на утверждение положительного просмотра назад.</span><span class="sxs-lookup"><span data-stu-id="66f91-300">The second pattern modifies the first regular expression by replacing a nested quantifier with a positive lookbehind assertion.</span></span> <span data-ttu-id="66f91-301">Выходные данные примера демонстрируют время выполнения метода <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="66f91-301">The output from the example displays the execution time of the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking5.cs#5)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking5.vb#5)]  
  
 <span data-ttu-id="66f91-302">Первый шаблон регулярного выражения `^[0-9A-Z]([-.\w]*[0-9A-Z])*@`определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="66f91-302">The first regular expression pattern, `^[0-9A-Z]([-.\w]*[0-9A-Z])*@`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="66f91-303">Шаблон</span><span class="sxs-lookup"><span data-stu-id="66f91-303">Pattern</span></span>|<span data-ttu-id="66f91-304">ОПИСАНИЕ</span><span class="sxs-lookup"><span data-stu-id="66f91-304">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="66f91-305">Совпадение с началом строки.</span><span class="sxs-lookup"><span data-stu-id="66f91-305">Start the match at the beginning of the string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="66f91-306">Совпадение с алфавитно-цифровым символом.</span><span class="sxs-lookup"><span data-stu-id="66f91-306">Match an alphanumeric character.</span></span> <span data-ttu-id="66f91-307">Поскольку метод <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> вызывается с параметром <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> , сравнение не зависит от регистра символов.</span><span class="sxs-lookup"><span data-stu-id="66f91-307">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="66f91-308">Нуль и более совпадений с дефисом, точкой или символом слова.</span><span class="sxs-lookup"><span data-stu-id="66f91-308">Match zero, one, or more occurrences of a hyphen, period, or word character.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="66f91-309">Совпадение с алфавитно-цифровым символом.</span><span class="sxs-lookup"><span data-stu-id="66f91-309">Match an alphanumeric character.</span></span>|  
|`([-.\w]*[0-9A-Z])*`|<span data-ttu-id="66f91-310">Ноль и более совпадений с комбинацией нуля и более дефисов, точек и символов слова, за которыми следует алфавитно-цифровой символ.</span><span class="sxs-lookup"><span data-stu-id="66f91-310">Match zero or more occurrences of the combination of zero or more hyphens, periods, or word characters, followed by an alphanumeric character.</span></span> <span data-ttu-id="66f91-311">Это первая группа записи.</span><span class="sxs-lookup"><span data-stu-id="66f91-311">This is the first capturing group.</span></span>|  
|`@`|<span data-ttu-id="66f91-312">Совпадение со знаком "коммерческое эт" (\@).</span><span class="sxs-lookup"><span data-stu-id="66f91-312">Match an at sign ("\@").</span></span>|  
  
 <span data-ttu-id="66f91-313">Второй шаблон регулярного выражения `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@`использует утверждение положительного просмотра назад.</span><span class="sxs-lookup"><span data-stu-id="66f91-313">The second regular expression pattern, `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@`, uses a positive lookbehind assertion.</span></span> <span data-ttu-id="66f91-314">Определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="66f91-314">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="66f91-315">Шаблон</span><span class="sxs-lookup"><span data-stu-id="66f91-315">Pattern</span></span>|<span data-ttu-id="66f91-316">ОПИСАНИЕ</span><span class="sxs-lookup"><span data-stu-id="66f91-316">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="66f91-317">Совпадение с началом строки.</span><span class="sxs-lookup"><span data-stu-id="66f91-317">Start the match at the beginning of the string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="66f91-318">Совпадение с алфавитно-цифровым символом.</span><span class="sxs-lookup"><span data-stu-id="66f91-318">Match an alphanumeric character.</span></span> <span data-ttu-id="66f91-319">Поскольку метод <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> вызывается с параметром <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> , сравнение не зависит от регистра символов.</span><span class="sxs-lookup"><span data-stu-id="66f91-319">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="66f91-320">Нуль и более совпадений с дефисом, точкой или символом слова.</span><span class="sxs-lookup"><span data-stu-id="66f91-320">Match zero or more occurrences of a hyphen, period, or word character.</span></span>|  
|`(?<=[0-9A-Z])`|<span data-ttu-id="66f91-321">Выполняется просмотр назад последнего совпавшего символа; поиск совпадения продолжается, если этот символ является алфавитно-цифровым.</span><span class="sxs-lookup"><span data-stu-id="66f91-321">Look back at the last matched character and continue the match if it is alphanumeric.</span></span> <span data-ttu-id="66f91-322">Обратите внимание, что алфавитно-цифровой символ является подмножеством набора, образованного точкой, дефисом и всеми символами слова.</span><span class="sxs-lookup"><span data-stu-id="66f91-322">Note that alphanumeric characters are a subset of the set that consists of periods, hyphens, and all word characters.</span></span>|  
|`@`|<span data-ttu-id="66f91-323">Совпадение со знаком "коммерческое эт" (\@).</span><span class="sxs-lookup"><span data-stu-id="66f91-323">Match an at sign ("\@").</span></span>|  
  
<a name="Lookahead"></a>   
### <a name="lookahead-assertions"></a><span data-ttu-id="66f91-324">утверждения просмотра вперед</span><span class="sxs-lookup"><span data-stu-id="66f91-324">Lookahead Assertions</span></span>  
 <span data-ttu-id="66f91-325">В платформу .NET входят два элемента языка, `(?=`*часть_выражения*`)` и `(?!`*часть_выражения*`)`, которые сопоставляются с одним или несколькими следующими символами во входной строке.</span><span class="sxs-lookup"><span data-stu-id="66f91-325">.NET includes two language elements, `(?=`*subexpression*`)` and `(?!`*subexpression*`)`, that match the next character or characters in the input string.</span></span> <span data-ttu-id="66f91-326">Оба элемента языка являются утверждениями нулевой ширины; они определяют, должны ли символы, непосредственно следующие за текущим, соответствовать *subexpression*. Смещения или поиска с возвратом не происходит.</span><span class="sxs-lookup"><span data-stu-id="66f91-326">Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately follow the current character can be matched by *subexpression*, without advancing or backtracking.</span></span>  
  
 <span data-ttu-id="66f91-327">`(?=` *subexpression* `)` — это утверждение положительного просмотра вперед; символы, непосредственно следующие за текущим, должны соответствовать *subexpression*.</span><span class="sxs-lookup"><span data-stu-id="66f91-327">`(?=` *subexpression* `)` is a positive lookahead assertion; that is, the character or characters after the current position must match *subexpression*.</span></span> <span data-ttu-id="66f91-328">`(?!`*subexpression*`)` — это утверждение отрицательного просмотра вперед; символы, непосредственно следующие за текущим, не должны соответствовать *subexpression*.</span><span class="sxs-lookup"><span data-stu-id="66f91-328">`(?!`*subexpression*`)` is a negative lookahead assertion; that is, the character or characters after the current position must not match *subexpression*.</span></span> <span data-ttu-id="66f91-329">Утверждения положительного и отрицательного просмотра вперед наиболее полезны, если *subexpression* является подмножеством следующего подвыражения.</span><span class="sxs-lookup"><span data-stu-id="66f91-329">Both positive and negative lookahead assertions are most useful when *subexpression* is a subset of the next subexpression.</span></span>  
  
 <span data-ttu-id="66f91-330">В следующем примере используются два одинаковых шаблона регулярного выражения, проверяющих полное имя типа.</span><span class="sxs-lookup"><span data-stu-id="66f91-330">The following example uses two equivalent regular expression patterns that validate a fully qualified type name.</span></span> <span data-ttu-id="66f91-331">Первый шаблон демонстрирует низкую производительность из-за неоправданного использования поиска с возвратом.</span><span class="sxs-lookup"><span data-stu-id="66f91-331">The first pattern is subject to poor performance because of excessive backtracking.</span></span> <span data-ttu-id="66f91-332">Во втором шаблоне то же самое регулярное выражение изменено. Вложенный квантификатор заменен на утверждение положительного просмотра вперед.</span><span class="sxs-lookup"><span data-stu-id="66f91-332">The second modifies the first regular expression by replacing a nested quantifier with a positive lookahead assertion.</span></span> <span data-ttu-id="66f91-333">Выходные данные примера демонстрируют время выполнения метода <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="66f91-333">The output from the example displays the execution time of the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking6.cs#6)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking6.vb#6)]  
  
 <span data-ttu-id="66f91-334">Первый шаблон регулярного выражения `^(([A-Z]\w*)+\.)*[A-Z]\w*$`определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="66f91-334">The first regular expression pattern, `^(([A-Z]\w*)+\.)*[A-Z]\w*$`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="66f91-335">Шаблон</span><span class="sxs-lookup"><span data-stu-id="66f91-335">Pattern</span></span>|<span data-ttu-id="66f91-336">ОПИСАНИЕ</span><span class="sxs-lookup"><span data-stu-id="66f91-336">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="66f91-337">Совпадение с началом строки.</span><span class="sxs-lookup"><span data-stu-id="66f91-337">Start the match at the beginning of the string.</span></span>|  
|`([A-Z]\w*)+\.`|<span data-ttu-id="66f91-338">Совпадение с алфавитным символом (A-Z), за которым следует ноль и более символов слова, повторенных ноль и более раз, за которыми следует точка.</span><span class="sxs-lookup"><span data-stu-id="66f91-338">Match an alphabetical character (A-Z) followed by zero or more word characters one or more times, followed by a period.</span></span> <span data-ttu-id="66f91-339">Поскольку метод <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> вызывается с параметром <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> , сравнение не зависит от регистра символов.</span><span class="sxs-lookup"><span data-stu-id="66f91-339">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`(([A-Z]\w*)+\.)*`|<span data-ttu-id="66f91-340">Совпадение с предыдущим шаблоном ноль и более раз.</span><span class="sxs-lookup"><span data-stu-id="66f91-340">Match the previous pattern zero or more times.</span></span>|  
|`[A-Z]\w*`|<span data-ttu-id="66f91-341">Совпадение с алфавитно-цифровым символом, за которым следует ноль и более символов слова.</span><span class="sxs-lookup"><span data-stu-id="66f91-341">Match an alphabetical character followed by zero or more word characters.</span></span>|  
|`$`|<span data-ttu-id="66f91-342">Совпадение должно заканчиваться в конце входной строки.</span><span class="sxs-lookup"><span data-stu-id="66f91-342">End the match at the end of the input string.</span></span>|  
  
 <span data-ttu-id="66f91-343">Второй шаблон регулярного выражения `^((?=[A-Z])\w+\.)*[A-Z]\w*$`использует утверждение положительного просмотра вперед.</span><span class="sxs-lookup"><span data-stu-id="66f91-343">The second regular expression pattern, `^((?=[A-Z])\w+\.)*[A-Z]\w*$`, uses a positive lookahead assertion.</span></span> <span data-ttu-id="66f91-344">Определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="66f91-344">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="66f91-345">Шаблон</span><span class="sxs-lookup"><span data-stu-id="66f91-345">Pattern</span></span>|<span data-ttu-id="66f91-346">ОПИСАНИЕ</span><span class="sxs-lookup"><span data-stu-id="66f91-346">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="66f91-347">Совпадение с началом строки.</span><span class="sxs-lookup"><span data-stu-id="66f91-347">Start the match at the beginning of the string.</span></span>|  
|`(?=[A-Z])`|<span data-ttu-id="66f91-348">Выполняется просмотр вперед к следующему символу; если он является алфавитным (A-Z), продолжается поиск совпадения.</span><span class="sxs-lookup"><span data-stu-id="66f91-348">Look ahead to the first character and continue the match if it is alphabetical (A-Z).</span></span> <span data-ttu-id="66f91-349">Поскольку метод <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> вызывается с параметром <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> , сравнение не зависит от регистра символов.</span><span class="sxs-lookup"><span data-stu-id="66f91-349">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`\w+\.`|<span data-ttu-id="66f91-350">Совпадение с одним или несколькими символами слова, за которыми следует точка.</span><span class="sxs-lookup"><span data-stu-id="66f91-350">Match one or more word characters followed by a period.</span></span>|  
|`((?=[A-Z])\w+\.)*`|<span data-ttu-id="66f91-351">Совпадение с одним или несколькими символами слова, за которым следует ноль и более точек.</span><span class="sxs-lookup"><span data-stu-id="66f91-351">Match the pattern of one or more word characters followed by a period zero or more times.</span></span> <span data-ttu-id="66f91-352">Первый символ слова должен быть алфавитным.</span><span class="sxs-lookup"><span data-stu-id="66f91-352">The initial word character must be alphabetical.</span></span>|  
|`[A-Z]\w*`|<span data-ttu-id="66f91-353">Совпадение с алфавитно-цифровым символом, за которым следует ноль и более символов слова.</span><span class="sxs-lookup"><span data-stu-id="66f91-353">Match an alphabetical character followed by zero or more word characters.</span></span>|  
|`$`|<span data-ttu-id="66f91-354">Совпадение должно заканчиваться в конце входной строки.</span><span class="sxs-lookup"><span data-stu-id="66f91-354">End the match at the end of the input string.</span></span>|  
  
 [<span data-ttu-id="66f91-355">К началу</span><span class="sxs-lookup"><span data-stu-id="66f91-355">Back to top</span></span>](#top)  
  
## <a name="see-also"></a><span data-ttu-id="66f91-356">См. также</span><span class="sxs-lookup"><span data-stu-id="66f91-356">See also</span></span>

- [<span data-ttu-id="66f91-357">Регулярные выражения .NET</span><span class="sxs-lookup"><span data-stu-id="66f91-357">.NET Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)
- [<span data-ttu-id="66f91-358">Элементы языка регулярных выражений — краткий справочник</span><span class="sxs-lookup"><span data-stu-id="66f91-358">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)
- [<span data-ttu-id="66f91-359">Квантификаторы</span><span class="sxs-lookup"><span data-stu-id="66f91-359">Quantifiers</span></span>](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md)
- [<span data-ttu-id="66f91-360">Конструкции чередования</span><span class="sxs-lookup"><span data-stu-id="66f91-360">Alternation Constructs</span></span>](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md)
- [<span data-ttu-id="66f91-361">Grouping Constructs</span><span class="sxs-lookup"><span data-stu-id="66f91-361">Grouping Constructs</span></span>](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)
