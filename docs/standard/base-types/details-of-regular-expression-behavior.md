---
title: Поведение регулярных выражений
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET Framework regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
ms.openlocfilehash: 0273d16028315452e35f83086dbc134d6fcb66c6
ms.sourcegitcommit: 1c1a1f9ec0bd1efb3040d86a79f7ee94e207cca5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/03/2020
ms.locfileid: "80635992"
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="11deb-102">Подробные сведения о поведении регулярных выражений</span><span class="sxs-lookup"><span data-stu-id="11deb-102">Details of regular expression behavior</span></span>

<span data-ttu-id="11deb-103">Обработчик регулярных выражений .NET Framework выполняет поиск с возвратом для регулярных выражений и является реализацией традиционного механизма NFA (недетерминированного конечного автомата), аналогично тем, которые используются в Perl, Python, Emacs и Tcl.</span><span class="sxs-lookup"><span data-stu-id="11deb-103">The .NET Framework regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="11deb-104">Это отличает его от более быстрых, но и более ограниченных DFA-машин (детерминированный конечный автомат), предназначенных только для регулярных выражений и используемых в awk, egrep или lex.</span><span class="sxs-lookup"><span data-stu-id="11deb-104">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="11deb-105">Это также отличает его от типовых, но более медленных POSIX NFA-машин.</span><span class="sxs-lookup"><span data-stu-id="11deb-105">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="11deb-106">В следующем разделе представлено описание трех типов обработчиков регулярных выражений и объясняется причина реализации регулярных выражений на платформе .NET с помощью классического механизма NFA.</span><span class="sxs-lookup"><span data-stu-id="11deb-106">The following section describes the three types of regular expression engines, and explains why regular expressions in the .NET Framework are implemented by using a traditional NFA engine.</span></span>

## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="11deb-107">Преимущества NFA-машин</span><span class="sxs-lookup"><span data-stu-id="11deb-107">Benefits of the NFA engine</span></span>

 <span data-ttu-id="11deb-108">Когда DFA-машины выполняют сопоставление шаблонов, порядок обработки определяется входной строкой.</span><span class="sxs-lookup"><span data-stu-id="11deb-108">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="11deb-109">Машина начинает обработку с начала входной строки и продолжает последовательную обработку для определения соответствия следующего символа шаблону регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="11deb-109">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="11deb-110">Их можно обнаружить как соответствия максимальной длины.</span><span class="sxs-lookup"><span data-stu-id="11deb-110">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="11deb-111">Так как DFA-машины не проверяют один и тот же знак дважды, они не поддерживают поиск с возвратом.</span><span class="sxs-lookup"><span data-stu-id="11deb-111">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="11deb-112">Но поскольку DFA-машина поддерживает только ограниченный режим работы, она не способна выполнять поиск соответствий по шаблону с обратными ссылками. Кроме того, она не создает явные выражения и не способна выделять части выражения.</span><span class="sxs-lookup"><span data-stu-id="11deb-112">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>

 <span data-ttu-id="11deb-113">В отличие от DFA-машин обычные NFA-машины выполняют поиск соответствий по шаблонам, и порядок обработки определяется шаблоном регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="11deb-113">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="11deb-114">По мере обработки определенного элемента языка машина использует жадное сопоставление: она выполняет сопоставление как можно большей части входной строки.</span><span class="sxs-lookup"><span data-stu-id="11deb-114">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="11deb-115">И кроме того, она сохраняет свое состояние после успешного поиска соответствия части выражения.</span><span class="sxs-lookup"><span data-stu-id="11deb-115">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="11deb-116">Если поиск соответствия в конечном счете завершился с ошибкой, машина может вернуться в сохраненное состояние, поэтому она может попытаться найти дополнительные соответствия.</span><span class="sxs-lookup"><span data-stu-id="11deb-116">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="11deb-117">Такой процесс, при котором успешно найденное соответствие части выражения "откладывается" для поиска соответствий с последующими языковыми элементами в регулярном выражении, называется *поиском с возвратом*.</span><span class="sxs-lookup"><span data-stu-id="11deb-117">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking*.</span></span> <span data-ttu-id="11deb-118">NFA-машины используют поиск с возвратом, проверяя все возможные расширения регулярного выражения в определенном порядке и принимая первое соответствие.</span><span class="sxs-lookup"><span data-stu-id="11deb-118">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="11deb-119">Поскольку обычная NFA-машина создает определенное расширение регулярного выражения для успешного сопоставления, она способна находить соответствия для частей выражений и обратных ссылок.</span><span class="sxs-lookup"><span data-stu-id="11deb-119">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="11deb-120">Но так как обычная NFA-машина выполняет поиск с возвратом, она может анализировать одно и то же состояние несколько раз, если к нему ведут несколько разных путей.</span><span class="sxs-lookup"><span data-stu-id="11deb-120">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="11deb-121">В результате в наихудшем случае работа может замедляться по экспоненте.</span><span class="sxs-lookup"><span data-stu-id="11deb-121">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="11deb-122">Так как обычная NFA-машина принимает первое найденное соответствие, другие (возможно, более длинные) соответствия могут остаться необнаруженными.</span><span class="sxs-lookup"><span data-stu-id="11deb-122">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>

 <span data-ttu-id="11deb-123">POSIX NFA-машины похожи на обычные NFA-машины, за исключением того, что они продолжают поиск с возвратом до тех пор, пока не будет найдено наиболее длинное совпадение.</span><span class="sxs-lookup"><span data-stu-id="11deb-123">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="11deb-124">В результате POSIX NFA-машина работает медленнее обычной NFA-машины, и при использовании POSIX NFA-машины, изменив порядок поиска с возвратом, невозможно задать предпочтение короткому совпадению вместо более длинного.</span><span class="sxs-lookup"><span data-stu-id="11deb-124">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>

 <span data-ttu-id="11deb-125">Программисты предпочитают обычные NFA-машины, поскольку они превосходят по возможностям управления строковыми соответствиями обычные DFA-машины или POSIX NFA-машины.</span><span class="sxs-lookup"><span data-stu-id="11deb-125">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="11deb-126">Несмотря на то, что в наихудшем случае быстродействие NFA-машин снижается, ими можно управлять так, что поиск соответствий будет проходить по линейному или полиномиальному времени. Добиться этого можно с помощью шаблонов, уменьшающих неоднозначности и ограничивающих количество возвратов.</span><span class="sxs-lookup"><span data-stu-id="11deb-126">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="11deb-127">Другими словами, хотя NFA-машины отличаются характеризуются мощностью и гибкостью за счет производительности, в большинстве случаев они обеспечивают хорошую (или хотя бы приемлемую) производительность, если регулярное выражение грамотно составлено и позволяет избежать ситуаций, при которых производительность поиска с возвратом снижается экспоненциально.</span><span class="sxs-lookup"><span data-stu-id="11deb-127">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well written and avoids cases in which backtracking degrades performance exponentially.</span></span>

> [!NOTE]
> <span data-ttu-id="11deb-128">Сведения о том, как чрезмерное использование поиска с возвратом влияет на производительность и как избегать его в регулярных выражениях, см. в статье [Поиск с возвратом в регулярных выражениях](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="11deb-128">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>

## <a name="net-framework-engine-capabilities"></a><span data-ttu-id="11deb-129">Возможности модуля .NET Framework</span><span class="sxs-lookup"><span data-stu-id="11deb-129">.NET Framework engine capabilities</span></span>

 <span data-ttu-id="11deb-130">Чтобы использовать все сильные стороны классического механизма NFA, в обработчик регулярных выражений для платформы .NET включен полный набор конструкций, позволяющий программистам управлять процессом поиска с возвратом.</span><span class="sxs-lookup"><span data-stu-id="11deb-130">To take advantage of the benefits of a traditional NFA engine, the .NET Framework regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="11deb-131">Эти структуры можно использовать для ускорения поиска или для выбора предпочтительных расширений.</span><span class="sxs-lookup"><span data-stu-id="11deb-131">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>

 <span data-ttu-id="11deb-132">Ниже представлены другие возможности обработчика регулярных выражений .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="11deb-132">Other features of the .NET Framework regular expression engine include the following:</span></span>

- <span data-ttu-id="11deb-133">Ленивые квантификаторы: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span><span class="sxs-lookup"><span data-stu-id="11deb-133">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="11deb-134">В первую очередь они указывают обработчику на необходимость ведения поиска минимального числа повторений.</span><span class="sxs-lookup"><span data-stu-id="11deb-134">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="11deb-135">Обычные "жадные" квантификаторы, наоборот, пытаются сначала найти наибольшее число повторений.</span><span class="sxs-lookup"><span data-stu-id="11deb-135">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="11deb-136">В следующем примере кода демонстрируется различие между двумя квантификаторами.</span><span class="sxs-lookup"><span data-stu-id="11deb-136">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="11deb-137">Регулярное выражение соответствует предложению, оканчивающемуся на число, и захваченная группа должна извлечь это число.</span><span class="sxs-lookup"><span data-stu-id="11deb-137">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="11deb-138">Регулярное выражение `.+(\d+)\.` содержит жадный квантификатор `.+`, под влиянием которого обработчик регулярных выражений захватывает только последнюю цифру числа.</span><span class="sxs-lookup"><span data-stu-id="11deb-138">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="11deb-139">И наоборот, регулярное выражение `.+?(\d+)\.` содержит ленивый квантификатор `.+?`, под влиянием которого обработчик регулярных выражений захватывает все число.</span><span class="sxs-lookup"><span data-stu-id="11deb-139">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]

     <span data-ttu-id="11deb-140">Описания "жадной" и "ленивой" версий этого регулярного выражения представлены в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="11deb-140">The greedy and lazy versions of this regular expression are defined as shown in the following table:</span></span>

    |<span data-ttu-id="11deb-141">Шаблон</span><span class="sxs-lookup"><span data-stu-id="11deb-141">Pattern</span></span>|<span data-ttu-id="11deb-142">Описание</span><span class="sxs-lookup"><span data-stu-id="11deb-142">Description</span></span>|
    |-------------|-----------------|
    |<span data-ttu-id="11deb-143">`.+` ("жадный" квантификатор)</span><span class="sxs-lookup"><span data-stu-id="11deb-143">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="11deb-144">Соответствие как минимум одному вхождению любого символа.</span><span class="sxs-lookup"><span data-stu-id="11deb-144">Match at least one occurrence of any character.</span></span> <span data-ttu-id="11deb-145">Это дает обработчику регулярных выражений команду на сопоставление всей строки и выполнение поиска с возвратом, который требуется для сопоставления оставшейся части шаблона.</span><span class="sxs-lookup"><span data-stu-id="11deb-145">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|
    |<span data-ttu-id="11deb-146">`.+?` ("ленивый" квантификатор)</span><span class="sxs-lookup"><span data-stu-id="11deb-146">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="11deb-147">Соответствие как минимум одному вхождению любого символа, но как можно меньшему количеству.</span><span class="sxs-lookup"><span data-stu-id="11deb-147">Match at least one occurrence of any character, but match as few as possible.</span></span>|
    |`(\d+)`|<span data-ttu-id="11deb-148">Соответствие как минимум одной цифре и назначение ее для первой захваченной группы.</span><span class="sxs-lookup"><span data-stu-id="11deb-148">Match at least one numeric character, and assign it to the first capturing group.</span></span>|
    |`\.`|<span data-ttu-id="11deb-149">Сопоставляется точка.</span><span class="sxs-lookup"><span data-stu-id="11deb-149">Match a period.</span></span>|

     <span data-ttu-id="11deb-150">Дополнительные сведения о ленивых квантификаторах см. в статье о [квантификаторах в регулярных выражениях](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="11deb-150">For more information about lazy quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>

- <span data-ttu-id="11deb-151">Положительный поиск вперед: `(?=`*часть_выражения*`)`.</span><span class="sxs-lookup"><span data-stu-id="11deb-151">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="11deb-152">Эта функция позволяет обработчику с поиском с возвратом возвращаться в начальное место в тексте после сопоставления части выражения.</span><span class="sxs-lookup"><span data-stu-id="11deb-152">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="11deb-153">Эта функция полезна при осуществлении поиска с одной позиции с помощью нескольких шаблонов.</span><span class="sxs-lookup"><span data-stu-id="11deb-153">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="11deb-154">Она также позволяет обработчику проверять существование части строки в конце соответствия, не включая при этом часть строки в сопоставленный текст.</span><span class="sxs-lookup"><span data-stu-id="11deb-154">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="11deb-155">В следующем примере используется положительный поиск вперед для извлечения слов в предложении, после которых нет знаков препинания.</span><span class="sxs-lookup"><span data-stu-id="11deb-155">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]

     <span data-ttu-id="11deb-156">Определение регулярного выражения `\b[A-Z]+\b(?=\P{P})` показано в таблице ниже.</span><span class="sxs-lookup"><span data-stu-id="11deb-156">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="11deb-157">Шаблон</span><span class="sxs-lookup"><span data-stu-id="11deb-157">Pattern</span></span>|<span data-ttu-id="11deb-158">Описание</span><span class="sxs-lookup"><span data-stu-id="11deb-158">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="11deb-159">Совпадение должно начинаться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="11deb-159">Begin the match at a word boundary.</span></span>|
    |`[A-Z]+`|<span data-ttu-id="11deb-160">Совпадение с любым символом один или более раз.</span><span class="sxs-lookup"><span data-stu-id="11deb-160">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="11deb-161">Поскольку метод <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> вызывается с параметром <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>, при сравнении не учитывается регистр символов.</span><span class="sxs-lookup"><span data-stu-id="11deb-161">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|
    |`\b`|<span data-ttu-id="11deb-162">Совпадение должно заканчиваться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="11deb-162">End the match at a word boundary.</span></span>|
    |`(?=\P{P})`|<span data-ttu-id="11deb-163">Поиск для определения, является ли следующий символ знаком препинания.</span><span class="sxs-lookup"><span data-stu-id="11deb-163">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="11deb-164">Если не является, соответствие считается успешным.</span><span class="sxs-lookup"><span data-stu-id="11deb-164">If it is not, the match succeeds.</span></span>|

     <span data-ttu-id="11deb-165">Дополнительные сведения об утверждениях положительного поиска вперед см. в статье [Конструкции группировки в регулярных выражениях](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="11deb-165">For more information about positive lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="11deb-166">Отрицательный поиск вперед: `(?!`*часть_выражения*`)`.</span><span class="sxs-lookup"><span data-stu-id="11deb-166">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="11deb-167">Сопоставление выражения выполняется только в том случае, когда не было обнаружено соответствия части выражения.</span><span class="sxs-lookup"><span data-stu-id="11deb-167">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="11deb-168">Это существенно упрощает поиск, поскольку часто бывает проще описать выражения, не соответствующие правилу, чем само правило.</span><span class="sxs-lookup"><span data-stu-id="11deb-168">This is powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="11deb-169">Например, трудно написать выражение для поиска слов, которые не начинаются с "non".</span><span class="sxs-lookup"><span data-stu-id="11deb-169">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="11deb-170">В следующем примере для их исключения используется отрицательный поиск.</span><span class="sxs-lookup"><span data-stu-id="11deb-170">The following example uses negative lookahead to exclude them.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]

     <span data-ttu-id="11deb-171">Шаблон регулярного выражения `\b(?!non)\w+\b` определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="11deb-171">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="11deb-172">Шаблон</span><span class="sxs-lookup"><span data-stu-id="11deb-172">Pattern</span></span>|<span data-ttu-id="11deb-173">Описание</span><span class="sxs-lookup"><span data-stu-id="11deb-173">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="11deb-174">Совпадение должно начинаться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="11deb-174">Begin the match at a word boundary.</span></span>|
    |`(?!non)`|<span data-ttu-id="11deb-175">Поиск для определения, не начинается ли текущая строка с "non".</span><span class="sxs-lookup"><span data-stu-id="11deb-175">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="11deb-176">Если начинается, соответствие считается неудачным.</span><span class="sxs-lookup"><span data-stu-id="11deb-176">If it does, the match fails.</span></span>|
    |`(\w+)`|<span data-ttu-id="11deb-177">Совпадение с одним или несколькими символами слова.</span><span class="sxs-lookup"><span data-stu-id="11deb-177">Match one or more word characters.</span></span>|
    |`\b`|<span data-ttu-id="11deb-178">Совпадение должно заканчиваться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="11deb-178">End the match at a word boundary.</span></span>|

     <span data-ttu-id="11deb-179">Дополнительные сведения об утверждениях отрицательного поиска вперед см. в статье [Конструкции группировки в регулярных выражениях](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="11deb-179">For more information about negative lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="11deb-180">Условная оценка: `(?(`*выражение*`)`*да*`|`*нет*`)` and `(?(`*имя*`)`*да*`|`*нет*`)`, где *выражение* — сопоставляемая часть выражения, *имя* — имя группы захвата, *да* — сопоставляемая строка, если *выражение* найдено в тексте или *имя* является допустимой непустой захваченной группой, а *нет* — сопоставляемая строка, если *выражение* не найдено или *имя* не является допустимой непустой захваченной группой.</span><span class="sxs-lookup"><span data-stu-id="11deb-180">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="11deb-181">Эта функция позволяет обработчику вести поиск с использованием нескольких альтернативных шаблонов в зависимости от результатов сопоставлений предыдущей части выражения или утверждения нулевой ширины.</span><span class="sxs-lookup"><span data-stu-id="11deb-181">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="11deb-182">Это более действенный вид обратной ссылки, позволяющий, например, искать соответствия части выражения в зависимости от соответствия предыдущей части выражения.</span><span class="sxs-lookup"><span data-stu-id="11deb-182">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="11deb-183">Регулярное выражение в следующем примере соответствует абзацам, предназначенным для общего и внутреннего использования.</span><span class="sxs-lookup"><span data-stu-id="11deb-183">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="11deb-184">Абзацы, предназначенные только для внутреннего использования, начинаются с тега `<PRIVATE>`.</span><span class="sxs-lookup"><span data-stu-id="11deb-184">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="11deb-185">Шаблон регулярного выражения `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` использует условную оценку для назначения содержимого абзацев, предназначенных для общего и внутреннего использования, для отдельных захваченных групп.</span><span class="sxs-lookup"><span data-stu-id="11deb-185">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="11deb-186">Поэтому эти абзацы можно обработать по-разному.</span><span class="sxs-lookup"><span data-stu-id="11deb-186">These paragraphs can then be handled differently.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]

     <span data-ttu-id="11deb-187">Шаблон регулярного выражения определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="11deb-187">The regular expression pattern is defined as shown in the following table.</span></span>

    |<span data-ttu-id="11deb-188">Шаблон</span><span class="sxs-lookup"><span data-stu-id="11deb-188">Pattern</span></span>|<span data-ttu-id="11deb-189">Описание</span><span class="sxs-lookup"><span data-stu-id="11deb-189">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="11deb-190">Начало совпадения в начале строки.</span><span class="sxs-lookup"><span data-stu-id="11deb-190">Begin the match at the beginning of a line.</span></span>|
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="11deb-191">Соответствует вхождениям в количестве 0 или 1 строки `<PRIVATE>` за которым следует символ пробела.</span><span class="sxs-lookup"><span data-stu-id="11deb-191">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="11deb-192">Назначение соответствия для захваченной группы с именем `Pvt`.</span><span class="sxs-lookup"><span data-stu-id="11deb-192">Assign the match to a capturing group named `Pvt`.</span></span>|
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="11deb-193">Если захваченная группа `Pvt` существует, сопоставление одного или нескольких вхождений одного или нескольких вхождений символов слов, за которыми следует 0 или 1 пунктуационный разделитель с последующим любым пробелом.</span><span class="sxs-lookup"><span data-stu-id="11deb-193">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="11deb-194">Назначение части строки первой захваченной группе.</span><span class="sxs-lookup"><span data-stu-id="11deb-194">Assign the substring to the first capturing group.</span></span>|
    |<code>&#124;((\w+\p{P}?\s)+))</code>|<span data-ttu-id="11deb-195">Если захваченная группа `Pvt` не существует, сопоставление одного или нескольких вхождений одного или нескольких вхождений символов слов, за которыми следует 0 или 1 пунктуационный разделитель с последующим любым пробелом.</span><span class="sxs-lookup"><span data-stu-id="11deb-195">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="11deb-196">Назначение части строки третьей захваченной группе.</span><span class="sxs-lookup"><span data-stu-id="11deb-196">Assign the substring to the third capturing group.</span></span>|
    |`\r?$`|<span data-ttu-id="11deb-197">Соответствует концу строки.</span><span class="sxs-lookup"><span data-stu-id="11deb-197">Match the end of a line or the end of the string.</span></span>|

     <span data-ttu-id="11deb-198">Дополнительные сведения об условной оценке см. в статье [Конструкции изменения в регулярных выражениях](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="11deb-198">For more information about conditional evaluation, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="11deb-199">Сбалансированные определения группы: `(?<`*имя1*`-`*имя2*`>` *часть_выражения*`)`.</span><span class="sxs-lookup"><span data-stu-id="11deb-199">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="11deb-200">Эта функция позволяет обработчику регулярных выражений отслеживать вложенные конструкции, такие как скобки или открывающие и закрывающие круглые скобки.</span><span class="sxs-lookup"><span data-stu-id="11deb-200">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="11deb-201">Пример см. в статье [Конструкции группировки в регулярных выражениях](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="11deb-201">For an example, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="11deb-202">Атомарные группы: `(?>`*часть выражения*`)`.</span><span class="sxs-lookup"><span data-stu-id="11deb-202">Atomic groups: `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="11deb-203">Эта функция обеспечивает для подвыражения верность только первого соответствия, как будто выражение запускалось независимо от содержащего его выражения.</span><span class="sxs-lookup"><span data-stu-id="11deb-203">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="11deb-204">Без этой конструкции поиск в большом выражении с использованием поиска с возвратом может изменить поведение части выражения.</span><span class="sxs-lookup"><span data-stu-id="11deb-204">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="11deb-205">Например, регулярное выражение `(a+)\w` соответствует одному или нескольким символам "a", а также символу слова, которое следует за последовательностью символов "a", и присваивает последовательность символов "a" первой группе захвата.</span><span class="sxs-lookup"><span data-stu-id="11deb-205">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group.</span></span> <span data-ttu-id="11deb-206">Но если последний символ входной строки также является "a", он соответствует элементу языка `\w` и не включается в захваченную группу.</span><span class="sxs-lookup"><span data-stu-id="11deb-206">However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]

     <span data-ttu-id="11deb-207">Регулярное выражение `((?>a+))\w` препятствует такому поведению.</span><span class="sxs-lookup"><span data-stu-id="11deb-207">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="11deb-208">Поскольку все последовательные символы "a" имеют соответствия без поиска с возвратом, первая захваченная группа содержит все последовательные символы "a".</span><span class="sxs-lookup"><span data-stu-id="11deb-208">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="11deb-209">Если после символов "a" не следует ни один символ, отличный от "a", соответствие считается неудачным.</span><span class="sxs-lookup"><span data-stu-id="11deb-209">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]

     <span data-ttu-id="11deb-210">Дополнительные сведения об атомарных группах см. в статье [Конструкции группировки](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="11deb-210">For more information about atomic groups, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="11deb-211">Поиск совпадений справа налево, для применения которого нужно передать параметр <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> в конструктор класса <xref:System.Text.RegularExpressions.Regex> или в статический метод сопоставления экземпляров.</span><span class="sxs-lookup"><span data-stu-id="11deb-211">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="11deb-212">Эта функция полезна при поиске справа налево вместо обычного поиска слева направо, а также бывает более эффективно начинать поиск с правой части шаблона, а не с левой.</span><span class="sxs-lookup"><span data-stu-id="11deb-212">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="11deb-213">Как показано в примере ниже, использование поиска соответствий справа налево может изменить поведение жадных квантификаторов.</span><span class="sxs-lookup"><span data-stu-id="11deb-213">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="11deb-214">В примере выполняется два поисковых запроса предложения, оканчивающегося на число.</span><span class="sxs-lookup"><span data-stu-id="11deb-214">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="11deb-215">При поиске слева направо с использованием жадного квантификатора `+` имеется соответствие одной из шести цифр в предложении, тогда как при поиске справа налево — всем шести цифрам.</span><span class="sxs-lookup"><span data-stu-id="11deb-215">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="11deb-216">Описание шаблона регулярного выражения см. в примере с ленивыми квантификаторами ранее в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="11deb-216">For a description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]

     <span data-ttu-id="11deb-217">Дополнительные сведения о поиске соответствий справа налево см. в разделе [Параметры регулярных выражений](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="11deb-217">For more information about right-to-left matching, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>

- <span data-ttu-id="11deb-218">Положительный и отрицательный поиск назад: `(?<=`*часть_выражения*`)` для положительного поиска назад и `(?<!`*часть_выражения*`)` для отрицательного просмотра назад.</span><span class="sxs-lookup"><span data-stu-id="11deb-218">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="11deb-219">Эта функция аналогична поиску вперед, рассмотренному ранее в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="11deb-219">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="11deb-220">Поскольку обработчик регулярных выражений позволяет выполнять поиск справа налево, к регулярным выражениям можно применять поиск назад без каких-либо ограничений.</span><span class="sxs-lookup"><span data-stu-id="11deb-220">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="11deb-221">С помощью положительного и отрицательного поиска назад также можно избегать вложенных квантификаторов, когда вложенная часть выражения является супермножеством внешнего выражения.</span><span class="sxs-lookup"><span data-stu-id="11deb-221">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="11deb-222">Регулярные выражения с такими вложенными квантификаторами часто являются причиной низкой производительности.</span><span class="sxs-lookup"><span data-stu-id="11deb-222">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="11deb-223">В следующем примере выполняется проверка, начинается ли и оканчивается ли строка с буквы или цифры, а также является ли любой другой символ в строке символом большего подмножества.</span><span class="sxs-lookup"><span data-stu-id="11deb-223">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="11deb-224">В результате формируется часть регулярного выражения для проверки адресов электронной почты. Дополнительные сведения см. в статье [Руководство. Проверка строк на соответствие формату электронной почты](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="11deb-224">It forms a portion of the regular expression used to validate email addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]

     <span data-ttu-id="11deb-225">Определение регулярного выражения ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` показано в таблице ниже.</span><span class="sxs-lookup"><span data-stu-id="11deb-225">The regular expression ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="11deb-226">Шаблон</span><span class="sxs-lookup"><span data-stu-id="11deb-226">Pattern</span></span>|<span data-ttu-id="11deb-227">Описание</span><span class="sxs-lookup"><span data-stu-id="11deb-227">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="11deb-228">Начало совпадения в начале строки.</span><span class="sxs-lookup"><span data-stu-id="11deb-228">Begin the match at the beginning of the string.</span></span>|
    |`[A-Z0-9]`|<span data-ttu-id="11deb-229">Соответствие любому алфавитно-цифровому символу.</span><span class="sxs-lookup"><span data-stu-id="11deb-229">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="11deb-230">(При сравнении регистр не учитывается.)</span><span class="sxs-lookup"><span data-stu-id="11deb-230">(The comparison is case-insensitive.)</span></span>|
    |<code>([-!#$%&'.*+/=?^\`{}&#124;~\w])\*</code>|<span data-ttu-id="11deb-231">Соответствие нулю или нескольким вхождениям любого символа слова или любого символа из следующего набора: -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, &#96;, {, }, &#124; или ~.</span><span class="sxs-lookup"><span data-stu-id="11deb-231">Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, &#96;, {, }, &#124;, or ~.</span></span>|
    |`(?<=[A-Z0-9])`|<span data-ttu-id="11deb-232">Поиск назад предыдущего символа, который должен являться числом или буквенно-цифровым символом.</span><span class="sxs-lookup"><span data-stu-id="11deb-232">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="11deb-233">(При сравнении регистр не учитывается.)</span><span class="sxs-lookup"><span data-stu-id="11deb-233">(The comparison is case-insensitive.)</span></span>|
    |`$`|<span data-ttu-id="11deb-234">Совпадение должно заканчиваться в конце строки.</span><span class="sxs-lookup"><span data-stu-id="11deb-234">End the match at the end of the string.</span></span>|

     <span data-ttu-id="11deb-235">Дополнительные сведения о положительном и отрицательном поиске назад см. в статье [Конструкции группировки в регулярных выражениях](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="11deb-235">For more information about positive and negative lookbehind, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

## <a name="related-articles"></a><span data-ttu-id="11deb-236">Связанные статьи</span><span class="sxs-lookup"><span data-stu-id="11deb-236">Related articles</span></span>

|<span data-ttu-id="11deb-237">Заголовок</span><span class="sxs-lookup"><span data-stu-id="11deb-237">Title</span></span>|<span data-ttu-id="11deb-238">Описание</span><span class="sxs-lookup"><span data-stu-id="11deb-238">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="11deb-239">Поиск с возвратом</span><span class="sxs-lookup"><span data-stu-id="11deb-239">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="11deb-240">Сведения об использовании поиска с возвратом для поиска альтернативных соответствий.</span><span class="sxs-lookup"><span data-stu-id="11deb-240">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|
|[<span data-ttu-id="11deb-241">Компиляция и многократное использование</span><span class="sxs-lookup"><span data-stu-id="11deb-241">Compilation and Reuse</span></span>](../../../docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="11deb-242">Сведения о компиляции и многократном использовании регулярных выражений для повышения производительности.</span><span class="sxs-lookup"><span data-stu-id="11deb-242">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|
|[<span data-ttu-id="11deb-243">Потокобезопасность</span><span class="sxs-lookup"><span data-stu-id="11deb-243">Thread Safety</span></span>](../../../docs/standard/base-types/thread-safety-in-regular-expressions.md)|<span data-ttu-id="11deb-244">Сведения о потокобезопасности регулярных выражений и времени синхронизации доступа к объектам регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="11deb-244">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|
|[<span data-ttu-id="11deb-245">Регулярные выражения в .NET Framework</span><span class="sxs-lookup"><span data-stu-id="11deb-245">.NET Framework Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)|<span data-ttu-id="11deb-246">Общие сведения о регулярных выражениях в контексте языка программирования.</span><span class="sxs-lookup"><span data-stu-id="11deb-246">Provides an overview of the programming language aspect of regular expressions.</span></span>|
|[<span data-ttu-id="11deb-247">Объектная модель регулярных выражений</span><span class="sxs-lookup"><span data-stu-id="11deb-247">The Regular Expression Object Model</span></span>](../../../docs/standard/base-types/the-regular-expression-object-model.md)|<span data-ttu-id="11deb-248">Сведения об использовании классов регулярных выражений и примеры кода.</span><span class="sxs-lookup"><span data-stu-id="11deb-248">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|
|[<span data-ttu-id="11deb-249">Элементы языка регулярных выражений — краткий справочник</span><span class="sxs-lookup"><span data-stu-id="11deb-249">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="11deb-250">Сведения о наборе символов, операторов и конструкций, которые можно использовать для определения регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="11deb-250">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|

## <a name="reference"></a><span data-ttu-id="11deb-251">Справочник</span><span class="sxs-lookup"><span data-stu-id="11deb-251">Reference</span></span>

- <xref:System.Text.RegularExpressions?displayProperty=nameWithType>
