---
title: Подробные сведения о поведении регулярных выражений
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET Framework regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: bd0611cc8a6d257192b389b023c4dcda8f1b7ec3
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2019
ms.locfileid: "64634426"
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="b88d8-102">Подробные сведения о поведении регулярных выражений</span><span class="sxs-lookup"><span data-stu-id="b88d8-102">Details of Regular Expression Behavior</span></span>
<span data-ttu-id="b88d8-103">Обработчик регулярных выражений .NET Framework выполняет поиск с возвратом для регулярных выражений и является реализацией традиционного механизма NFA (недетерминированного конечного автомата), аналогично тем, которые используются в Perl, Python, Emacs и Tcl.</span><span class="sxs-lookup"><span data-stu-id="b88d8-103">The .NET Framework regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="b88d8-104">Это отличает его от более быстрых, но и более ограниченных DFA-машин (детерминированный конечный автомат), предназначенных только для регулярных выражений и используемых в awk, egrep или lex.</span><span class="sxs-lookup"><span data-stu-id="b88d8-104">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="b88d8-105">Это также отличает его от типовых, но более медленных POSIX NFA-машин.</span><span class="sxs-lookup"><span data-stu-id="b88d8-105">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="b88d8-106">В следующем разделе представлено описание трех типов обработчиков регулярных выражений и объясняется причина реализации регулярных выражений на платформе .NET с помощью классического механизма NFA.</span><span class="sxs-lookup"><span data-stu-id="b88d8-106">The following section describes the three types of regular expression engines, and explains why regular expressions in the .NET Framework are implemented by using a traditional NFA engine.</span></span>  
  
## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="b88d8-107">Преимущества NFA-машины</span><span class="sxs-lookup"><span data-stu-id="b88d8-107">Benefits of the NFA Engine</span></span>  
 <span data-ttu-id="b88d8-108">Когда DFA-машины выполняют сопоставление шаблонов, порядок обработки определяется входной строкой.</span><span class="sxs-lookup"><span data-stu-id="b88d8-108">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="b88d8-109">Машина начинает обработку с начала входной строки и продолжает последовательную обработку для определения соответствия следующего символа шаблону регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="b88d8-109">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="b88d8-110">Их можно обнаружить как соответствия максимальной длины.</span><span class="sxs-lookup"><span data-stu-id="b88d8-110">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="b88d8-111">Так как DFA-машины не проверяют один и тот же знак дважды, они не поддерживают поиск с возвратом.</span><span class="sxs-lookup"><span data-stu-id="b88d8-111">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="b88d8-112">Но поскольку DFA-машина поддерживает только ограниченный режим работы, она не способна выполнять поиск соответствий по шаблону с обратными ссылками. Кроме того, она не создает явные выражения и не способна выделять части выражения.</span><span class="sxs-lookup"><span data-stu-id="b88d8-112">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>  
  
 <span data-ttu-id="b88d8-113">В отличие от DFA-машин обычные NFA-машины выполняют поиск соответствий по шаблонам, и порядок обработки определяется шаблоном регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="b88d8-113">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="b88d8-114">По мере обработки определенного элемента языка машина использует жадное сопоставление: она выполняет сопоставление как можно большей части входной строки.</span><span class="sxs-lookup"><span data-stu-id="b88d8-114">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="b88d8-115">И кроме того, она сохраняет свое состояние после успешного поиска соответствия части выражения.</span><span class="sxs-lookup"><span data-stu-id="b88d8-115">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="b88d8-116">Если поиск соответствия в конечном счете завершился с ошибкой, машина может вернуться в сохраненное состояние, поэтому она может попытаться найти дополнительные соответствия.</span><span class="sxs-lookup"><span data-stu-id="b88d8-116">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="b88d8-117">Такой процесс, при котором успешно найденное соответствие части выражения "откладывается" для поиска соответствий с последующими языковыми элементами в регулярном выражении, называется *поиском с возвратом*.</span><span class="sxs-lookup"><span data-stu-id="b88d8-117">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking*.</span></span> <span data-ttu-id="b88d8-118">NFA-машины используют поиск с возвратом, проверяя все возможные расширения регулярного выражения в определенном порядке и принимая первое соответствие.</span><span class="sxs-lookup"><span data-stu-id="b88d8-118">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="b88d8-119">Поскольку обычная NFA-машина создает определенное расширение регулярного выражения для успешного сопоставления, она способна находить соответствия для частей выражений и обратных ссылок.</span><span class="sxs-lookup"><span data-stu-id="b88d8-119">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="b88d8-120">Но так как обычная NFA-машина выполняет поиск с возвратом, она может анализировать одно и то же состояние несколько раз, если к нему ведут несколько разных путей.</span><span class="sxs-lookup"><span data-stu-id="b88d8-120">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="b88d8-121">В результате в наихудшем случае работа может замедляться по экспоненте.</span><span class="sxs-lookup"><span data-stu-id="b88d8-121">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="b88d8-122">Так как обычная NFA-машина принимает первое найденное соответствие, другие (возможно, более длинные) соответствия могут остаться необнаруженными.</span><span class="sxs-lookup"><span data-stu-id="b88d8-122">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>  
  
 <span data-ttu-id="b88d8-123">POSIX NFA-машины похожи на обычные NFA-машины, за исключением того, что они продолжают поиск с возвратом до тех пор, пока не будет найдено наиболее длинное совпадение.</span><span class="sxs-lookup"><span data-stu-id="b88d8-123">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="b88d8-124">В результате POSIX NFA-машина работает медленнее обычной NFA-машины, и при использовании POSIX NFA-машины, изменив порядок поиска с возвратом, невозможно задать предпочтение короткому совпадению вместо более длинного.</span><span class="sxs-lookup"><span data-stu-id="b88d8-124">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>  
  
 <span data-ttu-id="b88d8-125">Программисты предпочитают обычные NFA-машины, поскольку они превосходят по возможностям управления строковыми соответствиями обычные DFA-машины или POSIX NFA-машины.</span><span class="sxs-lookup"><span data-stu-id="b88d8-125">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="b88d8-126">Несмотря на то, что в наихудшем случае быстродействие NFA-машин снижается, ими можно управлять так, что поиск соответствий будет проходить по линейному или полиномиальному времени. Добиться этого можно с помощью шаблонов, уменьшающих неоднозначности и ограничивающих количество возвратов.</span><span class="sxs-lookup"><span data-stu-id="b88d8-126">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="b88d8-127">Другими словами, несмотря на то, что NFA-машины жертвуют производительностью в обмен на мощность и гибкость, в большинстве случаев они обеспечивают хорошую (или хотя бы приемлемую) производительность, если регулярное выражение грамотно написано и позволяет избежать ситуаций, при которых производительность поиска с возвратом снижается экспоненциально.</span><span class="sxs-lookup"><span data-stu-id="b88d8-127">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well-written and avoids cases in which backtracking degrades performance exponentially.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b88d8-128">Сведения о том, как чрезмерное использование поиска с возвратом влияет на производительность и как избегать его в регулярных выражениях, см. в статье [Поиск с возвратом в регулярных выражениях](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="b88d8-128">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>  
  
## <a name="net-framework-engine-capabilities"></a><span data-ttu-id="b88d8-129">Возможности обработчика .NET Framework</span><span class="sxs-lookup"><span data-stu-id="b88d8-129">.NET Framework Engine Capabilities</span></span>  
 <span data-ttu-id="b88d8-130">Чтобы использовать все сильные стороны классического механизма NFA, в обработчик регулярных выражений для платформы .NET включен полный набор конструкций, позволяющий программистам управлять процессом поиска с возвратом.</span><span class="sxs-lookup"><span data-stu-id="b88d8-130">To take advantage of the benefits of a traditional NFA engine, the .NET Framework regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="b88d8-131">Эти структуры можно использовать для ускорения поиска или для выбора предпочтительных расширений.</span><span class="sxs-lookup"><span data-stu-id="b88d8-131">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>  
  
 <span data-ttu-id="b88d8-132">Ниже представлены другие возможности обработчика регулярных выражений .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="b88d8-132">Other features of the .NET Framework regular expression engine include the following:</span></span>  
  
- <span data-ttu-id="b88d8-133">Ленивые квантификаторы: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span><span class="sxs-lookup"><span data-stu-id="b88d8-133">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="b88d8-134">В первую очередь они указывают обработчику на необходимость ведения поиска минимального числа повторений.</span><span class="sxs-lookup"><span data-stu-id="b88d8-134">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="b88d8-135">Обычные "жадные" квантификаторы, наоборот, пытаются сначала найти наибольшее число повторений.</span><span class="sxs-lookup"><span data-stu-id="b88d8-135">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="b88d8-136">В следующем примере кода демонстрируется различие между двумя квантификаторами.</span><span class="sxs-lookup"><span data-stu-id="b88d8-136">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="b88d8-137">Регулярное выражение соответствует предложению, оканчивающемуся на число, и захваченная группа должна извлечь это число.</span><span class="sxs-lookup"><span data-stu-id="b88d8-137">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="b88d8-138">Регулярное выражение `.+(\d+)\.` содержит жадный квантификатор `.+`, под влиянием которого обработчик регулярных выражений захватывает только последнюю цифру числа.</span><span class="sxs-lookup"><span data-stu-id="b88d8-138">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="b88d8-139">И наоборот, регулярное выражение `.+?(\d+)\.` содержит ленивый квантификатор `.+?`, под влиянием которого обработчик регулярных выражений захватывает все число.</span><span class="sxs-lookup"><span data-stu-id="b88d8-139">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]  
  
     <span data-ttu-id="b88d8-140">Определения "жадной" и "ленивой" версий этого регулярного выражения представлены в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="b88d8-140">The greedy and lazy versions of this regular expression are defined as shown in the following table.\`</span></span>  
  
    |<span data-ttu-id="b88d8-141">Шаблон</span><span class="sxs-lookup"><span data-stu-id="b88d8-141">Pattern</span></span>|<span data-ttu-id="b88d8-142">Описание</span><span class="sxs-lookup"><span data-stu-id="b88d8-142">Description</span></span>|  
    |-------------|-----------------|  
    |<span data-ttu-id="b88d8-143">`.+` ("жадный" квантификатор)</span><span class="sxs-lookup"><span data-stu-id="b88d8-143">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="b88d8-144">Соответствие как минимум одному вхождению любого символа.</span><span class="sxs-lookup"><span data-stu-id="b88d8-144">Match at least one occurrence of any character.</span></span> <span data-ttu-id="b88d8-145">Это дает обработчику регулярных выражений команду на сопоставление всей строки и выполнение поиска с возвратом, который требуется для сопоставления оставшейся части шаблона.</span><span class="sxs-lookup"><span data-stu-id="b88d8-145">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|  
    |<span data-ttu-id="b88d8-146">`.+?` ("ленивый" квантификатор)</span><span class="sxs-lookup"><span data-stu-id="b88d8-146">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="b88d8-147">Соответствие как минимум одному вхождению любого символа, но как можно меньшему количеству.</span><span class="sxs-lookup"><span data-stu-id="b88d8-147">Match at least one occurrence of any character, but match as few as possible.</span></span>|  
    |`(\d+)`|<span data-ttu-id="b88d8-148">Соответствие как минимум одной цифре и назначение ее для первой захваченной группы.</span><span class="sxs-lookup"><span data-stu-id="b88d8-148">Match at least one numeric character, and assign it to the first capturing group.</span></span>|  
    |`\.`|<span data-ttu-id="b88d8-149">Сопоставляется точка.</span><span class="sxs-lookup"><span data-stu-id="b88d8-149">Match a period.</span></span>|  
  
     <span data-ttu-id="b88d8-150">Дополнительные сведения о ленивых квантификаторах см. в статье о [квантификаторах в регулярных выражениях](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="b88d8-150">For more information about lazy quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="b88d8-151">Положительный поиск вперед: `(?=`*часть_выражения*`)`.</span><span class="sxs-lookup"><span data-stu-id="b88d8-151">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="b88d8-152">Эта функция позволяет обработчику с поиском с возвратом возвращаться в начальное место в тексте после сопоставления части выражения.</span><span class="sxs-lookup"><span data-stu-id="b88d8-152">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="b88d8-153">Эта функция полезна при осуществлении поиска с одной позиции с помощью нескольких шаблонов.</span><span class="sxs-lookup"><span data-stu-id="b88d8-153">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="b88d8-154">Она также позволяет обработчику проверять существование части строки в конце соответствия, не включая при этом часть строки в сопоставленный текст.</span><span class="sxs-lookup"><span data-stu-id="b88d8-154">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="b88d8-155">В следующем примере используется положительный поиск вперед для извлечения слов в предложении, после которых нет знаков препинания.</span><span class="sxs-lookup"><span data-stu-id="b88d8-155">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]  
  
     <span data-ttu-id="b88d8-156">Определение регулярного выражения `\b[A-Z]+\b(?=\P{P})` показано в таблице ниже.</span><span class="sxs-lookup"><span data-stu-id="b88d8-156">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="b88d8-157">Шаблон</span><span class="sxs-lookup"><span data-stu-id="b88d8-157">Pattern</span></span>|<span data-ttu-id="b88d8-158">Описание</span><span class="sxs-lookup"><span data-stu-id="b88d8-158">Description</span></span>|  
    |-------------|-----------------|  
    |`\b`|<span data-ttu-id="b88d8-159">Совпадение должно начинаться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="b88d8-159">Begin the match at a word boundary.</span></span>|  
    |`[A-Z]+`|<span data-ttu-id="b88d8-160">Совпадение с любым символом один или более раз.</span><span class="sxs-lookup"><span data-stu-id="b88d8-160">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="b88d8-161">Поскольку метод <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> вызывается с параметром <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>, при сравнении не учитывается регистр символов.</span><span class="sxs-lookup"><span data-stu-id="b88d8-161">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|  
    |`\b`|<span data-ttu-id="b88d8-162">Совпадение должно заканчиваться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="b88d8-162">End the match at a word boundary.</span></span>|  
    |`(?=\P{P})`|<span data-ttu-id="b88d8-163">Поиск для определения, является ли следующий символ знаком препинания.</span><span class="sxs-lookup"><span data-stu-id="b88d8-163">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="b88d8-164">Если не является, соответствие считается успешным.</span><span class="sxs-lookup"><span data-stu-id="b88d8-164">If it is not, the match succeeds.</span></span>|  
  
     <span data-ttu-id="b88d8-165">Дополнительные сведения об утверждениях положительного поиска вперед см. в статье [Конструкции группировки в регулярных выражениях](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="b88d8-165">For more information about positive lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="b88d8-166">Отрицательный поиск вперед: `(?!`*часть_выражения*`)`.</span><span class="sxs-lookup"><span data-stu-id="b88d8-166">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="b88d8-167">Сопоставление выражения выполняется только в том случае, когда не было обнаружено соответствия части выражения.</span><span class="sxs-lookup"><span data-stu-id="b88d8-167">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="b88d8-168">Это существенно упрощает поиск, поскольку часто бывает проще описать выражения, не соответствующие правилу, чем само правило.</span><span class="sxs-lookup"><span data-stu-id="b88d8-168">This is particularly powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="b88d8-169">Например, трудно написать выражение для поиска слов, которые не начинаются с "non".</span><span class="sxs-lookup"><span data-stu-id="b88d8-169">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="b88d8-170">В следующем примере для их исключения используется отрицательный поиск.</span><span class="sxs-lookup"><span data-stu-id="b88d8-170">The following example uses negative lookahead to exclude them.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]  
  
     <span data-ttu-id="b88d8-171">Шаблон регулярного выражения `\b(?!non)\w+\b` определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="b88d8-171">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="b88d8-172">Шаблон</span><span class="sxs-lookup"><span data-stu-id="b88d8-172">Pattern</span></span>|<span data-ttu-id="b88d8-173">Описание</span><span class="sxs-lookup"><span data-stu-id="b88d8-173">Description</span></span>|  
    |-------------|-----------------|  
    |`\b`|<span data-ttu-id="b88d8-174">Совпадение должно начинаться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="b88d8-174">Begin the match at a word boundary.</span></span>|  
    |`(?!non)`|<span data-ttu-id="b88d8-175">Поиск для определения, не начинается ли текущая строка с "non".</span><span class="sxs-lookup"><span data-stu-id="b88d8-175">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="b88d8-176">Если начинается, соответствие считается неудачным.</span><span class="sxs-lookup"><span data-stu-id="b88d8-176">If it does, the match fails.</span></span>|  
    |`(\w+)`|<span data-ttu-id="b88d8-177">Совпадение с одним или несколькими символами слова.</span><span class="sxs-lookup"><span data-stu-id="b88d8-177">Match one or more word characters.</span></span>|  
    |`\b`|<span data-ttu-id="b88d8-178">Совпадение должно заканчиваться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="b88d8-178">End the match at a word boundary.</span></span>|  
  
     <span data-ttu-id="b88d8-179">Дополнительные сведения об утверждениях отрицательного поиска вперед см. в статье [Конструкции группировки в регулярных выражениях](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="b88d8-179">For more information about negative lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="b88d8-180">Условная оценка: `(?(`*выражение*`)`*да*`|`*нет*`)` and `(?(`*имя*`)`*да*`|`*нет*`)`, где *выражение* — сопоставляемая часть выражения, *имя* — имя группы захвата, *да* — сопоставляемая строка, если *выражение* найдено в тексте или *имя* является допустимой непустой захваченной группой, а *нет* — сопоставляемая строка, если *выражение* не найдено или *имя* не является допустимой непустой захваченной группой.</span><span class="sxs-lookup"><span data-stu-id="b88d8-180">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="b88d8-181">Эта функция позволяет обработчику вести поиск с использованием нескольких альтернативных шаблонов в зависимости от результатов сопоставлений предыдущей части выражения или утверждения нулевой ширины.</span><span class="sxs-lookup"><span data-stu-id="b88d8-181">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="b88d8-182">Это более действенный вид обратной ссылки, позволяющий, например, искать соответствия части выражения в зависимости от соответствия предыдущей части выражения.</span><span class="sxs-lookup"><span data-stu-id="b88d8-182">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="b88d8-183">Регулярное выражение в следующем примере соответствует абзацам, предназначенным для общего и внутреннего использования.</span><span class="sxs-lookup"><span data-stu-id="b88d8-183">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="b88d8-184">Абзацы, предназначенные только для внутреннего использования, начинаются с тега `<PRIVATE>`.</span><span class="sxs-lookup"><span data-stu-id="b88d8-184">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="b88d8-185">Шаблон регулярного выражения `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` использует условную оценку для назначения содержимого абзацев, предназначенных для общего и внутреннего использования, для отдельных захваченных групп.</span><span class="sxs-lookup"><span data-stu-id="b88d8-185">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="b88d8-186">Поэтому эти абзацы можно обработать по-разному.</span><span class="sxs-lookup"><span data-stu-id="b88d8-186">These paragraphs can then be handled differently.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]  
  
     <span data-ttu-id="b88d8-187">Шаблон регулярного выражения определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="b88d8-187">The regular expression pattern is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="b88d8-188">Шаблон</span><span class="sxs-lookup"><span data-stu-id="b88d8-188">Pattern</span></span>|<span data-ttu-id="b88d8-189">Описание</span><span class="sxs-lookup"><span data-stu-id="b88d8-189">Description</span></span>|  
    |-------------|-----------------|  
    |`^`|<span data-ttu-id="b88d8-190">Начало совпадения в начале строки.</span><span class="sxs-lookup"><span data-stu-id="b88d8-190">Begin the match at the beginning of a line.</span></span>|  
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="b88d8-191">Соответствует вхождениям в количестве 0 или 1 строки `<PRIVATE>` за которым следует символ пробела.</span><span class="sxs-lookup"><span data-stu-id="b88d8-191">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="b88d8-192">Назначение соответствия для захваченной группы с именем `Pvt`.</span><span class="sxs-lookup"><span data-stu-id="b88d8-192">Assign the match to a capturing group named `Pvt`.</span></span>|  
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="b88d8-193">Если захваченная группа `Pvt` существует, сопоставление одного или нескольких вхождений одного или нескольких вхождений символов слов, за которыми следует 0 или 1 пунктуационный разделитель с последующим любым пробелом.</span><span class="sxs-lookup"><span data-stu-id="b88d8-193">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="b88d8-194">Назначение части строки первой захваченной группе.</span><span class="sxs-lookup"><span data-stu-id="b88d8-194">Assign the substring to the first capturing group.</span></span>|  
    |<code>&#124;((\w+\p{P}?\s)+))<code>|<span data-ttu-id="b88d8-195">Если захваченная группа `Pvt` не существует, сопоставление одного или нескольких вхождений одного или нескольких вхождений символов слов, за которыми следует 0 или 1 пунктуационный разделитель с последующим любым пробелом.</span><span class="sxs-lookup"><span data-stu-id="b88d8-195">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="b88d8-196">Назначение части строки третьей захваченной группе.</span><span class="sxs-lookup"><span data-stu-id="b88d8-196">Assign the substring to the third capturing group.</span></span>|  
    |`\r?$`|<span data-ttu-id="b88d8-197">Соответствует концу строки.</span><span class="sxs-lookup"><span data-stu-id="b88d8-197">Match the end of a line or the end of the string.</span></span>|  
  
     <span data-ttu-id="b88d8-198">Дополнительные сведения об условной оценке см. в статье [Конструкции изменения в регулярных выражениях](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="b88d8-198">For more information about conditional evaluation, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="b88d8-199">Сбалансированные определения группы: `(?<`*имя1*`-`*имя2*`>` *часть_выражения*`)`.</span><span class="sxs-lookup"><span data-stu-id="b88d8-199">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="b88d8-200">Эта функция позволяет обработчику регулярных выражений отслеживать вложенные конструкции, такие как скобки или открывающие и закрывающие круглые скобки.</span><span class="sxs-lookup"><span data-stu-id="b88d8-200">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="b88d8-201">Пример см. в статье [Конструкции группировки в регулярных выражениях](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="b88d8-201">For an example, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="b88d8-202">Невозвращающиеся ("жадные") части выражения: `(?>`*часть_выражения*`)`.</span><span class="sxs-lookup"><span data-stu-id="b88d8-202">Nonbacktracking subexpressions (also known as greedy subexpressions): `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="b88d8-203">Эта функция обеспечивает для подвыражения верность только первого соответствия, как будто выражение запускалось независимо от содержащего его выражения.</span><span class="sxs-lookup"><span data-stu-id="b88d8-203">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="b88d8-204">Без этой конструкции поиск в большом выражении с использованием поиска с возвратом может изменить поведение части выражения.</span><span class="sxs-lookup"><span data-stu-id="b88d8-204">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="b88d8-205">Например, регулярное выражение `(a+)\w` соответствует одному или нескольким символам "a" наряду с буквой, после которой идет последовательность символов "a", и назначает последовательность символов "a" для первой захваченной группы. Однако если последний символ входной строки также является символом "a", он соответствует элементу языка `\w` и не входит в захваченную группу.</span><span class="sxs-lookup"><span data-stu-id="b88d8-205">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group, However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]  
  
     <span data-ttu-id="b88d8-206">Регулярное выражение `((?>a+))\w` препятствует такому поведению.</span><span class="sxs-lookup"><span data-stu-id="b88d8-206">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="b88d8-207">Поскольку все последовательные символы "a" имеют соответствия без поиска с возвратом, первая захваченная группа содержит все последовательные символы "a".</span><span class="sxs-lookup"><span data-stu-id="b88d8-207">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="b88d8-208">Если после символов "a" не следует ни один символ, отличный от "a", соответствие считается неудачным.</span><span class="sxs-lookup"><span data-stu-id="b88d8-208">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]  
  
     <span data-ttu-id="b88d8-209">Дополнительные сведения о невозвращающихся частях выражений см. в статье [Конструкции группировки в регулярных выражениях](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="b88d8-209">For more information about nonbacktracking subexpressions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="b88d8-210">Поиск совпадений справа налево, для применения которого нужно передать параметр <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> в конструктор класса <xref:System.Text.RegularExpressions.Regex> или в статический метод сопоставления экземпляров.</span><span class="sxs-lookup"><span data-stu-id="b88d8-210">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="b88d8-211">Эта функция полезна при поиске справа налево вместо обычного поиска слева направо, а также бывает более эффективно начинать поиск с правой части шаблона, а не с левой.</span><span class="sxs-lookup"><span data-stu-id="b88d8-211">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="b88d8-212">Как показано в примере ниже, использование поиска соответствий справа налево может изменить поведение жадных квантификаторов.</span><span class="sxs-lookup"><span data-stu-id="b88d8-212">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="b88d8-213">В примере выполняется два поисковых запроса предложения, оканчивающегося на число.</span><span class="sxs-lookup"><span data-stu-id="b88d8-213">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="b88d8-214">При поиске слева направо с использованием жадного квантификатора `+` имеется соответствие одной из шести цифр в предложении, тогда как при поиске справа налево — всем шести цифрам.</span><span class="sxs-lookup"><span data-stu-id="b88d8-214">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="b88d8-215">Описание шаблона регулярного выражения см. в примере с ленивыми квантификаторами ранее в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="b88d8-215">For an description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]  
  
     <span data-ttu-id="b88d8-216">Дополнительные сведения о поиске соответствий справа налево см. в разделе [Параметры регулярных выражений](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="b88d8-216">For more information about right-to-left matching, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>  
  
- <span data-ttu-id="b88d8-217">Положительный и отрицательный поиск назад: `(?<=`*часть_выражения*`)` для положительного поиска назад и `(?<!`*часть_выражения*`)` для отрицательного просмотра назад.</span><span class="sxs-lookup"><span data-stu-id="b88d8-217">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="b88d8-218">Эта функция аналогична поиску вперед, рассмотренному ранее в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="b88d8-218">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="b88d8-219">Поскольку обработчик регулярных выражений позволяет выполнять поиск справа налево, к регулярным выражениям можно применять поиск назад без каких-либо ограничений.</span><span class="sxs-lookup"><span data-stu-id="b88d8-219">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="b88d8-220">С помощью положительного и отрицательного поиска назад также можно избегать вложенных квантификаторов, когда вложенная часть выражения является супермножеством внешнего выражения.</span><span class="sxs-lookup"><span data-stu-id="b88d8-220">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="b88d8-221">Регулярные выражения с такими вложенными квантификаторами часто являются причиной низкой производительности.</span><span class="sxs-lookup"><span data-stu-id="b88d8-221">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="b88d8-222">В следующем примере выполняется проверка, начинается ли и оканчивается ли строка с буквы или цифры, а также является ли любой другой символ в строке символом большего подмножества.</span><span class="sxs-lookup"><span data-stu-id="b88d8-222">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="b88d8-223">В результате формируется часть регулярного выражения для проверки адресов электронной почты. Дополнительные сведения см. в статье [Руководство. Проверка строк на соответствие формату электронной почты](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="b88d8-223">It forms a portion of the regular expression used to validate email addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]  
  
     <span data-ttu-id="b88d8-224">В таблице ниже представлено определение регулярного выражения `^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])\*(?<=[A-Z0-9])$\`.</span><span class="sxs-lookup"><span data-stu-id="b88d8-224">The regular expression `^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])\*(?<=[A-Z0-9])$\` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="b88d8-225">Шаблон</span><span class="sxs-lookup"><span data-stu-id="b88d8-225">Pattern</span></span>|<span data-ttu-id="b88d8-226">Описание</span><span class="sxs-lookup"><span data-stu-id="b88d8-226">Description</span></span>|  
    |-------------|-----------------|  
    |`^`|<span data-ttu-id="b88d8-227">Начало совпадения в начале строки.</span><span class="sxs-lookup"><span data-stu-id="b88d8-227">Begin the match at the beginning of the string.</span></span>|  
    |`[A-Z0-9]`|<span data-ttu-id="b88d8-228">Соответствие любому алфавитно-цифровому символу.</span><span class="sxs-lookup"><span data-stu-id="b88d8-228">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="b88d8-229">(При сравнении регистр не учитывается.)</span><span class="sxs-lookup"><span data-stu-id="b88d8-229">(The comparison is case-insensitive.)</span></span>|  
    |<code>([-!#$%&'.*+/=?^\`{}&#124;~\w])*<code>|Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., *, +, /, =, ?, ^, \`, {, }, &#124;, or ~.|  
    |`(?<=[A-Z0-9])`|<span data-ttu-id="b88d8-230">Поиск назад предыдущего символа, который должен являться числом или буквенно-цифровым символом.</span><span class="sxs-lookup"><span data-stu-id="b88d8-230">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="b88d8-231">(При сравнении регистр не учитывается.)</span><span class="sxs-lookup"><span data-stu-id="b88d8-231">(The comparison is case-insensitive.)</span></span>|  
    |`$`|<span data-ttu-id="b88d8-232">Совпадение должно заканчиваться в конце строки.</span><span class="sxs-lookup"><span data-stu-id="b88d8-232">End the match at the end of the string.</span></span>|  
  
     <span data-ttu-id="b88d8-233">Дополнительные сведения о положительном и отрицательном поиске назад см. в статье [Конструкции группировки в регулярных выражениях](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="b88d8-233">For more information about positive and negative lookbehind, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="b88d8-234">См. также</span><span class="sxs-lookup"><span data-stu-id="b88d8-234">Related Topics</span></span>  
  
|<span data-ttu-id="b88d8-235">Заголовок</span><span class="sxs-lookup"><span data-stu-id="b88d8-235">Title</span></span>|<span data-ttu-id="b88d8-236">Описание</span><span class="sxs-lookup"><span data-stu-id="b88d8-236">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="b88d8-237">Поиск с возвратом</span><span class="sxs-lookup"><span data-stu-id="b88d8-237">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="b88d8-238">Сведения об использовании поиска с возвратом для поиска альтернативных соответствий.</span><span class="sxs-lookup"><span data-stu-id="b88d8-238">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|  
|[<span data-ttu-id="b88d8-239">Компиляция и многократное использование</span><span class="sxs-lookup"><span data-stu-id="b88d8-239">Compilation and Reuse</span></span>](../../../docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="b88d8-240">Сведения о компиляции и многократном использовании регулярных выражений для повышения производительности.</span><span class="sxs-lookup"><span data-stu-id="b88d8-240">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|  
|[<span data-ttu-id="b88d8-241">Потокобезопасность</span><span class="sxs-lookup"><span data-stu-id="b88d8-241">Thread Safety</span></span>](../../../docs/standard/base-types/thread-safety-in-regular-expressions.md)|<span data-ttu-id="b88d8-242">Сведения о потокобезопасности регулярных выражений и времени синхронизации доступа к объектам регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="b88d8-242">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|  
|[<span data-ttu-id="b88d8-243">Регулярные выражения в .NET Framework</span><span class="sxs-lookup"><span data-stu-id="b88d8-243">.NET Framework Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)|<span data-ttu-id="b88d8-244">Общие сведения о регулярных выражениях в контексте языка программирования.</span><span class="sxs-lookup"><span data-stu-id="b88d8-244">Provides an overview of the programming language aspect of regular expressions.</span></span>|  
|[<span data-ttu-id="b88d8-245">Объектная модель регулярных выражений</span><span class="sxs-lookup"><span data-stu-id="b88d8-245">The Regular Expression Object Model</span></span>](../../../docs/standard/base-types/the-regular-expression-object-model.md)|<span data-ttu-id="b88d8-246">Сведения об использовании классов регулярных выражений и примеры кода.</span><span class="sxs-lookup"><span data-stu-id="b88d8-246">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|  
|[<span data-ttu-id="b88d8-247">Примеры регулярных выражений</span><span class="sxs-lookup"><span data-stu-id="b88d8-247">Regular Expression Examples</span></span>](../../../docs/standard/base-types/regular-expression-examples.md)|<span data-ttu-id="b88d8-248">Примеры кодов, иллюстрирующих использование регулярных выражений в обычных приложениях.</span><span class="sxs-lookup"><span data-stu-id="b88d8-248">Contains code examples that illustrate the use of regular expressions in common applications.</span></span>|  
|[<span data-ttu-id="b88d8-249">Элементы языка регулярных выражений — краткий справочник</span><span class="sxs-lookup"><span data-stu-id="b88d8-249">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="b88d8-250">Сведения о наборе символов, операторов и конструкций, которые можно использовать для определения регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="b88d8-250">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="b88d8-251">Ссылка</span><span class="sxs-lookup"><span data-stu-id="b88d8-251">Reference</span></span>  
 <xref:System.Text.RegularExpressions?displayProperty=nameWithType>
