---
title: Подробный обзор асинхронного программирования
description: Сведения о простом написании асинхронного кода, связанного с операциями ввода-вывода и задействованием ЦП, с помощью асинхронной модели .NET на базе класса Task.
author: cartermp
ms.author: wiwagn
ms.date: 06/20/2016
ms.technology: dotnet-standard
ms.assetid: 1e38f9d9-8f84-46ee-a15f-199aec4f2e34
ms.openlocfilehash: 91fd37ce329c03b43b5472e4579be7f5ef961738
ms.sourcegitcommit: 1b020356e421a9314dd525539da12463d980ce7a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/30/2019
ms.locfileid: "70169105"
---
# <a name="async-in-depth"></a><span data-ttu-id="dc63a-103">Подробный обзор асинхронного программирования</span><span class="sxs-lookup"><span data-stu-id="dc63a-103">Async in depth</span></span>

<span data-ttu-id="dc63a-104">Писать асинхронный код, связанный с операциями ввода-вывода и задействованием ЦП, очень просто с помощью асинхронной модели .NET на базе класса Task.</span><span class="sxs-lookup"><span data-stu-id="dc63a-104">Writing I/O- and CPU-bound asynchronous code is straightforward using the .NET Task-based async model.</span></span> <span data-ttu-id="dc63a-105">Эта модель основывается на типах `Task` и `Task<T>` и ключевых словах `async` и `await` в C# и Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="dc63a-105">The model is exposed by the `Task` and `Task<T>` types and the `async` and `await` keywords in C# and Visual Basic.</span></span> <span data-ttu-id="dc63a-106">(Ресурсы, связанные с определенным языком, см. в разделе [См. также](#see-also).) В этой статье описывается использование асинхронного кода в .NET и объясняется базовая асинхронная платформа.</span><span class="sxs-lookup"><span data-stu-id="dc63a-106">(Language-specific resources are found in the [See also](#see-also) section.) This article explains how to use .NET async and provides insight into the async framework used under the covers.</span></span>

## <a name="task-and-taskt"></a><span data-ttu-id="dc63a-107">Task и Task\<T></span><span class="sxs-lookup"><span data-stu-id="dc63a-107">Task and Task\<T></span></span>

<span data-ttu-id="dc63a-108">Task (задача) — это конструкции, реализующие [модель параллельной обработки на основе обещаний (Promise)](https://en.wikipedia.org/wiki/Futures_and_promises).</span><span class="sxs-lookup"><span data-stu-id="dc63a-108">Tasks are constructs used to implement what is known as the [Promise Model of Concurrency](https://en.wikipedia.org/wiki/Futures_and_promises).</span></span>  <span data-ttu-id="dc63a-109">Если в двух словах, она "обещает", что работа будет выполнена позже, позволяя взаимодействовать с помощью обещания с чистым API.</span><span class="sxs-lookup"><span data-stu-id="dc63a-109">In short, they offer you a "promise" that work will be completed at a later point, letting you coordinate with the promise with a clean API.</span></span>

- <span data-ttu-id="dc63a-110">`Task` представляет одну операцию, которая не возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="dc63a-110">`Task` represents a single operation which does not return a value.</span></span>
- <span data-ttu-id="dc63a-111">`Task<T>` представляет одну операцию, которая возвращает значение типа `T`.</span><span class="sxs-lookup"><span data-stu-id="dc63a-111">`Task<T>` represents a single operation which returns a value of type `T`.</span></span>

<span data-ttu-id="dc63a-112">Важно рассматривать задачи как абстракции асинхронных операций, но *не* как абстракции поверх потоков.</span><span class="sxs-lookup"><span data-stu-id="dc63a-112">It’s important to reason about tasks as abstractions of work happening asynchronously, and *not* an abstraction over threading.</span></span> <span data-ttu-id="dc63a-113">По умолчанию задачи выполняются в текущем потоке и при необходимости делегируют работу операционной системе.</span><span class="sxs-lookup"><span data-stu-id="dc63a-113">By default, tasks execute on the current thread and delegate work to the Operating System, as appropriate.</span></span> <span data-ttu-id="dc63a-114">Для задач может также явно запрашиваться запуск в отдельном потоке через API `Task.Run`.</span><span class="sxs-lookup"><span data-stu-id="dc63a-114">Optionally, tasks can be explicitly requested to run on a separate thread via the `Task.Run` API.</span></span>

<span data-ttu-id="dc63a-115">Задачи предоставляют протокол API для мониторинга, ожидания и доступа к результирующему значению (в случае `Task<T>`) задачи.</span><span class="sxs-lookup"><span data-stu-id="dc63a-115">Tasks expose an API protocol for monitoring, waiting upon and accessing the result value (in the case of `Task<T>`) of a task.</span></span> <span data-ttu-id="dc63a-116">Интеграция с языком через ключевое слово `await` обеспечивает абстракцию более высокого уровня для использования задач.</span><span class="sxs-lookup"><span data-stu-id="dc63a-116">Language integration, with the `await` keyword, provides a higher-level abstraction for using tasks.</span></span>

<span data-ttu-id="dc63a-117">Использование `await` позволяет приложению или службе выполнять полезную работу во время выполнения задачи за счет передачи управления вызывающему объекту задачи до ее завершения.</span><span class="sxs-lookup"><span data-stu-id="dc63a-117">Using `await` allows your application or service to perform useful work while a task is running by yielding control to its caller until the task is done.</span></span> <span data-ttu-id="dc63a-118">В коде не нужно использовать обратные вызовы или события для продолжения выполнения после завершения задачи.</span><span class="sxs-lookup"><span data-stu-id="dc63a-118">Your code does not need to rely on callbacks or events to continue execution after the task has been completed.</span></span> <span data-ttu-id="dc63a-119">Это берут на себя язык и интеграцию API-интерфейса задач.</span><span class="sxs-lookup"><span data-stu-id="dc63a-119">The language and task API integration does that for you.</span></span> <span data-ttu-id="dc63a-120">Если вы используете `Task<T>`, ключевое слово `await` будет дополнительно "разворачивать" значение, возвращаемое после завершения задачи.</span><span class="sxs-lookup"><span data-stu-id="dc63a-120">If you’re using `Task<T>`, the `await` keyword will additionally "unwrap" the value returned when the Task is complete.</span></span>  <span data-ttu-id="dc63a-121">Ниже приводится подробное описание того, как это работает.</span><span class="sxs-lookup"><span data-stu-id="dc63a-121">The details of how this works are explained further below.</span></span>

<span data-ttu-id="dc63a-122">Дополнительные сведения о задачах и разных способах взаимодействия с ними см. в статье [Асинхронный шаблон, основанный на задачах (TAP)](./asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).</span><span class="sxs-lookup"><span data-stu-id="dc63a-122">You can learn more about tasks and the different ways to interact with them in the [Task-based Asynchronous Pattern (TAP)](./asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) topic.</span></span>

## <a name="deeper-dive-into-tasks-for-an-io-bound-operation"></a><span data-ttu-id="dc63a-123">Подробный обзор задач, связанных с операциями ввода-вывода</span><span class="sxs-lookup"><span data-stu-id="dc63a-123">Deeper Dive into Tasks for an I/O-Bound Operation</span></span>

<span data-ttu-id="dc63a-124">В следующем разделе приводится общее описание того, что происходит с обычным асинхронным вызовом ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="dc63a-124">The following section describes a 10,000 foot view of what happens with a typical async I/O call.</span></span> <span data-ttu-id="dc63a-125">Начнем с нескольких примеров.</span><span class="sxs-lookup"><span data-stu-id="dc63a-125">Let's start with a couple examples.</span></span>

<span data-ttu-id="dc63a-126">В первом примере вызывается асинхронный метод и возвращается активная задача, которая, вероятно, еще не завершилась.</span><span class="sxs-lookup"><span data-stu-id="dc63a-126">The first example calls an async method and returns an active task, likely yet to complete.</span></span>

```csharp
public Task<string> GetHtmlAsync()
{
    // Execution is synchronous here
    var client = new HttpClient();

    return client.GetStringAsync("https://www.dotnetfoundation.org");
}
```

<span data-ttu-id="dc63a-127">Во втором примере для работы с задачей добавляются ключевые слова `async` и `await`.</span><span class="sxs-lookup"><span data-stu-id="dc63a-127">The second example adds the use of the `async` and `await` keywords to operate on the task.</span></span>

```csharp
public async Task<string> GetFirstCharactersCountAsync(string url, int count)
{
    // Execution is synchronous here
    var client = new HttpClient();

    // Execution of GetFirstCharactersCountAsync() is yielded to the caller here
    // GetStringAsync returns a Task<string>, which is *awaited*
    var page = await client.GetStringAsync("https://www.dotnetfoundation.org");

    // Execution resumes when the client.GetStringAsync task completes,
    // becoming synchronous again.

    if (count > page.Length)
    {
        return page;
    }
    else
    {
        return page.Substring(0, count);
    }
}
```

<span data-ttu-id="dc63a-128">Вызов `GetStringAsync()` обращается к библиотекам .NET более низкого уровня (возможно с вызовом других асинхронных методов), пока не достигнет вызова взаимодействия P/Invoke собственной сетевой библиотеки.</span><span class="sxs-lookup"><span data-stu-id="dc63a-128">The call to `GetStringAsync()` calls through lower-level .NET libraries (perhaps calling other async methods) until it reaches a P/Invoke interop call into a native networking library.</span></span> <span data-ttu-id="dc63a-129">Собственная библиотека может впоследствии воспользоваться вызовом API System (например, выполнить запись `write()` в сокет в системе Linux).</span><span class="sxs-lookup"><span data-stu-id="dc63a-129">The native library may subsequently call into a System API call (such as `write()` to a socket on Linux).</span></span> <span data-ttu-id="dc63a-130">Объект задачи будут создан на собственной/управляемой границе, возможно, с использованием [TaskCompletionSource](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600)).</span><span class="sxs-lookup"><span data-stu-id="dc63a-130">A task object will be created at the native/managed boundary, possibly using [TaskCompletionSource](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600)).</span></span> <span data-ttu-id="dc63a-131">Объект задачи будет передаваться вверх через уровни, возможно, с некоторой обработкой или напрямую, и в результате возвратится к исходному вызывающему объекту.</span><span class="sxs-lookup"><span data-stu-id="dc63a-131">The task object will be passed up through the layers, possibly operated on or directly returned, eventually returned to the initial caller.</span></span>

<span data-ttu-id="dc63a-132">Во втором примере выше объект `Task<T>` будет возвращен из `GetStringAsync`.</span><span class="sxs-lookup"><span data-stu-id="dc63a-132">In the second example above, a `Task<T>` object will be returned from `GetStringAsync`.</span></span> <span data-ttu-id="dc63a-133">Использование ключевого слова `await` предписывает методу возвратить только что созданный объект задачи.</span><span class="sxs-lookup"><span data-stu-id="dc63a-133">The use of the `await` keyword causes the method to return a newly created task object.</span></span> <span data-ttu-id="dc63a-134">Управление возвращается вызывающему объекту из этого места в методе `GetFirstCharactersCountAsync`.</span><span class="sxs-lookup"><span data-stu-id="dc63a-134">Control returns to the caller from this location in the `GetFirstCharactersCountAsync` method.</span></span> <span data-ttu-id="dc63a-135">Методы и свойства объекта [Task&lt;T&gt;](xref:System.Threading.Tasks.Task%601) позволяют вызывающим объектам отслеживать ход выполнения задачи, которая завершится после выполнения оставшегося кода в GetFirstCharactersCountAsync.</span><span class="sxs-lookup"><span data-stu-id="dc63a-135">The methods and properties of the [Task&lt;T&gt;](xref:System.Threading.Tasks.Task%601) object enable callers to monitor the progress of the task, which will complete when the remaining code in GetFirstCharactersCountAsync has executed.</span></span>

<span data-ttu-id="dc63a-136">После вызова API System запрос оказывается в пространстве ядра и доходит до сетевой подсистемы операционной системы (например, до `/net` в Linux).</span><span class="sxs-lookup"><span data-stu-id="dc63a-136">After the System API call, the request is now in kernel space, making its way to the networking subsystem of the OS (such as `/net` in the Linux Kernel).</span></span>  <span data-ttu-id="dc63a-137">На этом этапе ОС обрабатывает сетевой запрос *асинхронно*.</span><span class="sxs-lookup"><span data-stu-id="dc63a-137">Here the OS will handle the networking request *asynchronously*.</span></span>  <span data-ttu-id="dc63a-138">Детали могут отличаться в зависимости от используемой операционной системы (вызов драйвера устройства может быть запланирован как сигнал, возвращаемый в среду выполнения, либо сначала выполняется вызов драйвера устройства, а *затем* возвращается сигнал), но в конечном счете среда выполнения будет проинформирована о том, что идет выполнение сетевого запроса.</span><span class="sxs-lookup"><span data-stu-id="dc63a-138">Details may be different depending on the OS used (the device driver call may be scheduled as a signal sent back to the runtime, or a device driver call may be made and *then* a signal sent back), but eventually the runtime will be informed that the networking request is in progress.</span></span>  <span data-ttu-id="dc63a-139">В это время драйвер устройства может находиться в одном из трех состояний: работа запланирована, работа выполняется, работа завершена (запрос уже отправлен обратно), но так как все это происходит асинхронно, драйвер устройства может сразу же приступать к выполнению других задач.</span><span class="sxs-lookup"><span data-stu-id="dc63a-139">At this time, the work for the device driver will either be scheduled, in-progress, or already finished (the request is already out "over the wire") - but because this is all happening asynchronously, the device driver is able to immediately handle something else!</span></span>

<span data-ttu-id="dc63a-140">Например, в Windows поток операционной системы направляет вызов к драйверу сетевого устройства и запрашивает у него выполнение сетевой операции через пакет запроса прерывания (IRP), который представляет собой операцию.</span><span class="sxs-lookup"><span data-stu-id="dc63a-140">For example, in Windows an OS thread makes a call to the network device driver and asks it to perform the networking operation via an Interrupt Request Packet (IRP) which represents the operation.</span></span>  <span data-ttu-id="dc63a-141">Драйвер устройства получает IRP, делает вызов к сети, помечает IRP как "ожидающий" и возвращает управление операционной системе.</span><span class="sxs-lookup"><span data-stu-id="dc63a-141">The device driver receives the IRP, makes the call to the network, marks the IRP as "pending", and returns back to the OS.</span></span>  <span data-ttu-id="dc63a-142">Так как поток ОС теперь знает, что запрос является "ожидающим", ему больше нечего делать в рамках этого задания и он "возвращается" обратно, где его можно использовать в других целях.</span><span class="sxs-lookup"><span data-stu-id="dc63a-142">Because the OS thread now knows that the IRP is "pending", it doesn't have any more work to do for this job and "returns" back so that it can be used to perform other work.</span></span>

<span data-ttu-id="dc63a-143">Когда запрос выполнен и данные возвращаются через драйвер устройства, поток с помощью прерывания уведомляет ЦП о получении новых данных.</span><span class="sxs-lookup"><span data-stu-id="dc63a-143">When the request is fulfilled and data comes back through the device driver, it notifies the CPU of new data received via an interrupt.</span></span>  <span data-ttu-id="dc63a-144">Обработка этого прерывания зависит от операционной системы, но в конечном счете данные будут передаваться в ОС, пока не достигнут вызова системного взаимодействия (например, в Linux обработчик прерываний зарезервирует нижнюю половину IRQ для асинхронной передачи данных через ОС).</span><span class="sxs-lookup"><span data-stu-id="dc63a-144">How this interrupt gets handled will vary depending on the OS, but eventually the data will be passed through the OS until it reaches a system interop call (for example, in Linux an interrupt handler will schedule the bottom half of the IRQ to pass the data up through the OS asynchronously).</span></span>  <span data-ttu-id="dc63a-145">Обратите внимание, что это *также* происходит асинхронно.</span><span class="sxs-lookup"><span data-stu-id="dc63a-145">Note that this *also* happens asynchronously!</span></span>  <span data-ttu-id="dc63a-146">Результат помещается в очередь, пока следующий доступный поток не сможет выполнить асинхронный метод и развернуть результат завершенной задачи.</span><span class="sxs-lookup"><span data-stu-id="dc63a-146">The result is queued up until the next available thread is able to execute the async method and "unwrap" the result of the completed task.</span></span>

<span data-ttu-id="dc63a-147">На протяжении всего процесса ключевым моментом является то, что **ни один поток не выделяется для выполнения задачи**.</span><span class="sxs-lookup"><span data-stu-id="dc63a-147">Throughout this entire process, a key takeaway is that **no thread is dedicated to running the task**.</span></span>  <span data-ttu-id="dc63a-148">Несмотря на то, что работа выполняется в некотором контексте (т. е. ОС нужно передать данные в драйвер устройства и ответить на прерывание), никакой поток специально не выделяется для *ожидания* возвращения данных из запроса.</span><span class="sxs-lookup"><span data-stu-id="dc63a-148">Although work is executed in some context (that is, the OS does have to pass data to a device driver and respond to an interrupt), there is no thread dedicated to *waiting* for data from the request to come back.</span></span>  <span data-ttu-id="dc63a-149">Это позволяет системе выполнять гораздо больший объем работы, а не ждать завершения какого-либо вызова операции ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="dc63a-149">This allows the system to handle a much larger volume of work rather than waiting for some I/O call to finish.</span></span>

<span data-ttu-id="dc63a-150">Несмотря на то, что вышесказанное может показаться довольно масштабным процессом, если его оценивать по общему времени исполнения, это считанные мгновения по сравнению с временем, которое тратится на фактические процедуры ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="dc63a-150">Although the above may seem like a lot of work to be done, when measured in terms of wall clock time, it’s miniscule compared to the time it takes to do the actual I/O work.</span></span> <span data-ttu-id="dc63a-151">График выполнения такого вызова, без претензии на точность, может выглядеть следующим образом:</span><span class="sxs-lookup"><span data-stu-id="dc63a-151">Although not at all precise, a potential timeline for such a call would look like this:</span></span>

<span data-ttu-id="dc63a-152">0-1————————————————————————————————————————————————–2-3</span><span class="sxs-lookup"><span data-stu-id="dc63a-152">0-1————————————————————————————————————————————————–2-3</span></span>

- <span data-ttu-id="dc63a-153">Время между точками `0` и `1` — это все, что происходит до того, как асинхронный метод передает управление вызывающему его объекту.</span><span class="sxs-lookup"><span data-stu-id="dc63a-153">Time spent from points `0` to `1` is everything up until an async method yields control to its caller.</span></span>
- <span data-ttu-id="dc63a-154">Время между точками `1` и `2` — это время, которое тратится на операции ввода-вывода без участия ЦП.</span><span class="sxs-lookup"><span data-stu-id="dc63a-154">Time spent from points `1` to `2` is the time spent on I/O, with no CPU cost.</span></span>
- <span data-ttu-id="dc63a-155">Наконец, время между точками `2` и `3` — это время на передачу назад управления (и, возможно, значения) асинхронному методу, когда он начинает выполняться снова.</span><span class="sxs-lookup"><span data-stu-id="dc63a-155">Finally, time spent from points `2` to `3` is passing control back (and potentially a value) to the async method, at which point it is executing again.</span></span>

### <a name="what-does-this-mean-for-a-server-scenario"></a><span data-ttu-id="dc63a-156">Что это означает для сервера?</span><span class="sxs-lookup"><span data-stu-id="dc63a-156">What does this mean for a server scenario?</span></span>

<span data-ttu-id="dc63a-157">Эта модель хорошо подходит для типовых рабочих нагрузок на сервере.</span><span class="sxs-lookup"><span data-stu-id="dc63a-157">This model works well with a typical server scenario workload.</span></span>  <span data-ttu-id="dc63a-158">Поскольку потоков, выделенных для блокировки незавершенных задач, нет, пул потоков на сервере может обрабатывать намного большее количество веб-запросов.</span><span class="sxs-lookup"><span data-stu-id="dc63a-158">Because there are no threads dedicated to blocking on unfinished tasks, the server threadpool can service a much higher volume of web requests.</span></span>

<span data-ttu-id="dc63a-159">Рассмотрим два сервера: один выполняет асинхронный код, а второй нет.</span><span class="sxs-lookup"><span data-stu-id="dc63a-159">Consider two servers: one that runs async code, and one that does not.</span></span>  <span data-ttu-id="dc63a-160">В данном примере на каждом сервере есть только 5 потоков, доступных для обслуживания запросов.</span><span class="sxs-lookup"><span data-stu-id="dc63a-160">For the purpose of this example, each server only has 5 threads available to service requests.</span></span>  <span data-ttu-id="dc63a-161">Обратите внимание, что эти числа не имеют никакого отношения к реальным цифрам в жизни и используются только в качестве примера.</span><span class="sxs-lookup"><span data-stu-id="dc63a-161">Note that these numbers are imaginarily small and serve only in a demonstrative context.</span></span>

<span data-ttu-id="dc63a-162">Предположим, что оба сервера получили 6 параллельных запросов.</span><span class="sxs-lookup"><span data-stu-id="dc63a-162">Assume both servers receive 6 concurrent requests.</span></span> <span data-ttu-id="dc63a-163">В каждом запросе выполняется операция ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="dc63a-163">Each request performs an I/O operation.</span></span>  <span data-ttu-id="dc63a-164">Сервер *без* асинхронного кода должен поставить в очередь 6-й запрос, пока один из 5 потоков не завершит работу, связанную с вводом-выводом, и не возвратит ответ.</span><span class="sxs-lookup"><span data-stu-id="dc63a-164">The server *without* async code has to queue up the 6th request until one of the 5 threads have finished the I/O-bound work and written a response.</span></span> <span data-ttu-id="dc63a-165">После поступления 20-го запроса работа сервера может начать замедляться, поскольку очередь становится слишком длинной.</span><span class="sxs-lookup"><span data-stu-id="dc63a-165">At the point that the 20th request comes in, the server might start to slow down, because the queue is getting too long.</span></span>

<span data-ttu-id="dc63a-166">Сервер *с* асинхронным кодом также помещает 6-й запрос в очередь, но так как он использует `async` и `await`, каждый из его потоков освобождается при начале работы подсистемы ввода-вывода, а не после завершения такой работы.</span><span class="sxs-lookup"><span data-stu-id="dc63a-166">The server *with* async code running on it still queues up the 6th request, but because it uses `async` and `await`, each of its threads are freed up when the I/O-bound work starts, rather than when it finishes.</span></span>  <span data-ttu-id="dc63a-167">К моменту поступления 20-го запроса очередь входящих запросов будет гораздо меньше (если в ней вообще что-либо будет), а сервер будет работать как и прежде.</span><span class="sxs-lookup"><span data-stu-id="dc63a-167">By the time the 20th request comes in, the queue for incoming requests will be far smaller (if it has anything in it at all), and the server won't slow down.</span></span>

<span data-ttu-id="dc63a-168">Хотя этот пример и вымышленный, в реальном мире все происходит примерно так же.</span><span class="sxs-lookup"><span data-stu-id="dc63a-168">Although this is a contrived example, it works in a very similar fashion in the real world.</span></span>  <span data-ttu-id="dc63a-169">Фактически можно ожидать, что сервер сможет обрабатывать на порядок больше запросов при использовании `async` и `await`, в отличие от стратегии с выделением потока для каждого поступающего запроса.</span><span class="sxs-lookup"><span data-stu-id="dc63a-169">In fact, you can expect a server to be able to handle an order of magnitude more requests using `async` and `await` than if it were dedicating a thread for each request it receives.</span></span>

### <a name="what-does-this-mean-for-client-scenario"></a><span data-ttu-id="dc63a-170">Что это означает для клиента?</span><span class="sxs-lookup"><span data-stu-id="dc63a-170">What does this mean for client scenario?</span></span>

<span data-ttu-id="dc63a-171">Важнейшим преимуществом использования `async` и `await` для клиента является повышение скорости реагирования.</span><span class="sxs-lookup"><span data-stu-id="dc63a-171">The biggest gain for using `async` and `await` for a client app is an increase in responsiveness.</span></span>  <span data-ttu-id="dc63a-172">Несмотря на то, что приложение можно сделать более отзывчивым за счет создания потоков вручную, процедура создания потока — это дорогостоящая операция по сравнению с использованием `async` и `await`.</span><span class="sxs-lookup"><span data-stu-id="dc63a-172">Although you can make an app responsive by spawning threads manually, the act of spawning a thread is an expensive operation relative to just using `async` and `await`.</span></span>  <span data-ttu-id="dc63a-173">Это особенно актуально, например, для мобильных игр, где воздействие на поток пользовательского интерфейса минимально, а скорость ввода-вывода имеет решающее значение.</span><span class="sxs-lookup"><span data-stu-id="dc63a-173">Especially for something like a mobile game, impacting the UI thread as little as possible where I/O is concerned is crucial.</span></span>

<span data-ttu-id="dc63a-174">Что еще важнее, поскольку работа, связанная с вводом-выводом, практически не задействует ресурсов ЦП, выделение целого потока ЦП для выполнения мизерной нагрузки является крайне неэффективным использованием ресурсов.</span><span class="sxs-lookup"><span data-stu-id="dc63a-174">More importantly, because I/O-bound work spends virtually no time on the CPU, dedicating an entire CPU thread to perform barely any useful work would be a poor use of resources.</span></span>

<span data-ttu-id="dc63a-175">Кроме того, направление работы в поток пользовательского интерфейса (например, обновление пользовательского интерфейса) с помощью методов `async` реализуется очень просто и не требует дополнительных усилий (например, вызова потокобезопасного делегата).</span><span class="sxs-lookup"><span data-stu-id="dc63a-175">Additionally, dispatching work to the UI thread (such as updating a UI) is very simple with `async` methods, and does not require extra work (such as calling a thread-safe delegate).</span></span>

## <a name="deeper-dive-into-task-and-taskt-for-a-cpu-bound-operation"></a><span data-ttu-id="dc63a-176">Подробный обзор Task и Task\<T> для операций, связанных с ЦП</span><span class="sxs-lookup"><span data-stu-id="dc63a-176">Deeper Dive into Task and Task\<T> for a CPU-Bound Operation</span></span>

<span data-ttu-id="dc63a-177">Код `async`, связанный с использованием ЦП, немного отличается от кода `async`, связанного с операциями ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="dc63a-177">CPU-bound `async` code is a bit different than I/O-bound `async` code.</span></span>  <span data-ttu-id="dc63a-178">Поскольку работа выполняется на ЦП, невозможно избежать выделения потока для вычислений.</span><span class="sxs-lookup"><span data-stu-id="dc63a-178">Because the work is done on the CPU, there's no way to get around dedicating a thread to the computation.</span></span>  <span data-ttu-id="dc63a-179">Использование `async` и `await` предоставляет чистый способ взаимодействия с фоновым потоком и позволяет объекту, вызвавшему асинхронный метод, по-прежнему реагировать на новые запросы.</span><span class="sxs-lookup"><span data-stu-id="dc63a-179">The use of `async` and `await` provides you with a clean way to interact with a background thread and keep the caller of the async method responsive.</span></span>  <span data-ttu-id="dc63a-180">Обратите внимание, что это не обеспечивает защиту общих данных.</span><span class="sxs-lookup"><span data-stu-id="dc63a-180">Note that this does not provide any protection for shared data.</span></span>  <span data-ttu-id="dc63a-181">Если вы используете общие данные, все равно потребуется применять соответствующую стратегию синхронизации.</span><span class="sxs-lookup"><span data-stu-id="dc63a-181">If you are using shared data, you will still need to apply an appropriate synchronization strategy.</span></span>

<span data-ttu-id="dc63a-182">Ниже приводится общий обзор асинхронного вызова, связанного с ЦП:</span><span class="sxs-lookup"><span data-stu-id="dc63a-182">Here's a 10,000 foot view of a CPU-bound async call:</span></span>

```csharp
public async Task<int> CalculateResult(InputData data)
{
    // This queues up the work on the threadpool.
    var expensiveResultTask = Task.Run(() => DoExpensiveCalculation(data));

    // Note that at this point, you can do some other work concurrently,
    // as CalculateResult() is still executing!

    // Execution of CalculateResult is yielded here!
    var result = await expensiveResultTask;

    return result;
}
```

<span data-ttu-id="dc63a-183">`CalculateResult()` выполняется в потоке, в котором он вызывался.</span><span class="sxs-lookup"><span data-stu-id="dc63a-183">`CalculateResult()` executes on the thread it was called on.</span></span>  <span data-ttu-id="dc63a-184">Когда он вызывает `Task.Run`, он помещает дорогостоящую операцию, связанную с ЦП, `DoExpensiveCalculation()`, в очередь пула потоков и получает дескриптор `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="dc63a-184">When it calls `Task.Run`, it queues the expensive CPU-bound operation, `DoExpensiveCalculation()`, on the thread pool and receives a `Task<int>` handle.</span></span>  <span data-ttu-id="dc63a-185">`DoExpensiveCalculation()` в конечном счете выполняется параллельно в следующем доступном потоке, скорее всего, на другом ядре ЦП.</span><span class="sxs-lookup"><span data-stu-id="dc63a-185">`DoExpensiveCalculation()` is eventually run concurrently on the next available thread, likely on another CPU core.</span></span>  <span data-ttu-id="dc63a-186">Пока `DoExpensiveCalculation()` выполняется в другом потоке, можно выполнять параллельные операции, так как поток, вызвавший `CalculateResult()`, по-прежнему выполняется.</span><span class="sxs-lookup"><span data-stu-id="dc63a-186">It's possible to do concurrent work while `DoExpensiveCalculation()` is busy on another thread, because the thread which called `CalculateResult()` is still executing.</span></span>

<span data-ttu-id="dc63a-187">При появлении `await` выполнение `CalculateResult()` передается вызвавшему объекту, что позволяет выполнить другую работу в параллельном потоке, пока `DoExpensiveCalculation()` формирует результат.</span><span class="sxs-lookup"><span data-stu-id="dc63a-187">Once `await` is encountered, the execution of `CalculateResult()` is yielded to its caller, allowing other work to be done with the current thread while `DoExpensiveCalculation()` is churning out a result.</span></span>  <span data-ttu-id="dc63a-188">После завершения его работы результат передается в очередь для использования в основном потоке.</span><span class="sxs-lookup"><span data-stu-id="dc63a-188">Once it has finished, the result is queued up to run on the main thread.</span></span>  <span data-ttu-id="dc63a-189">В конечном счете основной поток вернется к выполнению `CalculateResult()`, при этом у него будет результат `DoExpensiveCalculation()`.</span><span class="sxs-lookup"><span data-stu-id="dc63a-189">Eventually, the main thread will return to executing `CalculateResult()`, at which point it will have the result of `DoExpensiveCalculation()`.</span></span>

### <a name="why-does-async-help-here"></a><span data-ttu-id="dc63a-190">Что здесь дает асинхронный режим?</span><span class="sxs-lookup"><span data-stu-id="dc63a-190">Why does async help here?</span></span>

<span data-ttu-id="dc63a-191">`async` и `await` рекомендуется использовать для действий, связанных с ЦП, когда необходима быстрая скорость реагирования.</span><span class="sxs-lookup"><span data-stu-id="dc63a-191">`async` and `await` are the best practice for managing CPU-bound work when you need responsiveness.</span></span> <span data-ttu-id="dc63a-192">Существуют разные модели использования асинхронного кода для работы, связанной с ЦП.</span><span class="sxs-lookup"><span data-stu-id="dc63a-192">There are multiple patterns for using async with CPU-bound work.</span></span> <span data-ttu-id="dc63a-193">Важно отметить, что использование асинхронного кода приводит к небольшим затратам и не рекомендуется для непрерывных циклов.</span><span class="sxs-lookup"><span data-stu-id="dc63a-193">It's important to note that there is a small cost to using async and it's not recommended for tight loops.</span></span>  <span data-ttu-id="dc63a-194">Решать, как использовать эту новую возможность в своем коде, предстоит вам.</span><span class="sxs-lookup"><span data-stu-id="dc63a-194">It's up to you to determine how you write your code around this new capability.</span></span>

## <a name="see-also"></a><span data-ttu-id="dc63a-195">См. также</span><span class="sxs-lookup"><span data-stu-id="dc63a-195">See also</span></span>

- [<span data-ttu-id="dc63a-196">Асинхронное программирование на C#</span><span class="sxs-lookup"><span data-stu-id="dc63a-196">Asynchronous programming in C#</span></span>](../csharp/async.md)
- [<span data-ttu-id="dc63a-197">Асинхронное программирование с использованием ключевых слов Async и Await (C#)</span><span class="sxs-lookup"><span data-stu-id="dc63a-197">Asynchronous programming with async and await (C#)</span></span>](../csharp/programming-guide/concepts/async/index.md)
- [<span data-ttu-id="dc63a-198">Асинхронное программирование на F#</span><span class="sxs-lookup"><span data-stu-id="dc63a-198">Async Programming in F#</span></span>](../fsharp/tutorials/asynchronous-and-concurrent-programming/async.md)
- [<span data-ttu-id="dc63a-199">Асинхронное программирование с использованием ключевых слов Async и Await (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="dc63a-199">Asynchronous Programming with Async and Await (Visual Basic)</span></span>](../visual-basic/programming-guide/concepts/async/index.md)
