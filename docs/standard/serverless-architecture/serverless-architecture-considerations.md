---
title: Рекомендации по бессерверной архитектуры ― Бессерверных приложений
description: Понимание проблем разработки бессерверных приложений, управление состоянием и постоянное хранилище, чтобы масштабировать, ведения журнала, трассировки и диагностики.
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 06/26/2018
ms.openlocfilehash: b12a09c0fcef7e7ff954a3f959fb9e3080a6e859
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61940950"
---
# <a name="serverless-architecture-considerations"></a>Рекомендации по бессерверной архитектуре

Внедрение бессерверной архитектуры поставляются с определенными задачами. В этом разделе рассматриваются некоторые из наиболее типичные аспекты, которые следует учитывать. Все эти проблемы имеют решения. Как и для всех вариантов архитектуры, решение для перехода на бессерверные технологии должен принимать только после тщательной проверки преимущества и недостатки. В зависимости от потребностей вашего приложения можно решить, что бессерверной реализации не подходящим решением для определенных компонентов.

## <a name="managing-state"></a>Управление состоянием

Бессерверные функции, как и в случае с микрослужбами в целом, не имеют состояния по умолчанию. Использования состояние позволяет без сервера является реальным, масштабировать и для обеспечения устойчивости без центральную точку сбоя. В некоторых случаях бизнес-процессы требуют состояния. Если процесс требует состояние, можно двумя способами. Можно внедрить модель, отличный от бессерверных или взаимодействия с отдельная служба, которая предоставляет состояние. Добавление состояния может усложнить решение и усложнить масштабирования и потенциально создать единую точку отказа. Внимательно рассмотрите, требуется ли функции абсолютно состояния. Если вы ответили «Да», определяют ли по-прежнему имеет смысл для его реализации благодаря бессерверной архитектуре.

Существует несколько решения для использования состоянии без ущерба для преимущества бессерверных приложений. Ниже перечислены некоторые из наиболее популярных решений.

* Использовать временное хранилище данных или распределенного кэша, например Redis
* Store состояния в базе данных, например SQL или CosmosDB
* Обработки состояния через механизм рабочих процессов, таких как устойчивые функции

Суть в том, что следует иметь в виду необходим для любой управления состоянием, в рамках процессов, которые вы решили реализовать благодаря бессерверной архитектуре.

## <a name="long-running-processes"></a>Длительно выполняемых процессов

Многие преимущества бессерверных полагаться на временные процессах. Короткое время упрощают для бессерверной поставщика для высвобождения ресурсов, как функции окончания и общая папка на узлах. Большинство поставщиков облачных служб ограничить общее время выполнения функции для около 10 минут. Если процесс может занять больше времени, можно рассмотреть альтернативную реализацию.

Существует несколько исключений и решений. Одним из решений может быть прервать процесс на более мелкие компоненты, которые по отдельности занять меньше времени на выполнение. Если процесс выполняется долго из-за зависимостей, можно также асинхронных рабочих процессов, с помощью такого решения, как устойчивых функций. Устойчивые функции приостанавливать и поддержания состояния вашего процесса, пока он ожидает завершения внешнего процесса. Асинхронной обработки уменьшает время, в которой выполняется процесс.

## <a name="startup-time"></a>Время запуска

Одна из потенциальных проблем с бессерверной реализациями — время запуска. В целях экономии ресурсов, многие поставщики бессерверной Создание инфраструктуры «по требованию». При независимой от сервера функции активации после определенного периода времени, ресурсов для размещения функция может потребоваться создать или перезапуска. В некоторых ситуациях холодного запуска может привести к задержкам несколько секунд. Время запуска различается поставщиков и уровни обслуживания. Если важно свести к минимуму для успеха приложения существует несколько подходов к времени запуска адрес.

* Некоторые поставщики разрешают пользователям оплачивать уровни обслуживания, которые гарантируют, что инфраструктура находится в «always on».
* Реализуйте механизм поддержания активности (проверка связи конечной точки для обеспечения его «переходит в спящий режим»).
* Используйте оркестрации как Kubernetes с помощью подхода контейнерных функции (узел уже выполняется, развертывания новых экземпляров выполняется очень быстро).

## <a name="database-updates-and-migrations"></a>Обновления базы данных и миграции

Преимуществом кода без сервера является то, что вы можете выпустить новые функции, без необходимости повторного развертывания всего приложения. Это преимущество могут стать недостаток, если существует реляционной базы данных. Изменение схемы базы данных не трудно выполнить синхронизацию с обновлениями без сервера. Дополнительные сложности предназначена, когда что-то пошло, и необходимо выполнить откат изменений. Целостность данных — одна из причин для микрослужб и бессерверных функций рекомендуется что у них есть свои собственные данные. Это позволяет развертывать изменения как единое целое вычислительных ресурсов и данных. Реальность состоит в том, что во многих системах предыдущих версий компонентов больших серверной базы данных, которые должны быть согласованы с помощью бессерверной архитектуры.

Популярный подход для решения управления версиями схемы — никогда не изменяйте существующие свойства и столбцы, а также добавить новые данные. Например, рассмотрим изменение для перемещения из логического значения «завершено» флаг для todo list для «Дата завершения». Вместо удаления старого поля, изменение базы данных выполняются следующие действия:

1. Добавьте поле нового «Дата завершения».
1. Преобразование «завершено» логическое поле для вычисляемой функции, который определяет, является ли дата завершения после текущей даты.
1. Добавление триггера для установки завершенного даты до текущей даты, когда задано значение завершенного логическое значение в значение true.

Последовательность изменений гарантирует, что устаревший код продолжает выполняться «как есть», пока новая бессерверных функций можно воспользоваться преимуществами нового поля.

Дополнительные сведения о данных в бессерверной архитектуры, см. в разделе [проблемы и решения распределенное управление данными](../microservices-architecture/architect-microservice-container-applications/distributed-data-management.md).

## <a name="scaling"></a>Масштабирование

Это распространенное заблуждение, что бессерверной означает «не server». Это на самом деле «меньше server». Тот факт, что является инфраструктуры резервных важно понимать, когда дело доходит до масштабирования. Наиболее бессерверной платформы предоставляют набор элементов управления для обработки, как инфраструктура должны масштабироваться при увеличении плотность событий. Можно выбрать из множества вариантов, но ваша стратегия зависит от функции. Кроме того функции обычно выполняются в узле связанных таким образом, чтобы функции на одном узле имеют одинаковые параметры масштабирования. Поэтому это необходимо для организации и разработки стратегии, какие функции размещаются вместе на основании требований к масштабированию.

Правила часто укажите способ вертикального масштабирования (увеличить ресурсы узла) и горизонтальное масштабирование (увеличение числа экземпляров узла) на основе различных параметров. Триггеры для шкал может включать в расписание, частоты запросов, использования ЦП и использование памяти. Более высокая производительность часто придется заплатить больше. Подходы дешевле, с учетом потребления ресурсов могут масштабироваться с увеличением быстро при частоте запросов неожиданно. Есть компромисс между платить заранее «страхования затраты», и платить строго «как вы go» и что подвергает риску ответы медленнее из-за внезапного увеличения спроса.

## <a name="monitoring-tracing-and-logging"></a>Мониторинг, трассировка и ведение журнала

Часто не уделяют должного внимания аспектом DevOps мониторинг приложений после развертывания. Очень важно иметь стратегию для наблюдения за бессерверные функции. Самая сложная задача — часто корреляции или распознает, когда пользователь вызывает несколько функций в рамках одного взаимодействия. Наиболее бессерверные платформы позволяют консоли, журнал, который можно импортировать в сторонние средства. Также вы можете автоматизировать сбор данных телеметрии, создавать и отслеживать идентификаторы корреляции и отслеживать определенные действия, чтобы получить подробное представление. Azure предоставляет расширенные [платформы Application Insights](https://docs.microsoft.com/azure/azure-functions/functions-monitoring) для мониторинга и анализа.

## <a name="inter-service-dependencies"></a>Зависимости между службами

Бессерверная архитектура может включать функции, которые зависят от других функций. На самом деле не нередко в бессерверной архитектуры, чтобы иметь несколько служб, которые вызывают друг друга в процессе взаимодействия или распределенной транзакции. Чтобы избежать возникновения сильных взаимозависимостей, рекомендуется, что службы не ссылаются друг на друга непосредственно. Если конечная точка для службы необходимо изменить, прямые ссылки может привести основных рефакторинга. Предлагаемое решение — предоставить механизм обнаружения служб, таких как реестр, который предоставляет соответствующую конечную точку для типа запроса. Еще одно решение — использовать обмена сообщениями службы, такие как очереди или разделы для обмена данными между службами.

## <a name="managing-failure-and-providing-resiliency"></a>Управление сбоя и предоставляя устойчивости

Это также необходимо иметь в виду *шаблона размыкателя цепи*: Если для какой-то причине службы продолжают возникать ошибки, не рекомендуется повторно вызывать эту службу. Вместо этого вызывается другую службу, или сообщение возвращается, пока не будет восстановлено состояние зависимые службы. Бессерверная архитектура необходимо принимать во внимание стратегии для разрешения и управление зависимостями между службами.

Для продолжения шаблона размыкателя цепи, службы должны быть отказоустойчивой и устойчивость. Устойчивость к сбоям означает способность приложения продолжать выполнение даже после непредвиденных исключений или обнаружены недопустимые состояния. Отказоустойчивость обычно является функцией сам код, и как он написал для обработки исключений. Устойчивость — это способность приложения находится на восстановление после сбоев. Устойчивость часто осуществляется с бессерверной платформе. Платформы должны иметь возможность запустить новый экземпляр независимой от сервера функции при сбое существующий. Платформа также должен быть достаточно «умными» для остановки развертывания новых экземпляров, когда каждый новый экземпляр выходит из строя.

Дополнительные сведения см. в разделе [реализация шаблона Размыкателя цепи](../microservices-architecture/implement-resilient-applications/implement-circuit-breaker-pattern.md).

## <a name="versioning-and-greenblue-deployments"></a>Управление версиями и зеленого и синего развертываний

Главным преимуществом бессерверной является возможность обновления определенной функции без необходимости повторного развертывания всего приложения. Обновления для успешной работы функции необходимо включить управление версиями, таким образом, вызывающих служб направляются в правильную версию кода. Важно также стратегии развертывания новых версий. Распространенным подходом является использование «зеленого и синего развертываний.» Зеленый развертывания является текущей функции. Новая версия «blue» развертывается в рабочей среде и тестирование. При тестировании проходов, зеленого и синего версии меняются местами, поэтому новой версии следует в реальном времени. Если возникли проблемы, их можно переключать обратно. Поддержка управления версиями и зеленого и синего развертываний требуется сочетание разработки функции в соответствии с изменением версии и работы с ними бессерверная платформа для обработки развертывания. Один из возможных способов является использование учетных записей-посредников, которые описаны в [Azure бессерверной платформе](azure-functions.md#proxies) главы.

>[!div class="step-by-step"]
>[Назад](serverless-architecture.md)
>[Вперед](serverless-design-examples.md)