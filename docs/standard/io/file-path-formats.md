---
title: Форматы путей к файлам в системах Windows
ms.date: 06/06/2019
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- I/O, long paths
- long paths
- path formats, Windows
ms.openlocfilehash: 258cf59fb8383fe131f4a0e78dac6189e1d9c91e
ms.sourcegitcommit: 30a558d23e3ac5a52071121a52c305c85fe15726
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/25/2019
ms.locfileid: "75337671"
---
# <a name="file-path-formats-on-windows-systems"></a><span data-ttu-id="dd3d6-102">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="dd3d6-102">File path formats on Windows systems</span></span>

<span data-ttu-id="dd3d6-103">Члены большинства типов в пространстве имен <xref:System.IO> имеют параметр `path`, который позволяет указать абсолютный или относительный путь к ресурсу в файловой системе.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-103">Members of many of the types in the <xref:System.IO> namespace include a `path` parameter that lets you specify an absolute or relative path to a file system resource.</span></span> <span data-ttu-id="dd3d6-104">Этот путь передается в [API файловой системы Windows](/windows/desktop/fileio/file-systems).</span><span class="sxs-lookup"><span data-stu-id="dd3d6-104">This path is then passed to [Windows file system APIs](/windows/desktop/fileio/file-systems).</span></span> <span data-ttu-id="dd3d6-105">В этом разделе рассматриваются форматы путей к файлам, которые можно использовать в операционных системах Windows.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-105">This topic discusses the formats for file paths that you can use on Windows systems.</span></span>

## <a name="traditional-dos-paths"></a><span data-ttu-id="dd3d6-106">Традиционные пути DOS</span><span class="sxs-lookup"><span data-stu-id="dd3d6-106">Traditional DOS paths</span></span>

<span data-ttu-id="dd3d6-107">Стандартный путь DOS может состоять из трех компонентов:</span><span class="sxs-lookup"><span data-stu-id="dd3d6-107">A standard DOS path can consist of three components:</span></span>

- <span data-ttu-id="dd3d6-108">Буква тома или диска, после которой следует разделитель томов (`:`).</span><span class="sxs-lookup"><span data-stu-id="dd3d6-108">A volume or drive letter followed by the volume separator (`:`).</span></span>
- <span data-ttu-id="dd3d6-109">Имя каталога.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-109">A directory name.</span></span> <span data-ttu-id="dd3d6-110">[Символ разделителя каталогов](<xref:System.IO.Path.DirectorySeparatorChar>) служит для разделения подкаталогов во внутренней иерархии каталога.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-110">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates subdirectories within the nested directory hierarchy.</span></span>
- <span data-ttu-id="dd3d6-111">Необязательное имя файла.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-111">An optional filename.</span></span> <span data-ttu-id="dd3d6-112">[Символ разделителя каталогов](<xref:System.IO.Path.DirectorySeparatorChar>) служит для разделения пути к файлу и его имени.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-112">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates the file path and the filename.</span></span>

<span data-ttu-id="dd3d6-113">Если присутствуют все три компонента, путь является абсолютным.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-113">If all three components are present, the path is absolute.</span></span> <span data-ttu-id="dd3d6-114">Если буква тома или диска не указана и имя каталога начинается с [символа разделителя каталогов](<xref:System.IO.Path.DirectorySeparatorChar>), такой путь задан относительно корня текущего диска.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-114">If no volume or drive letter is specified and the directory name begins with the [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>), the path is relative from the root of the current drive.</span></span> <span data-ttu-id="dd3d6-115">В противном случае путь задан относительно текущего каталога.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-115">Otherwise, the path is relative to the current directory.</span></span> <span data-ttu-id="dd3d6-116">В следующей таблице показаны некоторые возможные пути к каталогам и файлам.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-116">The following table shows some possible directory and file paths.</span></span>

|<span data-ttu-id="dd3d6-117">Путь</span><span class="sxs-lookup"><span data-stu-id="dd3d6-117">Path</span></span>  |<span data-ttu-id="dd3d6-118">Описание:</span><span class="sxs-lookup"><span data-stu-id="dd3d6-118">Description</span></span>  |
| -- | -- |
| `C:\Documents\Newsletters\Summer2018.pdf` | <span data-ttu-id="dd3d6-119">Абсолютный путь к файлу из корня диска C:.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-119">An absolute file path from the root of drive C:</span></span> |
| `\Program Files\Custom Utilities\StringFinder.exe` | <span data-ttu-id="dd3d6-120">Абсолютный путь из корня текущего диска.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-120">An absolute path from the root of the current drive.</span></span> |
| `2018\January.xlsx` | <span data-ttu-id="dd3d6-121">Относительный путь к файлу в подкаталоге текущего каталога.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-121">A relative path to a file in a subdirectory of the current directory.</span></span> |
| `..\Publications\TravelBrochure.pdf` | <span data-ttu-id="dd3d6-122">Относительный путь к файлу в каталоге, который является одноранговым для текущего каталога.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-122">A relative path to file in a directory that is a peer of the current directory.</span></span> |
| `C:\Projects\apilibrary\apilibrary.sln` | <span data-ttu-id="dd3d6-123">Абсолютный путь к файлу из корня диска C:.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-123">An absolute path to a file from the root of drive C:</span></span> |
| `C:Projects\apilibrary\apilibrary.sln` | <span data-ttu-id="dd3d6-124">Относительный путь из текущего каталога диска C:.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-124">A relative path from the current directory of the C: drive.</span></span> |

> [!IMPORTANT]
> <span data-ttu-id="dd3d6-125">Обратите внимание на различия между двумя последними путями.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-125">Note the difference between the last two paths.</span></span> <span data-ttu-id="dd3d6-126">В обоих случаях задается необязательный описатель тома (C:), однако первый путь, в отличие от второго, начинается с корня указанного тома.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-126">Both specify the optional volume specifier (C: in both cases), but the first begins with the root of the specified volume, whereas the second does not.</span></span> <span data-ttu-id="dd3d6-127">В результате первый путь является абсолютным из корневого каталога диска C:, тогда как второй — относительным из текущего каталога C:.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-127">As result, the first is an absolute path from the root directory of drive C:, whereas the second is a relative path from the current directory of drive C:.</span></span> <span data-ttu-id="dd3d6-128">Использование второй формы пути в тех случаях, когда предполагается наличие первой, является распространенным источником ошибок, связанных с путями к файлам в Windows.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-128">Use of the second form when the first is intended is a common source of bugs that involve Windows file paths.</span></span>

<span data-ttu-id="dd3d6-129">Чтобы определить, является ли путь к файлу полным (такой путь не зависит от текущего каталога и не изменяется при смене текущего каталога), можно вызвать метод <xref:System.IO.Path.IsPathFullyQualified%2A?displayProperty=nameWthType>.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-129">You can determine whether a file path is fully qualified (that is, it the path is independent of the current directory and does not change when the current directory changes) by calling the <xref:System.IO.Path.IsPathFullyQualified%2A?displayProperty=nameWthType> method.</span></span> <span data-ttu-id="dd3d6-130">Обратите внимание, что такой путь может включать сегменты с относительным путем к каталогу (`.` и `..`), но при этом по-прежнему будет полным, если разрешенный путь всегда указывает на одно и то же место.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-130">Note that such a path can include relative directory segments (`.` and `..`) and still be fully qualified if the resolved path always points to the same location.</span></span>

<span data-ttu-id="dd3d6-131">В приведенном ниже примере показано различие между абсолютными и относительными путями.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-131">The following example illustrates the difference between absolute and relative paths.</span></span> <span data-ttu-id="dd3d6-132">Предполагается, что каталог D:\FY2018\ существует и вы не установили какой-либо текущий каталог для диска D:\ из командной строки перед запуском этого примера.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-132">It assumes that the directory D:\FY2018\ exists, and that you haven't set any current directory for D:\ from the command prompt before running the example.</span></span>

[!code-csharp[absolute-and-relative-paths](~/samples/snippets/standard/io/file-names/cs/paths.cs)]
[!code-vb[absolute-and-relative-paths](~/samples/snippets/standard/io/file-names/vb/paths.vb)]

## <a name="unc-paths"></a><span data-ttu-id="dd3d6-133">UNC-пути</span><span class="sxs-lookup"><span data-stu-id="dd3d6-133">UNC paths</span></span>

<span data-ttu-id="dd3d6-134">UNC-пути (универсальное соглашение об именовании) используются для доступа к сетевым ресурсам и имеют следующий формат:</span><span class="sxs-lookup"><span data-stu-id="dd3d6-134">Universal naming convention (UNC) paths, which are used to access network resources, have the following format:</span></span>

- <span data-ttu-id="dd3d6-135">Имя сервера или узла, которому предшествуют символы \\\\.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-135">A server or host name, which is prefaced by \\\\.</span></span> <span data-ttu-id="dd3d6-136">В качестве имени сервера может выступать имя компьютера NetBIOS, а также IP-адрес или полное доменное имя (поддерживаются адреса IPv4 и IPv6).</span><span class="sxs-lookup"><span data-stu-id="dd3d6-136">The server name can be a NetBIOS machine name or an IP/FQDN address (IPv4 as well as v6 are supported).</span></span>
- <span data-ttu-id="dd3d6-137">Имя общего ресурса, которое отделяется от имени узла символами \\.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-137">A share name, which is separated from the host name by \\.</span></span> <span data-ttu-id="dd3d6-138">Имя сервера и имя общего ресурса в совокупности образуют том.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-138">Together, the server and share name make up the volume.</span></span>
- <span data-ttu-id="dd3d6-139">Имя каталога.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-139">A directory name.</span></span> <span data-ttu-id="dd3d6-140">[Символ разделителя каталогов](<xref:System.IO.Path.DirectorySeparatorChar>) служит для разделения подкаталогов во внутренней иерархии каталога.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-140">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates subdirectories within the nested directory hierarchy.</span></span>
- <span data-ttu-id="dd3d6-141">Необязательное имя файла.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-141">An optional filename.</span></span> <span data-ttu-id="dd3d6-142">[Символ разделителя каталогов](<xref:System.IO.Path.DirectorySeparatorChar>) служит для разделения пути к файлу и его имени.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-142">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates the file path and the filename.</span></span>

<span data-ttu-id="dd3d6-143">Ниже приводятся некоторые примеры UNC-путей:</span><span class="sxs-lookup"><span data-stu-id="dd3d6-143">The following are some examples of UNC paths:</span></span>

|<span data-ttu-id="dd3d6-144">Path</span><span class="sxs-lookup"><span data-stu-id="dd3d6-144">Path</span></span>  |<span data-ttu-id="dd3d6-145">Описание</span><span class="sxs-lookup"><span data-stu-id="dd3d6-145">Description</span></span>  |
| -- | -- |
| `\\system07\C$\` | <span data-ttu-id="dd3d6-146">Корневой каталог диска C: на компьютере `system07`.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-146">The root directory of the C: drive on `system07`.</span></span> |
| `\\Server2\Share\Test\Foo.txt` | <span data-ttu-id="dd3d6-147">Файл Foo.txt в каталоге Test на томе \\\\Server2\\Share.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-147">The Foo.txt file in the Test directory of the \\\\Server2\\Share volume.</span></span>|

<span data-ttu-id="dd3d6-148">UNC-пути всегда должны быть полными.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-148">UNC paths must always be fully qualified.</span></span> <span data-ttu-id="dd3d6-149">Они могут включать сегменты с относительным путем к каталогу (`.` и `..`), однако они должны быть частью полного пути.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-149">They can include relative directory segments (`.` and `..`), but these must be part of a fully qualified path.</span></span> <span data-ttu-id="dd3d6-150">Использовать относительные пути можно только посредством сопоставления UNC-пути с буквой диска.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-150">You can use relative paths only by mapping a UNC path to a drive letter.</span></span>

## <a name="dos-device-paths"></a><span data-ttu-id="dd3d6-151">Пути к устройствам DOS</span><span class="sxs-lookup"><span data-stu-id="dd3d6-151">DOS device paths</span></span>

<span data-ttu-id="dd3d6-152">В операционной системе Windows используется унифицированная объектная модель, которая указывает на все ресурсы, включая файлы.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-152">The Windows operating system has a unified object model that points to all resources, including files.</span></span> <span data-ttu-id="dd3d6-153">Эти пути к объектам доступны из окна консоли и предоставляются на уровень Win32 с использованием специальной папки с символьными ссылками, с которыми сопоставляются устаревшие пути DOS и UNC.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-153">These object paths are accessible from the console window and are exposed to the Win32 layer through a special folder of symbolic links that legacy DOS and UNC paths are mapped to.</span></span> <span data-ttu-id="dd3d6-154">Доступ к этой специальной папке осуществляется с использованием синтаксиса пути к устройству DOS, который может иметь одну из приведенных ниже форм:</span><span class="sxs-lookup"><span data-stu-id="dd3d6-154">This special folder is accessed via the DOS device path syntax, which is one of:</span></span>

`\\.\C:\Test\Foo.txt`
`\\?\C:\Test\Foo.txt`

<span data-ttu-id="dd3d6-155">Помимо использования буквы диска, вы можете указать том с помощью его GUID.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-155">In addition to identifying a drive by its drive letter, you can identify a volume by using its volume GUID.</span></span> <span data-ttu-id="dd3d6-156">Синтаксис будет иметь вид:</span><span class="sxs-lookup"><span data-stu-id="dd3d6-156">This takes the form:</span></span>

`\\.\Volume{b75e2c83-0000-0000-0000-602f00000000}\Test\Foo.txt`
`\\?\Volume{b75e2c83-0000-0000-0000-602f00000000}\Test\Foo.txt`

> [!NOTE]
> <span data-ttu-id="dd3d6-157">Синтаксис пути к устройству DOS поддерживается в реализациях платформы .NET для ОС Windows, начиная с версий .NET Core 1.1 и .NET Framework 4.6.2.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-157">DOS device path syntax is supported on .NET implementations running on Windows starting with .NET Core 1.1 and .NET Framework 4.6.2.</span></span>

<span data-ttu-id="dd3d6-158">Путь к устройству DOS состоит из следующих компонентов:</span><span class="sxs-lookup"><span data-stu-id="dd3d6-158">The DOS device path consists of the following components:</span></span>

- <span data-ttu-id="dd3d6-159">Описатель пути к устройству (`\\.\` или `\\?\`), который идентифицирует путь как путь к устройству DOS.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-159">The device path specifier (`\\.\` or `\\?\`), which identifies the path as a DOS device path.</span></span>

   > [!NOTE]
   > <span data-ttu-id="dd3d6-160">Описатель `\\?\` поддерживается во всех версиях .NET Core, а также в версиях .NET Framework, начиная с 4.6.2.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-160">The `\\?\` is supported in all versions of .NET Core and in the .NET Framework starting with version 4.6.2.</span></span>

- <span data-ttu-id="dd3d6-161">Символьная ссылка на "реальный" объект устройства (C: в случае имени диска или Volume{b75e2c83-0000-0000-0000-602f00000000} в случае GUID тома).</span><span class="sxs-lookup"><span data-stu-id="dd3d6-161">A symbolic link to the "real" device object (C: in the case of a drive name, or Volume{b75e2c83-0000-0000-0000-602f00000000} in the case of a volume GUID).</span></span>

   <span data-ttu-id="dd3d6-162">Первый сегмент пути к устройству DOS после описателя пути к устройству идентифицирует том или диск.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-162">The first segment of the DOS device path after the device path specifier identifies the volume or drive.</span></span> <span data-ttu-id="dd3d6-163">(Например, `\\?\C:\` и `\\.\BootPartition\`.)</span><span class="sxs-lookup"><span data-stu-id="dd3d6-163">(For example, `\\?\C:\` and `\\.\BootPartition\`.)</span></span>

   <span data-ttu-id="dd3d6-164">Для UNC-путей существует специальная ссылка, которая называется `UNC`.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-164">There is a specific link for UNCs that is called, not surprisingly, `UNC`.</span></span> <span data-ttu-id="dd3d6-165">Пример:</span><span class="sxs-lookup"><span data-stu-id="dd3d6-165">For example:</span></span>

  `\\.\UNC\Server\Share\Test\Foo.txt`
  `\\?\UNC\Server\Share\Test\Foo.txt`

    <span data-ttu-id="dd3d6-166">Для UNC-путей к устройствам часть сервера или общего сетевого ресурса образует том.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-166">For device UNCs, the server/share portion forms the volume.</span></span> <span data-ttu-id="dd3d6-167">Например, в пути `\\?\server1\e:\utilities\\filecomparer\` часть server1\utilities представляет сервер или общий сетевой ресурс.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-167">For example, in `\\?\server1\e:\utilities\\filecomparer\`, the server/share portion is server1\utilities.</span></span> <span data-ttu-id="dd3d6-168">Это важно при вызове такого метода, как <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> с сегментами с относительным путем к каталогу, поскольку переход дальше тома невозможен.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-168">This is significant when calling a method such as <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> with relative directory segments; it is never possible to navigate past the volume.</span></span>

<span data-ttu-id="dd3d6-169">Пути к устройствами DOS по определению являются полными.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-169">DOS device paths are fully qualified by definition.</span></span> <span data-ttu-id="dd3d6-170">Сегменты с относительным путем к каталогу (`.` и `..`) в них не допускаются.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-170">Relative directory segments (`.` and `..`) are not allowed.</span></span> <span data-ttu-id="dd3d6-171">Они никогда не задаются относительно текущего каталога.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-171">Current directories never enter into their usage.</span></span>

## <a name="example-ways-to-refer-to-the-same-file"></a><span data-ttu-id="dd3d6-172">Пример. Способы задать ссылку на один и тот же файл</span><span class="sxs-lookup"><span data-stu-id="dd3d6-172">Example: Ways to refer to the same file</span></span>

<span data-ttu-id="dd3d6-173">В следующем примере демонстрируются некоторые способы задать ссылку на файл с использованием API в пространстве имен <xref:System.IO>.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-173">The following example illustrates some of the ways in which you can refer to a file when using the APIs in the <xref:System.IO> namespace.</span></span> <span data-ttu-id="dd3d6-174">В этом примере создается экземпляр объекта <xref:System.IO.FileInfo> и используются его свойства <xref:System.IO.FileInfo.Name> и <xref:System.IO.FileInfo.Length>, чтобы отобразить имя и длину файла.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-174">The example instantiates a <xref:System.IO.FileInfo> object and uses its <xref:System.IO.FileInfo.Name> and <xref:System.IO.FileInfo.Length> properties to display the filename and the length of the file.</span></span>

[!code-csharp[referring-to-the-same-file](~/samples/snippets/standard/io/file-names/cs/file-refs.cs)]
[!code-vb[referring-to-the-same-file](~/samples/snippets/standard/io/file-names/vb/file-refs.vb)]

## <a name="path-normalization"></a><span data-ttu-id="dd3d6-175">Нормализация путей</span><span class="sxs-lookup"><span data-stu-id="dd3d6-175">Path normalization</span></span>

<span data-ttu-id="dd3d6-176">Практически все передаваемые в API Windows пути нормализуются.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-176">Almost all paths passed to Windows APIs are normalized.</span></span> <span data-ttu-id="dd3d6-177">При нормализации в Windows выполняются следующие действия:</span><span class="sxs-lookup"><span data-stu-id="dd3d6-177">During normalization, Windows performs the following steps:</span></span>

- <span data-ttu-id="dd3d6-178">Идентифицируется путь.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-178">Identifies the path.</span></span>
- <span data-ttu-id="dd3d6-179">Текущий каталог применяется к неполным (относительным) путям.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-179">Applies the current directory to partially qualified (relative) paths.</span></span>
- <span data-ttu-id="dd3d6-180">Выполняется канонизация разделителей каталогов.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-180">Canonicalizes component and directory separators.</span></span>
- <span data-ttu-id="dd3d6-181">Вычисляются относительные компоненты каталога (`.` для текущего и `..` для родительского каталога).</span><span class="sxs-lookup"><span data-stu-id="dd3d6-181">Evaluates relative directory components (`.` for the current directory and `..` for the parent directory).</span></span>
- <span data-ttu-id="dd3d6-182">Удаляются некоторые символы.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-182">Trims certain characters.</span></span>

<span data-ttu-id="dd3d6-183">Нормализация осуществляется неявно, но при необходимости вы можете выполнить ее явно, вызвав метод <xref:System.IO.Path.GetFullPath%2A?displayProperty=nameWithType>, который создает оболочку для вызова [функции GetFullPathName()](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span><span class="sxs-lookup"><span data-stu-id="dd3d6-183">This normalization happens implicitly, but you can do it explicitly by calling the <xref:System.IO.Path.GetFullPath%2A?displayProperty=nameWithType> method, which wraps a call to the  [GetFullPathName() function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span></span> <span data-ttu-id="dd3d6-184">Также можно вызвать [функцию GetFullPathName()](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) Windows напрямую с помощью P/Invoke.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-184">You can also call the Windows [GetFullPathName() function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) directly using P/Invoke.</span></span>

### <a name="identifying-the-path"></a><span data-ttu-id="dd3d6-185">Идентификация пути</span><span class="sxs-lookup"><span data-stu-id="dd3d6-185">Identifying the path</span></span>

<span data-ttu-id="dd3d6-186">На первом шаге процесса нормализации осуществляется идентификация типа пути.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-186">The first step in path normalization is identifying the type of path.</span></span> <span data-ttu-id="dd3d6-187">Пути могут относиться к одной из нескольких категорий:</span><span class="sxs-lookup"><span data-stu-id="dd3d6-187">Paths fall into one of a few categories:</span></span>

- <span data-ttu-id="dd3d6-188">Пути к устройствам: начинаются с двух разделителей и знака вопроса или точки (`\\?` или `\\.`).</span><span class="sxs-lookup"><span data-stu-id="dd3d6-188">They are device paths; that is, they begin with two separators and a question mark or period (`\\?` or `\\.`).</span></span>
- <span data-ttu-id="dd3d6-189">UNC-пути: начинаются с двух разделителей без знака вопроса или точки.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-189">They are UNC paths; that is, they begin with two separators without a question mark or period.</span></span>
- <span data-ttu-id="dd3d6-190">Полные пути DOS: начинаются с буквы диска, разделителя томов и компонентов (`C:\`).</span><span class="sxs-lookup"><span data-stu-id="dd3d6-190">They are fully qualified DOS paths; that is, they begin with a drive letter, a volume separator, and a component separator (`C:\`).</span></span>
- <span data-ttu-id="dd3d6-191">Пути к устаревшим устройствам (`CON`, `LPT1`).</span><span class="sxs-lookup"><span data-stu-id="dd3d6-191">They designate a legacy device (`CON`, `LPT1`).</span></span>
- <span data-ttu-id="dd3d6-192">Пути относительно корня текущего диска: начинаются с одного разделителя компонентов (`\`).</span><span class="sxs-lookup"><span data-stu-id="dd3d6-192">They are relative to the root of the current drive; that is, they begin with a single component separator (`\`).</span></span>
- <span data-ttu-id="dd3d6-193">Пути относительно текущего каталога указанного диска: начинаются с буквы диска и разделителя томов, но не содержат разделителя компонентов (`C:`).</span><span class="sxs-lookup"><span data-stu-id="dd3d6-193">They are relative to the current directory of a specified drive; that is, they begin with a drive letter, a volume separator, and no component separator (`C:`).</span></span>
- <span data-ttu-id="dd3d6-194">Пути относительно текущего каталога: начинаются с любых других символов (`temp\testfile.txt`).</span><span class="sxs-lookup"><span data-stu-id="dd3d6-194">They are relative to the current directory; that is, they begin with anything else (`temp\testfile.txt`).</span></span>

<span data-ttu-id="dd3d6-195">Тип пути определяет, будет ли каким-либо образом применяться текущий каталог.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-195">The type of the path determines whether or not a current directory is applied in some way.</span></span> <span data-ttu-id="dd3d6-196">Кроме того, от типа пути зависит применяемый корень.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-196">It also determines what the "root" of the path is.</span></span>

### <a name="handling-legacy-devices"></a><span data-ttu-id="dd3d6-197">Работа с устаревшими устройствами</span><span class="sxs-lookup"><span data-stu-id="dd3d6-197">Handling legacy devices</span></span>

<span data-ttu-id="dd3d6-198">Если путь указывает на устаревшее устройство DOS, например `CON`, `COM1` или `LPT1`, он преобразуется в путь к устройству путем добавления перед ним последовательности `\\.\` и возвращается в таком виде.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-198">If the path is a legacy DOS device such as `CON`, `COM1`, or `LPT1`, it is converted into a device path by prepending `\\.\` and returned.</span></span>

<span data-ttu-id="dd3d6-199">Путь, который начинается с имени устаревшего устройства, всегда интерпретируется как путь к устаревшему устройству с помощью метода <xref:System.IO.Path.GetFullPath(System.String)?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-199">A path that begins with a legacy device name is always interpreted as a legacy device by the <xref:System.IO.Path.GetFullPath(System.String)?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="dd3d6-200">Например, путь к устройству DOS `CON.TXT` будет выглядеть как `\\.\CON`, а путь к устройству DOS `COM1.TXT\file1.txt` будет выглядеть как `\\.\COM1`.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-200">For example, the DOS device path for `CON.TXT` is `\\.\CON`, and the DOS device path for `COM1.TXT\file1.txt` is `\\.\COM1`.</span></span>

### <a name="applying-the-current-directory"></a><span data-ttu-id="dd3d6-201">Применение текущего каталога</span><span class="sxs-lookup"><span data-stu-id="dd3d6-201">Applying the current directory</span></span>

<span data-ttu-id="dd3d6-202">Если путь не является полным, система Windows применяет к нему текущий каталог.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-202">If a path isn't fully qualified, Windows applies the current directory to it.</span></span> <span data-ttu-id="dd3d6-203">К UNC-путям и путям к устройствам текущий каталог не применяется.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-203">UNCs and device paths do not have the current directory applied.</span></span> <span data-ttu-id="dd3d6-204">Также текущий каталог не применяется к полным путям к диску с разделителем C:\\.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-204">Neither does a full drive with separator C:\\.</span></span>

<span data-ttu-id="dd3d6-205">Если путь начинается с одного разделителя компонентов, применяется диск текущего каталога.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-205">If the path starts with a single component separator, the drive from the current directory is applied.</span></span> <span data-ttu-id="dd3d6-206">Например, для пути к файлу `\utilities` и текущего каталога `C:\temp\` в результате нормализации будет получен путь `C:\utilities`.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-206">For example, if the file path is `\utilities` and the current directory is `C:\temp\`, normalization produces `C:\utilities`.</span></span>

<span data-ttu-id="dd3d6-207">Если путь начинается с буквы диска, разделителя томов и не содержит разделителя компонентов, применяется последний текущий каталог, установленный из командной оболочки.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-207">If the path starts with a drive letter, volume separator, and no component separator, the last current directory set from the command shell for the specified drive is applied.</span></span> <span data-ttu-id="dd3d6-208">Если последний текущий каталог не был установлен, применяется диск сам по себе.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-208">If the last current directory was not set, the drive alone is applied.</span></span> <span data-ttu-id="dd3d6-209">Например, для пути `D:sources`, текущего каталога `C:\Documents\` и последнего текущего каталога `D:\sources\` на диске D: в результате будет получен путь `D:\sources\sources`.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-209">For example, if the file path is `D:sources`, the current directory is `C:\Documents\`, and the last current directory on drive D: was `D:\sources\`, the result is `D:\sources\sources`.</span></span> <span data-ttu-id="dd3d6-210">Пути, задаваемые относительно диска, являются распространенными источниками ошибок программ и логики скрипта.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-210">These "drive relative" paths are a common source of program and script logic errors.</span></span> <span data-ttu-id="dd3d6-211">Предположение, что путь, начинающийся с буквы и двоеточия, не является относительным, очевидно неверно.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-211">Assuming that a path beginning with a letter and a colon isn't relative is obviously not correct.</span></span>

<span data-ttu-id="dd3d6-212">Если путь не начинается с разделителя, применяются текущий диск и текущий каталог.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-212">If the path starts with something other than a separator, the current drive and current directory are applied.</span></span> <span data-ttu-id="dd3d6-213">Например, для пути к файлу `filecompare` и текущего каталога `C:\utilities\` в результате будет получен путь `C:\utilities\filecompare\`.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-213">For example, if the path is `filecompare` and the current directory is `C:\utilities\`, the result is `C:\utilities\filecompare\`.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="dd3d6-214">Применение относительных путей в многопотоковых приложениях (то есть в большинстве приложений) сопряжено с определенными рисками, поскольку текущий каталог задается на уровне процесса.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-214">Relative paths are dangerous in multithreaded applications (that is, most applications) because the current directory is a per-process setting.</span></span> <span data-ttu-id="dd3d6-215">Таким образом, любой поток может в любое время изменить текущий каталог.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-215">Any thread can change the current directory at any time.</span></span> <span data-ttu-id="dd3d6-216">Начиная с версии .NET Core 2.1, вы можете вызвать метод <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> для получения абсолютного пути на основе относительного и базового (текущий каталог) путей, относительно которых требуется выполнить разрешение.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-216">Starting with .NET Core 2.1, you can call the <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> method to get an absolute path from a relative path and the base path (the current directory) that you want to resolve it against.</span></span>

### <a name="canonicalizing-separators"></a><span data-ttu-id="dd3d6-217">Канонизация разделителей</span><span class="sxs-lookup"><span data-stu-id="dd3d6-217">Canonicalizing separators</span></span>

<span data-ttu-id="dd3d6-218">Все символы косой черты (`/`) преобразуются в стандартные разделители Windows, то есть символы обратной косой черты (`\`).</span><span class="sxs-lookup"><span data-stu-id="dd3d6-218">All forward slashes (`/`) are converted into the standard Windows separator, the back slash (`\`).</span></span> <span data-ttu-id="dd3d6-219">Если они присутствуют, последовательность символов косой черты после первых двух таких символов свертывается в один символ косой черты.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-219">If they are present, a series of slashes that follow the first two slashes are collapsed into a single slash.</span></span>

### <a name="evaluating-relative-components"></a><span data-ttu-id="dd3d6-220">Вычисление относительных компонентов</span><span class="sxs-lookup"><span data-stu-id="dd3d6-220">Evaluating relative components</span></span>

<span data-ttu-id="dd3d6-221">При обработке пути выполняется вычисление любых его компонентов или сегментов, которые состоят из одной или двух точек (`.` или `..`):</span><span class="sxs-lookup"><span data-stu-id="dd3d6-221">As the path is processed, any components or segments that are composed of a single or a double period (`.` or `..`) are evaluated:</span></span>

- <span data-ttu-id="dd3d6-222">Если обнаруживается одна точка, текущий сегмент удаляется, поскольку он ссылается на текущий каталог.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-222">For a single period, the current segment is removed, since it refers to the current directory.</span></span>

- <span data-ttu-id="dd3d6-223">Если обнаруживаются две точки, удаляются текущий и родительский сегмент, поскольку в этом случае задается ссылка на родительский каталог.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-223">For a double period, the current segment and the parent segment are removed, since the double period refers to the parent directory.</span></span>

   <span data-ttu-id="dd3d6-224">Родительские каталоги удаляются только в том случае, если они не находятся после корня пути.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-224">Parent directories are only removed if they aren't past the root of the path.</span></span> <span data-ttu-id="dd3d6-225">Корень пути зависит от его типа.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-225">The root of the path depends on the type of path.</span></span> <span data-ttu-id="dd3d6-226">Это будет диск (`C:\`) для путей DOS, сервер или общий сетевой ресурс для UNC-путей (`\\Server\Share`) и префикс пути к устройству для путей к устройствам (`\\?\` или `\\.\`).</span><span class="sxs-lookup"><span data-stu-id="dd3d6-226">It is the drive (`C:\`) for DOS paths, the server/share for UNCs (`\\Server\Share`), and the device path prefix for device paths (`\\?\` or `\\.\`).</span></span>

### <a name="trimming-characters"></a><span data-ttu-id="dd3d6-227">Обрезка знаков</span><span class="sxs-lookup"><span data-stu-id="dd3d6-227">Trimming characters</span></span>

<span data-ttu-id="dd3d6-228">Помимо удаленных ранее разделителей и относительных сегментов во время нормализации также удаляются некоторые дополнительные знаки:</span><span class="sxs-lookup"><span data-stu-id="dd3d6-228">Along with the runs of separators and relative segments removed earlier, some additional characters are removed during normalization:</span></span>

- <span data-ttu-id="dd3d6-229">Если сегмент заканчивается одной точкой, эта точка удаляется.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-229">If a segment ends in a single period, that period is removed.</span></span> <span data-ttu-id="dd3d6-230">(Сегмент, состоящий из одной или двух точек, нормализуется на предыдущем шаге.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-230">(A segment of a single or double period is normalized in the previous step.</span></span> <span data-ttu-id="dd3d6-231">Сегмент, состоящий из трех или более точек, не нормализуется и фактически представляет собой допустимое имя файла или каталога.)</span><span class="sxs-lookup"><span data-stu-id="dd3d6-231">A segment of three or more periods is not normalized and is actually a valid file/directory name.)</span></span>

- <span data-ttu-id="dd3d6-232">Если путь не заканчивается разделителем, удаляются все конечные точки и пробелы (U+0020).</span><span class="sxs-lookup"><span data-stu-id="dd3d6-232">If the path doesn't end in a separator, all trailing periods and spaces (U+0020) are removed.</span></span> <span data-ttu-id="dd3d6-233">Если последний сегмент содержит только одну или две точки, к нему применяется приведенное выше правило для относительных компонентов.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-233">If the last segment is simply a single or double period, it falls under the relative components rule above.</span></span>

   <span data-ttu-id="dd3d6-234">Это правило устанавливает, что вы можете создать имя каталога с конечным пробелом, добавив разделитель после пробела.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-234">This rule means that you can create a directory name with a trailing space by adding a trailing separator after the space.</span></span>

   > [!IMPORTANT]
   > <span data-ttu-id="dd3d6-235">Создавать имена каталогов или файлов с конечным пробелом **нельзя**.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-235">You should **never** create a directory or filename with a trailing space.</span></span> <span data-ttu-id="dd3d6-236">Наличие конечных пробелов может затруднить или исключить возможность доступа к каталогу. В связи с этим при попытке обработать каталоги или файлы, имена которых содержат конечные пробелы, происходит сбой приложения.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-236">Trailing spaces can make it difficult or impossible to access a directory, and applications commonly fail when attempting to handle directories or files whose names include trailing spaces.</span></span>

## <a name="skipping-normalization"></a><span data-ttu-id="dd3d6-237">Пропуск нормализации</span><span class="sxs-lookup"><span data-stu-id="dd3d6-237">Skipping normalization</span></span>

<span data-ttu-id="dd3d6-238">Как правило, любой путь, передаваемый в API Windows передается в [функцию GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) и нормализуется.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-238">Normally, any path passed to a Windows API is (effectively) passed to the [GetFullPathName function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) and normalized.</span></span> <span data-ttu-id="dd3d6-239">Существует одно важное исключение: путь к устройству, который начинается со знака вопроса, а не с точки.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-239">There is one important exception: a device path that begins with a question mark instead of a period.</span></span> <span data-ttu-id="dd3d6-240">Если путь не начинается с последовательности `\\?\` (обратите внимание на использование канонической формы с обратной косой чертой), он нормализуется.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-240">Unless the path starts exactly with `\\?\` (note the use of the canonical backslash), it is normalized.</span></span>

<span data-ttu-id="dd3d6-241">Зачем нужно пропускать нормализацию?</span><span class="sxs-lookup"><span data-stu-id="dd3d6-241">Why would you want to skip normalization?</span></span> <span data-ttu-id="dd3d6-242">Существует три основных причины:</span><span class="sxs-lookup"><span data-stu-id="dd3d6-242">There are three major reasons:</span></span>

1. <span data-ttu-id="dd3d6-243">Получение путей, которые в обычных обстоятельствах недоступны, но являются допустимыми.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-243">To get access to paths that are normally unavailable but are legal.</span></span> <span data-ttu-id="dd3d6-244">Например, невозможно каким-либо иным способом получить доступ к файлу или каталогу с именем `hidden.`.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-244">A file or directory called `hidden.`, for example, is impossible to access in any other way.</span></span>

1. <span data-ttu-id="dd3d6-245">Повышение производительности за счет пропуска нормализации в тех случаях, когда нормализация уже выполнена.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-245">To improve performance by skipping normalization if you've already normalized.</span></span>

1. <span data-ttu-id="dd3d6-246">Только на платформе .NET Framework пропуск проверки длины пути `MAX_PATH` для использования путей длиной более 259 символов.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-246">On the .NET Framework only, to skip the `MAX_PATH` check for path length to allow for paths that are greater than 259 characters.</span></span> <span data-ttu-id="dd3d6-247">Такое поведение допускается в большинстве API за некоторыми исключениями.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-247">Most APIs allow this, with some exceptions.</span></span>

> [!NOTE]
> <span data-ttu-id="dd3d6-248">.NET Core обрабатывает длинные пути неявным образом и не выполняет проверку `MAX_PATH`.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-248">.NET Core handles long paths implicitly and does not perform a `MAX_PATH` check.</span></span> <span data-ttu-id="dd3d6-249">Проверка `MAX_PATH` применяется только для платформы .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-249">The `MAX_PATH` check applies only to the .NET Framework.</span></span>

<span data-ttu-id="dd3d6-250">Пропуск нормализации и проверки максимальной длины пути является единственным отличием между двумя видами синтаксиса путей к устройствам. В остальных аспектах они идентичны.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-250">Skipping normalization and max path checks is the only difference between the two device path syntaxes; they are otherwise identical.</span></span> <span data-ttu-id="dd3d6-251">Пропуск нормализации следует использовать с осторожностью, поскольку в этом случае легко получить пути, при работе с которыми в обычных приложениях будут возникать трудности.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-251">Be careful with skipping normalization, since you can easily create paths that are difficult for "normal" applications to deal with.</span></span>

<span data-ttu-id="dd3d6-252">Пути, начинающиеся с последовательности `\\?\`, по-прежнему нормализуются, если явно передать их в [функцию GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span><span class="sxs-lookup"><span data-stu-id="dd3d6-252">Paths that start with `\\?\` are still normalized if you explicitly pass them to the [GetFullPathName function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span></span>

<span data-ttu-id="dd3d6-253">Вы можете передавать пути длиной более `MAX_PATH` символов в [функцию GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) без `\\?\`.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-253">You can pass paths of more than `MAX_PATH` characters to [GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) without `\\?\`.</span></span> <span data-ttu-id="dd3d6-254">Она поддерживает пути произвольной длины, которая ограничивается лишь максимальным размером строки, поддерживаемым в Windows.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-254">It supports arbitrary length paths up to the maximum string size that Windows can handle.</span></span>

## <a name="case-and-the-windows-file-system"></a><span data-ttu-id="dd3d6-255">Регистр символов и файловая система Windows</span><span class="sxs-lookup"><span data-stu-id="dd3d6-255">Case and the Windows file system</span></span>

<span data-ttu-id="dd3d6-256">Особенность файловой системы Windows заключается в том, что пользователи и разработчики, имеющие дело с другими операционными системами, могут сталкиваться с проблемами из-за того, что в именах каталогов и путях не учитывается регистр символов.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-256">A peculiarity of the Windows file system that non-Windows users and developers find confusing is that path and directory names are case-insensitive.</span></span> <span data-ttu-id="dd3d6-257">Это значит, что в именах каталогов и файлов сохраняется регистр строк, используемый в момент их создания.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-257">That is, directory and file names reflect the casing of the strings used when they are created.</span></span> <span data-ttu-id="dd3d6-258">Например, вызов метода</span><span class="sxs-lookup"><span data-stu-id="dd3d6-258">For example, the method call</span></span>

```csharp
Directory.Create("TeStDiReCtOrY");
```

```vb
Directory.Create("TeStDiReCtOrY")
```

<span data-ttu-id="dd3d6-259">создает каталог с именем TeStDiReCtOrY.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-259">creates a directory named TeStDiReCtOrY.</span></span> <span data-ttu-id="dd3d6-260">Если переименовать каталог или файл так, чтобы изменился регистр символов, в имени будет отражен регистр, используемый в момент переименования.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-260">If you rename a directory or file to change its case, the directory or file name reflects the case of the string used when you rename it.</span></span> <span data-ttu-id="dd3d6-261">Например, следующий код переименовывает файл test.txt в Test.txt:</span><span class="sxs-lookup"><span data-stu-id="dd3d6-261">For example, the following code renames a file named test.txt to Test.txt:</span></span>

[!code-csharp[case-and-renaming](~/samples/snippets/standard/io/file-names/cs/rename.cs)]
[!code-vb[case-and-renaming](~/samples/snippets/standard/io/file-names/vb/rename.vb)]

<span data-ttu-id="dd3d6-262">Тем не менее при сравнении имен каталогов и файлов регистр символов не учитывается.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-262">However, directory and file name comparisons are case-insensitive.</span></span> <span data-ttu-id="dd3d6-263">Если выполнить поиск файла с именем "test.txt", API файловой системы .NET будут игнорировать регистр символов при сравнении.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-263">If you search for a file named "test.txt", .NET file system APIs ignore case in the comparison.</span></span> <span data-ttu-id="dd3d6-264">Таким образом, при поиске файла "test.txt" совпадения будут возвращены для файлов Test.txt, TEST.TXT, test.TXT, а также любых других их вариантов с различным сочетанием букв в верхнем и нижнем регистре.</span><span class="sxs-lookup"><span data-stu-id="dd3d6-264">Test.txt, TEST.TXT, test.TXT, and any other combination of upper- and lowercase letters will match "test.txt".</span></span>
