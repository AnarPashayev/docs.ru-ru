---
title: Обработка ошибок ввода-вывода в .NET
description: Узнайте, как обрабатывать ошибки ввода-вывода в .NET. Сопоставляйте коды ошибок с исключениями, обрабатывайте исключения в операциях ввода-вывода и обрабатывайте IOException.
ms.date: 08/27/2018
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- I/O, exception handling
- I/O, errors
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: bd7112b3052f246a01e4a36d6d425b37cb6174dd
ms.sourcegitcommit: 7588b1f16b7608bc6833c05f91ae670c22ef56f8
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/02/2020
ms.locfileid: "93188046"
---
# <a name="handling-io-errors-in-net"></a><span data-ttu-id="689dc-104">Обработка ошибок ввода-вывода в .NET</span><span class="sxs-lookup"><span data-stu-id="689dc-104">Handling I/O errors in .NET</span></span>

<span data-ttu-id="689dc-105">Помимо тех исключений, которые могут быть созданы в любом вызове метода (например, <xref:System.OutOfMemoryException> при высокой нагрузке на систему или <xref:System.NullReferenceException> при ошибке в программе), методы файловой системы .NET могут создавать следующие исключения:</span><span class="sxs-lookup"><span data-stu-id="689dc-105">In addition to the exceptions that can be thrown in any method call (such as an <xref:System.OutOfMemoryException> when a system is stressed or an <xref:System.NullReferenceException> due to programmer error), .NET file system methods can throw the following exceptions:</span></span>

- <span data-ttu-id="689dc-106"><xref:System.IO.IOException?displayProperty=nameWithType> — служит базовым классом для всех типов исключений <xref:System.IO>.</span><span class="sxs-lookup"><span data-stu-id="689dc-106"><xref:System.IO.IOException?displayProperty=nameWithType>, the base class of all <xref:System.IO> exception types.</span></span> <span data-ttu-id="689dc-107">Это исключение создается для ошибок, у которых код возврата из операционной системы не сопоставляется напрямую с другим типом исключения.</span><span class="sxs-lookup"><span data-stu-id="689dc-107">It is thrown for errors whose return codes from the operating system don't directly map to any other exception type.</span></span>
- <span data-ttu-id="689dc-108"><xref:System.IO.FileNotFoundException?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="689dc-108"><xref:System.IO.FileNotFoundException?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="689dc-109"><xref:System.IO.DirectoryNotFoundException?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="689dc-109"><xref:System.IO.DirectoryNotFoundException?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="689dc-110"><xref:System.IO.DriveNotFoundException??displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="689dc-110"><xref:System.IO.DriveNotFoundException??displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="689dc-111"><xref:System.IO.PathTooLongException?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="689dc-111"><xref:System.IO.PathTooLongException?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="689dc-112"><xref:System.OperationCanceledException?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="689dc-112"><xref:System.OperationCanceledException?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="689dc-113"><xref:System.UnauthorizedAccessException?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="689dc-113"><xref:System.UnauthorizedAccessException?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="689dc-114"><xref:System.ArgumentException?displayProperty=nameWithType> — создается для недопустимых символов пути на платформе .NET Framework, а также .NET Core 2.0 и предыдущих версиях.</span><span class="sxs-lookup"><span data-stu-id="689dc-114"><xref:System.ArgumentException?displayProperty=nameWithType>, which is thrown for invalid path characters on .NET Framework and on .NET Core 2.0 and previous versions.</span></span>
- <span data-ttu-id="689dc-115"><xref:System.NotSupportedException?displayProperty=nameWithType> — создается для недопустимых двоеточий в .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="689dc-115"><xref:System.NotSupportedException?displayProperty=nameWithType>, which is thrown for invalid colons in .NET Framework.</span></span>
- <span data-ttu-id="689dc-116"><xref:System.Security.SecurityException?displayProperty=nameWithType> — создается для приложений в частичном доверии, которые не имеют необходимых разрешений (только на платформе .NET Framework).</span><span class="sxs-lookup"><span data-stu-id="689dc-116"><xref:System.Security.SecurityException?displayProperty=nameWithType>, which is thrown for applications running in limited trust that lack the necessary permissions on .NET Framework only.</span></span> <span data-ttu-id="689dc-117">На платформе .NET Framework по умолчанию используется полное доверие.</span><span class="sxs-lookup"><span data-stu-id="689dc-117">(Full trust is the default on .NET Framework.)</span></span>

## <a name="mapping-error-codes-to-exceptions"></a><span data-ttu-id="689dc-118">Сопоставление кодов ошибок с исключениями</span><span class="sxs-lookup"><span data-stu-id="689dc-118">Mapping error codes to exceptions</span></span>

<span data-ttu-id="689dc-119">Так как файловая система представляет собой ресурс операционной системы, методы ввода-вывода в .NET Core и .NET Framework служат оболочками для соответствующих вызовов операционной системы.</span><span class="sxs-lookup"><span data-stu-id="689dc-119">Because the file system is an operating system resource, I/O methods in both .NET Core and .NET Framework wrap calls to the underlying operating system.</span></span> <span data-ttu-id="689dc-120">Если в коде, выполняемом операционной системой, возникает ошибка ввода-вывода, операционная система возвращает сведения об ошибке в метод ввода-вывода .NET.</span><span class="sxs-lookup"><span data-stu-id="689dc-120">When an I/O error occurs in code executed by the operating system, the operating system returns error information to the .NET I/O method.</span></span> <span data-ttu-id="689dc-121">Затем этот метод преобразует сведения об ошибке, обычно представленные кодом ошибки, в соответствующий тип исключения .NET.</span><span class="sxs-lookup"><span data-stu-id="689dc-121">The method then translates the error information, typically in the form of an error code, into a .NET exception type.</span></span> <span data-ttu-id="689dc-122">В большинстве случаев код ошибки напрямую определяет нужный тип исключения. Метод не выполняет никакой дополнительной обработки в соответствии с контекстом вызова метода.</span><span class="sxs-lookup"><span data-stu-id="689dc-122">In most cases, it does this by directly translating the error code into its corresponding exception type; it does not perform any special mapping of the error based on the context of the method call.</span></span>

<span data-ttu-id="689dc-123">Например, при вызове метода в операционной системе Windows код ошибки `ERROR_FILE_NOT_FOUND` (или 0x02) преобразуется в исключение <xref:System.IO.FileNotFoundException>, а код ошибки `ERROR_PATH_NOT_FOUND` (или 0x03) — в <xref:System.IO.DirectoryNotFoundException>.</span><span class="sxs-lookup"><span data-stu-id="689dc-123">For example, on the Windows operating system, a method call that returns an error code of `ERROR_FILE_NOT_FOUND` (or 0x02) maps to a <xref:System.IO.FileNotFoundException>, and an error code of `ERROR_PATH_NOT_FOUND` (or 0x03) maps to a <xref:System.IO.DirectoryNotFoundException>.</span></span>

<span data-ttu-id="689dc-124">К сожалению, точные условия возникновения определенных кодов ошибок в операционной системе часто не документируются или документируются в недостаточном объеме.</span><span class="sxs-lookup"><span data-stu-id="689dc-124">However, the precise conditions under which the operating system returns particular error codes is often undocumented or poorly documented.</span></span> <span data-ttu-id="689dc-125">Это означает, что возможны непредвиденные исключения.</span><span class="sxs-lookup"><span data-stu-id="689dc-125">As a result, unexpected exceptions can occur.</span></span> <span data-ttu-id="689dc-126">Например, при работе с каталогом логично ожидать, что передача недопустимого пути в конструктор <xref:System.IO.DirectoryInfo.%23ctor%2A> приведет к созданию исключения <xref:System.IO.DirectoryNotFoundException>.</span><span class="sxs-lookup"><span data-stu-id="689dc-126">For example, because you are working with a directory rather than a file, you would expect that providing an invalid directory path to the <xref:System.IO.DirectoryInfo.%23ctor%2A> constructor throws a <xref:System.IO.DirectoryNotFoundException>.</span></span> <span data-ttu-id="689dc-127">Но в этой ситуации может создаваться и <xref:System.IO.FileNotFoundException>.</span><span class="sxs-lookup"><span data-stu-id="689dc-127">However, it may also throw a <xref:System.IO.FileNotFoundException>.</span></span>

## <a name="exception-handling-in-io-operations"></a><span data-ttu-id="689dc-128">Обработка исключений при операциях ввода-вывода</span><span class="sxs-lookup"><span data-stu-id="689dc-128">Exception handling in I/O operations</span></span>

<span data-ttu-id="689dc-129">По причине зависимости от операционной системы иногда идентичные условия (например, отсутствие указанного каталога) могут создавать в методах ввода-вывода любое исключение из класса ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="689dc-129">Because of this reliance on the operating system, identical exception conditions (such as the directory not found error in our example) can result in an I/O method throwing any one of the entire class of I/O exceptions.</span></span> <span data-ttu-id="689dc-130">Это означает, что при вызове интерфейсов API ввода-вывода ваш код должн быть готов обработать все такие исключения или большую их часть, как показано в следующей таблице:</span><span class="sxs-lookup"><span data-stu-id="689dc-130">This means that, when calling I/O APIs, your code should be prepared to handle most or all of these exceptions, as shown in the following table:</span></span>

| <span data-ttu-id="689dc-131">Тип исключения</span><span class="sxs-lookup"><span data-stu-id="689dc-131">Exception type</span></span> | <span data-ttu-id="689dc-132">.NET Core и .NET 5 или более поздней версии</span><span class="sxs-lookup"><span data-stu-id="689dc-132">.NET Core/.NET 5+</span></span> | <span data-ttu-id="689dc-133">.NET Framework</span><span class="sxs-lookup"><span data-stu-id="689dc-133">.NET Framework</span></span> |
|---|---|---|
| <xref:System.IO.IOException> | <span data-ttu-id="689dc-134">Да</span><span class="sxs-lookup"><span data-stu-id="689dc-134">Yes</span></span> | <span data-ttu-id="689dc-135">Да</span><span class="sxs-lookup"><span data-stu-id="689dc-135">Yes</span></span> |
| <xref:System.IO.FileNotFoundException> | <span data-ttu-id="689dc-136">Да</span><span class="sxs-lookup"><span data-stu-id="689dc-136">Yes</span></span> | <span data-ttu-id="689dc-137">Да</span><span class="sxs-lookup"><span data-stu-id="689dc-137">Yes</span></span> |
| <xref:System.IO.DirectoryNotFoundException> | <span data-ttu-id="689dc-138">Да</span><span class="sxs-lookup"><span data-stu-id="689dc-138">Yes</span></span> | <span data-ttu-id="689dc-139">Да</span><span class="sxs-lookup"><span data-stu-id="689dc-139">Yes</span></span> |
| <xref:System.IO.DriveNotFoundException?> | <span data-ttu-id="689dc-140">Да</span><span class="sxs-lookup"><span data-stu-id="689dc-140">Yes</span></span> | <span data-ttu-id="689dc-141">Да</span><span class="sxs-lookup"><span data-stu-id="689dc-141">Yes</span></span> |
| <xref:System.IO.PathTooLongException> | <span data-ttu-id="689dc-142">Да</span><span class="sxs-lookup"><span data-stu-id="689dc-142">Yes</span></span> | <span data-ttu-id="689dc-143">Да</span><span class="sxs-lookup"><span data-stu-id="689dc-143">Yes</span></span> |
| <xref:System.OperationCanceledException> | <span data-ttu-id="689dc-144">Да</span><span class="sxs-lookup"><span data-stu-id="689dc-144">Yes</span></span> | <span data-ttu-id="689dc-145">Да</span><span class="sxs-lookup"><span data-stu-id="689dc-145">Yes</span></span> |
| <xref:System.UnauthorizedAccessException> | <span data-ttu-id="689dc-146">Да</span><span class="sxs-lookup"><span data-stu-id="689dc-146">Yes</span></span> | <span data-ttu-id="689dc-147">Да</span><span class="sxs-lookup"><span data-stu-id="689dc-147">Yes</span></span> |
| <xref:System.ArgumentException> | <span data-ttu-id="689dc-148">.NET Core 2.0 или более ранняя версия</span><span class="sxs-lookup"><span data-stu-id="689dc-148">.NET Core 2.0 and earlier</span></span>| <span data-ttu-id="689dc-149">Да</span><span class="sxs-lookup"><span data-stu-id="689dc-149">Yes</span></span> |
| <xref:System.NotSupportedException> | <span data-ttu-id="689dc-150">Нет</span><span class="sxs-lookup"><span data-stu-id="689dc-150">No</span></span> | <span data-ttu-id="689dc-151">Да</span><span class="sxs-lookup"><span data-stu-id="689dc-151">Yes</span></span> |
| <xref:System.Security.SecurityException> | <span data-ttu-id="689dc-152">Нет</span><span class="sxs-lookup"><span data-stu-id="689dc-152">No</span></span> | <span data-ttu-id="689dc-153">Только для ограниченного доверия</span><span class="sxs-lookup"><span data-stu-id="689dc-153">Limited trust only</span></span> |

## <a name="handling-ioexception"></a><span data-ttu-id="689dc-154">Обработка IOException</span><span class="sxs-lookup"><span data-stu-id="689dc-154">Handling IOException</span></span>

<span data-ttu-id="689dc-155"><xref:System.IO.IOException> является базовым классом для исключений в пространстве имен <xref:System.IO> и создается для любого кода ошибки, который не имеет сопоставления с определенным типом исключения.</span><span class="sxs-lookup"><span data-stu-id="689dc-155">As the base class for exceptions in the <xref:System.IO> namespace, <xref:System.IO.IOException> is also thrown for any error code that does not map to a predefined exception type.</span></span> <span data-ttu-id="689dc-156">Это означает, что оно может появиться в любой операции ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="689dc-156">This means that it can be thrown by any I/O operation.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="689dc-157">Так как <xref:System.IO.IOException> является базовым классом для других типов исключений в пространстве имен <xref:System.IO>, его нужно обрабатывать в блоке `catch` после обработки других исключений, связанных с вводом-выводом.</span><span class="sxs-lookup"><span data-stu-id="689dc-157">Because <xref:System.IO.IOException> is the base class of the other exception types in the <xref:System.IO> namespace, you should handle in a `catch` block after you've handled the other I/O-related exceptions.</span></span>

<span data-ttu-id="689dc-158">Кроме того, в версии .NET Core 2.1 не применяется проверка правильности пути (например, отсутствия недопустимых символов в пути), и теперь среда выполнения создает исключение, сопоставленное с кодом ошибки операционной системы, а не результат проверки в собственном коде.</span><span class="sxs-lookup"><span data-stu-id="689dc-158">In addition, starting with .NET Core 2.1, validation checks for path correctness (for example, to ensure that invalid characters are not present in a path) have been removed, and the runtime throws an exception mapped from an operating system error code rather than from its own validation code.</span></span> <span data-ttu-id="689dc-159">В такой ситуации чаще всего создается исключение <xref:System.IO.IOException>, но вы можете столкнуться с любым другим типом исключений.</span><span class="sxs-lookup"><span data-stu-id="689dc-159">The most likely exception to be thrown in this case is an <xref:System.IO.IOException>, although any other exception type could also be thrown.</span></span>

<span data-ttu-id="689dc-160">Обратите внимание, что в коде обработки исключений <xref:System.IO.IOException> всегда нужно обрабатывать последним.</span><span class="sxs-lookup"><span data-stu-id="689dc-160">Note that, in your exception handling code, you should always handle the <xref:System.IO.IOException> last.</span></span> <span data-ttu-id="689dc-161">Иначе блоки catch для производных классов не проверяются, ведь это исключение является базовым классом для всех остальных.</span><span class="sxs-lookup"><span data-stu-id="689dc-161">Otherwise, because it is the base class of all other IO exceptions, the catch blocks of derived classes will not be evaluated.</span></span>

<span data-ttu-id="689dc-162">В случае с <xref:System.IO.IOException> дополнительные сведения об ошибке можно получить из свойства [IOException.HResult](xref:System.Exception.HResult).</span><span class="sxs-lookup"><span data-stu-id="689dc-162">In the case of an <xref:System.IO.IOException>, you can get additional error information from the [IOException.HResult](xref:System.Exception.HResult) property.</span></span> <span data-ttu-id="689dc-163">Чтобы преобразовать значение HResult в код ошибки Win32, отбросьте верхние 16 бит из 32-разрядного значения.</span><span class="sxs-lookup"><span data-stu-id="689dc-163">To convert the HResult value to a Win32 error code, you strip out the upper 16 bits of the 32-bit value.</span></span> <span data-ttu-id="689dc-164">В приведенной ниже таблице перечислены коды ошибок, которые могут быть заключены в <xref:System.IO.IOException>.</span><span class="sxs-lookup"><span data-stu-id="689dc-164">The following table lists error codes that may be wrapped in an <xref:System.IO.IOException>.</span></span>

| <span data-ttu-id="689dc-165">HResult</span><span class="sxs-lookup"><span data-stu-id="689dc-165">HResult</span></span> | <span data-ttu-id="689dc-166">Константа</span><span class="sxs-lookup"><span data-stu-id="689dc-166">Constant</span></span> | <span data-ttu-id="689dc-167">Описание</span><span class="sxs-lookup"><span data-stu-id="689dc-167">Description</span></span> |
| --- | --- | --- |
| <span data-ttu-id="689dc-168">ERROR_SHARING_VIOLATION</span><span class="sxs-lookup"><span data-stu-id="689dc-168">ERROR_SHARING_VIOLATION</span></span> | <span data-ttu-id="689dc-169">32</span><span class="sxs-lookup"><span data-stu-id="689dc-169">32</span></span> | <span data-ttu-id="689dc-170">Отсутствует имя файла, или файл или каталог уже используется.</span><span class="sxs-lookup"><span data-stu-id="689dc-170">The file name is missing, or the file or directory is in use.</span></span> |
| <span data-ttu-id="689dc-171">ERROR_FILE_EXISTS</span><span class="sxs-lookup"><span data-stu-id="689dc-171">ERROR_FILE_EXISTS</span></span> | <span data-ttu-id="689dc-172">80</span><span class="sxs-lookup"><span data-stu-id="689dc-172">80</span></span> | <span data-ttu-id="689dc-173">Файл уже существует.</span><span class="sxs-lookup"><span data-stu-id="689dc-173">The file already exists.</span></span> |
| <span data-ttu-id="689dc-174">ERROR_INVALID_PARAMETER</span><span class="sxs-lookup"><span data-stu-id="689dc-174">ERROR_INVALID_PARAMETER</span></span> | <span data-ttu-id="689dc-175">87</span><span class="sxs-lookup"><span data-stu-id="689dc-175">87</span></span> | <span data-ttu-id="689dc-176">Методу передан недопустимый аргумент.</span><span class="sxs-lookup"><span data-stu-id="689dc-176">An argument supplied to the method is invalid.</span></span> |
| <span data-ttu-id="689dc-177">ERROR_ALREADY_EXISTS</span><span class="sxs-lookup"><span data-stu-id="689dc-177">ERROR_ALREADY_EXISTS</span></span> | <span data-ttu-id="689dc-178">183</span><span class="sxs-lookup"><span data-stu-id="689dc-178">183</span></span> | <span data-ttu-id="689dc-179">Файл или каталог уже существует.</span><span class="sxs-lookup"><span data-stu-id="689dc-179">The file or directory already exists.</span></span> |

<span data-ttu-id="689dc-180">Для обработки этих исключений можно применить предложение `When` в инструкции catch, как показано в приведенном ниже примере.</span><span class="sxs-lookup"><span data-stu-id="689dc-180">You can handle these using a `When` clause in a catch statement, as the following example shows.</span></span>

[!code-csharp[io-exception-handling](~/samples/snippets/standard/io/io-exceptions/cs/io-exceptions.cs)]
[!code-vb[io-exception-handling](~/samples/snippets/standard/io/io-exceptions/vb/io-exceptions.vb)]

## <a name="see-also"></a><span data-ttu-id="689dc-181">См. также</span><span class="sxs-lookup"><span data-stu-id="689dc-181">See also</span></span>

- [<span data-ttu-id="689dc-182">Обработка и создание исключений в .NET</span><span class="sxs-lookup"><span data-stu-id="689dc-182">Handling and throwing exceptions in .NET</span></span>](../exceptions/index.md)
- [<span data-ttu-id="689dc-183">Обработка исключений (библиотека параллельных задач)</span><span class="sxs-lookup"><span data-stu-id="689dc-183">Exception handling (Task Parallel Library)</span></span>](../parallel-programming/exception-handling-task-parallel-library.md)
- [<span data-ttu-id="689dc-184">Лучшие методики обработки исключений</span><span class="sxs-lookup"><span data-stu-id="689dc-184">Best practices for exceptions</span></span>](../exceptions/best-practices-for-exceptions.md)
- [<span data-ttu-id="689dc-185">Практическое руководство. Использование определенных исключений в блоке catch</span><span class="sxs-lookup"><span data-stu-id="689dc-185">How to use specific exceptions in a catch block</span></span>](../exceptions/how-to-use-specific-exceptions-in-a-catch-block.md)
