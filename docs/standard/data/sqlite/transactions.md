---
title: Транзакции
ms.date: 09/08/2020
description: Узнайте, как использовать транзакции.
ms.openlocfilehash: 50c4cd1023eac892cafc3ae4395e9168bd8e9f36
ms.sourcegitcommit: aa6d8a90a4f5d8fe0f6e967980b8c98433f05a44
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/16/2020
ms.locfileid: "90678866"
---
# <a name="transactions"></a><span data-ttu-id="6bf20-103">Транзакции</span><span class="sxs-lookup"><span data-stu-id="6bf20-103">Transactions</span></span>

<span data-ttu-id="6bf20-104">Транзакции позволяют сгруппировать несколько инструкций SQL в одну единицу работы, которая фиксируется в базе данных как одна атомарная единица.</span><span class="sxs-lookup"><span data-stu-id="6bf20-104">Transactions let you group multiple SQL statements into a single unit of work that is committed to the database as one atomic unit.</span></span> <span data-ttu-id="6bf20-105">При сбое любой инструкции в транзакции можно выполнить откат изменений, выполненных предыдущими инструкциями.</span><span class="sxs-lookup"><span data-stu-id="6bf20-105">If any statement in the transaction fails, changes made by the previous statements can be rolled back.</span></span> <span data-ttu-id="6bf20-106">Начальное состояние базы данных сохраняется при запуске транзакции.</span><span class="sxs-lookup"><span data-stu-id="6bf20-106">The initial state of the database when the transaction was started is preserved.</span></span> <span data-ttu-id="6bf20-107">Использование транзакций может также повысить производительность SQLite при одновременном внесении многочисленных изменений в базу данных.</span><span class="sxs-lookup"><span data-stu-id="6bf20-107">Using a transaction can also improve performance on SQLite when making numerous changes to the database at once.</span></span>

## <a name="concurrency"></a><span data-ttu-id="6bf20-108">параллелизм</span><span class="sxs-lookup"><span data-stu-id="6bf20-108">Concurrency</span></span>

<span data-ttu-id="6bf20-109">В SQLite только одна транзакция может иметь изменения, ожидающие внесения в базе данных, в любой конкретный момент времени.</span><span class="sxs-lookup"><span data-stu-id="6bf20-109">In SQLite, only one transaction is allowed to have changes pending in the database at a time.</span></span> <span data-ttu-id="6bf20-110">В связи с этим время ожидания вызовов <xref:Microsoft.Data.Sqlite.SqliteConnection.BeginTransaction%2A> и методов `Execute` в <xref:Microsoft.Data.Sqlite.SqliteCommand> может истечь, если другая транзакция занимает слишком много времени.</span><span class="sxs-lookup"><span data-stu-id="6bf20-110">Because of this, calls to <xref:Microsoft.Data.Sqlite.SqliteConnection.BeginTransaction%2A> and the `Execute` methods on <xref:Microsoft.Data.Sqlite.SqliteCommand> may time out if another transaction takes too long to complete.</span></span>

<span data-ttu-id="6bf20-111">Дополнительные сведения о блокировках, повторных попытках и времени ожидания см. в разделе [Ошибки базы данных](database-errors.md).</span><span class="sxs-lookup"><span data-stu-id="6bf20-111">For more information about locking, retries, and timeouts, see [Database errors](database-errors.md).</span></span>

## <a name="isolation-levels"></a><span data-ttu-id="6bf20-112">Уровни изоляции</span><span class="sxs-lookup"><span data-stu-id="6bf20-112">Isolation levels</span></span>

<span data-ttu-id="6bf20-113">Транзакции **сериализуемы** по умолчанию в SQLite.</span><span class="sxs-lookup"><span data-stu-id="6bf20-113">Transactions are **serializable** by default in SQLite.</span></span> <span data-ttu-id="6bf20-114">Этот уровень изоляции гарантирует, что любые изменения, внесенные в транзакцию, будут полностью изолированы.</span><span class="sxs-lookup"><span data-stu-id="6bf20-114">This isolation level guarantees that any changes made within a transaction are completely isolated.</span></span> <span data-ttu-id="6bf20-115">Изменения транзакции не затрагивают другие инструкции, выполняемые за пределами транзакции.</span><span class="sxs-lookup"><span data-stu-id="6bf20-115">Other statements executed outside of the transaction aren't affected by the transaction's changes.</span></span>

<span data-ttu-id="6bf20-116">SQLite также поддерживает **чтение незафиксированных изменений** при использовании общего кэша.</span><span class="sxs-lookup"><span data-stu-id="6bf20-116">SQLite also supports **read uncommitted** when using a shared cache.</span></span> <span data-ttu-id="6bf20-117">Этот уровень допускает "грязные" и неповторяемые операции чтения, а также фантомы:</span><span class="sxs-lookup"><span data-stu-id="6bf20-117">This level allows dirty reads, nonrepeatable reads, and phantoms:</span></span>

- <span data-ttu-id="6bf20-118">*"Грязное" чтение* происходит, когда изменения, ожидающие в одной транзакции, возвращаются запросом вне этой транзакции, но при этом изменения в транзакции откатываются.</span><span class="sxs-lookup"><span data-stu-id="6bf20-118">A *dirty read* occurs when changes pending in one transaction are returned by a query outside of the transaction, but the changes in the transaction are rolled back.</span></span> <span data-ttu-id="6bf20-119">Результаты содержат данные, которые никогда не фиксировались в базе данных.</span><span class="sxs-lookup"><span data-stu-id="6bf20-119">The results contain data that was never actually committed to the database.</span></span>

- <span data-ttu-id="6bf20-120">*Неповторяемое чтение* возникает, когда транзакция запрашивает одну и ту же строку дважды, но результаты различаются, так как они были изменены другой транзакцией между этими запросами.</span><span class="sxs-lookup"><span data-stu-id="6bf20-120">A *nonrepeatable read* occurs when a transaction queries same row twice, but the results are different because it was changed between the two queries by another transaction.</span></span>

- <span data-ttu-id="6bf20-121">*Фантомы* — это строки, которые изменяются или добавляются для соответствия предложению запроса where во время транзакции.</span><span class="sxs-lookup"><span data-stu-id="6bf20-121">*Phantoms* are rows that get changed or added to meet the where clause of a query during a transaction.</span></span> <span data-ttu-id="6bf20-122">Если они разрешены, один и тот же запрос может возвращать разные строки при двукратном выполнении в одной транзакции.</span><span class="sxs-lookup"><span data-stu-id="6bf20-122">If allowed, the same query could return different rows when executed twice in the same transaction.</span></span>

<span data-ttu-id="6bf20-123">Microsoft.Data.Sqlit рассматривает IsolationLevel, переданные в <xref:Microsoft.Data.Sqlite.SqliteConnection.BeginTransaction%2A> как минимальный уровень.</span><span class="sxs-lookup"><span data-stu-id="6bf20-123">Microsoft.Data.Sqlite treats the IsolationLevel passed to <xref:Microsoft.Data.Sqlite.SqliteConnection.BeginTransaction%2A> as a minimum level.</span></span> <span data-ttu-id="6bf20-124">Фактический уровень изоляции будет повышен до уровня чтения незафиксированных изменений или сериализуемого.</span><span class="sxs-lookup"><span data-stu-id="6bf20-124">The actual isolation level will be promoted to either read uncommitted or serializable.</span></span>

<span data-ttu-id="6bf20-125">Следующий код имитирует "грязное" чтение.</span><span class="sxs-lookup"><span data-stu-id="6bf20-125">The following code simulates a dirty read.</span></span> <span data-ttu-id="6bf20-126">Обратите внимание, что строка подключения должна включать `Cache=Shared`.</span><span class="sxs-lookup"><span data-stu-id="6bf20-126">Note, the connection string must include `Cache=Shared`.</span></span>

[!code-csharp[](../../../../samples/snippets/standard/data/sqlite/DirtyReadSample/Program.cs?name=snippet_DirtyRead)]

## <a name="deferred-transactions"></a><span data-ttu-id="6bf20-127">Отложенные транзакции</span><span class="sxs-lookup"><span data-stu-id="6bf20-127">Deferred transactions</span></span>

<span data-ttu-id="6bf20-128">Начиная с Microsoft.Data.Sqlite версии 5.0 транзакции можно откладывать.</span><span class="sxs-lookup"><span data-stu-id="6bf20-128">Starting with Microsoft.Data.Sqlite version 5.0, transactions can be deferred.</span></span> <span data-ttu-id="6bf20-129">В этом случае создание фактической транзакции в базе данных откладывается до выполнения первой команды.</span><span class="sxs-lookup"><span data-stu-id="6bf20-129">This defers the creation of the actual transaction in the database until the first command is executed.</span></span> <span data-ttu-id="6bf20-130">Кроме того, транзакция постепенно обновляется с транзакции чтения на транзакцию записи, как это требуется командам.</span><span class="sxs-lookup"><span data-stu-id="6bf20-130">It also causes the transaction to gradually upgrade from a read transaction to a write transaction as needed by its commands.</span></span> <span data-ttu-id="6bf20-131">Это может быть полезно для включения одновременного доступа к базе данных во время транзакции.</span><span class="sxs-lookup"><span data-stu-id="6bf20-131">This can be useful for enabling concurrent access to the database during the transaction.</span></span>

[!code-csharp[](../../../../samples/snippets/standard/data/sqlite/DeferredTransactionSample/Program.cs?name=snippet_DeferredTransaction)]

> [!WARNING]
> <span data-ttu-id="6bf20-132">Выполнение команд в отложенной транзакции может завершиться ошибкой, если они приводят к обновлению транзакции с транзакции чтения на транзакцию записи во время блокировки базы данных.</span><span class="sxs-lookup"><span data-stu-id="6bf20-132">Commands inside a deferred transaction can fail if they cause the transaction to be upgraded from a read transaction to a write transaction while the database is locked.</span></span> <span data-ttu-id="6bf20-133">В этом случае приложению потребуется повторить всю транзакцию.</span><span class="sxs-lookup"><span data-stu-id="6bf20-133">When this happens, the application will need to retry the entire transaction.</span></span>
