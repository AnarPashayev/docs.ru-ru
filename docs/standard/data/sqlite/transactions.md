---
title: Транзакции
ms.date: 09/08/2020
description: Узнайте, как использовать транзакции.
ms.openlocfilehash: 50c4cd1023eac892cafc3ae4395e9168bd8e9f36
ms.sourcegitcommit: aa6d8a90a4f5d8fe0f6e967980b8c98433f05a44
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/16/2020
ms.locfileid: "90678866"
---
# <a name="transactions"></a>Транзакции

Транзакции позволяют сгруппировать несколько инструкций SQL в одну единицу работы, которая фиксируется в базе данных как одна атомарная единица. При сбое любой инструкции в транзакции можно выполнить откат изменений, выполненных предыдущими инструкциями. Начальное состояние базы данных сохраняется при запуске транзакции. Использование транзакций может также повысить производительность SQLite при одновременном внесении многочисленных изменений в базу данных.

## <a name="concurrency"></a>параллелизм

В SQLite только одна транзакция может иметь изменения, ожидающие внесения в базе данных, в любой конкретный момент времени. В связи с этим время ожидания вызовов <xref:Microsoft.Data.Sqlite.SqliteConnection.BeginTransaction%2A> и методов `Execute` в <xref:Microsoft.Data.Sqlite.SqliteCommand> может истечь, если другая транзакция занимает слишком много времени.

Дополнительные сведения о блокировках, повторных попытках и времени ожидания см. в разделе [Ошибки базы данных](database-errors.md).

## <a name="isolation-levels"></a>Уровни изоляции

Транзакции **сериализуемы** по умолчанию в SQLite. Этот уровень изоляции гарантирует, что любые изменения, внесенные в транзакцию, будут полностью изолированы. Изменения транзакции не затрагивают другие инструкции, выполняемые за пределами транзакции.

SQLite также поддерживает **чтение незафиксированных изменений** при использовании общего кэша. Этот уровень допускает "грязные" и неповторяемые операции чтения, а также фантомы:

- *"Грязное" чтение* происходит, когда изменения, ожидающие в одной транзакции, возвращаются запросом вне этой транзакции, но при этом изменения в транзакции откатываются. Результаты содержат данные, которые никогда не фиксировались в базе данных.

- *Неповторяемое чтение* возникает, когда транзакция запрашивает одну и ту же строку дважды, но результаты различаются, так как они были изменены другой транзакцией между этими запросами.

- *Фантомы* — это строки, которые изменяются или добавляются для соответствия предложению запроса where во время транзакции. Если они разрешены, один и тот же запрос может возвращать разные строки при двукратном выполнении в одной транзакции.

Microsoft.Data.Sqlit рассматривает IsolationLevel, переданные в <xref:Microsoft.Data.Sqlite.SqliteConnection.BeginTransaction%2A> как минимальный уровень. Фактический уровень изоляции будет повышен до уровня чтения незафиксированных изменений или сериализуемого.

Следующий код имитирует "грязное" чтение. Обратите внимание, что строка подключения должна включать `Cache=Shared`.

[!code-csharp[](../../../../samples/snippets/standard/data/sqlite/DirtyReadSample/Program.cs?name=snippet_DirtyRead)]

## <a name="deferred-transactions"></a>Отложенные транзакции

Начиная с Microsoft.Data.Sqlite версии 5.0 транзакции можно откладывать. В этом случае создание фактической транзакции в базе данных откладывается до выполнения первой команды. Кроме того, транзакция постепенно обновляется с транзакции чтения на транзакцию записи, как это требуется командам. Это может быть полезно для включения одновременного доступа к базе данных во время транзакции.

[!code-csharp[](../../../../samples/snippets/standard/data/sqlite/DeferredTransactionSample/Program.cs?name=snippet_DeferredTransaction)]

> [!WARNING]
> Выполнение команд в отложенной транзакции может завершиться ошибкой, если они приводят к обновлению транзакции с транзакции чтения на транзакцию записи во время блокировки базы данных. В этом случае приложению потребуется повторить всю транзакцию.
