---
title: Рекомендации по использованию взаимодействия на уровне машинного кода для .NET
description: Ознакомьтесь с рекомендациями по взаимодействию с компонентами на уровне машинного кода в .NET.
ms.date: 01/18/2019
ms.openlocfilehash: 9486256b815856c0c283f5fe231be3d35d6e8f00
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2020
ms.locfileid: "76742748"
---
# <a name="native-interoperability-best-practices"></a>Рекомендации по использованию взаимодействия на уровне машинного кода

Платформа .NET предоставляет несколько способов настройки машинного кода для взаимодействия. В этой статье приводятся рекомендации для команд .NET-разработчиков, которые сталкиваются с проблемами взаимодействия на уровне машинного кода.

## <a name="general-guidance"></a>Общие рекомендации

Рекомендации в этом разделе относятся ко всем сценариям взаимодействия.

- ✔️ использовать одинаковые имена и регистр для методов и параметров в качестве собственного метода, который требуется вызвать.
- ✔️ Рассмотрите возможность использования одинаковых имен и регистров для постоянных значений.
- ✔️ использовать типы .NET, которые соответствуют ближайшим типам машинного кода. Например, если собственный тип в C# — `unsigned int`, используйте `uint`.
- ✔️ использовать только атрибуты `[In]` и `[Out]`, если нужное поведение отличается от поведения по умолчанию.
- ✔️ Рассмотрите возможность использования <xref:System.Buffers.ArrayPool%601?displayProperty=nameWithType> для объединения собственных буферов массива.
- ✔️ РЕКОМЕНДУЕТСЯ обернуть объявления P/Invoke в класс с тем же именем и регистром, что и в собственной библиотеке.
  - Это позволяет использовать возможность языка C# `nameof` для атрибутов `[DllImport]`, чтобы передать имя собственной библиотеки и проверить правильность его написания.

## <a name="dllimport-attribute-settings"></a>Параметры атрибута DllImport

| Параметр | Default | Рекомендация | Подробности |
|---------|---------|----------------|---------|
| <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>   | `true` |  Оставьте значение по умолчанию  | Если для параметра явно задано значение false, в результате сбоя запроса HRESULT возвращаются значения, которые вызывают исключения (и в результате возвращаемое значение в месте определения становится пустым).|
| <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> | `false`  | в зависимости от API  | Присвойте этому параметру значение true, если для получения значения в API используется GetLastError и Marshal.GetLastWin32Error. Если API устанавливает условие, указывающее на ошибку, перед тем как выполнить другие вызовы, получите информацию об ошибке, чтобы избежать ее непреднамеренной перезаписи.|
| <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet> | `CharSet.None` с откатом к реакции на событие `CharSet.Ansi`  | Если в определении есть строки или символы, используйте `CharSet.Unicode` или `CharSet.Ansi` в явном виде | Указывает реакцию на событие при маршалинге строк и то, как работает `ExactSpelling`, если задано значение `false`. Обратите внимание, что в Unix `CharSet.Ansi` имеет кодировку UTF8. _Обычно_ в Windows используется Юникод, а в Unix — UTF8. См. дополнительные сведения в [документации по кодировке](./charset.md). |
| <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> | `false` | `true`             | Если присвоить этому параметру значение true, можно немного повысить производительность — среда выполнения не будет искать другие имена функций с суффиксом "A" или "W" в зависимости от значения параметра `CharSet` ("A" для `CharSet.Ansi` и "W" для `CharSet.Unicode`). |

## <a name="string-parameters"></a>Строковые параметры

Если кодировка имеет кодировку Юникод или аргумент явно помечен как `[MarshalAs(UnmanagedType.LPWSTR)]` _и_ строка передается по значению (а не `ref` или `out`), строка закрепляется и используется непосредственно машинным кодом (а не копируется).

Если требуется обработка строк по стандарту Американского национального института стандартов (ANSI) в явном виде, не забудьте отметить параметр `[DllImport]` как `Charset.Unicode`.

❌ не использовать параметры `[Out] string`. Если эта строка интернирована, строковые параметры, передаваемые по значению с атрибутом `[Out]`, могут дестабилизировать среду выполнения. См. дополнительные сведения в документации по методу интернирования строк <xref:System.String.Intern%2A?displayProperty=nameWithType>.

❌ избежать `StringBuilder` параметров. `StringBuilder` во время маршалинга *всегда* создает копию собственного буфера. Таким образом, маршалинг может оказаться крайне неэффективным. Выполните обычный сценарий вызова API Windows, который принимает строку:

1. Создание SB требуемой емкости (выделяется управляемая емкость) **{1}** .
2. Вызвать
   1. Выделяется собственный буфер **{2}** .
   2. Копирует содержимое, если `[In]` _(значение по умолчанию для параметра `StringBuilder`)_
   3. Копирует собственный буфер в только что выделенный управляемый массив, если `[Out]` **{3}** _(также значение по умолчанию для `StringBuilder`)_
3. Выделение `ToString()` еще одного управляемого массива **{4}** .

Это *{4}*  распределения для получения строки из машинного кода. Чтобы уменьшить их количество, повторно используйте `StringBuilder` в другом вызове. Но это позволяет сэкономить только *одно* распределение. Гораздо лучше использовать и кэшировать буфер символов из `ArrayPool` — так вы сможете ограничиться распределением для `ToString()` при последующих вызовах.

Еще одна проблема, связанная с `StringBuilder`, заключается в том, что этот атрибут всегда создает резервную копию буфера возврата к первому значению NULL. Если возвращенная строка не завершена или завершается двумя символами NULL, атрибут P/Invoke задан неправильно (в лучшем случае).

Если вы все же *используете*`StringBuilder`, возникает еще одна проблема — емкость **не** включает скрытого значения NULL, которое всегда учитывается при взаимодействии. Пользователи часто ошибаются, так как для многих API требуется, чтобы в размер буфера *включалось* значение NULL. Это может привести к чрезмерному или ненужному распределению. Кроме того, эта ошибка не позволяет среде выполнения оптимизировать маршалинг `StringBuilder` для минимизации количества копий.

✔️ Рассмотрите возможность использования `char[]`s из `ArrayPool`.

Дополнительные сведения см. в статье [Маршалинг по умолчанию для строк](../../framework/interop/default-marshaling-for-strings.md) и разделе [Customizing string parameters](customize-parameter-marshaling.md#customizing-string-parameters) (Настройка строковых параметров).

> __Только для Windows__ Для `[Out]` строк среда CLR по умолчанию будет использовать `CoTaskMemFree` для освобождения строк или `SysStringFree` для строк, помеченных как `UnmanagedType.BSTR`.
> **Для большинства API-интерфейсов с буфером выходной строки:** Переданное число символов должно включать значение null. Если возвращаемое значение меньше, чем количество переданных символов, значит, вызов завершился успешно. В таком случае значение — это количество символов *без* NULL в конце. В противном случае это требуемый размер буфера, *включая* нуль-символ.
>
> - Передайте 5, Get 4: строка имеет 4 символа с завершающим значением NULL.
> - Передайте 5, Get 6: длина строки составляет 5 символов, для хранения значения NULL требуется буфер из 6 символов.
> [Windows Data Types for Strings](/windows/desktop/Intl/windows-data-types-for-strings) (Типы данных Windows для работы со строками)

## <a name="boolean-parameters-and-fields"></a>Логические параметры и поля

Логические значения можно легко спутать. По умолчанию тип .NET `bool` маршалируется в тип Windows `BOOL`, где имеет 4-байтовое значение. Но типы `_Bool` и `bool` в C и C++ имеют размер *один* байт. Это может усложнить поиск ошибок, так как половина возвращаемого значения может не учитываться, что, *возможно*, изменит результат. См. дополнительные сведения о маршалинге значений .NET `bool` для типов C или C++ `bool` в документации по [настройке маршалинга логического поля](customize-struct-marshaling.md#customizing-boolean-field-marshaling).

## <a name="guids"></a>Идентификаторы GUID

Идентификаторы GUID используются непосредственно в сигнатурах. Многие API Windows принимают такие псевдонимы типа `GUID&`, как `REFIID`. При их передаче по ссылке можно воспользоваться атрибутом `ref` или `[MarshalAs(UnmanagedType.LPStruct)]`.

| GUID | Идентификатор GUID для передачи по ссылке |
|------|-------------|
| `KNOWNFOLDERID` | `REFKNOWNFOLDERID` |

❌ не используют `[MarshalAs(UnmanagedType.LPStruct)]` для любых значений, кроме `ref` параметров GUID.

## <a name="blittable-types"></a>Непреобразуемые типы данных

Непреобразуемые типы — это типы данных с одинаковым представлением на битовом уровне в управляемом и машинном коде. Для маршалинга в машинный код и из него эти типы не обязательно преобразовывать в другой формат, что повышает производительность. Поэтому им следует отдавать предпочтение.

**Непреобразуемые типы данных:**

- `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `single`, `double`
- невложенные одномерные массивы непреобразуемых типов (например, `int[]`);
- структуры и классы с фиксированной структурой, содержащие только непреобразуемые значения, например типы полей;
  - чтобы обеспечить фиксированную структуру, необходимо указать `[StructLayout(LayoutKind.Sequential)]` или `[StructLayout(LayoutKind.Explicit)]`;
  - по умолчанию для структур указывается `LayoutKind.Sequential`, а для классов — `LayoutKind.Auto`

**Преобразуемые типы данных:**

- `bool`

**ПЕРИОДИЧЕСКИ преобразуемые типы данных:**

- `char`, `string`

Если непреобразуемые типы передаются по ссылке, маршалер просто закрепляет их вместо копирования в промежуточный буфер (классы изначально передаются по ссылке, структуры данных передаются по ссылке при использовании атрибутов `ref` или `out`).

Тип `char` является непреобразуемым в одномерном массиве **или**, если он является частью другого типа, явным образом помечается `[StructLayout]` с `CharSet = CharSet.Unicode`.

```csharp
[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
public struct UnicodeCharStruct
{
    public char c;
}
```

Тип `string` является непреобразуемым, если не содержится в другом типе, и передается как аргумент с атрибутом `[MarshalAs(UnmanagedType.LPWStr)]` или `[DllImport]` имеет набор `CharSet = CharSet.Unicode`.

Чтобы проверить, является ли тип непреобразуемым, попытайтесь создать закрепленный атрибут `GCHandle`. Если тип не является строкой или считается непреобразуемым, `GCHandle.Alloc` вызовет `ArgumentException`.

✔️ сделать структуры непреобразуемыми, если это возможно.

Дополнительные сведения см. в следующих разделах.

- [Преобразуемые и непреобразуемые типы](../../framework/interop/blittable-and-non-blittable-types.md)
- [Маршалинг типов](type-marshaling.md)

## <a name="keeping-managed-objects-alive"></a>Сохранение управляемых объектов активными

`GC.KeepAlive()` гарантирует, что объект остается в области видимости, пока не будет завершен метод проверки активности KeepAlive.

[`HandleRef`](xref:System.Runtime.InteropServices.HandleRef) позволяет маршалеру сохранять объект активным во время выполнения P/Invoke. Его можно использовать вместо `IntPtr` в сигнатурах метода. `SafeHandle` фактически заменяет этот класс и должен использоваться вместо него.

[`GCHandle`](xref:System.Runtime.InteropServices.GCHandle) разрешает закреплять управляемый объект и получать собственный указатель на него. Базовый шаблон приведен ниже:

```csharp
GCHandle handle = GCHandle.Alloc(obj, GCHandleType.Pinned);
IntPtr ptr = handle.AddrOfPinnedObject();
handle.Free();
```

Для `GCHandle` по умолчанию не задано закрепление. Еще один основной шаблон предназначен для передачи ссылки на управляемый объект через машинный код и обратно на управляемый код, обычно с обратным вызовом. Вот этот шаблон:

```csharp
GCHandle handle = GCHandle.Alloc(obj);
SomeNativeEnumerator(callbackDelegate, GCHandle.ToIntPtr(handle));

// In the callback
GCHandle handle = GCHandle.FromIntPtr(param);
object managedObject = handle.Target;

// After the last callback
handle.Free();
```

Не забывайте, что `GCHandle` необходимо явно освобождать, чтобы избежать утечек памяти.

## <a name="common-windows-data-types"></a>Общие типы данных Windows

Ниже приведен список типов данных, часто используемых в API Windows, и типов данных C#, используемых при вызове в виде кода Windows.

Указанные ниже типы имеют одинаковый размер в 32-разрядной и 64-разрядной версиях Windows независимо от их имен.

| Ширина | Портал          | C (Windows)          | C#       | Альтернатива                          |
|:------|:-----------------|:---------------------|:---------|:-------------------------------------|
| 32    | `BOOL`           | `int`                | `int`    | `bool`                               |
| 8     | `BOOLEAN`        | `unsigned char`      | `byte`   | `[MarshalAs(UnmanagedType.U1)] bool` |
| 8     | `BYTE`           | `unsigned char`      | `byte`   |                                      |
| 8     | `CHAR`           | `char`               | `sbyte`  |                                      |
| 8     | `UCHAR`          | `unsigned char`      | `byte`   |                                      |
| 16    | `SHORT`          | `short`              | `short`  |                                      |
| 16    | `CSHORT`         | `short`              | `short`  |                                      |
| 16    | `USHORT`         | `unsigned short`     | `ushort` |                                      |
| 16    | `WORD`           | `unsigned short`     | `ushort` |                                      |
| 16    | `ATOM`           | `unsigned short`     | `ushort` |                                      |
| 32    | `INT`            | `int`                | `int`    |                                      |
| 32    | `LONG`           | `long`               | `int`    |                                      |
| 32    | `ULONG`          | `unsigned long`      | `uint`   |                                      |
| 32    | `DWORD`          | `unsigned long`      | `uint`   |                                      |
| 64    | `QWORD`          | `long long`          | `long`   |                                      |
| 64    | `LARGE_INTEGER`  | `long long`          | `long`   |                                      |
| 64    | `LONGLONG`       | `long long`          | `long`   |                                      |
| 64    | `ULONGLONG`      | `unsigned long long` | `ulong`  |                                      |
| 64    | `ULARGE_INTEGER` | `unsigned long long` | `ulong`  |                                      |
| 32    | `HRESULT`        | `long`               | `int`    |                                      |
| 32    | `NTSTATUS`       | `long`               | `int`    |                                      |

Следующие типы являются указателями и зависят от ширины платформы. Для них используйте `IntPtr`/`UIntPtr`.

| Типы указателей со знаком (используйте `IntPtr`) | Типы указателей без знака (используйте `UIntPtr`) |
|:------------------------------------|:---------------------------------------|
| `HANDLE`                            | `WPARAM`                               |
| `HWND`                              | `UINT_PTR`                             |
| `HINSTANCE`                         | `ULONG_PTR`                            |
| `LPARAM`                            | `SIZE_T`                               |
| `LRESULT`                           |                                        |
| `LONG_PTR`                          |                                        |
| `INT_PTR`                           |                                        |

`PVOID` в Windows — это аналог `void*` в C, который можно маршалировать как `IntPtr` или `UIntPtr`, но рекомендуется по возможности выбирать `void*`.

[Типы данных Windows](/windows/desktop/WinProg/windows-data-types)

[Диапазоны типов данных](/cpp/cpp/data-type-ranges)

## <a name="structs"></a>структурам;

Управляемые структуры создаются в стеке и не удаляются, пока метод не вернет значение. Таким образом, по определению, эти структуры "закреплены" (не перемещаются службой сборки мусора). Кроме того, если в машинном коде не используется указатель, по завершении этого метода вы можете получить адрес из блоков неуправляемого кода.

Непреобразуемые структуры обеспечивают высокую производительность, так как их можно использовать непосредственно на слое маршалинга. Попробуйте сделать структуры непреобразуемыми (например, не используйте атрибут `bool`). См. дополнительные сведения в разделе [Непреобразуемые типы данных](#blittable-types).

*Если* структура является непреобразуемой, используйте атрибут `sizeof()` вместо `Marshal.SizeOf<MyStruct>()`, чтобы повысить производительность. Как описано выше, чтобы проверить, является ли тип непреобразуемым, попытайтесь создать закрепленный атрибут `GCHandle`. Если тип не является строкой или считается непреобразуемым, атрибут `GCHandle.Alloc` вызовет `ArgumentException`.

Указатели структур в определениях необходимо передавать в `ref` или с помощью `unsafe` и `*`.

✔️ по возможности сопоставлять управляемую структуру с фигурой и именами, которые используются в официальной документации по платформе или заголовке.

✔️ использовать C# `sizeof()` вместо `Marshal.SizeOf<MyStruct>()` для непреобразуемых структур, чтобы повысить производительность.

Массив `INT_PTR Reserved1[2]` необходимо маршалировать в два поля `IntPtr`: `Reserved1a` и `Reserved1b`. Если собственный массив имеет простой тип, используйте ключевое слово `fixed`, чтобы записать его более точно. Например, `SYSTEM_PROCESS_INFORMATION` в заголовке машинного кода выглядит следующим образом:

```c
typedef struct _SYSTEM_PROCESS_INFORMATION {
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    BYTE Reserved1[48];
    UNICODE_STRING ImageName;
...
} SYSTEM_PROCESS_INFORMATION
```

В C# можно написать такой код:

```csharp
internal unsafe struct SYSTEM_PROCESS_INFORMATION
{
    internal uint NextEntryOffset;
    internal uint NumberOfThreads;
    private fixed byte Reserved1[48];
    internal Interop.UNICODE_STRING ImageName;
    ...
}
```

Но с буферами фиксированного размера возникают некоторые ошибки. Буферы фиксированного размера преобразуемых типов не маршалируются правильно, поэтому локальный массив следует развернуть до нескольких отдельных полей. Кроме того, в .NET Framework и .NET Core версий, предшествующих 3.0, если структура содержит поле буфера фиксированного размера и вложена в преобразуемую структуру, поле буфера фиксированного размера не маршалируется правильно в машинный код.
