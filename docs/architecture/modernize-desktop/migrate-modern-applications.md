---
title: Перенос современных настольных приложений
description: Все, что необходимо знать о процессе миграции для современных настольных приложений.
ms.date: 01/19/2021
ms.openlocfilehash: b5bea6e601dc040adfd8ed410320a3416cb3372e
ms.sourcegitcommit: 632818f4b527e5bf3c48fc04e0c7f3b4bdb8a248
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/20/2021
ms.locfileid: "98615767"
---
# <a name="migrating-modern-desktop-applications"></a>Перенос современных настольных приложений

В этой главе рассматриваются наиболее распространенные проблемы и проблемы, с которыми можно столкнуться при переносе существующего приложения из платформа .NET Framework в .NET.

Сложное классическое приложение не работает в изоляции и требует какого-либо взаимодействия с подсистемами, которые могут находиться на локальном компьютере или на удаленном сервере. Возможно, потребуется некоторый тип базы данных для подключения к хранилищу сохраняемости локально или удаленно. С порождением архитектур, ориентированных на Интернет и службы, обычно приложение подключается к некоторым службам, размещенным на удаленном сервере или в облаке. Для реализации некоторой функциональности может потребоваться доступ к файловой системе компьютера. Кроме того, возможно, вы используете часть функциональных возможностей, находящихся внутри COM-объекта за пределами приложения, что является распространенным сценарием, например при интеграции сборок Office в приложение.

Кроме того, существуют различия в области API, предоставляемой платформа .NET Framework и .NET, а некоторые функции, доступные на платформа .NET Framework, недоступны в .NET. Поэтому важно понять и принять их при планировании миграции.

## <a name="configuration-files"></a>Файлы конфигурации.

Файлы конфигурации обеспечивают возможность хранения наборов свойств, которые считываются во время выполнения, и влияют на поведение наших приложений, например место расположения базы данных или количество выполнений цикла. Преимуществом этой методики является то, что вы можете изменить некоторые аспекты приложения без необходимости Recode и повторной компиляции. Это удобно, когда, например, один и тот же код приложения выполняется в среде разработки с определенным набором значений конфигурации и в производстве с другим.

### <a name="configuration-on-net-framework"></a>Конфигурация на платформа .NET Framework

Если у вас есть рабочий платформа .NET Framework классическое приложение, скорее всего, у вас есть *app.configный* файл, к которому можно получить доступ с помощью <xref:System.Configuration.AppSettingsSection> класса из `System.Configuration` пространства имен.

В инфраструктуре платформа .NET Framework есть иерархия файлов конфигурации, которые наследуют свойства родительских элементов. Можно найти файл *machine.config* , который определяет множество свойств и разделов конфигурации, которые можно использовать или переопределить в любом файле конфигурации потомков.

### <a name="configuration-on-net"></a>Настройка в .NET

В мире .NET нет *machine.configного* файла. Несмотря на то, что вы можете продолжать использовать старое <xref:System.Configuration> пространство имен, вы можете рассмотреть возможность перехода на современный <xref:Microsoft.Extensions.Configuration> , который предлагает хорошее количество улучшений.

API конфигурации поддерживает концепцию поставщика конфигурации, который определяет источник данных, используемый для загрузки конфигурации. Существуют различные виды встроенных поставщиков, например:

- объектов .NET в памяти;
- INI-файлы
- файлы JSON;
- файлы XML.
- Аргументы командной строки
- Переменные среды
- Зашифрованное хранилище пользователей

 Вы также можете создать собственный.

Новая конфигурация позволяет получить список пар "имя-значение", которые могут быть сгруппированы в многоуровневую иерархию. Любое сохраненное значение сопоставляется со строкой, и существует встроенная поддержка привязки, позволяющая десериализовать параметры в пользовательском объекте Plain старого типа CLR (POCO).

<xref:Microsoft.Extensions.Configuration.ConfigurationBuilder>Объект позволяет добавить столько поставщиков конфигурации, сколько может потребоваться для приложения, используя правило приоритета для разрешения предпочтений. Таким образом, последний поставщик, добавленный в код, переопределит другие. Это отличная функция для управления различными средами, поскольку вы можете определить различные конфигурации для разработки, тестирования и рабочей среды, а также управлять ими с помощью одной функции внутри кода.

### <a name="migrating-configuration-files"></a>Миграция файлов конфигурации

Вы можете продолжить использовать существующий XML-файл app.config. Однако вы можете воспользоваться этой возможностью для переноса конфигурации, чтобы воспользоваться преимуществами некоторых усовершенствований, вносимых в .NET.

Чтобы выполнить миграцию с *app.config* старого стиля на новый файл конфигурации, необходимо выбрать формат XML и формат JSON.

Если выбрать XML, преобразование будет простым. Так как содержимое совпадает, просто сохраните файл *app.config* с типом XML. Затем измените код, ссылающийся на AppSettings, для использования `ConfigurationBuilder` класса. Это изменение должно быть простым.

Если вы хотите использовать формат JSON и вы не хотите выполнять миграцию вручную, есть средство [DotNet-config2json](https://www.nuget.org/packages/dotnet-config2json/) , доступное в .NET, которое может преобразовать файл *app.config* в файл конфигурации JSON.

Кроме того, при использовании разделов конфигурации, определенных в файле *machine.config* , могут возникнуть некоторые проблемы. Например, рассмотрим следующую конфигурацию:

```xml
<configuration>
    <system.diagnostics>
        <switches>
            <add name="General" value="4" />
        </switches>
        <trace autoflush="true" indentsize="2">
            <listeners>
                <add name="myListener"
                     type="System.Diagnostics.TextWriterTraceListener,
                           System, Version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
                     initializeData="MyListener.log"
                     traceOutputOptions="ProcessId, LogicalOperationStack, Timestamp, ThreadId, Callstack, DateTime" />
            </listeners>
        </trace>
    </system.diagnostics>
</configuration>
```

Если вы предпримете эту конфигурацию для .NET, вы получите исключение:

> Нераспознанный раздел конфигурации система. Диагностика

Это исключение возникает, поскольку этот раздел и сборка, отвечающая за обработку этого раздела, определена в файле *machine.config* , который теперь не существует.

Чтобы легко устранить проблему, можно скопировать определение раздела из старого *machine.config* в новый файл конфигурации:

```xml
<configSections>
    <section name="system.diagnostics"
             type="System.Diagnostics.SystemDiagnosticsSection,
                   System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>
</configSections>
```

## <a name="accessing-databases"></a>Доступ к базам данных

Практически для всех настольных приложений требуется некоторый тип базы данных. Для настольных компьютеров часто можно найти архитектуру клиент-сервер с прямым подключением между классом Desktop и ядром СУБД. Эти базы данных могут быть локальными или удаленными в зависимости от необходимости обмена информацией между разными пользователями.

С точки зрения кода существовало много технологий и платформ, которые позволяют разработчикам подключать, запрашивать и обновлять базу данных.

Наиболее распространенные примеры баз данных, которые можно найти, если речь идет о классическом приложении Windows — Microsoft Access и Microsoft SQL Server. Если вы используете более 20 лет опыта программирования для настольных систем, такие имена, как ODBC, OLEDB, RDO, ADO, ADO.NET, LINQ и Entity Framework, будут привычными.

### <a name="odbc"></a>ODBC

Вы можете продолжать использовать ODBC в .NET, так как корпорация Майкрософт предоставляет `System.Data.Odbc` библиотеку, совместимую с .NET Standard 2,0.

### <a name="ole-db"></a>OLE DB

[OLE DB](/previous-versions/windows/desktop/ms722784(v=vs.85)) был отличным способом для единообразного доступа к различным источникам данных. Но это было основано на модели COM, которая является технологией только для Windows, и поэтому она не лучше всего подходит для кросс-платформенной технологии, такой как .NET. Он также не поддерживается в SQL Server версии 2014 и более поздних версиях. По этим причинам OLE DB не будет поддерживаться .NET.

### <a name="adonet"></a>ADO.NET

Вы по-прежнему можете использовать ADO.NET из существующего кода на рабочем столе в .NET. Вам нужно просто обновить некоторые пакеты NuGet.

### <a name="ef-core-vs-ef6"></a>EF Core и EF6

В настоящее время поддерживаются две версии Entity Framework (EF), Entity Framework 6 (EF6) и EF Core.

Новейшая технология, выпущенная как часть платформа .NET Framework мира, Entity Frameworkа, а 6,4 — Последняя версия. При запуске .NET Core Корпорация Майкрософт также выпустила новый стек доступа к данным на основе Entity Framework и называется Entity Framework Core.

EF 6,4 и EF Core можно использовать как в платформа .NET Framework, так и в .NET. Итак, каковы драйверы принятия решений, помогающие решить эти два?

EF 6,3 — это первая версия EF6, которая может работать на .NET и работать на разных платформах. На самом деле, основная цель этого выпуска — упростить миграцию существующих приложений, использующих EF6, в .NET.

EF Core был разработан как аналог EF6. Большая часть API верхнего уровня сохранена, поэтому EF Core покажется знакомым тем разработчикам, которые использовали EF6.

Несмотря на совместимость, существуют различия в реализации, которые следует проверить перед принятием решения.
Дополнительные сведения см. в разделе [Compare EF Core & EF6](/ef/efcore-and-ef6/).

Рекомендуется использовать EF Core если:

* Приложению требуются возможности .NET.
* EF Core поддерживает все функции, которые требуются приложению.

Используйте EF6, если выполнены оба условия:

* Приложение будет работать в Windows, платформа .NET Framework 4,0 или более поздней версии.
* EF6 поддерживает все функции, которые требуются приложению.

### <a name="relational-databases"></a>реляционные базы данных

#### <a name="sql-server"></a>SQL Server

SQL Server была одной из выбранных баз данных, если вы разрабатываете для рабочего стола несколько лет назад. Используя <xref:System.Data.SqlClient> в платформа .NET Framework, можно получить доступ к версиям SQL Server, которая инкапсулирует протоколы, относящиеся к базе данных.

В .NET можно найти новый `SqlClient` класс, полностью совместимый с существующим в платформа .NET Framework, но расположенным в <xref:Microsoft.Data.SqlClient> библиотеке. Необходимо просто добавить ссылку на пакет NuGet [Microsoft. Data. SqlClient](https://www.nuget.org/packages/Microsoft.Data.SqlClient/) и выполнить переименование для пространств имен, и все должно работать должным образом.

#### <a name="microsoft-access"></a>Microsoft Access

Microsoft Access использовался в течение нескольких лет, когда сложное и масштабируемое SQL Server не требовалось. Вы по-прежнему можете подключаться к Microsoft Access с помощью <xref:System.Data.Odbc> библиотеки.

## <a name="consuming-services"></a>Использование служб

С порождением архитектур, ориентированных на службы, настольные приложения начали развиваться от модели "клиент-сервер" до подхода с тремя уровнями. При подходе "клиент-сервер" прямое подключение к базе данных устанавливается с клиента, который владеет бизнес-логикой, как правило, внутри одного файла EXE. С другой стороны, подход с тремя уровнями устанавливает промежуточный слой служб, реализующий бизнес-логику и доступ к базе данных, что обеспечивает лучшую безопасность, масштабируемость и многократное использование. Вместо того, чтобы работать непосредственно с наборами данных, подход слоя использует набор служб, реализующих контракты и типы объектов в качестве способа реализации обмена данными.

Если у вас есть классическое приложение, использующее службу WCF, и вы хотите перенести его в .NET, необходимо учитывать некоторые моменты.

В первую очередь, как разрешить конфигурацию для доступа к службе. Так как конфигурация отличается в .NET, необходимо внести некоторые обновления в файл конфигурации.

Во вторых, необходимо повторно создать клиент службы с помощью новых средств, имеющихся в Visual Studio 2019. На этом шаге необходимо активировать создание синхронных операций, чтобы обеспечить совместимость клиента с существующим кодом.

Если после миграции обнаруживается наличие библиотек, которые отсутствуют в .NET, можно добавить ссылку на пакет NuGet [Microsoft. Windows. Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility) и проверить наличие недостающих функций.

Если вы используете <xref:System.Net.WebRequest> класс для выполнения вызовов веб-служб, вы можете столкнуться с некоторыми отличиями .NET. Рекомендуется использовать вместо него System .NET. http. HttpClient.

## <a name="consuming-a-com-object"></a>Использование COM-объекта

В настоящее время нет способа добавить ссылку на COM-объект из Visual Studio 2019 для использования с .NET. Поэтому необходимо вручную изменить файл проекта.

Вставьте `COMReference` структуру в файл проекта, как показано в следующем примере:

```xml
<ItemGroup>
    <COMReference Include="MSHTML">
        <Guid>{3050F1C5-98B5-11CF-BB82-00AA00BDCE0B}\</Guid>
        <VersionMajor>4</VersionMajor>
        <VersionMinor>0</VersionMinor>
        <Lcid>0</Lcid>
        <WrapperTool>primary</WrapperTool>
        <Isolated>false</Isolated>
    </COMReference>
</ItemGroup>
```

## <a name="more-things-to-consider"></a>Другие вещи, которые следует учитывать

Несколько технологий, доступных для платформа .NET Framework библиотек, недоступны для .NET Core и .NET 5. Если ваш код полагается на некоторые из этих технологий, рассмотрите альтернативные подходы, описанные в этом разделе.

[Пакет обеспечения совместимости Windows](../../core/porting/windows-compat-pack.md) предоставляет доступ к интерфейсам API, которые ранее были доступны только для платформа .NET Framework. Его можно использовать в проектах .NET Core и .NET Standard.

Дополнительные сведения о совместимости API можно найти в документации по критическим изменениям и устаревшим API-интерфейсам <https://docs.microsoft.com/dotnet/core/compatibility/fx-core> .

### <a name="appdomains"></a>Домены приложений

Домены приложений позволяют изолировать приложения друг от друга. AppDomains требуется поддержка среды выполнения и дорогостоящие. Создание дополнительных доменов приложений не поддерживается. Вместо нее для изоляции кода мы рекомендуем использовать отдельные процессы или контейнеры. Для динамической загрузки сборок рекомендуется использовать новый класс <xref:System.Runtime.Loader.AssemblyLoadContext>.

Чтобы упростить миграцию кода с платформа .NET Framework, .NET предоставляет некоторую `AppDomain` поверхность API. Некоторые API-интерфейсы работают без изменений (например, <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>), одни элементы не выполняют никаких действий (например, <xref:System.AppDomain.SetCachePath%2A>), а другие создают исключение <xref:System.PlatformNotSupportedException> (например, <xref:System.AppDomain.CreateDomain%2A>).

### <a name="remoting"></a>Удаленное взаимодействие

Удаленное взаимодействие .NET использовалось для взаимодействия между доменами AppDomain, которое больше не поддерживается. Кроме того, для удаленного взаимодействия требуется поддержка среды выполнения, обслуживание которой дорого обходится. По этим причинам удаленное взаимодействие .NET не поддерживается в .NET.

Для обмена данными между процессами следует рассмотреть механизмы межпроцессного взаимодействия (IPC) в качестве альтернативы удаленному взаимодействию, например <xref:System.IO.Pipes?displayProperty=nameWithType> <xref:System.IO.MemoryMappedFiles.MemoryMappedFile> классу или.

Для взаимодействия между компьютерами в качестве альтернативы можно использовать сетевое решение, Желательно использовать протокол открытого текста с низкими издержками, например HTTP. Еще один вариант — веб-сервер Kestrel, используемый платформой ASP.NET Core.

### <a name="code-access-security-cas"></a>CAS (Code Access Security — безопасность доступа кода)

Изолированная среда, которая использует среду выполнения или платформу для ограничения ресурсов, используемых или выполняемых управляемым приложением или библиотекой, не поддерживается в .NET.

Используйте границы безопасности, предоставляемые операционной системой, такие как виртуализация, контейнеры или учетные записи пользователей, для выполнения процессов с минимальным набором привилегий.

### <a name="security-transparency"></a>Прозрачность безопасности

Аналогично CAS, прозрачность безопасности позволяет декларативно отделить изолированный код от кода, критически важного с точки зрения безопасности, но больше не поддерживается как ограничение безопасности.

Используйте границы безопасности, предоставляемые операционной системой, такие как виртуализация, контейнеры или учетные записи пользователей, для выполнения процессов с наименьшим набором привилегий.

>[!div class="step-by-step"]
>[Назад](whats-new-dotnet.md )
>[Вперед](windows-migration.md)
