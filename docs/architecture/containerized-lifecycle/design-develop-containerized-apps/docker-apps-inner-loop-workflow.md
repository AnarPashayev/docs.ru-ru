---
title: Рабочий процесс внутреннего цикла разработки для приложений Docker
description: Узнайте о рабочем процессе внутреннего цикла разработки для приложений Docker.
ms.date: 08/06/2020
ms.openlocfilehash: bf837ab53fff2b53cf141b2e621d484cff9b6889
ms.sourcegitcommit: ef50c99928183a0bba75e07b9f22895cd4c480f8
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/07/2020
ms.locfileid: "87916148"
---
# <a name="inner-loop-development-workflow-for-docker-apps"></a>Рабочий процесс внутреннего цикла разработки для приложений Docker

Рабочий процесс внутреннего цикла, охватывающий весь цикл DevOps, начинается на компьютере каждого разработчика, где разработчик локально пишет код приложения на предпочитаемых языках и платформах, а затем тестирует его (рис. 4-21). Независимо от выбранного языка и платформы этот рабочий процесс имеет одну общую черту: В этом конкретном рабочем процессе вы всегда разрабатываете и тестируете контейнеры Docker не в других средах, а локально.

![Схема, показывающая концепцию среды разработки внутреннего цикла](./media/docker-apps-inner-loop-workflow/inner-loop-development-context.png)

**Рис. 4-21**. Контекст внутреннего цикла разработки

В каждый контейнер или экземпляр образа Docker входят следующие компоненты:

- выбранная операционная система (например, Windows или дистрибутив Linux);

- файлы, добавленные разработчиком (например, двоичные файлы приложения);

- конфигурация (например, параметры среды и зависимости);

- инструкции касательно того, какие процессы должны выполняться Docker.

Рабочий процесс внутреннего цикла разработки на основе Docker можно настроить как процесс (как описано в следующем разделе). Учтите, что начальные этапы настройки среды здесь не рассматриваются, так как они выполняются только один раз.

## <a name="building-a-single-app-within-a-docker-container-using-visual-studio-code-and-docker-cli"></a>Создание одного приложения в контейнере Docker с помощью Visual Studio Code и интерфейса командной строки (CLI) Docker

Приложение состоит из ваших собственных служб и дополнительных библиотек (зависимостей).

На рис. 4-22 показаны основные шаги, которые обычно необходимо выполнить при сборке приложения Docker, после чего приводится подробное описание каждого из них.

![Схема, на которой показаны семь шагов, необходимых для создания контейнерного приложения.](./media/docker-apps-inner-loop-workflow/life-cycle-containerized-apps-docker-cli.png)

**Рис. 4-22**. Высокоуровневое представление рабочего процесса для жизненного цикла контейнерных приложений Docker, создаваемых с помощью CLI Docker

### <a name="step-1-start-coding-in-visual-studio-code-and-create-your-initial-appservice-baseline"></a>Шаг 1. Начало программирования в Visual Studio Code и создание первого приложения или базовой службы

Разработка приложения Docker аналогична разработке приложения без Docker. Разница заключается в том, что при разработке развертывание и тестирование приложения или служб, работающих в контейнерах Docker, выполняется в локальной среде (например, в Windows или виртуальной машине Linux).

**Настройка локальной среды**

С помощью последних версий Docker Desktop для Mac и Windows разрабатывать приложения Docker стало еще легче. Настройка очень проста.

> [!TIP]
> Инструкции по настройке Docker Desktop для Windows см. на странице <https://docs.docker.com/docker-for-windows/>.
>
> Инструкции по настройке Docker Desktop для Mac см. на странице <https://docs.docker.com/docker-for-mac/>.

Кроме того, вам потребуется редактор кода для разработки приложения с помощью CLI Docker.

Корпорация Майкрософт предлагает Visual Studio Code, простой редактор кода, который поддерживается в macOS, Windows и Linux. Он предоставляет технологию IntelliSense с [поддержкой множества языков](https://code.visualstudio.com/docs/languages/overview) (JavaScript, .NET, Go, Java, Ruby, Python и большинства современных языков), возможность [отладки](https://code.visualstudio.com/Docs/editor/debugging), [интеграцию с Git](https://code.visualstudio.com/Docs/editor/versioncontrol) и [поддержку расширений](https://code.visualstudio.com/docs/extensions/overview). Это средство отлично подойдет разработчикам, использующим macOS и Linux. В Windows также можно использовать Visual Studio.

> [!TIP]
> Инструкции по установке Visual Studio Code для Windows, macOS или Linux см. на странице <https://code.visualstudio.com/docs/setup/setup-overview/>.
>
> Инструкции по настройке Docker для Mac см. на странице <https://docs.docker.com/docker-for-mac/>.

Вы можете использовать CLI Docker и писать код в любом редакторе кода, однако Visual Studio Code в сочетании с расширением Docker упрощает создание файлов `Dockerfile` и `docker-compose.yml`. Вы также можете выполнять задачи и скрипты из интегрированной среды разработки Visual Studio Code для выполнения команд Docker на базе CLI Docker.

Расширение Docker для VS Code предоставляет следующие возможности:

- автоматическое создание файлов `Dockerfile` и `docker-compose.yml`;

- выделение синтаксических конструкций и подсказки при наведении для файлов `docker-compose.yml` и `Dockerfile`;

- IntelliSense (варианты завершения) для файлов `Dockerfile` и `docker-compose.yml`;

- статический анализ кода (ошибки и предупреждения) для файлов `Dockerfile`;

- интеграция палитры команд (F1) с наиболее часто используемыми командами Docker;

- интеграция в обозреватель для управления образами и контейнерами;

- развертывание образов из DockerHub и реестров контейнеров Azure в службе приложений Azure.

Чтобы установить расширение Docker, нажмите клавиши CTRL+SHIFT+P, введите `ext install` и выполните команду "Установить расширение", чтобы открыть список расширений в Marketplace. Затем введите **docker**, чтобы отфильтровать результаты, и выберите расширение поддержки Docker, как показано на рис. 4-23.

![Расширение Docker для VS Code.](media/docker-apps-inner-loop-workflow/install-docker-extension-vs-code.png)

**Рис. 4-23**. Установка расширения Docker в Visual Studio Code

### <a name="step-2-create-a-dockerfile-related-to-an-existing-image-plain-os-or-dev-environments-like-net-core-nodejs-and-ruby"></a>Шаг 2. Создание файла Dockerfile, связанного с существующим образом (обычная ОС или среды разработки, такие как .NET Core, Node.js и Ruby)

Для каждого собираемого образа и каждого развертываемого контейнера требуется файл `DockerFile`. Если в приложении имеется только одна пользовательская служба, необходим один файл `DockerFile`. Но если приложение состоит из нескольких служб (как в архитектуре на основе микрослужб), потребуется по одному файлу `Dockerfile` для каждой службы.

Файл `DockerFile` обычно находится в корневой папке приложения или службы и содержит команды, которые требуются Docker для настройки и запуска приложения или службы. Вы можете создать файл `DockerFile` самостоятельно и добавить его в проект вместе с кодом (node.js, .NET Core и т. д.) или, если у вас нет опыта работы со средой, воспользоваться приведенным ниже советом.

> [!TIP]
> При использовании файлов `Dockerfile` и `docker-compose.yml`, связанных с контейнерами Docker, можно следовать указаниям, которые предоставляются расширением Docker. Вероятно, в дальнейшем вы будете создавать эти файлы, не прибегая к помощи данного средства, но поначалу оно позволяет ускорить обучение.

На рис. 4-24 приведены шаги по добавлению файлов Docker в проект с помощью расширения Docker для VS Code.

1. Откройте палитру команд, введите "**docker**" и нажмите "**Добавить файлы Docker в рабочую область**".
2. Выберите платформу приложения (ASP.NET Core)
3. Выберите операционную систему (Linux)
4. При необходимости включите дополнительные файлы Docker Compose
5. Введите порты для публикации (80, 443)
6. Выбор проекта

![Действия по добавлению файлов Docker с помощью расширения Docker](media/docker-apps-inner-loop-workflow/add-docker-files-to-workspace-command.png)

**Рис. 4-24**. Добавление файлов Docker с помощью команды **Добавить файлы Docker в рабочую область**

При добавлении файла Dockerfile указывается базовый образ Docker, который необходимо использовать (например, `FROM mcr.microsoft.com/dotnet/core/aspnet`). Обычно пользовательский образ создается на основе базового образа, полученного из официального репозитория в [реестре Docker Hub](https://hub.docker.com/) (например, [образа для .NET Core](https://hub.docker.com/_/microsoft-dotnet-core/) или [Node.js](https://hub.docker.com/_/node/)).

> [!TIP]
> Эту процедуру необходимо повторить для каждого проекта в приложении. Однако после первого запуска расширение будет запрашивать перезапись созданного файла docker-compose. На запрос на перезапись нужно отвечать отказом, чтобы расширение создавало отдельные файлы docker-compose, которые затем можно объединить вручную перед выполнением docker-compose.

**_Использование существующего официального образа Docker_**

Использование официального репозитория стека языка с номером версии гарантирует, что на всех компьютерах (включая компьютеры для разработки, тестирования и работы) будут доступны одни и те же функции языка.

Вот пример файла Dockerfile для контейнера .NET Core:

```Dockerfile
FROM mcr.microsoft.com/dotnet/core/aspnet:3.1 AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/core/sdk:3.1 AS build
WORKDIR /src
COPY ["src/WebApi/WebApi.csproj", "src/WebApi/"]
RUN dotnet restore "src/WebApi/WebApi.csproj"
COPY . .
WORKDIR "/src/src/WebApi"
RUN dotnet build "WebApi.csproj" -c Release -o /app/build

FROM build AS publish
RUN dotnet publish "WebApi.csproj" -c Release -o /app/publish

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "WebApi.dll"]
```

В этом случае образ основан на версии 3.1 официального образа Docker ASP.NET Core (мультиархитектурного, для Linux и Windows), что следует из строки `FROM mcr.microsoft.com/dotnet/core/aspnet:3.1`. (Дополнительные сведения по этой теме см. на страницах [Образ Docker ASP.NET Core](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) и [Образ Docker .NET Core](https://hub.docker.com/_/microsoft-dotnet-core/).)

Кроме того, в файле Dockerfile можно указать, что средство Docker должно прослушивать порт TCP, который будет использоваться во время выполнения (например, порт 80 или 443).

В Dockerfile можно задать дополнительные параметры конфигурации, в зависимости от используемого языка и платформы. Например, строка `ENTRYPOINT` со значением `["dotnet", "WebMvcApplication.dll"]` указывает Docker запускать приложение .NET Core. Если для создания и запуска приложения .NET используется пакет SDK и .NET Core CLI (`dotnet CLI`), этот параметр будет другим. Ключевой момент здесь заключается в том, что строка ENTRYPOINT и другие параметры зависят от языка и платформы, выбранных для приложения.

> [!TIP]
> Дополнительные сведения о создании образов Docker для приложений .NET Core см. на странице <https://docs.microsoft.com/dotnet/core/docker/building-net-docker-images>.
>
> Дополнительные сведения о создании собственных образов см. на странице <https://docs.docker.com/engine/tutorials/dockerimages/>.

**Использование репозиториев мультиархитектурных образов**

В репозитории могут содержаться варианты одного и того же образа для разных платформ, например образ Linux и образ Windows. Это позволяет поставщикам, таким как Майкрософт, которые создают базовые образы, создать один репозиторий для охвата нескольких платформ (т. е. Windows и Linux). Например, репозиторий [dotnet/core/aspnet](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) в реестре Docker Hub обеспечивает поддержку Linux и Windows Nano Server при использовании одного и того же имени образа.

При запросе образа [dotnet/core/aspnet](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) с узла Windows извлекается вариант для Windows, а при запросе образа с тем же именем с узла Linux — вариант для Linux.

**_Создание базового образа с нуля_**

Вы можете создать собственный базовый образ Docker с нуля, как описано в этой [статье](https://docs.docker.com/engine/userguide/eng-image/baseimages/). Этот сценарий, вероятно, будет не самым лучшим для тех, кто только начинает работать с Docker, но если вы хотите задать определенные биты базового образа, это можно сделать.

### <a name="step-3-create-your-custom-docker-images-embedding-your-service-in-it"></a>Шаг 3. Создание пользовательских образов Docker и внедрение в них собственных служб

Для каждой пользовательской службы в приложении необходимо создать связанный образ. Если приложение состоит из одной службы или веб-приложения, достаточно одного образа.

> [!NOTE]
> В рамках "рабочего процесса внешнего цикла DevOps" образы создаются автоматическим процессом сборки при отправке исходного кода в репозиторий Git (непрерывная интеграция), поэтому образы будут создаваться в этой глобальной среде из вашего исходного кода.
>
> Однако перед переходом к этому внешнему циклу необходимо убедиться в том, что приложение Docker действительно работает правильно, чтобы в систему управления версиями (Git и т. д.) не передавался неправильно работающий код.
>
> Поэтому каждый разработчик должен вначале полностью выполнить внутренний цикл, чтобы провести тестирование локально, прежде чем отправлять в систему управления версиями полностью готовую функцию или изменение.

Чтобы создать образ в локальной среде и использовать DockerFile, можно использовать команду docker build, как показано на рис. 4-25, так как она сразу помечает образ и создает образы для всех служб в приложении с помощью простой команды.

![Снимок экрана, показывающий выходные данные команды docker-compose build в консоли.](media/docker-apps-inner-loop-workflow/run-docker-build-command.png)

**Рис. 4-25**. Выполнение команды docker build

При необходимости вместо непосредственного выполнения команды `docker build` из папки проекта можно сначала создать развертываемую папку с нужными библиотеками .NET, выполнив команду `dotnet publish`, а затем использовать команду `docker build`.

В этом примере создается образ Docker с именем `explore-docker-vscode/webapi:latest` (`:latest` — это тег, например определенная версия). Этот шаг можно выполнить для каждого пользовательского образа, который требуется создать для составного приложения Docker с несколькими контейнерами. Однако в следующем разделе мы увидим, что это проще сделать с помощью `docker-compose`.

Вы можете найти образы, имеющиеся в локальном репозитории (на компьютере разработки), с помощью команды `docker images`, как показано на рисунке 4-26.

![Выходные данные команды docker images в консоли со списком существующих образов.](media/docker-apps-inner-loop-workflow/view-existing-images-with-docker-images.png)

**Рис. 4-26**. Просмотр существующих образов с помощью команды docker images

### <a name="step-4-define-your-services-in-docker-composeyml-when-building-a-composed-docker-app-with-multiple-services"></a>Шаг 4. Определение служб в файле docker-compose.yml при сборке составного приложения Docker с несколькими службами

В файле `docker-compose.yml` можно задать ряд связанных служб для развертывания в качестве составного приложения с помощью команд развертывания, описанных в следующем разделе.

Создайте этот файл в основной или корневой папке решения. Его содержимое должно быть аналогично приведенному в следующем файле `docker-compose.yml`:

```yml
version: "3.4"

services:
  webapi:
    image: webapi
    build:
      context: .
      dockerfile: src/WebApi/Dockerfile
    ports:
      - 51080:80
    depends_on:
      - redis
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - ASPNETCORE_URLS=http://+:80

  webapp:
    image: webapp
    build:
      context: .
      dockerfile: src/WebApp/Dockerfile
    ports:
      - 50080:80
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - ASPNETCORE_URLS=http://+:80
      - WebApiBaseAddress=http://webapi

  redis:
    image: redis
```

В данном случае в этом файле определены три службы: служба веб-API (ваша пользовательская служба), веб-приложение и служба Redis (популярная служба кэширования). Каждая служба развертывается как контейнер, поэтому для каждой из них требуется определенный образ Docker. Для этого конкретного приложения:

- Служба веб-API строится на основе DockerFile в каталоге `src/WebApi/Dockerfile`.

- Порт узла 51080 перенаправляется на доступный порт 80 в контейнере `webapi`.

- Служба веб-API зависит от службы Redis.

- Веб-приложение обращается к службе веб-API, используя внутренний адрес: `http://webapi`.

- Служба Redis использует [последний общедоступный образ Redis](https://hub.docker.com/_/redis/), извлеченный из реестра Docker Hub. [Redis](https://redis.io/) — это популярная система кэширования для серверных приложений.

### <a name="step-5-build-and-run-your-docker-app"></a>Шаг 5. Сборка и запуск приложения Docker

Если в приложении имеется только один контейнер, его можно запустить путем развертывания на узле Docker (в виртуальной машине или на физическом сервере). Однако если приложение состоит из нескольких служб, его также необходимо _скомпоновать_. Давайте рассмотрим разные варианты.

**_Вариант А. Запуск одного контейнера или службы_**

Образ Docker можно запустить с помощью команды docker run, как показано в этом примере:

```console
docker run -t -d -p 50080:80 explore-docker-vscode/webapp:latest
```

Для этого конкретного развертывания мы будем перенаправлять запросы, отправленные на порт 50080 узла, на внутренний порт 80.

**_Вариант Б. Компоновка и запуск многоконтейнерного приложения_**

В большинстве корпоративных сценариев приложение Docker будет состоять из нескольких служб. В таких случаях можно выполнить команду `docker-compose up` (рис. 4-27), которая использует ранее созданный файл docker-compose.yml. В результате ее выполнения выполняется сборка всех пользовательских образов и развертывается скомпонованное приложение со всеми связанными контейнерами.

![Выходные данные команды docker-compose up в консоли.](media/docker-apps-inner-loop-workflow/results-docker-compose-up.png)

**Рис. 4-27**. Результаты выполнения команды docker-compose up

После выполнения команды `docker-compose up` приложение и связанные с ним контейнеры развертываются в узле Docker, как показано в представлении виртуальной машины на рисунке 4-28.

![Виртуальная машина, в которой выполняются многоконтейнерные приложения.](./media/docker-apps-inner-loop-workflow/vm-with-docker-containers-deployed.png)

**Рис. 4-28**. Виртуальная машина с развернутыми контейнерами Docker

### <a name="step-6-test-your-docker-application-locally-in-your-local-cd-vm"></a>Шаг 6. Тестирование приложения Docker (в локальной виртуальной машине для непрерывного развертывания)

Этот шаг будет зависеть от того, что делает ваше приложение.

В случае простого веб-API Hello World на основе .NET Core, развернутого в виде единственного контейнера или службы, для доступа к службе достаточно указать TCP-порт из файла Dockerfile.

В узле Docker откройте браузер и перейдите на этот сайт. Вы должны увидеть работающее приложение или службу, как показано на рисунке 4-29.

![Ответ от localhost/API/values в браузере.](media/docker-apps-inner-loop-workflow/test-docker-app-locally-localhost.png)

**Рис. 4-29**. Локальное тестирование приложения Docker с помощью браузера

Обратите внимание на то, что используется порт 50080, однако внутренние запросы перенаправляются на порт 80, поскольку именно так было выполнено развертывание с помощью команды `docker compose`, как это описывалось ранее.

Это можно проверить с помощью браузера, используя cURL из терминала, как показано на рис. 4-30.

![Результат cURL, полученный из http://localhost:51080/WeatherForecast](media/docker-apps-inner-loop-workflow/test-docker-app-locally-curl.png)

**Рис. 4-30**. Локальное тестирование приложения Docker с помощью CURL

**Отладка контейнера, запущенного в Docker**

Visual Studio Code поддерживает отладку Docker при использовании Node.js и других платформ, таких как контейнеры .NET Core.

Вы также можете отлаживать контейнеры .NET Core или .NET Framework в Docker с помощью Visual Studio для Windows или Mac, как описано в следующем разделе.

> [!TIP]
> См. сведения об <https://blog.docker.com/2016/07/live-debugging-docker/>отладке контейнеров Docker Node.js<https://docs.microsoft.com/archive/blogs/user_ed/visual-studio-code-new-features-13-big-debugging-updates-rich-object-hover-conditional-breakpoints-node-js-mono-more>.

> [!div class="step-by-step"]
> [Назад](docker-apps-development-environment.md)
> [Вперед](visual-studio-tools-for-docker.md)
