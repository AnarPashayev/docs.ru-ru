---
title: Рабочий процесс внутреннего цикла разработки для приложений Docker
description: Сведения о рабочем процессе "внутреннего цикла" при разработке приложений Docker.
ms.date: 02/15/2019
ms.openlocfilehash: 3d2fc889d22dbf02acccfbf9231ad98fca224cff
ms.sourcegitcommit: 7e2128d4a4c45b4274bea3b8e5760d4694569ca1
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/14/2020
ms.locfileid: "75936802"
---
# <a name="inner-loop-development-workflow-for-docker-apps"></a>Рабочий процесс внутреннего цикла разработки для приложений Docker

Рабочий процесс внутреннего цикла, охватывающий весь цикл DevOps, начинается на компьютере каждого разработчика, где разработчик локально пишет код приложения на предпочитаемых языках и платформах, а затем тестирует его (рис. 4-21). Независимо от выбранного языка и платформы этот рабочий процесс имеет одну общую черту: вы всегда разрабатываете и тестируете контейнеры Docker, но делаете это локально.

![Схема, показывающая концепцию среды разработки внутреннего цикла](./media/docker-apps-inner-loop-workflow/inner-loop-development-context.png)

**Рис. 4-21**. Контекст внутреннего цикла разработки

В каждый контейнер или экземпляр образа Docker входят следующие компоненты:

- выбранная операционная система (например, Windows или дистрибутив Linux);

- файлы, добавленные разработчиком (например, двоичные файлы приложения);

- конфигурация (например, параметры среды и зависимости);

- инструкции касательно того, какие процессы должны выполняться Docker.

Рабочий процесс внутреннего цикла разработки на основе Docker можно настроить как процесс (как описано в следующем разделе). Учтите, что начальные этапы настройки среды здесь не рассматриваются, так как они выполняются только один раз.

## <a name="building-a-single-app-within-a-docker-container-using-visual-studio-code-and-docker-cli"></a>Создание одного приложения в контейнере Docker с помощью Visual Studio Code и интерфейса командной строки (CLI) Docker

Приложение состоит из ваших собственных служб и дополнительных библиотек (зависимостей).

На рис. 4-22 показаны основные шаги, которые обычно необходимо выполнить при сборке приложения Docker, после чего приводится подробное описание каждого из них.

![Схема, на которой показаны семь шагов, необходимых для создания контейнерного приложения.](./media/docker-apps-inner-loop-workflow/life-cycle-containerized-apps-docker-cli.png)

**Рис. 4-22**. Высокоуровневое представление рабочего процесса для жизненного цикла контейнерных приложений Docker, создаваемых с помощью CLI Docker

### <a name="step-1-start-coding-in-visual-studio-code-and-create-your-initial-appservice-baseline"></a>Шаг 1. Начало программирования в Visual Studio Code и создание первого приложения или базовой службы

Разработка приложения Docker аналогична разработке приложения без Docker. Разница заключается в том, что при разработке развертывание и тестирование приложения или служб, работающих в контейнерах Docker, выполняется в локальной среде (например, в Windows или виртуальной машине Linux).

**Настройка локальной среды**

С помощью последних версий Docker для Mac и Windows разрабатывать приложения Docker стало еще легче. Настройка очень проста.

> [!TIP]
> Инструкции по настройке Docker для Windows см. на странице <https://docs.docker.com/docker-for-windows/>.
>
>Инструкции по настройке Docker для Mac см. на странице <https://docs.docker.com/docker-for-mac/>.

Кроме того, вам потребуется редактор кода для разработки приложения с помощью CLI Docker.

Корпорация Майкрософт предлагает Visual Studio Code, простой редактор кода, который поддерживается в macOS, Windows и Linux. Он предоставляет технологию IntelliSense с [поддержкой множества языков](https://code.visualstudio.com/docs/languages/overview) (JavaScript, .NET, Go, Java, Ruby, Python и большинства современных языков), возможность [отладки](https://code.visualstudio.com/Docs/editor/debugging), [интеграцию с Git](https://code.visualstudio.com/Docs/editor/versioncontrol) и [поддержку расширений](https://code.visualstudio.com/docs/extensions/overview). Это средство отлично подойдет разработчикам, использующим macOS и Linux. В Windows также можно использовать Visual Studio.

> [!TIP]
> Инструкции по установке Visual Studio Code для Windows, macOS или Linux см. на странице <https://code.visualstudio.com/docs/setup/setup-overview/>.
>
> Инструкции по настройке Docker для Mac см. на странице <https://docs.docker.com/docker-for-mac/>.

Вы можете использовать CLI Docker и писать код в любом редакторе кода, однако Visual Studio Code в сочетании с расширением Docker упрощает создание файлов `Dockerfile` и `docker-compose.yml`. Вы также можете выполнять задачи и скрипты из интегрированной среды разработки Visual Studio Code для выполнения команд Docker на базе CLI Docker.

Расширение Docker для VS Code предоставляет следующие возможности:

- автоматическое создание файлов `Dockerfile` и `docker-compose.yml`;

- выделение синтаксических конструкций и подсказки при наведении для файлов `docker-compose.yml` и `Dockerfile`;

- IntelliSense (варианты завершения) для файлов `Dockerfile` и `docker-compose.yml`;

- статический анализ кода (ошибки и предупреждения) для файлов `Dockerfile`;

- интеграция палитры команд (F1) с наиболее часто используемыми командами Docker;

- интеграция в обозреватель для управления образами и контейнерами;

- развертывание образов из DockerHub и реестров контейнеров Azure в службе приложений Azure.

Чтобы установить расширение Docker, нажмите клавиши CTRL+SHIFT+P, введите `ext install` и выполните команду "Установить расширение", чтобы открыть список расширений в Marketplace. Затем введите **docker**, чтобы отфильтровать результаты, и выберите расширение поддержки Docker, как показано на рис. 4-23.

![Расширение Docker для VS Code.](./media/docker-apps-inner-loop-workflow/install-docker-extension-vs-code.png)

**Рис. 4-23**. Установка расширения Docker в Visual Studio Code

### <a name="step-2-create-a-dockerfile-related-to-an-existing-image-plain-os-or-dev-environments-like-net-core-nodejs-and-ruby"></a>Шаг 2. Создание файла Dockerfile, связанного с существующим образом (обычная ОС или среды разработки, такие как .NET Core, Node.js и Ruby)

Для каждого собираемого образа и каждого развертываемого контейнера требуется файл `DockerFile`. Если в приложении имеется только одна пользовательская служба, необходим один файл `DockerFile`. Но если приложение состоит из нескольких служб (как в архитектуре на основе микрослужб), потребуется по одному файлу `Dockerfile` для каждой службы.

Файл `DockerFile` обычно находится в корневой папке приложения или службы и содержит команды, которые требуются Docker для настройки и запуска приложения или службы. Вы можете создать файл `DockerFile` самостоятельно и добавить его в проект вместе с кодом (node.js, .NET Core и т. д.) или, если у вас нет опыта работы со средой, воспользоваться приведенным ниже советом.

> [!TIP]
> При использовании файлов `Dockerfile` и `docker-compose.yml`, связанных с контейнерами Docker, можно следовать указаниям, которые предоставляются расширением Docker. Вероятно, в дальнейшем вы будете создавать эти файлы, не прибегая к помощи данного средства, но поначалу оно позволяет ускорить обучение.

На рисунке 4-24 показано, как добавляется файл docker-compose с помощью расширения Docker для VS Code.

![Консоль расширения Docker для VS Code.](./media/docker-apps-inner-loop-workflow/add-docker-files-to-workspace-command.png)

**Рис. 4-24**. Добавление файлов Docker с помощью **команды добавления файлов Docker в рабочую область**

При добавлении файла Dockerfile указывается базовый образ Docker, который необходимо использовать (например, `FROM mcr.microsoft.com/dotnet/core/aspnet`). Обычно пользовательский образ создается на основе базового образа, полученного из официального репозитория в [реестре Docker Hub](https://hub.docker.com/) (например, [образа для .NET Core](https://hub.docker.com/_/microsoft-dotnet-core/) или [Node.js](https://hub.docker.com/_/node/)).

***Использование существующего официального образа Docker***

Использование официального репозитория стека языка с номером версии гарантирует, что на всех компьютерах (включая компьютеры для разработки, тестирования и работы) будут доступны одни и те же функции языка.

Вот пример файла Dockerfile для контейнера .NET Core:

```Dockerfile
# Base Docker image to use  
FROM mcr.microsoft.com/dotnet/core/aspnet:2.2
  
# Set the Working Directory and files to be copied to the image  
ARG source  
WORKDIR /app  
COPY ${source:-bin/Release/PublishOutput} .  
  
# Configure the listening port to 80 (Internal/Secured port within Docker host)  
EXPOSE 80  
  
# Application entry point  
ENTRYPOINT ["dotnet", "MyCustomMicroservice.dll"]
```

В этом случае образ основан на версии 2.2 официального образа Docker ASP.NET Core (мультиархитектурного, для Linux и Windows), что следует из строки `FROM mcr.microsoft.com/dotnet/core/aspnet:2.2`. (Дополнительные сведения по этой теме см. на страницах [Образ Docker ASP.NET Core](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) и [Образ Docker .NET Core](https://hub.docker.com/_/microsoft-dotnet-core/).)

Кроме того, в файле Dockerfile можно указать, что средство Docker должно прослушивать порт TCP, который будет использоваться во время выполнения (например, порт 80).

В Dockerfile можно задать дополнительные параметры конфигурации, в зависимости от используемого языка и платформы. Например, строка `ENTRYPOINT` со значением `["dotnet", "MySingleContainerWebApp.dll"]` указывает Docker запускать приложение .NET Core. Если для создания и запуска приложения .NET используется пакет SDK и .NET Core CLI (`dotnet CLI`), этот параметр будет другим. Ключевой момент здесь заключается в том, что строка ENTRYPOINT и другие параметры зависят от языка и платформы, выбранных для приложения.

> [!TIP]
> Дополнительные сведения о создании образов Docker для приложений .NET Core см. на странице <https://docs.microsoft.com/dotnet/core/docker/building-net-docker-images>.
>
> Дополнительные сведения о создании собственных образов см. на странице <https://docs.docker.com/engine/tutorials/dockerimages/>.

**Использование репозиториев мультиархитектурных образов**

В репозитории могут содержаться варианты одного и того же образа для разных платформ, например образ Linux и образ Windows. Это позволяет поставщикам, таким как Майкрософт, которые создают базовые образы, создать один репозиторий для охвата нескольких платформ (т. е. Windows и Linux). Например, репозиторий [dotnet/core/aspnet](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) в реестре Docker Hub обеспечивает поддержку Linux и Windows Nano Server при использовании одного и того же имени образа.

При запросе образа [dotnet/core/aspnet](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) с узла Windows извлекается вариант для Windows, а при запросе образа с тем же именем с узла Linux — вариант для Linux.

***Создание базового образа с нуля***

Вы можете создать собственный базовый образ Docker с нуля, как описано в этой [статье](https://docs.docker.com/engine/userguide/eng-image/baseimages/). Этот сценарий, вероятно, будет не самым лучшим для тех, кто только начинает работать с Docker, но если вы хотите задать определенные биты базового образа, это можно сделать.

### <a name="step-3-create-your-custom-docker-images-embedding-your-service-in-it"></a>Шаг 3. Создание пользовательских образов Docker и внедрение в них собственных служб

Для каждой пользовательской службы в приложении необходимо создать связанный образ. Если приложение состоит из одной службы или веб-приложения, достаточно одного образа.

> [!NOTE]
> В рамках "рабочего процесса внешнего цикла DevOps" образы создаются автоматическим процессом сборки при отправке исходного кода в репозиторий Git (непрерывная интеграция), поэтому образы будут создаваться в этой глобальной среде из вашего исходного кода.
>
> Однако перед переходом к этому внешнему циклу необходимо убедиться в том, что приложение Docker действительно работает правильно, чтобы в систему управления версиями (Git и т. д.) не передавался неправильно работающий код.
>
> Поэтому каждый разработчик должен вначале полностью выполнить внутренний цикл, чтобы провести тестирование локально, прежде чем отправлять в систему управления версиями полностью готовую функцию или изменение.

Чтобы создать образ в локальной среде с помощью Dockerfile, можно использовать команду docker build, как показано на рисунке 4-25 (для приложений, состоящих из нескольких контейнеров или служб, можно также выполнить команду `docker-compose up --build`).

![Снимок экрана, показывающий выходные данные команды docker build в консоли.](./media/docker-apps-inner-loop-workflow/run-docker-build-command.png)

**Рис. 4-25**. Выполнение команды docker build

При необходимости вместо непосредственного выполнения команды `docker build` из папки проекта можно сначала создать развертываемую папку с нужными библиотеками .NET, выполнив команду `dotnet publish`, а затем использовать команду `docker build`.

В этом примере создается образ Docker с именем `cesardl/netcore-webapi-microservice-docker:first` (`:first` — это тег, например определенная версия). Этот шаг можно выполнить для каждого пользовательского образа, который требуется создать для составного приложения Docker с несколькими контейнерами.

Вы можете найти образы, имеющиеся в локальном репозитории (на компьютере разработки), с помощью команды docker images, как показано на рисунке 4-26.

![Выходные данные команды docker images в консоли со списком существующих образов.](./media/docker-apps-inner-loop-workflow/view-existing-images-with-docker-images.png)

**Рис. 4-26**. Просмотр существующих образов с помощью команды docker images

### <a name="step-4-define-your-services-in-docker-composeyml-when-building-a-composed-docker-app-with-multiple-services"></a>Шаг 4. Определение служб в файле docker-compose.yml при сборке составного приложения Docker с несколькими службами

В файле `docker-compose.yml` можно задать ряд связанных служб для развертывания в качестве составного приложения с помощью команд развертывания, описанных в следующем разделе.

Создайте этот файл в основной или корневой папке решения. Его содержимое должно быть аналогично приведенному в следующем файле `docker-compose.yml`:

```yml
version: '3.4'
services:
  web:
    build: .
    ports:
     - "81:80"
    volumes:
     - .:/code
    depends_on:
     - redis
  redis:
    image: redis
```

В данном случае в этом файле определены две службы: веб-служба (ваша пользовательская служба) и служба Redis (популярная служба кэширования). Каждая служба развертывается как контейнер, поэтому для каждой из них требуется определенный образ Docker. Для данной веб-службы образ должен выполнять следующие действия:

- выполнять сборку из файла Dockerfile в текущем каталоге;

- переадресовывать предоставленный порт 80 в контейнере на внешний порт 81 на компьютере узла;

- подключать каталог проекта в узле к /code в контейнере, чтобы код можно было изменять, не перестраивая образ;

- связывать веб-службу со службой Redis.

Служба Redis использует [последний общедоступный образ Redis](https://hub.docker.com/_/redis/), извлеченный из реестра Docker Hub. [Redis](https://redis.io/) — это популярная система кэширования для серверных приложений.

### <a name="step-5-build-and-run-your-docker-app"></a>Шаг 5. Сборка и запуск приложения Docker

Если в приложении имеется только один контейнер, его можно запустить путем развертывания на узле Docker (в виртуальной машине или на физическом сервере). Однако если приложение состоит из нескольких служб, его также необходимо *скомпоновать*. Давайте рассмотрим разные варианты.

***Вариант А. Запуск одного контейнера или службы***

Образ Docker можно запустить с помощью команды docker run, как показано в этом примере:

```console
docker run -t -d -p 80:5000 cesardl/netcore-webapi-microservice-docker:first
```

В случае с этим развертыванием запросы, отправляемые на порт 80, перенаправляются на внутренний порт 5000. Теперь приложение ожидает передачи данных через внешний порт 80 на уровне узла.

***Вариант Б. Компоновка и запуск многоконтейнерного приложения***

В большинстве корпоративных сценариев приложение Docker будет состоять из нескольких служб. В таких случаях можно выполнить команду `docker-compose up` (рис. 4-27), которая использует ранее созданный файл docker-compose.yml. В результате ее выполнения развертывается скомпонованное приложение со всеми связанными контейнерами.

![Выходные данные команды docker-compose up в консоли.](./media/docker-apps-inner-loop-workflow/results-docker-compose-up.png)

**Рис. 4-27**. Результаты выполнения команды docker-compose up

После выполнения команды `docker-compose up` приложение и связанные с ним контейнеры развертываются в узле Docker, как показано в представлении виртуальной машины на рисунке 4-28.

![Виртуальная машина, в которой выполняются многоконтейнерные приложения.](./media/docker-apps-inner-loop-workflow/vm-with-docker-containers-deployed.png)

**Рис. 4-28**. Виртуальная машина с развернутыми контейнерами Docker

### <a name="step-6-test-your-docker-application-locally-in-your-local-cd-vm"></a>Шаг 6. Тестирование приложения Docker (в локальной виртуальной машине для непрерывного развертывания)

Этот шаг будет зависеть от того, что делает ваше приложение.

В случае простого веб-API Hello World на основе .NET Core, развернутого в виде единственного контейнера или службы, для доступа к службе достаточно указать TCP-порт из файла Dockerfile.

Если localhost не включен, то для перехода к службе определите IP-адрес компьютера с помощью следующей команды:

```console
docker-machine {IP} {YOUR-CONTAINER-NAME}
```

В узле Docker откройте браузер и перейдите на этот сайт. Вы должны увидеть работающее приложение или службу, как показано на рисунке 4-29.

![Ответ от localhost/API/values в браузере.](./media/docker-apps-inner-loop-workflow/test-docker-app-locally-localhost.png)

**Рис. 4-29**. Локальное тестирование приложения Docker с помощью localhost

Обратите внимание на то, что используется порт 80, однако внутренние запросы перенаправляются на порт 5000, поскольку именно так было выполнено развертывание с помощью команды `docker run`, как описывалось ранее.

Вы можете выполнить тестирование с помощью команды CURL из терминала. Для Docker в Windows IP-адресом по умолчанию является 10.0.75.1, как показано на рисунке 4-30.

![Выходные данные команды curl, выполненной применительно к http://10.0.75.1/API/values, в консоли](./media/docker-apps-inner-loop-workflow/test-docker-app-locally-curl.png)

**Рис. 4-30**. Локальное тестирование приложения Docker с помощью CURL

**Отладка контейнера, запущенного в Docker**

Visual Studio Code поддерживает отладку Docker при использовании Node.js и других платформ, таких как контейнеры .NET Core.

Вы также можете отлаживать контейнеры .NET Core или .NET Framework в Docker с помощью Visual Studio для Windows или Mac, как описано в следующем разделе.

> [!TIP]
> См. сведения об <https://blog.docker.com/2016/07/live-debugging-docker/>отладке контейнеров Docker Node.js<https://docs.microsoft.com/archive/blogs/user_ed/visual-studio-code-new-features-13-big-debugging-updates-rich-object-hover-conditional-breakpoints-node-js-mono-more>.

>[!div class="step-by-step"]
>[Назад](docker-apps-development-environment.md)
>[Вперед](visual-studio-tools-for-docker.md)
