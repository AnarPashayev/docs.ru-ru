---
title: Создание повторно используемых компонентов пользовательского интерфейса с помощью Blazor
description: Узнайте, как создавать повторно используемые компоненты пользовательского интерфейса с помощью Blazor и сравнивать их с элементами управления веб-форм ASP.NET.
author: danroth27
ms.author: daroth
no-loc:
- Blazor
ms.date: 09/18/2019
ms.openlocfilehash: 4fdf062fb719e62b53e47f79db1e93d0bf079350
ms.sourcegitcommit: 0100be20fcf23f61dab672deced70059ed71bb2e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/17/2020
ms.locfileid: "88267689"
---
# <a name="build-reusable-ui-components-with-no-locblazor"></a>Создание повторно используемых компонентов пользовательского интерфейса с помощью Blazor

Одним из замечательных вещей ASP.NET Web Forms является то, как она позволяет инкапсулировать многократно используемые фрагменты кода пользовательского интерфейса в многократно используемые элементы управления ПОЛЬЗОВАТЕЛЬСКОГО интерфейса. Настраиваемые пользовательские элементы управления могут быть определены в разметке с помощью файлов *. ascx* . Кроме того, можно создавать сложные серверные элементы управления в коде с полной поддержкой конструктора.

Blazor также поддерживает инкапсуляцию пользовательского интерфейса через *компоненты*. Компонент:

- — Это автономный фрагмент пользовательского интерфейса.
- Поддерживает собственную логику состояния и отрисовки.
- Может определять обработчики событий пользовательского интерфейса, выполнять привязку к входным данным и управлять собственным жизненным циклом.
- Обычно определяется в файле с *расширением Razor* с помощью синтаксис Razor.

## <a name="an-introduction-to-razor"></a>Введение в Razor

Razor — это облегченный язык создания шаблонов разметки на основе HTML и C#. С помощью Razor можно легко переходить между разметкой и кодом C#, чтобы определить логику отрисовки компонента. При компиляции файла *. Razor* логика отрисовки записывается структурированным образом в классе .NET. Имя скомпилированного класса берется из имени файла *. Razor* . Пространство имен берется из пространства имен по умолчанию для проекта и пути к папке, либо можно явно указать пространство имен с помощью `@namespace` директивы (Подробнее об директивах Razor ниже).

Логика отрисовки компонента создается с помощью обычной разметки HTML с динамической логикой, добавленной с помощью C#. `@`Символ используется для перехода на C#. Razor обычно является разумным, чтобы определить, когда вы переключились обратно на HTML. Например, следующий компонент отображает `<p>` тег с текущим временем:

```razor
<p>@DateTime.Now</p>
```

Чтобы явно указать начало и конец выражения C#, используйте круглые скобки:

```razor
<p>@(DateTime.Now)</p>
```

Razor также упрощает использование потока управления C# в логике отрисовки. Например, можно выполнить условное отображение HTML-кода следующим образом:

```razor
@if (value % 2 == 0)
{
    <p>The value was even.</p>
}
```

Также можно создать список элементов с помощью обычного `foreach` цикла C# следующим образом:

```razor
<ul>
@foreach (var item in items)
{
    <li>@item.Text</li>
}
</ul>
```

Директивы Razor, такие как директивы в ASP.NET Web Forms, управляют многими аспектами компиляции компонента Razor. Примеры включают в себя компонент:

- Пространство имен
- Базовый класс
- Реализованные интерфейсы
- Универсальные параметры
- Импортированные пространства имен
- Маршруты

Директивы Razor начинаются с `@` символа и обычно используются в начале новой строки в начале файла. Например, `@namespace` директива определяет пространство имен компонента:

```razor
@namespace MyComponentNamespace
```

В следующей таблице перечислены различные директивы Razor, используемые в, Blazor и их эквиваленты ASP.NET Web Forms, если они существуют.

|Директива    |Описание|Пример|Эквивалент веб-форм|
|-------------|-----------|-------|--------------------|
|`@attribute` |Добавляет атрибут уровня класса в компонент|`@attribute [Authorize]`|Нет|
|`@code`      |Добавляет члены класса в компонент|`@code { ... }`|`<script runat="server">...</script>`|
|`@implements`|Реализует указанный интерфейс|`@implements IDisposable`|Использование кода программной части|
|`@inherits`  |Наследует от указанного базового класса|`@inherits MyComponentBase`|`<%@ Control Inherits="MyUserControlBase" %>`|
|`@inject`    |Внедряет службу в компонент.|`@inject IJSRuntime JS`|Нет|
|`@layout`    |Задает компонент макета для компонента|`@layout MainLayout`|`<%@ Page MasterPageFile="~/Site.Master" %>`|
|`@namespace` |Задает пространство имен для компонента.|`@namespace MyNamespace`|Нет|
|`@page`      |Указывает маршрут для компонента|`@page "/product/{id}"`|`<%@ Page %>`|
|`@typeparam` |Задает параметр универсального типа для компонента|`@typeparam TItem`|Использование кода программной части|
|`@using`     |Указывает пространство имен для переноса в область|`@using MyComponentNamespace`|Добавление пространства имен в *web.config*|

Компоненты Razor также активно используют *атрибуты директивы* в элементах для управления различными аспектами компиляции компонентов (обработки событий, привязки данных, компонентов & ссылок на элементы и т. д.). Все атрибуты директивы следуют общему универсальному синтаксису, в котором значения в круглых скобках являются необязательными:

```razor
@directive(-suffix(:name))(="value")
```

В следующей таблице перечислены различные атрибуты директив Razor, используемые в Blazor .

|attribute    |Описание|Пример|
|-------------|-----------|-------|
|`@attributes`|Подготавливает к просмотру словарь атрибутов|`<input @attributes="ExtraAttributes" />`|
|`@bind`      |Создает двустороннюю привязку данных    |`<input @bind="username" @bind:event="oninput" />`|
|`@on{event}` |Добавляет обработчик событий для указанного события|`<button @onclick="IncrementCount">Click me!</button>`|
|`@key`       |Задает ключ, используемый алгоритмом сравнения для сохранения элементов в коллекции.|`<DetailsEditor @key="person" Details="person.Details" />`|
|`@ref`       |Захватывает ссылку на компонент или HTML-элемент|`<MyDialog @ref="myDialog" />`|

Различные атрибуты директивы, используемые Blazor ( `@onclick` , `@bind` , и `@ref` т. д.), описаны в разделах ниже и последующих главах.

Многие из синтаксисов, используемых в файлах *. aspx* и *. ascx* , имеют параллельные синтаксисы в Razor. Ниже приведено простое сравнение синтаксиса для веб-форм ASP.NET и Razor.

|Функция                      |веб-формы           |Синтаксис               |Razor         |Синтаксис |
|-----------------------------|--------------------|---------------------|--------------|-------|
|Директивы                   |`<%@ [directive] %>`|`<%@ Page %>`        |`@[directive]`|`@page`|
|Блоки кода                  |`<% %>`             |`<% int x = 123; %>` |`@{ }`        |`@{ int x = 123; }`|
|Выражения<br>(В кодировке HTML)|`<%: %>`            |`<%:DateTime.Now %>` |Полностью `@`<br>Прямая `@()`|`@DateTime.Now`<br>`@(DateTime.Now)`|
|Комментарии                     |`<%-- --%>`         |`<%-- Commented --%>`|`@* *@`       |`@* Commented *@`|
|Привязка данных                 |`<%# %>`            |`<%# Bind("Name") %>`|`@bind`       |`<input @bind="username" />`|

Чтобы добавить члены в класс компонента Razor, используйте `@code` директиву. Этот метод аналогичен использованию `<script runat="server">...</script>` блока в пользовательском элементе управления или странице веб-форм ASP.NET.

```razor
@code {
    int count = 0;

    void IncrementCount()
    {
        count++;
    }
}
```

Поскольку Razor основан на C#, он должен быть скомпилирован из проекта C# (*. csproj*). Файлы *. Razor* нельзя компилировать из проекта Visual Basic (*. vbproj*). Вы по-прежнему можете ссылаться на Visual Basic проекты из Blazor проекта. Обратное тоже верно.

Полный справочник по синтаксис Razor см. в статье [синтаксис Razor Справочник по ASP.NET Core](/aspnet/core/mvc/views/razor).

## <a name="use-components"></a>Использование компонентов

Помимо обычного HTML, компоненты также могут использовать другие компоненты как часть логики отрисовки. Синтаксис использования компонента в Razor подобен использованию пользовательского элемента управления в приложении веб-форм ASP.NET. Компоненты указываются с помощью тега элемента, соответствующего имени типа компонента. Например, можно добавить `Counter` компонент следующим образом:

```razor
<Counter />
```

В отличие от веб-форм ASP.NET, компоненты в Blazor :

- Не используйте префикс элемента (например, `asp:` ).
- Не требовать регистрации на странице или в *web.config*.

Подумайте о таких компонентах Razor, как типы .NET, так как это именно то, что они представляют. Если имеется ссылка на сборку, содержащую компонент, то компонент доступен для использования. Чтобы перенести пространство имен компонента в область, примените `@using` директиву:

```razor
@using MyComponentLib

<Counter />
```

Как видно в проектах по умолчанию Blazor , директивы можно размещать `@using` в файле *_Imports. Razor* , чтобы они были импортированы во все файлы *Razor* в одном и том же каталоге и в дочерних каталогах.

Если пространство имен для компонента не находится в области, можно указать компонент, используя его полное имя типа, как в C#:

```razor
<MyComponentLib.Counter />
```

## <a name="component-parameters"></a>Параметры компонентов

В ASP.NET Web Forms можно передавать параметры и данные в элементы управления с помощью общедоступных свойств. Эти свойства можно задать в разметке с помощью атрибутов или непосредственно в коде. Blazor компоненты работают аналогичным образом, хотя свойства компонентов также должны быть помечены `[Parameter]` атрибутом, который будет считаться параметрами компонента.

Следующий `Counter` компонент определяет параметр компонента `IncrementAmount` с именем, который можно использовать для указания величины `Counter` приращения при каждом нажатии кнопки.

```razor
<h1>Counter</h1>

<p>Current count: @currentCount</p>

<button class="btn btn-primary" @onclick="IncrementCount">Click me</button>

@code {
    int currentCount = 0;

    [Parameter]
    public int IncrementAmount { get; set; } = 1;

    void IncrementCount()
    {
        currentCount+=IncrementAmount;
    }
}
```

Чтобы указать параметр компонента в Blazor , используйте атрибут, как в веб-формах ASP.NET.

```razor
<Counter IncrementAmount="10" />
```

## <a name="event-handlers"></a>Обработчики событий

Веб-формы ASP.NET и Blazor предоставляют модель программирования на основе событий для обработки событий пользовательского интерфейса. Примеры таких событий включают нажатия кнопок и ввод текста. В ASP.NET Web Forms используются серверные элементы управления HTML для работы с событиями пользовательского интерфейса, предоставляемыми моделью DOM, или для выполнения событий, предоставляемых серверными веб-элементами управления. События отображаются на сервере посредством запросов обратной передачи. Рассмотрим следующие примеры кнопок веб-форм:

*Counter. ascx*

```aspx-csharp
<asp:Button ID="ClickMeButton" runat="server" Text="Click me!" OnClick="ClickMeButton_Click" />
```

*Counter.ascx.cs*

```csharp
public partial class Counter : System.Web.UI.UserControl
{
    protected void ClickMeButton_Click(object sender, EventArgs e)
    {
        Console.WriteLine("The button was clicked!");
    }
}
```

В Blazor можно зарегистрировать обработчики для событий пользовательского интерфейса DOM напрямую с помощью атрибутов директивы в форме `@on{event}` . `{event}`Заполнитель представляет имя события. Например, можно прослушивать нажатия кнопок следующим образом:

```razor
<button @onclick="OnClick">Click me!</button>

@code {
    void OnClick()
    {
        Console.WriteLine("The button was clicked!);
    }
}
```

Обработчики событий могут принимать необязательный аргумент, относящийся к конкретному событию, для предоставления дополнительных сведений о событии. Например, события мыши могут принимать `MouseEventArgs` аргумент, но это не обязательно.

```razor
<button @onclick="OnClick">Click me!</button>

@code {
    void OnClick(MouseEventArgs e)
    {
        Console.WriteLine($"Mouse clicked at {e.ScreenX}, {e.ScreenY}.");
    }
}
```

Вместо ссылки на группу методов для обработчика событий можно использовать лямбда-выражение. Лямбда-выражение позволяет закрывать другие значения в области.

```razor
@foreach (var buttonLabel in buttonLabels)
{
    <button @onclick="() => Console.WriteLine($"The {buttonLabel} button was clicked!")">@buttonLabel</button>
}
```

Обработчики событий могут выполняться синхронно или асинхронно. Например, следующий `OnClick` обработчик событий выполняется асинхронно:

```razor
<button @onclick="OnClick">Click me!</button>

@code {
    async Task OnClick()
    {
        var result = await Http.GetAsync("api/values");
    }
}
```

После обработки события компонент подготавливается к просмотру для учета изменений состояния компонента. При использовании асинхронных обработчиков событий компонент подготавливается к просмотру сразу после завершения выполнения обработчика. После завершения асинхронного выполнения компонент *снова* готовится к просмотру `Task` . Этот асинхронный режим выполнения позволяет визуализировать какой-либо соответствующий пользовательский интерфейс во время `Task` выполнения асинхронной операции.

```razor
<button @onclick="ShowMessage">Get message</button>

@if (showMessage)
{
    @if (message == null)
    {
        <p><em>Loading...</em></p>
    }
    else
    {
        <p>The message is: @message</p>
    }
}

@code
{
    bool showMessage = false;
    string message;

    public async Task ShowMessage()
    {
        showMessage = true;
        message = await MessageService.GetMessageAsync();
    }
}
```

Компоненты также могут определять собственные события, определяя параметр компонента типа `EventCallback<TValue>` . Обратные вызовы событий поддерживают все разновидности обработчиков событий пользовательского интерфейса DOM: необязательные аргументы, синхронные или асинхронные, группы методов или лямбда-выражения.

```razor
<button class="btn btn-primary" @onclick="OnClick">Click me!</button>

@code {
    [Parameter]
    public EventCallback<MouseEventArgs> OnClick { get; set; }
}
```

## <a name="data-binding"></a>Привязка данных

Blazor предоставляет простой механизм привязки данных из компонента пользовательского интерфейса к состоянию компонента. Этот подход отличается от функций в ASP.NET Web Forms для привязки данных из источников данных к элементам управления пользовательского интерфейса. Мы обсудим обработку данных из различных источников данных в разделе " [Работа с данными](data.md) ".

Чтобы создать двустороннюю привязку данных от компонента пользовательского интерфейса к состоянию компонента, используйте `@bind` атрибут директивы. В следующем примере значение флажка привязано к `isChecked` полю.

```razor
<input type="checkbox" @bind="isChecked" />

@code {
    bool isChecked;
}
```

При подготовке компонента к просмотру значение флажка устанавливается равным значению `isChecked` поля. Когда пользователь переключает флажок, `onchange` событие срабатывает и `isChecked` для поля задается новое значение. `@bind`Синтаксис в этом случае эквивалентен следующей разметке:

```razor
<input value="@isChecked" @onchange="(UIChangeEventArgs e) => isChecked = e.Value" />
```

Чтобы изменить событие, используемое для привязки, используйте `@bind:event` атрибут.

```razor
<input @bind="text" @bind:event="oninput" />
<p>@text</p>

@code {
    string text;
}
```

Компоненты также могут поддерживать привязку данных к их параметрам. Для привязки данных определите параметр обратного вызова события с тем же именем, что и у привязываемого параметра. В имя добавляется суффикс "Changed".

*PasswordBox. Razor*

```razor
Password: <input
    value="@Password"
    @oninput="OnPasswordChanged"
    type="@(showPassword ? "text" : "password")" />

<label><input type="checkbox" @bind="showPassword" />Show password</label>

@code {
    private bool showPassword;

    [Parameter]
    public string Password { get; set; }

    [Parameter]
    public EventCallback<string> PasswordChanged { get; set; }

    private Task OnPasswordChanged(ChangeEventArgs e)
    {
        Password = e.Value.ToString();
        return PasswordChanged.InvokeAsync(Password);
    }
}
```

Чтобы связать привязку данных с базовым элементом пользовательского интерфейса, установите значение и обработайте событие непосредственно в элементе пользовательского интерфейса, а не с помощью `@bind` атрибута.

Чтобы выполнить привязку к параметру компонента, используйте `@bind-{Parameter}` атрибут, чтобы указать параметр, с которым необходимо выполнить привязку.

```razor
<PasswordBox @bind-Password="password" />

@code {
    string password;
}
```

## <a name="state-changes"></a>Изменения состояния

Если состояние компонента изменилось за пределами обычного пользовательского интерфейса или обратного вызова события, компонент должен вручную сообщить, что он должен быть визуализирован повторно. Чтобы сообщить о том, что состояние компонента изменилось, вызовите `StateHasChanged` метод для компонента.

В приведенном ниже примере компонент отображает сообщение из `AppState` службы, которая может быть обновлена другими частями приложения. Компонент регистрирует свой `StateHasChanged` метод с `AppState.OnChange` событием, чтобы компонент был визуализирован при каждом обновлении сообщения.

```csharp
public class AppState
{
    public string Message { get; }

    // Lets components receive change notifications
    public event Action OnChange;

    public void UpdateMessage(string message)
    {
        Message = message;
        NotifyStateChanged();
    }

    private void NotifyStateChanged() => OnChange?.Invoke();
}
```

```razor
@inject AppState AppState

<p>App message: @AppState.Message</p>

@code {
    protected override void OnInitialized()
    {
        AppState.OnChange += StateHasChanged
    }
}
```

## <a name="component-lifecycle"></a>Жизненный цикл компонента

Платформа веб-форм ASP.NET имеет четко определенные методы жизненного цикла для модулей, страниц и элементов управления. Например, следующий элемент управления реализует обработчики событий для `Init` `Load` `UnLoad` событий жизненного цикла, и:

*Counter.ascx.cs*

```csharp
public partial class Counter : System.Web.UI.UserControl
{
    protected void Page_Init(object sender, EventArgs e) { ... }
    protected void Page_Load(object sender, EventArgs e) { ... }
    protected void Page_UnLoad(object sender, EventArgs e) { ... }
}
```

Blazor компоненты также имеют четко определенный жизненный цикл. Жизненный цикл компонента можно использовать для инициализации состояния компонента и реализации дополнительных поведений компонентов.

Все Blazor методы жизненного цикла компонента имеют как синхронные, так и асинхронные версии. Визуализация компонента является синхронной. Асинхронную логику нельзя выполнять в процессе подготовки компонента к просмотру. Вся Асинхронная логика должна выполняться как часть `async` метода жизненного цикла.

### <a name="oninitialized"></a>Oninitiald

`OnInitialized`Методы и `OnInitializedAsync` используются для инициализации компонента. Обычно компонент инициализируется после его первого отображения. После инициализации компонента он может быть визуализирован несколько раз, прежде чем он будет удален в конечном итоге. `OnInitialized`Метод аналогичен `Page_Load` событию на страницах и элементах управления веб-форм ASP.NET.

```csharp
protected override void OnInitialized() { ... }
protected override async Task OnInitializedAsync() { await ... }
```

### <a name="onparametersset"></a>Onparameters, параметр

`OnParametersSet`Методы и `OnParametersSetAsync` вызываются, когда компонент получил параметры от своего родителя, и значение присваивается свойствам. Эти методы выполняются после инициализации компонента и при *каждом отображении компонента*.

```csharp
protected override void OnParametersSet() { ... }
protected override async Task OnParametersSetAsync() { await ... }
```

### <a name="onafterrender"></a>онафтеррендер

`OnAfterRender`Методы и `OnAfterRenderAsync` вызываются после завершения подготовки компонента к просмотру. Ссылки на элементы и компоненты заполняются в этот момент (Подробнее об этих концепциях см. ниже). В данный момент интерактивное взаимодействие с браузером включено. Взаимодействие с моделью DOM и выполнением JavaScript может безопасно выполняться.

```csharp
protected override void OnAfterRender(bool firstRender)
{
    if (firstRender)
    {
        ...
    }
}
protected override async Task OnAfterRenderAsync(bool firstRender)
{
    if (firstRender)
    {
        await ...
    }
}
```

`OnAfterRender` и `OnAfterRenderAsync` *не вызываются при предварительной отрисовке на сервере*.

`firstRender`Параметр является `true` первым при подготовке компонента к просмотру; в противном случае — значение `false` .

### <a name="idisposable"></a>IDisposable

Blazor компоненты могут реализовать `IDisposable` для удаления ресурсов при удалении компонента из пользовательского интерфейса. Компонент Razor может реализовать с `IDispose` помощью `@implements` директивы:

```razor
@using System
@implements IDisposable

...

@code {
    public void Dispose()
    {
        ...
    }
}
```

## <a name="capture-component-references"></a>Ссылки на компоненты записи

В ASP.NET Web Forms можно управлять экземпляром элемента управления непосредственно в коде, ссылаясь на его идентификатор. В можно Blazor также собрать ссылку на компонент и манипулировать ей, хотя она гораздо менее распространена.

Чтобы записать ссылку на компонент в Blazor , используйте `@ref` атрибут директивы. Значение атрибута должно совпадать с именем настраиваемого поля, имеющего тот же тип, что и компонент, на который указывает ссылка.

```razor
<MyLoginDialog @ref="loginDialog" ... />

@code {
    MyLoginDialog loginDialog;

    void OnSomething()
    {
        loginDialog.Show();
    }
}
```

При подготовке к просмотру родительского компонента поле заполняется экземпляром дочернего компонента. Затем можно вызывать методы в экземпляре компонента или иным образом манипулировать им.

Не рекомендуется манипулировать состоянием компонента непосредственно с помощью ссылок на компоненты. Это предотвращает автоматическое отображение компонента в нужное время.

## <a name="capture-element-references"></a>Запись ссылок на элементы

Blazor компоненты могут записывать ссылки на элемент. В отличие от серверных элементов управления HTML в веб-формах ASP.NET, модель DOM нельзя манипулировать напрямую с помощью ссылки на элемент в Blazor . Blazor обрабатывает большинство взаимодействий DOM с помощью алгоритма сравнения DOM. Захваченные ссылки на элементы в Blazor являются непрозрачными. Однако они используются для передачи определенной ссылки на элемент в вызове взаимодействия JavaScript. Дополнительные сведения о взаимодействии JavaScript см. в разделе [ASP.NET Core Blazor взаимодействие JavaScript](/aspnet/core/blazor/javascript-interop).

## <a name="templated-components"></a>Шаблонные компоненты

В ASP.NET Web Forms можно создавать *шаблонные элементы управления*. Шаблонные элементы управления позволяют разработчику указать часть HTML-кода, используемую для визуализации элемента управления контейнера. Механизм создания шаблонных серверных элементов управления является сложным, но он позволяет создавать эффективные сценарии для отрисовки данных с настраиваемым пользователем способом. Примеры элементов управления с шаблонами включают `Repeater` и `DataList` .

Blazor для компонентов также можно создавать шаблоны путем определения параметров компонентов типа `RenderFragment` или `RenderFragment<T>` . `RenderFragment`Представляет фрагмент разметки Razor, который затем может быть визуализирован компонентом. `RenderFragment<T>`— Это фрагмент разметки Razor, принимающий параметр, который может быть указан при подготовке к просмотру фрагмента прорисовки.

### <a name="child-content"></a>Дочернее содержимое

Blazor компоненты могут записывать свое дочернее содержимое в виде `RenderFragment` и подготавливать содержимое в процессе подготовки к просмотру компонента. Чтобы записать дочернее содержимое, определите параметр компонента типа `RenderFragment` и присвойте ему имя `ChildContent` .

*Чилдконтенткомпонент. Razor*

```razor
<h1>Component with child content</h1>

<div>@ChildContent</div>

@code {
    [Parameter]
    public RenderFragment ChildContent { get; set; }
}
```

После этого родительский компонент может предоставить дочернее содержимое, используя обычные синтаксис Razor.

```razor
<ChildContentComponent>
    <p>The time is @DateTime.Now</p>
</ChildContentComponent>
```

### <a name="template-parameters"></a>Параметры шаблона

Компонент с шаблоном Blazor может также определять несколько параметров компонента типа `RenderFragment` или `RenderFragment<T>` . Параметр для `RenderFragment<T>` можно указать при вызове. Чтобы указать параметр универсального типа для компонента, используйте `@typeparam` директиву Razor.

*Симплелиствиев. Razor*

```razor
@typeparam TItem

@Heading

<ul>
@foreach (var item in Items)
{
    <li>@ItemTemplate(item)</li>
}
</ul>

@code {
    [Parameter]
    public RenderFragment Heading { get; set; }

    [Parameter]
    public RenderFragment<TItem> ItemTemplate { get; set; }

    [Parameter]
    public IEnumerable<TItem> Items { get; set; }
}
```

При использовании компонента шаблона можно указать параметры шаблона с помощью дочерних элементов, соответствующих именам параметров. Аргументы компонента типа, `RenderFragment<T>` переданные как элементы, имеют неявный параметр с именем `context` . Имя этого параметра реализации можно изменить с помощью `Context` атрибута в дочернем элементе. Любые параметры универсального типа можно указать с помощью атрибута, совпадающего с именем параметра типа. Параметр типа будет выведен, если это возможно:

```razor
<SimpleListView Items="messages" TItem="string">
    <Heading>
        <h1>My list</h1>
    </Heading>
    <ItemTemplate Context="message">
        <p>The message is: @message</p>
    </ItemTemplate>
</SimpleListView>
```

Выходные данные этого компонента выглядят следующим образом:

```html
<h1>My list</h1>
<ul>
    <li><p>The message is: message1</p></li>
    <li><p>The message is: message2</p></li>
<ul>
```

## <a name="code-behind"></a>Файл с кодом программной части

BlazorКомпонент обычно создается в одном файле *Razor* . Однако можно разделить код и разметку с помощью файла кода программной части. Чтобы использовать файл компонента, добавьте файл C#, соответствующий имени файла компонента, но с добавленным расширением *CS* (*Counter.Razor.CS*). Используйте файл C#, чтобы определить базовый класс для компонента. Можно присвоить имя базовому классу все, что вам нужно, но обычно имя класса является таким же, как и класс Component, но с `Base` добавленным расширением ( `CounterBase` ). Класс на основе компонентов также должен быть производным от `ComponentBase` . Затем в файле компонента Razor добавьте `@inherits` директиву, чтобы указать базовый класс для компонента ( `@inherits CounterBase` ).

*Счетчик. Razor*

```razor
@inherits CounterBase

<h1>Counter</h1>

<p>Current count: @currentCount</p>

<button @onclick="IncrementCount">Click me</button>
```

*Counter.razor.cs*

```csharp
public class CounterBase : ComponentBase
{
    protected int currentCount = 0;

    protected void IncrementCount()
    {
        currentCount++;
    }
}
```

Видимость членов компонента в базовом классе должна быть `protected` или `public` видима для класса Component.

## <a name="additional-resources"></a>Дополнительные ресурсы

Приведенная выше функция не является исчерпывающей облечения всех аспектов Blazor компонентов. Дополнительные сведения о [создании и использовании ASP.NET Core компонентов Razor](/aspnet/core/blazor/components)см Blazor . в документации.

>[!div class="step-by-step"]
>[Назад](app-startup.md)
>[Вперед](pages-routing-layouts.md)
