---
title: Создание повторно используемых компонентов пользовательского интерфейса с помощью Блазор
description: Узнайте, как создавать повторно используемые компоненты пользовательского интерфейса с помощью Блазор и сравнить их с элементами управления веб-форм ASP.NET.
author: danroth27
ms.author: daroth
ms.date: 09/18/2019
ms.openlocfilehash: 5e5ca128bea2e77d795cede17df73963d9b49a48
ms.sourcegitcommit: 30a558d23e3ac5a52071121a52c305c85fe15726
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/25/2019
ms.locfileid: "75337401"
---
# <a name="build-reusable-ui-components-with-blazor"></a>Создание повторно используемых компонентов пользовательского интерфейса с помощью Блазор

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

Одним из замечательных вещей ASP.NET Web Forms является то, как она позволяет инкапсулировать многократно используемые фрагменты кода пользовательского интерфейса в многократно используемые элементы управления ПОЛЬЗОВАТЕЛЬСКОГО интерфейса. Настраиваемые пользовательские элементы управления могут быть определены в разметке с помощью файлов *. ascx* . Кроме того, можно создавать сложные серверные элементы управления в коде с полной поддержкой конструктора.

Блазор также поддерживает инкапсуляцию пользовательского интерфейса через *компоненты*. Компонент:

- — Это автономный фрагмент пользовательского интерфейса.
- Поддерживает собственную логику состояния и отрисовки.
- Может определять обработчики событий пользовательского интерфейса, выполнять привязку к входным данным и управлять собственным жизненным циклом.
- Обычно определяется в файле с *расширением Razor* с помощью синтаксис Razor.

## <a name="an-introduction-to-razor"></a>Введение в Razor

Razor — это облегченный язык создания шаблонов разметки на основе HTML C#и. С помощью Razor можно легко переходить между разметкой C# и кодом, чтобы определить логику отрисовки компонента. При компиляции файла *. Razor* логика отрисовки записывается структурированным образом в классе .NET. Имя скомпилированного класса берется из имени файла *. Razor* . Пространство имен берется из пространства имен по умолчанию для проекта и пути к папке, либо можно явно указать пространство имен с помощью директивы `@namespace` (см. дополнительные директивы Razor ниже).

Логика отрисовки компонента создается с помощью обычной разметки HTML с динамической логикой, C#добавленной с помощью. Символ `@` используется для перехода в C#. Razor обычно является разумным, чтобы определить, когда вы переключились обратно на HTML. Например, следующий компонент визуализирует `<p>` тег с текущим временем:

```razor
<p>@DateTime.Now</p>
```

Чтобы явно указать начало и конец C# выражения, используйте круглые скобки:

```razor
<p>@(DateTime.Now)</p>
```

Razor также упрощает использование C# потока управления в логике отрисовки. Например, можно выполнить условное отображение HTML-кода следующим образом:

```razor
@if (value % 2 == 0)
{
    <p>The value was even.</p>
}
```

Вы также можете создать список элементов с помощью обычного C# цикла `foreach` следующим образом:

```razor
<ul>
@foreach (var item in items)
{
    <li>item.Text</li>
}
</ul>
```

Директивы Razor, такие как директивы в ASP.NET Web Forms, управляют многими аспектами компиляции компонента Razor. Примеры включают в себя компонент:

- Пространство имен
- Базовый класс
- Реализованные интерфейсы
- Универсальные параметры
- Импортированные пространства имен
- Маршруты

Директивы Razor начинаются с `@` символа и обычно используются в начале новой строки в начале файла. Например, директива `@namespace` определяет пространство имен компонента:

```razor
@namespace MyComponentNamespace
```

В следующей таблице перечислены различные директивы Razor, используемые в Блазор, и их эквиваленты ASP.NET веб-форм, если они существуют.

|Directive    |Описание|Пример|Эквивалент веб-форм|
|-------------|-----------|-------|--------------------|
|`@attribute` |Добавляет атрибут уровня класса в компонент|`@attribute [Authorize]`|Нет|
|`@code`      |Добавляет члены класса в компонент|`@code { ... }`|`<script runat="server">...</script>`|
|`@implements`|Реализует указанный интерфейс|`@implements IDisposable`|Использование кода программной части|
|`@inherits`  |Наследует от указанного базового класса|`@inherits MyComponentBase`|`<%@ Control Inherits="MyUserControlBase" %>`|
|`@inject`    |Внедряет службу в компонент.|`@inject IJSRuntime JS`|Нет|
|`@layout`    |Задает компонент макета для компонента|`@layout MainLayout`|`<%@ Page MasterPageFile="~/Site.Master" %>`|
|`@namespace` |Задает пространство имен для компонента.|`@namespace MyNamespace`|Нет|
|`@page`      |Указывает маршрут для компонента|`@page "/product/{id}"`|`<%@ Page %>`|
|`@typeparam` |Задает параметр универсального типа для компонента|`@typeparam TItem`|Использование кода программной части|
|`@using`     |Указывает пространство имен для переноса в область|`@using MyComponentNamespace`|Добавление пространства имен в *файл Web. config*|

Компоненты Razor также активно используют *атрибуты директивы* в элементах для управления различными аспектами компиляции компонентов (обработки событий, привязки данных, компонентов & ссылок на элементы и т. д.). Все атрибуты директивы следуют общему универсальному синтаксису, в котором значения в круглых скобках являются необязательными:

```razor
@directive(-suffix(:name))(="value")
```

В следующей таблице приведены различные атрибуты директив Razor, используемые в Блазор.

|Атрибут    |Описание|Пример|
|-------------|-----------|-------|
|`@attributes`|Подготавливает к просмотру словарь атрибутов|`<input @attributes="ExtraAttributes" />`|
|`@bind`      |Создает двустороннюю привязку данных    |`<input @bind="username" @bind:event="oninput" />`|
|`@on{event}` |Добавляет обработчик событий для указанного события|`<button @onclick="IncrementCount">Click me!</button>`|
|`@key`       |Задает ключ, используемый алгоритмом сравнения для сохранения элементов в коллекции.|`<DetailsEditor @key="person" Details="person.Details" />`|
|`@ref`       |Захватывает ссылку на компонент или HTML-элемент|`<MyDialog @ref="myDialog" />`|

Различные атрибуты директивы, используемые Блазор (`@onclick`, `@bind`, `@ref`и т. д.), описаны в разделах ниже и последующих главах.

Многие из синтаксисов, используемых в файлах *. aspx* и *. ascx* , имеют параллельные синтаксисы в Razor. Ниже приведено простое сравнение синтаксиса для веб-форм ASP.NET и Razor.

|Функция                      |веб-формы           |Синтаксис               |Razor         |Синтаксис |
|-----------------------------|--------------------|---------------------|--------------|-------|
|Директивы                   |`<%@ [directive] %>`|`<%@ Page %>`        |`@[directive]`|`@page`|
|Блоки кода                  |`<% %>`             |`<% int x = 123; %>` |`@{ }`        |`@{ int x = 123; }`|
|Выражения<br>(В кодировке HTML)|`<%: %>`            |`<%:DateTime.Now %>` |Неявные: `@`<br>Явное: `@()`|`@DateTime.Now`<br>`@(DateTime.Now)`|
|Comments                     |`<%-- --%>`         |`<%-- Commented --%>`|`@* *@`       |`@* Commented *@`|
|привязка данных,                 |`<%# %>`            |`<%# Bind("Name") %>`|`@bind`       |`<input @bind="username" />`|

Чтобы добавить члены в класс компонента Razor, используйте директиву `@code`. Этот метод аналогичен использованию блока `<script runat="server">...</script>` в пользовательском элементе управления или странице веб-форм ASP.NET.

```razor
@code {
    int count = 0;

    void IncrementCount()
    {
        count++;
    }
}
```

Поскольку Razor основан на C#, он должен быть скомпилирован из C# проекта (*CSPROJ*). Файлы *. Razor* нельзя компилировать из проекта Visual Basic ( *. vbproj*). Вы по-прежнему можете ссылаться на Visual Basic проекты из проекта Блазор. Обратное тоже верно.

Полный справочник по синтаксис Razor см. в статье [синтаксис Razor Справочник по ASP.NET Core](/aspnet/core/mvc/views/razor).

## <a name="use-components"></a>Использование компонентов

Помимо обычного HTML, компоненты также могут использовать другие компоненты как часть логики отрисовки. Синтаксис использования компонента в Razor подобен использованию пользовательского элемента управления в приложении веб-форм ASP.NET. Компоненты указываются с помощью тега элемента, соответствующего имени типа компонента. Например, можно добавить `Counter` компонент, например:

```razor
<Counter />
```

В отличие от веб-форм ASP.NET, компоненты в Блазор:

- Не используйте префикс элемента (например, `asp:`).
- Не требовать регистрации на странице или в *файле Web. config*.

Подумайте о таких компонентах Razor, как типы .NET, так как это именно то, что они представляют. Если имеется ссылка на сборку, содержащую компонент, то компонент доступен для использования. Чтобы перенести пространство имен компонента в область, примените директиву `@using`:

```razor
@using MyComponentLib

<Counter />
```

Как видно в проектах Блазор по умолчанию, часто `@using` директивы помещаются в файл *_Imports. Razor* , чтобы они были импортированы во все файлы *Razor* в одном и том же каталоге и в дочерних каталогах.

Если пространство имен для компонента не находится в области, можно указать компонент, используя его полное имя типа, как в C#следующих случаях:

```razor
<MyComponentLib.Counter />
```

## <a name="component-parameters"></a>Параметры компонентов

В ASP.NET Web Forms можно передавать параметры и данные в элементы управления с помощью общедоступных свойств. Эти свойства можно задать в разметке с помощью атрибутов или непосредственно в коде. Компоненты блазор работают аналогичным образом, хотя свойства компонентов также должны быть помечены атрибутом `[Parameter]`, чтобы считаться параметрами компонента.

Следующий `Counter` компонент определяет параметр компонента с именем `IncrementAmount`, который можно использовать для указания величины приращения `Counter` при каждом нажатии кнопки.

```razor
<h1>Counter</h1>

<p>Current count: @currentCount</p>

<button class="btn btn-primary" @onclick="IncrementCount">Click me</button>

@code {
    int currentCount = 0;

    [Parameter]
    public int IncrementAmount { get; set; } = 1;

    void IncrementCount()
    {
        currentCount+=IncrementAmount;
    }
}
```

Чтобы указать параметр компонента в Блазор, используйте атрибут, как в ASP.NET Web Forms:

```razor
<Counter IncrementAmount="10" />
```

## <a name="event-handlers"></a>Обработчики событий

Как веб-формы ASP.NET, так и Блазор предоставляют модель программирования на основе событий для обработки событий пользовательского интерфейса. Примеры таких событий включают нажатия кнопок и ввод текста. В ASP.NET Web Forms используются серверные элементы управления HTML для работы с событиями пользовательского интерфейса, предоставляемыми моделью DOM, или для выполнения событий, предоставляемых серверными веб-элементами управления. События отображаются на сервере посредством запросов обратной передачи. Рассмотрим следующие примеры кнопок веб-форм:

*Counter. ascx*

```aspx-csharp
<asp:Button ID="ClickMeButton" runat="server" Text="Click me!" OnClick="ClickMeButton_Click" />
```

*Counter.ascx.cs*

```csharp
public partial class Counter : System.Web.UI.UserControl
{
    protected void ClickMeButton_Click(object sender, EventArgs e)
    {
        Console.WriteLine("The button was clicked!");
    }
}
```

В Блазор можно зарегистрировать обработчики для событий пользовательского интерфейса DOM напрямую с помощью атрибутов директивы в форме `@on{event}`. Заполнитель `{event}` представляет имя события. Например, можно прослушивать нажатия кнопок следующим образом:

```razor
<button @onclick="OnClick">Click me!</button>

@code {
    void OnClick()
    {
        Console.WriteLine("The button was clicked!);
    }
}
```

Обработчики событий могут принимать необязательный аргумент, относящийся к конкретному событию, для предоставления дополнительных сведений о событии. Например, события мыши могут принимать `MouseEventArgs` аргумент, но это не обязательно.

```razor
<button @onclick="OnClick">Click me!</button>

@code {
    void OnClick(MouseEventArgs e)
    {
        Console.WriteLine($"Mouse clicked at {e.ScreenX}, {e.ScreenY}.");
    }
}
```

Вместо ссылки на группу методов для обработчика событий можно использовать лямбда-выражение. Лямбда-выражение позволяет закрывать другие значения в области.

```razor
@foreach (var buttonLabel in buttonLabels)
{
    <button @onclick="() => Console.WriteLine($"The {buttonLabel} button was clicked!")">@buttonLabel</button>
}
```

Обработчики событий могут выполняться синхронно или асинхронно. Например, следующий обработчик событий `OnClick` выполняется асинхронно:

```razor
<button @onclick="OnClick">Click me!</button>

@code {
    async Task OnClick()
    {
        var result = await Http.GetAsync("api/values");
    }
}
```

После обработки события компонент подготавливается к просмотру для учета изменений состояния компонента. При использовании асинхронных обработчиков событий компонент подготавливается к просмотру сразу после завершения выполнения обработчика. После завершения асинхронного `Task` компонент *снова* готовится к просмотру. Этот асинхронный режим выполнения позволяет визуализировать какой-либо соответствующий пользовательский интерфейс во время выполнения асинхронного `Task`.

```razor
<button @onclick="Get message">Get message</button>

@if (showMessage)
{
    @if (message == null)
    {
        <p><em>Loading...</em></p>
    }
    else
    {
        <p>The message is: @message</p>
    }
}

@code
{
    bool showMessage = false;
    string message;

    public async Task ShowMessage()
    {
        showMessage = true;
        message = await MessageService.GetMessageAsync();
    }
}
```

Компоненты также могут определять собственные события, определяя параметр компонента типа `EventCallback<TValue>`. Обратные вызовы событий поддерживают все разновидности обработчиков событий пользовательского интерфейса DOM: необязательные аргументы, синхронные или асинхронные, группы методов или лямбда-выражения.

```razor
<button class="btn btn-primary" @onclick="OnClick">Click me!</button>

@code {
    [Parameter]
    public EventCallback<MouseEventArgs> OnClick { get; set; }
}
```

## <a name="data-binding"></a>привязка данных,

Блазор предоставляет простой механизм привязки данных из компонента пользовательского интерфейса к состоянию компонента. Этот подход отличается от функций в ASP.NET Web Forms для привязки данных из источников данных к элементам управления пользовательского интерфейса. Мы обсудим обработку данных из различных источников данных в разделе " [Работа с данными](data.md) ".

Чтобы создать двустороннюю привязку данных от компонента пользовательского интерфейса к состоянию компонента, используйте атрибут директивы `@bind`. В следующем примере значение флажка привязано к полю `isChecked`.

```razor
<input type="checkbox" @bind="isChecked" />

@code {
    bool isChecked;
}
```

При подготовке компонента к просмотру значение флажка устанавливается равным значению поля `isChecked`. Когда пользователь переключает флажок, срабатывает событие `onchange`, и в поле `isChecked` задается новое значение. Синтаксис `@bind` в этом случае эквивалентен следующей разметке:

```razor
<input value="@isChecked" @onchange="(UIChangeEventArgs e) => isChecked = e.Value" />
```

Чтобы изменить событие, используемое для привязки, используйте атрибут `@bind:event`.

```razor
<input @bind="text" @bind:event="oninput" />
<p>@text</p>

@code {
    string text;
}
```

Компоненты также могут поддерживать привязку данных к их параметрам. Для привязки данных определите параметр обратного вызова события с тем же именем, что и у привязываемого параметра. В имя добавляется суффикс "Changed".

*PasswordBox. Razor*

```razor
Password: <input
    value="@Password"
    @oninput="OnPasswordChanged"
    type="@(showPassword ? "text" : "password")" />

<label><input type="checkbox" @bind="showPassword" />Show password</label>

@code {
    private bool showPassword;

    [Parameter]
    public string Password { get; set; }

    [Parameter]
    public EventCallback<string> PasswordChanged { get; set; }

    private Task OnPasswordChanged(ChangeEventArgs e)
    {
        Password = e.Value.ToString();
        return PasswordChanged.InvokeAsync(Password);
    }
}
```

Чтобы связать привязку данных с базовым элементом пользовательского интерфейса, установите значение и обработайте событие непосредственно в элементе пользовательского интерфейса, а не с помощью атрибута `@bind`.

Чтобы выполнить привязку к параметру компонента, используйте атрибут `@bind-{Parameter}`, чтобы указать параметр, с которым необходимо выполнить привязку.

```razor
<PasswordBox @bind-Password="password" />

@code {
    string password;
}
```

## <a name="state-changes"></a>Изменения состояния

Если состояние компонента изменилось за пределами обычного пользовательского интерфейса или обратного вызова события, компонент должен вручную сообщить, что он должен быть визуализирован повторно. Чтобы сообщить о том, что состояние компонента изменилось, вызовите метод `StateHasChanged` для компонента.

В приведенном ниже примере компонент отображает сообщение из службы `AppState`, которая может быть обновлена другими частями приложения. Компонент регистрирует свой метод `StateHasChanged` с событием `AppState.OnChange`, чтобы компонент был подготовлен при каждом обновлении сообщения.

```csharp
public class AppState
{
    public string Message { get; }

    // Lets components receive change notifications
    public event Action OnChange;

    public void UpdateMessage(string message)
    {
        shortlist.Add(itinerary);
        NotifyStateChanged();
    }

    private void NotifyStateChanged() => OnChange?.Invoke();
}
```

```razor
@inject AppState AppState

<p>App message: @AppState.Message</p>

@code {
    protected override void OnInitialized()
    {
        AppState.OnChange += StateHasChanged
    }
}
```

## <a name="component-lifecycle"></a>Жизненный цикл компонента

Платформа веб-форм ASP.NET имеет четко определенные методы жизненного цикла для модулей, страниц и элементов управления. Например, следующий элемент управления реализует обработчики событий для событий жизненного цикла `Init`, `Load`и `UnLoad`:

*Counter.ascx.cs*

```csharp
public partial class Counter : System.Web.UI.UserControl
{
    protected void Page_Init(object sender, EventArgs e) { ... }
    protected void Page_Load(object sender, EventArgs e) { ... }
    protected void Page_UnLoad(object sender, EventArgs e) { ... }
}
```

Компоненты блазор также имеют четко определенный жизненный цикл. Жизненный цикл компонента можно использовать для инициализации состояния компонента и реализации дополнительных поведений компонентов.

Все методы жизненного цикла компонента Блазор имеют как синхронные, так и асинхронные версии. Визуализация компонента является синхронной. Асинхронную логику нельзя выполнять в процессе подготовки компонента к просмотру. Вся Асинхронная логика должна выполняться как часть метода жизненного цикла `async`.

### <a name="oninitialized"></a>Oninitiald

Методы `OnInitialized` и `OnInitializedAsync` используются для инициализации компонента. Обычно компонент инициализируется после его первого отображения. После инициализации компонента он может быть визуализирован несколько раз, прежде чем он будет удален в конечном итоге. Метод `OnInitialized` аналогичен событию `Page_Load` в ASP.NET страницах и элементах управления веб-форм.

```csharp
protected override void OnInitialized() { ... }
protected override async Task OnInitializedAsync() { await ... }
```

### <a name="onparametersset"></a>Onparameters, параметр

Методы `OnParametersSet` и `OnParametersSetAsync` вызываются, когда компонент получил параметры от родительского элемента, и значение присваиваются свойствам. Эти методы выполняются после инициализации компонента и при *каждом отображении компонента*.

```csharp
protected override void OnParametersSet() { ... }
protected override async Task OnParametersSetAsync() { await ... }
```

### <a name="onafterrender"></a>онафтеррендер

Методы `OnAfterRender` и `OnAfterRenderAsync` вызываются после завершения подготовки компонента к просмотру. Ссылки на элементы и компоненты заполняются в этот момент (Подробнее об этих концепциях см. ниже). В данный момент интерактивное взаимодействие с браузером включено. Взаимодействие с моделью DOM и выполнением JavaScript может безопасно выполняться.

```csharp
protected override void OnAfterRender(bool firstRender)
{
    if (firstRender)
    {
        ...
    }
}
protected override async Task OnAfterRenderAsync(bool firstRender)
{
    if (firstRender)
    {
        await ...
    }
}
```

`OnAfterRender` и `OnAfterRenderAsync` *не вызываются при предварительной отрисовке на сервере*.

Параметр `firstRender` `true` при первом отображении компонента; в противном случае его значение — `false`.

### <a name="idisposable"></a>IDisposable

Компоненты блазор могут реализовывать `IDisposable` для удаления ресурсов, когда компонент удаляется из пользовательского интерфейса. Компонент Razor может реализовать `IDispose` с помощью директивы `@implements`:

```razor
@using System
@implements IDisposable

...

@code {
    public void Dispose()
    {
        ...
    }
}
```

## <a name="capture-component-references"></a>Ссылки на компоненты записи

В ASP.NET Web Forms можно управлять экземпляром элемента управления непосредственно в коде, ссылаясь на его идентификатор. В Блазор также можно захватить ссылку на компонент и управлять ей, хотя он гораздо менее распространен.

Чтобы записать ссылку на компонент в Блазор, используйте атрибут директивы `@ref`. Значение атрибута должно совпадать с именем настраиваемого поля, имеющего тот же тип, что и компонент, на который указывает ссылка.

```razor
<MyLoginDialog @ref="loginDialog" ... />

@code {
    MyLoginDialog loginDialog;

    void OnSomething()
    {
        loginDialog.Show();
    }
}
```

При подготовке к просмотру родительского компонента поле заполняется экземпляром дочернего компонента. Затем можно вызывать методы в экземпляре компонента или иным образом манипулировать им.

Не рекомендуется манипулировать состоянием компонента непосредственно с помощью ссылок на компоненты. Это предотвращает автоматическое отображение компонента в нужное время.

## <a name="capture-element-references"></a>Запись ссылок на элементы

Компоненты блазор могут записывать ссылки на элемент. В отличие от серверных элементов управления HTML в веб-формах ASP.NET, модель DOM нельзя манипулировать напрямую с помощью ссылки на элемент в Блазор. Блазор обрабатывает большинство взаимодействий DOM с помощью алгоритма сравнения DOM. Захваченные ссылки на элементы в Блазор являются непрозрачными. Однако они используются для передачи определенной ссылки на элемент в вызове взаимодействия JavaScript. Дополнительные сведения о взаимодействии JavaScript см. в разделе [ASP.NET Core Блазор JavaScript Interop](/aspnet/core/blazor/javascript-interop).

## <a name="templated-components"></a>Шаблонные компоненты

В ASP.NET Web Forms можно создавать *шаблонные элементы управления*. Шаблонные элементы управления позволяют разработчику указать часть HTML-кода, используемую для визуализации элемента управления контейнера. Механизм создания шаблонных серверных элементов управления является сложным, но он позволяет создавать эффективные сценарии для отрисовки данных с настраиваемым пользователем способом. Примеры элементов управления с шаблонами включают `Repeater` и `DataList`.

Компоненты блазор также можно шаблонировать путем определения параметров компонентов типа `RenderFragment` или `RenderFragment<T>`. `RenderFragment` представляет фрагмент разметки Razor, который затем может быть визуализирован компонентом. `RenderFragment<T>` — это фрагмент разметки Razor, принимающий параметр, который можно указать при подготовке к просмотру фрагмента прорисовки.

### <a name="child-content"></a>Дочернее содержимое

Компоненты блазор могут записывать свое дочернее содержимое в виде `RenderFragment` и отображать его в процессе подготовки к просмотру компонента. Чтобы записать дочернее содержимое, определите параметр компонента типа `RenderFragment` и присвойте ему имя `ChildContent`.

*Чилдконтенткомпонент. Razor*

```razor
<h1>Component with child content</h1>

<div>@ChildContent</div>

@code {
    [Parameter]
    public RenderFragment ChildContent { get; set; }
}
```

После этого родительский компонент может предоставить дочернее содержимое, используя обычные синтаксис Razor.

```razor
<ChildContentComponent>
    <p>The time is @DateTime.Now</p>
</ChildContentComponent>
```

### <a name="template-parameters"></a>Параметры шаблона

Шаблонный компонент Блазор также может определять несколько параметров компонента типа `RenderFragment` или `RenderFragment<T>`. Параметр для `RenderFragment<T>` можно указать при его вызове. Чтобы указать параметр универсального типа для компонента, используйте директиву `@typeparam` Razor.

*Симплелиствиев. Razor*

```razor
@typeparam TItem

@Heading

<ul>
@foreach (var item in Items)
{
    <li>@ItemTemplate(item)</li>
}
</ul>

@code {
    [Parameter]
    public RenderFragment Heading { get; set; }

    [Parameter]
    public RenderFragment<TItem> ItemTemplate { get; set; }

    [Parameter]
    public IEnumerable<TItem> Items { get; set; }
}
```

При использовании компонента шаблона можно указать параметры шаблона с помощью дочерних элементов, соответствующих именам параметров. Аргументы компонента типа `RenderFragment<T>` переданные как элементы, имеют неявный параметр с именем `context`. Имя этого параметра реализации можно изменить с помощью атрибута `Context` дочернего элемента. Любые параметры универсального типа можно указать с помощью атрибута, совпадающего с именем параметра типа. Параметр типа будет выведен, если это возможно:

```razor
<SimpleListView Items="messages" TItem="string">
    <Heading>
        <h1>My list</h1>
    </Heading>
    <ItemTemplate Content="message">
        <p>The message is: @message</p>
    </ItemTemplate>
</SimpleListView>
```

Выходные данные этого компонента выглядят следующим образом:

```html
<h1>My list</h1>
<ul>
    <li>The message is: message1</li>
    <li>The message is: message2</li>
<ul>
```

## <a name="code-behind"></a>Код программной части

Компонент Блазор обычно создается в одном файле *Razor* . Однако можно разделить код и разметку с помощью файла кода программной части. Чтобы использовать файл компонента, добавьте C# файл, соответствующий имени файла компонента, но с добавленным расширением *CS* (*Counter.Razor.CS*). Используйте C# файл, чтобы определить базовый класс для компонента. Можно присвоить имя базовому классу все, что вам нужно, но обычно имя класса является таким же, как и класс Component, но с добавленным расширением `Base` (`CounterBase`). Класс на основе компонентов также должен быть производным от `ComponentBase`. Затем в файле компонента Razor добавьте директиву `@inherits`, чтобы указать базовый класс для компонента (`@inherits CounterBase`).

*Счетчик. Razor*

```razor
@inherits CounterBase

<h1>Counter</h1>

<p>Current count: @currentCount</p>

<button @onclick="IncrementCount">Click me</button>
```

*Counter.razor.cs*

```csharp
public class CounterBase : ComponentBase
{
    protected int currentCount = 0;

    protected void IncrementCount()
    {
        currentCount++;
    }
}
```

Видимость членов компонента в базовом классе должна быть `protected` или `public`, чтобы быть видимыми для класса Component.

## <a name="additional-resources"></a>Дополнительные ресурсы

Предыдущая не является исчерпывающей облечения всех аспектов компонентов Блазор. Дополнительные сведения о [создании и использовании ASP.NET Core компонентов Razor](/aspnet/core/blazor/components)см. в документации по блазор.

>[!div class="step-by-step"]
>[Назад](app-startup.md)
>[Вперед](pages-routing-layouts.md)
