---
title: Доступ к данным и управление ими
description: Узнайте, как получить доступ к данным и работать с ними в веб-формах ASP.NET и Blazor .
author: csharpfritz
ms.author: jefritz
no-loc:
- Blazor
ms.date: 09/08/2020
ms.openlocfilehash: 84e12f9890351fa46cd7ed0ee31db449f3c55e59
ms.sourcegitcommit: 0c3ce6d2e7586d925a30f231f32046b7b3934acb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/08/2020
ms.locfileid: "89515856"
---
# <a name="work-with-data"></a>Работа с данными

Доступ к данным — это основа приложения веб-форм ASP.NET. Что происходит с этими данными при создании форм для Интернета? С помощью веб-форм существовало несколько методов доступа к данным, которые можно использовать для взаимодействия с базой данных:

- обозревателе решений
- ADO.NET
- Entity Framework

Источники данных — это элементы управления, которые можно разместить на странице веб-форм и настроить аналогично другим элементам управления. Visual Studio предоставляет удобный набор диалоговых окон для настройки и привязки элементов управления к страницам веб-форм. Разработчики, которые пользуются «низким кодом» или «без кода», предпочитают этот метод при первом выпуске веб-форм.

![обозревателе решений](media/data/datasources.png)

ADO.NET — это подход низкого уровня для взаимодействия с базой данных. Приложения могут создать подключение к базе данных с помощью команд, наборов записей и наборов данных для взаимодействия. Затем результаты могут быть привязаны к полям на экране без большого объема кода. Недостаток этого подхода заключается в том, что каждый набор объектов ADO.NET ( `Connection` , `Command` и `Recordset` ) был привязан к библиотекам, предоставленным поставщиком базы данных. Использование этих компонентов сделало код жестким и сложным при переходе на другую базу данных.

## <a name="entity-framework"></a>Entity Framework

Entity Framework (EF) — это инфраструктура объектно-реляционного сопоставления с открытым исходным кодом, поддерживаемая .NET Foundation. Первоначально выпущенная с .NET Framework, EF позволяет создавать код для подключений к базе данных, схем хранилища и взаимодействий. Эта абстракция позволяет сосредоточиться на бизнес-правилах приложения и разрешать управление базой данных с помощью доверенного администратора базы данных. В .NET Core можно использовать обновленную версию EF, именуемую EF Core. EF Core помогает создавать и обслуживать взаимодействия между кодом и базой данных с помощью ряда команд, доступных для вас при помощи `dotnet ef` программы командной строки. Давайте рассмотрим несколько примеров для работы с базой данных.

### <a name="ef-code-first"></a>EF Code First

Чтобы быстро приступить к созданию взаимодействия с базой данных, начните с объектов класса, с которыми вы хотите работать. EF предоставляет средство, помогающее создать соответствующий код базы данных для классов. Этот подход называется разработкой «Code First». Рассмотрим следующий `Product` класс для примера приложения витрины, которое мы хотим хранить в реляционной базе данных, например Microsoft SQL Server.

```csharp
public class Product
{
    public int Id { get; set; }

    [Required]
    public string Name { get; set; }

    [MaxLength(4000)]
    public string Description { get; set; }

    [Range(0, 99999,99)]
    [DataType(DataType.Currency)]
    public decimal Price { get; set; }
}
```

У продукта есть первичный ключ и три дополнительных поля, которые будут созданы в нашей базе данных:  

- EF будет обозначать `Id` свойство как первичный ключ по соглашению.
- `Name` будет храниться в столбце, настроенном для хранения текста. Атрибут, определяющий `[Required]` это свойство, добавит `not null` ограничение, чтобы обеспечить соблюдение этого объявленного поведения свойства.
- `Description` будет храниться в столбце, настроенном для хранения текста, и иметь максимальную длину, настроенную на 4000 символов в соответствии с `[MaxLength]` атрибутом. Схема базы данных будет настроена с использованием столбца с именем `MaxLength` Data Type `varchar(4000)` .
- `Price`Свойство будет храниться как валюта. `[Range]`Атрибут создаст соответствующие ограничения для предотвращения хранения данных за пределами минимального и максимального числа объявленных значений.

Нам нужно добавить этот `Product` класс в класс контекста базы данных, который определяет операции подключения и преобразования в нашей базе данных.

```csharp
public class MyDbContext : DbContext
{
    public DbSet<Product> Products { get; set; }
}
```

`MyDbContext`Класс предоставляет одно свойство, определяющее доступ и перевод для `Product` класса.  Приложение настраивает этот класс для взаимодействия с базой данных, используя следующие записи в `Startup` `ConfigureServices` методе класса:

```csharp
services.AddDbContext<MyDbContext>(options =>
    options.UseSqlServer("MY DATABASE CONNECTION STRING"));
```

Приведенный выше код будет подключаться к SQL Server базе данных с указанной строкой подключения. Строку подключения можно поместить в *appsettings.jsдля* файла, переменных среды или других мест хранения конфигурации и соответствующим образом заменить эту внедренную строку.

Затем можно создать таблицу базы данных, подходящую для этого класса, с помощью следующих команд:

```dotnetcli
dotnet ef migrations add 'Create Product table'
dotnet ef database update
```

Первая команда определяет изменения, внесенные в схему базы данных в качестве новой миграции EF `Create Product table` .  Миграция определяет способ применения и удаления новых изменений базы данных.

После применения вы получите простую `Product` таблицу в базе данных и некоторые новые классы, добавленные в проект, помогающие управлять схемой базы данных.  Созданные классы по умолчанию можно найти в новой папке, именуемой *миграцией*.  При внесении изменений в `Product` класс или добавлении дополнительных связанных классов для взаимодействия с базой данных необходимо снова выполнить команды командной строки с новым именем миграции.  Эта команда создаст другой набор классов миграции для обновления схемы базы данных.

### <a name="ef-database-first"></a>EF Database First

Для существующих баз данных можно создать классы для EF Core с помощью программ командной строки .NET. Для формирования шаблонов классов используйте разновидность следующей команды:

```dotnetcli
dotnet ef dbcontext scaffold "CONNECTION STRING" Microsoft.EntityFrameworkCore.SqlServer -c MyDbContext -t Product -t Customer
```

Предыдущая команда подключается к базе данных, используя указанную строку соединения и `Microsoft.EntityFrameworkCore.SqlServer` поставщик. После подключения создается класс контекста базы данных с именем `MyDbContext` . Кроме того, вспомогательные классы создаются для `Product` таблиц и `Customer` , которые были указаны с помощью `-t` параметров. Существует множество параметров конфигурации этой команды для создания иерархии классов, подходящей для вашей базы данных. Полный справочник см. [в документации по команде](/ef/core/miscellaneous/cli/dotnet#dotnet-ef-dbcontext-scaffold).

Дополнительные сведения о [EF Core](/ef/core/) можно найти на сайте документация Майкрософт.

## <a name="interact-with-web-services"></a>Взаимодействие с веб-службами

При первом выпуске ASP.NET службы SOAP были предпочтительнее для веб-серверов и клиентов обмениваться данными. С тех пор изменились с момента этого времени, и предпочтительные взаимодействия со службами были сдвинуты к взаимодействию с клиентами HTTP. С помощью ASP.NET Core и Blazor можно зарегистрировать конфигурацию `HttpClient` в `Startup` `ConfigureServices` методе класса. Используйте эту конфигурацию, когда необходимо взаимодействовать с конечной точкой HTTP. Рассмотрим следующий код конфигурации:

```csharp
services.AddHttpClient("github", client =>
{
    client.BaseAddress = new Uri("http://api.github.com/");
    // Github API versioning
    client.DefaultRequestHeaders.Add("Accept", "application/vnd.github.v3+json");
    // Github requires a user-agent
    client.DefaultRequestHeaders.Add("User-Agent", "BlazorWebForms-Sample");
});
```

При необходимости доступа к данным из GitHub Создайте клиент с именем `github` . Клиент настраивается с базовым адресом, а заголовки запроса задаются соответствующим образом. Вставьте в `IHttpClientFactory` Blazor компоненты с помощью `@inject` директивы или `[Inject]` атрибута в свойстве. Создайте именованный клиент и взаимодействуйте со службами, используя следующий синтаксис:

```razor
@inject IHttpClientFactory factory

...

@code {
    protected override async Task OnInitializedAsync()
    {
        var client = factory.CreateClient("github");
        var response = await client.GetAsync("repos/dotnet/docs/issues");
        response.EnsureStatusCode();
        var content = await response.Content.ReadAsStringAsync();
    }
}
```

Этот метод возвращает строку, описывающую коллекцию проблем в репозитории *DotNet/документацию* GitHub. Он возвращает содержимое в формате JSON и десериализуется в соответствующие объекты проблем GitHub. Существует множество способов настройки `HttpClientFactory` для предоставления предварительно настроенных `HttpClient` объектов. Попробуйте настроить несколько `HttpClient` экземпляров с разными именами и конечными точками для различных веб-служб, с которыми вы работаете. Этот подход сделает взаимодействие с этими службами проще для работы на каждой странице. Дополнительные сведения см. [в документации по ихттпклиентфактори](/aspnet/core/fundamentals/http-requests).

>[!div class="step-by-step"]
>[Назад](forms-validation.md)
>[Вперед](middleware.md)
