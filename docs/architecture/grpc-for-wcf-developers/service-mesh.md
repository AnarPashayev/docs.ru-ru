---
title: Сети службы — gRPC для разработчиков WCF
description: Использование сети службы для маршрутизации и балансировки запросов к gRPC службам в кластере Kubernetes.
ms.date: 12/15/2020
ms.openlocfilehash: a1c72a4facf1c133af912bbee242328653a051b6
ms.sourcegitcommit: 655f8a16c488567dfa696fc0b293b34d3c81e3df
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2021
ms.locfileid: "97938134"
---
# <a name="service-meshes"></a>Слои взаимодействия служб

Сетка служб — это компонент инфраструктуры, который принимает Управление запросами службы маршрутизации в сети. Сети служб могут обслуживать все виды сетевых проблем в кластере Kubernetes, в том числе:

- обнаружение служб;
- Балансировка нагрузки
- Отказоустойчивость
- Шифрование
- Наблюдение

Сети службы Kubernetes работают путем добавления дополнительного контейнера, именуемого *прокси-сервером расширения*, в каждый модуль, входящий в эту сеть. Прокси-сервер обрабатывает все входящие и исходящие сетевые запросы. После этого настройку и управление сетями можно настроить отдельно от контейнеров приложений. Во многих случаях это разделение не требует внесения изменений в код приложения.

В примере, приведенном в [предыдущей главе](kubernetes.md#test-the-application), запросы gRPC из веб-приложения были направлены на один экземпляр службы gRPC. Это происходит потому, что имя узла службы разрешается в IP-адрес, а этот IP-адрес кэшируется в течение времени существования `HttpClientHandler` экземпляра. Это поведение можно обойти, обрабатывая поиск DNS вручную или создав несколько клиентов. Но это решение усложняет код приложения без добавления ценности бизнеса или клиента.

При использовании сетки службы запросы из контейнера приложения отправляются на прокси-сервер расширения. Прокси-сервер расширения может затем распределять их по всем экземплярам другой службы. Сетка также может:

- Беспрепятственное реагирование на сбои отдельных экземпляров службы.
- Обрабатывает семантику повторных попыток для вызовов или истечения времени ожидания.
- Перенаправление невыполненных запросов на альтернативный экземпляр без возврата в клиентское приложение.

На следующем снимке экрана показано приложение Стокквеб, работающее с сеткой службы Linkerd. В коде приложения нет изменений, а образ DOCKER не используется. Единственным необходимым изменением было Добавление заметки к развертыванию в файлах YAML для `stockdata` `stockweb` служб и.

![Стокквеб с сетчатой службой](media/service-mesh/stockweb-servicemesh-screenshot.png)

Из столбца **сервера** можно увидеть, что запросы из приложения стокквеб были направлены в обе реплики службы стоккдата, несмотря на то, что исходит от одного `HttpClient` экземпляра в коде приложения. На самом деле, если вы просматриваете код, вы увидите, что все 100 запросов к службе Стоккдата создаются одновременно с использованием того же `HttpClient` экземпляра. При использовании сетки службы эти запросы будут сбалансированы по тем множеству, что доступны многие экземпляры служб.

Сети служб применяются только к трафику в кластере. Сведения о внешних клиентах см. в следующей главе [Балансировка нагрузки](load-balancing.md).

## <a name="service-mesh-options"></a>Параметры сетки служб

В настоящее время существует три реализации универсальной сетки служб для использования с Kubernetes: [Istio](https://istio.io), [Linkerd](https://linkerd.io)и [Consul Connect](https://consul.io/mesh.html). Все три предоставляют маршрутизацию запросов и прокси-серверы, шифрование трафика, устойчивость, аутентификацию между узлами и управление трафиком.

Выбор сетки служб зависит от нескольких факторов:

- Конкретные требования Организации к затратам, соответствию требованиям, платным тарифным планам и т. д.
- Характер кластера, его размер, количество развернутых служб и объем трафика в сети кластера.
- Простота развертывания и управления сеткой и ее использование со службами.

## <a name="example-add-linkerd-to-a-deployment"></a>Пример. Добавление Linkerd в развертывание

В этом примере вы узнаете, как использовать сетку службы Linkerd с приложением *стокккубе* из [предыдущего раздела](kubernetes.md).
Чтобы выполнить этот пример, необходимо [установить интерфейс командной строки Linkerd](https://linkerd.io/2/getting-started/#step-1-install-the-cli). Вы можете скачать двоичные файлы Windows из раздела, содержащего выпуски GitHub. Обязательно используйте последний *стабильный* выпуск, а не один из выпусков.

После установки Linkerd CLI [Начало работы](https://linkerd.io/2/getting-started/index.html) следуйте инструкциям по установке компонентов Linkerd в кластере Kubernetes. Эти инструкции просты, и установка на локальном экземпляре Kubernetes займет всего несколько минут.

### <a name="add-linkerd-to-kubernetes-deployments"></a>Добавление Linkerd в развертывания Kubernetes

Интерфейс командной строки Linkerd предоставляет `inject` команду для добавления необходимых разделов и свойств в файлы Kubernetes. Можно выполнить команду и записать выходные данные в новый файл.

```console
linkerd inject stockdata.yml > stockdata-with-mesh.yml
linkerd inject stockweb.yml > stockweb-with-mesh.yml
```

Вы можете просмотреть новые файлы, чтобы узнать, какие изменения были сделаны. Для объектов развертывания добавляется заметка метаданных, указывающая Linkerd вставить в модуль расширения контейнер прокси-сервера при его создании.

Также можно передать выходные данные `linkerd inject` команды `kubectl` непосредственно. Следующие команды будут работать в PowerShell или в любой оболочке Linux.

```console
linkerd inject stockdata.yml | kubectl apply -f -
linkerd inject stockweb.yml | kubectl apply -f -
```

### <a name="inspect-services-in-the-linkerd-dashboard"></a>Проверка служб на панели мониторинга Linkerd

Откройте панель мониторинга Linkerd с помощью `linkerd` интерфейса командной строки.

```console
linkerd dashboard
```

На панели мониторинга содержатся подробные сведения обо всех службах, подключенных к сети.

![Панель мониторинга Linkerd, показывающая приложения Стокккубе](media/service-mesh/linkerd-screenshot.png)

Если вы увеличите число реплик службы Стоккдата gRPC, как показано в следующем примере, и обновите страницу Стокквеб в браузере, вы увидите сочетание идентификаторов в столбце **сервер** . Этот набор указывает, что все доступные экземпляры обслуживают запросы.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: stockdata
  namespace: stocks
spec:
  selector:
    matchLabels:
      run: stockdata
  replicas: 2 # Increase the target number of instances
  template:
    metadata:
      annotations:
        linkerd.io/inject: enabled
      creationTimestamp: null
      labels:
        run: stockdata
    spec:
      containers:
      - name: stockdata
        image: stockdata:1.0.0
        imagePullPolicy: Never
        resources:
          limits:
            cpu: 100m
            memory: 100Mi
        ports:
        - containerPort: 80
```

>[!div class="step-by-step"]
>[Назад](kubernetes.md)
>[Вперед](load-balancing.md)
