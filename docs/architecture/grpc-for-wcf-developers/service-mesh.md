---
title: Сети службы — gRPC для разработчиков WCF
description: Использование сети службы для маршрутизации и балансировки запросов к gRPC службам в кластере Kubernetes.
ms.date: 09/02/2019
ms.openlocfilehash: a29d6893e585c7eb60c847cef0149afeeaebcdab
ms.sourcegitcommit: f38e527623883b92010cf4760246203073e12898
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/20/2020
ms.locfileid: "77503388"
---
# <a name="service-meshes"></a>Сети службы

Сетка служб — это компонент инфраструктуры, который принимает Управление запросами службы маршрутизации в сети. Сети служб могут обслуживать все виды сетевых проблем в кластере Kubernetes, в том числе:

- Обнаружение службы
- Балансировка нагрузки
- Отказоустойчивость
- Шифрование
- Наблюдение

Сети службы Kubernetes работают путем добавления дополнительного контейнера, именуемого *прокси-сервером расширения*, в каждый модуль, входящий в эту сеть. Прокси-сервер обрабатывает все входящие и исходящие сетевые запросы. После этого можно настроить настройку и управление сетями от контейнеров приложений. Во многих случаях это разделение не требует внесения изменений в код приложения.

В примере, приведенном в [предыдущей главе](kubernetes.md#test-the-application), запросы gRPC из веб-приложения были направлены на один экземпляр службы gRPC. Это происходит потому, что имя узла службы разрешается в IP-адрес, а этот IP-адрес кэшируется в течение времени существования экземпляра `HttpClientHandler`. Это можно обойти, обрабатывая поиск DNS вручную или создав несколько клиентов. Но это решение усложняет код приложения без добавления ценности бизнеса или клиента.

При использовании сетки службы запросы из контейнера приложения отправляются на прокси-сервер расширения. Прокси-сервер расширения может затем распределять их по всем экземплярам другой службы. Сетка также может:

- Беспрепятственное реагирование на сбои отдельных экземпляров службы.
- Обрабатывает семантику повторных попыток для вызовов или истечения времени ожидания.
- Перенаправление невыполненных запросов на альтернативный экземпляр без возврата в клиентское приложение.

На следующем снимке экрана показано приложение Стокквеб, работающее с сеткой службы Linkerd. В коде приложения нет изменений, а образ DOCKER не используется. Единственным необходимым изменением было Добавление заметки к развертыванию в файлах YAML для служб `stockdata` и `stockweb`.

![Стокквеб с сетчатой службой](media/service-mesh/stockweb-servicemesh-screenshot.png)

Из столбца **сервера** можно увидеть, что запросы из приложения стокквеб были направлены в обе реплики службы стоккдата, несмотря на то, что исходит от одного `HttpClient` экземпляра в коде приложения. На самом деле, если вы просматриваете код, вы увидите, что все 100 запросов к службе Стоккдата будут выполняться одновременно с использованием того же экземпляра `HttpClient`. При использовании сетки службы эти запросы будут сбалансированы по тем множеству, что доступны многие экземпляры служб.

Сети служб применяются только к трафику в кластере. Сведения о внешних клиентах см. в следующей главе [Балансировка нагрузки](load-balancing.md).

## <a name="service-mesh-options"></a>Параметры сетки служб

В настоящее время существует три реализации универсальной сетки служб для использования с Kubernetes: [Istio](https://istio.io), [Linkerd](https://linkerd.io)и [Consul Connect](https://consul.io/mesh.html). Все три предоставляют маршрутизацию запросов и прокси-серверы, шифрование трафика, устойчивость, аутентификацию между узлами и управление трафиком.

Выбор сетки служб зависит от нескольких факторов:

- Конкретные требования Организации к затратам, соответствию требованиям, платным тарифным планам и т. д.
- Характер кластера, его размер, количество развернутых служб и объем трафика в сети кластера.
- Простота развертывания и управления сеткой и ее использование со службами.

## <a name="example-add-linkerd-to-a-deployment"></a>Пример. Добавление Linkerd в развертывание

В этом примере вы узнаете, как использовать сетку службы Linkerd с приложением *стокккубе* из [предыдущего раздела](kubernetes.md).
Чтобы выполнить этот пример, необходимо [установить интерфейс командной строки Linkerd](https://linkerd.io/2/getting-started/#step-1-install-the-cli). Вы можете скачать двоичные файлы Windows из раздела, содержащего выпуски GitHub. Обязательно используйте последний *стабильный* выпуск, а не один из выпусков.

После установки Linkerd CLI [Начало работы](https://linkerd.io/2/getting-started/index.html) следуйте инструкциям по установке компонентов Linkerd в кластере Kubernetes. Инструкции просты, и установка на локальном экземпляре Kubernetes займет всего несколько минут.

### <a name="add-linkerd-to-kubernetes-deployments"></a>Добавление Linkerd в развертывания Kubernetes

Linkerd CLI предоставляет команду `inject`, чтобы добавить необходимые разделы и свойства в файлы Kubernetes. Можно выполнить команду и записать выходные данные в новый файл.

```console
linkerd inject stockdata.yml > stockdata-with-mesh.yml
linkerd inject stockweb.yml > stockweb-with-mesh.yml
```

Вы можете просмотреть новые файлы, чтобы узнать, какие изменения были сделаны. Для объектов развертывания добавляется заметка метаданных, указывающая Linkerd вставить в модуль расширения контейнер прокси-сервера при его создании.

Также можно передать выходные данные команды `linkerd inject` для `kubectl` напрямую. Следующие команды будут работать в PowerShell или в любой оболочке Linux.

```console
linkerd inject stockdata.yml | kubectl apply -f -
linkerd inject stockweb.yml | kubectl apply -f -
```

### <a name="inspect-services-in-the-linkerd-dashboard"></a>Проверка служб на панели мониторинга Linkerd

Откройте панель мониторинга Linkerd с помощью `linkerd` CLI.

```console
linkerd dashboard
```

На панели мониторинга содержатся подробные сведения обо всех службах, подключенных к сети.

![Панель мониторинга Linkerd, показывающая приложения Стокккубе](media/service-mesh/linkerd-screenshot.png)

Если вы увеличите число реплик службы Стоккдата gRPC, как показано в следующем примере, и обновите страницу Стокквеб в браузере, вы увидите сочетание идентификаторов в столбце **сервер** . Этот набор указывает, что все доступные экземпляры обслуживают запросы.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: stockdata
  namespace: stocks
spec:
  selector:
    matchLabels:
      run: stockdata
  replicas: 2 # Increase the target number of instances
  template:
    metadata:
      annotations:
        linkerd.io/inject: enabled
      creationTimestamp: null
      labels:
        run: stockdata
    spec:
      containers:
      - name: stockdata
        image: stockdata:1.0.0
        imagePullPolicy: Never
        resources:
          limits:
            cpu: 100m
            memory: 100Mi
        ports:
        - containerPort: 80
```

>[!div class="step-by-step"]
>[Назад](kubernetes.md)
>[Вперед](load-balancing.md)
