---
title: Сообщения Protobuf - gRPC для разработчиков WCF
description: Узнайте, как сообщения Protobuf определяются в IDL и генерируются в C.
ms.date: 09/09/2019
ms.openlocfilehash: 5b3d4383de39a3785ef804fec21939a740f54669
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79147988"
---
# <a name="protobuf-messages"></a>Сообщения Protobuf

В этом разделе рассказывается о том, как `.proto` декларировать сообщения Протокола буфера (Protobuf) в файлах. В нем разъясняется основные понятия полевых чисел `protoc` и типов, а также рассматривается код C-кода, генерируемого компилятором.

Остальная часть главы будет более подробно рассматривать, как различные типы данных представлены в Protobuf.

## <a name="declaring-a-message"></a>Объявление сообщения

В Windows Communication Foundation (WCF) `Stock` класс для торгового приложения на фондовом рынке может быть определен следующим примером:

```csharp
namespace TraderSys
{
    [DataContract]
    public class Stock
    {
        [DataMember]
        public int Id { get; set;}
        [DataMember]
        public string Symbol { get; set;}
        [DataMember]
        public string DisplayName { get; set;}
        [DataMember]
        public int MarketId { get; set; }
    }
}
```

Чтобы реализовать эквивалентный класс в Protobuf, `.proto` необходимо объявить его в файле. Компилятор `protoc` будет генерировать класс .NET как часть процесса сборки.

```protobuf
syntax "proto3";

option csharp_namespace = "TraderSys";

message Stock {

    int32 id = 1;
    string symbol = 2;
    string display_name = 3;
    int32 market_id = 4;

}  
```

Первая строка объявляет используемую версию синтаксиса. Версия 3 языка была выпущена в 2016 году. Это версия, которую мы рекомендуем для услуг gRPC.

Линия `option csharp_namespace` определяет пространство имен, которое будет использоваться для генерируемых типов C.'. Этот параметр будет проигнорирован `.proto` при компиляции файла для других языков. Файлы Protobuf часто содержат языковые параметры для нескольких языков.

Определение `Stock` сообщения определяет четыре поля. Каждый из них имеет тип, имя и номер поля.

## <a name="field-numbers"></a>Номера полей

Полевые номера являются важной частью Протобуфа. Они используются для идентификации полей в двоичных закодированных данных, что означает, что они не могут меняться от версии к версии службы. Преимущество в том, что возможна обратная совместимость и передовая совместимость. Клиенты и службы будут просто игнорировать номера полей, о которыми они не знают, до тех пор, пока будет обработана возможность отсутствующих значений.

В двоичном формате номер поля сочетается с идентификатором типа. Полевые номера от 1 до 15 могут быть закодированы с их типом в качестве одного байта. Цифры от 16 до 2047 принимают 2 байта. Вы можете подняться выше, если вам нужно более 2047 полей на сообщение по любой причине. Одноразовые идентификаторы байтов для полевых чисел от 1 до 15 обеспечивают более высокую производительность, поэтому их следует использовать для самых основных, часто используемых полей.

## <a name="types"></a>Типы

В декларациях типа используются нативные типы данных Protobuf, которые более подробно обсуждаются в [следующем разделе.](protobuf-data-types.md) Остальная часть этой главы будет охватывать встроенные типы Protobuf и показать, как они относятся к общим типам .NET.

> [!NOTE]
> Protobuf не родной поддержки `decimal` типа, поэтому `double` используется вместо. Для приложений, которые требуют полной десятичной точности, обратитесь к [разделу о десятичных знаков](protobuf-data-types.md#decimals) в следующей части этой главы.

## <a name="the-generated-code"></a>Сформированный код

При создании приложения Protobuf создает классы для каждого из ваших сообщений, отображая его родные типы до типов C. Генерируемый `Stock` тип будет иметь следующую подпись:

```csharp
public class Stock
{
    public int Id { get; set; }
    public string Symbol { get; set; }
    public string DisplayName { get; set; }
    public int MarketId { get; set; }
}
```

Сгенерированный код гораздо сложнее, чем этот. Причина в том, что каждый класс содержит весь код, необходимый для сериализации и десериализации в формате двоичного провода.

### <a name="property-names"></a>Имена свойств

Обратите внимание, что компилятор Protobuf применяется `PascalCase` к именам свойств, хотя они были `snake_case` в файле. `.proto` [Руководство по стилю Protobuf](https://developers.google.com/protocol-buffers/docs/style) рекомендует использовать `snake_case` в определениях сообщений, чтобы генерация кода для других платформ побуждала ожидаемый аргумент для их конвенций.

>[!div class="step-by-step"]
>[Предыдущий](protocol-buffers.md)
>[Следующий](protobuf-data-types.md)
