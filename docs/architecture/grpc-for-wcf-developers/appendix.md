---
title: Приложение-gRPC для разработчиков WCF
description: Обсуждение распределенных транзакций и их реализации в современных архитектурах микрослужб.
ms.date: 09/02/2019
ms.openlocfilehash: 9931681727f921e007c2f80852ad0e69cd7288de
ms.sourcegitcommit: 5fb5b6520b06d7f5e6131ec2ad854da302a28f2e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/03/2019
ms.locfileid: "74711471"
---
# <a name="appendix-a---transactions"></a>Приложение а. транзакции

Windows Communication Foundation (WCF) поддерживает распределенные транзакции, что позволяет выполнять атомарные операции в нескольких службах. Эта функция основана на [координатор распределенных транзакций Майкрософт](https://docs.microsoft.com/previous-versions/windows/desktop/ms684146(v=vs.85)).

В современных микрослужбах такой тип автоматизированной обработки распределенных транзакций невозможен. Существует слишком много различных технологий, включая реляционные базы данных, NoSQL хранилища данных и системы обмена сообщениями. Кроме того, в одной среде могут использоваться сочетания операционных систем, языков программирования и платформ.

Распределенная транзакция WCF является реализацией того, что называется [двухфазной фиксацией (2PC)](https://en.wikipedia.org/wiki/Two-phase_commit_protocol). 2PC транзакции можно реализовать вручную путем координирования сообщений между службами, создания открытых транзакций в каждой службе и отправки сообщений фиксации или отката в зависимости от успешности или сбоя. Однако сложность, связанная с управлением 2PC, может значительно увеличить экспоненциальное развитие систем. Открытые транзакции хранят блокировки баз данных, которые могут негативно повлиять на производительность, или, что еще хуже, привести к взаимоблокировкам между службами.

По возможности лучше избегать распределенных транзакций. Если два элемента данных связаны так, чтобы требовать атомарных обновлений, рассмотрите возможность их обработки с помощью одной и той же службы. Примените эти атомарные изменения с помощью одного запроса или сообщения к этой службе.

Если это невозможно, в качестве альтернативы можно использовать [шаблон Saga](https://microservices.io/patterns/data/saga.html). В Saga обновления обрабатываются последовательно. После завершения каждого обновления запускается следующий. Эти триггеры могут распространяться из службы в службу или управляются координатором Saga или Orchestrator. Если обновление завершается сбоем в любой момент, службы, которые уже выполнили их обновления, применяют определенную логику для их изменения.

Другой вариант — использовать проектирование на основе домена (DDD) и разделение ответственности за использование команд и запросов (CQRS), как описано в [электронной документации по микрослужбам .NET](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/). В частности, использование событий предметной области или [источников событий](https://martinfowler.com/eaaDev/EventSourcing.html) может помочь обеспечить согласованность обновлений, если они не применяются немедленно.

>[!div class="step-by-step"]
>[Назад](application-performance-management.md)
