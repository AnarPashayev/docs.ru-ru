---
title: Приложение-gRPC для разработчиков WCF
description: Обсуждение распределенных транзакций и их реализации в современных архитектурах микрослужб.
ms.date: 09/02/2019
ms.openlocfilehash: f60899463a13e9f740f6ae63150d18eab3069124
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/24/2020
ms.locfileid: "91165862"
---
# <a name="appendix-a---transactions"></a>Приложение а. транзакции

Windows Communication Foundation (WCF) поддерживает распределенные транзакции, что позволяет выполнять атомарные операции в нескольких службах. Эта функция основана на [координатор распределенных транзакций Майкрософт](/previous-versions/windows/desktop/ms684146(v=vs.85)).

В современных микрослужбах такой тип автоматизированной обработки распределенных транзакций невозможен. Существует слишком много различных технологий, включая реляционные базы данных, NoSQL хранилища данных и системы обмена сообщениями. Кроме того, в одной среде могут использоваться сочетания операционных систем, языков программирования и платформ.

Распределенная транзакция WCF является реализацией того, что называется [двухфазной фиксацией (2PC)](https://en.wikipedia.org/wiki/Two-phase_commit_protocol). 2PC транзакции можно реализовать вручную путем координирования сообщений между службами, создания открытых транзакций в каждой службе и отправки сообщений фиксации или отката в зависимости от успешности или сбоя. Однако сложность, связанная с управлением 2PC, может значительно увеличить экспоненциальное развитие систем. Открытые транзакции хранят блокировки баз данных, которые могут негативно повлиять на производительность, или, что еще хуже, привести к взаимоблокировкам между службами.

По возможности лучше избегать распределенных транзакций. Если два элемента данных связаны так, чтобы требовать атомарных обновлений, рассмотрите возможность их обработки с помощью одной и той же службы. Примените эти атомарные изменения с помощью одного запроса или сообщения к этой службе.

Если это невозможно, в качестве альтернативы можно использовать [шаблон Saga](https://microservices.io/patterns/data/saga.html). В Saga обновления обрабатываются последовательно. После завершения каждого обновления запускается следующий. Эти триггеры могут распространяться из службы в службу или управляются координатором Saga или Orchestrator. Если обновление завершается сбоем в любой момент, службы, которые уже выполнили их обновления, применяют определенную логику для их изменения.

Другой вариант — использовать проектирование на основе домена (DDD) и разделение ответственности за использование команд и запросов (CQRS), как описано в [электронной документации по микрослужбам .NET](../microservices/microservice-ddd-cqrs-patterns/index.md). В частности, использование событий предметной области или [источников событий](https://martinfowler.com/eaaDev/EventSourcing.html) может помочь обеспечить согласованность обновлений, если они не применяются немедленно.

>[!div class="step-by-step"]
>[Назад](application-performance-management.md)
