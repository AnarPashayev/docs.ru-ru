---
title: Приложение-gRPC для разработчиков WCF
description: Обсуждение распределенных транзакций и их реализации в современных архитектурах микрослужб.
ms.date: 09/02/2019
ms.openlocfilehash: 061aef016fd0e4303e1bbcbf0e73cec2b0c54f74
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/12/2019
ms.locfileid: "73968220"
---
# <a name="appendix-a---transactions"></a>Приложение а. транзакции

Windows Communication Foundation (WCF) поддерживали распределенные транзакции, что позволяет выполнять атомарные операции в нескольких службах. Эта функция основана на [координатор распределенных транзакций Майкрософт](https://docs.microsoft.com/previous-versions/windows/desktop/ms684146(v=vs.85)).

В современных микрослужбах такой тип автоматизированной обработки распределенных транзакций невозможен. В игре существует слишком много различных технологий, включая реляционные базы данных, NoSQL хранилища данных и системы обмена сообщениями, а не упоминание комбинаций операционных систем, языков программирования и платформ, которые могут использоваться в одной среде.

Распределенная транзакция WCF является реализацией того, что называется [двухфазной фиксацией (2PC)](https://en.wikipedia.org/wiki/Two-phase_commit_protocol). 2PC транзакции можно реализовать вручную путем координирования сообщений между службами, создания открытых транзакций в каждой службе и отправки сообщений "commit" или "Rollback" в зависимости от успешности или сбоя. Однако сложность, связанная с управлением 2PC, может увеличиваться экспоненциально по мере развития систем, а открытые транзакции хранят блокировки баз данных, которые могут негативно сказаться на производительности или, что еще хуже, привести к взаимоблокировкам между службами.

По возможности лучше избегать распределенных транзакций. Если два элемента данных связаны так, чтобы требовать атомарных обновлений, рассмотрите возможность их обработки с помощью одной и той же службы и примените эти атомарные изменения с помощью одного запроса или сообщения к этой службе.

Если это невозможно, в качестве альтернативы можно использовать [шаблон Saga](https://microservices.io/patterns/data/saga.html). В Saga обновления обрабатываются последовательно; После завершения каждого обновления запускается следующий. Эти триггеры могут распространяться из службы в службу или управляются координатором Saga или Orchestrator. Если обновление завершается сбоем в любой момент, службы, которые уже выполнили их обновления, применяют определенную логику для их изменения.

Другой вариант — использовать проектирование на основе домена (DDD) и разделение ответственности за использование команд и запросов (CQRS), как описано в [электронной документации по микрослужбам .NET](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/). В частности, использование событий предметной области или [источников событий](https://martinfowler.com/eaaDev/EventSourcing.html) может помочь обеспечить согласованное&mdash;обновлений, если они не&mdash;применяться немедленно.

>[!div class="step-by-step"]
>[Назад](application-performance-management.md)
