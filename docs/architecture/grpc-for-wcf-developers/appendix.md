---
title: Приложение-gRPC для разработчиков WCF
description: Обсуждение распределенных транзакций и их реализации в современных архитектурах микрослужб.
ms.date: 09/02/2019
ms.openlocfilehash: 061aef016fd0e4303e1bbcbf0e73cec2b0c54f74
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/12/2019
ms.locfileid: "73968220"
---
# <a name="appendix-a---transactions"></a><span data-ttu-id="0a12c-103">Приложение а. транзакции</span><span class="sxs-lookup"><span data-stu-id="0a12c-103">Appendix A - Transactions</span></span>

<span data-ttu-id="0a12c-104">Windows Communication Foundation (WCF) поддерживали распределенные транзакции, что позволяет выполнять атомарные операции в нескольких службах.</span><span class="sxs-lookup"><span data-stu-id="0a12c-104">Windows Communication Foundation (WCF) supported distributed transactions, allowing atomic operations to be performed across multiple services.</span></span> <span data-ttu-id="0a12c-105">Эта функция основана на [координатор распределенных транзакций Майкрософт](https://docs.microsoft.com/previous-versions/windows/desktop/ms684146(v=vs.85)).</span><span class="sxs-lookup"><span data-stu-id="0a12c-105">This functionality was based on the [Microsoft Distributed Transaction Coordinator](https://docs.microsoft.com/previous-versions/windows/desktop/ms684146(v=vs.85)).</span></span>

<span data-ttu-id="0a12c-106">В современных микрослужбах такой тип автоматизированной обработки распределенных транзакций невозможен.</span><span class="sxs-lookup"><span data-stu-id="0a12c-106">In the modern microservices landscape, this type of automated distributed transaction processing isn't possible.</span></span> <span data-ttu-id="0a12c-107">В игре существует слишком много различных технологий, включая реляционные базы данных, NoSQL хранилища данных и системы обмена сообщениями, а не упоминание комбинаций операционных систем, языков программирования и платформ, которые могут использоваться в одной среде.</span><span class="sxs-lookup"><span data-stu-id="0a12c-107">There are too many different technologies at play, including relational databases, NoSQL data stores, and messaging systems, not to mention the mix of operating systems, programming languages and frameworks that may be used in a single environment.</span></span>

<span data-ttu-id="0a12c-108">Распределенная транзакция WCF является реализацией того, что называется [двухфазной фиксацией (2PC)](https://en.wikipedia.org/wiki/Two-phase_commit_protocol).</span><span class="sxs-lookup"><span data-stu-id="0a12c-108">The WCF distributed transaction is an implementation of what is known as a [two-phase commit (2PC)](https://en.wikipedia.org/wiki/Two-phase_commit_protocol).</span></span> <span data-ttu-id="0a12c-109">2PC транзакции можно реализовать вручную путем координирования сообщений между службами, создания открытых транзакций в каждой службе и отправки сообщений "commit" или "Rollback" в зависимости от успешности или сбоя.</span><span class="sxs-lookup"><span data-stu-id="0a12c-109">It's possible to implement 2PC transactions manually by coordinating messages across services, creating open transactions within each service and sending "commit" or "rollback" messages depending upon success or failure.</span></span> <span data-ttu-id="0a12c-110">Однако сложность, связанная с управлением 2PC, может увеличиваться экспоненциально по мере развития систем, а открытые транзакции хранят блокировки баз данных, которые могут негативно сказаться на производительности или, что еще хуже, привести к взаимоблокировкам между службами.</span><span class="sxs-lookup"><span data-stu-id="0a12c-110">However, the complexity that is involved in managing 2PC can increase exponentially as systems evolve, and open transactions hold database locks that can negatively impact performance or, worse, cause cross-service deadlocks.</span></span>

<span data-ttu-id="0a12c-111">По возможности лучше избегать распределенных транзакций.</span><span class="sxs-lookup"><span data-stu-id="0a12c-111">If possible, it's best to avoid distributed transactions altogether.</span></span> <span data-ttu-id="0a12c-112">Если два элемента данных связаны так, чтобы требовать атомарных обновлений, рассмотрите возможность их обработки с помощью одной и той же службы и примените эти атомарные изменения с помощью одного запроса или сообщения к этой службе.</span><span class="sxs-lookup"><span data-stu-id="0a12c-112">If two items of data are so linked as to require atomic updates, consider handling them both with the same service, and applying those atomic changes using a single request or message to that service.</span></span>

<span data-ttu-id="0a12c-113">Если это невозможно, в качестве альтернативы можно использовать [шаблон Saga](https://microservices.io/patterns/data/saga.html).</span><span class="sxs-lookup"><span data-stu-id="0a12c-113">If that isn't possible, then one alternative is to use the [Saga pattern](https://microservices.io/patterns/data/saga.html).</span></span> <span data-ttu-id="0a12c-114">В Saga обновления обрабатываются последовательно; После завершения каждого обновления запускается следующий.</span><span class="sxs-lookup"><span data-stu-id="0a12c-114">In a saga, updates are processing sequentially; as each update succeeds the next one is triggered.</span></span> <span data-ttu-id="0a12c-115">Эти триггеры могут распространяться из службы в службу или управляются координатором Saga или Orchestrator.</span><span class="sxs-lookup"><span data-stu-id="0a12c-115">These triggers can be propagated from service to service, or managed by a saga coordinator or "orchestrator".</span></span> <span data-ttu-id="0a12c-116">Если обновление завершается сбоем в любой момент, службы, которые уже выполнили их обновления, применяют определенную логику для их изменения.</span><span class="sxs-lookup"><span data-stu-id="0a12c-116">If an update fails at any point during the process, the services that have already completed their updates apply specific logic to reverse them.</span></span>

<span data-ttu-id="0a12c-117">Другой вариант — использовать проектирование на основе домена (DDD) и разделение ответственности за использование команд и запросов (CQRS), как описано в [электронной документации по микрослужбам .NET](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/).</span><span class="sxs-lookup"><span data-stu-id="0a12c-117">Another option is to use Domain Driven Design (DDD) and Command/Query Responsibility Segregation (CQRS), as described in the [.NET Microservices e-book](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/).</span></span> <span data-ttu-id="0a12c-118">В частности, использование событий предметной области или [источников событий](https://martinfowler.com/eaaDev/EventSourcing.html) может помочь обеспечить согласованное&mdash;обновлений, если они не&mdash;применяться немедленно.</span><span class="sxs-lookup"><span data-stu-id="0a12c-118">In particular, using domain events or [event sourcing](https://martinfowler.com/eaaDev/EventSourcing.html) can help to ensure that updates are consistently&mdash;if not immediately&mdash;applied.</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="0a12c-119">Назад</span><span class="sxs-lookup"><span data-stu-id="0a12c-119">Previous</span></span>](application-performance-management.md)
