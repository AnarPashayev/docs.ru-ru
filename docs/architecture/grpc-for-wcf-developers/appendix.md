---
title: Приложение-gRPC для разработчиков WCF
description: Обсуждение распределенных транзакций и их реализации в современных архитектурах микрослужб.
ms.date: 09/02/2019
ms.openlocfilehash: 9931681727f921e007c2f80852ad0e69cd7288de
ms.sourcegitcommit: 5fb5b6520b06d7f5e6131ec2ad854da302a28f2e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/03/2019
ms.locfileid: "74711471"
---
# <a name="appendix-a---transactions"></a><span data-ttu-id="af378-103">Приложение а. транзакции</span><span class="sxs-lookup"><span data-stu-id="af378-103">Appendix A - Transactions</span></span>

<span data-ttu-id="af378-104">Windows Communication Foundation (WCF) поддерживает распределенные транзакции, что позволяет выполнять атомарные операции в нескольких службах.</span><span class="sxs-lookup"><span data-stu-id="af378-104">Windows Communication Foundation (WCF) supports distributed transactions, allowing you to perform atomic operations across multiple services.</span></span> <span data-ttu-id="af378-105">Эта функция основана на [координатор распределенных транзакций Майкрософт](https://docs.microsoft.com/previous-versions/windows/desktop/ms684146(v=vs.85)).</span><span class="sxs-lookup"><span data-stu-id="af378-105">This functionality is based on the [Microsoft Distributed Transaction Coordinator](https://docs.microsoft.com/previous-versions/windows/desktop/ms684146(v=vs.85)).</span></span>

<span data-ttu-id="af378-106">В современных микрослужбах такой тип автоматизированной обработки распределенных транзакций невозможен.</span><span class="sxs-lookup"><span data-stu-id="af378-106">In the newer microservices landscape, this type of automated distributed transaction processing isn't possible.</span></span> <span data-ttu-id="af378-107">Существует слишком много различных технологий, включая реляционные базы данных, NoSQL хранилища данных и системы обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="af378-107">There are too many different technologies involved, including relational databases, NoSQL data stores, and messaging systems.</span></span> <span data-ttu-id="af378-108">Кроме того, в одной среде могут использоваться сочетания операционных систем, языков программирования и платформ.</span><span class="sxs-lookup"><span data-stu-id="af378-108">There might also be a mix of operating systems, programming languages, and frameworks in use in a single environment.</span></span>

<span data-ttu-id="af378-109">Распределенная транзакция WCF является реализацией того, что называется [двухфазной фиксацией (2PC)](https://en.wikipedia.org/wiki/Two-phase_commit_protocol).</span><span class="sxs-lookup"><span data-stu-id="af378-109">WCF distributed transaction is an implementation of what is known as a [two-phase commit (2PC)](https://en.wikipedia.org/wiki/Two-phase_commit_protocol).</span></span> <span data-ttu-id="af378-110">2PC транзакции можно реализовать вручную путем координирования сообщений между службами, создания открытых транзакций в каждой службе и отправки сообщений фиксации или отката в зависимости от успешности или сбоя.</span><span class="sxs-lookup"><span data-stu-id="af378-110">You can implement 2PC transactions manually by coordinating messages across services, creating open transactions within each service, and sending commit or rollback messages, depending upon success or failure.</span></span> <span data-ttu-id="af378-111">Однако сложность, связанная с управлением 2PC, может значительно увеличить экспоненциальное развитие систем.</span><span class="sxs-lookup"><span data-stu-id="af378-111">However, the complexity involved in managing 2PC can increase exponentially as systems evolve.</span></span> <span data-ttu-id="af378-112">Открытые транзакции хранят блокировки баз данных, которые могут негативно повлиять на производительность, или, что еще хуже, привести к взаимоблокировкам между службами.</span><span class="sxs-lookup"><span data-stu-id="af378-112">Open transactions hold database locks that can negatively affect performance, or, worse, cause cross-service deadlocks.</span></span>

<span data-ttu-id="af378-113">По возможности лучше избегать распределенных транзакций.</span><span class="sxs-lookup"><span data-stu-id="af378-113">If possible, it's best to avoid distributed transactions altogether.</span></span> <span data-ttu-id="af378-114">Если два элемента данных связаны так, чтобы требовать атомарных обновлений, рассмотрите возможность их обработки с помощью одной и той же службы.</span><span class="sxs-lookup"><span data-stu-id="af378-114">If two items of data are so linked as to require atomic updates, consider handling them both with the same service.</span></span> <span data-ttu-id="af378-115">Примените эти атомарные изменения с помощью одного запроса или сообщения к этой службе.</span><span class="sxs-lookup"><span data-stu-id="af378-115">Apply those atomic changes by using a single request or message to that service.</span></span>

<span data-ttu-id="af378-116">Если это невозможно, в качестве альтернативы можно использовать [шаблон Saga](https://microservices.io/patterns/data/saga.html).</span><span class="sxs-lookup"><span data-stu-id="af378-116">If that isn't possible, then one alternative is to use the [Saga pattern](https://microservices.io/patterns/data/saga.html).</span></span> <span data-ttu-id="af378-117">В Saga обновления обрабатываются последовательно. После завершения каждого обновления запускается следующий.</span><span class="sxs-lookup"><span data-stu-id="af378-117">In a saga, updates are processed sequentially; as each update succeeds, the next one is triggered.</span></span> <span data-ttu-id="af378-118">Эти триггеры могут распространяться из службы в службу или управляются координатором Saga или Orchestrator.</span><span class="sxs-lookup"><span data-stu-id="af378-118">These triggers can be propagated from service to service, or managed by a saga coordinator or orchestrator.</span></span> <span data-ttu-id="af378-119">Если обновление завершается сбоем в любой момент, службы, которые уже выполнили их обновления, применяют определенную логику для их изменения.</span><span class="sxs-lookup"><span data-stu-id="af378-119">If an update fails at any point during the process, the services that have already completed their updates apply specific logic to reverse them.</span></span>

<span data-ttu-id="af378-120">Другой вариант — использовать проектирование на основе домена (DDD) и разделение ответственности за использование команд и запросов (CQRS), как описано в [электронной документации по микрослужбам .NET](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/).</span><span class="sxs-lookup"><span data-stu-id="af378-120">Another option is to use Domain Driven Design (DDD) and Command/Query Responsibility Segregation (CQRS), as described in the [.NET Microservices e-book](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/).</span></span> <span data-ttu-id="af378-121">В частности, использование событий предметной области или [источников событий](https://martinfowler.com/eaaDev/EventSourcing.html) может помочь обеспечить согласованность обновлений, если они не применяются немедленно.</span><span class="sxs-lookup"><span data-stu-id="af378-121">In particular, using domain events or [event sourcing](https://martinfowler.com/eaaDev/EventSourcing.html) can help to ensure that updates are consistently, if not immediately, applied.</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="af378-122">Назад</span><span class="sxs-lookup"><span data-stu-id="af378-122">Previous</span></span>](application-performance-management.md)
