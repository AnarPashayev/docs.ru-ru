---
title: Почему мы рекомендуем gRPC для разработчиков WCF — gRPC для разработчиков WCF
description: Обсуждение того, почему gRPC хорошо подходит для разработчиков WCF, желающих перейти на современные архитектуры и платформы.
ms.date: 12/15/2020
ms.openlocfilehash: 058f85297610116e96c8580fcefb10ee6dfcf935
ms.sourcegitcommit: 655f8a16c488567dfa696fc0b293b34d3c81e3df
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2021
ms.locfileid: "97937978"
---
# <a name="why-we-recommend-grpc-for-wcf-developers"></a>Причины, по которым мы рекомендуем gRPC разработчикам WCF

Прежде чем мы подробно рассмотрим язык и методы gRPC, стоит обсудить, почему gRPC является верным решением для разработчиков Windows Communication Foundation (WCF), желающих перейти на .NET.

## <a name="similarity-to-wcf"></a>Сходство с WCF

Хотя реализация и подход в случае с gRPC отличаются, принципы разработки и использования служб с помощью gRPC должны быть интуитивно понятными для разработчиков на WCF. Основной целью является то же, что можно сделать код так, как если бы клиент и сервер находились на одной платформе, без необходимости беспокоиться о работе сети.

Обе платформы совместно используют принцип объявления и реализации интерфейса, даже если процесс объявления этого интерфейса отличается. Как вы увидите в главе 5, различные типы вызовов RPC, которые gRPC поддерживают, соответствуют привязкам, доступным службам WCF.

## <a name="benefits-of-grpc"></a>Преимущества gRPC

gRPC соответствует другим решениям по следующим причинам.

### <a name="performance"></a>Производительность

Использование HTTP/2 вместо HTTP/1.1 устраняет необходимость в сообщениях, доступных для чтения человеком, а вместо этого использует меньший, более быстрый двоичный протокол. Это более эффективно для анализа компьютеров. HTTP/2 также поддерживает запросы на мультиплексирование через одно соединение. Эта поддержка позволяет отправлять ответы, как только они будут готовы, без необходимости ждать в очереди. (В HTTP/1.1 Эта проблема называется «головной (HOL) блокировкой».) При использовании gRPC требуется меньше ресурсов, что делает его хорошим решением для использования с мобильными устройствами и более медленными сетями.

### <a name="interoperability"></a>Совместимость

Существуют средства и библиотеки gRPC для всех основных языков программирования и платформ, включая .NET, Java, Python, Go, C++, Node.js, Swift, Dart, Ruby и PHP. Благодаря протоколу буферов двоичного формата и эффективному созданию кода для каждой платформы разработчики могут создавать приложения, поддерживающие различные платформы.

### <a name="usability-and-productivity"></a>Удобство использования и производительность

gRPC — это комплексное решение RPC. Оно работает согласованно на различных языках и платформах. Он также предоставляет отличные средства, при этом большая часть необходимого стандартного кода создается автоматически. Итак, время разработки освобождается для того, чтобы сосредоточиться на бизнес-логике.

### <a name="streaming"></a>Потоковая передача

в gRPC есть полная двунаправленная потоковая передача, которая обеспечивает аналогичные функции для полноценных служб WCF. Потоковая передача gRPC может производиться по обычным подключениям через Интернет, посредством подсистем балансировки нагрузки и через одноранговые сети служб.

### <a name="deadlinetimeouts-and-cancellation"></a>Крайний срок, время ожидания и отмена

gRPC позволяет клиентам указать максимальное время, в течение которого должен быть завершен вызов RPC. При истечении указанного крайнего срока сервер может отменить операцию независимо от клиента. Крайние сроки и отмены можно распространить с помощью дальнейших вызовов gRPC, чтобы обеспечить ограничение использования ресурсов. Клиенты также могут прерывать операции при превышении крайнего срока или более ранней (например, из-за взаимодействия с пользователем).

### <a name="security"></a>Безопасность

gRPC является неявно защищенным, если используется HTTP/2 по отношению к сквозному шифрованному соединению TLS. Поддержка проверки подлинности с помощью сертификата клиента (см. [главу 6](security.md)) дополнительно повышает безопасность и доверие между клиентом и сервером.

>[!div class="step-by-step"]
>[Назад](network-protocols.md)
>[Вперед](protocol-buffers.md)
