---
title: Почему мы рекомендуем gRPC для разработчиков WCF — gRPC для разработчиков WCF
description: Обсуждение того, почему gRPC хорошо подходит для разработчиков WCF, желающих перейти на современные архитектуры и платформы.
ms.date: 09/02/2019
ms.openlocfilehash: fc93ca4c8f2a28dc4d3a0b0466d19c86273b40b8
ms.sourcegitcommit: f38e527623883b92010cf4760246203073e12898
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/20/2020
ms.locfileid: "77503319"
---
# <a name="why-we-recommend-grpc-for-wcf-developers"></a>Почему мы рекомендуем gRPC для разработчиков WCF

Прежде чем мы подробно рассмотрим язык и методы gRPC, стоит обсудить, почему gRPC является верным решением для разработчиков Windows Communication Foundation (WCF), желающих перейти на .NET Core.

## <a name="similarity-to-wcf"></a>Сходство с WCF

Хотя реализация и подход отличаются для gRPC, опыт разработки и использования служб с gRPC должен быть интуитивно понятным для разработчиков WCF. Основной целью является то же, что можно сделать код так, как если бы клиент и сервер находились на одной платформе, без необходимости беспокоиться о работе сети. 

Обе платформы совместно используют принцип объявления и реализации интерфейса, даже если процесс объявления этого интерфейса отличается. Как вы увидите в главе 5, различные типы вызовов RPC, которые gRPC поддерживают, соответствуют привязкам, доступным службам WCF.

## <a name="benefits-of-grpc"></a>Преимущества gRPC

gRPC соответствует другим решениям по следующим причинам.

### <a name="performance"></a>Производительность

Использование HTTP/2 вместо HTTP/1.1 устраняет необходимость в сообщениях, доступных для чтения человеком, а вместо этого использует меньший, более быстрый двоичный протокол. Это более эффективно для анализа компьютеров. HTTP/2 также поддерживает запросы на мультиплексирование через одно соединение. Эта поддержка позволяет отправлять ответы, как только они будут готовы, без необходимости ждать в очереди. (В HTTP/1.1 Эта проблема называется «головной (HOL) блокировкой».) При использовании gRPC требуется меньше ресурсов, что делает его хорошим решением для использования с мобильными устройствами и более медленными сетями.

### <a name="interoperability"></a>Совместимость

Существуют средства и библиотеки gRPC для всех основных языков программирования и платформ, включая .NET, Java, Python, Go, C++, Node. js, SWIFT, DART, Ruby и PHP. Благодаря протоколу буферов двоичного формата и эффективному созданию кода для каждой платформы разработчики могут создавать приложения, поддерживающие различные платформы.

### <a name="usability-and-productivity"></a>Удобство использования и производительность

gRPC — это комплексное решение RPC. Он работает единообразно на нескольких языках и платформах. Он также предоставляет отличные средства, при этом большая часть необходимого стандартного кода создается автоматически. Итак, время разработки освобождается для того, чтобы сосредоточиться на бизнес-логике.

### <a name="streaming"></a>Потоковая передача

gRPC имеет полноценную двунаправленную потоковую передачу, которая обеспечивает аналогичные функции для полноценных служб дуплексной передачи данных WCF. Потоковая передача gRPC может обрабатывать обычные подключения к Интернету, подсистемы балансировки нагрузки и сети служб.

### <a name="deadlinetimeouts-and-cancellation"></a>Крайний срок, время ожидания и Отмена

gRPC позволяет клиентам указать максимальное время для завершения RPC. При превышении указанного крайнего срока сервер может отменить операцию независимо от клиента. Крайние сроки и отмены можно распространить с помощью дальнейших вызовов gRPC, чтобы обеспечить ограничение использования ресурсов. Клиенты также могут прерывать операции при превышении крайнего срока или более ранней (например, из-за взаимодействия с пользователем).

### <a name="security"></a>безопасность

gRPC является неявно защищенным, если используется HTTP/2 по отношению к сквозному шифрованному соединению TLS. Поддержка проверки подлинности с помощью сертификата клиента (см. [главу 6](security.md)) дополнительно повышает безопасность и доверие между клиентом и сервером.

>[!div class="step-by-step"]
>[Назад](network-protocols.md)
>[Вперед](protocol-buffers.md)
