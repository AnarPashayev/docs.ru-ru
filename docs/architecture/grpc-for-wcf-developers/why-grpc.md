---
title: Зачем использовать gRPC для разработчиков WCF — gRPC для разработчиков WCF
description: Обсуждение того, почему gRPC хорошо подходит для разработчиков WCF, стремящихся перейти на современные архитектуры и платформы.
ms.date: 09/02/2019
ms.openlocfilehash: da712e1ceee92f0a1a2661252dcda602f5dde9a0
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/12/2019
ms.locfileid: "73966944"
---
# <a name="why-grpc-is-recommended-for-wcf-developers"></a>Почему gRPC рекомендуется для разработчиков WCF

Прежде чем углубляться в язык и методы gRPC, стоит обсудить, почему gRPC является верным решением для разработчиков WCF, которые хотят перейти на .NET Core, учитывая, что доступны альтернативные варианты.

## <a name="similarity-to-wcf"></a>Сходство с WCF

Хотя его реализация и подход различаются, фактический опыт разработки и использования служб с gRPC должен быть интуитивно понятен для разработчиков WCF. Основная цель сделать возможным написание кода так, как если бы клиент и сервер находились на одной и той же платформе без необходимости беспокоиться о работе сети, — то же самое. Обе платформы совместно используют принцип объявления и реализации интерфейса, даже если процесс объявления этого интерфейса отличается. Как вы увидите в главе 5, различные типы вызовов RPC, поддерживаемые gRPC Map, очень хорошо подходят для различных привязок, доступных службам WCF.

## <a name="benefits-of-grpc"></a>Преимущества gRPC

Дополнительные причины, по которым gRPC соответствует другим решениям:

### <a name="performance"></a>Производительность

Как уже говорилось, использование HTTP/2 вместо HTTP/1.1 устраняет необходимость в восприятных сообщениях и вместо этого использует более быстрый двоичный протокол. Это более эффективно для анализа компьютеров. HTTP/2 также поддерживает запросы на мультиплексирование по одному соединению, позволяя отправлять ответы, как только они будут готовы, без ожидания в очереди (ошибка в HTTP/1.1, известная как "Блокировка" Headed-Line (HOL) "). При использовании gRPC требуется меньше ресурсов, что делает его хорошим решением для использования с мобильными устройствами и более медленными сетями.

### <a name="interoperability"></a>Взаимодействие

Существуют средства и библиотеки gRPC для всех основных языков программирования и платформ, включая .NET, Java, Python, Go, C++, Node. js, SWIFT, DART, Ruby и PHP. Благодаря протоколу буферов двоичного формата и эффективному созданию кода для каждой платформы разработчики могут создавать приложения, поддерживающие различные платформы.

### <a name="usability-and-productivity"></a>Удобство использования и производительность

gRPC — это комплексное решение RPC. Он работает единообразно на нескольких языках и платформах и предоставляет отличные средства, при этом большая часть необходимого стандартного кода сформирована автоматически, так что больше времени разработчика освобождается для того, чтобы сосредоточиться на бизнес-логике.

### <a name="streaming"></a>Streaming

в gRPC есть полная двунаправленная потоковая передача, которая обеспечивает очень похожую функциональность для полноценных служб в WCF. Потоковая передача gRPC может обрабатывать обычные подключения к Интернету, подсистемы балансировки нагрузки и сети служб.

### <a name="deadlinetimeouts-and-cancellation"></a>Крайний срок, время ожидания и Отмена

gRPC позволяет клиентам указать максимальное время для завершения RPC. Если превышен указанный крайний срок, сервер может отменить операцию независимо от клиента. Крайние сроки и отмены можно распространить с помощью дальнейших вызовов gRPC, чтобы обеспечить ограничение использования ресурсов. Клиенты также могут прерывать операции при превышении крайнего срока или более ранней (например, из-за взаимодействия с пользователем).

### <a name="security"></a>Безопасность

gRPC является неявно защищенным при использовании HTTP/2 по отношению к сквозному шифрованному соединению TLS. Поддержка проверки подлинности с помощью сертификата клиента (см. главу 6) дополнительно повышает безопасность и доверие между клиентом и сервером.

>[!div class="step-by-step"]
>[Назад](network-protocols.md)
>[Вперед](protocol-buffers.md)
