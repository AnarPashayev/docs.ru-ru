---
title: Шаблоны данных, ориентированные на облако
description: Создание архитектуры облачных приложений .NET для Azure | Собственные шаблоны данных в облаке
ms.date: 06/30/2019
ms.openlocfilehash: 9e90409b0b633796b452cfcfecb3896e79002d4d
ms.sourcegitcommit: 30a558d23e3ac5a52071121a52c305c85fe15726
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/25/2019
ms.locfileid: "75337426"
---
# <a name="cloud-native-data-patterns"></a><span data-ttu-id="6c339-103">Шаблоны данных, ориентированные на облако</span><span class="sxs-lookup"><span data-stu-id="6c339-103">Cloud-native data patterns</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="6c339-104">Хотя децентрализованные данные могут привести к повышению производительности, масштабируемости и экономии затрат, она также предоставляет множество проблем.</span><span class="sxs-lookup"><span data-stu-id="6c339-104">While decentralized data can lead to improved performance, scalability, and cost savings, it also presents many challenges.</span></span> <span data-ttu-id="6c339-105">Запросы данных между микрослужбами являются сложными.</span><span class="sxs-lookup"><span data-stu-id="6c339-105">Querying for data across microservices is complex.</span></span> <span data-ttu-id="6c339-106">Транзакция, охватывающая микрослужбы, должна управляться программно, так как распределенные транзакции не поддерживаются в облачных приложениях.</span><span class="sxs-lookup"><span data-stu-id="6c339-106">A transaction that spans microservices must be managed programmatically as distributed transactions aren't supported in cloud-native applications.</span></span> <span data-ttu-id="6c339-107">Вы перейдете из мира *немедленной согласованности* в *окончательную согласованность*.</span><span class="sxs-lookup"><span data-stu-id="6c339-107">You  move from a world of *immediate consistency* to *eventual consistency*.</span></span>

<span data-ttu-id="6c339-108">Сейчас мы обсудим эти проблемы.</span><span class="sxs-lookup"><span data-stu-id="6c339-108">We discuss these challenges now.</span></span>

## <a name="cross-service-queries"></a><span data-ttu-id="6c339-109">Запросы между службами</span><span class="sxs-lookup"><span data-stu-id="6c339-109">Cross-service queries</span></span>

<span data-ttu-id="6c339-110">Как приложение запрашивает данные, распределенные по нескольким независимым микрослужбам?</span><span class="sxs-lookup"><span data-stu-id="6c339-110">How does an application query data that is spread across many independent microservices?</span></span>

<span data-ttu-id="6c339-111">Этот сценарий показан на рис. 5-4.</span><span class="sxs-lookup"><span data-stu-id="6c339-111">Figure 5-4 shows this scenario.</span></span>

![Запросы между микрослужбами](./media/cross-service-query.png)

<span data-ttu-id="6c339-113">**Рис. 5-4**.</span><span class="sxs-lookup"><span data-stu-id="6c339-113">**Figure 5-4**.</span></span> <span data-ttu-id="6c339-114">Запросы между микрослужбами</span><span class="sxs-lookup"><span data-stu-id="6c339-114">Querying across microservices</span></span>

<span data-ttu-id="6c339-115">Обратите внимание, как на предыдущем рисунке показана микрослужба корзины покупок, которая добавляет элемент в корзину пользователя.</span><span class="sxs-lookup"><span data-stu-id="6c339-115">Note how in the previous figure we see a shopping basket microservice that adds an item to a user's shopping cart.</span></span> <span data-ttu-id="6c339-116">Хотя хранилище данных покупательской корзины содержит таблицу корзины и lineItem, она не содержит данных о продуктах или ценах, так как эти товары находятся в микрослужбах продукта и цены.</span><span class="sxs-lookup"><span data-stu-id="6c339-116">While the shopping basket's data store contains a basket and lineItem table, it doesn't contain product or pricing data as those items are found in the product and price microservices.</span></span> <span data-ttu-id="6c339-117">Чтобы добавить элемент, микрослужбе корзины покупок требуются данные и цены на продукты.</span><span class="sxs-lookup"><span data-stu-id="6c339-117">To add an item, the shopping basket microservice needs product data and pricing data.</span></span> <span data-ttu-id="6c339-118">Что такое параметры для получения данных о продуктах и ценах?</span><span class="sxs-lookup"><span data-stu-id="6c339-118">What are options to obtain the product and pricing data?</span></span>

<span data-ttu-id="6c339-119">На рис. 5-5 показано, как микрослужба корзины покупок выполняет прямой вызов по протоколу HTTP как к каталогу продуктов, так и к микрослужбам ценообразования.</span><span class="sxs-lookup"><span data-stu-id="6c339-119">Figure 5-5 shows the shopping basket microservice making a direct HTTP call to both the product catalog and pricing microservices.</span></span>

![Прямой обмен данными по протоколу HTTP](./media/direct-http-communication.png)

<span data-ttu-id="6c339-121">**Рис. 5-5**.</span><span class="sxs-lookup"><span data-stu-id="6c339-121">**Figure 5-5**.</span></span> <span data-ttu-id="6c339-122">Прямой обмен данными по протоколу HTTP</span><span class="sxs-lookup"><span data-stu-id="6c339-122">Direct HTTP communication</span></span>

<span data-ttu-id="6c339-123">В главе 4 мы обсуждали, как прямые вызовы HTTP между микрослужбами приводят к использованию системы и не считаются хорошей практикой.</span><span class="sxs-lookup"><span data-stu-id="6c339-123">While feasible to implement, in chapter 4 we discussed how direct HTTP calls across microservices couple the system and aren't considered a good practice.</span></span>

<span data-ttu-id="6c339-124">Можно реализовать микрослужбу агрегатора, показанную на рисунке 5-6.</span><span class="sxs-lookup"><span data-stu-id="6c339-124">We could implement an aggregator microservice shown in Figure 5-6.</span></span>

![Микрослужба агрегатора](./media/aggregator-microservice.png)

<span data-ttu-id="6c339-126">**Рис. 5-6**.</span><span class="sxs-lookup"><span data-stu-id="6c339-126">**Figure 5-6.**</span></span> <span data-ttu-id="6c339-127">Микрослужба агрегатора</span><span class="sxs-lookup"><span data-stu-id="6c339-127">Aggregator microservice</span></span>

<span data-ttu-id="6c339-128">Хотя этот подход инкапсулирует рабочий процесс бизнес-операций в отдельной микрослужбе, он добавляет сложность и по-прежнему приводит к прямым вызовам HTTP.</span><span class="sxs-lookup"><span data-stu-id="6c339-128">While this approach encapsulates the business operation workflow in an individual microservice, it adds complexity and still results in direct HTTP calls.</span></span>

<span data-ttu-id="6c339-129">Распространенный подход к выполнению запросов между службами использует [шаблон материализованных представлений](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), показанный на рис. 5-7.</span><span class="sxs-lookup"><span data-stu-id="6c339-129">A common approach for executing cross-service queries uses the [Materialized View Pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), shown in Figure 5-7.</span></span>

![Шаблон материализованных представлений](./media/materialized-view-pattern.png)

<span data-ttu-id="6c339-131">**Figure5-7**.</span><span class="sxs-lookup"><span data-stu-id="6c339-131">**Figure5-7**.</span></span> <span data-ttu-id="6c339-132">Шаблон материализованных представлений</span><span class="sxs-lookup"><span data-stu-id="6c339-132">Materialized View Pattern</span></span>

<span data-ttu-id="6c339-133">С помощью этого шаблона вы напрямую размещаете локальную таблицу (которая называется *моделью чтения*) в службе корзины покупок, которая содержит денормализованную копию данных, необходимых для микрослужб продукта и ценообразования.</span><span class="sxs-lookup"><span data-stu-id="6c339-133">With this pattern, you directly place a local table (known as a *read model*) in the shopping basket service that contains a denormalized copy of the data that is needed from the product and pricing microservices.</span></span> <span data-ttu-id="6c339-134">Помещение этих данных в микрослужбу корзины покупок устраняет необходимость в вызове дорогостоящих вызовов между службами.</span><span class="sxs-lookup"><span data-stu-id="6c339-134">Placing that data inside the shopping basket microservice eliminates the need for invoking expensive cross-service calls.</span></span> <span data-ttu-id="6c339-135">Данные, локальные для службы, позволяют повысить время отклика и надежность.</span><span class="sxs-lookup"><span data-stu-id="6c339-135">With the data local to the service, you improve response time and reliability.</span></span>

<span data-ttu-id="6c339-136">Перехватить этот подход, теперь у вас есть дублирующиеся данные в системе.</span><span class="sxs-lookup"><span data-stu-id="6c339-136">The catch with this approach is you now have duplicate data in your system.</span></span> <span data-ttu-id="6c339-137">В собственных системах в облаке дублированные данные не считаются [антишаблоном](https://en.wikipedia.org/wiki/Anti-pattern) и обычно реализуются в собственных системах в облаке.</span><span class="sxs-lookup"><span data-stu-id="6c339-137">In cloud-native systems, duplicate data isn't considered an [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern) and is commonly implemented in cloud-native systems.</span></span> <span data-ttu-id="6c339-138">Однако только одна система может быть владельцем любого набора данных, и необходимо реализовать механизм синхронизации для системы записи, чтобы обновить все связанные модели чтения, при каждом изменении базовых данных.</span><span class="sxs-lookup"><span data-stu-id="6c339-138">However, one and only one system can be the owner of any dataset, and you'll need to implement a synchronization mechanism for the system of record to update all of the associated read models, whenever a change to its underlying data occurs.</span></span>

## <a name="transactional-support"></a><span data-ttu-id="6c339-139">Поддержка транзакций</span><span class="sxs-lookup"><span data-stu-id="6c339-139">Transactional support</span></span>

<span data-ttu-id="6c339-140">Хотя запросы между микрослужбами являются сложной задачей, реализация транзакции между микрослужбами может быть сложной.</span><span class="sxs-lookup"><span data-stu-id="6c339-140">While queries across microservices are challenging, implementing a transaction across microservices can be complex.</span></span> <span data-ttu-id="6c339-141">Встроенная задача поддержания согласованности данных между источниками данных, которые находятся в разных микрослужбах, не может быть неполной.</span><span class="sxs-lookup"><span data-stu-id="6c339-141">The inherent challenge of maintaining data consistency across data sources that reside in different microservices can't be understated.</span></span> <span data-ttu-id="6c339-142">На рис. 5-8 показана проблема.</span><span class="sxs-lookup"><span data-stu-id="6c339-142">Figure 5-8 shows the problem.</span></span>

![Транзакция в шаблоне Saga](./media/saga-transaction-operation.png)

<span data-ttu-id="6c339-144">**Рис. 5-8**.</span><span class="sxs-lookup"><span data-stu-id="6c339-144">**Figure 5-8**.</span></span> <span data-ttu-id="6c339-145">Реализация транзакции по микрослужбам</span><span class="sxs-lookup"><span data-stu-id="6c339-145">Implementing a transaction across microservices</span></span>

<span data-ttu-id="6c339-146">Обратите внимание на то, как на предыдущем рисунке пять независимых микрослужб участвуют в распределенной транзакции *создания заказа* .</span><span class="sxs-lookup"><span data-stu-id="6c339-146">Note how in the previous figure five independent microservices all participate in a distributed *Create Order* transaction.</span></span> <span data-ttu-id="6c339-147">Однако транзакция для каждой из пяти отдельных микрослужб должна завершиться с ошибкой, или все они должны прерываться и выполнять откат операции.</span><span class="sxs-lookup"><span data-stu-id="6c339-147">However, the transaction for each of the five individual microservices must succeed, or all must abort and roll back the operation.</span></span> <span data-ttu-id="6c339-148">Хотя встроенная поддержка транзакций доступна внутри каждой микрослужбы, распределенная транзакция не поддерживается во всех пяти службах.</span><span class="sxs-lookup"><span data-stu-id="6c339-148">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction across all five services.</span></span>

<span data-ttu-id="6c339-149">Так как поддержка транзакций необходима для того, чтобы эта операция поддерживала согласованность данных в каждой микрослужбе, необходимо программно создать распределенную транзакцию.</span><span class="sxs-lookup"><span data-stu-id="6c339-149">Since transactional support is essential for this operation to keep the data consistent in each of the microservices, you have to programmatically construct a distributed transaction.</span></span>

<span data-ttu-id="6c339-150">Популярным шаблоном программного добавления поддержки транзакций является [шаблон Saga](https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/).</span><span class="sxs-lookup"><span data-stu-id="6c339-150">A popular pattern for programmatically adding transactional support is the [Saga pattern](https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/).</span></span> <span data-ttu-id="6c339-151">Он реализуется путем группирования локальных транзакций вместе и последовательного вызова каждого из них.</span><span class="sxs-lookup"><span data-stu-id="6c339-151">It's implemented by grouping local transactions together and sequentially invoking each one.</span></span> <span data-ttu-id="6c339-152">Если локальная транзакция завершается ошибкой, Saga прерывает операцию и вызывает набор [компенсирующих транзакций](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction) для отмены изменений, внесенных предыдущими локальными транзакциями.</span><span class="sxs-lookup"><span data-stu-id="6c339-152">If a local transaction fails, the Saga aborts the operation and invokes a set of [compensating transactions](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction) to undo the changes made by the preceding local transactions.</span></span> <span data-ttu-id="6c339-153">На рис. 5-9 показана неудачная транзакция с шаблоном Saga.</span><span class="sxs-lookup"><span data-stu-id="6c339-153">Figure 5-9 shows a failed transaction with the Saga pattern.</span></span>

![Откат в шаблоне Saga](./media/saga-rollback-operation.png)

<span data-ttu-id="6c339-155">**Рис. 5-9**.</span><span class="sxs-lookup"><span data-stu-id="6c339-155">**Figure 5-9**.</span></span> <span data-ttu-id="6c339-156">Откат транзакции</span><span class="sxs-lookup"><span data-stu-id="6c339-156">Rolling back a transaction</span></span>

<span data-ttu-id="6c339-157">Обратите внимание на то, как на предыдущем рисунке операция *женератеконтент* завершилась сбоем в микрослужбе музыки.</span><span class="sxs-lookup"><span data-stu-id="6c339-157">Note how in the previous figure the *GenerateContent* operation has failed in the music microservice.</span></span> <span data-ttu-id="6c339-158">Saga вызывает компенсирующие транзакции (красным цветом) для удаления содержимого, отмены платежа и отмены заказа, возвращая данные для каждой микрослужбы обратно в противоречивое состояние.</span><span class="sxs-lookup"><span data-stu-id="6c339-158">The Saga invokes compensating transactions (in red) to remove the content, cancel the payment, and cancel the order, returning the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="6c339-159">Шаблоны Saga обычно организуются как ряд связанных событий или организованы в виде набора связанных команд.</span><span class="sxs-lookup"><span data-stu-id="6c339-159">Saga patterns are typically choreographed as a series of related events or orchestrated as a set of related commands.</span></span>

## <a name="cqrs-pattern"></a><span data-ttu-id="6c339-160">Шаблон CQRS</span><span class="sxs-lookup"><span data-stu-id="6c339-160">CQRS pattern</span></span>

<span data-ttu-id="6c339-161">CQRS или [Разделение команд и запросов](https://docs.microsoft.com/azure/architecture/patterns/cqrs)— шаблон архитектуры, который разделяет операции, считывающие данные из тех, которые записывают данные.</span><span class="sxs-lookup"><span data-stu-id="6c339-161">CQRS, or [Command and Query Responsibility Segregation](https://docs.microsoft.com/azure/architecture/patterns/cqrs), is an architectural pattern that separate operations that read data from those that write data.</span></span> <span data-ttu-id="6c339-162">Этот шаблон помогает повысить производительность, масштабируемость и безопасность.</span><span class="sxs-lookup"><span data-stu-id="6c339-162">This pattern can help maximize performance, scalability, and security.</span></span>

<span data-ttu-id="6c339-163">В обычных сценариях доступа к данным реализуется одна модель (объект сущности и репозитория), которая *выполняет операции* чтения и записи данных.</span><span class="sxs-lookup"><span data-stu-id="6c339-163">In normal data access scenarios, you implement a single model (entity and repository object) that perform *both* read and write data operations.</span></span>

<span data-ttu-id="6c339-164">Однако более продвинутый сценарий доступа к данным может выиграть от отдельных моделей и таблиц данных для операций чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="6c339-164">However, a more advanced data access scenario might benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="6c339-165">Чтобы повысить производительность, операция считывания, известная как *запрос*, может выполнить запрос к строго денормализованному представлению данных, чтобы избежать дорогостоящих повторяющихся соединений таблиц.</span><span class="sxs-lookup"><span data-stu-id="6c339-165">To improve performance, the read operation, known as a *query*, might query against a highly denormalized representation of the data to avoid expensive repetitive table joins.</span></span> <span data-ttu-id="6c339-166">В то время как операция *записи* , называемая *командой*, может обновляться по полностью нормализованному представлению данных.</span><span class="sxs-lookup"><span data-stu-id="6c339-166">Whereas the *write* operation, known as a *command*, might update against a fully normalized representation of the data.</span></span> <span data-ttu-id="6c339-167">Затем необходимо реализовать механизм, обеспечивающий синхронизацию обоих представлений. Как правило, при изменении таблицы записи возникает событие, которое реплицирует изменение данных в таблицу чтения.</span><span class="sxs-lookup"><span data-stu-id="6c339-167">You would then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it raises an event that replicates the data modification to the read table.</span></span>

<span data-ttu-id="6c339-168">На рис. 5-10 показана реализация шаблона CQRS.</span><span class="sxs-lookup"><span data-stu-id="6c339-168">Figure 5-10 shows an implementation of the CQRS pattern.</span></span>

![Реализация CQRS](./media/cqrs-implementation.png)

<span data-ttu-id="6c339-170">**Рис. 5-10**.</span><span class="sxs-lookup"><span data-stu-id="6c339-170">**Figure 5-10**.</span></span> <span data-ttu-id="6c339-171">Реализация CQRS</span><span class="sxs-lookup"><span data-stu-id="6c339-171">CQRS implementation</span></span>

<span data-ttu-id="6c339-172">Обратите внимание на то, как на предыдущем рисунке реализована отдельная модель команд и запросов.</span><span class="sxs-lookup"><span data-stu-id="6c339-172">Note how in the previous figure separate command and query models are implemented.</span></span> <span data-ttu-id="6c339-173">Более того, каждая операция записи данных сохраняется в хранилище записи и затем передается в хранилище для чтения.</span><span class="sxs-lookup"><span data-stu-id="6c339-173">Moreover, each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="6c339-174">Обратите особое внимание на то, как процесс распространения работает с принципом [окончательной согласованности](https://www.cloudcomputingpatterns.org/eventual_consistency/), в то время как модель чтения в конечном итоге синхронизируется с моделью записи, но в процессе может возникнуть некоторое запаздывание.</span><span class="sxs-lookup"><span data-stu-id="6c339-174">Pay close attention to how the propagation process operates on the principle of [eventual consistency](https://www.cloudcomputingpatterns.org/eventual_consistency/), whereas the read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span>

<span data-ttu-id="6c339-175">Реализуя разделение, вы можете масштабировать операции чтения и записи отдельно.</span><span class="sxs-lookup"><span data-stu-id="6c339-175">By implementing separation, you have the ability to scale reads and writes separately.</span></span> <span data-ttu-id="6c339-176">Кроме того, при операциях записи может быть обеспечена более строгая безопасность, чем в отношении операций чтения.</span><span class="sxs-lookup"><span data-stu-id="6c339-176">As well, you might impose tighter security on write operations than those concerning reads.</span></span>

<span data-ttu-id="6c339-177">Как правило, шаблоны CQRS применяются к ограниченным разделам системы в зависимости от конкретных потребностей.</span><span class="sxs-lookup"><span data-stu-id="6c339-177">Typically, CQRS patterns are applied to limited sections of your system based upon specific needs.</span></span>

## <a name="relational-vs-nosql"></a><span data-ttu-id="6c339-178">Реляционная VS NoSQL</span><span class="sxs-lookup"><span data-stu-id="6c339-178">Relational vs NoSQL</span></span>

<span data-ttu-id="6c339-179">Влияние технологий [NoSQL](https://www.geeksforgeeks.org/introduction-to-nosql/) не может быть слишком строгим, особенно для распределенных облачных систем.</span><span class="sxs-lookup"><span data-stu-id="6c339-179">The impact of [NoSQL](https://www.geeksforgeeks.org/introduction-to-nosql/) technologies can't be overstated, especially for distributed cloud-native systems.</span></span> <span data-ttu-id="6c339-180">Распространение новых технологий для работы с данными в этом пространстве приводит к нарушению работы решений, которые в монопольном режиме пополагались на реляционные базы данных.</span><span class="sxs-lookup"><span data-stu-id="6c339-180">The proliferation of new data technologies in this space has disrupted solutions that once exclusively relied on relational databases.</span></span>

<span data-ttu-id="6c339-181">С одной стороны, реляционные базы данных были распространенной технологией для десятилетий.</span><span class="sxs-lookup"><span data-stu-id="6c339-181">On the one side, relational databases have been a prevalent technology for decades.</span></span> <span data-ttu-id="6c339-182">Они являются зрелыми, проверенными и широко реализованными.</span><span class="sxs-lookup"><span data-stu-id="6c339-182">They're mature, proven, and widely implemented.</span></span> <span data-ttu-id="6c339-183">Конкурирующие продукты баз данных, опыт и инструментарий абаундс.</span><span class="sxs-lookup"><span data-stu-id="6c339-183">Competing database products, expertise and tooling abounds.</span></span> <span data-ttu-id="6c339-184">Реляционные базы данных предоставляют хранилище связанных таблиц данных.</span><span class="sxs-lookup"><span data-stu-id="6c339-184">Relational databases provide a store of related data tables.</span></span> <span data-ttu-id="6c339-185">Эти таблицы имеют фиксированную схему, используют SQL (язык SQL) для управления данными и имеют гарантии [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) (также известной как атомарность, согласованность, изоляция и устойчивость).</span><span class="sxs-lookup"><span data-stu-id="6c339-185">These tables have a fixed schema, use SQL (Structured Query Language) to manage data and have [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) (also known as Atomicity, Consistency, Isolation, and Durability) guarantees.</span></span>

<span data-ttu-id="6c339-186">Базы данных No-SQL, на другой стороне, относятся к высокопроизводительным, нереляционным хранилищам данных.</span><span class="sxs-lookup"><span data-stu-id="6c339-186">No-SQL databases, on the other side, refer to high-performance, non-relational data stores.</span></span> <span data-ttu-id="6c339-187">Эти приложения Excel позволяют легко использовать, масштабируемость, устойчивость и характеристики доступности.</span><span class="sxs-lookup"><span data-stu-id="6c339-187">They excel in their ease-of-use, scalability, resilience, and availability characteristics.</span></span> <span data-ttu-id="6c339-188">Вместо объединения таблиц нормализованных данных NoSQL хранит Самоописывающие (без схемы) данные обычно в документах JSON.</span><span class="sxs-lookup"><span data-stu-id="6c339-188">Instead of joining tables of normalized data, NoSQL stores self-describing (schemaless) data typically in JSON documents.</span></span> <span data-ttu-id="6c339-189">Они не предлагают гарантий [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) .</span><span class="sxs-lookup"><span data-stu-id="6c339-189">They don't offer [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) guarantees.</span></span>

<span data-ttu-id="6c339-190">Способ понять различия между этими типами баз данных можно найти в [теоремае Cap](https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e), наборе принципов, которые можно применить к распределенным системам, в которых хранится состояние.</span><span class="sxs-lookup"><span data-stu-id="6c339-190">A way to understand the differences between these types of databases can be found in the [CAP theorem](https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e), a set of principles that can be applied to distributed systems that store state.</span></span> <span data-ttu-id="6c339-191">На рис. 5-11 показаны три свойства теоремаа CAP.</span><span class="sxs-lookup"><span data-stu-id="6c339-191">Figure 5-11 shows the three properties of the CAP theorem.</span></span>

![Теорема CAP](./media/cap-theorem.png)

<span data-ttu-id="6c339-193">**Рис. 5-11**.</span><span class="sxs-lookup"><span data-stu-id="6c339-193">**Figure 5-11**.</span></span> <span data-ttu-id="6c339-194">Теорема CAP</span><span class="sxs-lookup"><span data-stu-id="6c339-194">The CAP theorem</span></span>

<span data-ttu-id="6c339-195">Теорема утверждает, что любая распределенная система данных будет предоставлять компромисс между согласованностью, доступностью и отклонениям секций, и что любая база данных может гарантировать только два из трех свойств:</span><span class="sxs-lookup"><span data-stu-id="6c339-195">The theorem states that any distributed data system will offer a trade-off between consistency, availability, and partition tolerance, and that any database can only guarantee two of the three properties:</span></span>

- <span data-ttu-id="6c339-196">*Согласованность*. Каждый узел в кластере будет отвечать последним данным, даже если он требует блокировки запроса, пока все реплики не будут правильно обновлены.</span><span class="sxs-lookup"><span data-stu-id="6c339-196">*Consistency*: every node in the cluster will respond with the most recent data, even if it requires blocking a request until all replicas are correctly updated.</span></span>

- <span data-ttu-id="6c339-197">*Доступность*. Каждый узел будет возвращать ответ в разумное время, даже если этот ответ не является самыми последними данными.</span><span class="sxs-lookup"><span data-stu-id="6c339-197">*Availability*: every node will return a response in a reasonable amount of time, even if that response isn't the most recent data.</span></span>

- <span data-ttu-id="6c339-198">*Допуск секции*: гарантирует, что система продолжит работу в случае сбоя узла или потери связи с другим.</span><span class="sxs-lookup"><span data-stu-id="6c339-198">*Partition Tolerance*: guarantees that the system will continue operating if a node fails or loses connectivity with another.</span></span>

<span data-ttu-id="6c339-199">Реляционные базы данных представляют согласованность и доступность, но не допускают отклонения секций.</span><span class="sxs-lookup"><span data-stu-id="6c339-199">Relational databases exhibit consistency and availability, but not partition tolerance.</span></span> <span data-ttu-id="6c339-200">Секционирование реляционной базы данных, например сегментирование, является сложной задачей и может повлиять на производительность.</span><span class="sxs-lookup"><span data-stu-id="6c339-200">Partitioning a relational database, such as sharding, is difficult and can impact performance.</span></span>

<span data-ttu-id="6c339-201">С другой стороны, базы данных NoSQL обычно демонстрируют допустимость разбиения на разделы, которая называется горизонтальной масштабируемостью и высокой доступностью.</span><span class="sxs-lookup"><span data-stu-id="6c339-201">On the other hand, NoSQL databases typically exhibit partition tolerance, known as horizontal scalability, and high availability.</span></span> <span data-ttu-id="6c339-202">Как теорема ограничения указывает, вы можете иметь только два из трех принципов, и вы потеряли свойство согласованности.</span><span class="sxs-lookup"><span data-stu-id="6c339-202">As the CAP theorem specifies, you can only have two of the three principles, and you lose the  consistency property.</span></span>

<span data-ttu-id="6c339-203">Базы данных NoSQL распределяются и обычно масштабируются на серверах.</span><span class="sxs-lookup"><span data-stu-id="6c339-203">NoSQL databases are distributed and commonly scaled out across commodity servers.</span></span> <span data-ttu-id="6c339-204">Это может обеспечить высокую доступность как внутри, так и между географическими регионами с меньшими затратами.</span><span class="sxs-lookup"><span data-stu-id="6c339-204">Doing so can provide great availability, both within and across geographical regions at a reduced cost.</span></span> <span data-ttu-id="6c339-205">Данные можно секционировать и реплицировать на этих компьютерах или узлах, обеспечивая избыточность и отказоустойчивость.</span><span class="sxs-lookup"><span data-stu-id="6c339-205">Data can be partitioned and replicated across these machines, or nodes, providing redundancy and fault tolerance.</span></span> <span data-ttu-id="6c339-206">Недостатком является согласованность.</span><span class="sxs-lookup"><span data-stu-id="6c339-206">The downside is consistency.</span></span> <span data-ttu-id="6c339-207">Изменение данных на одном узле NoSQL может занять некоторое время для распространения на другие узлы.</span><span class="sxs-lookup"><span data-stu-id="6c339-207">A change to data on one NoSQL node can take some time to propagate to other nodes.</span></span> <span data-ttu-id="6c339-208">Как правило, узел базы данных NoSQL предоставит немедленный ответ на запрос, даже если данные, которые он представляет, устарели и еще не обновлены.</span><span class="sxs-lookup"><span data-stu-id="6c339-208">Typically, a NoSQL database node will provide an immediate response to a query, even if the data that it is presenting is stale and has not been updated yet.</span></span>

<span data-ttu-id="6c339-209">Это известная [Окончательная согласованность](https://www.cloudcomputingpatterns.org/eventual_consistency/), характеристика распределенных систем данных, в которой транзакции ACID не поддерживаются.</span><span class="sxs-lookup"><span data-stu-id="6c339-209">This is known [eventual consistency](https://www.cloudcomputingpatterns.org/eventual_consistency/), a characteristic of distributed data systems where ACID transactions aren't supported.</span></span> <span data-ttu-id="6c339-210">Это небольшая задержка между обновлением элемента данных и временем, которое требуется для распространения этого обновления на каждый из узлов реплик.</span><span class="sxs-lookup"><span data-stu-id="6c339-210">It's a brief delay between the update of a data item and time that it takes to propagate that update to each of the replica nodes.</span></span> <span data-ttu-id="6c339-211">Если обновить элемент продукта в базе данных NoSQL в США, но в то же время запросите тот же элемент данных из узла реплики в Европе, вы можете получить сведения о продукте более ранней версии до тех пор, пока не будет обновлен Европейский узел с изменением продукта.</span><span class="sxs-lookup"><span data-stu-id="6c339-211">If you update a product item in a NoSQL database in the United States, but at same time query that same data item from a replica node in Europe, you might retrieve the earlier product information - until the European node has been updated with product change.</span></span> <span data-ttu-id="6c339-212">Компромисс заключается в том, что благодаря [надежной согласованности](https://en.wikipedia.org/wiki/Strong_consistency), ожидающей обновления всех узлов реплики перед возвратом результата запроса, можно поддерживать огромные масштабы и объем трафика, но с возможностью представления более старых данных.</span><span class="sxs-lookup"><span data-stu-id="6c339-212">The trade-off is that by giving up [strong consistency](https://en.wikipedia.org/wiki/Strong_consistency),  waiting for all replica nodes to update before returning a query result, you can support enormous scale and traffic volume, but with the possibility of presenting older data.</span></span>

<span data-ttu-id="6c339-213">Базы данных NoSQL можно классифицировать по следующим четырем моделям:</span><span class="sxs-lookup"><span data-stu-id="6c339-213">NoSQL databases can be categorized by the following four models:</span></span>

- <span data-ttu-id="6c339-214">*Хранилище документов* (MongoDB, CouchDB, Couchbase): данные (и соответствующие метаданные) хранятся нереляционно в денормализованных документах на основе JSON внутри базы данных.</span><span class="sxs-lookup"><span data-stu-id="6c339-214">*Document Store* (MongoDB, CouchDB, Couchbase): data (and corresponding metadata) is stored non-relationally in denormalized JSON-based documents inside the database.</span></span>

- <span data-ttu-id="6c339-215">*Хранилище "ключ — значение* " (Redis, Риак, memcached): данные хранятся в виде простых пар "ключ-значение" с системными операциями, выполняемыми по уникальному ключу доступа, сопоставленному со значением данных пользователя.</span><span class="sxs-lookup"><span data-stu-id="6c339-215">*Key/Value Store* (Redis, Riak, memcached): data is stored in simple key-value pairs with system operations performed against a unique access key that is mapped to a value of user data.</span></span>

- <span data-ttu-id="6c339-216">*Хранилище в широких столбцах* (HBase, Cassandra). связанные данные хранятся в формате столбцов в виде набора пар «вложенные ключ-значение» в одном столбце, при этом данные обычно извлекаются в виде одной единицы без объединения нескольких таблиц.</span><span class="sxs-lookup"><span data-stu-id="6c339-216">*Wide-Column Store* (HBase, Cassandra): related Data is stored in a columnar format as a set of nested-key/value pairs within a single column with data typically retrieved as a single unit without having to join multiple tables together.</span></span>

- <span data-ttu-id="6c339-217">*Хранилища графов* (neo4j, Titan): данные хранятся в виде графического представления внутри узла вместе с краями, задающих связь между узлами.</span><span class="sxs-lookup"><span data-stu-id="6c339-217">*Graph stores* (neo4j, titan): data is stored as a graphical representation within a node along with edges that specify the relationship between the nodes.</span></span>

<span data-ttu-id="6c339-218">Базы данных NoSQL можно оптимизировать для работы с крупномасштабными данными, особенно если данные относительно просты.</span><span class="sxs-lookup"><span data-stu-id="6c339-218">NoSQL databases can be optimized to deal with large-scale data, especially when the data is relatively simple.</span></span> <span data-ttu-id="6c339-219">Рассмотрим базу данных NoSQL, когда:</span><span class="sxs-lookup"><span data-stu-id="6c339-219">Consider a NoSQL database when:</span></span>

- <span data-ttu-id="6c339-220">Для рабочей нагрузки требуется большой масштаб и высокая степень параллелизма.</span><span class="sxs-lookup"><span data-stu-id="6c339-220">Your workload requires a large scale and high concurrency.</span></span>
- <span data-ttu-id="6c339-221">У вас большое число пользователей.</span><span class="sxs-lookup"><span data-stu-id="6c339-221">You have large numbers of users.</span></span>
- <span data-ttu-id="6c339-222">Данные могут быть выражены просто без связей.</span><span class="sxs-lookup"><span data-stu-id="6c339-222">Your data can be expressed simply without relationships.</span></span>
- <span data-ttu-id="6c339-223">Необходимо географически распределить данные.</span><span class="sxs-lookup"><span data-stu-id="6c339-223">You need to geographically distribute your data.</span></span>
- <span data-ttu-id="6c339-224">Вам не нужны гарантии ACID.</span><span class="sxs-lookup"><span data-stu-id="6c339-224">You don't need ACID guarantees.</span></span>
- <span data-ttu-id="6c339-225">Будет развернут на оборудование для товара.</span><span class="sxs-lookup"><span data-stu-id="6c339-225">Will be deployed to commodity hardware.</span></span>

<span data-ttu-id="6c339-226">Затем рассмотрим реляционную базу данных в следующих случаях:</span><span class="sxs-lookup"><span data-stu-id="6c339-226">Then, consider a relational database when:</span></span>

- <span data-ttu-id="6c339-227">Для рабочих нагрузок требуется средний или большой масштаб.</span><span class="sxs-lookup"><span data-stu-id="6c339-227">Your workloads require medium to large scale.</span></span>
- <span data-ttu-id="6c339-228">Параллелизм не является серьезной проблемой.</span><span class="sxs-lookup"><span data-stu-id="6c339-228">Concurrency isn't a major concern.</span></span>
- <span data-ttu-id="6c339-229">Необходимы гарантии ACID.</span><span class="sxs-lookup"><span data-stu-id="6c339-229">ACID guarantees are needed.</span></span>
- <span data-ttu-id="6c339-230">Данные лучше выразить реляционно.</span><span class="sxs-lookup"><span data-stu-id="6c339-230">Data is best expressed relationally.</span></span>
- <span data-ttu-id="6c339-231">Приложение будет развернуто на большом и высоком оборудовании.</span><span class="sxs-lookup"><span data-stu-id="6c339-231">Your application will be deployed to large, high-end hardware.</span></span>

<span data-ttu-id="6c339-232">Далее мы рассмотрим хранилище данных в облаке Azure.</span><span class="sxs-lookup"><span data-stu-id="6c339-232">Next, we look at data storage in the Azure cloud.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="6c339-233">[Назад](distributed-data.md)
>[Вперед](azure-data-storage.md)</span><span class="sxs-lookup"><span data-stu-id="6c339-233">[Previous](distributed-data.md)
[Next](azure-data-storage.md)</span></span>
