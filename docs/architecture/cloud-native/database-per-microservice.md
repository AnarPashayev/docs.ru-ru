---
title: Одна база данных для каждой микрослужбы
description: Контрастное хранение данных в монолитных и облачных приложениях.
author: robvet
ms.date: 01/22/2020
ms.openlocfilehash: c0c5611fa866d70f155e4bdad2eee1181b13c065
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79141449"
---
# <a name="database-per-microservice"></a>Одна база данных для каждой микрослужбы

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

Как мы видели в этой книге, облачный подход изменяет способ проектирования, развертывания и управления приложениями. Это также изменяет способ управления и хранения данных.

Рисунок 5-1 контрастирует различия.

![Хранение данных в облачных приложениях](./media/distributed-data.png)

**Рисунок 5-1**. Управление данными в облачных приложениях

Опытные разработчики легко узнают архитектуру на левой стороне фигуры 5-1. В этом *монолитном приложении*компоненты бизнес-услуг объединяются в общий уровень служб, обмениваясь данными из единой реляционной базы данных.

Во многих отношениях единая база данных обеспечивает простоту управления данными. Запрос данных в нескольких таблицах прост. Изменения в обновлении данных вместе или все они откат. [Операции ACID](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties) гарантируют сильную и немедленную последовательность.

Разрабатывая для облачных носителей, мы подходим по-другому. Справа от рисунка 5-1 обратите внимание на то, как бизнес-функциональность сегрегируется на небольшие независимые микрослужбы. Каждая микрослужба инкапсулирует определенные бизнес-возможности и свои собственные данные. Монолитная база данных разлагается на распределенную модель данных с большим количеством меньших баз данных, каждая из которых выравнивается с микрослужбой. Когда дым очищается, мы выходим с дизайном, который предоставляет *базу данных в микрослужбе.*

## <a name="why"></a>Почему?

Эта база данных на микроуслугу дает много преимуществ, особенно для систем, которые должны быстро развиваться и поддерживать массовый масштаб. С этой моделью...

- Данные домена инкапсулируются в службе
- Схема данных может развиваться, не влияя непосредственно на другие службы
- Каждый хранилище данных может самостоятельно масштабировать
- Сбой хранилища данных в одной службе не повлияет непосредственно на другие службы

Сегрегирование данных также позволяет каждой микрослужбе реализовать тип хранилища данных, который лучше всего оптимизировать для его рабочей нагрузки, потребностей в хранении и шаблонов чтения/записи. Выбор включает реляционные, документальные, ключевые значения и даже хранилища данных на основе графика.

На рисунке 5-2 представлен принцип сохранения полиглота в облачной системе.

![Сохранение данных Polyglot](./media/polyglot-data-persistence.png)

**Рисунок 5-2**. Сохранение данных Polyglot

Обратите внимание на предыдущую цифру, как каждая микрослужба поддерживает другой тип хранилища данных.

- Микрослужба каталога продуктов потребляет реляционную базу данных для размещения богатой реляционной структуры базовых данных.
- Микрослужба корзины потребляет распределенный кэш, который поддерживает его простой, ключевой запас данных.
- Заказ микрослужбы потребляет как базу данных документов NoSql для записи операций, а также высоко денормализованный магазин ключей/значений для размещения больших объемов считывающих операций.
  
В то время как реляционные базы данных остаются актуальными для микрослужб со сложными данными, базы данных НоСЗЛ приобрели значительную популярность. Они обеспечивают массовый масштаб и высокую доступность. Их бессхемативная природа позволяет разработчикам отойти от архитектуры типов набранных данных и ORM, которые делают изменения дорогостоящими и трудоемкими. Позже в этой главе мы рассмотрим базы данных NoS'L.

 Хотя инкапсуляция данных в отдельные микрослужбы может повысить гибкость, производительность и масштабируемость, она также создает множество проблем. В следующем разделе мы обсуждаем эти проблемы вместе с шаблонами и практиками, помогая их преодолеть.  

## <a name="cross-service-queries"></a>Запросы кросс-сервисов

Хотя микрослужбы независимы и сосредоточены на конкретных функциональных возможностях, таких как инвентаризация, доставка или заказ, они часто требуют интеграции с другими микрослужбами. Часто интеграция включает в себя один микрослужбы *запрос другой* для данных. На рисунке 5-3 показан сценарий.

![Запрос через микрослужбы](./media/cross-service-query.png)

**Рисунок 5-3**. Запрос через микрослужбы

На предыдущем рисунке мы видим микросервис корзины покупок, который добавляет товар в корзину покупок пользователя. В то время как хранилище данных для этой микрослужбы содержит данные о корзинах и элементах строки, оно не поддерживает данные о продукте или ценах. Вместо этого эти элементы данных принадлежат каталогу и микросервисам ценообразования. Это создает проблему. Как микросервис корзины покупок может добавлять продукт в корзину пользователей, если в его базе данных нет ни продуктов, ни ценовых данных?

Одним из вариантов, обсуждаемых в главе 4, является [прямой звонок HTTP](service-to-service-communication.md#queries) из корзины покупок в каталог и ценообразование микроуслуг. Тем не менее, в главе 4, мы сказали, синхронные HTTP звонки *пара* микрослужб вместе, уменьшая их автономность и уменьшая их архитектурные преимущества.

Мы также можем реализовать шаблон запрос-ответ с отдельными входящими и исходящими очередями для каждой службы. Тем не менее, эта схема является сложной и требует сантехника для корреляции запроса и ответ сообщений.
В то время как он отделяет вызовы бэкэнда микрослужбы, служба вызова должна все еще синхронно ждать вызова для завершения. Перегрузка сети, переходные сбои или перегруженная микрослужба могут привести к длительным и даже неудачным операциям.

Вместо этого общепринятым шаблоном для удаления зависимостей кросс-сервисов является [шаблон Materialized View,](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)показанный на рисунке 5-4.

![Материализованный шаблон представления](./media/materialized-view-pattern.png)

**Рисунок 5-4**. Материализованный шаблон представления

С помощью этого шаблона вы размещаете локальную таблицу данных (известную как *модель чтения)* в службу корзины покупок. Эта таблица содержит денормализованную копию данных, необходимых от микросервисов продукта и ценообразования. Копирование данных непосредственно в микросервис корзины устраняет необходимость в дорогостоящих перекрестных вызовах. С локальной службой данных вы улучшаете время отклика и надежность службы. Кроме того, наличие собственной копии данных делает услугу корзины покупок более устойчивой. Если служба каталога станет недоступной, это не повлияет непосредственно на службу корзины покупок. Корзина покупок может продолжать работать с данными из собственного магазина.

Загвоздка в том, что теперь у вас есть дубликаты данных в вашей системе. Однако *стратегически* дублирование данных в облачных системах является установившейся практикой и не считается антишаблоном или плохой практикой. Имейте в виду, что *одна и только одна служба* может владеть набором данных и иметь над ним полномочия. При обновлении системы записи необходимо синхронизировать считываемые модели. Синхронизация обычно осуществляется с помощью асинхронных сообщений с [шаблоном публикации/подписки,](service-to-service-communication.md#events)как показано на рисунке 5.4.

## <a name="distributed-transactions"></a>Распределенные транзакции

Хотя запрос данных в микрослужбах затруднен, реализация транзакции в нескольких микрослужбах является еще более сложной задачей. Неможет быть занижена неотъемлемая задача поддержания согласованности данных в независимых источниках данных в различных микрослужбах. Отсутствие распределенных транзакций в облачных приложениях означает, что вы должны управлять распределенными транзакциями программно. Вы переходите из мира *немедленной последовательности* в мир *возможной последовательности.*

На рисунке 5-5 показана проблема.

![Транзакция в шаблоне саги](./media/saga-transaction-operation.png)

**Рисунок 5-5**. Реализация транзакции в микрослужбах

В предыдущем рисунке пять независимых микрослужб участвуют в распределенной транзакции, которая создает заказ. Каждая микрослужба поддерживает свой собственный хранилище данных и реализует локальную транзакцию для своего хранилища. Чтобы создать заказ, локальная транзакция для *каждой отдельной* микрослужбы должна быть успешной, или *все* должны прервать и откатить операцию. В то время как встроенная транзакционная поддержка доступна внутри каждой из микрослужб, нет поддержки распределенной транзакции, которая охватила бы все пять служб, чтобы сохранить данные в соответствии.

Вместо этого необходимо построить эту *распределенную транзакцию программно.*

Популярным шаблоном для добавления распределенной транзакционной поддержки является шаблон Saga. Она реализуется путем группирования локальных транзакций вместе программно и последовательно, ссылаясь на каждый из них. Если какая-либо из локальных транзакций не удается, Saga прерывает операцию и вызывает набор [компенсирующих транзакций.](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction) Компенсаторные транзакции отменяют изменения, внесенные предыдущими локальными транзакциями, и восстанавливают согласованность данных. На рисунке 5-6 показана неудачная транзакция с шаблоном Saga.

![Откат в саге шаблон](./media/saga-rollback-operation.png)

**Рисунок 5-6**. Откат транзакции

На предыдущем рисунке операция *обновления инвентаризации* не прошла в микрослужбе инвентаризации. Saga вызывает набор компенсирующих транзакций (красным цветом) для корректировки количества запасов, отмены платежа и заказа и возвращения данных по каждой микрослужбе в согласованное состояние.

Шаблоны саги обычно хореографии как ряд связанных событий, или организованы как набор связанных команд. В главе 4 мы обсудили шаблон агрегатора услуг, который будет основой для реализации сагы. Мы также обсудили события наряду с вопросами Azure Service Bus и Azure Event Grid, которые станут основой для реализации хореографической саги.

## <a name="high-volume-data"></a>Данные о высоком объеме

Крупные облачные приложения часто поддерживают требования к большим объемам данных. В этих сценариях традиционные методы хранения данных могут вызвать узкие места. Для сложных систем, развертываемых в больших масштабах, как Command, так и сегрегация ответственности запросов (C'RS) и Event Sourcing могут повысить производительность приложения.  

### <a name="cqrs"></a>CQRS

[C'RS](https://docs.microsoft.com/azure/architecture/patterns/cqrs), — это архитектурный шаблон, который может помочь повысить производительность, масштабируемость и безопасность. Шаблон отделяет операции, которые считываются данные, от тех операций, которые пишут данные.

Для обычных сценариев одна и та же модель сущности и объект репозитория данных используются *как* для операций чтения, так и для записи.

Однако сценарий данных с большим объемом может быть выгодна для отдельных моделей и таблиц данных для чтения и записи. Чтобы повысить производительность, считывательная операция может задать запрос против сильно денормализованного представления данных, чтобы избежать дорогостоящих повторяющихся соединений таблиц и блокировок таблиц. Операция *записи,* известная как *команда,* будет обновляться на фоне полностью нормализованного представления данных, которые гарантировали бы согласованность. Затем необходимо реализовать механизм синхронизации обоих представлений. Обычно, когда таблица записей изменяется, она публикует событие, которое повторяет изменение таблицы чтения.

На рисунке 5-7 показана реализация шаблона СЗРС.

![Сегрегация ответственности командования и запросов](./media/cqrs-implementation.png)

**Рисунок 5-7**. Реализация СЗРС

В предыдущем рисунке реализованы отдельные модели команд и запросов. Каждая операция записи данных сохраняется в хранилище записей, а затем распространяется в магазин чтения. Обратите пристальное внимание на то, как процесс распространения данных работает по принципу [возможной согласованности.](http://www.cloudcomputingpatterns.org/eventual_consistency/) Модель чтения в конечном итоге синхронизируется с моделью записи, но может быть некоторое отставание в процессе. Мы обсуждаем возможную согласованность в следующем разделе.

Это разделение позволяет читать и писать для масштабирования независимо. Операции чтения используют схему, оптимизированную для запросов, в то время как записи используют схему, оптимизированную для обновлений. Прочитанные запросы идут вразрез с денормализации данных, в то время как сложная бизнес-логика может быть применена к модели записи. Кроме того, вы можете наложить более жесткую безопасность на записи операций, чем те, подвергая читает.

Внедрение C'RS может повысить производительность приложений для облачных служб. Тем не менее, это приводит к более сложной конструкции. Тщательно и стратегически примените этот принцип к тем разделам вашего облачного приложения, которые получат от него пользу. Для получения более подробной информации [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns)о C'RS см.

### <a name="event-sourcing"></a>Поиск событий

Другой подход к оптимизации сценариев данных с большим объемом включает в себя [Event Sourcing.](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing)

Система обычно хранит текущее состояние сущности данных. Например, если пользователь меняет свой номер телефона, запись клиента обновляется новым номером. Мы всегда знаем текущее состояние сущности данных, но каждое обновление перезаписывает предыдущее состояние.

В большинстве случаев эта модель работает нормально. Однако в системах большого объема накладные расходы от транзакционной блокировки и частых операций обновления могут повлиять на производительность базы данных, отзывчивость и ограничить масштабируемость.

Event Sourcing использует другой подход к сбору данных. Каждая операция, влияя на данные, сохраняется в хранилище событий. Вместо обновления состояния записи данных мы прилагаем каждое изменение к последовательному списку прошлых событий, аналогичному бухгалтерскому учету. Event Store становится системой записи данных. Он используется для распространения различных материализованных представлений в ограниченном контексте микрослужбы. На рисунке 5.8 показана схема.

![Источник событий](./media/event-sourcing.png)

**Рисунок 5-8**. Источник событий

На предыдущем рисунке обратите внимание на то, как каждая запись (синим цветом) для корзины пользователей прикладывается к базовому магазину событий. В смежном материализованном представлении система проецирует текущее состояние, переигрывая все события, связанные с каждой корзиной. Это представление, или модель чтения, затем подвергается обратно в uI. События также могут быть интегрированы с внешними системами и приложениями или запрошены для определения текущего состояния объекта. При таком подходе вы поддерживаете историю. Вы знаете не только текущее состояние объекта, но и то, как вы достигли этого состояния.

Механически говоря, поиск событий упрощает модель записи. Нет никаких обновлений или удалений. Придание каждой записи данных как неизменяемого события сводит к минимуму разногласия, блокировку и конфликты параллели, связанные с реляционными базами данных. Создание моделей чтения с помощью материализованного шаблона представления позволяет отделить представление от модели записи и выбрать лучший хранилище данных для оптимизации потребностей uI-има использования приложений.

Для этого шаблона рассмотрим хранилище данных, которое непосредственно поддерживает поиск событий. Azure Cosmos DB, MongoDB, Cassandra, CouchDB и RavenDB являются хорошими кандидатами.

Как и во всех шаблонах и технологиях, внедрять стратегически и когда это необходимо. В то время как поиск событий может обеспечить повышенную производительность и масштабируемость, это происходит за счет сложности и кривой обучения.

>[!div class="step-by-step"]
>[Предыдущий](service-mesh-communication-infrastructure.md)
>[Следующий](relational-vs-nosql-data.md)
