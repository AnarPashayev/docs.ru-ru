---
title: Одна база данных для каждой микрослужбы
description: Контрастное хранение данных в монолитных и облачных приложениях.
author: robvet
ms.date: 01/22/2020
ms.openlocfilehash: c0c5611fa866d70f155e4bdad2eee1181b13c065
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79141449"
---
# <a name="database-per-microservice"></a><span data-ttu-id="4af47-103">Одна база данных для каждой микрослужбы</span><span class="sxs-lookup"><span data-stu-id="4af47-103">Database-per-microservice</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="4af47-104">Как мы видели в этой книге, облачный подход изменяет способ проектирования, развертывания и управления приложениями.</span><span class="sxs-lookup"><span data-stu-id="4af47-104">As we've seen throughout this book, a cloud-native approach changes the way you design, deploy, and manage applications.</span></span> <span data-ttu-id="4af47-105">Это также изменяет способ управления и хранения данных.</span><span class="sxs-lookup"><span data-stu-id="4af47-105">It also changes the way you manage and store data.</span></span>

<span data-ttu-id="4af47-106">Рисунок 5-1 контрастирует различия.</span><span class="sxs-lookup"><span data-stu-id="4af47-106">Figure 5-1 contrasts the differences.</span></span>

![Хранение данных в облачных приложениях](./media/distributed-data.png)

<span data-ttu-id="4af47-108">**Рисунок 5-1**.</span><span class="sxs-lookup"><span data-stu-id="4af47-108">**Figure 5-1**.</span></span> <span data-ttu-id="4af47-109">Управление данными в облачных приложениях</span><span class="sxs-lookup"><span data-stu-id="4af47-109">Data management in cloud-native applications</span></span>

<span data-ttu-id="4af47-110">Опытные разработчики легко узнают архитектуру на левой стороне фигуры 5-1.</span><span class="sxs-lookup"><span data-stu-id="4af47-110">Experienced developers will easily recognize the architecture on the left-side of figure 5-1.</span></span> <span data-ttu-id="4af47-111">В этом *монолитном приложении*компоненты бизнес-услуг объединяются в общий уровень служб, обмениваясь данными из единой реляционной базы данных.</span><span class="sxs-lookup"><span data-stu-id="4af47-111">In this *monolithic application*, business service components collocate together in a shared services tier, sharing data from a single relational database.</span></span>

<span data-ttu-id="4af47-112">Во многих отношениях единая база данных обеспечивает простоту управления данными.</span><span class="sxs-lookup"><span data-stu-id="4af47-112">In many ways, a single database keeps data management simple.</span></span> <span data-ttu-id="4af47-113">Запрос данных в нескольких таблицах прост.</span><span class="sxs-lookup"><span data-stu-id="4af47-113">Querying data across multiple tables is straightforward.</span></span> <span data-ttu-id="4af47-114">Изменения в обновлении данных вместе или все они откат.</span><span class="sxs-lookup"><span data-stu-id="4af47-114">Changes to data update together or they all rollback.</span></span> <span data-ttu-id="4af47-115">[Операции ACID](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties) гарантируют сильную и немедленную последовательность.</span><span class="sxs-lookup"><span data-stu-id="4af47-115">[ACID transactions](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties) guarantee strong and immediate consistency.</span></span>

<span data-ttu-id="4af47-116">Разрабатывая для облачных носителей, мы подходим по-другому.</span><span class="sxs-lookup"><span data-stu-id="4af47-116">Designing for cloud-native, we take a different approach.</span></span> <span data-ttu-id="4af47-117">Справа от рисунка 5-1 обратите внимание на то, как бизнес-функциональность сегрегируется на небольшие независимые микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="4af47-117">On the right-side of Figure 5-1, note how business functionality segregates into small, independent microservices.</span></span> <span data-ttu-id="4af47-118">Каждая микрослужба инкапсулирует определенные бизнес-возможности и свои собственные данные.</span><span class="sxs-lookup"><span data-stu-id="4af47-118">Each microservice encapsulates a specific business capability and its own data.</span></span> <span data-ttu-id="4af47-119">Монолитная база данных разлагается на распределенную модель данных с большим количеством меньших баз данных, каждая из которых выравнивается с микрослужбой.</span><span class="sxs-lookup"><span data-stu-id="4af47-119">The monolithic database decomposes into a distributed data model with many smaller databases, each aligning with a microservice.</span></span> <span data-ttu-id="4af47-120">Когда дым очищается, мы выходим с дизайном, который предоставляет *базу данных в микрослужбе.*</span><span class="sxs-lookup"><span data-stu-id="4af47-120">When the smoke clears, we emerge with a design that exposes a *database per microservice*.</span></span>

## <a name="why"></a><span data-ttu-id="4af47-121">Почему?</span><span class="sxs-lookup"><span data-stu-id="4af47-121">Why?</span></span>

<span data-ttu-id="4af47-122">Эта база данных на микроуслугу дает много преимуществ, особенно для систем, которые должны быстро развиваться и поддерживать массовый масштаб.</span><span class="sxs-lookup"><span data-stu-id="4af47-122">This database per microservice provides many benefits, especially for systems that must evolve rapidly and support massive scale.</span></span> <span data-ttu-id="4af47-123">С этой моделью...</span><span class="sxs-lookup"><span data-stu-id="4af47-123">With this model...</span></span>

- <span data-ttu-id="4af47-124">Данные домена инкапсулируются в службе</span><span class="sxs-lookup"><span data-stu-id="4af47-124">Domain data is encapsulated within the service</span></span>
- <span data-ttu-id="4af47-125">Схема данных может развиваться, не влияя непосредственно на другие службы</span><span class="sxs-lookup"><span data-stu-id="4af47-125">Data schema can evolve without directly impacting other services</span></span>
- <span data-ttu-id="4af47-126">Каждый хранилище данных может самостоятельно масштабировать</span><span class="sxs-lookup"><span data-stu-id="4af47-126">Each data store can independently scale</span></span>
- <span data-ttu-id="4af47-127">Сбой хранилища данных в одной службе не повлияет непосредственно на другие службы</span><span class="sxs-lookup"><span data-stu-id="4af47-127">A data store failure in one service won't directly impact other services</span></span>

<span data-ttu-id="4af47-128">Сегрегирование данных также позволяет каждой микрослужбе реализовать тип хранилища данных, который лучше всего оптимизировать для его рабочей нагрузки, потребностей в хранении и шаблонов чтения/записи.</span><span class="sxs-lookup"><span data-stu-id="4af47-128">Segregating data also enables each microservice to implement the data store type that is best optimized for its workload, storage needs, and read/write patterns.</span></span> <span data-ttu-id="4af47-129">Выбор включает реляционные, документальные, ключевые значения и даже хранилища данных на основе графика.</span><span class="sxs-lookup"><span data-stu-id="4af47-129">Choices include relational, document, key-value, and even graph-based data stores.</span></span>

<span data-ttu-id="4af47-130">На рисунке 5-2 представлен принцип сохранения полиглота в облачной системе.</span><span class="sxs-lookup"><span data-stu-id="4af47-130">Figure 5-2 presents the principle of polyglot persistence in a cloud-native system.</span></span>

![Сохранение данных Polyglot](./media/polyglot-data-persistence.png)

<span data-ttu-id="4af47-132">**Рисунок 5-2**.</span><span class="sxs-lookup"><span data-stu-id="4af47-132">**Figure 5-2**.</span></span> <span data-ttu-id="4af47-133">Сохранение данных Polyglot</span><span class="sxs-lookup"><span data-stu-id="4af47-133">Polyglot data persistence</span></span>

<span data-ttu-id="4af47-134">Обратите внимание на предыдущую цифру, как каждая микрослужба поддерживает другой тип хранилища данных.</span><span class="sxs-lookup"><span data-stu-id="4af47-134">Note in the previous figure how each microservice supports a different type of data store.</span></span>

- <span data-ttu-id="4af47-135">Микрослужба каталога продуктов потребляет реляционную базу данных для размещения богатой реляционной структуры базовых данных.</span><span class="sxs-lookup"><span data-stu-id="4af47-135">The product catalog microservice consumes a relational database to accommodate the rich relational structure of its underlying data.</span></span>
- <span data-ttu-id="4af47-136">Микрослужба корзины потребляет распределенный кэш, который поддерживает его простой, ключевой запас данных.</span><span class="sxs-lookup"><span data-stu-id="4af47-136">The shopping cart microservice consumes a distributed cache that supports its simple, key-value data store.</span></span>
- <span data-ttu-id="4af47-137">Заказ микрослужбы потребляет как базу данных документов NoSql для записи операций, а также высоко денормализованный магазин ключей/значений для размещения больших объемов считывающих операций.</span><span class="sxs-lookup"><span data-stu-id="4af47-137">The ordering microservice consumes both a NoSql document database for write operations along with a highly denormalized key/value store to accommodate high-volumes of read operations.</span></span>
  
<span data-ttu-id="4af47-138">В то время как реляционные базы данных остаются актуальными для микрослужб со сложными данными, базы данных НоСЗЛ приобрели значительную популярность.</span><span class="sxs-lookup"><span data-stu-id="4af47-138">While relational databases remain relevant for microservices with complex data, NoSQL databases have gained considerable popularity.</span></span> <span data-ttu-id="4af47-139">Они обеспечивают массовый масштаб и высокую доступность.</span><span class="sxs-lookup"><span data-stu-id="4af47-139">They provide massive scale and high availability.</span></span> <span data-ttu-id="4af47-140">Их бессхемативная природа позволяет разработчикам отойти от архитектуры типов набранных данных и ORM, которые делают изменения дорогостоящими и трудоемкими.</span><span class="sxs-lookup"><span data-stu-id="4af47-140">Their schemaless nature allows developers to move away from an architecture of typed data classes and ORMs that make change expensive and time-consuming.</span></span> <span data-ttu-id="4af47-141">Позже в этой главе мы рассмотрим базы данных NoS'L.</span><span class="sxs-lookup"><span data-stu-id="4af47-141">We cover NoSQL databases later in this chapter.</span></span>

 <span data-ttu-id="4af47-142">Хотя инкапсуляция данных в отдельные микрослужбы может повысить гибкость, производительность и масштабируемость, она также создает множество проблем.</span><span class="sxs-lookup"><span data-stu-id="4af47-142">While encapsulating  data into separate microservices can increase agility, performance, and scalability, it also presents many challenges.</span></span> <span data-ttu-id="4af47-143">В следующем разделе мы обсуждаем эти проблемы вместе с шаблонами и практиками, помогая их преодолеть.</span><span class="sxs-lookup"><span data-stu-id="4af47-143">In the next section, we discuss these challenges along with patterns and practices to help overcome them.</span></span>  

## <a name="cross-service-queries"></a><span data-ttu-id="4af47-144">Запросы кросс-сервисов</span><span class="sxs-lookup"><span data-stu-id="4af47-144">Cross-service queries</span></span>

<span data-ttu-id="4af47-145">Хотя микрослужбы независимы и сосредоточены на конкретных функциональных возможностях, таких как инвентаризация, доставка или заказ, они часто требуют интеграции с другими микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="4af47-145">While microservices are independent and focus on specific functional capabilities, like inventory, shipping, or ordering, they frequently require integration with other microservices.</span></span> <span data-ttu-id="4af47-146">Часто интеграция включает в себя один микрослужбы *запрос другой* для данных.</span><span class="sxs-lookup"><span data-stu-id="4af47-146">Often the integration involves one microservice *querying* another for data.</span></span> <span data-ttu-id="4af47-147">На рисунке 5-3 показан сценарий.</span><span class="sxs-lookup"><span data-stu-id="4af47-147">Figure 5-3 shows the scenario.</span></span>

![Запрос через микрослужбы](./media/cross-service-query.png)

<span data-ttu-id="4af47-149">**Рисунок 5-3**.</span><span class="sxs-lookup"><span data-stu-id="4af47-149">**Figure 5-3**.</span></span> <span data-ttu-id="4af47-150">Запрос через микрослужбы</span><span class="sxs-lookup"><span data-stu-id="4af47-150">Querying across microservices</span></span>

<span data-ttu-id="4af47-151">На предыдущем рисунке мы видим микросервис корзины покупок, который добавляет товар в корзину покупок пользователя.</span><span class="sxs-lookup"><span data-stu-id="4af47-151">In the preceding figure, we see a shopping basket microservice that adds an item to a user's shopping basket.</span></span> <span data-ttu-id="4af47-152">В то время как хранилище данных для этой микрослужбы содержит данные о корзинах и элементах строки, оно не поддерживает данные о продукте или ценах.</span><span class="sxs-lookup"><span data-stu-id="4af47-152">While the data store for this microservice contains basket and line item data, it doesn't maintain product or pricing data.</span></span> <span data-ttu-id="4af47-153">Вместо этого эти элементы данных принадлежат каталогу и микросервисам ценообразования.</span><span class="sxs-lookup"><span data-stu-id="4af47-153">Instead, those data items are owned by the catalog and pricing microservices.</span></span> <span data-ttu-id="4af47-154">Это создает проблему.</span><span class="sxs-lookup"><span data-stu-id="4af47-154">This presents a problem.</span></span> <span data-ttu-id="4af47-155">Как микросервис корзины покупок может добавлять продукт в корзину пользователей, если в его базе данных нет ни продуктов, ни ценовых данных?</span><span class="sxs-lookup"><span data-stu-id="4af47-155">How can the shopping basket microservice add a product to the user's shopping basket when it doesn't have product nor pricing data in its database?</span></span>

<span data-ttu-id="4af47-156">Одним из вариантов, обсуждаемых в главе 4, является [прямой звонок HTTP](service-to-service-communication.md#queries) из корзины покупок в каталог и ценообразование микроуслуг.</span><span class="sxs-lookup"><span data-stu-id="4af47-156">One option discussed in Chapter 4 is a [direct HTTP call](service-to-service-communication.md#queries) from the shopping basket to the catalog and pricing microservices.</span></span> <span data-ttu-id="4af47-157">Тем не менее, в главе 4, мы сказали, синхронные HTTP звонки *пара* микрослужб вместе, уменьшая их автономность и уменьшая их архитектурные преимущества.</span><span class="sxs-lookup"><span data-stu-id="4af47-157">However, in chapter 4, we said synchronous HTTP calls *couple* microservices together, reducing their autonomy and diminishing their architectural benefits.</span></span>

<span data-ttu-id="4af47-158">Мы также можем реализовать шаблон запрос-ответ с отдельными входящими и исходящими очередями для каждой службы.</span><span class="sxs-lookup"><span data-stu-id="4af47-158">We could also implement a request-reply pattern with separate inbound and outbound queues for each service.</span></span> <span data-ttu-id="4af47-159">Тем не менее, эта схема является сложной и требует сантехника для корреляции запроса и ответ сообщений.</span><span class="sxs-lookup"><span data-stu-id="4af47-159">However, this pattern is complicated and requires plumbing to correlate request and response messages.</span></span>
<span data-ttu-id="4af47-160">В то время как он отделяет вызовы бэкэнда микрослужбы, служба вызова должна все еще синхронно ждать вызова для завершения.</span><span class="sxs-lookup"><span data-stu-id="4af47-160">While it does decouple the backend microservice calls, the calling service must still synchronously wait for the call to complete.</span></span> <span data-ttu-id="4af47-161">Перегрузка сети, переходные сбои или перегруженная микрослужба могут привести к длительным и даже неудачным операциям.</span><span class="sxs-lookup"><span data-stu-id="4af47-161">Network congestion, transient faults, or an overloaded microservice and can result in long-running and even failed operations.</span></span>

<span data-ttu-id="4af47-162">Вместо этого общепринятым шаблоном для удаления зависимостей кросс-сервисов является [шаблон Materialized View,](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)показанный на рисунке 5-4.</span><span class="sxs-lookup"><span data-stu-id="4af47-162">Instead, a widely accepted pattern for removing cross-service dependencies is the [Materialized View Pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), shown in Figure 5-4.</span></span>

![Материализованный шаблон представления](./media/materialized-view-pattern.png)

<span data-ttu-id="4af47-164">**Рисунок 5-4**.</span><span class="sxs-lookup"><span data-stu-id="4af47-164">**Figure 5-4**.</span></span> <span data-ttu-id="4af47-165">Материализованный шаблон представления</span><span class="sxs-lookup"><span data-stu-id="4af47-165">Materialized View Pattern</span></span>

<span data-ttu-id="4af47-166">С помощью этого шаблона вы размещаете локальную таблицу данных (известную как *модель чтения)* в службу корзины покупок.</span><span class="sxs-lookup"><span data-stu-id="4af47-166">With this pattern, you place a local data table (known as a *read model*) in the shopping basket service.</span></span> <span data-ttu-id="4af47-167">Эта таблица содержит денормализованную копию данных, необходимых от микросервисов продукта и ценообразования.</span><span class="sxs-lookup"><span data-stu-id="4af47-167">This table contains a denormalized copy of the data needed from the product and pricing microservices.</span></span> <span data-ttu-id="4af47-168">Копирование данных непосредственно в микросервис корзины устраняет необходимость в дорогостоящих перекрестных вызовах.</span><span class="sxs-lookup"><span data-stu-id="4af47-168">Copying the data directly into the shopping basket microservice eliminates the need for expensive cross-service calls.</span></span> <span data-ttu-id="4af47-169">С локальной службой данных вы улучшаете время отклика и надежность службы.</span><span class="sxs-lookup"><span data-stu-id="4af47-169">With the data local to the service, you improve the service's response time and reliability.</span></span> <span data-ttu-id="4af47-170">Кроме того, наличие собственной копии данных делает услугу корзины покупок более устойчивой.</span><span class="sxs-lookup"><span data-stu-id="4af47-170">Additionally, having its own copy of the data makes the shopping basket service more resilient.</span></span> <span data-ttu-id="4af47-171">Если служба каталога станет недоступной, это не повлияет непосредственно на службу корзины покупок.</span><span class="sxs-lookup"><span data-stu-id="4af47-171">If the catalog service should become unavailable, it wouldn't directly impact the shopping basket service.</span></span> <span data-ttu-id="4af47-172">Корзина покупок может продолжать работать с данными из собственного магазина.</span><span class="sxs-lookup"><span data-stu-id="4af47-172">The shopping basket can continue operating with the data from its own store.</span></span>

<span data-ttu-id="4af47-173">Загвоздка в том, что теперь у вас есть дубликаты данных в вашей системе.</span><span class="sxs-lookup"><span data-stu-id="4af47-173">The catch with this approach is that you now have duplicate data in your system.</span></span> <span data-ttu-id="4af47-174">Однако *стратегически* дублирование данных в облачных системах является установившейся практикой и не считается антишаблоном или плохой практикой.</span><span class="sxs-lookup"><span data-stu-id="4af47-174">However, *strategically* duplicating data in cloud-native systems is an established practice and not considered an anti-pattern, or bad practice.</span></span> <span data-ttu-id="4af47-175">Имейте в виду, что *одна и только одна служба* может владеть набором данных и иметь над ним полномочия.</span><span class="sxs-lookup"><span data-stu-id="4af47-175">Keep in mind that *one and only one service* can own a data set and have authority over it.</span></span> <span data-ttu-id="4af47-176">При обновлении системы записи необходимо синхронизировать считываемые модели.</span><span class="sxs-lookup"><span data-stu-id="4af47-176">You'll need to synchronize the read models when the system of record is updated.</span></span> <span data-ttu-id="4af47-177">Синхронизация обычно осуществляется с помощью асинхронных сообщений с [шаблоном публикации/подписки,](service-to-service-communication.md#events)как показано на рисунке 5.4.</span><span class="sxs-lookup"><span data-stu-id="4af47-177">Synchronization is typically implemented via asynchronous messaging with a [publish/subscribe pattern](service-to-service-communication.md#events), as shown in Figure 5.4.</span></span>

## <a name="distributed-transactions"></a><span data-ttu-id="4af47-178">Распределенные транзакции</span><span class="sxs-lookup"><span data-stu-id="4af47-178">Distributed transactions</span></span>

<span data-ttu-id="4af47-179">Хотя запрос данных в микрослужбах затруднен, реализация транзакции в нескольких микрослужбах является еще более сложной задачей.</span><span class="sxs-lookup"><span data-stu-id="4af47-179">While querying data across microservices is difficult, implementing a transaction across several microservices is even more complex.</span></span> <span data-ttu-id="4af47-180">Неможет быть занижена неотъемлемая задача поддержания согласованности данных в независимых источниках данных в различных микрослужбах.</span><span class="sxs-lookup"><span data-stu-id="4af47-180">The inherent challenge of maintaining data consistency across independent data sources in different microservices can't be understated.</span></span> <span data-ttu-id="4af47-181">Отсутствие распределенных транзакций в облачных приложениях означает, что вы должны управлять распределенными транзакциями программно.</span><span class="sxs-lookup"><span data-stu-id="4af47-181">The lack of distributed transactions in cloud-native applications means that you must manage distributed transactions programmatically.</span></span> <span data-ttu-id="4af47-182">Вы переходите из мира *немедленной последовательности* в мир *возможной последовательности.*</span><span class="sxs-lookup"><span data-stu-id="4af47-182">You move from a world of *immediate consistency* to that of *eventual consistency*.</span></span>

<span data-ttu-id="4af47-183">На рисунке 5-5 показана проблема.</span><span class="sxs-lookup"><span data-stu-id="4af47-183">Figure 5-5 shows the problem.</span></span>

![Транзакция в шаблоне саги](./media/saga-transaction-operation.png)

<span data-ttu-id="4af47-185">**Рисунок 5-5**.</span><span class="sxs-lookup"><span data-stu-id="4af47-185">**Figure 5-5**.</span></span> <span data-ttu-id="4af47-186">Реализация транзакции в микрослужбах</span><span class="sxs-lookup"><span data-stu-id="4af47-186">Implementing a transaction across microservices</span></span>

<span data-ttu-id="4af47-187">В предыдущем рисунке пять независимых микрослужб участвуют в распределенной транзакции, которая создает заказ.</span><span class="sxs-lookup"><span data-stu-id="4af47-187">In the preceding figure, five independent microservices participate in a distributed transaction that creates an order.</span></span> <span data-ttu-id="4af47-188">Каждая микрослужба поддерживает свой собственный хранилище данных и реализует локальную транзакцию для своего хранилища.</span><span class="sxs-lookup"><span data-stu-id="4af47-188">Each microservice maintains its own data store and implements a local transaction for its store.</span></span> <span data-ttu-id="4af47-189">Чтобы создать заказ, локальная транзакция для *каждой отдельной* микрослужбы должна быть успешной, или *все* должны прервать и откатить операцию.</span><span class="sxs-lookup"><span data-stu-id="4af47-189">To create the order, the local transaction for *each* individual microservice must succeed, or *all* must abort and roll back the operation.</span></span> <span data-ttu-id="4af47-190">В то время как встроенная транзакционная поддержка доступна внутри каждой из микрослужб, нет поддержки распределенной транзакции, которая охватила бы все пять служб, чтобы сохранить данные в соответствии.</span><span class="sxs-lookup"><span data-stu-id="4af47-190">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction that would span across all five services to keep data consistent.</span></span>

<span data-ttu-id="4af47-191">Вместо этого необходимо построить эту *распределенную транзакцию программно.*</span><span class="sxs-lookup"><span data-stu-id="4af47-191">Instead, you must construct this distributed transaction *programmatically*.</span></span>

<span data-ttu-id="4af47-192">Популярным шаблоном для добавления распределенной транзакционной поддержки является шаблон Saga.</span><span class="sxs-lookup"><span data-stu-id="4af47-192">A popular pattern for adding distributed transactional support is the Saga pattern.</span></span> <span data-ttu-id="4af47-193">Она реализуется путем группирования локальных транзакций вместе программно и последовательно, ссылаясь на каждый из них.</span><span class="sxs-lookup"><span data-stu-id="4af47-193">It's implemented by grouping local transactions together programmatically and sequentially invoking each one.</span></span> <span data-ttu-id="4af47-194">Если какая-либо из локальных транзакций не удается, Saga прерывает операцию и вызывает набор [компенсирующих транзакций.](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)</span><span class="sxs-lookup"><span data-stu-id="4af47-194">If any of the local transactions fail, the Saga aborts the operation and invokes a set of [compensating transactions](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction).</span></span> <span data-ttu-id="4af47-195">Компенсаторные транзакции отменяют изменения, внесенные предыдущими локальными транзакциями, и восстанавливают согласованность данных.</span><span class="sxs-lookup"><span data-stu-id="4af47-195">The compensating transactions undo the changes made by the preceding local transactions and restore data consistency.</span></span> <span data-ttu-id="4af47-196">На рисунке 5-6 показана неудачная транзакция с шаблоном Saga.</span><span class="sxs-lookup"><span data-stu-id="4af47-196">Figure 5-6 shows a failed transaction with the Saga pattern.</span></span>

![Откат в саге шаблон](./media/saga-rollback-operation.png)

<span data-ttu-id="4af47-198">**Рисунок 5-6**.</span><span class="sxs-lookup"><span data-stu-id="4af47-198">**Figure 5-6**.</span></span> <span data-ttu-id="4af47-199">Откат транзакции</span><span class="sxs-lookup"><span data-stu-id="4af47-199">Rolling back a transaction</span></span>

<span data-ttu-id="4af47-200">На предыдущем рисунке операция *обновления инвентаризации* не прошла в микрослужбе инвентаризации.</span><span class="sxs-lookup"><span data-stu-id="4af47-200">In the previous figure, the *Update Inventory* operation has failed in the Inventory microservice.</span></span> <span data-ttu-id="4af47-201">Saga вызывает набор компенсирующих транзакций (красным цветом) для корректировки количества запасов, отмены платежа и заказа и возвращения данных по каждой микрослужбе в согласованное состояние.</span><span class="sxs-lookup"><span data-stu-id="4af47-201">The Saga invokes a set of compensating transactions (in red) to adjust the inventory counts, cancel the payment and the order, and return the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="4af47-202">Шаблоны саги обычно хореографии как ряд связанных событий, или организованы как набор связанных команд.</span><span class="sxs-lookup"><span data-stu-id="4af47-202">Saga patterns are typically choreographed as a series of related events, or orchestrated as a set of related commands.</span></span> <span data-ttu-id="4af47-203">В главе 4 мы обсудили шаблон агрегатора услуг, который будет основой для реализации сагы.</span><span class="sxs-lookup"><span data-stu-id="4af47-203">In Chapter 4, we discussed the service aggregator pattern that would be the foundation for an orchestrated saga implementation.</span></span> <span data-ttu-id="4af47-204">Мы также обсудили события наряду с вопросами Azure Service Bus и Azure Event Grid, которые станут основой для реализации хореографической саги.</span><span class="sxs-lookup"><span data-stu-id="4af47-204">We also discussed eventing along with Azure Service Bus and Azure Event Grid topics that would be a foundation for a choreographed saga implementation.</span></span>

## <a name="high-volume-data"></a><span data-ttu-id="4af47-205">Данные о высоком объеме</span><span class="sxs-lookup"><span data-stu-id="4af47-205">High volume data</span></span>

<span data-ttu-id="4af47-206">Крупные облачные приложения часто поддерживают требования к большим объемам данных.</span><span class="sxs-lookup"><span data-stu-id="4af47-206">Large cloud-native applications often support high-volume data requirements.</span></span> <span data-ttu-id="4af47-207">В этих сценариях традиционные методы хранения данных могут вызвать узкие места.</span><span class="sxs-lookup"><span data-stu-id="4af47-207">In these scenarios, traditional data storage techniques can cause bottlenecks.</span></span> <span data-ttu-id="4af47-208">Для сложных систем, развертываемых в больших масштабах, как Command, так и сегрегация ответственности запросов (C'RS) и Event Sourcing могут повысить производительность приложения.</span><span class="sxs-lookup"><span data-stu-id="4af47-208">For complex systems that deploy on a large scale, both Command and Query Responsibility Segregation (CQRS) and Event Sourcing may improve application performance.</span></span>  

### <a name="cqrs"></a><span data-ttu-id="4af47-209">CQRS</span><span class="sxs-lookup"><span data-stu-id="4af47-209">CQRS</span></span>

<span data-ttu-id="4af47-210">[C'RS](https://docs.microsoft.com/azure/architecture/patterns/cqrs), — это архитектурный шаблон, который может помочь повысить производительность, масштабируемость и безопасность.</span><span class="sxs-lookup"><span data-stu-id="4af47-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs), is an architectural pattern that can help maximize performance, scalability, and security.</span></span> <span data-ttu-id="4af47-211">Шаблон отделяет операции, которые считываются данные, от тех операций, которые пишут данные.</span><span class="sxs-lookup"><span data-stu-id="4af47-211">The pattern separates operations that read data from those operations that write data.</span></span>

<span data-ttu-id="4af47-212">Для обычных сценариев одна и та же модель сущности и объект репозитория данных используются *как* для операций чтения, так и для записи.</span><span class="sxs-lookup"><span data-stu-id="4af47-212">For normal scenarios, the same entity model and data repository object are used for *both* read and write operations.</span></span>

<span data-ttu-id="4af47-213">Однако сценарий данных с большим объемом может быть выгодна для отдельных моделей и таблиц данных для чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="4af47-213">However, a high volume data scenario can benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="4af47-214">Чтобы повысить производительность, считывательная операция может задать запрос против сильно денормализованного представления данных, чтобы избежать дорогостоящих повторяющихся соединений таблиц и блокировок таблиц.</span><span class="sxs-lookup"><span data-stu-id="4af47-214">To improve performance, the read operation could query against a highly denormalized representation of the data to avoid expensive repetitive table joins and table locks.</span></span> <span data-ttu-id="4af47-215">Операция *записи,* известная как *команда,* будет обновляться на фоне полностью нормализованного представления данных, которые гарантировали бы согласованность.</span><span class="sxs-lookup"><span data-stu-id="4af47-215">The *write* operation, known as a *command*, would update against a fully normalized representation of the data that would guarantee consistency.</span></span> <span data-ttu-id="4af47-216">Затем необходимо реализовать механизм синхронизации обоих представлений. Обычно, когда таблица записей изменяется, она публикует событие, которое повторяет изменение таблицы чтения.</span><span class="sxs-lookup"><span data-stu-id="4af47-216">You then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it publishes an event that replicates the modification to the read table.</span></span>

<span data-ttu-id="4af47-217">На рисунке 5-7 показана реализация шаблона СЗРС.</span><span class="sxs-lookup"><span data-stu-id="4af47-217">Figure 5-7 shows an implementation of the CQRS pattern.</span></span>

![Сегрегация ответственности командования и запросов](./media/cqrs-implementation.png)

<span data-ttu-id="4af47-219">**Рисунок 5-7**.</span><span class="sxs-lookup"><span data-stu-id="4af47-219">**Figure 5-7**.</span></span> <span data-ttu-id="4af47-220">Реализация СЗРС</span><span class="sxs-lookup"><span data-stu-id="4af47-220">CQRS implementation</span></span>

<span data-ttu-id="4af47-221">В предыдущем рисунке реализованы отдельные модели команд и запросов.</span><span class="sxs-lookup"><span data-stu-id="4af47-221">In the previous figure, separate command and query models are implemented.</span></span> <span data-ttu-id="4af47-222">Каждая операция записи данных сохраняется в хранилище записей, а затем распространяется в магазин чтения.</span><span class="sxs-lookup"><span data-stu-id="4af47-222">Each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="4af47-223">Обратите пристальное внимание на то, как процесс распространения данных работает по принципу [возможной согласованности.](http://www.cloudcomputingpatterns.org/eventual_consistency/)</span><span class="sxs-lookup"><span data-stu-id="4af47-223">Pay close attention to how the data propagation process operates on the principle of [eventual consistency](http://www.cloudcomputingpatterns.org/eventual_consistency/).</span></span> <span data-ttu-id="4af47-224">Модель чтения в конечном итоге синхронизируется с моделью записи, но может быть некоторое отставание в процессе.</span><span class="sxs-lookup"><span data-stu-id="4af47-224">The read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span> <span data-ttu-id="4af47-225">Мы обсуждаем возможную согласованность в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="4af47-225">We discuss eventual consistency in the next section.</span></span>

<span data-ttu-id="4af47-226">Это разделение позволяет читать и писать для масштабирования независимо.</span><span class="sxs-lookup"><span data-stu-id="4af47-226">This separation enables reads and writes to scale independently.</span></span> <span data-ttu-id="4af47-227">Операции чтения используют схему, оптимизированную для запросов, в то время как записи используют схему, оптимизированную для обновлений.</span><span class="sxs-lookup"><span data-stu-id="4af47-227">Read operations use a schema optimized for queries, while the writes use a schema optimized for updates.</span></span> <span data-ttu-id="4af47-228">Прочитанные запросы идут вразрез с денормализации данных, в то время как сложная бизнес-логика может быть применена к модели записи.</span><span class="sxs-lookup"><span data-stu-id="4af47-228">Read queries go against denormalized data, while complex business logic can be applied to the write model.</span></span> <span data-ttu-id="4af47-229">Кроме того, вы можете наложить более жесткую безопасность на записи операций, чем те, подвергая читает.</span><span class="sxs-lookup"><span data-stu-id="4af47-229">As well, you might impose tighter security on write operations than those exposing reads.</span></span>

<span data-ttu-id="4af47-230">Внедрение C'RS может повысить производительность приложений для облачных служб.</span><span class="sxs-lookup"><span data-stu-id="4af47-230">Implementing CQRS can improve application performance for cloud-native services.</span></span> <span data-ttu-id="4af47-231">Тем не менее, это приводит к более сложной конструкции.</span><span class="sxs-lookup"><span data-stu-id="4af47-231">However, it does result in a more complex design.</span></span> <span data-ttu-id="4af47-232">Тщательно и стратегически примените этот принцип к тем разделам вашего облачного приложения, которые получат от него пользу.</span><span class="sxs-lookup"><span data-stu-id="4af47-232">Apply this principle carefully and strategically to those sections of your cloud-native application that will benefit from it.</span></span> <span data-ttu-id="4af47-233">Для получения более подробной информации [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns)о C'RS см.</span><span class="sxs-lookup"><span data-stu-id="4af47-233">For more on CQRS, see the Microsoft book [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns).</span></span>

### <a name="event-sourcing"></a><span data-ttu-id="4af47-234">Поиск событий</span><span class="sxs-lookup"><span data-stu-id="4af47-234">Event sourcing</span></span>

<span data-ttu-id="4af47-235">Другой подход к оптимизации сценариев данных с большим объемом включает в себя [Event Sourcing.](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing)</span><span class="sxs-lookup"><span data-stu-id="4af47-235">Another approach to optimizing high volume data scenarios involves [Event Sourcing](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing).</span></span>

<span data-ttu-id="4af47-236">Система обычно хранит текущее состояние сущности данных.</span><span class="sxs-lookup"><span data-stu-id="4af47-236">A system typically stores the current state of a data entity.</span></span> <span data-ttu-id="4af47-237">Например, если пользователь меняет свой номер телефона, запись клиента обновляется новым номером.</span><span class="sxs-lookup"><span data-stu-id="4af47-237">If a user changes their phone number, for example, the customer record is updated with the new number.</span></span> <span data-ttu-id="4af47-238">Мы всегда знаем текущее состояние сущности данных, но каждое обновление перезаписывает предыдущее состояние.</span><span class="sxs-lookup"><span data-stu-id="4af47-238">We always know the current state of a data entity, but each update overwrites the previous state.</span></span>

<span data-ttu-id="4af47-239">В большинстве случаев эта модель работает нормально.</span><span class="sxs-lookup"><span data-stu-id="4af47-239">In most cases, this model works fine.</span></span> <span data-ttu-id="4af47-240">Однако в системах большого объема накладные расходы от транзакционной блокировки и частых операций обновления могут повлиять на производительность базы данных, отзывчивость и ограничить масштабируемость.</span><span class="sxs-lookup"><span data-stu-id="4af47-240">In high volume systems, however, overhead from transactional locking and frequent update operations can impact database performance, responsiveness, and limit scalability.</span></span>

<span data-ttu-id="4af47-241">Event Sourcing использует другой подход к сбору данных.</span><span class="sxs-lookup"><span data-stu-id="4af47-241">Event Sourcing takes a different approach to capturing data.</span></span> <span data-ttu-id="4af47-242">Каждая операция, влияя на данные, сохраняется в хранилище событий.</span><span class="sxs-lookup"><span data-stu-id="4af47-242">Each operation that affects data is persisted to an event store.</span></span> <span data-ttu-id="4af47-243">Вместо обновления состояния записи данных мы прилагаем каждое изменение к последовательному списку прошлых событий, аналогичному бухгалтерскому учету.</span><span class="sxs-lookup"><span data-stu-id="4af47-243">Instead of updating the state of a data record, we append each change to a sequential list of past events - similar to an accountant's ledger.</span></span> <span data-ttu-id="4af47-244">Event Store становится системой записи данных.</span><span class="sxs-lookup"><span data-stu-id="4af47-244">The Event Store becomes the system of record for the data.</span></span> <span data-ttu-id="4af47-245">Он используется для распространения различных материализованных представлений в ограниченном контексте микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="4af47-245">It's used to propagate various materialized views within the bounded context of a microservice.</span></span> <span data-ttu-id="4af47-246">На рисунке 5.8 показана схема.</span><span class="sxs-lookup"><span data-stu-id="4af47-246">Figure 5.8 shows the pattern.</span></span>

![Источник событий](./media/event-sourcing.png)

<span data-ttu-id="4af47-248">**Рисунок 5-8**.</span><span class="sxs-lookup"><span data-stu-id="4af47-248">**Figure 5-8**.</span></span> <span data-ttu-id="4af47-249">Источник событий</span><span class="sxs-lookup"><span data-stu-id="4af47-249">Event Sourcing</span></span>

<span data-ttu-id="4af47-250">На предыдущем рисунке обратите внимание на то, как каждая запись (синим цветом) для корзины пользователей прикладывается к базовому магазину событий.</span><span class="sxs-lookup"><span data-stu-id="4af47-250">In the previous figure, note how each entry (in blue) for a user's shopping cart is appended to an underlying event store.</span></span> <span data-ttu-id="4af47-251">В смежном материализованном представлении система проецирует текущее состояние, переигрывая все события, связанные с каждой корзиной.</span><span class="sxs-lookup"><span data-stu-id="4af47-251">In the adjoining materialized view, the system projects the current state by replaying all the events associated with each shopping cart.</span></span> <span data-ttu-id="4af47-252">Это представление, или модель чтения, затем подвергается обратно в uI.</span><span class="sxs-lookup"><span data-stu-id="4af47-252">This view, or read model, is then exposed back to the UI.</span></span> <span data-ttu-id="4af47-253">События также могут быть интегрированы с внешними системами и приложениями или запрошены для определения текущего состояния объекта.</span><span class="sxs-lookup"><span data-stu-id="4af47-253">Events can also be integrated with external systems and applications or queried to determine the current state of an entity.</span></span> <span data-ttu-id="4af47-254">При таком подходе вы поддерживаете историю.</span><span class="sxs-lookup"><span data-stu-id="4af47-254">With this approach, you maintain history.</span></span> <span data-ttu-id="4af47-255">Вы знаете не только текущее состояние объекта, но и то, как вы достигли этого состояния.</span><span class="sxs-lookup"><span data-stu-id="4af47-255">You know not only the current state of an entity, but also how you reached this state.</span></span>

<span data-ttu-id="4af47-256">Механически говоря, поиск событий упрощает модель записи.</span><span class="sxs-lookup"><span data-stu-id="4af47-256">Mechanically speaking, event sourcing simplifies the write model.</span></span> <span data-ttu-id="4af47-257">Нет никаких обновлений или удалений.</span><span class="sxs-lookup"><span data-stu-id="4af47-257">There are no updates or deletes.</span></span> <span data-ttu-id="4af47-258">Придание каждой записи данных как неизменяемого события сводит к минимуму разногласия, блокировку и конфликты параллели, связанные с реляционными базами данных.</span><span class="sxs-lookup"><span data-stu-id="4af47-258">Appending each data entry as an immutable event minimizes contention, locking, and concurrency conflicts associated with relational databases.</span></span> <span data-ttu-id="4af47-259">Создание моделей чтения с помощью материализованного шаблона представления позволяет отделить представление от модели записи и выбрать лучший хранилище данных для оптимизации потребностей uI-има использования приложений.</span><span class="sxs-lookup"><span data-stu-id="4af47-259">Building read models with the materialized view pattern enables you to decouple the view from the write model and choose the best data store to optimize the needs of your application UI.</span></span>

<span data-ttu-id="4af47-260">Для этого шаблона рассмотрим хранилище данных, которое непосредственно поддерживает поиск событий.</span><span class="sxs-lookup"><span data-stu-id="4af47-260">For this pattern, consider a data store that directly supports event sourcing.</span></span> <span data-ttu-id="4af47-261">Azure Cosmos DB, MongoDB, Cassandra, CouchDB и RavenDB являются хорошими кандидатами.</span><span class="sxs-lookup"><span data-stu-id="4af47-261">Azure Cosmos DB, MongoDB, Cassandra, CouchDB, and RavenDB are good candidates.</span></span>

<span data-ttu-id="4af47-262">Как и во всех шаблонах и технологиях, внедрять стратегически и когда это необходимо.</span><span class="sxs-lookup"><span data-stu-id="4af47-262">As with all patterns and technologies, implement strategically and when needed.</span></span> <span data-ttu-id="4af47-263">В то время как поиск событий может обеспечить повышенную производительность и масштабируемость, это происходит за счет сложности и кривой обучения.</span><span class="sxs-lookup"><span data-stu-id="4af47-263">While event sourcing can provide increased performance and scalability, it comes at the expense of complexity and a learning curve.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="4af47-264">[Предыдущий](service-mesh-communication-infrastructure.md)
>[Следующий](relational-vs-nosql-data.md)</span><span class="sxs-lookup"><span data-stu-id="4af47-264">[Previous](service-mesh-communication-infrastructure.md)
[Next](relational-vs-nosql-data.md)</span></span>
