---
title: Общие сведения о приложениях, ориентированных на облако
description: Дополнительные сведения о вычислениях в облаке
author: robvet
ms.date: 01/19/2021
ms.openlocfilehash: 852eed27d4cfcaefdfa89a73c54414a6306ed28d
ms.sourcegitcommit: f2ab02d9a780819ca2e5310bbcf5cfe5b7993041
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/03/2021
ms.locfileid: "99506101"
---
# <a name="introduction-to-cloud-native-applications"></a>Общие сведения о приложениях, ориентированных на облако

Еще один день в офисе, работающий над «следующим большим предметом».

Кольца целлфоне. Это ваш удобный набор сотрудников, который дважды вызывает вас в день о новых заданиях.

Но на этот раз это отличается: запуск, капитал и масса финансирования.

Упоминание облачной и пограничной технологии помещает вас за границы.

Перемотка вперед на несколько недель, и теперь вы являетесь новым сотрудником в сеансе проектирования, архитектором основного приложения электронной коммерции. Вы будете конкурировать с ведущими сайтами электронной коммерции.

Как вы будете строить его?

Если следовать инструкциям за последние 15 лет, скорее всего, будет построена система, показанная на рис. 1,1.

![Традиционный монолитный дизайн](./media/monolithic-design.png)

**Рис. 1-1**. Традиционный монолитный дизайн

Вы конструируете большое основное приложение, содержащее всю логику предметной области. Она включает такие модули, как удостоверение, каталог, упорядочение и многое другое. Основное приложение взаимодействует с большой реляционной базой данных. Ядро предоставляет функциональные возможности через интерфейс HTML.

Поздравляем!  Вы только что создали монолитное приложение.

Не все — плохое. Монолитные части предлагают некоторые различные преимущества. Например, они просты в...

- build;
- Тестировать
- развернуть
- Устранение неполадок
- scale

Многие успешно созданные сегодня приложения были созданы как монолитные. Приложение находится в попадании и продолжит развиваться, итерацию после итерации, добавив дополнительные функции.

Однако в некоторый момент вы можете приступить к неудобному. Вы обнаружите, что вы теряете контроль над приложением. По мере того, как пройдет время, чувство становится более интенсивным, и в конечном итоге вы вводите состояние, называемое `Fear Cycle` .

- Приложение стало настолько запутанным, что никто не понимает его.
- Вы не вносите изменения — каждое изменение имеет непреднамеренное и дорогостоящие побочные эффекты.
- Новые функции и исправления становятся сложными, трудоемкими и затратными для реализации.
- Каждый выпуск как можно меньше и требует полного развертывания всего приложения.
- Один нестабильный компонент может вызвать сбой всей системы.
- Новые технологии и платформы не являются вариантами.
- Сложно реализовать методологии гибкой доставки.
- Архитектура еросион в качестве базы кода приводит к невозможности «незавершенных» особых случаев.
- Консультанты сообщат вам о необходимости перезаписи.

Многие организации решают монолитный цикл, используя собственный облачный подход к созданию систем. На рис. 1-2 показана та же система, которая применяет собственные приемы и методики облака.

![Разработка Cloud-Native](./media/cloud-native-design.png)

**Рис. 1-2**. Разработка в собственном облаке

Обратите внимание, что приложение разбивается по набору небольших изолированных микрослужб. Каждая служба самодостаточна и инкапсулирует свой собственный код, данные и зависимости. Каждый из них развертывается в контейнере программного обеспечения и управляется контейнером Orchestrator. Вместо большой реляционной базы данных каждая служба владеет хранилищем данных, тип которого зависит от потребностей, связанных с данными. Обратите внимание, что некоторые службы зависят от реляционной базы данных, а другие — в базах данных NoSQL. Одна служба хранит свое состояние в распределенном кэше. Обратите внимание, как весь трафик проходит через службу шлюза API, которая отвечает за направление трафика к основным серверным службам и применение множества перекрестных проблем. Что важнее всего, приложение использует все преимущества функций масштабируемости, доступности и устойчивости, имеющихся в современных облачных платформах.

### <a name="cloud-native-computing"></a>Облачные вычисления

Странно... Мы только что использовали этот термин — _облако Native_. Первое, что можно сделать, — «что именно это значит?» Еще одна отрасль, термин конкоктед поставщиками программного обеспечения, на рынке дополнительных материалов?»

К счастью, это далеко не так, и надеюсь, что эта книга поможет убедить вас.

В течение короткого времени облачный машинный код становится движущие тенденцией в отрасли программного обеспечения. Это новый способ подумать о создании крупных и сложных систем, который использует все преимущества современных методик разработки программного обеспечения, технологий и облачной инфраструктуры. Подход изменяет способ проектирования, реализации, развертывания и эксплуатацию систем.

В отличие от непрерывных устанавливать ориентиры, которые применяют нашу отрасль, облачный машинный код — _реальная_. Рассмотрим [облачный машинный фундамент](https://www.cncf.io/) (кнкф), который является консорциумом более 300 крупных предприятий с Уставом, чтобы обеспечить повсеместную облачную вычислительную производительность по технологиям и облачным стекам. Как одна из самых влиятельные групп с открытым исходным кодом, она содержит множество самых быстро растущего проекта с открытым исходным кодом в GitHub. К ним относятся такие проекты, как [Kubernetes](https://kubernetes.io/), [Prometheus](https://prometheus.io/), [Helm](https://helm.sh/), [делегат](https://www.envoyproxy.io/)и [gRPC](https://grpc.io/).

КНКФ способствует экосистеме с открытым исходным кодом и нейтральностью поставщика. В этой книге рассматриваются принципы, шаблоны и практические рекомендации, которые не зависят от технологий. В то же время мы обсудим службы и инфраструктуру, доступные в Microsoft Azure облаке для создания собственных облачных систем.

Итак, что именно является облачным машинным кодом? Перейдем, не стоит, и позвольте нам помочь вам исследовать новый мир.

>[!div class="step-by-step"]
>[Назад](index.md)
>[Вперед](definition.md)
