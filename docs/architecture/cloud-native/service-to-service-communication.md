---
title: Связь между службами
description: Узнайте, как облачные микрослужбы, нативные на конец, взаимодействуют с другими микрослужбами бэк-энда.
author: robvet
ms.date: 09/09/2019
ms.openlocfilehash: 926be3c2eb4513c89ebcd1f31dceb7d58639dc6f
ms.sourcegitcommit: 79b0dd8bfc63f33a02137121dd23475887ecefda
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/01/2020
ms.locfileid: "80523560"
---
# <a name="service-to-service-communication"></a>Связь между службами

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

Переходя от фронт-энд-клиента, мы теперь обращаемся к бэк-энд микрослужб ы общаться друг с другом.

При построении облачного приложения необходимо учитывать, как службы бэк-энда взаимодействуют друг с другом. В идеале, чем меньше межсервисная связь, тем лучше. Однако избежать не всегда возможно, так как службы бэк-энда часто полагаются друг на друга для завершения операции.

Существует несколько широко признанных подходов к внедрению межсервисной связи. *Тип взаимодействия связи* часто определяет наилучший подход.

Рассмотрим следующие типы взаимодействия:

- *Запрос* - когда вызов микрослужбы требует ответа от так называемой микрослужбы, такие как: "Эй, дайте мне информацию о покупателе для данного клиента Id".

- *Командование* - когда вызывающая микрослужба нуждается в другой микрослужбе для выполнения действия, но не требует ответа, например: "Эй, просто отправь этот заказ".

- *Событие* - когда микрослужба, называемая издателем, поднимает событие, в которое изменилось состояние или произошло действие. Другие микросервисы, называемые абонентами, которые заинтересованы, могут соответствующим образом отреагировать на это событие. Издатель и подписчики не знают друг о друге.

Системы микрослужб обычно используют комбинацию этих типов взаимодействия при выполнения операций, требующих взаимодействия между ней. Давайте внимательно рассмотрим каждый из них и как вы могли бы реализовать их.

## <a name="queries"></a>Запросы

Во многих случаях одной микрослужбе может потребоваться *запрос* другой, что требует немедленного ответа для завершения операции. Микросервису корзины для покупок может потребоваться информация о продукте и цена для добавления товара в корзину. Существует ряд подходов к реализации операций запросов.

### <a name="requestresponse-messaging"></a>Сообщения о запросе/ответе

Один из вариантов реализации этого сценария заключается в том, чтобы микрослужба вызова бэк-энда делала прямые запросы HTTP в микрослужбы, необходимые для запроса, показанные на рисунке 4-8.

![Прямая связь HTTP](./media/direct-http-communication.png)

**Рисунок 4-8**. Прямая связь HTTP

Хотя прямые вызовы HTTP между микрослужбами относительно просты в реализации, следует позаботиться о том, чтобы свести к минимуму эту практику. Для начала эти вызовы всегда *синхронны* и будут блокировать операцию до тех пор, пока результат не будет возвращен или время запроса не выйдет. То, что когда-то было автономным, независимыми службами, способными развиваться независимо и часто развертываться, теперь становится связано друг с другом. По мере увеличения связей между микрослужбами их архитектурные преимущества уменьшаются.

Выполнение нечастых запросов, в результате которого делается один прямой вызов HTTP в другую микрослужбу, может быть приемлемым для некоторых систем. Однако нерекомендуете количество звонков, которые вызывают прямые http-звонки в несколько микрослужб. Они могут увеличить задержку и негативно повлиять на производительность, масштабируемость и доступность вашей системы. Еще хуже то, что длинная серия прямой http-коммуникации может привести к глубоким и сложным цепочкам синхронных вызовов микросервисов, показанных на рисунке 4-9:

![Цепочка http-запросов](./media/chaining-http-queries.png)

**Рисунок 4-9**. Цепочка http-запросов

Вы, конечно, можете себе представить риск в дизайне показано на предыдущем изображении. Что произойдет, если шаг \#3 выйдет из строя? Или \#Шаг 8 терпит неудачу? Как вы восстанавливаетесь? Что делать, если шаг \#6 медленный, потому что основная служба занята? Как вы продолжаете? Даже если все работает правильно, подумайте о задержке, которую понесет этот вызов, которая является суммой задержки каждого шага.

Большая степень соединения на предыдущем изображении позволяет предположить, что службы не были оптимально смоделированы. Было бы обязывать команду вернуться к их дизайну.

### <a name="materialized-view-pattern"></a>Шаблон материализованного представления

Популярным вариантом удаления связи микрослужб является [шаблон Materialized View.](https://docs.microsoft.com/azure/architecture/patterns/materialized-view) С помощью этого шаблона микрослужба хранит свою собственную локальную денормализованную копию данных, принадлежащих другим службам. Вместо того, чтобы микрослужба Shopping Basket, задающая запрос на каталог продуктов и микросервисы ценообразования, она сохраняет свою собственную локальную копию этих данных. Этот шаблон устраняет ненужное соединение и повышает надежность и время отклика. Вся операция выполняется внутри одного процесса. Мы исследуем эту модель и другие проблемы данных в главе 5.

### <a name="service-aggregator-pattern"></a>Шаблон агрегатора услуг

Еще одним вариантом устранения связи между микросервисами и микросервисами является [микросервис Агрегатора,](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/)показанный фиолетовым цветом на рисунке 4-10.

![Услуги агрегатора](./media/aggregator-service.png)

**Рисунок 4-10**. Микросервис агрегатора

Шаблон изолирует операцию, которая делает вызовы к нескольким бэк-энд микрослужб, централизация его логики в специализированной микрослужбы.  Фиолетовый агрегатор кассатов на предыдущей цифре оркеструет рабочий процесс для операции Checkout. Она включает в себя вызовы в несколько бэк-энд микрослужб в последовательном порядке. Данные из рабочего процесса агрегируются и возвращаются вызывающему. Несмотря на то, что она по-прежнему реализует прямые http-звонки, микрослужба агрегатора снижает прямую зависимость между бэк-эндом микрослужб.

### <a name="requestreply-pattern"></a>Шаблон запроса/ответа

Другим подходом к разъединению синхронных сообщений HTTP является [шаблон запроса и ответа,](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html)который использует общение очередей. Связь с помощью очереди всегда является односторонним каналом, при этом производитель отправляет сообщение, а потребитель получает его. С помощью этого шаблона выполняется как очередь запросов, так и очередь ответа, показанная на рисунке 4-11.

![Шаблон запроса-ответа](./media/request-reply-pattern.png)

**Рисунок 4-11**. Шаблон запроса-ответа

В данном месте производитель сообщений создает сообщение на основе запроса, содержащее уникальный идентификатор корреляции, и помещает его в очередь запроса. Потребляющая служба разлагает сообщения, обрабатывает их и помещает ответ в очередь ответа с тем же идентификатором корреляции. Служба производителя разлагает сообщение, сопоставляет его с идентификатором корреляции и продолжает обработку. В следующем разделе мы подробно покрываем очереди.

## <a name="commands"></a>Команды

Другим типом взаимодействия связи является *команда.* Для выполнения действия микрослужбе может потребоваться другая микрослужба. Микрослужба заказа может понадобиться для создания отгрузки для заказа. На рисунке 4-12 одна микрослужба, называемая "Производитель", отправляет сообщение другому микросервису, потребителю, повелевая ему что-то делать.

![Взаимодействие командования с очередью](./media/command-interaction-with-queue.png)

**Рис. 4-12**. Взаимодействие командования с очередью

Чаще всего, Производитель не требует ответа и может *стрелять и забыть* сообщение. Если ответ необходим, потребитель отправляет отдельное сообщение продюсеру на другом канале. Командное сообщение лучше всего отправлять асинхронно с очередью сообщений. поддерживается легким брокером сообщений. На предыдущей диаграмме обратите внимание, как очередь отделяет и отделяет обе службы.

Очередь сообщений — это посредник, через который производитель и потребитель передают сообщение. Очереди реализуют асинхронный шаблон обмена сообщениями по точкам. Производитель знает, куда должна быть отправлена команда и маршруты надлежащим образом. Очередь гарантирует, что сообщение обрабатывается именно одним из экземпляров потребителя, которые читают из канала. В этом сценарии, либо производитель или потребитель службы может масштабироваться, не затрагивая других. Кроме того, технологии могут быть разрозненными с каждой стороны, а это означает, что у нас может быть микрослужба Java, вызывающая микрослужбу [Голанг.](https://golang.org)

В главе 1 мы говорили о *поддержке услуг*. Службы поддержки — вспомогательные ресурсы, от которых зависят облачные системы. Очереди сообщений являются службами поддержки. Облако Azure поддерживает два типа очередей сообщений, которые могут использовать облачные системы для реализации командных сообщений: очереди хранения данных Azure и очереди служб ы Azure.

### <a name="azure-storage-queues"></a>Очереди службы хранилища Azure

Очереди хранения Azure предлагают простую инфраструктуру очередей, которая является быстрой, доступной и поддерживаемой учетными записями хранения Azure.

[Очереди хранения данных Azure оснащены](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction) механизмом очередей на основе REST с надежными и постоянными сообщениями. Они обеспечивают минимальный набор функций, но стоят недорого и хранят миллионы сообщений. Их мощность составляет до 500 ТБ. Одно сообщение может быть размером до 64 кБ.

Вы можете получить доступ к сообщениям из любой точки мира с помощью аутентифицированных звонков с помощью HTTP или HTTPS. Очереди хранения могут масштабироваться до большого количества одновременных клиентов для обработки спайков трафика.

Тем не менее, есть ограничения с услугой:

- Заказ сообщений не гарантируется.

- Сообщение может сохраняться только в течение семи дней, прежде чем оно будет автоматически удалено.

- Поддержка государственного управления, дублирования обнаружения или транзакций недоступна.

На рисунке 4-13 показана иерархия очереди хранения Azure.

![Иерархия очередей хранения](./media/storage-queue-hierarchy.png)

**Рис. 4-13**. Иерархия очередей хранения

На предыдущем рисунке обратите внимание на то, как очереди хранения хранят свои сообщения в основной учетной записи хранения Azure.

Для разработчиков корпорация Майкрософт предоставляет несколько библиотек для обработки очередей хранения данных. Большинство основных платформ поддерживаются, включая .NET, Java, JavaScript, Ruby, Python и Go. Разработчики никогда не должны напрямую общаться с этими библиотеками. Это позволит тесно соединить ваш код микрослужбы с службой Azure Storage Queue. Лучше изолировать детали реализации API. Введите слой посредничества, или промежуточный API, который предоставляет общие операции и инкапсулирует конкретную библиотеку. Эта свободная связь позволяет вам поменять одну службу очередей на другую без внесения изменений в код службы магистральных линий.

Очереди хранилища Azure — это экономичный вариант для реализации командных сообщений в облачных приложениях. Особенно, когда размер очереди превысит 80 ГБ, или простой набор функций является приемлемым. Вы платите только за хранение сообщений; нет фиксированных почасовых платежей.

### <a name="azure-service-bus-queues"></a>Очереди служебной шины Azure

Для более сложных требований к обмену сообщениями рассмотрим очереди автобусов Azure.

Расположенный на вершине надежной инфраструктуры сообщений, [Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) поддерживает *модель обмена сообщениями по средних раз.* Сообщения надежно хранятся в брокере (очередь) до получения потребителем. Очередь гарантирует доставку сообщений First-In/First-Out (FIFO), уважая порядок добавления сообщений в очередь.

Размер сообщения может быть гораздо больше, до 256 кБ. Сообщения сохраняются в очереди в течение неограниченного периода времени. Service Bus поддерживает не только вызовы на основе HTTP, но и обеспечивает полную поддержку [протокола АМПЗ.](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview) АМПЗ является открытым стандартом для всех поставщиков, который поддерживает двоичный протокол и более высокую степень надежности.

Service Bus предоставляет богатый набор функций, включая [поддержку транзакций](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions) и [функцию обнаружения дубликата.](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection) Очередь гарантирует "не чаще одного раза доставки" за сообщение. Он автоматически отбрасывает уже отправленное сообщение. Если производитель сомневается, он может отправить одно и то же сообщение, и Сервисный автобус гарантирует, что будет обработана только одна копия. Дублирование обнаружения освобождает вас от необходимости строить дополнительную инфраструктуру сантехники.

Еще две функции предприятия - раздел и сеансы. Обычная очередь Service Bus обрабатывается одним брокером сообщений и хранится в одном хранилище сообщений. Но, [Раздел saбиста обслуживания](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) распространяет очередь через множественные маклеры сообщений и магазины сообщений. Общая пропускная способность больше не ограничивается производительностью одного брокера сообщений или магазина обмена сообщениями. Временное отключение хранилища сообщений не делает недоступной разделенную очередь.

[Служба автобусных сессий](https://codingcanvas.com/azure-service-bus-sessions/) обеспечивают способ групповых сообщений. Представьте себе сценарий рабочего процесса, в котором сообщения должны обрабатываться вместе, а операция завершена в конце. Чтобы воспользоваться преимуществами, сеансы должны быть явно включены для очереди, и каждое связанное сообщение должно содержать тот же идентификатор сеанса.

Тем не менее, есть некоторые важные предостережения: размер очередей Service Bus ограничен 80 ГБ, что намного меньше, чем то, что доступно в очередях магазинов. Кроме того, очереди Сервисного автобуса несут базовую стоимость и плату за операцию.

На рисунке 4-14 описывается архитектура высокого уровня очереди сервисных автобусов.

![Очередь служебной шины](./media/service-bus-queue.png)

**Рис. 4-14**. Очередь служебной шины

В предыдущем рисунке обратите внимание на отношение по точкам. Два экземпляра одного и того же поставщика заглатывают сообщения в единую очередь Service Bus. Каждое сообщение потребляется только одним из трех экземпляров потребителя справа. Далее мы обсудим, как реализовать сообщения, где разные потребители могут быть заинтересованы в одном и том же сообщении.

## <a name="events"></a>События

Очереди сообщений — это эффективный способ реализации коммуникации, в которой производитель может асинхронно отправлять сообщение потребителю. Однако, что происходит, когда *многие различные потребители* заинтересованы в одном и том же сообщении? Выделенная очередь сообщений для каждого потребителя не будет масштабироваться хорошо и станет трудно управлять.

Для решения этого сценария мы переходим к третьему типу взаимодействия сообщений, *событию*. Одна микрослужба сообщает о том, что было совершено действие. Другие микрослужбы, если они заинтересованы, реагируют на действие или событие.

Eventing — это двухэтапный процесс. Для данного изменения состояния микрослужба публикует событие брокеру сообщений, делая его доступным для любой другой заинтересованной микрослужбы. Заинтересованная микроуслуга уведомляется, подписавшись на событие в сообщении брокера. Шаблон [Publish/Subscribe](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber) используется для реализации [коммуникации на основе событий.](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications)

На рисунке 4-15 показана микрослужба по покупке, публикуевав случай с двумя другими микрослужбами, подписавшимися на него.

![Обмен сообщениями с инициативой события](./media/event-driven-messaging.png)

**Рис. 4-15**. Обмен сообщениями с инициативой события

Обратите внимание на компонент *шины событий,* который находится в середине канала связи. Это пользовательский класс, который инкапсулирует сообщение брокера и отсоединяет его от базового приложения. Заказали и инвентаризации микрослужб самостоятельно управлять событием без знания друг друга, ни микрослужбы корзины покупок. Когда зарегистрированное событие публикуется в автобусе события, они действуют на него.

С eventing, мы переходим от технологии очередей к *темам*. [Тема](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions) похожа на очередь, но поддерживает шаблон обмена сообщениями от одного к многим. Одна микрослужба публикует сообщение. Несколько подподписки микрослужб могут выбрать для получения и действовать на этом сообщении. На рисунке 4-16 показана тема архитектуры.

![Архитектура темы](./media/topic-architecture.png)

**Рис. 4-16**. Архитектура темы

На предыдущем рисунке издатели отправляют сообщения на эту тему. В конце абоненты получают сообщения от подписок. В середине, тема препровождает сообщения к подпискам на основе набора *правил,* показанных в темно-синих коробках. Правила выступают в качестве фильтра, который перенаправляет определенные сообщения в подписку. Здесь мероприятие "CreateOrder" будет отправлено \#в \#Подписку 1 и \#Подписку 3, но не на подписку 2. Мероприятие "OrderCompleted" будет отправлено \#в \#подписку 2 и подписку 3.

Облако Azure поддерживает два различных тематических сервиса: Темы для обслуживания служб Azure и Azure EventGrid.

### <a name="azure-service-bus-topics"></a>Разделы служебной шины Azure

Расположенные на вершине той же надежной модели сообщений посреднической связи очередей Azure Service Bus являются [темы автобусов Azure.](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions) Тема может получать сообщения от нескольких независимых издателей и отправлять сообщения до 2000 подписчиков. Подписки могут быть динамически добавлены или удалены во время выполнения, не останавливая систему или воссоздание темы.

Многие расширенные функции из очередей Azure Service Bus также доступны для тематических тем, включая [поддержку обнаружения и](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection) [транзакций.](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions) По умолчанию темы Service Bus обрабатываются одним брокером сообщений и хранятся в одном хранилище сообщений. Но, [Сервис Ный раздел масштабов](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) темы, распространяя его во многих брокеров сообщений и магазинов сообщений.

[Запланированная доставка сообщений](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing) помечает сообщение с определенным временем обработки. Сообщение не будет отображаться в теме до этого времени. [Отсрочка сообщений](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral) позволяет отложить поиск сообщения на более позднее время. Оба они обычно используются в сценариях обработки рабочего процесса, где операции обрабатываются в определенном порядке. Вы можете отложить обработку полученных сообщений до завершения предыдущей работы.

Темы Сервисного автобуса — это надежная и проверенная технология, позволяющая публиковать/подписывать связь в облачных системах.

### <a name="azure-event-grid"></a>Сетка событий Azure

В то время как Azure Service Bus является проверенным в бою брокером обмена сообщениями с полным набором корпоративных функций, [Azure Event Grid](https://docs.microsoft.com/azure/event-grid/overview) — это новый парень в блоке.

На первый взгляд, Event Grid может выглядеть как просто еще одна тема на основе системы обмена сообщениями. Тем не менее, это разные во многих отношениях. Сосредоточенный на рабочих нагрузках, управляемых событиями, он обеспечивает обработку событий в режиме реального времени, глубокую интеграцию Azure и открытую платформу - все это на инфраструктуре без серверов. Он предназначен для современных облачных и без серверных приложений

Как централизованная *задняя плоскость*или труба, Event Grid реагирует на события внутри ресурсов Azure и от ваших собственных служб.

Уведомления о событиях публикуются в тему Event Grid Topic, которая, в свою очередь, направляет каждое событие в подписку. Подписчики отображают карту подписок и потребляют события. Как и Service Bus, Event Grid поддерживает *отфильтрованную модель абонента,* в которой подписка устанавливает правило для событий, которые она хочет получить. Event Grid обеспечивает быструю пропускную связь с гарантией 10 миллионов событий в секунду, что позволяет осуществлять доставку в режиме реального времени , что намного больше, чем может генерировать Azure Service Bus.

Сладким местом для Event Grid является его глубокая интеграция в структуру инфраструктуры Azure. Ресурс Azure, такой как Cosmos DB, может публиковать встроенные события непосредственно в другие заинтересованные ресурсы Azure без необходимости в пользовательском коде. Event Grid может публиковать события из группы ресурсов Azure, группы ресурсов или службы, предоставляя разработчикам возможность контролировать жизненный цикл облачных ресурсов. Однако Event Grid не ограничивается Azure. Это открытая платформа, которая может использовать пользовательские события HTTP, опубликованные из приложений или сторонних служб и маршрут событий для внешних абонентов.

При публикации и подписке на местные события из ресурсов Azure кодирование не требуется. С помощью простой конфигурации можно интегрировать события с одного ресурса Azure в другой, используя встроенную сантехнику для тем и подписки. На рисунке 4-17 показана анатомия Event Grid.

![Анатомия сетки событий](./media/event-grid-anatomy.png)

**Рис. 4-17**. Анатомия сетки событий

Основным отличием EventGrid от Service Bus является базовый *шаблон обмена сообщениями.*

Service Bus реализует старую *модель притяжения* стиля, в которой нижепом абонент активно опросы тему подписки на новые сообщения. С другой стороны, этот подход дает абоненту полный контроль над темпами, с которыми он обрабатывает сообщения. Он контролирует, когда и сколько сообщений для обработки в любой момент времени. Непрочитае сообщения остаются в подписке до обработки. Существенным недостатком является задержка между моментом возникновения события и операцией опроса, которая тянет это сообщение к абоненту для обработки. Кроме того, накладные расходы на постоянное голосование на следующее мероприятие потребляет ресурсы и деньги.

EventGrid, однако, отличается. Он реализует *модель push,* в которой события отправляются в EventHandlers в качестве полученных, предоставляя почти в режиме реального времени доставку событий. Это также снижает стоимость, поскольку служба срабатывает только тогда, когда она необходима для потребления события - не постоянно, как с опроса. Тем не менее, обработчик событий должен обрабатывать входящие нагрузки и обеспечивать механизмы регулирования, чтобы защитить себя от перегружены. Многие службы Azure, потребляющие эти события, такие как Функции Azure и логические приложения, предоставляют возможности автоматического автоматического масштабирования для обработки повышенных нагрузок.  

Event Grid — это полностью управляемый облачный сервис без серверов. Он динамически масштабируется на основе вашего трафика и взимает плату только за ваше фактическое использование, а не предварительно приобретенные мощности. Первые 100 000 операций в месяц являются бесплатными – операции определяются как вход события (входящие уведомления о событиях), попытки доставки подписок, вызовы управления и фильтрация по субъекту. С 99,99% доступности, EventGrid гарантирует доставку события в течение 24-часового периода, со встроенной функциональностью повтора для неудачной доставки. Недоставленные сообщения могут быть перемещены в очередь «мертвого письма» для разрешения.  В отличие от Azure Service Bus, Event Grid настроен анаментируется для быстрой работы и не поддерживает такие функции, как упорядоченные сообщения, транзакции и сеансы.

### <a name="streaming-messages-in-the-azure-cloud"></a>Потоковые сообщения в облаке Azure

Служба обслуживания Azure и Event Grid обеспечивают большую поддержку приложениям, которые разоблачают отдельные, дискретные события, такие как новый документ, вставленный в DB Космоса. Но что делать, если ваша облачная система должна обрабатывать *поток связанных событий?* Потоки событий являются более [сложными.](https://docs.microsoft.com/archive/msdn-magazine/2015/february/microsoft-azure-the-rise-of-event-stream-oriented-systems) Они обычно упорядочены по времени, взаимосвязаны и должны обрабатываться как группа.

[Azure Event Hub](https://azure.microsoft.com/services/event-hubs/) — это платформа для потоковой передачи данных и служба приема событий, которая собирает, преобразует и хранит события. Он дорабатывается для захвата потоковых данных, таких как непрерывные уведомления о событиях, испускаемые из контекста телеметрии. Услуга очень масштабируема и может хранить и [обрабатывать миллионы событий в секунду.](https://docs.microsoft.com/azure/event-hubs/event-hubs-about) Показано на рисунке 4-18, это часто входная дверь для конвейера событий, разъединяя поток глотать от потребления событий.

![концентратору событий Azure](./media/azure-event-hub.png)

**Рис. 4-18**. концентратору событий Azure

Концентратор событий поддерживает низкую задержку и настраиваемое время удержания. В отличие от очередей и тем, концентраторы событий хранят данные о событиях после их прочтения потребителем. Эта функция позволяет другим аналитическим службам данных, как внутренним, так и внешним, воспроизводить данные для дальнейшего анализа. События, хранящиеся в концентраторе событий, удаляются только по истечении периода хранения, который является одним днем по умолчанию, но настраивается.

Концентратор событий поддерживает общие протоколы публикации событий, включая HTTPS и АМЗП. Он также поддерживает Кафку 1.0. [Существующие приложения Kafka могут общаться с Event Hub,](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview) используя протокол Kafka, предоставляя альтернативу управлению большими кластерами Kafka. Многие облачные системы с открытым исходным кодом охватывают Kafka.

Концентраторы событий реализуют потоковую передачу сообщений через [разделенную модель потребителя,](https://docs.microsoft.com/azure/event-hubs/event-hubs-features) в которой каждый потребитель читает только определенный подмножество или раздел потока сообщений. Это позволяет получить непревзойденные преимущества горизонтального масштабирования для обработки событий и другие ориентированные на работу с потоками функции, недоступные в очередях и разделах. Секция — это упорядоченная последовательность событий, хранящаяся в концентраторе событий. По мере поступления новых событий они добавляются к концу этой последовательности.На рисунке 4-19 показана разделвивание в концентраторе событий.

![Разделки концентратора событий](./media/event-hub-partitioning.png)

**Рис. 4-19**. Разделки концентратора событий

Вместо того, чтобы читать с одного ресурса, каждая группа потребителей читает через подмножество или раздел потока сообщений.

Для облачных приложений, которые должны передавать большое количество событий, Azure Event Hub может стать надежным и доступным решением.

>[!div class="step-by-step"]
>[Предыдущий](front-end-communication.md)
>[Следующий](grpc.md)
