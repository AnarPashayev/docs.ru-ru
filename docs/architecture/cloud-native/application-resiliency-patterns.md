---
title: Шаблоны устойчивости приложения
description: Создание архитектуры облачных приложений .NET для Azure | Шаблоны устойчивости приложений
author: robvet
ms.date: 05/13/2020
ms.openlocfilehash: bb72e47704c833a2ce86f103a66b0414ce3a37ff
ms.sourcegitcommit: 27db07ffb26f76912feefba7b884313547410db5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/19/2020
ms.locfileid: "83614332"
---
# <a name="application-resiliency-patterns"></a><span data-ttu-id="132d6-103">Шаблоны устойчивости приложения</span><span class="sxs-lookup"><span data-stu-id="132d6-103">Application resiliency patterns</span></span>

<span data-ttu-id="132d6-104">Первой линией обороны является устойчивость приложений.</span><span class="sxs-lookup"><span data-stu-id="132d6-104">The first line of defense is application resiliency.</span></span>

<span data-ttu-id="132d6-105">Хотя вы можете вкладывать значительное время в собственную платформу устойчивости, такие продукты уже существуют.</span><span class="sxs-lookup"><span data-stu-id="132d6-105">While you could invest considerable time writing your own resiliency framework, such products already exist.</span></span> <span data-ttu-id="132d6-106">[Polly](http://www.thepollyproject.org/) — это комплексная библиотека устойчивости и обработки временных ошибок .NET, которая позволяет разработчикам выразить политики устойчивости в свободном и безопасном для потоков режиме.</span><span class="sxs-lookup"><span data-stu-id="132d6-106">[Polly](http://www.thepollyproject.org/) is a comprehensive .NET resilience and transient-fault-handling library that allows developers to express resiliency policies in a fluent and thread-safe manner.</span></span> <span data-ttu-id="132d6-107">Polly предназначен для приложений, созданных с помощью .NET Framework или .NET Core.</span><span class="sxs-lookup"><span data-stu-id="132d6-107">Polly targets applications built with either the .NET Framework or .NET Core.</span></span> <span data-ttu-id="132d6-108">В следующей таблице описаны функции устойчивости, которые называются `policies` доступными в библиотеке Polly.</span><span class="sxs-lookup"><span data-stu-id="132d6-108">The following table describes the resiliency features, called `policies`, available in the Polly Library.</span></span> <span data-ttu-id="132d6-109">Они могут быть применены по отдельности или сгруппированы вместе.</span><span class="sxs-lookup"><span data-stu-id="132d6-109">They can be applied individually or grouped together.</span></span>

| <span data-ttu-id="132d6-110">Политика</span><span class="sxs-lookup"><span data-stu-id="132d6-110">Policy</span></span> | <span data-ttu-id="132d6-111">Взаимодействие</span><span class="sxs-lookup"><span data-stu-id="132d6-111">Experience</span></span> |
| :-------- | :-------- |
| <span data-ttu-id="132d6-112">Повторить попытку</span><span class="sxs-lookup"><span data-stu-id="132d6-112">Retry</span></span> | <span data-ttu-id="132d6-113">Настраивает операции повтора для указанных операций.</span><span class="sxs-lookup"><span data-stu-id="132d6-113">Configures retry operations on designated operations.</span></span> |
| <span data-ttu-id="132d6-114">Автоматическое выключение</span><span class="sxs-lookup"><span data-stu-id="132d6-114">Circuit Breaker</span></span> | <span data-ttu-id="132d6-115">Блокирует запрошенные операции для предопределенного периода, когда ошибки превышают заданное пороговое значение</span><span class="sxs-lookup"><span data-stu-id="132d6-115">Blocks requested operations for a predefined period when faults exceed a configured threshold</span></span> |
| <span data-ttu-id="132d6-116">Время ожидания</span><span class="sxs-lookup"><span data-stu-id="132d6-116">Timeout</span></span> | <span data-ttu-id="132d6-117">Размещает ограничение на продолжительность времени, в течение которого вызывающий объект может ожидать ответа.</span><span class="sxs-lookup"><span data-stu-id="132d6-117">Places limit on the duration for which a caller can wait for a response.</span></span> |
| <span data-ttu-id="132d6-118">Распределительный блок</span><span class="sxs-lookup"><span data-stu-id="132d6-118">Bulkhead</span></span> | <span data-ttu-id="132d6-119">Ограничивает действия пулом ресурсов фиксированного размера, чтобы предотвратить неудачные вызовы из перегрузки ресурса.</span><span class="sxs-lookup"><span data-stu-id="132d6-119">Constrains actions to fixed-size resource pool to prevent failing calls from swamping a resource.</span></span> |
| <span data-ttu-id="132d6-120">Кэш</span><span class="sxs-lookup"><span data-stu-id="132d6-120">Cache</span></span> | <span data-ttu-id="132d6-121">Сохраняет ответы автоматически.</span><span class="sxs-lookup"><span data-stu-id="132d6-121">Stores responses automatically.</span></span> |
| <span data-ttu-id="132d6-122">Резервирование</span><span class="sxs-lookup"><span data-stu-id="132d6-122">Fallback</span></span> | <span data-ttu-id="132d6-123">Определяет структурированное поведение при сбое.</span><span class="sxs-lookup"><span data-stu-id="132d6-123">Defines structured behavior upon a failure.</span></span> |

<span data-ttu-id="132d6-124">Обратите внимание, как на предыдущем рисунке политики устойчивости применяются к сообщениям запроса независимо от того, поступает ли от внешнего клиента или серверной службы.</span><span class="sxs-lookup"><span data-stu-id="132d6-124">Note how in the previous figure the resiliency policies apply to request messages, whether coming from an external client or back-end service.</span></span> <span data-ttu-id="132d6-125">Цель — компенсировать запрос службы, которая может быть недоступна мгновенно.</span><span class="sxs-lookup"><span data-stu-id="132d6-125">The goal is to compensate the request for a service that might be momentarily unavailable.</span></span> <span data-ttu-id="132d6-126">Эти кратковременные перерывы обычно проводят себя с кодом состояния HTTP, приведенным в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="132d6-126">These short-lived interruptions typically manifest themselves with the HTTP status codes shown in the following table.</span></span>

| <span data-ttu-id="132d6-127">Код состояния HTTP</span><span class="sxs-lookup"><span data-stu-id="132d6-127">HTTP Status Code</span></span>| <span data-ttu-id="132d6-128">Причина:</span><span class="sxs-lookup"><span data-stu-id="132d6-128">Cause</span></span> |
| :-------- | :-------- |
| <span data-ttu-id="132d6-129">404</span><span class="sxs-lookup"><span data-stu-id="132d6-129">404</span></span> | <span data-ttu-id="132d6-130">Не найдено</span><span class="sxs-lookup"><span data-stu-id="132d6-130">Not Found</span></span> |
| <span data-ttu-id="132d6-131">408</span><span class="sxs-lookup"><span data-stu-id="132d6-131">408</span></span> | <span data-ttu-id="132d6-132">Время ожидания запроса</span><span class="sxs-lookup"><span data-stu-id="132d6-132">Request timeout</span></span> |
| <span data-ttu-id="132d6-133">429</span><span class="sxs-lookup"><span data-stu-id="132d6-133">429</span></span> | <span data-ttu-id="132d6-134">Слишком много запросов (вы, скорее всего, отрегулированы)</span><span class="sxs-lookup"><span data-stu-id="132d6-134">Too many requests (you've most likely been throttled)</span></span> |
| <span data-ttu-id="132d6-135">502</span><span class="sxs-lookup"><span data-stu-id="132d6-135">502</span></span> | <span data-ttu-id="132d6-136">Недопустимый шлюз</span><span class="sxs-lookup"><span data-stu-id="132d6-136">Bad gateway</span></span> |
| <span data-ttu-id="132d6-137">503</span><span class="sxs-lookup"><span data-stu-id="132d6-137">503</span></span> | <span data-ttu-id="132d6-138">Служба недоступна</span><span class="sxs-lookup"><span data-stu-id="132d6-138">Service unavailable</span></span> |
| <span data-ttu-id="132d6-139">504</span><span class="sxs-lookup"><span data-stu-id="132d6-139">504</span></span> | <span data-ttu-id="132d6-140">Время ожидания шлюза</span><span class="sxs-lookup"><span data-stu-id="132d6-140">Gateway timeout</span></span> |

<span data-ttu-id="132d6-141">Вопрос. можно ли повторить код состояния HTTP 403-запрещено?</span><span class="sxs-lookup"><span data-stu-id="132d6-141">Question: Would you retry an HTTP Status Code of 403 - Forbidden?</span></span> <span data-ttu-id="132d6-142">Нет.</span><span class="sxs-lookup"><span data-stu-id="132d6-142">No.</span></span> <span data-ttu-id="132d6-143">В этом случае система работает правильно, но сообщает вызывающему объекту, что он не имеет прав для выполнения запрошенной операции.</span><span class="sxs-lookup"><span data-stu-id="132d6-143">Here, the system is functioning properly, but informing the caller that they aren't authorized to perform the requested operation.</span></span> <span data-ttu-id="132d6-144">Необходимо соблюдать осторожность, чтобы повторить только операции, вызванные сбоями.</span><span class="sxs-lookup"><span data-stu-id="132d6-144">Care must be taken to retry only those operations caused by failures.</span></span>

<span data-ttu-id="132d6-145">Как мы рекомендуем в главе 1, разработчики Майкрософт, создающие облачные приложения, должны ориентироваться на платформу .NET Core.</span><span class="sxs-lookup"><span data-stu-id="132d6-145">As recommended in Chapter 1, Microsoft developers constructing cloud-native applications should target the .NET Core platform.</span></span> <span data-ttu-id="132d6-146">В версии 2,1 появилась библиотека [хттпклиентфактори](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore) для создания экземпляров клиентов HTTP для взаимодействия с ресурсами на основе URL-адресов.</span><span class="sxs-lookup"><span data-stu-id="132d6-146">Version 2.1 introduced the [HTTPClientFactory](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore) library for creating HTTP Client instances for interacting with URL-based resources.</span></span> <span data-ttu-id="132d6-147">Заменяя исходный класс HTTPClient, класс фабрики поддерживает множество улучшенных функций, одна из которых [тесно интегрируется](../microservices/implement-resilient-applications/implement-http-call-retries-exponential-backoff-polly.md) с библиотекой устойчивости Polly.</span><span class="sxs-lookup"><span data-stu-id="132d6-147">Superseding the original HTTPClient class, the factory class supports many enhanced features, one of which is [tight integration](../microservices/implement-resilient-applications/implement-http-call-retries-exponential-backoff-polly.md) with the Polly resiliency library.</span></span> <span data-ttu-id="132d6-148">С его помощью можно легко определить политики устойчивости в классе запуска приложения для решения частичных сбоев и проблем с подключением.</span><span class="sxs-lookup"><span data-stu-id="132d6-148">With it, you can easily define resiliency policies in the application Startup class to handle partial failures and connectivity issues.</span></span>

<span data-ttu-id="132d6-149">Теперь давайте разберем шаблоны повтора и повторного запуска.</span><span class="sxs-lookup"><span data-stu-id="132d6-149">Next, let's expand on retry and circuit breaker patterns.</span></span>

### <a name="retry-pattern"></a><span data-ttu-id="132d6-150">Шаблон повторов</span><span class="sxs-lookup"><span data-stu-id="132d6-150">Retry pattern</span></span>

<span data-ttu-id="132d6-151">В распределенной облачной среде вызовы служб и облачных ресурсов могут завершаться сбоем из-за временных сбоев (кратковременных), которые обычно исправляются по истечении короткого периода времени.</span><span class="sxs-lookup"><span data-stu-id="132d6-151">In a distributed cloud-native environment, calls to services and cloud resources can fail because of transient (short-lived) failures, which typically correct themselves after a brief period of time.</span></span> <span data-ttu-id="132d6-152">Реализация стратегии повторных попыток помогает облачной службе снизить эти сценарии.</span><span class="sxs-lookup"><span data-stu-id="132d6-152">Implementing a retry strategy helps a cloud-native service mitigate these scenarios.</span></span>

<span data-ttu-id="132d6-153">[Шаблон повторных попыток](https://docs.microsoft.com/azure/architecture/patterns/retry) позволяет службе повторить операцию невыполненного запроса (настраивается) количество раз с экспоненциально увеличивающимся временем ожидания.</span><span class="sxs-lookup"><span data-stu-id="132d6-153">The [Retry pattern](https://docs.microsoft.com/azure/architecture/patterns/retry) enables a service to retry a failed request operation a (configurable) number of times with an exponentially increasing wait time.</span></span> <span data-ttu-id="132d6-154">На рис. 6-2 показана повторная попытка в действии.</span><span class="sxs-lookup"><span data-stu-id="132d6-154">Figure 6-2 shows a retry in action.</span></span>

![Шаблон повторных попыток в действии](./media/retry-pattern.png)

<span data-ttu-id="132d6-156">**Рис. 6-2**.</span><span class="sxs-lookup"><span data-stu-id="132d6-156">**Figure 6-2**.</span></span> <span data-ttu-id="132d6-157">Шаблон повторных попыток в действии</span><span class="sxs-lookup"><span data-stu-id="132d6-157">Retry pattern in action</span></span>

<span data-ttu-id="132d6-158">На предыдущем рисунке для операции запроса был реализован шаблон повтора.</span><span class="sxs-lookup"><span data-stu-id="132d6-158">In the previous figure, a retry pattern has been implemented for a request operation.</span></span> <span data-ttu-id="132d6-159">Он разрешает до четырех повторных попыток, прежде чем завершать работу с интервалом перехода (время ожидания), начиная с двух секунд, экспоненциально удваивается при каждой последующей попытке.</span><span class="sxs-lookup"><span data-stu-id="132d6-159">It's configured to allow up to four retries before failing with a backoff interval (wait time) starting at two seconds, which exponentially doubles for each subsequent attempt.</span></span>

- <span data-ttu-id="132d6-160">При первом вызове происходит сбой и возвращается код состояния HTTP 500.</span><span class="sxs-lookup"><span data-stu-id="132d6-160">The first invocation fails and returns an HTTP status code of 500.</span></span> <span data-ttu-id="132d6-161">Приложение ожидает две секунды и повторяет вызов.</span><span class="sxs-lookup"><span data-stu-id="132d6-161">The application waits for two seconds and retries the call.</span></span>
- <span data-ttu-id="132d6-162">Второй вызов также завершается ошибкой и возвращает код состояния HTTP 500.</span><span class="sxs-lookup"><span data-stu-id="132d6-162">The second invocation also fails and returns an HTTP status code of 500.</span></span> <span data-ttu-id="132d6-163">Теперь приложение удваивает интервал отхода до четырех секунд и повторяет вызов.</span><span class="sxs-lookup"><span data-stu-id="132d6-163">The application now doubles the backoff interval to four seconds and retries the call.</span></span>
- <span data-ttu-id="132d6-164">Наконец, третий вызов будет выполнен.</span><span class="sxs-lookup"><span data-stu-id="132d6-164">Finally, the third call succeeds.</span></span>
- <span data-ttu-id="132d6-165">В этом сценарии операция повтора попыталась выполнить до четырех повторных попыток, не выполняя при этом вызов.</span><span class="sxs-lookup"><span data-stu-id="132d6-165">In this scenario, the retry operation would have attempted up to four retries while doubling the backoff duration before failing the call.</span></span>
- <span data-ttu-id="132d6-166">Если не удалось выполнить четвертую попытку повтора, будет вызвана политика резервного использования для корректной работы этой проблемы.</span><span class="sxs-lookup"><span data-stu-id="132d6-166">Had the 4th retry attempt failed, a fallback policy would be invoked to gracefully handle the problem.</span></span>

<span data-ttu-id="132d6-167">Важно увеличить период отсрочки перед повторным выполнением вызова, чтобы разрешить время службы самостоятельно.</span><span class="sxs-lookup"><span data-stu-id="132d6-167">It's important to increase the backoff period before retrying the call to allow the service time to self-correct.</span></span> <span data-ttu-id="132d6-168">Рекомендуется реализовать экспоненциальное увеличение задержки (удвоение периода при каждой повторной попытке), чтобы обеспечить адекватное время исправления.</span><span class="sxs-lookup"><span data-stu-id="132d6-168">It's a best practice to implement an exponentially increasing backoff (doubling the period on each retry) to allow adequate correction time.</span></span>

## <a name="circuit-breaker-pattern"></a><span data-ttu-id="132d6-169">Шаблон автоматического выключения</span><span class="sxs-lookup"><span data-stu-id="132d6-169">Circuit breaker pattern</span></span>

<span data-ttu-id="132d6-170">Хотя шаблон повторных попыток может помочь в восстановлении запроса, запутанными в частичный сбой, бывают ситуации, когда сбои могут быть вызваны непредвиденными событиями, требующими более длительных периодов времени для разрешения.</span><span class="sxs-lookup"><span data-stu-id="132d6-170">While the retry pattern can help salvage a request entangled in a partial failure, there are situations where failures can be caused by unanticipated events that will require longer periods of time to resolve.</span></span> <span data-ttu-id="132d6-171">Такие сбои могут быть различной степени серьезности: от частичной потери соединения до полного отказа службы.</span><span class="sxs-lookup"><span data-stu-id="132d6-171">These faults can range in severity from a partial loss of connectivity to the complete failure of a service.</span></span> <span data-ttu-id="132d6-172">В таких ситуациях приложение не позволяет постоянно повторять операцию, которая вряд ли будет выполнена.</span><span class="sxs-lookup"><span data-stu-id="132d6-172">In these situations, it's pointless for an application to continually retry an operation that is unlikely to succeed.</span></span>

<span data-ttu-id="132d6-173">Чтобы сделать что-то хуже, выполнение непрерывных операций повтора в службе, не поддерживающей реагирование, может переместить вас в неуправляемый сценарий отказа в обслуживании, когда вы перейдете в службу, используя непрерывные вызовы, такие как память, потоки и подключения к базе данных, что приведет к сбою в работе несвязанных частей системы, использующих те же ресурсы.</span><span class="sxs-lookup"><span data-stu-id="132d6-173">To make things worse, executing continual retry operations on a non-responsive service can move you into a self-imposed denial of service scenario where you flood your service with continual calls exhausting resources such as memory, threads and database connections, causing failure in unrelated parts of the system that use the same resources.</span></span>

<span data-ttu-id="132d6-174">В таких ситуациях было бы предпочтительнее выполнить операцию неудачно и попытаться вызвать службу только в случае ее удачного завершения.</span><span class="sxs-lookup"><span data-stu-id="132d6-174">In these situations, it would be preferable for the operation to fail immediately and only attempt to invoke the service if it's likely to succeed.</span></span>

<span data-ttu-id="132d6-175">[Шаблон](https://docs.microsoft.com/azure/architecture/patterns/circuit-breaker) автоматического выключения может помешать приложению многократно пытаться выполнить операцию, которая, скорее всего, завершится ошибкой.</span><span class="sxs-lookup"><span data-stu-id="132d6-175">The [Circuit Breaker pattern](https://docs.microsoft.com/azure/architecture/patterns/circuit-breaker) can prevent an application from repeatedly trying to execute an operation that's likely to fail.</span></span> <span data-ttu-id="132d6-176">После определенного числа неудачных вызовов он блокирует весь трафик к службе.</span><span class="sxs-lookup"><span data-stu-id="132d6-176">After a pre-defined number of failed calls, it blocks all traffic to the service.</span></span> <span data-ttu-id="132d6-177">Периодически это позволяет вызываемому пробному вызову определить, устранена ли ошибка.</span><span class="sxs-lookup"><span data-stu-id="132d6-177">Periodically, it will allow a trial call to determine whether the fault has resolved.</span></span> <span data-ttu-id="132d6-178">На рис. 6-3 показан шаблон автоматического выключения цепи в действии.</span><span class="sxs-lookup"><span data-stu-id="132d6-178">Figure 6-3 shows the Circuit Breaker pattern in action.</span></span>

![Шаблон автоматического прерывания в действии](./media/circuit-breaker-pattern.png)

<span data-ttu-id="132d6-180">**Рис. 6-3**.</span><span class="sxs-lookup"><span data-stu-id="132d6-180">**Figure 6-3**.</span></span> <span data-ttu-id="132d6-181">Шаблон автоматического прерывания в действии</span><span class="sxs-lookup"><span data-stu-id="132d6-181">Circuit breaker pattern in action</span></span>

<span data-ttu-id="132d6-182">На предыдущем рисунке к исходному шаблону повтора добавлен шаблон автоматического выключения.</span><span class="sxs-lookup"><span data-stu-id="132d6-182">In the previous figure, a Circuit Breaker pattern has been added to the original retry pattern.</span></span> <span data-ttu-id="132d6-183">Обратите внимание, что после 100 неудачных запросов автоматически открываются вызовы, которые больше не допускают обращения к службе.</span><span class="sxs-lookup"><span data-stu-id="132d6-183">Note how after 100 failed requests, the circuit breakers opens and no longer allows calls to the service.</span></span> <span data-ttu-id="132d6-184">Значение ЧеккЦиркуит, заданное в течение 30 секунд, указывает, как часто библиотека разрешает выполнение одного запроса к службе.</span><span class="sxs-lookup"><span data-stu-id="132d6-184">The CheckCircuit value, set at 30 seconds, specifies how often the library allows one request to proceed to the service.</span></span> <span data-ttu-id="132d6-185">Если этот вызов завершается, канал закрывается, а служба снова становится доступной для трафика.</span><span class="sxs-lookup"><span data-stu-id="132d6-185">If that call succeeds, the circuit closes and the service is once again available to traffic.</span></span>

<span data-ttu-id="132d6-186">Помните, что цель шаблона автоматического выключения *отличается* от цели шаблона повторного выполнения.</span><span class="sxs-lookup"><span data-stu-id="132d6-186">Keep in mind that the intent of the Circuit Breaker pattern is *different* than that of the Retry pattern.</span></span> <span data-ttu-id="132d6-187">Шаблон повторных попыток позволяет приложению повторить операцию в ожидании, что оно будет выполняться.</span><span class="sxs-lookup"><span data-stu-id="132d6-187">The Retry pattern enables an application to retry an operation in the expectation that it will succeed.</span></span> <span data-ttu-id="132d6-188">Шаблон автоматического выключения не позволяет приложению выполнить операцию, которая, скорее всего, завершится ошибкой.</span><span class="sxs-lookup"><span data-stu-id="132d6-188">The Circuit Breaker pattern prevents an application from doing an operation that is likely to fail.</span></span> <span data-ttu-id="132d6-189">Как правило, приложение *объединяет* эти два шаблона, используя шаблон повтора для вызова операции через автоматическое выключение.</span><span class="sxs-lookup"><span data-stu-id="132d6-189">Typically, an application will *combine* these two patterns by using the Retry pattern to invoke an operation through a circuit breaker.</span></span>

## <a name="testing-for-resiliency"></a><span data-ttu-id="132d6-190">Тестирование отказоустойчивости</span><span class="sxs-lookup"><span data-stu-id="132d6-190">Testing for resiliency</span></span>

<span data-ttu-id="132d6-191">Проверка устойчивости не всегда выполняется точно так же, как тестирование функциональности приложения (путем выполнения модульных тестов, интеграционных тестов и т. д.).</span><span class="sxs-lookup"><span data-stu-id="132d6-191">Testing for resiliency cannot always be done the same way that you test application functionality (by running unit tests, integration tests and so on).</span></span> <span data-ttu-id="132d6-192">Вместо этого вы должны проверить, как сквозная рабочая нагрузка выполняется в условиях сбоя, которые происходят только периодически.</span><span class="sxs-lookup"><span data-stu-id="132d6-192">Instead, you must test how the end-to-end workload performs under failure conditions which only occur intermittently.</span></span> <span data-ttu-id="132d6-193">Например: Вставка сбоев с помощью процессов аварийного завершения, просроченных сертификатов, недоступность зависимых служб и т. д. Такие платформы, как [Chaos-обезьяна](https://github.com/Netflix/chaosmonkey) , можно использовать для такого тестирования Chaos.</span><span class="sxs-lookup"><span data-stu-id="132d6-193">For example: inject failures by crashing processes, expired certificates, make dependent services unavailable etc. Frameworks like [chaos-monkey](https://github.com/Netflix/chaosmonkey) can be used for such chaos testing.</span></span>

<span data-ttu-id="132d6-194">Устойчивость приложений является обязательной для обработки проблемно запрашиваемых операций.</span><span class="sxs-lookup"><span data-stu-id="132d6-194">Application resiliency is a must for handling problematic requested operations.</span></span> <span data-ttu-id="132d6-195">Но это лишь половина истории.</span><span class="sxs-lookup"><span data-stu-id="132d6-195">But, it's only half of the story.</span></span> <span data-ttu-id="132d6-196">Далее мы рассмотрим функции устойчивости, доступные в облаке Azure.</span><span class="sxs-lookup"><span data-stu-id="132d6-196">Next, we cover resiliency features available in the Azure cloud.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="132d6-197">[Назад](resiliency.md)
>[Вперед](infrastructure-resiliency-azure.md)</span><span class="sxs-lookup"><span data-stu-id="132d6-197">[Previous](resiliency.md)
[Next](infrastructure-resiliency-azure.md)</span></span>
