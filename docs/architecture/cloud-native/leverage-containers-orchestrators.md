---
title: Использование контейнеров и оркестраторов
description: Использование контейнеров DOCKER и orchestration Kubernetes в Azure
ms.date: 06/30/2019
ms.openlocfilehash: 7b136ed2760ea471f42ff82d20298ff8714c6dee
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/30/2019
ms.locfileid: "73841765"
---
# <a name="leveraging-containers-and-orchestrators"></a>Использование контейнеров и оркестраторов

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

Контейнеры и оркестрации предназначены для решения проблем, характерных для монолитных подходов к развертыванию.

## <a name="challenges-with-monolithic-deployments"></a>Проблемы с монолитными развертываниями

Обычно большинство приложений развернуты как единое целое. Такие приложения называются монолитными. Этот общий подход к развертыванию приложений в виде отдельных единиц, даже если они состоят из нескольких модулей или сборок, называется монолитной архитектурой, как показано на рисунке 3-1.

![Монолитная архитектура.](./media/monolithic-architecture.png)

**Рис. 3-1**. Монолитная архитектура.

Хотя они имеют преимущество простоты, монолитные архитектуры сталкиваются с несколькими проблемами:

### <a name="deployments"></a>развертывания,

Развертывание в монолитных приложениях обычно требует перезапуска всего приложения, даже если заменяется только один маленький модуль. В зависимости от количества компьютеров, на которых размещается приложение, это может привести к простою во время развертывания.

### <a name="hosting"></a>Размещение

Монолитные приложения полностью размещаются на одном экземпляре компьютера. Это может потребовать наличия оборудования более высокого уровня, чем требуется для любого модуля в распределенном приложении. Кроме того, если какая-либо часть приложения становится узким местом, все приложение должно быть развернуто на дополнительных узлах компьютера для масштабирования.

### <a name="environment"></a>Среда

Монолитные приложения обычно развертываются в существующей среде размещения (операционная система, установленные платформы и т. д.). Эта среда может не соответствовать среде, в которой приложение было разработано или протестировано. Несоответствия в среде приложения являются распространенным источником проблем для монолитных развертываний.

### <a name="coupling"></a>Тесн

Монолитные приложения, скорее всего, будут иметь большое отношение между различными частями приложения и между приложением и его средой. Это может усложнить выгрузку определенной службы или устранить ее позже, чтобы повысить масштабируемость или переключение в другой реализации. Такая связь также приводит к значительному увеличению возможных последствий изменений в системе, что требует всестороннего тестирования в больших приложениях.

### <a name="technology-choice"></a>Вариант технологии

Монолитные приложения создаются и развертываются как единое целое. Это обеспечивает простоту и единообразие, но может быть препятствием для инноваций. Несмотря на то что новая функция или модуль в системе лучше подходят для более современной платформы или платформы, она, скорее всего, будет построена с использованием текущего подхода приложения для обеспечения согласованности, а также для простоты разработки и развертывания.

## <a name="what-are-the-benefits-of-containers-and-orchestrators"></a>Каковы преимущества контейнеров и оркестрации?

DOCKER — это самая популярная платформа управления контейнерами и создания образов, которая позволяет быстро работать с контейнерами в Linux и Windows. Контейнеры предоставляют отдельные, но воспроизводимые среды приложений, которые выполняются одинаково в любой системе. Это делает их идеальными для разработки и размещения приложений и компонентов приложений в собственных облачных приложениях. Контейнеры изолированы друг от друга, поэтому два контейнера на одном и том же оборудовании могут иметь разные версии программного обеспечения и даже установленные операционные системы, без зависимостей, вызывающих конфликты.

Более того, контейнеры определяются простыми файлами, которые можно вернуть в систему управления версиями. В отличие от полных серверов, даже виртуальных машин, для которых часто требуется ручная работа по применению обновлений или установке дополнительных служб, инфраструктура контейнеров может легко управлять версиями. Таким образом, приложения, созданные для работы в контейнерах, можно разрабатывать, тестировать и развертывать с помощью автоматизированных средств в составе конвейера сборки.

Контейнеры являются неизменяемыми. Определив контейнер, вы можете повторно создать этот контейнер, который будет выполняться точно так же. Эта неизменность предоставляет модель, основанную на компонентах. Если некоторые части приложения не изменяются так часто, как и другие, то зачем повторно развертывать все приложение, когда можно просто развернуть наиболее часто меняющиеся части? Различные функции и проблемы с перекрестной обрезкой приложения можно разбить на отдельные единицы. На рис. 3-2 показано, как монолитное приложение может использовать преимущества контейнеров и микрослужб, делегируя определенные функции или функциональные возможности. Остальные функции в самом приложении также были контейнерными.

![разбить монолитное приложение на использование микрослужб в серверной части.](./media/breaking-up-monolith-with-backend-microservices.png)
**рис. 3-2**. Разбивает монолитное приложение на использование микрослужб в серверной части.

Облачные приложения, созданные с помощью отдельных контейнеров, могут развертывать как можно больше или как небольшую часть приложения по мере необходимости. Отдельные службы могут размещаться на узлах с ресурсами, соответствующими каждой службе. Среда, в которой работает каждая служба, является неизменяемой, ее можно совместно использовать для разработки, тестирования и рабочей среды, а также для легкого управления версиями. Связь между различными областями приложения происходит явным образом в виде вызовов или сообщений между службами, а не зависимостями во время компиляции внутри монолиты. И любая заданная часть приложения может выбрать технологию, которая наиболее эффективно подходит для этой функции или возможности, не требуя внесения изменений в остальную часть приложения.

## <a name="what-are-the-scaling-benefits"></a>Каковы преимущества масштабирования?

Службы, созданные на основе контейнеров, могут использовать преимущества масштабирования, предоставляемые средствами оркестрации, такими как Kubernetes. По проектам контейнеры хорошо осведомлены о себе. После начала работы с несколькими контейнерами, которые должны работать вместе, может быть целесообразно упорядочить их на более высоком уровне. Организация большого количества контейнеров и их общих зависимостей, таких как конфигурация сети, заключается в том, где средства оркестрации могут сэкономить день! Kubernetes — это платформа оркестрации контейнеров, предназначенная для автоматизации развертывания, масштабирования и управления контейнерными приложениями. Он создает слой абстракции поверх групп контейнеров и организует их в модули *Pod.* Модули Pod выполняются на рабочих компьютерах, которые называются *узлами*. Вся упорядоченная группа называется *кластером*. На рис. 3-3 показаны различные компоненты кластера Kubernetes.

![компоненты кластера Kubernetes.](./media/kubernetes-cluster-components.png)
**рис. 3-3**. Компоненты кластера Kubernetes.

Kubernetes имеет встроенную поддержку масштабирования кластеров в соответствии с потребностями. В сочетании с контейнерными микрослужбами это обеспечивает собственные облачные приложения с возможностью быстрого и эффективного реагирования на пиковые нагрузки с дополнительными ресурсами, когда и где они требуются.

### <a name="declarative-versus-imperative"></a>Декларативная и императивная

Kubernetes поддерживает как декларативную, так и императивную конфигурацию объекта. Императивный подход включает выполнение различных команд, которые сообщают Kubernetes, что делать каждый шаг. *Запустите* этот образ. *Удалите* этот модуль. *Предоставление* этого порта. С помощью декларативного подхода вы используете файл конфигурации, который описывает, что *вам нужно* , а не *то, что делать, и Kubernetes* , что нужно сделать для достижения нужного конечного состояния. Если вы уже настроили кластер с помощью императивных команд, можно экспортировать декларативный манифест с помощью `kubectl get svc SERVICENAME -o yaml > service.yaml`. При этом будет создан файл манифеста следующего вида:

```yaml
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: "2019-09-13T13:58:47Z"
  labels:
    component: apiserver
    provider: kubernetes
  name: kubernetes
  namespace: default
  resourceVersion: "153"
  selfLink: /api/v1/namespaces/default/services/kubernetes
  uid: 9b1fac62-d62e-11e9-8968-00155d38010d
spec:
  clusterIP: 10.96.0.1
  ports:
  - name: https
    port: 443
    protocol: TCP
    targetPort: 6443
  sessionAffinity: None
  type: ClusterIP
status:
  loadBalancer: {}
```

При использовании декларативной конфигурации можно предварительно просмотреть изменения, которые будут внесены перед их фиксацией, с помощью `kubectl diff -f FOLDERNAME` к папке, в которой находятся файлы конфигурации. Убедившись, что вы хотите применить изменения, запустите `kubectl apply -f FOLDERNAME`. Добавьте `-R` для рекурсивной обработки иерархии папок.

В дополнение к службам можно использовать декларативную конфигурацию для других функций Kubernetes, таких как *развертывания*. Декларативные развертывания используются контроллерами развертывания для обновления ресурсов кластера. Развертывания используются для развертывания новых изменений, увеличения масштаба для поддержки дополнительной нагрузки или отката к предыдущей редакции. Если кластер работает нестабильно, декларативные развертывания предоставляют механизм для автоматического переноса кластера в требуемое состояние.

Использование декларативной конфигурации позволяет представить инфраструктуру в виде кода, который можно возвратить и поработать с версиями вместе с кодом приложения. Это обеспечивает улучшенный контроль изменений и улучшенную поддержку непрерывного развертывания с помощью конвейера сборки и развертывания, привязанного к изменениям системы управления версиями.

## <a name="what-scenarios-are-ideal-for-containers-and-orchestrators"></a>Какие сценарии идеально подходят для контейнеров и оркестрации?

Следующие сценарии идеально подходят для использования контейнеров и оркестрации.

### <a name="applications-requiring-high-uptime-and-scalability"></a>Приложения, которым требуются высокая отказоустойчивость и масштабируемость

Отдельные приложения с высокой степенью бесперебойной работы и требованиями к масштабируемости являются идеальным кандидатом для собственных облачных архитектур, использующих микрослужбы, контейнеры и оркестрации. Эти приложения можно разрабатывать в контейнерах с помощью сред с управлением версиями. их можно тщательно протестировать, прежде чем перейти в рабочую среду и можно будет развернуть в рабочей среде с нулевым временем простоя. Использование кластеров Kubernetes гарантирует, что такие приложения также могут масштабироваться по запросу и автоматически восстанавливаться при сбоях узлов.

### <a name="large-numbers-of-applications"></a>Большое число приложений

Организации, которые развертывают и должны в дальнейшем поддерживать большое количество приложений, имеют преимущество от контейнеров и оркестрации. Настройка контейнерных сред и кластеров Kubernetes в первую очередь является фиксированной ценой. При развертывании, обслуживании и обновлении отдельных приложений стоимость зависит от количества приложений, которые необходимо поддерживать. Помимо определенного довольно небольшого количества приложений, сложность обслуживания пользовательских приложений вручную превышает затраты на реализацию решения с помощью контейнеров и оркестрации.

## <a name="when-should-you-avoid-using-containers-and-orchestrators"></a>Когда следует избегать использования контейнеров и оркестрации?

Если вы не собираетесь создавать приложение и не сможете создать его, следуя этим принципам, возможно, лучше избегать контейнеров и оркестрации. В таких случаях лучше всего перейти вперед с платформы размещения на основе виртуальных машин или, возможно, некоторой гибридной системы, в которой можно прокрутить определенные части функциональности на отдельные контейнеры или даже на бессерверные функции.

## <a name="development-resources"></a>Ресурсы по разработке

В этом разделе приведен краткий список ресурсов по разработке, которые могут помочь приступить к использованию контейнеров и оркестрации для следующего приложения. Если вы ищете рекомендации по проектированию собственного облачного приложения архитектуры микрослужб, ознакомьтесь с руководством по работе с этой книгой, [микрослужбами .NET: архитектурой для контейнерных приложений .NET](https://aka.ms/microservicesebook).

### <a name="local-kubernetes-development"></a>Локальная разработка Kubernetes

Развертывания Kubernetes предоставляют отличное значение в рабочих средах, но их также можно запускать локально. Несмотря на то, что очень важно иметь возможность работать с отдельными приложениями или микрослужбами независимо, иногда бывает неплохо иметь возможность запускать всю систему локально, так же, как она будет выполняться при развертывании в рабочей среде. Существует несколько способов добиться этого, два из которых — Minikube и DOCKER Desktop. Visual Studio также предоставляет средства для разработки DOCKER.

### <a name="minikube"></a>Minikube

Что такое Minikube? Проект Minikube говорит «Minikube реализует локальный кластер Kubernetes в macOS, Linux и Windows». Ее основными целями являются «лучший инструмент для разработки локальных Kubernetes приложений и поддержка всех функций Kubernetes». Установка Minikube отделена от DOCKER, но Minikube поддерживает различные низкоуровневые оболочки, чем поддерживает DOCKER Desktop. В настоящее время Minikube поддерживает следующие функции Kubernetes:

- DNS
- нодепортс
- Конфигмапс и секреты
- Панели мониторинга
- Среды выполнения контейнеров: DOCKER, RKT, CRI-O и контейнеры
- Включение сетевого интерфейса контейнера (CNI)
- Входящего трафика

После установки Minikube можно быстро приступить к работе, выполнив команду `minikube start`, которая скачивает образ и запускает локальный кластер Kubernetes. После запуска кластера вы взаимодействуете с ним с помощью стандартных команд `kubectl` Kubernetes.

### <a name="docker-desktop"></a>DOCKER Desktop

Вы также можете работать с Kubernetes непосредственно из DOCKER Desktop в Windows. Это единственный вариант, если вы используете контейнеры Windows, а также отличный выбор для контейнеров, отличных от Windows. Для настройки Kubernetes, запускаемой из DOCKER Desktop, используется стандартное приложение конфигурации DOCKER Desktop.

![Настройка Kubernetes в DOCKER Desktop](./media/docker-desktop-kubernetes.png)

**Рис. 3-4**. Настройка Kubernetes в DOCKER Desktop.

DOCKER Desktop уже является самым популярным средством для локальной настройки и запуска контейнерных приложений. При работе с DOCKER Desktop можно разрабатывать локально на основе того же набора образов контейнеров DOCKER, который будет развернут в рабочей среде. Приложение DOCKER Desktop предназначено для локального создания, тестирования и поставки контейнерных приложений. После отправки образов в реестр образов, например в реестр контейнеров Azure или DOCKER Hub, службы, такие как Azure Kubernetes Service (AKS), управляют приложением в рабочей среде.

### <a name="visual-studio-docker-tooling"></a>Инструментарий DOCKER в Visual Studio

Visual Studio поддерживает разработку DOCKER для веб-приложений. При создании нового ASP.NET Core приложения вы можете настроить его с поддержкой DOCKER в рамках процесса создания проекта, как показано на рис. 3-5.

![Visual Studio включить поддержку DOCKER](./media/visual-studio-enable-docker-support.png)

**Рис. 3-5**. Visual Studio включить поддержку DOCKER

Если выбран этот параметр, проект создается с `Dockerfile` в корневом каталоге, который можно использовать для создания и размещения приложения в контейнере DOCKER. Пример Dockerfile показан на рисунке 3-6.

```docker
FROM mcr.microsoft.com/dotnet/core/aspnet:3.0-stretch-slim AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/core/sdk:3.0-stretch AS build
WORKDIR /src
COPY ["WebApplication3/WebApplication3.csproj", "WebApplication3/"]
RUN dotnet restore "WebApplication3/WebApplication3.csproj"
COPY . .
WORKDIR "/src/WebApplication3"
RUN dotnet build "WebApplication3.csproj" -c Release -o /app

FROM build AS publish
RUN dotnet publish "WebApplication3.csproj" -c Release -o /app

FROM base AS final
WORKDIR /app
COPY --from=publish /app .
ENTRYPOINT ["dotnet", "WebApplication3.dll"]
```

**Рис. 3-6**. Visual Studio Generated Dockerfile

Поведение по умолчанию при запуске приложения настроено на использование DOCKER. На рис. 3-7 показаны различные параметры запуска, доступные в новом проекте ASP.NET Core, созданном с помощью добавленной поддержки DOCKER.

![Параметры запуска для Visual Studio DOCKER](./media/visual-studio-docker-run-options.png)

**Рис. 3-7**. Параметры запуска для Visual Studio DOCKER

Помимо локальной разработки [Azure dev Spaces](https://docs.microsoft.com/azure/dev-spaces/) предоставляет несколько разработчикам удобный способ работы с собственными конфигурациями Kubernetes в Azure. Как видно на рисунке 3-7, приложение можно также запустить в Azure Dev Spaces.

Если вы не добавляете поддержку DOCKER в приложение ASP.NET Core при его создании, всегда можно добавить его позже. В обозреватель решений Visual Studio щелкните проект правой кнопкой мыши и выберите **добавить** > **Поддержка DOCKER**, как показано на рис. 3-8.

![Поддержка добавления DOCKER в Visual Studio](./media/visual-studio-add-docker-support.png)

**Рис. 3-8**. Поддержка добавления DOCKER в Visual Studio

Помимо поддержки DOCKER, также можно добавить поддержку оркестрации контейнеров, также показанную на рисунке 3-8. По умолчанию Orchestrator использует Kubernetes и Helm. После выбора Orchestrator в корневой каталог проекта добавляется `azds.yaml` файл, и добавляется папка `charts`, содержащая диаграммы Helm, используемые для настройки и развертывания приложения в Kubernetes. На рис. 3-9 показаны итоговые файлы в новом проекте.

![Добавление поддержки Orchestrator в Visual Studio](./media/visual-studio-add-orchestrator-support.png)

**Рис. 3-9**. Добавление поддержки Orchestrator в Visual Studio

## <a name="references"></a>Ссылки

- [Что такое Kubernetes?](https://blog.newrelic.com/engineering/what-is-kubernetes/)
- [Установка Kubernetes с помощью Minikube](https://kubernetes.io/docs/setup/learning-environment/minikube/)
- [MiniKube VS DOCKER Desktop](https://medium.com/containers-101/local-kubernetes-for-windows-minikube-vs-docker-desktop-25a1c6d3b766)
- [Инструменты Visual Studio для Docker](https://docs.microsoft.com/dotnet/standard/containerized-lifecycle-architecture/design-develop-containerized-apps/visual-studio-tools-for-docker)

>[!div class="step-by-step"]
>[Назад](scale-applications.md)
>[Вперед](leverage-serverless-functions.md)
