---
title: Использование контейнеров и оркестраторов
description: Использование контейнеров Docker и оркестрантов Kubernetes в Azure
ms.date: 06/30/2019
ms.openlocfilehash: 44b2fff8c9c88717d83e41a421b9817e2cc68135
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2020
ms.locfileid: "80989042"
---
# <a name="leveraging-containers-and-orchestrators"></a>Использование контейнеров и оркестраторов

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

Контейнеры и оркестранты предназначены для решения проблем, характерных для монолитных подходов развертывания.

## <a name="challenges-with-monolithic-deployments"></a>Проблемы с монолитным развертыванием

Традиционно большинство приложений были развернуты в виде единого устройства. Такие приложения называются монолитом. Этот общий подход к развертыванию приложений в единичные единицы, даже если они состоят из нескольких модулей или сборок, известен как монолитная архитектура, как показано на рисунке 3-1.

![Монолитная архитектура.](./media/monolithic-architecture.png)

**Рисунок 3-1**. Монолитная архитектура.

Хотя они имеют преимущество простоты, монолитные архитектуры сталкиваются с рядом проблем:

### <a name="deployments"></a>Развернутые приложения

Развертывание в монолитных приложениях обычно требует перезапуска всего приложения, даже если заменяется только один небольшой модуль. В зависимости от количества машин, размещающих приложение, это может привести к простою во время развертывания.

### <a name="hosting"></a>Hosting

Монолитные приложения размещаются полностью на одном экземпляре машины. Для этого может потребоваться оборудование с более высокой производительности, чем потребуется любому модулю в распределенном приложении. Кроме того, если какая-либо часть приложения становится узким местом, все приложение должно быть развернуто в дополнительные узлы машины для масштабирования.

### <a name="environment"></a>Среда

Монолитные приложения обычно развертываются в существующую среду хостинга (операционная система, установленные фреймворки и т.д.). Эта среда может не соответствовать среде, в которой приложение было разработано или протестировано. Несоответствия в среде приложения являются общим источником проблем для монолитных развертываний.

### <a name="coupling"></a>Муфта

Монолитные приложения, вероятно, будут иметь большое сочетание между различными частями приложения, а также между приложением и его средой. Это может затруднить более позднюю инпланисти конкретной услуги или проблемы, с тем чтобы повысить ее масштабируемость или своп в альтернативной реализации. Это соединение также приводит к гораздо большим потенциальным последствиям для изменений в системе, требующих тщательного тестирования в больших приложениях.

### <a name="technology-choice"></a>Выбор технологий

Монолитные приложения строятся и развертываются как единое целое. Это обеспечивает простоту и единообразие, но может быть препятствием для инноваций. Хотя новая функция или модуль в системе может быть лучше подходит для более современной платформы или платформы, она, вероятно, будет построена с использованием текущего подхода приложения ради согласованности, а также простоты разработки и развертывания.

## <a name="what-are-the-benefits-of-containers-and-orchestrators"></a>Каковы преимущества контейнеров и оркестрантов?

Docker является самой популярной платформой управления контейнерами и визуализации и позволяет быстро работать с контейнерами на Linux и Windows. Контейнеры обеспечивают отдельные, но воспроизводимые среды применения, которые работают одинаково в любой системе. Это делает их идеальными для разработки и хостинга приложений и компонентов приложений в облачных приложениях. Контейнеры изолированы друг от друга, поэтому два контейнера на одном и том же аппаратуру могут иметь различные версии программного обеспечения и даже установленную операционную систему, без зависимостей, вызывающих конфликты.

Более того, контейнеры определяются простыми файлами, которые могут быть проверены в исходном управлении. В отличие от полных серверов, даже виртуальных машин, которые часто требуют ручной работы для применения обновлений или установки дополнительных услуг, контейнерная инфраструктура может быть легко под контролем версии. Таким образом, приложения, созданные для работы в контейнерах, могут быть разработаны, протестированы и развернуты с помощью автоматизированных инструментов в рамках конвейера сборки.

Контейнеры неизменяемы. Если у вас есть определение контейнера, вы можете воссоздать этот контейнер, и он будет работать точно так же. Эта неизменяемость поддается дизайну на основе компонентов. Если некоторые части приложения меняются не так часто, как другие, зачем перераспределять все приложение, когда можно просто развернуть части, которые изменяются чаще всего? Различные функции и кросс-резка проблемы приложения могут быть разбиты на отдельные единицы. На рисунке 3-2 показано, как монолитное приложение может воспользоваться преимуществами контейнеров и микрослужб, делегируя определенные функции или функциональные возможности. Оставшаяся функциональность в самом приложении также была контейнеризирована.

![Разбивка монолитного приложения для использования микрослужб в задней части. ](./media/breaking-up-monolith-with-backend-microservices.png)
 **Рисунок 3-2**. Разбивка монолитного приложения для использования микрослужб в задней части.

Облачные приложения, созданные с использованием отдельных контейнеров, выигрывают от возможности развертывания столько или меньше приложения по мере необходимости. Индивидуальные службы могут размещаться на узлах с ресурсами, подходящими для каждой службы. Среда, в которой работает каждая служба, неизменяема, может быть разделена между разработчиком, тестом и производством и может быть легко версия. Соединение между различными областями приложения происходит явно как звонки или сообщения между службами, а не компиляция времени зависимостей в монолите. И любая часть общего приложения может выбрать технологию, которая имеет наибольший смысл для этой функции или возможности, не требуя изменений в остальной части приложения.

## <a name="what-are-the-scaling-benefits"></a>Каковы преимущества масштабирования?

Услуги, построенные на контейнерах, могут использовать преимущества масштабирования, предоставляемые инструментами оркестровки, такими как Kubernetes. По дизайну контейнеры знают только о себе. Как только вы начинаете иметь несколько контейнеров, которые должны работать вместе, это может быть целесообразно организовать их на более высоком уровне. Организация большого количества контейнеров и их общих зависимостей, таких как конфигурация сети, является местом, где инструменты оркестровки приходят, чтобы спасти день! Kubernetes — это платформа контейнерной оркестровки, предназначенная для автоматизации развертывания, масштабирования и управления контейнерными приложениями. Он создает слой абстракции поверх групп контейнеров и организует их в *стручки.* Стручки работают на рабочих машинах, называемых *узлами.* Вся организованная группа называется *кластером.* На рисунке 3-3 показаны различные компоненты кластера Кубернете.

![Компоненты кластера Kubernetes. ](./media/kubernetes-cluster-components.png)
 **Рисунок 3-3**. Компоненты кластера Kubernetes.

Kubernetes оказывает встроенную поддержку масштабированию кластеров для удовлетворения спроса. В сочетании с контейнерными микрослужбами это обеспечивает возможность облачных приложений быстро и эффективно реагировать на всплески спроса с помощью дополнительных ресурсов, когда и где они необходимы.

### <a name="declarative-versus-imperative"></a>Декларативное против императив

Kubernetes поддерживает как декларативную, так и императивную конфигурацию объектов. Императивный подход включает в себя запуск различных команд, которые говорят Kubernetes, что делать на каждом этапе пути. *Запустите* это изображение. *Удалите* этот стручок. *Разоблачить* этот порт. При декларативном подходе используется файл конфигурации, описывающий *то, что вы хотите,* а не *что делать,* и Kubernetes выясняет, что делать для достижения желаемого конечного состояния. Если вы уже настроили кластер с помощью императивных `kubectl get svc SERVICENAME -o yaml > service.yaml`команд, можно экспортировать декларативный манифест с помощью . Это позволит создать файл манифеста, как этот:

```yaml
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: "2019-09-13T13:58:47Z"
  labels:
    component: apiserver
    provider: kubernetes
  name: kubernetes
  namespace: default
  resourceVersion: "153"
  selfLink: /api/v1/namespaces/default/services/kubernetes
  uid: 9b1fac62-d62e-11e9-8968-00155d38010d
spec:
  clusterIP: 10.96.0.1
  ports:
  - name: https
    port: 443
    protocol: TCP
    targetPort: 6443
  sessionAffinity: None
  type: ClusterIP
status:
  loadBalancer: {}
```

При использовании декларативной конфигурации можно просмотреть изменения, `kubectl diff -f FOLDERNAME` которые будут внесены перед их совершением, используя против папки, где находятся файлы конфигурации. Как только вы уверены, что хотите `kubectl apply -f FOLDERNAME`применить изменения, запустите. Добавьте `-R` к рекурсивному процессу иерархию папок.

В дополнение к службам можно использовать декларативную конфигурацию для других функций Kubernetes, таких как *развертывания.* Декларативные развертывания используются контроллерами развертывания для обновления кластерных ресурсов. Развертывания используются для развертывания новых изменений, масштабирования для поддержки большей нагрузки или отката к предыдущему пересмотру. Если кластер нестабилен, декларативные развертывания обеспечивают механизм автоматического возвращения кластера в нужное состояние.

Использование декларативной конфигурации позволяет представлять инфраструктуру в качестве кода, который может быть зарегистрирован и версияна вместе с кодом приложения. Это обеспечивает улучшенный контроль изменений и лучшую поддержку непрерывного развертывания с помощью сборки и развертывания конвейера, привязанного к изменениям управления исходными данными.

## <a name="what-scenarios-are-ideal-for-containers-and-orchestrators"></a>Какие сценарии идеально подходят для контейнеров и оркестрантов?

Следующие сценарии идеально подходят для использования контейнеров и оркестрантов.

### <a name="applications-requiring-high-uptime-and-scalability"></a>Приложения, требующие высокого времени простоя и масштабируемости

Отдельные приложения с высокими требованиями к простоям и масштабируемости являются идеальными кандидатами для облачных архитектур с использованием микрослужб, контейнеров и оркестрантов. Эти приложения могут быть разработаны в контейнерах с использованием версий сред, могут быть тщательно протестированы перед началом производства, и могут быть развернуты в производство с нулевым временем простоя. Использование кластеров Kubernetes гарантирует, что такие приложения могут также масштабироваться по требованию и автоматически восстанавливаться после сбоев узлов.

### <a name="large-numbers-of-applications"></a>Большое количество приложений

Организации, которые развертывают и должны впоследствии поддерживать большое количество приложений, пользуются контейнерами и оркестрантами. Предостережающее усилие создания контейнерных сред и кластеров Kubernetes является в первую очередь фиксированной стоимостью. Развертывание, обслуживание и обновление отдельных приложений имеет стоимость, которая зависит от количества приложений, которые необходимо поддерживать. Помимо довольно небольшого количества приложений, сложность обслуживания пользовательских приложений вручную превышает затраты на реализацию решения с использованием контейнеров и оркестрантов.

## <a name="when-should-you-avoid-using-containers-and-orchestrators"></a>Когда следует избегать использования контейнеров и оркестрантов?

Если вы не желаете или не можете создать свое приложение в соответствии с принципами Twelve-Factor App, вам, вероятно, будет лучше избегать контейнеров и оркестрантов. В этих случаях, возможно, лучше двигаться вперед с VM-платформы хостинга, или, возможно, некоторые гибридные системы, в которых вы можете спина от определенных частей функциональности в отдельные контейнеры или даже без серверов функций.

## <a name="development-resources"></a>Ресурсы развития

В этом разделе показан краткий список ресурсов разработки, которые могут помочь вам начать использовать контейнеры и оркестранты для следующего приложения. Если вы ищете рекомендации о том, как создать приложение для архитектуры микрослужб на основе облачных услуг, прочитайте спутник этой [книги, .NET Microservices: Architecture for Containerized .NET Applications.](https://aka.ms/microservicesebook)

### <a name="local-kubernetes-development"></a>Местное развитие Кубернете

Развертывание Kubernetes обеспечивает большую ценность в производственных средах, но вы также можете запустить их локально. Хотя большую часть времени это хорошо, чтобы иметь возможность работать на отдельных приложений или микрослужб независимо, иногда это хорошо, чтобы иметь возможность запустить всю систему локально так же, как он будет работать при развертывании в производство. Есть несколько способов для достижения этой цели, два из которых Minikube и Docker Desktop. Visual Studio также предоставляет инструменты для разработки Docker.

### <a name="minikube"></a>Minikube

Что такое Миникубе? В проекте Minikube говорится: «Миникубе реализует локальный кластер Kubernetes на macOS, Linux и Windows». Его основные цели – «быть лучшим инструментом для разработки местных приложений Kubernetes и поддерживать все функции Kubernetes, которые подходят». Установка Minikube отделена от Docker, но Minikube поддерживает различные гипервизоры, чем поддерживает Docker Desktop. Следующие функции Kubernetes в настоящее время поддерживаются Minikube:

- DNS
- Узловые порты
- ConfigMaps и секреты
- Панели мониторинга
- Контейнерные время выполнения: Докер, ркт, CRI-O и контейнерные
- Включение интерфейса контейнерной сети (CNI)
- Входящий трафик

После установки Minikube вы можете быстро начать `minikube start` использовать его, запустив команду, которая загружает изображение и начинает локальное кластер Kubernetes. После запуска кластера с ним взаимодействуют, используя `kubectl` стандартные команды Kubernetes.

### <a name="docker-desktop"></a>Docker Desktop

Вы также можете работать с Kubernetes непосредственно с Docker Desktop на Windows. Это единственный вариант, если вы используете Windows Контейнеры, и является отличным выбором для не-Windows контейнеров, а также. Стандартное приложение конфигурации Docker Desktop используется для настройки Kubernetes, работая с Docker Desktop.

![Настройка Kubernetes в Docker Desktop](./media/docker-desktop-kubernetes.png)

**Рисунок 3-4**. Настройка Kubernetes в Docker Desktop.

Docker Desktop уже является самым популярным инструментом для настройки и локального запуска контейнеризированных приложений. Работая с Docker Desktop, вы можете разрабатывать локально против того же набора изображений контейнеров Docker, которые вы развернете в производстве. Docker Desktop предназначен для локального создания, тестирования и отправки контейнерных приложений. После отправки изображений в реестр изображений, таких как реестр контейнеров Azure или Docker Hub, сервисы, такие как Azure Kubernetes Service (AKS), управляют приложением в производственном секторе.

### <a name="visual-studio-docker-tooling"></a>Визуальная студия Докер Инструментирование

Visual Studio поддерживает разработку Docker для веб-приложений. При создании нового приложения ASP.NET Core вам предоставляется возможность настроить его с поддержкой Docker в рамках процесса создания проекта, как показано на рисунке 3-5.

![Визуальная студия Включить Докер поддержки](./media/visual-studio-enable-docker-support.png)

**Рисунок 3-5**. Визуальная студия Включить Докер поддержки

При выборе этой опции проект создается с корнем, `Dockerfile` который может быть использован для создания и размещения приложения в контейнере Docker. Пример Dockerfile показан на рисунке 3-6.

```docker
FROM mcr.microsoft.com/dotnet/core/aspnet:3.0-stretch-slim AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/core/sdk:3.0-stretch AS build
WORKDIR /src
COPY ["WebApplication3/WebApplication3.csproj", "WebApplication3/"]
RUN dotnet restore "WebApplication3/WebApplication3.csproj"
COPY . .
WORKDIR "/src/WebApplication3"
RUN dotnet build "WebApplication3.csproj" -c Release -o /app

FROM build AS publish
RUN dotnet publish "WebApplication3.csproj" -c Release -o /app

FROM base AS final
WORKDIR /app
COPY --from=publish /app .
ENTRYPOINT ["dotnet", "WebApplication3.dll"]
```

**Рисунок 3-6**. Визуальная студия генерируется Dockerfile

Поведение по умолчанию при запуске приложения настроено на использование Docker. На рисунке 3-7 показаны различные варианты выполнения, доступные в новом проекте ASP.NET Core, созданном при добавленной поддержке Docker.

![Визуальная студия Докер Выполнить Варианты](./media/visual-studio-docker-run-options.png)

**Рисунок 3-7**. Визуальная студия Докер Выполнить Варианты

Помимо локальной разработки, [Azure Dev Spaces](https://docs.microsoft.com/azure/dev-spaces/) предоставляет нескольким разработчикам удобный способ работы с собственными конфигурациями Kubernetes в Azure. Как вы можете видеть на рисунке 3-7, вы также можете запустить приложение в пространствах Azure Dev.

Если при его создании поддержка Docker не добавляется в приложение ASP.NET Core, вы всегда можете добавить его позже. С Visual Studio Solution Explorer, нажмите право на проект и выберите **Добавить** > **Docker поддержки**, как показано на рисунке 3-8.

![Визуальная студия Добавить Докер поддержка](./media/visual-studio-add-docker-support.png)

**Рисунок 3-8**. Визуальная студия Добавить Докер поддержка

В дополнение к поддержке Docker, вы также можете добавить поддержку оркестровки контейнеров, также показанную на рисунке 3-8. По умолчанию оркестрант использует Kubernetes и Helm. После того, как вы выбрали `azds.yaml` оркестратора, файл добавляется `charts` в корень проекта и папка добавляется, содержащий диаграммы helm, используемые для настройки и развертывания приложения в Kubernetes. На рисунке 3-9 показаны полученные файлы в новом проекте.

![Визуальная студия Добавить оркестраторподдержки](./media/visual-studio-add-orchestrator-support.png)

**Рисунок 3-9**. Визуальная студия Добавить оркестраторподдержки

## <a name="references"></a>Ссылки

- [Что такое Kubernetes?](https://blog.newrelic.com/engineering/what-is-kubernetes/)
- [Установка Kubernetes с Minikube](https://kubernetes.io/docs/setup/learning-environment/minikube/)
- [МиниКубе - Докер Настольный стол](https://medium.com/containers-101/local-kubernetes-for-windows-minikube-vs-docker-desktop-25a1c6d3b766)
- [Инструменты Visual Studio для Docker](https://docs.microsoft.com/dotnet/standard/containerized-lifecycle-architecture/design-develop-containerized-apps/visual-studio-tools-for-docker)

>[!div class="step-by-step"]
>[Назад](scale-applications.md)
>[Вперед](leverage-serverless-functions.md)
