---
title: gRPC
description: Узнайте о gRPC, его роли в облачных приложениях и о том, чем он отличается от http RESTful.
author: robvet
ms.date: 03/31/2020
ms.openlocfilehash: 28a07ad5ec105d3fc5b65e4cf0ac0cd85eb16627
ms.sourcegitcommit: 79b0dd8bfc63f33a02137121dd23475887ecefda
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/01/2020
ms.locfileid: "80524211"
---
# <a name="grpc"></a><span data-ttu-id="b3d1b-103">gRPC</span><span class="sxs-lookup"><span data-stu-id="b3d1b-103">gRPC</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="b3d1b-104">До сих пор в этой книге, мы сосредоточены на [REST основе](https://docs.microsoft.com/azure/architecture/best-practices/api-design) связи.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-104">So far in this book, we've focused on [REST-based](https://docs.microsoft.com/azure/architecture/best-practices/api-design) communication.</span></span> <span data-ttu-id="b3d1b-105">Мы видели, что REST является гибким архитектурным стилем, который определяет операции на основе CRUD в отношении ресурсов сущности.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-105">We've seen that REST is a flexible architectural style that defines CRUD-based operations against entity resources.</span></span> <span data-ttu-id="b3d1b-106">Клиенты взаимодействуют с ресурсами по http с помощью модели связи запроса/ответа.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-106">Clients interact with resources across HTTP with a request/response communication model.</span></span> <span data-ttu-id="b3d1b-107">В то время как REST широко внедряется, более новая коммуникационная технология, gRPC, получила огромный импульс в облачном сообществе.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-107">While REST is widely implemented, a newer communication technology, gRPC, has gained tremendous momentum across the cloud-native community.</span></span>

## <a name="what-is-grpc"></a><span data-ttu-id="b3d1b-108">Что такое gRPC?</span><span class="sxs-lookup"><span data-stu-id="b3d1b-108">What is gRPC?</span></span>

<span data-ttu-id="b3d1b-109">gRPC - это современная высокопроизводительная структура, которая развивает вековой протокол [удаленного вызова процедуры (RPC).](https://en.wikipedia.org/wiki/Remote_procedure_call)</span><span class="sxs-lookup"><span data-stu-id="b3d1b-109">gRPC is a modern, high-performance framework that evolves the age-old [remote procedure call (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call) protocol.</span></span> <span data-ttu-id="b3d1b-110">На уровне приложений gRPC упрощает обмен сообщениями между клиентами и бэк-энд-сервисами.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-110">At the application level, gRPC streamlines messaging between clients and back-end services.</span></span> <span data-ttu-id="b3d1b-111">Происходит от Google, gRPC является открытым исходным кодом и частью [Облачных Родные вычислительные фонд (CNCF)](https://www.cncf.io/) экосистемы облачных предложений.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-111">Originating from Google, gRPC is open source and part of the  [Cloud Native Computing Foundation (CNCF)](https://www.cncf.io/) ecosystem of cloud-native offerings.</span></span> <span data-ttu-id="b3d1b-112">CNCF считает gRPC [инкубационным проектом.](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc)</span><span class="sxs-lookup"><span data-stu-id="b3d1b-112">CNCF considers gRPC an [incubating project](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc).</span></span> <span data-ttu-id="b3d1b-113">Инкубация означает, что конечные пользователи используют технологию в производственных приложениях, и проект имеет здоровое количество участников.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-113">Incubating means end users are using the technology in production applications, and the project has a healthy number of contributors.</span></span>

<span data-ttu-id="b3d1b-114">Типичное клиентское приложение gRPC будет подвергать локальной функции в процессе, которая реализует бизнес-операцию.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-114">A typical gRPC client app will expose a local, in-process function that implements a business operation.</span></span> <span data-ttu-id="b3d1b-115">Под крышками эта локальная функция вызывает другую функцию на удаленном компьютере.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-115">Under the covers, that local function invokes another function on a remote machine.</span></span> <span data-ttu-id="b3d1b-116">То, что кажется локальным вызовом, по существу становится прозрачным внепроцессным вызовом в удаленный сервис.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-116">What appears to be a local call essentially becomes a transparent out-of-process call to a remote service.</span></span> <span data-ttu-id="b3d1b-117">RPC сантехника абстрагирует точечную сетевую связь, сериализацию и выполнение между компьютерами.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-117">The RPC plumbing abstracts the point-to-point networking communication, serialization, and execution between computers.</span></span>

<span data-ttu-id="b3d1b-118">В облачных приложениях разработчики часто работают в разных языках программирования, инфраструктурах и технологиях.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-118">In cloud-native applications, developers often work across programming languages, frameworks, and technologies.</span></span> <span data-ttu-id="b3d1b-119">Такая *совместимость* усложняет контракты на сообщения и сантехнику, необходимую для кросс-платформенного общения.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-119">This *interoperability* complicates message contracts and the plumbing required for cross-platform communication.</span></span>  <span data-ttu-id="b3d1b-120">gRPC обеспечивает "единый горизонтальный слой", который абстрагирует эти проблемы.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-120">gRPC provides a "uniform horizontal layer" that abstracts these concerns.</span></span> <span data-ttu-id="b3d1b-121">Разработчики код в их родной платформе сосредоточены на бизнес-функциональности, в то время как gRPC обрабатывает коммуникационной сантехники.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-121">Developers code in their native platform focused on business functionality, while gRPC handles communication plumbing.</span></span>

<span data-ttu-id="b3d1b-122">gRPC предлагает всестороннюю поддержку в наиболее популярных стеках разработки, включая Java, JavaScript, C, Go, Swift и NodeJS.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-122">gRPC offers comprehensive support across most popular development stacks, including Java, JavaScript, C#, Go, Swift, and NodeJS.</span></span>

## <a name="grpc-benefits"></a><span data-ttu-id="b3d1b-123">преимущества gRPC</span><span class="sxs-lookup"><span data-stu-id="b3d1b-123">gRPC Benefits</span></span>

<span data-ttu-id="b3d1b-124">gRPC использует HTTP/2 для своего транспортного протокола.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-124">gRPC uses HTTP/2 for its transport protocol.</span></span> <span data-ttu-id="b3d1b-125">В то время как совместимый с HTTP 1.1, HTTP/2 имеет много расширенных возможностей:</span><span class="sxs-lookup"><span data-stu-id="b3d1b-125">While compatible with HTTP 1.1, HTTP/2 features many advanced capabilities:</span></span>

- <span data-ttu-id="b3d1b-126">Двоичный протокол для передачи данных - в отличие от HTTP 1.1, который отправляет данные как четкий текст.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-126">A binary protocol for data transport - unlike HTTP 1.1, which sends data as clear text.</span></span>
- <span data-ttu-id="b3d1b-127">Поддержка мультиплексирования для отправки нескольких параллельных запросов по одному и тому же подключению - HTTP 1.1 ограничивает обработку одного запроса/ответа одновременно.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-127">Multiplexing support for sending multiple parallel requests over the same connection - HTTP 1.1 limits processing to one request/response message at a time.</span></span>
- <span data-ttu-id="b3d1b-128">Двунаправленная полнодуплексная связь для одновременной отправки запросов клиентов и ответов на серверы.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-128">Bidirectional full-duplex communication for sending both client requests and server responses simultaneously.</span></span>
- <span data-ttu-id="b3d1b-129">Встроенная потоковая передача позволяет запросы и ответы на асинхронную потоковую передачу больших наборов данных.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-129">Built-in streaming enabling requests and responses to asynchronously stream large data sets.</span></span>

<span data-ttu-id="b3d1b-130">gRPC является легким и высокоэффективным.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-130">gRPC is lightweight and highly performant.</span></span> <span data-ttu-id="b3d1b-131">Это может быть до 8раз быстрее, чем JSON сериализации с сообщениями 60-80% меньше.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-131">It can be up to 8x faster than JSON serialization with messages 60-80% smaller.</span></span> <span data-ttu-id="b3d1b-132">На языке Microsoft [Windows Communication Foundation (WCF)](https://docs.microsoft.com/dotnet/framework/wcf/whats-wcf) производительность gRPC превышает скорость и эффективность высокооптимизированных [привязок NetTCP.](https://docs.microsoft.com/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8)</span><span class="sxs-lookup"><span data-stu-id="b3d1b-132">In Microsoft [Windows Communication Foundation (WCF)](https://docs.microsoft.com/dotnet/framework/wcf/whats-wcf) parlance, gRPC performance exceeds the speed and efficiency of the highly optimized [NetTCP bindings](https://docs.microsoft.com/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8).</span></span> <span data-ttu-id="b3d1b-133">В отличие от NetTCP, которая выступает за стек Microsoft, gRPC является кросс-платформенным.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-133">Unlike NetTCP, which favors the Microsoft stack, gRPC is cross-platform.</span></span>

## <a name="protocol-buffers"></a><span data-ttu-id="b3d1b-134">Protocol Buffers</span><span class="sxs-lookup"><span data-stu-id="b3d1b-134">Protocol Buffers</span></span>

<span data-ttu-id="b3d1b-135">gRPC использует технологию с открытым исходным кодом под названием [Протокол буферов](https://developers.google.com/protocol-buffers/docs/overview).</span><span class="sxs-lookup"><span data-stu-id="b3d1b-135">gRPC embraces an open-source technology called [Protocol Buffers](https://developers.google.com/protocol-buffers/docs/overview).</span></span> <span data-ttu-id="b3d1b-136">Они обеспечивают высокоэффективный и нейтральный на платформе формат сериализации для сериализации структурированных сообщений, которые службы отправляют друг другу.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-136">They provide a highly efficient and platform-neutral serialization format for serializing structured messages that services send to each other.</span></span> <span data-ttu-id="b3d1b-137">Используя кросс-платформенный язык определения интерфейса (IDL), разработчики определяют контракт на обслуживание для каждой микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-137">Using a cross-platform Interface Definition Language (IDL), developers define a service contract for each microservice.</span></span> <span data-ttu-id="b3d1b-138">Контракт, реализованный как текстовый `.proto` файл, описывает методы, входы и выходы для каждой службы.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-138">The contract, implemented as a text-based `.proto` file, describes the methods, inputs, and outputs for each service.</span></span> <span data-ttu-id="b3d1b-139">Один и тот же файл контракта может быть использован для клиентов gRPC и услуг, построенных на различных платформах разработки.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-139">The same contract file can be used for gRPC clients and services built on different development platforms.</span></span>

<span data-ttu-id="b3d1b-140">Используя файл прото, компилятор Protobuf, `protoc`генерирует как клиент, так и код обслуживания для вашей целевой платформы.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-140">Using the proto file, the Protobuf compiler, `protoc`, generates both client and service code for your target platform.</span></span> <span data-ttu-id="b3d1b-141">Код включает в себя следующие компоненты:</span><span class="sxs-lookup"><span data-stu-id="b3d1b-141">The code includes the following components:</span></span>

- <span data-ttu-id="b3d1b-142">Сильно набранные объекты, совместно используемые клиентом и службой, представляющие элементы службы и элементы данных для сообщения.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-142">Strongly-typed objects, shared by the client and service, that represent the service operations and data elements for a message.</span></span>
- <span data-ttu-id="b3d1b-143">Сильно типированный базовый класс с необходимой сетевой сантехникой, которую может наследовать и расширять дистанционная служба gRPC.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-143">A strongly-typed base class with the required network plumbing that the remote gRPC service can inherit and extend.</span></span>
- <span data-ttu-id="b3d1b-144">Клиент заглушка, которая содержит необходимые сантехника для вызывания удаленной службы gRPC.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-144">A client stub that contains the required plumbing to invoke the remote gRPC service.</span></span>

<span data-ttu-id="b3d1b-145">Во время выполнения каждое сообщение сериализируется как стандартное представление Protobuf и обменивается между клиентом и удаленным сервисом.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-145">At runtime, each message is serialized as a standard Protobuf representation and exchanged between the client and remote service.</span></span> <span data-ttu-id="b3d1b-146">В отличие от JSON или XML, сообщения Protobuf сериализуются как компиляционные бинарные байты.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-146">Unlike JSON or XML, Protobuf messages are serialized as compiled binary bytes.</span></span>

<span data-ttu-id="b3d1b-147">Книга, [gRPC для разработчиков WCF](https://docs.microsoft.com/dotnet/architecture/grpc-for-wcf-developers/), доступна на сайте Microsoft Architecture, обеспечивает углубленное покрытие gRPC и протокола буферов.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-147">The book, [gRPC for WCF Developers](https://docs.microsoft.com/dotnet/architecture/grpc-for-wcf-developers/), available from the Microsoft Architecture site, provides in-depth coverage of gRPC and Protocol Buffers.</span></span>

## <a name="grpc-support-in-net"></a><span data-ttu-id="b3d1b-148">поддержка gRPC в .NET</span><span class="sxs-lookup"><span data-stu-id="b3d1b-148">gRPC support in .NET</span></span>

<span data-ttu-id="b3d1b-149">gRPC интегрирован в .NET Core 3.0 SDK или позже.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-149">gRPC is integrated into .NET Core 3.0 SDK or later.</span></span> <span data-ttu-id="b3d1b-150">Его поддерживают следующие инструменты:</span><span class="sxs-lookup"><span data-stu-id="b3d1b-150">The following tools support it:</span></span>

- <span data-ttu-id="b3d1b-151">Visual Studio 2019, версия 16.3 или более поздняя, с установленной рабочей нагрузкой веб-разработки.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-151">Visual Studio 2019, version 16.3 or later, with the web development workload installed.</span></span>
- <span data-ttu-id="b3d1b-152">Visual Studio Code</span><span class="sxs-lookup"><span data-stu-id="b3d1b-152">Visual Studio Code</span></span>
- <span data-ttu-id="b3d1b-153">дотнет CLI</span><span class="sxs-lookup"><span data-stu-id="b3d1b-153">the dotnet CLI</span></span>

<span data-ttu-id="b3d1b-154">SDK включает в себя инструментарий для конечных точек, встроенный IoC и журналирование.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-154">The SDK includes tooling for endpoint routing, built-in IoC, and logging.</span></span> <span data-ttu-id="b3d1b-155">Веб-сервер Kestrel с открытым исходным кодом поддерживает соединения HTTP/2.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-155">The open-source Kestrel web server supports HTTP/2 connections.</span></span> <span data-ttu-id="b3d1b-156">На рисунке 4-20 показан шаблон Visual Studio 2019, который создает скелетный проект для сервиса gRPC.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-156">Figure 4-20 shows a Visual Studio 2019 template that scaffolds a skeleton project for a gRPC service.</span></span> <span data-ttu-id="b3d1b-157">Обратите внимание, что .NET Core полностью поддерживает Windows, Linux и macOS.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-157">Note how .NET Core fully supports Windows, Linux, and macOS.</span></span>

![поддержка gRPC в визуальной студии 2019](./media/visual-studio-2019-grpc-template.png)

<span data-ttu-id="b3d1b-159">**Рис. 4-20**.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-159">**Figure 4-20**.</span></span> <span data-ttu-id="b3d1b-160">поддержка gRPC в Visual Studio 2019</span><span class="sxs-lookup"><span data-stu-id="b3d1b-160">gRPC support in Visual Studio 2019</span></span>
  
<span data-ttu-id="b3d1b-161">На рисунке 4-21 показана услуга скелета gRPC, созданная из встроенных строительных лесов, включенных в Visual Studio 2019.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-161">Figure 4-21 shows the skeleton gRPC service generated from the built-in scaffolding included in Visual Studio 2019.</span></span>  

![проект gRPC в Visual Studio 2019](./media/grpc-project.png  )

<span data-ttu-id="b3d1b-163">**Рис. 4-21**.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-163">**Figure 4-21**.</span></span> <span data-ttu-id="b3d1b-164">проект gRPC в Visual Studio 2019</span><span class="sxs-lookup"><span data-stu-id="b3d1b-164">gRPC project in Visual Studio 2019</span></span>

<span data-ttu-id="b3d1b-165">На предыдущем рисунке обратите внимание на файл прото описания и код службы.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-165">In the previous figure, note the proto description file and service code.</span></span> <span data-ttu-id="b3d1b-166">Как вы увидите в ближайшее время, Visual Studio генерирует дополнительную конфигурацию как в классе Startup, так и в базовом файле проекта.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-166">As you'll see shortly, Visual Studio generates additional configuration in both the Startup class and underlying project file.</span></span>

## <a name="grpc-usage"></a><span data-ttu-id="b3d1b-167">использование gRPC</span><span class="sxs-lookup"><span data-stu-id="b3d1b-167">gRPC usage</span></span>

<span data-ttu-id="b3d1b-168">Благоприятный gRPC для следующих сценариев:</span><span class="sxs-lookup"><span data-stu-id="b3d1b-168">Favor gRPC for the following scenarios:</span></span>

- <span data-ttu-id="b3d1b-169">Синхронная бэкэндная связь между микрослужбами и микрослужбами, в которой требуется немедленный ответ для продолжения обработки.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-169">Synchronous backend microservice-to-microservice communication where an immediate response is required to continue processing.</span></span>
- <span data-ttu-id="b3d1b-170">Среды Polyglot, которые должны поддерживать смешанные платформы программирования.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-170">Polyglot environments that need to support mixed programming platforms.</span></span>
- <span data-ttu-id="b3d1b-171">Низкая задержка и высокая пропускная способность связи, где производительность имеет решающее значение.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-171">Low latency and high throughput communication where performance is critical.</span></span>
- <span data-ttu-id="b3d1b-172">От точки к точке в режиме реального времени связи - gRPC может толкать сообщения в режиме реального времени без опроса и имеет отличную поддержку для двухнаправления потоковой передачи.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-172">Point-to-point real-time communication - gRPC can push messages in real time without polling and has excellent support for bi-directional streaming.</span></span>
- <span data-ttu-id="b3d1b-173">Сетевые ограниченные среды - двоичные gRPC-сообщения всегда меньше, чем эквивалентное текстовое сообщение JSON.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-173">Network constrained environments – binary gRPC messages are always smaller than an equivalent text-based JSON message.</span></span>

<span data-ttu-id="b3d1b-174">В то время, в этой письменной форме, gRPC в первую очередь используется с бэкэнд-сервисов.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-174">At the time, of this writing, gRPC is primarily used with backend services.</span></span> <span data-ttu-id="b3d1b-175">Большинство современных браузеров не могут обеспечить уровень управления HTTP/2, необходимый для поддержки фронт-энда gRPC клиента.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-175">Most modern browsers can't provide the level of HTTP/2 control required to support a front-end gRPC client.</span></span> <span data-ttu-id="b3d1b-176">Тем не менее, есть [ранняя инициатива,](https://devblogs.microsoft.com/aspnet/grpc-web-experiment/) которая позволяет gRPC связи из браузерных приложений, построенных с JavaScript или Blazor WebAssembly технологий.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-176">That said, there's an [early initiative](https://devblogs.microsoft.com/aspnet/grpc-web-experiment/) that enables gRPC communication from browser-based apps built with JavaScript or Blazor WebAssembly technologies.</span></span> <span data-ttu-id="b3d1b-177">[gRPC-Web для .NET](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md) позволяет ASP.NET core gRPC приложение для поддержки функций gRPC в приложениях браузера:</span><span class="sxs-lookup"><span data-stu-id="b3d1b-177">The  [gRPC-Web for .NET](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md) enables an ASP.NET Core gRPC app to support gRPC features in browser apps:</span></span>

- <span data-ttu-id="b3d1b-178">Сильно набранные код-генерируемые клиенты</span><span class="sxs-lookup"><span data-stu-id="b3d1b-178">Strongly-typed code-generated clients</span></span>
- <span data-ttu-id="b3d1b-179">Компактные сообщения Protobuf</span><span class="sxs-lookup"><span data-stu-id="b3d1b-179">Compact Protobuf messages</span></span>
- <span data-ttu-id="b3d1b-180">Потоковая передача серверов</span><span class="sxs-lookup"><span data-stu-id="b3d1b-180">Server streaming</span></span>

## <a name="grpc-implementation"></a><span data-ttu-id="b3d1b-181">gRPC реализация</span><span class="sxs-lookup"><span data-stu-id="b3d1b-181">gRPC implementation</span></span>

<span data-ttu-id="b3d1b-182">Архитектура ссылки на микрослужбы, [eShop on Containers,](https://github.com/dotnet-architecture/eShopOnContainers)от корпорации Майкрософт, показывает, как реализовать услуги gRPC в приложениях .NET Core.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-182">The microservice reference architecture, [eShop on Containers](https://github.com/dotnet-architecture/eShopOnContainers), from Microsoft, shows how to implement gRPC services in .NET Core applications.</span></span> <span data-ttu-id="b3d1b-183">Рисунок 4-22 представляет архитектуру бэк-энда.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-183">Figure 4-22 presents the back-end architecture.</span></span>

![Архитектура бэкэнда для eShop на контейнерах](./media/eshop-with-aggregators.png)

<span data-ttu-id="b3d1b-185">**Рис. 4-22**.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-185">**Figure 4-22**.</span></span> <span data-ttu-id="b3d1b-186">Архитектура бэкэнда для eShop на контейнерах</span><span class="sxs-lookup"><span data-stu-id="b3d1b-186">Backend architecture for eShop on Containers</span></span>

<span data-ttu-id="b3d1b-187">На предыдущей цифре обратите внимание, как eShop охватывает [шаблон Backend for Frontends](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends) (BFF), подвергая несколько шлюзов API.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-187">In the previous figure, note how eShop embraces the [Backend for Frontends pattern](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends) (BFF) by exposing multiple API gateways.</span></span> <span data-ttu-id="b3d1b-188">Мы обсудили модель BFF ранее в этой главе.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-188">We discussed the BFF pattern earlier in this chapter.</span></span> <span data-ttu-id="b3d1b-189">Обратите пристальное внимание на микросервис агрегатора (в сером цвете), который находится между Web-Shopping API Gateway и бэкэнд омичем.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-189">Pay close attention to the Aggregator microservice (in gray) that sits between the Web-Shopping API Gateway and backend Shopping microservices.</span></span> <span data-ttu-id="b3d1b-190">Агрегатор получает один запрос от клиента, отправляет его в различные микрослужбы, агрегирует результаты и отправляет их обратно запрашивающему клиенту.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-190">The Aggregator receives a single request from a client, dispatches it to various microservices, aggregates the results, and sends them back to the requesting client.</span></span> <span data-ttu-id="b3d1b-191">Такие операции обычно требуют синхронной связи, чтобы дать немедленный ответ.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-191">Such operations typically require synchronous communication as to produce an immediate response.</span></span> <span data-ttu-id="b3d1b-192">В eShop бэкэнд-звонки от агрегатора выполняются с помощью gRPC, как показано на рисунке 4-23.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-192">In eShop, backend calls from the Aggregator are performed using gRPC as shown in Figure 4-23.</span></span>

![gRPC в интернет-магазине на контейнерах](./media/grpc-implementation.png)

<span data-ttu-id="b3d1b-194">**Рис. 4-23**.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-194">**Figure 4-23**.</span></span> <span data-ttu-id="b3d1b-195">gRPC в интернет-магазине на контейнерах</span><span class="sxs-lookup"><span data-stu-id="b3d1b-195">gRPC in eShop on Containers</span></span>

<span data-ttu-id="b3d1b-196">gRPC для связи требуется как клиентские, так и серверные компоненты.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-196">gRPC communication requires both client and server components.</span></span> <span data-ttu-id="b3d1b-197">В предыдущем рисунке обратите внимание, как торговый агрегатор реализует клиент gRPC.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-197">In the previous figure, note how the Shopping Aggregator implements a gRPC client.</span></span> <span data-ttu-id="b3d1b-198">Клиент делает синхронные вызовы gRPC (красным цветом) для бэкэнд-сервисов, каждый из которых реализует сервер gRPC.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-198">The client makes synchronous gRPC calls (in red) to backend microservices, each of which implement a gRPC server.</span></span> <span data-ttu-id="b3d1b-199">Как клиент, так и сервер пользуются встроенным gRPC сантехникой от .NET Core 3.0 SDK.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-199">Both the client and server take advantage of the built-in gRPC plumbing from the .NET Core 3.0 SDK.</span></span> <span data-ttu-id="b3d1b-200">Клиент-сторона *заглушки* обеспечивают сантехнику для вызова удаленных вызовов gRPC.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-200">Client-side *stubs* provide the plumbing to invoke remote gRPC calls.</span></span> <span data-ttu-id="b3d1b-201">Компоненты на стороне сервера обеспечивают сантехнику gRPC, которую пользовательские классы служб могут наследовать и потреблять.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-201">Server-side components provide gRPC plumbing that custom service classes can inherit and consume.</span></span>

<span data-ttu-id="b3d1b-202">Микрослужбы, которые разоблачают как RESTful API, так и gRPC-связь, требуют нескольких конечных точек для управления трафиком.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-202">Microservices that expose both a RESTful API and gRPC communication require multiple endpoints to manage traffic.</span></span> <span data-ttu-id="b3d1b-203">Вы бы открыть конечную точку, которая слушает для трафика HTTP для RESTful звонки, а другой для gRPC звонки.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-203">You would open an endpoint that listens for HTTP traffic for the RESTful calls and another for gRPC calls.</span></span> <span data-ttu-id="b3d1b-204">Конечная точка gRPC должна быть настроена для протокола HTTP/2, необходимого для связи gRPC.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-204">The gRPC endpoint must be configured for the HTTP/2 protocol that is required for gRPC communication.</span></span>

<span data-ttu-id="b3d1b-205">В то время как мы стремимся отделить микрослужбы с асинхронными коммуникационными шаблонами, некоторые операции требуют прямых вызовов.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-205">While we strive to decouple microservices with asynchronous communication patterns, some operations require direct calls.</span></span> <span data-ttu-id="b3d1b-206">gRPC должен быть основным выбором для прямой синхронной связи между микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-206">gRPC should be the primary choice for direct synchronous communication between microservices.</span></span> <span data-ttu-id="b3d1b-207">Его высокопроизводительный коммуникационный протокол, основанный на HTTP/2 и буферах протокола, делает его идеальным выбором.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-207">Its high-performance communication protocol, based on HTTP/2 and protocol buffers, make it a perfect choice.</span></span>

## <a name="looking-ahead"></a><span data-ttu-id="b3d1b-208">Заглядывая в будущее</span><span class="sxs-lookup"><span data-stu-id="b3d1b-208">Looking ahead</span></span>

<span data-ttu-id="b3d1b-209">Заглядывая в будущее, gRPC будет продолжать набирать обороты для облачных систем.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-209">Looking ahead, gRPC will continue to gain traction for cloud-native systems.</span></span> <span data-ttu-id="b3d1b-210">Преимущества производительности и простота развития являются убедительными.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-210">The performance benefits and ease of development are compelling.</span></span> <span data-ttu-id="b3d1b-211">Тем не менее, REST, вероятно, будет вокруг в течение длительного времени.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-211">However, REST will likely be around for a long time.</span></span> <span data-ttu-id="b3d1b-212">Он выделяется для публично выставленных AIS и по причинам обратной совместимости.</span><span class="sxs-lookup"><span data-stu-id="b3d1b-212">It excels for publicly exposed APIs and for backward compatibility reasons.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="b3d1b-213">[Предыдущий](service-to-service-communication.md)
>[Следующий](service-mesh-communication-infrastructure.md)</span><span class="sxs-lookup"><span data-stu-id="b3d1b-213">[Previous](service-to-service-communication.md)
[Next](service-mesh-communication-infrastructure.md)</span></span>
