---
title: gRPC
description: Узнайте о gRPC, ее роли в собственных приложениях в облаке и о том, как она отличается от обмена данными с RESTFUL по протоколу HTTP.
author: robvet
no-loc:
- Blazor
- Blazor WebAssembly
ms.date: 01/19/2021
ms.openlocfilehash: 8667f2d3a7a19aa6dffdd8ce8bef103eab5cc54f
ms.sourcegitcommit: f2ab02d9a780819ca2e5310bbcf5cfe5b7993041
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/03/2021
ms.locfileid: "99505704"
---
# <a name="grpc"></a>gRPC

До сих пор в этой книге мы сосредоточены на связи на [основе RESTful](/azure/architecture/best-practices/api-design) . Мы увидели, что остальное является гибким архитектурным стилем, который определяет операции на основе CRUD на ресурсах сущностей. Клиенты взаимодействуют с ресурсами по протоколу HTTP с помощью модели связи "запрос-ответ". Несмотря на широкое внедрение технологии RESTFUL, более новая технология связи, gRPC, получила огромный опыт работы сообщества в облаке.

## <a name="what-is-grpc"></a>Что такое gRPC?

gRPC — это современная высокопроизводительная платформа, которая используется для развития устаревшего протокола [удаленного вызова процедур (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call) . На уровне приложения gRPC упрощает обмен сообщениями между клиентами и серверными службами. Исходя из Google, gRPC является открытым исходным кодом и частью экосистемы  [облачных вычислений (кнкф)](https://www.cncf.io/) облачных собственных предложений. КНКФ считает gRPC [проект инкубация](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc). Инкубация означает, что конечные пользователи используют технологию в рабочих приложениях, а проект имеет работоспособное количество участников.

Типичное клиентское приложение gRPC будет предоставлять локальную, внутрипроцессный функцию, которая реализует бизнес-операцию. На самом деле локальная функция вызывает другую функцию на удаленном компьютере. То, что кажется локальным вызовом, по сути становится прозрачным необработанным вызовом к удаленной службе. Механизм RPC абстрагирует сетевую связь «точка-точка», сериализацию и выполнение между компьютерами.

В собственных облачных приложениях разработчики часто работают на языках программирования, платформах и технологиях. Такое *взаимодействие* усложняет контракты сообщений и коммуникации, необходимых для межплатформенного обмена данными.  gRPC предоставляет «равномерный горизонтальный слой», который абстрагирует эти проблемы. Разработчики в своей собственной платформе получают код для бизнес-функций, тогда как gRPC обрабатывает коммуникационные коммуникации.

gRPC предлагает комплексную поддержку для большинства популярных стеков разработки, включая Java, JavaScript, C#, Go, SWIFT и NodeJS.

## <a name="grpc-benefits"></a>Преимущества gRPC

gRPC использует HTTP/2 для транспортного протокола. Несмотря на то, что совместимость с HTTP 1,1, HTTP/2 включает в себя множество дополнительных возможностей:

- Протокол двоичной кадрирования для транспорта данных, в отличие от HTTP 1,1, который основан на тексте.
- Поддержка мультиплексирования для отправки нескольких параллельных запросов через одно подключение — HTTP 1,1 ограничивает обработку одного сообщения "запрос-ответ" за раз.
- Двунаправленный дуплексный обмен данными для одновременной отправки клиентских запросов и ответов сервера.
- Встроенная потоковая передача, позволяющая запросам и ответам асинхронного потока больших наборов данных.
- Сжатие заголовков, уменьшающее использование сети.

gRPC является упрощенной и очень производительной. Это может быть не более 8X, чем сериализация JSON с сообщениями 60-80% меньше. В Microsoft [Windows Communication Foundation (WCF)](../../framework/wcf/whats-wcf.md) терминах производительность gRPC превышает скорость и эффективность [привязок NetTcp](/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8)с высоким уровнем оптимизации. В отличие от NetTCP, которая предпочитает стек Майкрософт, gRPC является кросс-платформенным.

## <a name="protocol-buffers"></a>Protocol Buffers

gRPC использует технологию с открытым исходным кодом, называемую [буферами протоколов](https://developers.google.com/protocol-buffers/docs/overview). Они предоставляют очень эффективный и независимый от платформы формат сериализации для сериализации структурированных сообщений, которые службы отправляют друг другу. Используя язык IDL, разработчики определяют контракт службы для каждой микрослужбы. Контракт, реализованный в виде текстового `.proto` файла, описывает методы, входные и выходные данные для каждой службы. Один и тот же файл контракта можно использовать для клиентов и служб gRPC, созданных на разных платформах разработки.

Используя файл с таким же параметром, компилятор protobuf `protoc` создает как клиентский, так и код службы для целевой платформы. Код включает следующие компоненты:

- Строго типизированные объекты, совместно используемые клиентом и службой, которые представляют операции службы и элементы данных для сообщения.
- Строго типизированный базовый класс с необходимыми сетевыми механизмами, которые может наследовать и расширять служба удаленной gRPC.
- Клиентская заглушка, которая содержит необходимые коммуникации для вызова удаленной службы gRPC.

Во время выполнения каждое сообщение сериализуется как стандартное представление protobuf и обменивается между клиентом и удаленной службой. В отличие от JSON или XML, сообщения protobuf сериализуются как скомпилированные двоичные байты.

Книга, [gRPC для разработчиков WCF](../grpc-for-wcf-developers/index.md), доступная на сайте архитектуры Майкрософт, содержит подробное описание GRPC и буферов протоколов.

## <a name="grpc-support-in-net"></a>Поддержка gRPC в .NET

gRPC интегрирован в пакет SDK для .NET Core 3,0 и более поздней версии. Эти средства поддерживают следующие инструменты:

- Visual Studio 2019, версия 16,3 или более поздняя, с установленной рабочей нагрузкой веб-разработки.
- Visual Studio Code
- интерфейс командной строки DotNet

Пакет SDK включает инструментарий для маршрутизации конечных точек, встроенный IoC и ведение журнала. Веб-сервер Kestrel с открытым кодом поддерживает подключения HTTP/2. На рис. 4-20 показан шаблон Visual Studio 2019, который формирует скелет проекта для службы gRPC. Обратите внимание, что .NET полностью поддерживает Windows, Linux и macOS.

![Поддержка gRPC в Visual Studio 2019](./media/visual-studio-2019-grpc-template.png)

**Рис. 4-20**. Поддержка gRPC в Visual Studio 2019
  
На рис. 4-21 показана скелетная служба gRPC, созданная на основе встроенного механизма формирования шаблонов, входящего в Visual Studio 2019.  

![проект gRPC в Visual Studio 2019](./media/grpc-project.png  )

**Рис. 4-21**. проект gRPC в Visual Studio 2019

На предыдущем рисунке обратите внимание на файл описания и код службы. Как вы вскоре увидите, Visual Studio создаст дополнительную конфигурацию в классе Startup и базовом файле проекта.

## <a name="grpc-usage"></a>Использование gRPC

Предпочитать gRPC в следующих сценариях:

- Синхронное взаимодействие микрослужбы с микрослужбой, где требуется немедленное реагирование для продолжения обработки.
- Polyglot среды, которые должны поддерживать смешанные платформы программирования.
- Низкая задержка и скорость обмена данными с высокой пропускной способностью, когда важна производительность.
- Связь "точка-точка" в реальном времени может отправлять сообщения в режиме реального времени без опроса и имеет отличную поддержку двунаправленной потоковой передачи.
- Ограниченные среды сети — двоичные сообщения gRPC всегда меньше, чем эквивалентное текстовое сообщение JSON.

На момент написания этой статьи gRPC в основном используется с серверными службами. Современные браузеры не могут предоставить уровень управления HTTP/2, необходимый для поддержки клиентского gRPC клиента. С другой стороны, существует поддержка [gRPC-Web с .NET](https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/) , которая позволяет gRPC взаимодействие из приложений на основе браузера, созданных с помощью JavaScript или Blazor WebAssembly технологий. [gRPC-Web](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md) включает приложение ASP.NET Core gRPC для поддержки функций gRPC в приложениях браузера:

- Строго типизированные, генерируемые кодом клиенты
- Compact protobuf сообщения
- Потоковая передача сервера

## <a name="grpc-implementation"></a>Реализация gRPC

Эталонная архитектура микрослужб, [ешоп в контейнерах](https://github.com/dotnet-architecture/eShopOnContainers)от Майкрософт, демонстрирует, как реализовать службы gRPC в приложениях .NET. На рисунке 4-22 представлена серверная архитектура.

![Серверная архитектура для Ешоп в контейнерах](./media/eshop-with-aggregators.png)

**Рис. 4-22**. Серверная архитектура для Ешоп в контейнерах

На предыдущем рисунке обратите внимание, как Ешоп использует [серверную часть для шаблона интерфейсной части](/azure/architecture/patterns/backends-for-frontends) (БФФ), предоставляя несколько шлюзов API. Ранее в этой главе мы обсуждали шаблон БФФ. Обратите особое внимание на микрослужбу агрегатора (серым), расположенную между шлюзом API Web-Shopping и внутренними службами для покупок. Агрегатор получает один запрос от клиента, передает его в различные микрослужбы, объединяет результаты и отправляет их обратно запрашивающему клиенту. Таким операциям обычно требуется синхронное взаимодействие, чтобы получить немедленный ответ. В Ешоп внутренние вызовы из агрегатора выполняются с помощью gRPC, как показано на рис. 4-23.

![gRPC в Ешоп в контейнерах](./media/grpc-implementation.png)

**Рис. 4-23**. gRPC в Ешоп в контейнерах

для обмена данными gRPC требуются клиентские и серверные компоненты. На предыдущем рисунке обратите внимание на то, как агрегатор покупок реализует клиент gRPC. Клиент выполняет синхронные вызовы gRPC (красным) в серверные микрослужбы, каждый из которых реализует сервер gRPC. Как клиент, так и сервер используют преимущества встроенных gRPCных коммуникаций из пакета SDK для .NET. Клиентские *заглушки* предоставляют механизм для вызова удаленных вызовов gRPC. Серверные компоненты предоставляют gRPCные коммуникации, которые могут наследовать и использовать пользовательские классы служб.

Микрослужбы, которые предоставляют как API RESTFUL, так и gRPC обмен данными, нуждаются в нескольких конечных точках для управления трафиком. Вы откроете конечную точку, которая прослушивает HTTP-трафик для вызовов RESTFUL, а другой — для вызовов gRPC. Конечная точка gRPC должна быть настроена для протокола HTTP/2, необходимого для обмена данными gRPC.

Хотя мы стремимся разделять микрослужбы с помощью асинхронных шаблонов связи, некоторым операциям требуются прямые вызовы. gRPC должен быть основным выбором для прямого синхронного взаимодействия между микрослужбами. Его высокопроизводительный протокол связи, основанный на HTTP/2 и буферах протоколов, делает его идеальным выбором.

## <a name="looking-ahead"></a>Взгляд на будущее

Взглянув на gRPC, вы продолжите работать с собственными системами в облаке. Преимущества производительности и простота разработки очень привлекательны. Однако, скорее всего, в течение длительного времени все будет работать. Он предназначен для общедоступных API-интерфейсов и для обеспечения обратной совместимости.

>[!div class="step-by-step"]
>[Назад](service-to-service-communication.md)
>[Вперед](service-mesh-communication-infrastructure.md)
