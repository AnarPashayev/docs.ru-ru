---
title: gRPC
description: Узнайте о gRPC, его роли в облачных приложениях и о том, чем он отличается от http RESTful.
author: robvet
ms.date: 03/31/2020
ms.openlocfilehash: 28a07ad5ec105d3fc5b65e4cf0ac0cd85eb16627
ms.sourcegitcommit: 79b0dd8bfc63f33a02137121dd23475887ecefda
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/01/2020
ms.locfileid: "80524211"
---
# <a name="grpc"></a>gRPC

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

До сих пор в этой книге, мы сосредоточены на [REST основе](https://docs.microsoft.com/azure/architecture/best-practices/api-design) связи. Мы видели, что REST является гибким архитектурным стилем, который определяет операции на основе CRUD в отношении ресурсов сущности. Клиенты взаимодействуют с ресурсами по http с помощью модели связи запроса/ответа. В то время как REST широко внедряется, более новая коммуникационная технология, gRPC, получила огромный импульс в облачном сообществе.

## <a name="what-is-grpc"></a>Что такое gRPC?

gRPC - это современная высокопроизводительная структура, которая развивает вековой протокол [удаленного вызова процедуры (RPC).](https://en.wikipedia.org/wiki/Remote_procedure_call) На уровне приложений gRPC упрощает обмен сообщениями между клиентами и бэк-энд-сервисами. Происходит от Google, gRPC является открытым исходным кодом и частью [Облачных Родные вычислительные фонд (CNCF)](https://www.cncf.io/) экосистемы облачных предложений. CNCF считает gRPC [инкубационным проектом.](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc) Инкубация означает, что конечные пользователи используют технологию в производственных приложениях, и проект имеет здоровое количество участников.

Типичное клиентское приложение gRPC будет подвергать локальной функции в процессе, которая реализует бизнес-операцию. Под крышками эта локальная функция вызывает другую функцию на удаленном компьютере. То, что кажется локальным вызовом, по существу становится прозрачным внепроцессным вызовом в удаленный сервис. RPC сантехника абстрагирует точечную сетевую связь, сериализацию и выполнение между компьютерами.

В облачных приложениях разработчики часто работают в разных языках программирования, инфраструктурах и технологиях. Такая *совместимость* усложняет контракты на сообщения и сантехнику, необходимую для кросс-платформенного общения.  gRPC обеспечивает "единый горизонтальный слой", который абстрагирует эти проблемы. Разработчики код в их родной платформе сосредоточены на бизнес-функциональности, в то время как gRPC обрабатывает коммуникационной сантехники.

gRPC предлагает всестороннюю поддержку в наиболее популярных стеках разработки, включая Java, JavaScript, C, Go, Swift и NodeJS.

## <a name="grpc-benefits"></a>преимущества gRPC

gRPC использует HTTP/2 для своего транспортного протокола. В то время как совместимый с HTTP 1.1, HTTP/2 имеет много расширенных возможностей:

- Двоичный протокол для передачи данных - в отличие от HTTP 1.1, который отправляет данные как четкий текст.
- Поддержка мультиплексирования для отправки нескольких параллельных запросов по одному и тому же подключению - HTTP 1.1 ограничивает обработку одного запроса/ответа одновременно.
- Двунаправленная полнодуплексная связь для одновременной отправки запросов клиентов и ответов на серверы.
- Встроенная потоковая передача позволяет запросы и ответы на асинхронную потоковую передачу больших наборов данных.

gRPC является легким и высокоэффективным. Это может быть до 8раз быстрее, чем JSON сериализации с сообщениями 60-80% меньше. На языке Microsoft [Windows Communication Foundation (WCF)](https://docs.microsoft.com/dotnet/framework/wcf/whats-wcf) производительность gRPC превышает скорость и эффективность высокооптимизированных [привязок NetTCP.](https://docs.microsoft.com/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8) В отличие от NetTCP, которая выступает за стек Microsoft, gRPC является кросс-платформенным.

## <a name="protocol-buffers"></a>Protocol Buffers

gRPC использует технологию с открытым исходным кодом под названием [Протокол буферов](https://developers.google.com/protocol-buffers/docs/overview). Они обеспечивают высокоэффективный и нейтральный на платформе формат сериализации для сериализации структурированных сообщений, которые службы отправляют друг другу. Используя кросс-платформенный язык определения интерфейса (IDL), разработчики определяют контракт на обслуживание для каждой микрослужбы. Контракт, реализованный как текстовый `.proto` файл, описывает методы, входы и выходы для каждой службы. Один и тот же файл контракта может быть использован для клиентов gRPC и услуг, построенных на различных платформах разработки.

Используя файл прото, компилятор Protobuf, `protoc`генерирует как клиент, так и код обслуживания для вашей целевой платформы. Код включает в себя следующие компоненты:

- Сильно набранные объекты, совместно используемые клиентом и службой, представляющие элементы службы и элементы данных для сообщения.
- Сильно типированный базовый класс с необходимой сетевой сантехникой, которую может наследовать и расширять дистанционная служба gRPC.
- Клиент заглушка, которая содержит необходимые сантехника для вызывания удаленной службы gRPC.

Во время выполнения каждое сообщение сериализируется как стандартное представление Protobuf и обменивается между клиентом и удаленным сервисом. В отличие от JSON или XML, сообщения Protobuf сериализуются как компиляционные бинарные байты.

Книга, [gRPC для разработчиков WCF](https://docs.microsoft.com/dotnet/architecture/grpc-for-wcf-developers/), доступна на сайте Microsoft Architecture, обеспечивает углубленное покрытие gRPC и протокола буферов.

## <a name="grpc-support-in-net"></a>поддержка gRPC в .NET

gRPC интегрирован в .NET Core 3.0 SDK или позже. Его поддерживают следующие инструменты:

- Visual Studio 2019, версия 16.3 или более поздняя, с установленной рабочей нагрузкой веб-разработки.
- Visual Studio Code
- дотнет CLI

SDK включает в себя инструментарий для конечных точек, встроенный IoC и журналирование. Веб-сервер Kestrel с открытым исходным кодом поддерживает соединения HTTP/2. На рисунке 4-20 показан шаблон Visual Studio 2019, который создает скелетный проект для сервиса gRPC. Обратите внимание, что .NET Core полностью поддерживает Windows, Linux и macOS.

![поддержка gRPC в визуальной студии 2019](./media/visual-studio-2019-grpc-template.png)

**Рис. 4-20**. поддержка gRPC в Visual Studio 2019
  
На рисунке 4-21 показана услуга скелета gRPC, созданная из встроенных строительных лесов, включенных в Visual Studio 2019.  

![проект gRPC в Visual Studio 2019](./media/grpc-project.png  )

**Рис. 4-21**. проект gRPC в Visual Studio 2019

На предыдущем рисунке обратите внимание на файл прото описания и код службы. Как вы увидите в ближайшее время, Visual Studio генерирует дополнительную конфигурацию как в классе Startup, так и в базовом файле проекта.

## <a name="grpc-usage"></a>использование gRPC

Благоприятный gRPC для следующих сценариев:

- Синхронная бэкэндная связь между микрослужбами и микрослужбами, в которой требуется немедленный ответ для продолжения обработки.
- Среды Polyglot, которые должны поддерживать смешанные платформы программирования.
- Низкая задержка и высокая пропускная способность связи, где производительность имеет решающее значение.
- От точки к точке в режиме реального времени связи - gRPC может толкать сообщения в режиме реального времени без опроса и имеет отличную поддержку для двухнаправления потоковой передачи.
- Сетевые ограниченные среды - двоичные gRPC-сообщения всегда меньше, чем эквивалентное текстовое сообщение JSON.

В то время, в этой письменной форме, gRPC в первую очередь используется с бэкэнд-сервисов. Большинство современных браузеров не могут обеспечить уровень управления HTTP/2, необходимый для поддержки фронт-энда gRPC клиента. Тем не менее, есть [ранняя инициатива,](https://devblogs.microsoft.com/aspnet/grpc-web-experiment/) которая позволяет gRPC связи из браузерных приложений, построенных с JavaScript или Blazor WebAssembly технологий. [gRPC-Web для .NET](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md) позволяет ASP.NET core gRPC приложение для поддержки функций gRPC в приложениях браузера:

- Сильно набранные код-генерируемые клиенты
- Компактные сообщения Protobuf
- Потоковая передача серверов

## <a name="grpc-implementation"></a>gRPC реализация

Архитектура ссылки на микрослужбы, [eShop on Containers,](https://github.com/dotnet-architecture/eShopOnContainers)от корпорации Майкрософт, показывает, как реализовать услуги gRPC в приложениях .NET Core. Рисунок 4-22 представляет архитектуру бэк-энда.

![Архитектура бэкэнда для eShop на контейнерах](./media/eshop-with-aggregators.png)

**Рис. 4-22**. Архитектура бэкэнда для eShop на контейнерах

На предыдущей цифре обратите внимание, как eShop охватывает [шаблон Backend for Frontends](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends) (BFF), подвергая несколько шлюзов API. Мы обсудили модель BFF ранее в этой главе. Обратите пристальное внимание на микросервис агрегатора (в сером цвете), который находится между Web-Shopping API Gateway и бэкэнд омичем. Агрегатор получает один запрос от клиента, отправляет его в различные микрослужбы, агрегирует результаты и отправляет их обратно запрашивающему клиенту. Такие операции обычно требуют синхронной связи, чтобы дать немедленный ответ. В eShop бэкэнд-звонки от агрегатора выполняются с помощью gRPC, как показано на рисунке 4-23.

![gRPC в интернет-магазине на контейнерах](./media/grpc-implementation.png)

**Рис. 4-23**. gRPC в интернет-магазине на контейнерах

gRPC для связи требуется как клиентские, так и серверные компоненты. В предыдущем рисунке обратите внимание, как торговый агрегатор реализует клиент gRPC. Клиент делает синхронные вызовы gRPC (красным цветом) для бэкэнд-сервисов, каждый из которых реализует сервер gRPC. Как клиент, так и сервер пользуются встроенным gRPC сантехникой от .NET Core 3.0 SDK. Клиент-сторона *заглушки* обеспечивают сантехнику для вызова удаленных вызовов gRPC. Компоненты на стороне сервера обеспечивают сантехнику gRPC, которую пользовательские классы служб могут наследовать и потреблять.

Микрослужбы, которые разоблачают как RESTful API, так и gRPC-связь, требуют нескольких конечных точек для управления трафиком. Вы бы открыть конечную точку, которая слушает для трафика HTTP для RESTful звонки, а другой для gRPC звонки. Конечная точка gRPC должна быть настроена для протокола HTTP/2, необходимого для связи gRPC.

В то время как мы стремимся отделить микрослужбы с асинхронными коммуникационными шаблонами, некоторые операции требуют прямых вызовов. gRPC должен быть основным выбором для прямой синхронной связи между микрослужбами. Его высокопроизводительный коммуникационный протокол, основанный на HTTP/2 и буферах протокола, делает его идеальным выбором.

## <a name="looking-ahead"></a>Заглядывая в будущее

Заглядывая в будущее, gRPC будет продолжать набирать обороты для облачных систем. Преимущества производительности и простота развития являются убедительными. Тем не менее, REST, вероятно, будет вокруг в течение длительного времени. Он выделяется для публично выставленных AIS и по причинам обратной совместимости.

>[!div class="step-by-step"]
>[Предыдущий](service-to-service-communication.md)
>[Следующий](service-mesh-communication-infrastructure.md)
