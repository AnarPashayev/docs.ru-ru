---
title: REST и gRPC
description: Узнайте о gRPC, ее роли в собственных приложениях в облаке и о том, как она отличается от протокола HTTP RESTFUL.
author: robvet
ms.date: 09/08/2019
ms.openlocfilehash: c77343e7a594d34cbd2c00ce11281bd6bf4000c1
ms.sourcegitcommit: 30a558d23e3ac5a52071121a52c305c85fe15726
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/25/2019
ms.locfileid: "75337075"
---
# <a name="rest-and-grpc"></a>REST и gRPC

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

До сих пор в этой книге мы сосредоточены на связи на [основе RESTful](https://docs.microsoft.com/azure/architecture/best-practices/api-design) . "ОСТАВШАЯся" — это архитектурный стиль, который способствует взаимодействию между распределенными системами компьютеров. Он использует модель "запрос-ответ", где каждый ответ сервера связан с запросом от клиента. В то время как широко распространено, остальное не подходит для каждой проблемы. Более новая технология связи, озаглавленная gRPC, быстро получает популярность и делает ее в собственном мире в облаке.

## <a name="grpc"></a>gRPC

gRPC — это связь с открытым кодом, полученная от Google. Она построена на основе модели [удаленного вызова процедур (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call) , популярной в распределенных вычислениях. После этой модели локальная клиентская программа предоставляет внутрипроцессный метод для выполнения операции. В фоновом режиме этот вызов вызывается для внешней службы в распределенной сети. Разработчик кодирует операцию как вызов локальной процедуры. Базовая платформа абстрагирует сетевую связь «точка-точка», сериализацию и выполнение.

gRPC — это современная платформа RPC, которая является простой и высокопроизводительной. Он использует HTTP/2 для транспортного протокола. Несмотря на то, что совместимость с HTTP 1,1, HTTP/2 включает в себя множество дополнительных возможностей:

- Хотя HTTP 1,1 отправляет данные в виде открытого текста, HTTP/2 является двоичным протоколом. Он быстрее анализирует данные с помощью меньшего объема памяти, сокращает задержку в сети с помощью связанных улучшений для ускорения и более эффективного управления сетевыми ресурсами.
- Хотя HTTP 1,1 ограничена обработкой одного запроса или ответа приема-передачи за раз, HTTP/2 поддерживает мультиплексирование или несколько параллельных запросов по одному соединению.
- HTTP/2 поддерживает дуплексную или двунаправленную связь, где как клиент, так и сервер могут обмениваться данными в одно и то же время. Клиент может отправлять данные запроса одновременно с отправкой данных ответа сервером.
- Потоковая передача встроена в HTTP/2, что означает, что запросы и ответы могут асинхронно потокировать большие наборы данных.
- Сочетание gRPC и HTTP/2 значительно повышает производительность. В [Windows Communication Foundation (WCF)](https://docs.microsoft.com/dotnet/framework/wcf/whats-wcf) терминах производительность gRPC соответствует и превышает скорость и эффективность [привязок NetTcp](https://docs.microsoft.com/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8). Однако, в отличие от NetTCP, gRPC не ограничивается такими языками Майкрософт, C# как или Visual Basic.

gRPC поддерживается на самых популярных платформах, включая Java, C#, Golang и NodeJS.

## <a name="protocol-buffers"></a>Protocol Buffers

gRPC использует другую технологию с открытым исходным кодом, которая называется [буфером протоколов](https://developers.google.com/protocol-buffers/docs/overview) или сообщениями protobuf для отправки и получения данных. Как и в случае с [контрактом данных WCF](https://docs.microsoft.com/dotnet/framework/wcf/feature-details/using-data-contracts), protobuf сериализует структурированные данные для систем для чтения и записи. Это сокращает затраты, которые могут быть доступны для удобочитаемых форматов, таких как XML или JSON.

Многие методы сериализации объектов соответствуют структуре объектов данных во время выполнения. Protobuf требует, чтобы структура была заранее определена с использованием независимого от платформы языка (языкового буфера протокола). Каждое определение хранится в файле ". \". Затем с помощью компилятора protobuf, "Proton", вы создаете клиентский и серверный код для любой из поддерживаемых платформ. Созданный код оптимизирован для быстрой сериализации и десериализации данных. Во время выполнения каждое сообщение упаковывается в строго типизированный контракт службы и сериализуется в стандартное представление protobuf.

## <a name="grpc-support-in-net"></a>Поддержка gRPC в .NET

Microsoft .NET Core Framework 3,0 включает средства и встроенную поддержку gRPC. На рис. 4-20 показан шаблон Visual Studio 2019, который формирует проект схемы gRPC для службы gRPC. Обратите внимание, как .NET Core поддерживает платформы Windows, Linux и macOS.

![Поддержка gRPC в Visual Studio 2019](./media/visual-studio-2019-grpc-template.png)

**Рис. 4-20**. Поддержка gRPC в Visual Studio 2019

.NET Core 3,0 легко интегрирует gRPC в свою инфраструктуру, включая маршрутизацию конечных точек, встроенную поддержку IoC и ведение журнала. Веб-сервер Kestrel с открытым кодом полностью поддерживает подключения HTTP/2.

На рис. 4-21 показана структура службы gRPC в Visual Studio 2019. Обратите внимание, что структура папок включает папки для файлов с указанием и кода службы.

![проект gRPC в Visual Studio 2019](./media/grpc-project.png  )

**Рис. 4-21**. проект gRPC в Visual Studio 2019

## <a name="grpc-usage"></a>Использование gRPC

gRPC хорошо подходит для следующих сценариев:

- Низкая задержка и обмен данными с высокой пропускной способностью. gRPC отлично подходит для облегченных микрослужб, в которых важна эффективность.
- Обмен данными «точка-точка» в реальном времени. gRPC обладает отличной поддержкой двунаправленной потоковой передачи. службы gRPC Services могут отправлять сообщения в режиме реального времени без опроса.
- Polyglot среды — средства gRPC поддерживают большинство популярных языков разработки, делая их хорошим выбором для многоязыковых сред.
- Ограниченные среды сети — сообщения gRPC сериализуются с помощью protobuf, облегченного формата сообщений. Сообщение gRPC всегда меньше, чем эквивалентное сообщение JSON.

Во время написания этой книги большинство браузеров имеют ограниченную поддержку gRPC. gRPC сильно использует функции HTTP/2, и ни один браузер не предоставляет необходимый уровень контроля над веб-запросами для поддержки клиента gRPC. gRPC обычно используется для взаимодействия внутренних микрослужб с микрослужбами. На рис. 4-22 показана простая, но распространенная схема использования.

![Шаблоны использования gRPC](./media/grpc-usage.png)

**Рис. 4-22**. шаблоны использования gRPC

Обратите внимание на предыдущее, как интерфейсный трафик вызывается с помощью HTTP, а фоновая микрослужба для микрослужбы использует gRPC.

Взглянув на будущее, gRPC может играть значительную роль в десронинг превосходствоа для собственных облачных систем. Преимущества производительности и простота разработки слишком хороши для передачи. Тем не менее, не делайте никаких ошибок, остальное будет продолжаться в течение долгого времени. Он по-прежнему предназначен для общедоступных API и для обеспечения обратной совместимости.

>[!div class="step-by-step"]
>[Назад](service-to-service-communication.md)
>[Вперед](service-mesh-communication-infrastructure.md)
