---
title: Рекомендации по бессерверной архитектуре. Бессерверные приложения
description: Узнайте о сложностях, связанных с проектированием бессерверных приложений — от управления состоянием и создания постоянного хранилища до масштабирования, ведения журналов, трассировки и диагностики.
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 06/26/2018
ms.openlocfilehash: c856683cf6910be98661e634246cd003b93a6d76
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "72522424"
---
# <a name="serverless-architecture-considerations"></a><span data-ttu-id="8c18a-103">Рекомендации по бессерверной архитектуре</span><span class="sxs-lookup"><span data-stu-id="8c18a-103">Serverless architecture considerations</span></span>

<span data-ttu-id="8c18a-104">Внедрение бессерверной архитектуры сопряжено с определенными сложностями.</span><span class="sxs-lookup"><span data-stu-id="8c18a-104">Adopting a serverless architecture does come with certain challenges.</span></span> <span data-ttu-id="8c18a-105">В этом разделе рассматриваются самые распространенные рекомендации, которые следует учитывать.</span><span class="sxs-lookup"><span data-stu-id="8c18a-105">This section explores some of the more common considerations to be aware of.</span></span> <span data-ttu-id="8c18a-106">Для всех этих проблем есть решения.</span><span class="sxs-lookup"><span data-stu-id="8c18a-106">All of these challenges have solutions.</span></span> <span data-ttu-id="8c18a-107">Независимо от варианта архитектуры, решение использовать бессерверную модель следует принимать, только тщательно рассмотрев преимущества и недостатки.</span><span class="sxs-lookup"><span data-stu-id="8c18a-107">As with all architecture choices, the decision to go serverless should be made only after carefully considering the pros and cons.</span></span> <span data-ttu-id="8c18a-108">Учтя потребности приложения, вы можете выяснить, что бессерверная реализация не подходит для определенных компонентов.</span><span class="sxs-lookup"><span data-stu-id="8c18a-108">Depending on the needs of your application, you may decide a serverless implementation isn't the right solution for certain components.</span></span>

## <a name="managing-state"></a><span data-ttu-id="8c18a-109">Управление состоянием</span><span class="sxs-lookup"><span data-stu-id="8c18a-109">Managing state</span></span>

<span data-ttu-id="8c18a-110">Бессерверные функции, как и большинство микрослужб, по умолчанию работают без учета состояния.</span><span class="sxs-lookup"><span data-stu-id="8c18a-110">Serverless functions, as with microservices in general, are stateless by default.</span></span> <span data-ttu-id="8c18a-111">Отсутствие данных о состоянии в бессерверной модели позволяет использовать временные компоненты, горизонтально масштабировать архитектуру и обеспечить устойчивость без центральной точки отказа.</span><span class="sxs-lookup"><span data-stu-id="8c18a-111">Avoiding state enables serverless to be ephemeral, to scale out, and to provide resiliency without a central point of failure.</span></span> <span data-ttu-id="8c18a-112">В некоторых случаях для бизнес-процессов требуются сведения о состоянии.</span><span class="sxs-lookup"><span data-stu-id="8c18a-112">In some circumstances, business processes require state.</span></span> <span data-ttu-id="8c18a-113">Если для процесса требуются сведения о состоянии, есть два варианта.</span><span class="sxs-lookup"><span data-stu-id="8c18a-113">If your process requires state, you have two options.</span></span> <span data-ttu-id="8c18a-114">Можно использовать не бессерверную, а другую модель, или связать приложение с отдельной службой, которая предоставляет данные о состоянии.</span><span class="sxs-lookup"><span data-stu-id="8c18a-114">You can adopt a model other than serverless, or interact with a separate service that provides state.</span></span> <span data-ttu-id="8c18a-115">Добавление возможности учета данных о состоянии может усложнить решение и затруднить масштабирование, а также повлечь создание единой точки отказа.</span><span class="sxs-lookup"><span data-stu-id="8c18a-115">Adding state can complicate the solution and make it harder to scale, and potentially create a single point of failure.</span></span> <span data-ttu-id="8c18a-116">Тщательно продумайте, основательно ли требуются для функции данные состояния.</span><span class="sxs-lookup"><span data-stu-id="8c18a-116">Carefully consider whether your function absolutely requires state.</span></span> <span data-ttu-id="8c18a-117">Если да, определите, можно ли реализовать их учет в бессерверной модели.</span><span class="sxs-lookup"><span data-stu-id="8c18a-117">If the answer is "yes," determine whether it still makes sense to implement it with serverless.</span></span>

<span data-ttu-id="8c18a-118">Существует несколько решений, которые позволяют обеспечить учет состояния, не мешая использовать преимущества бессерверной архитектуры.</span><span class="sxs-lookup"><span data-stu-id="8c18a-118">There are several solutions to adopt state without compromising the benefits of serverless.</span></span> <span data-ttu-id="8c18a-119">К самым популярным решениям относятся:</span><span class="sxs-lookup"><span data-stu-id="8c18a-119">Some of the more popular solutions include:</span></span>

- <span data-ttu-id="8c18a-120">использование временного хранилища данных или распределенного кэша, например Redis;</span><span class="sxs-lookup"><span data-stu-id="8c18a-120">Use a temporary data store or distributed cache, like Redis</span></span>
- <span data-ttu-id="8c18a-121">сохранение состояния в базе данных, например SQL или Cosmos DB;</span><span class="sxs-lookup"><span data-stu-id="8c18a-121">Store state in a database, like SQL or CosmosDB</span></span>
- <span data-ttu-id="8c18a-122">обработка данных о состоянии через механизм рабочих процессов, например с использованием устойчивых функций.</span><span class="sxs-lookup"><span data-stu-id="8c18a-122">Handle state through a workflow engine like durable functions</span></span>

<span data-ttu-id="8c18a-123">По сути, необходимо учитывать потребность в управлении состоянием в процессах при внедрении бессерверной модели.</span><span class="sxs-lookup"><span data-stu-id="8c18a-123">The bottom line is that you should be aware of the need for any state management within processes you're considering to implement with serverless.</span></span>

## <a name="long-running-processes"></a><span data-ttu-id="8c18a-124">Длительные процессы</span><span class="sxs-lookup"><span data-stu-id="8c18a-124">Long-running processes</span></span>

<span data-ttu-id="8c18a-125">В основе многих преимуществ бессерверной архитектуры лежат временные процессы.</span><span class="sxs-lookup"><span data-stu-id="8c18a-125">Many benefits of serverless rely on the processes being ephemeral.</span></span> <span data-ttu-id="8c18a-126">Короткое время выполнения упрощает бессерверному поставщику освобождение ресурсов по мере завершения функций и совместное использование функций на разных узлах.</span><span class="sxs-lookup"><span data-stu-id="8c18a-126">Short run times make it easier for the serverless provider to free up resources as functions end and share functions across hosts.</span></span> <span data-ttu-id="8c18a-127">Большинство поставщиков облачных служб ограничивают общее время работы функции приблизительно 10 минутами.</span><span class="sxs-lookup"><span data-stu-id="8c18a-127">Most cloud providers limit the total time your function can run to around 10 minutes.</span></span> <span data-ttu-id="8c18a-128">Если выполнение процесса может занимать больше времени, вы можете рассмотреть альтернативную реализацию.</span><span class="sxs-lookup"><span data-stu-id="8c18a-128">If your process may take longer, you might consider an alternative implementation.</span></span>

<span data-ttu-id="8c18a-129">Существует несколько исключений и решений.</span><span class="sxs-lookup"><span data-stu-id="8c18a-129">There are a few exceptions and solutions.</span></span> <span data-ttu-id="8c18a-130">Первое возможное решение — разбить процесс на небольшие компоненты, выполнение которых по отдельности занимает меньше времени.</span><span class="sxs-lookup"><span data-stu-id="8c18a-130">One solution may be to break your process into smaller components that individually take less time to run.</span></span> <span data-ttu-id="8c18a-131">Если процесс выполняется долго из-за зависимостей, можно также использовать асинхронный рабочий процесс с применением такого решения, как устойчивые функции.</span><span class="sxs-lookup"><span data-stu-id="8c18a-131">If your process runs long because of dependencies, you can also consider an asynchronous workflow using a solution like durable functions.</span></span> <span data-ttu-id="8c18a-132">Устойчивые функции приостанавливают и сохраняют состояние процесса, пока ожидается завершение внешнего процесса.</span><span class="sxs-lookup"><span data-stu-id="8c18a-132">Durable functions pause and maintain the state of your process while it's waiting on an external process to finish.</span></span> <span data-ttu-id="8c18a-133">Асинхронная обработка сокращает время выполнения фактического процесса.</span><span class="sxs-lookup"><span data-stu-id="8c18a-133">Asynchronous handling reduces the time the actual process runs.</span></span>

## <a name="startup-time"></a><span data-ttu-id="8c18a-134">Время запуска</span><span class="sxs-lookup"><span data-stu-id="8c18a-134">Startup time</span></span>

<span data-ttu-id="8c18a-135">Одна из потенциальных проблем с бессерверными реализациями связана с временем запуска.</span><span class="sxs-lookup"><span data-stu-id="8c18a-135">One potential concern with serverless implementations is startup time.</span></span> <span data-ttu-id="8c18a-136">Чтобы сэкономить ресурсы, многие бессерверные поставщики создают инфраструктуру "по запросу".</span><span class="sxs-lookup"><span data-stu-id="8c18a-136">To conserve resources, many serverless providers create infrastructure "on demand."</span></span> <span data-ttu-id="8c18a-137">Когда бессерверная функция запускается по истечении определенного периода времени, может потребоваться создать или перезапустить ресурсы для размещения функции.</span><span class="sxs-lookup"><span data-stu-id="8c18a-137">When a serverless function is triggered after a period of time, the resources to host the function may need to be created or restarted.</span></span> <span data-ttu-id="8c18a-138">В некоторых ситуациях холодный запуск может приводить к задержкам в несколько секунд.</span><span class="sxs-lookup"><span data-stu-id="8c18a-138">In some situations, cold starts may result in delays of several seconds.</span></span> <span data-ttu-id="8c18a-139">Время запуска зависит от поставщиков и уровней обслуживания.</span><span class="sxs-lookup"><span data-stu-id="8c18a-139">Startup time varies across providers and service levels.</span></span> <span data-ttu-id="8c18a-140">Если для успешной работы приложения необходимо уменьшить это время, можно рассмотреть несколько подходов к управлению временем запуска.</span><span class="sxs-lookup"><span data-stu-id="8c18a-140">There are a few approaches to address startup time if it's important to minimize for the success of the app.</span></span>

- <span data-ttu-id="8c18a-141">Некоторые поставщики предусматривают оплату уровней обслуживания, гарантирующих постоянную доступность инфраструктуры.</span><span class="sxs-lookup"><span data-stu-id="8c18a-141">Some providers allow users to pay for service levels that guarantee infrastructure is "always on".</span></span>
- <span data-ttu-id="8c18a-142">Реализуйте механизм поддержания активности (проверку связи с конечной точкой, чтобы она оставалась в рабочем режиме).</span><span class="sxs-lookup"><span data-stu-id="8c18a-142">Implement a keep-alive mechanism (ping the endpoint to keep it "awake").</span></span>
- <span data-ttu-id="8c18a-143">Используйте оркестрацию, например Kubernetes, вместе с контейнерной функцией (узел уже работает, поэтому запуск новых экземпляров проходит чрезвычайно быстро).</span><span class="sxs-lookup"><span data-stu-id="8c18a-143">Use orchestration like Kubernetes with a containerized function approach (the host is already running so spinning up new instances is extremely fast).</span></span>

## <a name="database-updates-and-migrations"></a><span data-ttu-id="8c18a-144">Обновление и миграция базы данных</span><span class="sxs-lookup"><span data-stu-id="8c18a-144">Database updates and migrations</span></span>

<span data-ttu-id="8c18a-145">Преимущество бессерверного кода заключается в возможности выпускать новые функции без необходимости повторно развертывать все приложение.</span><span class="sxs-lookup"><span data-stu-id="8c18a-145">An advantage of serverless code is that you can release new functions without having to redeploy the entire application.</span></span> <span data-ttu-id="8c18a-146">Это преимущество может стать недостатком, если задействована реляционная база данных.</span><span class="sxs-lookup"><span data-stu-id="8c18a-146">This advantage can become a disadvantage when there's a relational database involved.</span></span> <span data-ttu-id="8c18a-147">Изменения в схемах баз данных трудно синхронизировать с обновлениями бессерверной модели.</span><span class="sxs-lookup"><span data-stu-id="8c18a-147">Changes to database schemas are difficult to synchronize with serverless updates.</span></span> <span data-ttu-id="8c18a-148">Дополнительные трудности возникают при сбоях, когда необходимо откатить изменения.</span><span class="sxs-lookup"><span data-stu-id="8c18a-148">Additional challenges are posed when things go wrong and the changes must be rolled back.</span></span> <span data-ttu-id="8c18a-149">Целостность данных — одна из причин, по которой в микрослужбах и бессерверных функциях рекомендуется использовать собственные данные.</span><span class="sxs-lookup"><span data-stu-id="8c18a-149">Data integrity is one reason that a best practice for microservices and serverless functions is that they own their own data.</span></span> <span data-ttu-id="8c18a-150">Изменения можно развернуть как единую единицу вычислений и данных.</span><span class="sxs-lookup"><span data-stu-id="8c18a-150">It is possible to deploy changes as a single unit of compute and data.</span></span> <span data-ttu-id="8c18a-151">В действительности у многих устаревших систем есть большая серверная база данных, которую необходимо согласовывать с бессерверной архитектурой.</span><span class="sxs-lookup"><span data-stu-id="8c18a-151">The reality is that many legacy systems feature a large back-end database that must be reconciled with the serverless architecture.</span></span>

<span data-ttu-id="8c18a-152">Самый распространенный подход к управлению версиями схемы заключается в том, чтобы не изменять существующие свойства и столбцы, а вместо этого добавлять новые сведения.</span><span class="sxs-lookup"><span data-stu-id="8c18a-152">A popular approach to solve schema versioning is to never modify existing properties and columns, but instead add new information.</span></span> <span data-ttu-id="8c18a-153">Например, рассмотрите переход с логического флага завершения для списка дел на флаг даты завершения.</span><span class="sxs-lookup"><span data-stu-id="8c18a-153">For example, consider a change to move from a Boolean "completed" flag for a todo list to a "completed date."</span></span> <span data-ttu-id="8c18a-154">Вместо удаления старого поля нужно будет изменить базу данных следующим образом:</span><span class="sxs-lookup"><span data-stu-id="8c18a-154">Instead of removing the old field, the database change will:</span></span>

1. <span data-ttu-id="8c18a-155">Добавьте новое поле даты завершения.</span><span class="sxs-lookup"><span data-stu-id="8c18a-155">Add a new "completed date" field.</span></span>
1. <span data-ttu-id="8c18a-156">Преобразуйте логическое поле завершения в вычисляемую функцию, которая будет оценивать, наступает ли дата завершения после текущей даты.</span><span class="sxs-lookup"><span data-stu-id="8c18a-156">Transform the "completed" Boolean field to a computed function that evaluates whether the completed date is after the current date.</span></span>
1. <span data-ttu-id="8c18a-157">Добавьте триггер, устанавливающий для даты завершения текущую дату, когда для логического значения завершения задано значение true.</span><span class="sxs-lookup"><span data-stu-id="8c18a-157">Add a trigger to set the completed date to the current date when the completed Boolean is set to true.</span></span>

<span data-ttu-id="8c18a-158">Последовательность изменений гарантирует, что устаревший код продолжит выполняться "как есть", а новые бессерверные функции смогут использовать новое поле.</span><span class="sxs-lookup"><span data-stu-id="8c18a-158">The sequence of changes ensures that legacy code continues to run "as is" while newer serverless functions can take advantage of the new field.</span></span>

<span data-ttu-id="8c18a-159">Дополнительные сведения о данных в бессерверных архитектурах см. в статье [Распределенное управление данными: проблемы и решения](../microservices/architect-microservice-container-applications/distributed-data-management.md).</span><span class="sxs-lookup"><span data-stu-id="8c18a-159">For more information about data in serverless architectures, see [Challenges and solutions for distributed data management](../microservices/architect-microservice-container-applications/distributed-data-management.md).</span></span>

## <a name="scaling"></a><span data-ttu-id="8c18a-160">Масштабирование</span><span class="sxs-lookup"><span data-stu-id="8c18a-160">Scaling</span></span>

<span data-ttu-id="8c18a-161">То, что бессерверная архитектура значит отсутствие сервера, — распространенное заблуждение.</span><span class="sxs-lookup"><span data-stu-id="8c18a-161">It's a common misconception that serverless means "no server."</span></span> <span data-ttu-id="8c18a-162">На самом деле это значит, что сервер используется меньше.</span><span class="sxs-lookup"><span data-stu-id="8c18a-162">It's in fact "less server."</span></span> <span data-ttu-id="8c18a-163">Фактически наличие резервной инфраструктуры играет важную роль при масштабировании.</span><span class="sxs-lookup"><span data-stu-id="8c18a-163">The fact there is a backing infrastructure is important to understand when it comes to scaling.</span></span> <span data-ttu-id="8c18a-164">Большинство бессерверных платформ предусматривают набор элементов управления, позволяющих контролировать способ масштабирования инфраструктуры при увеличении плотности событий.</span><span class="sxs-lookup"><span data-stu-id="8c18a-164">Most serverless platforms provide a set of controls to handle how the infrastructure should scale when event density increases.</span></span> <span data-ttu-id="8c18a-165">Вы можете выбрать один из различных вариантов, но в зависимости от функции стратегия может отличаться.</span><span class="sxs-lookup"><span data-stu-id="8c18a-165">You can choose from a variety of options, but your strategy may vary depending on the function.</span></span> <span data-ttu-id="8c18a-166">Более того, функции обычно выполняются на связанном узле, поэтому у функций на одном и том же узле одинаковые параметры масштабирования.</span><span class="sxs-lookup"><span data-stu-id="8c18a-166">Furthermore, functions are typically run under a related host, so that functions on the same host have the same scale options.</span></span> <span data-ttu-id="8c18a-167">Следовательно необходимо организовать функции и продумать, какие из них разместить вместе, в зависимости от требований к масштабированию.</span><span class="sxs-lookup"><span data-stu-id="8c18a-167">Therefore it is necessary to organize and strategize which functions are hosted together based on scale requirements.</span></span>

<span data-ttu-id="8c18a-168">Правила часто определяют способ увеличения масштаба (ресурсов узла) и горизонтального масштабирования (увеличения количества экземпляров узла) на основе различных параметров.</span><span class="sxs-lookup"><span data-stu-id="8c18a-168">Rules often specify how to scale-up (increase the host resources) and scale-out (increase the number of host instances) based on varying parameters.</span></span> <span data-ttu-id="8c18a-169">В качестве триггеров масштабирования можно использовать расписание, частоту запросов, загрузку ЦП и потребление памяти.</span><span class="sxs-lookup"><span data-stu-id="8c18a-169">Triggers for scales may include schedule, request rates, CPU utilization, and memory usage.</span></span> <span data-ttu-id="8c18a-170">Более высокая производительность зачастую стоит дороже.</span><span class="sxs-lookup"><span data-stu-id="8c18a-170">Higher performance often comes at a greater cost.</span></span> <span data-ttu-id="8c18a-171">Менее затратные подходы с платой за использованные ресурсы могут не обеспечить быстрое масштабирование при внезапном увеличении частоты запросов.</span><span class="sxs-lookup"><span data-stu-id="8c18a-171">The less expensive, consumption-based approaches may not scale as quickly when the request rate suddenly increases.</span></span> <span data-ttu-id="8c18a-172">Необходимо сделать выбор между оплатой "страховой стоимости" и оплатой по мере использования с риском медленных ответов по причине внезапного роста спроса.</span><span class="sxs-lookup"><span data-stu-id="8c18a-172">There is a trade-off between paying up front "insurance cost" versus paying strictly "as you go" and risking slower responses due to sudden increases in demand.</span></span>

## <a name="monitoring-tracing-and-logging"></a><span data-ttu-id="8c18a-173">Мониторинг, трассировка и ведение журнала</span><span class="sxs-lookup"><span data-stu-id="8c18a-173">Monitoring, tracing, and logging</span></span>

<span data-ttu-id="8c18a-174">Часто таким аспектом DevOps, как мониторинг приложений, пренебрегают после развертывания приложений.</span><span class="sxs-lookup"><span data-stu-id="8c18a-174">An often overlooked aspect of DevOps is monitoring applications once deployed.</span></span> <span data-ttu-id="8c18a-175">Стратегия мониторинга бессерверных функций крайне важна.</span><span class="sxs-lookup"><span data-stu-id="8c18a-175">It's important to have a strategy for monitoring serverless functions.</span></span> <span data-ttu-id="8c18a-176">Зачастую самая большая проблема — это корреляция (распознавание условий, когда пользователь вызывает несколько функций в рамках одного и того же взаимодействия).</span><span class="sxs-lookup"><span data-stu-id="8c18a-176">The biggest challenge is often correlation, or recognizing when a user calls multiple functions as part of the same interaction.</span></span> <span data-ttu-id="8c18a-177">Большинство бессерверных платформ позволяют вести журнал консоли, который можно импортировать в сторонние средства.</span><span class="sxs-lookup"><span data-stu-id="8c18a-177">Most serverless platforms allow console logging that can be imported into third-party tools.</span></span> <span data-ttu-id="8c18a-178">Есть также параметры для автоматизации сбора данных телеметрии, создания и отслеживания идентификаторов корреляции, а также отслеживания определенных действий для получения подробных сведений.</span><span class="sxs-lookup"><span data-stu-id="8c18a-178">There are also options to automate collection of telemetry, generate and track correlation IDs, and monitor specific actions to provide detailed insights.</span></span> <span data-ttu-id="8c18a-179">Azure предусматривает расширенную [платформу Application Insights](https://docs.microsoft.com/azure/azure-functions/functions-monitoring) для мониторинга и анализа.</span><span class="sxs-lookup"><span data-stu-id="8c18a-179">Azure provides the advanced [Application Insights platform](https://docs.microsoft.com/azure/azure-functions/functions-monitoring) for monitoring and analytics.</span></span>

## <a name="inter-service-dependencies"></a><span data-ttu-id="8c18a-180">Зависимости между службами</span><span class="sxs-lookup"><span data-stu-id="8c18a-180">Inter-service dependencies</span></span>

<span data-ttu-id="8c18a-181">В бессерверной архитектуре одни функции могут зависеть от других.</span><span class="sxs-lookup"><span data-stu-id="8c18a-181">A serverless architecture may include functions that rely on other functions.</span></span> <span data-ttu-id="8c18a-182">На самом деле нередко в бессерверной архитектуре несколько служб вызывают друг друга в рамках одного взаимодействия или распределенной транзакции.</span><span class="sxs-lookup"><span data-stu-id="8c18a-182">In fact, it isn't uncommon in a serverless architecture to have multiple services call each other as part of an interaction or distributed transaction.</span></span> <span data-ttu-id="8c18a-183">Во избежание сильной взаимосвязи рекомендуется, чтобы службы не ссылались на друг друга напрямую.</span><span class="sxs-lookup"><span data-stu-id="8c18a-183">To avoid strong coupling, it's recommended that services don't reference each other directly.</span></span> <span data-ttu-id="8c18a-184">Прямые ссылки могут привести к значительному рефакторингу, если необходимо изменить конечную точку службы.</span><span class="sxs-lookup"><span data-stu-id="8c18a-184">When the endpoint for a service needs to change, direct references could result in major refactoring.</span></span> <span data-ttu-id="8c18a-185">Предлагаемое решение — обеспечить механизм обнаружения служб, например реестр, предоставляющий соответствующую конечную точку для типа запроса.</span><span class="sxs-lookup"><span data-stu-id="8c18a-185">A suggested solution is to provide a service discovery mechanism, such as a registry, that provides the appropriate end point for a request type.</span></span> <span data-ttu-id="8c18a-186">Другое решение — использовать для обмена данными между службами такие службы обмена сообщениями, как очереди или разделы.</span><span class="sxs-lookup"><span data-stu-id="8c18a-186">Another solution is to leverage messaging services like queues or topics for communication between services.</span></span>

## <a name="managing-failure-and-providing-resiliency"></a><span data-ttu-id="8c18a-187">Управление сбоями и обеспечение устойчивости</span><span class="sxs-lookup"><span data-stu-id="8c18a-187">Managing failure and providing resiliency</span></span>

<span data-ttu-id="8c18a-188">Важно также рассмотреть *шаблон автоматического выключения*. Если по какой-либо причине происходит сбой службы, не рекомендуется многократно ее вызывать.</span><span class="sxs-lookup"><span data-stu-id="8c18a-188">It's also important to consider the *circuit-breaker pattern*: If, for some reason, a service continues to fail, it isn't advisable to call that service repeatedly.</span></span> <span data-ttu-id="8c18a-189">Вместо этого вызывается альтернативная служба или возвращается сообщение до тех пор, пока не будет восстановлена работоспособность зависимой службы.</span><span class="sxs-lookup"><span data-stu-id="8c18a-189">Instead, an alternative service is called or a message returned until the health of the dependent service is re-established.</span></span> <span data-ttu-id="8c18a-190">В бессерверной архитектуре необходимо учесть стратегию управления зависимостями между службами и разрешения этих зависимостей.</span><span class="sxs-lookup"><span data-stu-id="8c18a-190">The serverless architecture needs to take into account the strategy for resolving and managing inter-service dependencies.</span></span>

<span data-ttu-id="8c18a-191">Чтобы продолжать работать по шаблону автоматического выключения, службы должны быть не только устойчивыми, но и отказоустойчивыми.</span><span class="sxs-lookup"><span data-stu-id="8c18a-191">To continue the circuit-breaker pattern, services need to be fault tolerant and resilient.</span></span> <span data-ttu-id="8c18a-192">Отказоустойчивость означает возможность приложения продолжать работу даже после непредвиденных исключений или при обнаружении недопустимых состояний.</span><span class="sxs-lookup"><span data-stu-id="8c18a-192">Fault tolerance refers to the ability of your application to continue running even after unexpected exceptions or invalid states are encountered.</span></span> <span data-ttu-id="8c18a-193">Отказоустойчивость обычно является функцией самого кода, а ее написание определяет управление исключениями.</span><span class="sxs-lookup"><span data-stu-id="8c18a-193">Fault tolerance is typically a function of the code itself and how it's written to handle exceptions.</span></span> <span data-ttu-id="8c18a-194">Устойчивость предполагает возможность приложения восстанавливаться после сбоев.</span><span class="sxs-lookup"><span data-stu-id="8c18a-194">Resiliency refers to how capable the app is at recovering from failures.</span></span> <span data-ttu-id="8c18a-195">Управление устойчивостью часто осуществляется бессерверной платформой.</span><span class="sxs-lookup"><span data-stu-id="8c18a-195">Resiliency is often managed by the serverless platform.</span></span> <span data-ttu-id="8c18a-196">У платформы должна быть возможность запуска нового экземпляра бессерверной функции на случай сбоя имеющегося.</span><span class="sxs-lookup"><span data-stu-id="8c18a-196">The platform should be able to spin up a new serverless function instance when the existing one fails.</span></span> <span data-ttu-id="8c18a-197">Платформа также должна обладать достаточным количеством интеллектуальных ресурсов, чтобы при сбое каждого нового экземпляра останавливать запуск новых экземпляров.</span><span class="sxs-lookup"><span data-stu-id="8c18a-197">The platform should also be intelligent enough to stop spinning up new instances when every new instance fails.</span></span>

<span data-ttu-id="8c18a-198">Дополнительные сведения см. в статье [Реализация шаблона размыкателя цепи](../microservices/implement-resilient-applications/implement-circuit-breaker-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="8c18a-198">For more information, see [Implementing the Circuit Breaker pattern](../microservices/implement-resilient-applications/implement-circuit-breaker-pattern.md).</span></span>

## <a name="versioning-and-greenblue-deployments"></a><span data-ttu-id="8c18a-199">Управление версиями, а также "зеленые" и "синие" развертывания</span><span class="sxs-lookup"><span data-stu-id="8c18a-199">Versioning and green/blue deployments</span></span>

<span data-ttu-id="8c18a-200">Основным преимуществом бессерверных приложений является возможность обновления определенной функции без необходимости повторного развертывания всего приложения.</span><span class="sxs-lookup"><span data-stu-id="8c18a-200">A major benefit of serverless is the ability to upgrade a specific function without having to redeploy the entire application.</span></span> <span data-ttu-id="8c18a-201">Чтобы обновление было успешным, необходимо распределить версии функций так, чтобы службы, вызывающие функции, направлялись к правильной версии кода.</span><span class="sxs-lookup"><span data-stu-id="8c18a-201">For upgrades to be successful, functions must be versioned so that services calling them are routed to the correct version of code.</span></span> <span data-ttu-id="8c18a-202">Стратегия развертывания новых версий также важна.</span><span class="sxs-lookup"><span data-stu-id="8c18a-202">A strategy for deploying new versions is also important.</span></span> <span data-ttu-id="8c18a-203">Самый распространенный подход — использовать "зеленые" и "синие" развертывания.</span><span class="sxs-lookup"><span data-stu-id="8c18a-203">A common approach is to use "green/blue deployments."</span></span> <span data-ttu-id="8c18a-204">"Зеленое" развертывание — это текущая функция.</span><span class="sxs-lookup"><span data-stu-id="8c18a-204">The green deployment is the current function.</span></span> <span data-ttu-id="8c18a-205">Новая "синяя" версия развертывается в рабочей среде и тестируется.</span><span class="sxs-lookup"><span data-stu-id="8c18a-205">A new "blue" version is deployed to production and tested.</span></span> <span data-ttu-id="8c18a-206">После тестирования "зеленые" и "синие" версии заменяются и используется новая версия.</span><span class="sxs-lookup"><span data-stu-id="8c18a-206">When testing passes, the green and blue versions are swapped so the new version comes live.</span></span> <span data-ttu-id="8c18a-207">При возникновении каких-либо проблем эти версии можно вернуть обратно.</span><span class="sxs-lookup"><span data-stu-id="8c18a-207">If any issues are encountered, they can be swapped back.</span></span> <span data-ttu-id="8c18a-208">Поддержка управления версиями, а также "зеленых" и "синих" развертываний, требует совмещения разработки функций, чтобы управлять изменением версий, и работы с бессерверной платформой для управления развертываниями.</span><span class="sxs-lookup"><span data-stu-id="8c18a-208">Supporting versioning and green/blue deployments requires a combination of authoring the functions to accommodate version changes and working with the serverless platform to handle deployments.</span></span> <span data-ttu-id="8c18a-209">Один из возможных подходов — использование прокси-серверов, описанное в соответствующем разделе статьи [Azure Functions](azure-functions.md#proxies) (Функции Azure).</span><span class="sxs-lookup"><span data-stu-id="8c18a-209">One possible approach is to use proxies, which are described in the [Azure serverless platform](azure-functions.md#proxies) chapter.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="8c18a-210">[Назад](serverless-architecture.md)
>[Вперед](serverless-design-examples.md)</span><span class="sxs-lookup"><span data-stu-id="8c18a-210">[Previous](serverless-architecture.md)
[Next](serverless-design-examples.md)</span></span>
