---
title: Рекомендации по бессерверной архитектуре. Бессерверные приложения
description: Узнайте о сложностях, связанных с проектированием бессерверных приложений — от управления состоянием и создания постоянного хранилища до масштабирования, ведения журналов, трассировки и диагностики.
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 06/26/2018
ms.openlocfilehash: c856683cf6910be98661e634246cd003b93a6d76
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "72522424"
---
# <a name="serverless-architecture-considerations"></a>Рекомендации по бессерверной архитектуре

Внедрение бессерверной архитектуры сопряжено с определенными сложностями. В этом разделе рассматриваются самые распространенные рекомендации, которые следует учитывать. Для всех этих проблем есть решения. Независимо от варианта архитектуры, решение использовать бессерверную модель следует принимать, только тщательно рассмотрев преимущества и недостатки. Учтя потребности приложения, вы можете выяснить, что бессерверная реализация не подходит для определенных компонентов.

## <a name="managing-state"></a>Управление состоянием

Бессерверные функции, как и большинство микрослужб, по умолчанию работают без учета состояния. Отсутствие данных о состоянии в бессерверной модели позволяет использовать временные компоненты, горизонтально масштабировать архитектуру и обеспечить устойчивость без центральной точки отказа. В некоторых случаях для бизнес-процессов требуются сведения о состоянии. Если для процесса требуются сведения о состоянии, есть два варианта. Можно использовать не бессерверную, а другую модель, или связать приложение с отдельной службой, которая предоставляет данные о состоянии. Добавление возможности учета данных о состоянии может усложнить решение и затруднить масштабирование, а также повлечь создание единой точки отказа. Тщательно продумайте, основательно ли требуются для функции данные состояния. Если да, определите, можно ли реализовать их учет в бессерверной модели.

Существует несколько решений, которые позволяют обеспечить учет состояния, не мешая использовать преимущества бессерверной архитектуры. К самым популярным решениям относятся:

- использование временного хранилища данных или распределенного кэша, например Redis;
- сохранение состояния в базе данных, например SQL или Cosmos DB;
- обработка данных о состоянии через механизм рабочих процессов, например с использованием устойчивых функций.

По сути, необходимо учитывать потребность в управлении состоянием в процессах при внедрении бессерверной модели.

## <a name="long-running-processes"></a>Длительные процессы

В основе многих преимуществ бессерверной архитектуры лежат временные процессы. Короткое время выполнения упрощает бессерверному поставщику освобождение ресурсов по мере завершения функций и совместное использование функций на разных узлах. Большинство поставщиков облачных служб ограничивают общее время работы функции приблизительно 10 минутами. Если выполнение процесса может занимать больше времени, вы можете рассмотреть альтернативную реализацию.

Существует несколько исключений и решений. Первое возможное решение — разбить процесс на небольшие компоненты, выполнение которых по отдельности занимает меньше времени. Если процесс выполняется долго из-за зависимостей, можно также использовать асинхронный рабочий процесс с применением такого решения, как устойчивые функции. Устойчивые функции приостанавливают и сохраняют состояние процесса, пока ожидается завершение внешнего процесса. Асинхронная обработка сокращает время выполнения фактического процесса.

## <a name="startup-time"></a>Время запуска

Одна из потенциальных проблем с бессерверными реализациями связана с временем запуска. Чтобы сэкономить ресурсы, многие бессерверные поставщики создают инфраструктуру "по запросу". Когда бессерверная функция запускается по истечении определенного периода времени, может потребоваться создать или перезапустить ресурсы для размещения функции. В некоторых ситуациях холодный запуск может приводить к задержкам в несколько секунд. Время запуска зависит от поставщиков и уровней обслуживания. Если для успешной работы приложения необходимо уменьшить это время, можно рассмотреть несколько подходов к управлению временем запуска.

- Некоторые поставщики предусматривают оплату уровней обслуживания, гарантирующих постоянную доступность инфраструктуры.
- Реализуйте механизм поддержания активности (проверку связи с конечной точкой, чтобы она оставалась в рабочем режиме).
- Используйте оркестрацию, например Kubernetes, вместе с контейнерной функцией (узел уже работает, поэтому запуск новых экземпляров проходит чрезвычайно быстро).

## <a name="database-updates-and-migrations"></a>Обновление и миграция базы данных

Преимущество бессерверного кода заключается в возможности выпускать новые функции без необходимости повторно развертывать все приложение. Это преимущество может стать недостатком, если задействована реляционная база данных. Изменения в схемах баз данных трудно синхронизировать с обновлениями бессерверной модели. Дополнительные трудности возникают при сбоях, когда необходимо откатить изменения. Целостность данных — одна из причин, по которой в микрослужбах и бессерверных функциях рекомендуется использовать собственные данные. Изменения можно развернуть как единую единицу вычислений и данных. В действительности у многих устаревших систем есть большая серверная база данных, которую необходимо согласовывать с бессерверной архитектурой.

Самый распространенный подход к управлению версиями схемы заключается в том, чтобы не изменять существующие свойства и столбцы, а вместо этого добавлять новые сведения. Например, рассмотрите переход с логического флага завершения для списка дел на флаг даты завершения. Вместо удаления старого поля нужно будет изменить базу данных следующим образом:

1. Добавьте новое поле даты завершения.
1. Преобразуйте логическое поле завершения в вычисляемую функцию, которая будет оценивать, наступает ли дата завершения после текущей даты.
1. Добавьте триггер, устанавливающий для даты завершения текущую дату, когда для логического значения завершения задано значение true.

Последовательность изменений гарантирует, что устаревший код продолжит выполняться "как есть", а новые бессерверные функции смогут использовать новое поле.

Дополнительные сведения о данных в бессерверных архитектурах см. в статье [Распределенное управление данными: проблемы и решения](../microservices/architect-microservice-container-applications/distributed-data-management.md).

## <a name="scaling"></a>Масштабирование

То, что бессерверная архитектура значит отсутствие сервера, — распространенное заблуждение. На самом деле это значит, что сервер используется меньше. Фактически наличие резервной инфраструктуры играет важную роль при масштабировании. Большинство бессерверных платформ предусматривают набор элементов управления, позволяющих контролировать способ масштабирования инфраструктуры при увеличении плотности событий. Вы можете выбрать один из различных вариантов, но в зависимости от функции стратегия может отличаться. Более того, функции обычно выполняются на связанном узле, поэтому у функций на одном и том же узле одинаковые параметры масштабирования. Следовательно необходимо организовать функции и продумать, какие из них разместить вместе, в зависимости от требований к масштабированию.

Правила часто определяют способ увеличения масштаба (ресурсов узла) и горизонтального масштабирования (увеличения количества экземпляров узла) на основе различных параметров. В качестве триггеров масштабирования можно использовать расписание, частоту запросов, загрузку ЦП и потребление памяти. Более высокая производительность зачастую стоит дороже. Менее затратные подходы с платой за использованные ресурсы могут не обеспечить быстрое масштабирование при внезапном увеличении частоты запросов. Необходимо сделать выбор между оплатой "страховой стоимости" и оплатой по мере использования с риском медленных ответов по причине внезапного роста спроса.

## <a name="monitoring-tracing-and-logging"></a>Мониторинг, трассировка и ведение журнала

Часто таким аспектом DevOps, как мониторинг приложений, пренебрегают после развертывания приложений. Стратегия мониторинга бессерверных функций крайне важна. Зачастую самая большая проблема — это корреляция (распознавание условий, когда пользователь вызывает несколько функций в рамках одного и того же взаимодействия). Большинство бессерверных платформ позволяют вести журнал консоли, который можно импортировать в сторонние средства. Есть также параметры для автоматизации сбора данных телеметрии, создания и отслеживания идентификаторов корреляции, а также отслеживания определенных действий для получения подробных сведений. Azure предусматривает расширенную [платформу Application Insights](https://docs.microsoft.com/azure/azure-functions/functions-monitoring) для мониторинга и анализа.

## <a name="inter-service-dependencies"></a>Зависимости между службами

В бессерверной архитектуре одни функции могут зависеть от других. На самом деле нередко в бессерверной архитектуре несколько служб вызывают друг друга в рамках одного взаимодействия или распределенной транзакции. Во избежание сильной взаимосвязи рекомендуется, чтобы службы не ссылались на друг друга напрямую. Прямые ссылки могут привести к значительному рефакторингу, если необходимо изменить конечную точку службы. Предлагаемое решение — обеспечить механизм обнаружения служб, например реестр, предоставляющий соответствующую конечную точку для типа запроса. Другое решение — использовать для обмена данными между службами такие службы обмена сообщениями, как очереди или разделы.

## <a name="managing-failure-and-providing-resiliency"></a>Управление сбоями и обеспечение устойчивости

Важно также рассмотреть *шаблон автоматического выключения*. Если по какой-либо причине происходит сбой службы, не рекомендуется многократно ее вызывать. Вместо этого вызывается альтернативная служба или возвращается сообщение до тех пор, пока не будет восстановлена работоспособность зависимой службы. В бессерверной архитектуре необходимо учесть стратегию управления зависимостями между службами и разрешения этих зависимостей.

Чтобы продолжать работать по шаблону автоматического выключения, службы должны быть не только устойчивыми, но и отказоустойчивыми. Отказоустойчивость означает возможность приложения продолжать работу даже после непредвиденных исключений или при обнаружении недопустимых состояний. Отказоустойчивость обычно является функцией самого кода, а ее написание определяет управление исключениями. Устойчивость предполагает возможность приложения восстанавливаться после сбоев. Управление устойчивостью часто осуществляется бессерверной платформой. У платформы должна быть возможность запуска нового экземпляра бессерверной функции на случай сбоя имеющегося. Платформа также должна обладать достаточным количеством интеллектуальных ресурсов, чтобы при сбое каждого нового экземпляра останавливать запуск новых экземпляров.

Дополнительные сведения см. в статье [Реализация шаблона размыкателя цепи](../microservices/implement-resilient-applications/implement-circuit-breaker-pattern.md).

## <a name="versioning-and-greenblue-deployments"></a>Управление версиями, а также "зеленые" и "синие" развертывания

Основным преимуществом бессерверных приложений является возможность обновления определенной функции без необходимости повторного развертывания всего приложения. Чтобы обновление было успешным, необходимо распределить версии функций так, чтобы службы, вызывающие функции, направлялись к правильной версии кода. Стратегия развертывания новых версий также важна. Самый распространенный подход — использовать "зеленые" и "синие" развертывания. "Зеленое" развертывание — это текущая функция. Новая "синяя" версия развертывается в рабочей среде и тестируется. После тестирования "зеленые" и "синие" версии заменяются и используется новая версия. При возникновении каких-либо проблем эти версии можно вернуть обратно. Поддержка управления версиями, а также "зеленых" и "синих" развертываний, требует совмещения разработки функций, чтобы управлять изменением версий, и работы с бессерверной платформой для управления развертываниями. Один из возможных подходов — использование прокси-серверов, описанное в соответствующем разделе статьи [Azure Functions](azure-functions.md#proxies) (Функции Azure).

>[!div class="step-by-step"]
>[Назад](serverless-architecture.md)
>[Вперед](serverless-design-examples.md)
