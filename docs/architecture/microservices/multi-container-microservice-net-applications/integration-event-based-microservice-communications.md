---
title: Реализация взаимодействия между микрослужбами на основе событий (события интеграции)
description: Архитектура микрослужб .NET для контейнерных приложений .NET | События интеграции для реализации взаимодействия между микрослужбами на основе событий.
ms.date: 10/02/2018
ms.openlocfilehash: 8a1d4950247d63e5684c85c029efccf8269e7435
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2020
ms.locfileid: "80988327"
---
# <a name="implementing-event-based-communication-between-microservices-integration-events"></a><span data-ttu-id="cf899-103">Реализация взаимодействия между микрослужбами на основе событий (события интеграции)</span><span class="sxs-lookup"><span data-stu-id="cf899-103">Implementing event-based communication between microservices (integration events)</span></span>

<span data-ttu-id="cf899-104">Как было описано ранее, при обмене данными на основе событий микрослужба публикует событие, когда происходит что-то важное, например, когда она обновляет бизнес-объект.</span><span class="sxs-lookup"><span data-stu-id="cf899-104">As described earlier, when you use event-based communication, a microservice publishes an event when something notable happens, such as when it updates a business entity.</span></span> <span data-ttu-id="cf899-105">Другие микрослужбы подписываются на эти события.</span><span class="sxs-lookup"><span data-stu-id="cf899-105">Other microservices subscribe to those events.</span></span> <span data-ttu-id="cf899-106">Когда микрослужба получает событие, она может обновить свои собственные бизнес-объекты, что может привести к публикации дополнительных событий.</span><span class="sxs-lookup"><span data-stu-id="cf899-106">When a microservice receives an event, it can update its own business entities, which might lead to more events being published.</span></span> <span data-ttu-id="cf899-107">Это суть концепции итоговой согласованности.</span><span class="sxs-lookup"><span data-stu-id="cf899-107">This is the essence of the eventual consistency concept.</span></span> <span data-ttu-id="cf899-108">Эта система публикаций и подписок обычно реализуется с помощью шины событий.</span><span class="sxs-lookup"><span data-stu-id="cf899-108">This publish/subscribe system is usually performed by using an implementation of an event bus.</span></span> <span data-ttu-id="cf899-109">Шина событий может быть спроектирована как интерфейс с API, который необходим для подписки и отмены подписки на события и для публикации событий.</span><span class="sxs-lookup"><span data-stu-id="cf899-109">The event bus can be designed as an interface with the API needed to subscribe and unsubscribe to events and to publish events.</span></span> <span data-ttu-id="cf899-110">Шина событий может иметь одну или несколько реализаций на основе любого межпроцессорного обмена или обмена сообщениями, например очереди сообщений или служебной шины, поддерживающей асинхронное взаимодействие и модель публикаций и подписок.</span><span class="sxs-lookup"><span data-stu-id="cf899-110">It can also have one or more implementations based on any inter-process or messaging communication, such as a messaging queue or a service bus that supports asynchronous communication and a publish/subscribe model.</span></span>

<span data-ttu-id="cf899-111">События можно использовать для реализации бизнес-транзакций, которые охватывают несколько служб, что позволяет обеспечить итоговую согласованность между этими службами.</span><span class="sxs-lookup"><span data-stu-id="cf899-111">You can use events to implement business transactions that span multiple services, which gives you eventual consistency between those services.</span></span> <span data-ttu-id="cf899-112">Согласованная по принципу итоговой согласованности транзакция состоит из коллекции распределенных действий.</span><span class="sxs-lookup"><span data-stu-id="cf899-112">An eventually consistent transaction consists of a series of distributed actions.</span></span> <span data-ttu-id="cf899-113">Для каждого действия микрослужба обновляет бизнес-объект и публикует событие, которое вызывает следующее действие.</span><span class="sxs-lookup"><span data-stu-id="cf899-113">At each action, the microservice updates a business entity and publishes an event that triggers the next action.</span></span> <span data-ttu-id="cf899-114">На рис. 6-18 ниже показано событие PriceUpdated, опубликованное с помощью шины событий, поэтому обновление цен распространяется на микрослужбу Basket и другие микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="cf899-114">Figure 6-18 below, shows a PriceUpdated event published through and event bus, so the price update is propagated to the Basket and other microservices.</span></span>

![Схема асинхронного взаимодействия на основе событий с помощью шины событий.](./media/integration-event-based-microservice-communications/event-driven-communication.png)

<span data-ttu-id="cf899-116">**Рис. 6-18**.</span><span class="sxs-lookup"><span data-stu-id="cf899-116">**Figure 6-18**.</span></span> <span data-ttu-id="cf899-117">Обмен данными под управлением событиями на основе шины событий</span><span class="sxs-lookup"><span data-stu-id="cf899-117">Event-driven communication based on an event bus</span></span>

<span data-ttu-id="cf899-118">В этом разделе описано, как реализовать такой обмен данными в .NET с помощью общего интерфейса шины событий, как показано на рис. 6-18.</span><span class="sxs-lookup"><span data-stu-id="cf899-118">This section describes how you can implement this type of communication with .NET by using a generic event bus interface, as shown in Figure 6-18.</span></span> <span data-ttu-id="cf899-119">Существует несколько потенциальных реализаций, в каждой из которых используются собственные технологии или инфраструктуры, например RabbitMQ, служебная шина Azure или любые другие сторонние реализации служебной шины, коммерческие или с открытым исходным кодом.</span><span class="sxs-lookup"><span data-stu-id="cf899-119">There are multiple potential implementations, each using a different technology or infrastructure such as RabbitMQ, Azure Service Bus, or any other third-party open-source or commercial service bus.</span></span>

## <a name="using-message-brokers-and-services-buses-for-production-systems"></a><span data-ttu-id="cf899-120">Использование брокеров сообщений и служебных шин для систем в рабочей среде</span><span class="sxs-lookup"><span data-stu-id="cf899-120">Using message brokers and services buses for production systems</span></span>

<span data-ttu-id="cf899-121">Как упоминалось в разделе об архитектуре, для реализации абстрактной шины событий можно выбрать одну из нескольких технологий обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="cf899-121">As noted in the architecture section, you can choose from multiple messaging technologies for implementing your abstract event bus.</span></span> <span data-ttu-id="cf899-122">Однако эти технологии находятся на разных уровнях.</span><span class="sxs-lookup"><span data-stu-id="cf899-122">But these technologies are at different levels.</span></span> <span data-ttu-id="cf899-123">Например, RabbitMQ, транспорт брокера обмена сообщениями, находится на более низком уровне по сравнению с коммерческими продуктами, такими как служебная шина Azure, NServiceBus, MassTransit или Brighter.</span><span class="sxs-lookup"><span data-stu-id="cf899-123">For instance, RabbitMQ, a messaging broker transport, is at a lower level than commercial products like Azure Service Bus, NServiceBus, MassTransit, or Brighter.</span></span> <span data-ttu-id="cf899-124">Большинство этих продуктов могут работать поверх RabbitMQ или служебной шины Azure.</span><span class="sxs-lookup"><span data-stu-id="cf899-124">Most of these products can work on top of either RabbitMQ or Azure Service Bus.</span></span> <span data-ttu-id="cf899-125">Выбор продукта зависит от количества функций и объема масштабирования, необходимых для вашего приложения.</span><span class="sxs-lookup"><span data-stu-id="cf899-125">Your choice of product depends on how many features and how much out-of-the-box scalability you need for your application.</span></span>

<span data-ttu-id="cf899-126">Для реализации шины событий, предназначенной только для демонстрации принципа работы и используемой в среде разработки, как было показано на примере eShopOnContainers, достаточно простой реализации на основе системы RabbitMQ, работающей в контейнере.</span><span class="sxs-lookup"><span data-stu-id="cf899-126">For implementing just an event bus proof-of-concept for your development environment, as in the eShopOnContainers sample, a simple implementation on top of RabbitMQ running as a container might be enough.</span></span> <span data-ttu-id="cf899-127">Однако для создания критически важных систем и систем в рабочей среде с высокой масштабируемостью может потребоваться оценить и использовать служебную шину Azure.</span><span class="sxs-lookup"><span data-stu-id="cf899-127">But for mission-critical and production systems that need high scalability, you might want to evaluate and use Azure Service Bus.</span></span>

<span data-ttu-id="cf899-128">Если вам необходима абстракция более высокого уровня и более широкий набор функций, например [Sagas](https://docs.particular.net/nservicebus/sagas/) для длительных рабочих процессов, которые упрощают распределенную разработку, можете воспользоваться другими коммерческими и открытыми реализациями служебной шины, например NServiceBus, MassTransit и Brighter.</span><span class="sxs-lookup"><span data-stu-id="cf899-128">If you require high-level abstractions and richer features like [Sagas](https://docs.particular.net/nservicebus/sagas/) for long-running processes that make distributed development easier, other commercial and open-source service buses like NServiceBus, MassTransit, and Brighter are worth evaluating.</span></span> <span data-ttu-id="cf899-129">В этом случае обычно используются не ваши собственные абстракции, а абстракции и API, предоставляемые этими решениями высокого уровня (например, [абстракции простой шины событий в eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/BuildingBlocks/EventBus/EventBus/Abstractions/IEventBus.cs)).</span><span class="sxs-lookup"><span data-stu-id="cf899-129">In this case, the abstractions and API to use would usually be directly the ones provided by those high-level service buses instead of your own abstractions (like the [simple event bus abstractions provided at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/BuildingBlocks/EventBus/EventBus/Abstractions/IEventBus.cs)).</span></span> <span data-ttu-id="cf899-130">Поэтому можете обратиться к [вилке проекта eShopOnContainers, в которой используется NServiceBus](https://go.particular.net/eShopOnContainers) (дополнительный производный пример, реализованный Particular Software).</span><span class="sxs-lookup"><span data-stu-id="cf899-130">For that matter, you can research the [forked eShopOnContainers using NServiceBus](https://go.particular.net/eShopOnContainers) (additional derived sample implemented by Particular Software).</span></span>

<span data-ttu-id="cf899-131">Конечно, вы всегда можете создать собственные функции служебной шины на основе низкоуровневых технологий, таких как RabbitMQ и Docker, но объем работы, необходимой для того, чтобы "изобрести велосипед", может быть слишком большим для пользовательского корпоративного приложения.</span><span class="sxs-lookup"><span data-stu-id="cf899-131">Of course, you could always build your own service bus features on top of lower-level technologies like RabbitMQ and Docker, but the work needed to "reinvent the wheel" might be too costly for a custom enterprise application.</span></span>

<span data-ttu-id="cf899-132">Повторюсь: абстракции и реализации в примере шины событий, показанные в примере eShopOnContainers, предназначены только для подтверждения концепции.</span><span class="sxs-lookup"><span data-stu-id="cf899-132">To reiterate: the sample event bus abstractions and implementation showcased in the eShopOnContainers sample are intended to be used only as a proof of concept.</span></span> <span data-ttu-id="cf899-133">Если вы решите, что вам нужно асинхронное взаимодействие на основе событий, как описано в этой статье, выберите продукт служебной шины, который лучше всего соответствует вашим потребностям для рабочей среды.</span><span class="sxs-lookup"><span data-stu-id="cf899-133">Once you have decided that you want to have asynchronous and event-driven communication, as explained in the current section, you should choose the service bus product that best fits your needs for production.</span></span>

## <a name="integration-events"></a><span data-ttu-id="cf899-134">События интеграции</span><span class="sxs-lookup"><span data-stu-id="cf899-134">Integration events</span></span>

<span data-ttu-id="cf899-135">События интеграции используются для синхронизации состояния домена между несколькими микрослужбами или внешними системами.</span><span class="sxs-lookup"><span data-stu-id="cf899-135">Integration events are used for bringing domain state in sync across multiple microservices or external systems.</span></span> <span data-ttu-id="cf899-136">Это достигается путем публикации событий интеграции за границы микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="cf899-136">This is done by publishing integration events outside the microservice.</span></span> <span data-ttu-id="cf899-137">При публикации события в нескольких микрослужбах-получателях (в тех микрослужбах, которые подписаны на события интеграции), соответствующий обработчик событий в каждой микрослужбе-получателе обрабатывает событие.</span><span class="sxs-lookup"><span data-stu-id="cf899-137">When an event is published to multiple receiver microservices (to as many microservices as are subscribed to the integration event), the appropriate event handler in each receiver microservice handles the event.</span></span>

<span data-ttu-id="cf899-138">Событие интеграции по сути представляет собой класс для хранения данных, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="cf899-138">An integration event is basically a data-holding class, as in the following example:</span></span>

```csharp
public class ProductPriceChangedIntegrationEvent : IntegrationEvent
{
    public int ProductId { get; private set; }
    public decimal NewPrice { get; private set; }
    public decimal OldPrice { get; private set; }

    public ProductPriceChangedIntegrationEvent(int productId, decimal newPrice,
        decimal oldPrice)
    {
        ProductId = productId;
        NewPrice = newPrice;
        OldPrice = oldPrice;
    }
}
```

<span data-ttu-id="cf899-139">События интеграции можно определить на уровне приложения для каждой микрослужбы, поэтому они отделены от других микрослужб примерно так же, как модели представления разделены на сервере и на клиенте.</span><span class="sxs-lookup"><span data-stu-id="cf899-139">The integration events can be defined at the application level of each microservice, so they are decoupled from other microservices, in a way comparable to how ViewModels are defined in the server and client.</span></span> <span data-ttu-id="cf899-140">Не рекомендуется использовать общую библиотеку событий интеграции для нескольких микрослужб; это может привести к связыванию этих микрослужб с одной библиотекой данных для определения событий.</span><span class="sxs-lookup"><span data-stu-id="cf899-140">What is not recommended is sharing a common integration events library across multiple microservices; doing that would be coupling those microservices with a single event definition data library.</span></span> <span data-ttu-id="cf899-141">Это нежелательно по тем же причинам, по которым нежелательно использовать общую модель предметной области для нескольких микрослужб — микрослужбы должны быть полностью автономными.</span><span class="sxs-lookup"><span data-stu-id="cf899-141">You do not want to do that for the same reasons that you do not want to share a common domain model across multiple microservices: microservices must be completely autonomous.</span></span>

<span data-ttu-id="cf899-142">Существует всего несколько видов библиотек, которые должны быть общими для микрослужб.</span><span class="sxs-lookup"><span data-stu-id="cf899-142">There are only a few kinds of libraries you should share across microservices.</span></span> <span data-ttu-id="cf899-143">Одна из таких библиотек — конечные блоки приложений, например [API клиента шины событий](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/BuildingBlocks/EventBus), как в eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="cf899-143">One is libraries that are final application blocks, like the [Event Bus client API](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/BuildingBlocks/EventBus), as in eShopOnContainers.</span></span> <span data-ttu-id="cf899-144">Другие — библиотеки, предоставляющие инструменты, которые можно совместно использовать как компоненты NuGet, например сериализаторы JSON.</span><span class="sxs-lookup"><span data-stu-id="cf899-144">Another is libraries that constitute tools that could also be shared as NuGet components, like JSON serializers.</span></span>

## <a name="the-event-bus"></a><span data-ttu-id="cf899-145">Шина событий</span><span class="sxs-lookup"><span data-stu-id="cf899-145">The event bus</span></span>

<span data-ttu-id="cf899-146">Шина событий позволяет осуществлять обмен данными между микрослужбами с помощью механизма публикации и подписки, при котором компоненты могут явно не взаимодействовать друг с другом, как показано на рис. 6-19.</span><span class="sxs-lookup"><span data-stu-id="cf899-146">An event bus allows publish/subscribe-style communication between microservices without requiring the components to explicitly be aware of each other, as shown in Figure 6-19.</span></span>

![Схема, на которой показан базовый шаблон публикации и подписки.](./media/integration-event-based-microservice-communications/publish-subscribe-basics.png)

<span data-ttu-id="cf899-148">**Рис. 6-19**.</span><span class="sxs-lookup"><span data-stu-id="cf899-148">**Figure 6-19**.</span></span> <span data-ttu-id="cf899-149">Основные сведения о шине событий с использованием механизма публикации и подписки</span><span class="sxs-lookup"><span data-stu-id="cf899-149">Publish/subscribe basics with an event bus</span></span>

<span data-ttu-id="cf899-150">На схеме выше показано, что микрослужба A выполняет публикацию в шину событий, которая распределяет сообщения подписчикам — микрослужбам B и C, а издателю при этом не обязательно знать о подписчиках.</span><span class="sxs-lookup"><span data-stu-id="cf899-150">The above diagram shows that microservice A publishes to Event Bus, which distributes to subscribing microservices B and C, without the publisher needing to know the subscribers.</span></span> <span data-ttu-id="cf899-151">Шина событий связана с шаблоном наблюдателя и с шаблоном публикации и подписки.</span><span class="sxs-lookup"><span data-stu-id="cf899-151">The event bus is related to the Observer pattern and the publish-subscribe pattern.</span></span>

### <a name="observer-pattern"></a><span data-ttu-id="cf899-152">Шаблон наблюдателя</span><span class="sxs-lookup"><span data-stu-id="cf899-152">Observer pattern</span></span>

<span data-ttu-id="cf899-153">В [шаблоне наблюдателя](https://en.wikipedia.org/wiki/Observer_pattern) основной объект (наблюдаемый объект) передает другим объектам (наблюдателям) соответствующие данные (события).</span><span class="sxs-lookup"><span data-stu-id="cf899-153">In the [Observer pattern](https://en.wikipedia.org/wiki/Observer_pattern), your primary object (known as the Observable) notifies other interested objects (known as Observers) with relevant information (events).</span></span>

### <a name="publishsubscribe-pubsub-pattern"></a><span data-ttu-id="cf899-154">Шаблон публикации и подписки</span><span class="sxs-lookup"><span data-stu-id="cf899-154">Publish/Subscribe (Pub/Sub) pattern</span></span>

<span data-ttu-id="cf899-155">Назначение [шаблона публикации и подписки](https://docs.microsoft.com/previous-versions/msp-n-p/ff649664(v=pandp.10)) — точно такое же, как у шаблона наблюдателя: уведомлять другие службы при возникновении определенных событий.</span><span class="sxs-lookup"><span data-stu-id="cf899-155">The purpose of the [Publish/Subscribe pattern](https://docs.microsoft.com/previous-versions/msp-n-p/ff649664(v=pandp.10)) is the same as the Observer pattern: you want to notify other services when certain events take place.</span></span> <span data-ttu-id="cf899-156">Однако между шаблоном наблюдателя и шаблоном публикации и подписки есть важное различие.</span><span class="sxs-lookup"><span data-stu-id="cf899-156">But there is an important difference between the Observer and Pub/Sub patterns.</span></span> <span data-ttu-id="cf899-157">В шаблоне наблюдателя широковещательная рассылка осуществляется напрямую из наблюдаемого объекта наблюдателям, поэтому они "знают" друг друга.</span><span class="sxs-lookup"><span data-stu-id="cf899-157">In the observer pattern, the broadcast is performed directly from the observable to the observers, so they "know" each other.</span></span> <span data-ttu-id="cf899-158">При использовании шаблона публикации и подписки существует третий компонент — брокер, брокер сообщений или служебная шина. Этот компонент известен как издателю, так и подписчику.</span><span class="sxs-lookup"><span data-stu-id="cf899-158">But when using a Pub/Sub pattern, there is a third component, called broker or message broker or event bus, which is known by both the publisher and subscriber.</span></span> <span data-ttu-id="cf899-159">Таким образом, при использовании шаблон публикации и подписки явным образом разделены благодаря упомянутой шине событий или брокеру сообщений.</span><span class="sxs-lookup"><span data-stu-id="cf899-159">Therefore, when using the Pub/Sub pattern the publisher and the subscribers are precisely decoupled thanks to the mentioned event bus or message broker.</span></span>

### <a name="the-middleman-or-event-bus"></a><span data-ttu-id="cf899-160">Шина событий, или посредник</span><span class="sxs-lookup"><span data-stu-id="cf899-160">The middleman or event bus</span></span>

<span data-ttu-id="cf899-161">Как обеспечить анонимность между издателем и подписчиком?</span><span class="sxs-lookup"><span data-stu-id="cf899-161">How do you achieve anonymity between publisher and subscriber?</span></span> <span data-ttu-id="cf899-162">Самый простой способ — возложить весь обмен данными на посредника.</span><span class="sxs-lookup"><span data-stu-id="cf899-162">An easy way is let a middleman take care of all the communication.</span></span> <span data-ttu-id="cf899-163">Одним из таких посредников является шина событий.</span><span class="sxs-lookup"><span data-stu-id="cf899-163">An event bus is one such middleman.</span></span>

<span data-ttu-id="cf899-164">Шина событий обычно состоит из двух частей:</span><span class="sxs-lookup"><span data-stu-id="cf899-164">An event bus is typically composed of two parts:</span></span>

- <span data-ttu-id="cf899-165">Абстракция или интерфейс.</span><span class="sxs-lookup"><span data-stu-id="cf899-165">The abstraction or interface.</span></span>

- <span data-ttu-id="cf899-166">Одна или несколько реализаций.</span><span class="sxs-lookup"><span data-stu-id="cf899-166">One or more implementations.</span></span>

<span data-ttu-id="cf899-167">На рис. 6-19 вы видите, что, с точки зрения приложения, шина событий — не что иное, как канал публикации и подписки.</span><span class="sxs-lookup"><span data-stu-id="cf899-167">In Figure 6-19 you can see how, from an application point of view, the event bus is nothing more than a Pub/Sub channel.</span></span> <span data-ttu-id="cf899-168">Реализовать этот асинхронный обмен данными можно различными способами.</span><span class="sxs-lookup"><span data-stu-id="cf899-168">The way you implement this asynchronous communication can vary.</span></span> <span data-ttu-id="cf899-169">Он может иметь несколько реализаций, и вы можете переключаться между ними в зависимости от требований к среде (например, к рабочей среде по сравнению со средой разработки).</span><span class="sxs-lookup"><span data-stu-id="cf899-169">It can have multiple implementations so that you can swap between them, depending on the environment requirements (for example, production versus development environments).</span></span>

<span data-ttu-id="cf899-170">На рис. 6-20 показана абстракция шины событий с несколькими реализациями для различных технологий обмена сообщениями, таких как RabbitMQ, служебная шина Azure или другой брокер событий или брокер сообщений.</span><span class="sxs-lookup"><span data-stu-id="cf899-170">In Figure 6-20 you can see an abstraction of an event bus with multiple implementations based on infrastructure messaging technologies like RabbitMQ, Azure Service Bus, or another event/message broker.</span></span>

![Схема, на которой показано добавление уровня абстракции для шины событий.](./media/integration-event-based-microservice-communications/multiple-implementations-event-bus.png)

<span data-ttu-id="cf899-172">**Рис. 6-20.**</span><span class="sxs-lookup"><span data-stu-id="cf899-172">**Figure 6- 20.**</span></span> <span data-ttu-id="cf899-173">Несколько реализаций шины событий</span><span class="sxs-lookup"><span data-stu-id="cf899-173">Multiple implementations of an event bus</span></span>

<span data-ttu-id="cf899-174">Рекомендуется определить шину событий через интерфейс, чтобы ее можно было реализовать с помощью нескольких технологий, например служебной шины Azure RabbitMQ и других.</span><span class="sxs-lookup"><span data-stu-id="cf899-174">It's good to have the event bus defined through an interface so it can be implemented with several technologies, like RabbitMQ Azure Service bus or others.</span></span> <span data-ttu-id="cf899-175">Тем не менее, как упоминалось ранее, использование собственных абстракций (интерфейса шины событий) разумно только в том случае, если вам нужны базовые функции шины событий, поддерживаемые вашими абстракциями.</span><span class="sxs-lookup"><span data-stu-id="cf899-175">However, and as mentioned previously, using your own abstractions (the event bus interface) is good only if you need basic event bus features supported by your abstractions.</span></span> <span data-ttu-id="cf899-176">Если требуется более широкий набор функций, следует использовать API и абстракции, предоставляемые используемой коммерческой служебной шиной вместо собственных абстракций.</span><span class="sxs-lookup"><span data-stu-id="cf899-176">If you need richer service bus features, you should probably use the API and abstractions provided by your preferred commercial service bus instead of your own abstractions.</span></span>

### <a name="defining-an-event-bus-interface"></a><span data-ttu-id="cf899-177">Определение интерфейса шины событий</span><span class="sxs-lookup"><span data-stu-id="cf899-177">Defining an event bus interface</span></span>

<span data-ttu-id="cf899-178">Давайте начнем с реализации кода для интерфейса шины событий и возможных реализаций для целей исследования.</span><span class="sxs-lookup"><span data-stu-id="cf899-178">Let's start with some implementation code for the event bus interface and possible implementations for exploration purposes.</span></span> <span data-ttu-id="cf899-179">Интерфейс должен быть универсальным и простым, как и следующий интерфейс.</span><span class="sxs-lookup"><span data-stu-id="cf899-179">The interface should be generic and straightforward, as in the following interface.</span></span>

```csharp
public interface IEventBus
{
    void Publish(IntegrationEvent @event);

    void Subscribe<T, TH>()
        where T : IntegrationEvent
        where TH : IIntegrationEventHandler<T>;

    void SubscribeDynamic<TH>(string eventName)
        where TH : IDynamicIntegrationEventHandler;

    void UnsubscribeDynamic<TH>(string eventName)
        where TH : IDynamicIntegrationEventHandler;

    void Unsubscribe<T, TH>()
        where TH : IIntegrationEventHandler<T>
        where T : IntegrationEvent;
}
```

<span data-ttu-id="cf899-180">Метод `Publish` достаточно прост.</span><span class="sxs-lookup"><span data-stu-id="cf899-180">The `Publish` method is straightforward.</span></span> <span data-ttu-id="cf899-181">Шина событий передает полученное событие интеграции всем микрослужбам и даже внешним приложениям, которые подписаны на это событие.</span><span class="sxs-lookup"><span data-stu-id="cf899-181">The event bus will broadcast the integration event passed to it to any microservice, or even an external application, subscribed to that event.</span></span> <span data-ttu-id="cf899-182">Этот метод используется микрослужбой, которая публикует событие.</span><span class="sxs-lookup"><span data-stu-id="cf899-182">This method is used by the microservice that is publishing the event.</span></span>

<span data-ttu-id="cf899-183">Методы `Subscribe` (возможны различные реализации в зависимости от аргументов) используются микрослужбами, которые хотят получать события.</span><span class="sxs-lookup"><span data-stu-id="cf899-183">The `Subscribe` methods (you can have several implementations depending on the arguments) are used by the microservices that want to receive events.</span></span> <span data-ttu-id="cf899-184">У этого метода есть два аргумента.</span><span class="sxs-lookup"><span data-stu-id="cf899-184">This method has two arguments.</span></span> <span data-ttu-id="cf899-185">Первый — это событие интеграции, на которое он подписан (`IntegrationEvent`).</span><span class="sxs-lookup"><span data-stu-id="cf899-185">The first is the integration event to subscribe to (`IntegrationEvent`).</span></span> <span data-ttu-id="cf899-186">Второй аргумент — обработчик события интеграции (или метод обратного вызова) с именем `IIntegrationEventHandler<T>`, который будет выполнен, когда микрослужба-получатель получит сообщение об этом событии интеграции.</span><span class="sxs-lookup"><span data-stu-id="cf899-186">The second argument is the integration event handler (or callback method), named `IIntegrationEventHandler<T>`, to be executed when the receiver microservice gets that integration event message.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="cf899-187">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="cf899-187">Additional resources</span></span>

<span data-ttu-id="cf899-188">Некоторые решения для обмена сообщениями, готовые для рабочей среды:</span><span class="sxs-lookup"><span data-stu-id="cf899-188">Some production-ready messaging solutions:</span></span>

- <span data-ttu-id="cf899-189">**Служебная шина Azure** </span><span class="sxs-lookup"><span data-stu-id="cf899-189">**Azure Service Bus** </span></span>\
  <https://docs.microsoft.com/azure/service-bus-messaging/>
  
- <span data-ttu-id="cf899-190">**NServiceBus** </span><span class="sxs-lookup"><span data-stu-id="cf899-190">**NServiceBus** </span></span>\
  <https://particular.net/nservicebus>
  
- <span data-ttu-id="cf899-191">**MassTransit** </span><span class="sxs-lookup"><span data-stu-id="cf899-191">**MassTransit** </span></span>\
  <https://masstransit-project.com/>

> [!div class="step-by-step"]
> <span data-ttu-id="cf899-192">[Назад](database-server-container.md)
> [Вперед](rabbitmq-event-bus-development-test-environment.md)</span><span class="sxs-lookup"><span data-stu-id="cf899-192">[Previous](database-server-container.md)
[Next](rabbitmq-event-bus-development-test-environment.md)</span></span>
