---
title: События предметной области. Проектирование и реализация
description: Архитектура микрослужб .NET для контейнерных приложений .NET | Подробный обзор событий предметной области, ключевая концепция для установления связи между агрегатами.
ms.date: 10/08/2018
ms.openlocfilehash: 0cc2072408e110d94b47bd47a9c337a604d4c1a3
ms.sourcegitcommit: e0803b8975d3eb12e735a5d07637020dd6dac5ef
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/01/2020
ms.locfileid: "89271780"
---
# <a name="domain-events-design-and-implementation"></a><span data-ttu-id="f6d64-104">События предметной области: проектирование и реализация</span><span class="sxs-lookup"><span data-stu-id="f6d64-104">Domain events: design and implementation</span></span>

<span data-ttu-id="f6d64-105">События предметной области позволяют явным образом реализовывать побочные эффекты изменений в предметной области.</span><span class="sxs-lookup"><span data-stu-id="f6d64-105">Use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="f6d64-106">Другими словами и согласно терминологии DDD, события предметной области используются для явной реализации побочных эффектов между несколькими агрегатами.</span><span class="sxs-lookup"><span data-stu-id="f6d64-106">In other words, and using DDD terminology, use domain events to explicitly implement side effects across multiple aggregates.</span></span> <span data-ttu-id="f6d64-107">Кроме того, итоговая согласованность между агрегатами в рамках одной предметной области обеспечивает улучшенную масштабируемость и оказывает меньшее воздействие на блокировки базы данных.</span><span class="sxs-lookup"><span data-stu-id="f6d64-107">Optionally, for better scalability and less impact in database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="what-is-a-domain-event"></a><span data-ttu-id="f6d64-108">Что такое событие предметной области?</span><span class="sxs-lookup"><span data-stu-id="f6d64-108">What is a domain event?</span></span>

<span data-ttu-id="f6d64-109">Событие — это то, что произошло в прошлом.</span><span class="sxs-lookup"><span data-stu-id="f6d64-109">An event is something that has happened in the past.</span></span> <span data-ttu-id="f6d64-110">Событие предметной области — это то, что произошло в предметной области и о чем вы хотите уведомить остальные части той же предметной области (внутрипроцессно).</span><span class="sxs-lookup"><span data-stu-id="f6d64-110">A domain event is, something that happened in the domain that you want other parts of the same domain (in-process) to be aware of.</span></span> <span data-ttu-id="f6d64-111">Обычно уведомленные части каким-то образом реагируют на события.</span><span class="sxs-lookup"><span data-stu-id="f6d64-111">The notified parts usually react somehow to the events.</span></span>

<span data-ttu-id="f6d64-112">Важное преимущество событий предметной области в том, что побочные эффекты можно выразить явно.</span><span class="sxs-lookup"><span data-stu-id="f6d64-112">An important benefit of domain events is that side effects can be expressed explicitly.</span></span>

<span data-ttu-id="f6d64-113">Например, если вы используете Entity Framework и на какое-то событие должна быть реакция, вы вставите нужный код рядом с тем, что активирует событие.</span><span class="sxs-lookup"><span data-stu-id="f6d64-113">For example, if you're just using Entity Framework and there has to be a reaction to some event, you would probably code whatever you need close to what triggers the event.</span></span> <span data-ttu-id="f6d64-114">Так что правило неявно привязывается к коду, и вам нужно заглянуть в код, чтобы, будем надеяться, понять, что правило реализовано там.</span><span class="sxs-lookup"><span data-stu-id="f6d64-114">So the rule gets coupled, implicitly, to the code, and you have to look into the code to, hopefully, realize the rule is implemented there.</span></span>

<span data-ttu-id="f6d64-115">С другой стороны, при использовании событий предметной области эта концепция становится явной, так как в этом участвует `DomainEvent` и по крайней мере один `DomainEventHandler`.</span><span class="sxs-lookup"><span data-stu-id="f6d64-115">On the other hand, using domain events makes the concept explicit, because there is a `DomainEvent` and at least one `DomainEventHandler` involved.</span></span>

<span data-ttu-id="f6d64-116">Например, в приложении eShopOnContainers при создании заказа пользователь становится покупателем, поэтому `OrderStartedDomainEvent` возникает и обрабатывается в `ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler`, так что базовая концепция очевидна.</span><span class="sxs-lookup"><span data-stu-id="f6d64-116">For example, in the eShopOnContainers application, when an order is created, the user becomes a buyer, so an `OrderStartedDomainEvent` is raised and handled in the `ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler`, so the underlying concept is evident.</span></span>

<span data-ttu-id="f6d64-117">Вкратце, события предметной области помогают явно выразить правила предметной области в соответствии с единым языком, предоставляемым специалистами в предметной области.</span><span class="sxs-lookup"><span data-stu-id="f6d64-117">In short, domain events help you to express, explicitly, the domain rules, based in the ubiquitous language provided by the domain experts.</span></span> <span data-ttu-id="f6d64-118">События предметной области также обеспечивают лучшее разделение задач между классами в одной предметной области.</span><span class="sxs-lookup"><span data-stu-id="f6d64-118">Domain events also enable a better separation of concerns among classes within the same domain.</span></span>

<span data-ttu-id="f6d64-119">Важно убедиться, что, как и с транзакцией в базе данных, либо все операции, относящиеся к событию предметной области, завершаются успешно, либо ни одно из них.</span><span class="sxs-lookup"><span data-stu-id="f6d64-119">It's important to ensure that, just like a database transaction, either all the operations related to a domain event finish successfully or none of them do.</span></span>

<span data-ttu-id="f6d64-120">События предметной области похожи на события в стиле обмена сообщениями, с одним важным отличием.</span><span class="sxs-lookup"><span data-stu-id="f6d64-120">Domain events are similar to messaging-style events, with one important difference.</span></span> <span data-ttu-id="f6d64-121">В реальной системе обмена сообщениями, с очередями сообщений, посредниками или служебной шиной, использующей AMQP, сообщение всегда отправляется в асинхронном режиме и передается между процессами и компьютерами.</span><span class="sxs-lookup"><span data-stu-id="f6d64-121">With real messaging, message queuing, message brokers, or a service bus using AMQP, a message is always sent asynchronously and communicated across processes and machines.</span></span> <span data-ttu-id="f6d64-122">Это полезно для интеграции нескольких ограниченных контекстов, микрослужб или даже разных приложений.</span><span class="sxs-lookup"><span data-stu-id="f6d64-122">This is useful for integrating multiple Bounded Contexts, microservices, or even different applications.</span></span> <span data-ttu-id="f6d64-123">Однако в случае с событиями предметной области существует ситуация, когда вы хотите вызвать событие из выполняемой в данный момент операции предметной области, но вам нужно, чтобы любые побочные эффекты возникали в пределах той же предметной области.</span><span class="sxs-lookup"><span data-stu-id="f6d64-123">However, with domain events, you want to raise an event from the domain operation you are currently running, but you want any side effects to occur within the same domain.</span></span>

<span data-ttu-id="f6d64-124">События предметной области и их побочные эффекты (запускаемые впоследствии действия, управляемые обработчиками событий) должны происходить практически немедленно, обычно в рамках процесса и в одной предметной области.</span><span class="sxs-lookup"><span data-stu-id="f6d64-124">The domain events and their side effects (the actions triggered afterwards that are managed by event handlers) should occur almost immediately, usually in-process, and within the same domain.</span></span> <span data-ttu-id="f6d64-125">Таким образом, события предметной области могут быть синхронными или асинхронными.</span><span class="sxs-lookup"><span data-stu-id="f6d64-125">Thus, domain events could be synchronous or asynchronous.</span></span> <span data-ttu-id="f6d64-126">Однако события интеграции всегда должны быть асинхронными.</span><span class="sxs-lookup"><span data-stu-id="f6d64-126">Integration events, however, should always be asynchronous.</span></span>

## <a name="domain-events-versus-integration-events"></a><span data-ttu-id="f6d64-127">События предметной области и события интеграции</span><span class="sxs-lookup"><span data-stu-id="f6d64-127">Domain events versus integration events</span></span>

<span data-ttu-id="f6d64-128">Семантически события предметной области и события интеграции представляют собой одно и то же: уведомления о том, что только что произошло.</span><span class="sxs-lookup"><span data-stu-id="f6d64-128">Semantically, domain and integration events are the same thing: notifications about something that just happened.</span></span> <span data-ttu-id="f6d64-129">Но их реализации должны быть разными.</span><span class="sxs-lookup"><span data-stu-id="f6d64-129">However, their implementation must be different.</span></span> <span data-ttu-id="f6d64-130">События предметной области — это просто сообщения, отправляемые диспетчеру событий предметной области, который может быть реализован в виде посредника в памяти на основе контейнера IoC или любого другого метода.</span><span class="sxs-lookup"><span data-stu-id="f6d64-130">Domain events are just messages pushed to a domain event dispatcher, which could be implemented as an in-memory mediator based on an IoC container or any other method.</span></span>

<span data-ttu-id="f6d64-131">С другой стороны, события интеграции предназначены для распространения зафиксированных транзакций и обновлений в дополнительные подсистемы независимо от того, являются ли они микрослужбами, ограниченными контекстами или даже внешними приложениями.</span><span class="sxs-lookup"><span data-stu-id="f6d64-131">On the other hand, the purpose of integration events is to propagate committed transactions and updates to additional subsystems, whether they are other microservices, Bounded Contexts or even external applications.</span></span> <span data-ttu-id="f6d64-132">Следовательно, они должны происходить только в случае успешного сохранения сущности, в противном случае дело обстоит так, будто вся операция не выполнялась.</span><span class="sxs-lookup"><span data-stu-id="f6d64-132">Hence, they should occur only if the entity is successfully persisted, otherwise it's as if the entire operation never happened.</span></span>

<span data-ttu-id="f6d64-133">Как уже упоминалось, события интеграции должны основываться на асинхронной связи между несколькими микрослужбами (другими ограниченными контекстами) или даже внешними системами или приложениями.</span><span class="sxs-lookup"><span data-stu-id="f6d64-133">As mentioned before, integration events must be based on asynchronous communication between multiple microservices (other Bounded Contexts) or even external systems/applications.</span></span>

<span data-ttu-id="f6d64-134">Таким образом, интерфейсу шины событий требуется некоторая инфраструктура, позволяющая осуществлять межпроцессное и распределенное взаимодействие между потенциально удаленными службами.</span><span class="sxs-lookup"><span data-stu-id="f6d64-134">Thus, the event bus interface needs some infrastructure that allows inter-process and distributed communication between potentially remote services.</span></span> <span data-ttu-id="f6d64-135">Ее основой могут быть коммерческая служебная шина, очереди, общая база данных, используемая в качестве почтового ящика, или любая другая распределенная и (в идеальном случае) основанная на push-уведомлениях система обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="f6d64-135">It can be based on a commercial service bus, queues, a shared database used as a mailbox, or any other distributed and ideally push based messaging system.</span></span>

## <a name="domain-events-as-a-preferred-way-to-trigger-side-effects-across-multiple-aggregates-within-the-same-domain"></a><span data-ttu-id="f6d64-136">События предметной области как предпочтительный способ вызова побочных эффектов между несколькими агрегатами в одной предметной области</span><span class="sxs-lookup"><span data-stu-id="f6d64-136">Domain events as a preferred way to trigger side effects across multiple aggregates within the same domain</span></span>

<span data-ttu-id="f6d64-137">Если для выполнения команды, относящейся к одному экземпляру агрегата, требуется запустить дополнительные правила предметной области в одном или нескольких дополнительных агрегатах, следует разработать и реализовать побочные эффекты, запускаемые событиями предметной области.</span><span class="sxs-lookup"><span data-stu-id="f6d64-137">If executing a command related to one aggregate instance requires additional domain rules to be run on one or more additional aggregates, you should design and implement those side effects to be triggered by domain events.</span></span> <span data-ttu-id="f6d64-138">Как показано на рис. 7-14, одним из наиболее важных вариантов использования событий предметной области является распространение изменений состояния между несколькими агрегатами в одной модели предметной области.</span><span class="sxs-lookup"><span data-stu-id="f6d64-138">As shown in Figure 7-14, and as one of the most important use cases, a domain event should be used to propagate state changes across multiple aggregates within the same domain model.</span></span>

![Схема, на которой показано событие предметной области, управляющее данными агрегата Buyer (Покупатель).](./media/domain-events-design-implementation/domain-model-ordering-microservice.png)

<span data-ttu-id="f6d64-140">**Рис. 7-14**.</span><span class="sxs-lookup"><span data-stu-id="f6d64-140">**Figure 7-14**.</span></span> <span data-ttu-id="f6d64-141">События предметной области для обеспечения согласованности между несколькими агрегатами в одной предметной области</span><span class="sxs-lookup"><span data-stu-id="f6d64-141">Domain events to enforce consistency between multiple aggregates within the same domain</span></span>

<span data-ttu-id="f6d64-142">На рис. 7-14 показано, как с помощью событий предметной области достигается согласованность между агрегатами.</span><span class="sxs-lookup"><span data-stu-id="f6d64-142">Figure 7-14 shows how consistency between aggregates is achieved by domain events.</span></span> <span data-ttu-id="f6d64-143">Когда пользователь оформляет заказ, агрегат Order (Заказ) отправляет событие предметной области `OrderStarted`.</span><span class="sxs-lookup"><span data-stu-id="f6d64-143">When the user initiates an order, the Order Aggregate sends an `OrderStarted` domain event.</span></span> <span data-ttu-id="f6d64-144">Событие предметной области OrderStarted обрабатывается агрегатом Buyer (Покупатель), который создает объект Buyer (Покупатель) в микрослужбе по работе с заказами на основе исходных сведений о пользователе из микрослужбы идентификации (со сведениями, указанными в команде CreateOrder).</span><span class="sxs-lookup"><span data-stu-id="f6d64-144">The OrderStarted domain event is handled by the Buyer Aggregate to create a Buyer object in the ordering microservice, based on the original user info from the identity microservice (with information provided in the CreateOrder command).</span></span>

<span data-ttu-id="f6d64-145">Кроме того, корень агрегата может быть подписан на события предметной области, вызываемые членами его агрегатов (дочерними сущностями).</span><span class="sxs-lookup"><span data-stu-id="f6d64-145">Alternately, you can have the aggregate root subscribed for events raised by members of its aggregates (child entities).</span></span> <span data-ttu-id="f6d64-146">Например, каждая дочерняя сущность OrderItem может вызвать событие, когда цена товара превышает определенное значение или когда количество товарных единиц слишком велико.</span><span class="sxs-lookup"><span data-stu-id="f6d64-146">For instance, each OrderItem child entity can raise an event when the item price is higher than a specific amount, or when the product item amount is too high.</span></span> <span data-ttu-id="f6d64-147">Затем корень агрегата может получать эти события и выполнять глобальные или статистические вычисления.</span><span class="sxs-lookup"><span data-stu-id="f6d64-147">The aggregate root can then receive those events and perform a global calculation or aggregation.</span></span>

<span data-ttu-id="f6d64-148">Важно понимать, что это взаимодействие на основе событий не реализуется непосредственно в агрегатах — необходимо реализовать обработчики событий предметной области.</span><span class="sxs-lookup"><span data-stu-id="f6d64-148">It is important to understand that this event-based communication is not implemented directly within the aggregates; you need to implement domain event handlers.</span></span>

<span data-ttu-id="f6d64-149">Обработкой событий предметной области занимается приложение.</span><span class="sxs-lookup"><span data-stu-id="f6d64-149">Handling the domain events is an application concern.</span></span> <span data-ttu-id="f6d64-150">Уровень модели предметной области должен концентрироваться только на логике предметной области — на вещах, которые будут понятны эксперту в предметной области, а не на компонентах инфраструктуры приложений, таких как обработчики и действия сохраняемости побочных эффектов с репозиториями.</span><span class="sxs-lookup"><span data-stu-id="f6d64-150">The domain model layer should only focus on the domain logic—things that a domain expert would understand, not application infrastructure like handlers and side-effect persistence actions using repositories.</span></span> <span data-ttu-id="f6d64-151">Таким образом, на уровне приложения находятся обработчики событий предметной области, запускающие действия при возникновении события предметной области.</span><span class="sxs-lookup"><span data-stu-id="f6d64-151">Therefore, the application layer level is where you should have domain event handlers triggering actions when a domain event is raised.</span></span>

<span data-ttu-id="f6d64-152">События предметной области могут также использоваться для запуска любого количества действий приложения и, что более важно, должны быть открытыми, чтобы увеличивать это количество в будущем независимо от каких-либо причин.</span><span class="sxs-lookup"><span data-stu-id="f6d64-152">Domain events can also be used to trigger any number of application actions, and what is more important, must be open to increase that number in the future in a decoupled way.</span></span> <span data-ttu-id="f6d64-153">Например, при запуске процесса заказа может потребоваться опубликовать событие предметной области для распространения этих данных в другие агрегаты или даже для вызова таких действий приложения, как уведомления.</span><span class="sxs-lookup"><span data-stu-id="f6d64-153">For instance, when the order is started, you might want to publish a domain event to propagate that info to other aggregates or even to raise application actions like notifications.</span></span>

<span data-ttu-id="f6d64-154">Основной момент здесь — открытое количество действий, которые будут выполняться при возникновении события домена.</span><span class="sxs-lookup"><span data-stu-id="f6d64-154">The key point is the open number of actions to be executed when a domain event occurs.</span></span> <span data-ttu-id="f6d64-155">В конечном итоге количество действий и правил в предметной области и приложении будет увеличиваться.</span><span class="sxs-lookup"><span data-stu-id="f6d64-155">Eventually, the actions and rules in the domain and application will grow.</span></span> <span data-ttu-id="f6d64-156">Сложность или количество действий побочных эффектов будет расти, но если фрагменты кода были дополнены связующим элементом (то есть созданием определенных объектов с `new`), то при каждом добавлении нового действия потребуется изменять рабочий и протестированный код.</span><span class="sxs-lookup"><span data-stu-id="f6d64-156">The complexity or number of side-effect actions when something happens will grow, but if your code were coupled with "glue" (that is, creating specific objects with `new`), then every time you needed to add a new action you would also need to change working and tested code.</span></span>

<span data-ttu-id="f6d64-157">Это изменение может привести к новым ошибкам, и этот подход также противоречит [принципу открытия-закрытия](https://en.wikipedia.org/wiki/Open/closed_principle) из [SOLID](https://en.wikipedia.org/wiki/SOLID).</span><span class="sxs-lookup"><span data-stu-id="f6d64-157">This change could result in new bugs and this approach also goes against the [Open/Closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) from [SOLID](https://en.wikipedia.org/wiki/SOLID).</span></span> <span data-ttu-id="f6d64-158">Кроме того, исходный класс, который управлял операциями, будет постоянно увеличиваться, что противоречит [принципу единственной обязанности (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span><span class="sxs-lookup"><span data-stu-id="f6d64-158">Not only that, the original class that was orchestrating the operations would grow and grow, which goes against the [Single Responsibility Principle (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span></span>

<span data-ttu-id="f6d64-159">С другой стороны, при использовании событий предметной области можно создать детальную и несвязанную реализацию путем разделения обязанностей с помощью приведенного далее подхода.</span><span class="sxs-lookup"><span data-stu-id="f6d64-159">On the other hand, if you use domain events, you can create a fine-grained and decoupled implementation by segregating responsibilities using this approach:</span></span>

1. <span data-ttu-id="f6d64-160">Отправка команды (например, CreateOrder).</span><span class="sxs-lookup"><span data-stu-id="f6d64-160">Send a command (for example, CreateOrder).</span></span>
2. <span data-ttu-id="f6d64-161">Получение команды в обработчике команд.</span><span class="sxs-lookup"><span data-stu-id="f6d64-161">Receive the command in a command handler.</span></span>
   - <span data-ttu-id="f6d64-162">Выполнение транзакции одного агрегата.</span><span class="sxs-lookup"><span data-stu-id="f6d64-162">Execute a single aggregate's transaction.</span></span>
   - <span data-ttu-id="f6d64-163">Вызов событий предметной области для побочных эффектов (например, OrderStartedDomainEvent) (необязательно).</span><span class="sxs-lookup"><span data-stu-id="f6d64-163">(Optional) Raise domain events for side effects (for example, OrderStartedDomainEvent).</span></span>
3. <span data-ttu-id="f6d64-164">Обработка событий предметной области (в рамках текущего процесса), которые будут выполнять открытое количество побочных эффектов в нескольких агрегатах или действиях приложения.</span><span class="sxs-lookup"><span data-stu-id="f6d64-164">Handle domain events (within the current process) that will execute an open number of side effects in multiple aggregates or application actions.</span></span> <span data-ttu-id="f6d64-165">Пример:</span><span class="sxs-lookup"><span data-stu-id="f6d64-165">For example:</span></span>
   - <span data-ttu-id="f6d64-166">Проверка или создание покупателя или метода оплаты.</span><span class="sxs-lookup"><span data-stu-id="f6d64-166">Verify or create buyer and payment method.</span></span>
   - <span data-ttu-id="f6d64-167">Создание и отправка связанного события интеграции в шину событий для распространения состояний в микрослужбах или запуска внешних действий, таких как отправка сообщения покупателю.</span><span class="sxs-lookup"><span data-stu-id="f6d64-167">Create and send a related integration event to the event bus to propagate states across microservices or trigger external actions like sending an email to the buyer.</span></span>
   - <span data-ttu-id="f6d64-168">Обработка других побочных эффектов.</span><span class="sxs-lookup"><span data-stu-id="f6d64-168">Handle other side effects.</span></span>

<span data-ttu-id="f6d64-169">Как показано на рис. 7-15, начиная с того же события предметной области, можно обрабатывать несколько действий, связанных с другими агрегатами в предметной области, или дополнительные действия приложения, которые необходимо выполнить в микрослужбах, взаимодействующих с событиями интеграции и шиной событий.</span><span class="sxs-lookup"><span data-stu-id="f6d64-169">As shown in Figure 7-15, starting from the same domain event, you can handle multiple actions related to other aggregates in the domain or additional application actions you need to perform across microservices connecting with integration events and the event bus.</span></span>

![Схема, на которой показано событие предметной области, передающее данные в несколько обработчиков событий.](./media/domain-events-design-implementation/aggregate-domain-event-handlers.png)

<span data-ttu-id="f6d64-171">**Рис. 7-15**.</span><span class="sxs-lookup"><span data-stu-id="f6d64-171">**Figure 7-15**.</span></span> <span data-ttu-id="f6d64-172">Обработка нескольких действий для каждой предметной области</span><span class="sxs-lookup"><span data-stu-id="f6d64-172">Handling multiple actions per domain</span></span>

<span data-ttu-id="f6d64-173">Может существовать несколько обработчиков для одного события предметной области на прикладном уровне: один обработчик может решать согласованность между агрегатами, а другой обработчик может публиковать событие интеграции, чтобы другие микрослужбы могли отреагировать.</span><span class="sxs-lookup"><span data-stu-id="f6d64-173">There can be several handlers for the same domain event in the Application Layer, one handler can solve consistency between aggregates and another handler can publish an integration event, so other microservices can do something with it.</span></span> <span data-ttu-id="f6d64-174">Обработчики событий обычно действуют на уровне приложения, так как для поведения микрослужбы будут использоваться такие объекты инфраструктуры, как репозитории или API приложения.</span><span class="sxs-lookup"><span data-stu-id="f6d64-174">The event handlers are typically in the application layer, because you will use infrastructure objects like repositories or an application API for the microservice's behavior.</span></span> <span data-ttu-id="f6d64-175">В этом смысле обработчики событий аналогичны обработчикам команд, поэтому оба этих типа являются частью уровня приложения.</span><span class="sxs-lookup"><span data-stu-id="f6d64-175">In that sense, event handlers are similar to command handlers, so both are part of the application layer.</span></span> <span data-ttu-id="f6d64-176">Важное отличие заключается в том, что команды должны обрабатываться только один раз.</span><span class="sxs-lookup"><span data-stu-id="f6d64-176">The important difference is that a command should be processed only once.</span></span> <span data-ttu-id="f6d64-177">Событие предметной области может не обрабатываться или обрабатываться *n* раз, так как его могут получать несколько получателей или обработчиков событий с разными для каждого обработчика целями.</span><span class="sxs-lookup"><span data-stu-id="f6d64-177">A domain event could be processed zero or *n* times, because it can be received by multiple receivers or event handlers with a different purpose for each handler.</span></span>

<span data-ttu-id="f6d64-178">Наличие открытого количества обработчиков для каждого события предметной области позволяет добавлять сколько угодно правил предметной области без влияния на текущий код.</span><span class="sxs-lookup"><span data-stu-id="f6d64-178">Having an open number of handlers per domain event allows you to add as many domain rules as needed, without affecting  current code.</span></span> <span data-ttu-id="f6d64-179">Например, реализация следующего бизнес-правила может сводиться к добавлению нескольких обработчиков событий (или даже всего одного):</span><span class="sxs-lookup"><span data-stu-id="f6d64-179">For instance, implementing the following business rule might be as easy as adding a few event handlers (or even just one):</span></span>

> <span data-ttu-id="f6d64-180">Если общая сумма товаров, приобретенных клиентом в магазине по любому количеству заказов, превышает 6000 USD, следует применять 10-процентную скидку к каждому новому заказу и уведомлять об этом клиента по электронной почте.</span><span class="sxs-lookup"><span data-stu-id="f6d64-180">When the total amount purchased by a customer in the store, across any number of orders, exceeds $6,000, apply a 10% off discount to every new order and notify the customer with an email about that discount for future orders.</span></span>

## <a name="implement-domain-events"></a><span data-ttu-id="f6d64-181">Реализация событий предметной области</span><span class="sxs-lookup"><span data-stu-id="f6d64-181">Implement domain events</span></span>

<span data-ttu-id="f6d64-182">В C# событие предметной области представляет собой структуру или класс хранения данных, например DTO, со всеми сведениями, связанными с действием, только что произошедшим в предметной области, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="f6d64-182">In C#, a domain event is simply a data-holding structure or class, like a DTO, with all the information related to what just happened in the domain, as shown in the following example:</span></span>

```csharp
public class OrderStartedDomainEvent : INotification
{
    public string UserId { get; }
    public int CardTypeId { get; }
    public string CardNumber { get; }
    public string CardSecurityNumber { get; }
    public string CardHolderName { get; }
    public DateTime CardExpiration { get; }
    public Order Order { get; }

    public OrderStartedDomainEvent(Order order,
                                   int cardTypeId, string cardNumber,
                                   string cardSecurityNumber, string cardHolderName,
                                   DateTime cardExpiration)
    {
        Order = order;
        CardTypeId = cardTypeId;
        CardNumber = cardNumber;
        CardSecurityNumber = cardSecurityNumber;
        CardHolderName = cardHolderName;
        CardExpiration = cardExpiration;
    }
}
```

<span data-ttu-id="f6d64-183">По сути, это класс, содержащий все данные, относящиеся к событию OrderStarted.</span><span class="sxs-lookup"><span data-stu-id="f6d64-183">This is essentially a class that holds all the data related to the OrderStarted event.</span></span>

<span data-ttu-id="f6d64-184">Если говорить единым языком предметной области, поскольку событием является то, что произошло в прошлом, имя класса события должно быть представлено с глаголом в прошедшем времени, например OrderStartedDomainEvent или OrderShippedDomainEvent.</span><span class="sxs-lookup"><span data-stu-id="f6d64-184">In terms of the ubiquitous language of the domain, since an event is something that happened in the past, the class name of the event should be represented as a past-tense verb, like OrderStartedDomainEvent or OrderShippedDomainEvent.</span></span> <span data-ttu-id="f6d64-185">Именно так событие предметной области реализуется в микрослужбе по оформлению заказов в eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="f6d64-185">That's how the domain event is implemented in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="f6d64-186">Как отмечалось ранее, важной характеристикой событий является его неизменяемость, так как это действие, которое произошло в прошлом.</span><span class="sxs-lookup"><span data-stu-id="f6d64-186">As noted earlier, an important characteristic of events is that since an event is something that happened in the past, it should not change.</span></span> <span data-ttu-id="f6d64-187">Поэтому событие должно быть неизменяемым классом.</span><span class="sxs-lookup"><span data-stu-id="f6d64-187">Therefore, it must be an immutable class.</span></span> <span data-ttu-id="f6d64-188">В предыдущем коде видно, что свойства доступны только для чтения.</span><span class="sxs-lookup"><span data-stu-id="f6d64-188">You can see in the previous code that the properties are read-only.</span></span> <span data-ttu-id="f6d64-189">Невозможно обновить объект, значения можно задать только при создании.</span><span class="sxs-lookup"><span data-stu-id="f6d64-189">There's no way to update the object, you can only set values when you create it.</span></span>

<span data-ttu-id="f6d64-190">Важно подчеркнуть, что, если события предметной области должны были бы обрабатываться асинхронно, с помощью очереди, которая требует сериализации и десериализации объектов событий, для свойств нужно было бы задать закрытую установку, а не режим "только для чтения", чтобы десериализатор смог назначать значения при выведении из очереди.</span><span class="sxs-lookup"><span data-stu-id="f6d64-190">It's important to highlight here that if domain events were to be handled asynchronously, using a queue that required serializing and deserializing the event objects, the properties would have to be "private set" instead of read-only, so the deserializer would be able to assign the values upon dequeuing.</span></span> <span data-ttu-id="f6d64-191">Это не проблема в микрослужбе заказов, поскольку событие публикации/подписки предметной области реализуется синхронно с помощью MediatR.</span><span class="sxs-lookup"><span data-stu-id="f6d64-191">This is not an issue in the Ordering microservice, as the domain event pub/sub is implemented synchronously using MediatR.</span></span>

### <a name="raise-domain-events"></a><span data-ttu-id="f6d64-192">Создание событий предметной области</span><span class="sxs-lookup"><span data-stu-id="f6d64-192">Raise domain events</span></span>

<span data-ttu-id="f6d64-193">Следующий вопрос в том, как инициировать событие предметной области, чтобы оно достигало соответствующих обработчиков событий.</span><span class="sxs-lookup"><span data-stu-id="f6d64-193">The next question is how to raise a domain event so it reaches its related event handlers.</span></span> <span data-ttu-id="f6d64-194">Можно использовать несколько способов.</span><span class="sxs-lookup"><span data-stu-id="f6d64-194">You can use multiple approaches.</span></span>

<span data-ttu-id="f6d64-195">Уди Дахан (Udi Dahan) изначально предложил (в нескольких тематических записях блога, таких как [Domain Events — Take 2](https://udidahan.com/2008/08/25/domain-events-take-2/) (События предметной области — два важных момента)) использовать статический класс для вызова событий и управления ими.</span><span class="sxs-lookup"><span data-stu-id="f6d64-195">Udi Dahan originally proposed (for example, in several related posts, such as [Domain Events – Take 2](https://udidahan.com/2008/08/25/domain-events-take-2/)) using a static class for managing and raising the events.</span></span> <span data-ttu-id="f6d64-196">Это может быть статический класс DomainEvents, который при вызове сразу же будет создавать события предметной области с помощью синтаксиса наподобие `DomainEvents.Raise(Event myEvent)`.</span><span class="sxs-lookup"><span data-stu-id="f6d64-196">This might include a static class named DomainEvents that would raise domain events immediately when it is called, using syntax like `DomainEvents.Raise(Event myEvent)`.</span></span> <span data-ttu-id="f6d64-197">Джимми Богард (Jimmy Bogard) написал статью ([Усиление предметной области: события предметной области](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)), где рекомендуется схожий подход.</span><span class="sxs-lookup"><span data-stu-id="f6d64-197">Jimmy Bogard wrote a blog post ([Strengthening your domain: Domain Events](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) that recommends a similar approach.</span></span>

<span data-ttu-id="f6d64-198">Однако если класс событий предметной области является статическим, он также немедленно отправляется обработчикам.</span><span class="sxs-lookup"><span data-stu-id="f6d64-198">However, when the domain events class is static, it also dispatches to handlers immediately.</span></span> <span data-ttu-id="f6d64-199">Это усложняет процедуры тестирования и отладки, поскольку обработчики событий с логикой побочных эффектов выполняются сразу же после возникновения события.</span><span class="sxs-lookup"><span data-stu-id="f6d64-199">This makes testing and debugging more difficult, because the event handlers with side-effects logic are executed immediately after the event is raised.</span></span> <span data-ttu-id="f6d64-200">Вполне очевидно, что во время тестирования и отладки необходимо концентрироваться только на том, что происходит в текущих агрегатных классах, а внезапное перенаправление на другие обработчики событий для побочных эффектов, связанных с другими агрегатами или логикой приложения, не приветствуется.</span><span class="sxs-lookup"><span data-stu-id="f6d64-200">When you are testing and debugging, you want to focus on and just what is happening in the current aggregate classes; you do not want to suddenly be redirected to other event handlers for side effects related to other aggregates or application logic.</span></span> <span data-ttu-id="f6d64-201">Именно поэтому были усовершенствованы другие подходы, как описано в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="f6d64-201">This is why other approaches have evolved, as explained in the next section.</span></span>

#### <a name="the-deferred-approach-to-raise-and-dispatch-events"></a><span data-ttu-id="f6d64-202">Отложенный подход к порождению и отправке событий</span><span class="sxs-lookup"><span data-stu-id="f6d64-202">The deferred approach to raise and dispatch events</span></span>

<span data-ttu-id="f6d64-203">Вместо немедленной отправки обработчику событий рекомендуется добавить события предметной области в коллекцию, а затем отправить их *непосредственно до* или *непосредственно* *после* фиксации транзакции (как в случае с SaveChanges в EF).</span><span class="sxs-lookup"><span data-stu-id="f6d64-203">Instead of dispatching to a domain event handler immediately, a better approach is to add the domain events to a collection and then to dispatch those domain events *right before* or *right* *after* committing the transaction (as with SaveChanges in EF).</span></span> <span data-ttu-id="f6d64-204">(Джимми Богард (Jimmy Bogard) описал этот подход в публикации [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/) (Лучший шаблон для событий предметной области).)</span><span class="sxs-lookup"><span data-stu-id="f6d64-204">(This approach was described by Jimmy Bogard in this post [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span></span>

<span data-ttu-id="f6d64-205">Принятие решения о моменте отправки событий предметной области (непосредственно до или непосредственно после фиксации транзакции) является важным шагом, так как оно определяет возможность включения побочных эффектов в состав одной или разных транзакций.</span><span class="sxs-lookup"><span data-stu-id="f6d64-205">Deciding if you send the domain events right before or right after committing the transaction is important, since it determines whether you will include the side effects as part of the same transaction or in different transactions.</span></span> <span data-ttu-id="f6d64-206">В последнем случае потребуется иметь дело с итоговой согласованностью между несколькими агрегатами.</span><span class="sxs-lookup"><span data-stu-id="f6d64-206">In the latter case, you need to deal with eventual consistency across multiple aggregates.</span></span> <span data-ttu-id="f6d64-207">Эта тема будет рассматриваться в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="f6d64-207">This topic is discussed in the next section.</span></span>

<span data-ttu-id="f6d64-208">Отложенный подход используется в микрослужбе eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="f6d64-208">The deferred approach is what eShopOnContainers uses.</span></span> <span data-ttu-id="f6d64-209">Сначала вы добавляете события, происходящие в сущностях, в коллекцию или список событий для каждой сущности.</span><span class="sxs-lookup"><span data-stu-id="f6d64-209">First, you add the events happening in your entities into a collection or list of events per entity.</span></span> <span data-ttu-id="f6d64-210">Этот список должен входить в состав объекта сущности или, что еще лучше, в состав базового класса сущности, как показано в следующем примере базового класса сущности.</span><span class="sxs-lookup"><span data-stu-id="f6d64-210">That list should be part of the entity object, or even better, part of your base entity class, as shown in the following example of the Entity base class:</span></span>

```csharp
public abstract class Entity
{
     //...
     private List<INotification> _domainEvents;
     public List<INotification> DomainEvents => _domainEvents;

     public void AddDomainEvent(INotification eventItem)
     {
         _domainEvents = _domainEvents ?? new List<INotification>();
         _domainEvents.Add(eventItem);
     }

     public void RemoveDomainEvent(INotification eventItem)
     {
         _domainEvents?.Remove(eventItem);
     }
     //... Additional code
}
```

<span data-ttu-id="f6d64-211">Когда нужно вызвать событие, вы просто добавляете его в коллекцию событий из кода в любом методе сущности корня агрегата.</span><span class="sxs-lookup"><span data-stu-id="f6d64-211">When you want to raise an event, you just add it to the event collection from code at any method of the aggregate-root entity.</span></span>

<span data-ttu-id="f6d64-212">Следующий пример кода является частью [корня агрегата "Заказ" в микрослужбе eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs):</span><span class="sxs-lookup"><span data-stu-id="f6d64-212">The following code, part of the [Order aggregate-root at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs), shows an example:</span></span>

```csharp
var orderStartedDomainEvent = new OrderStartedDomainEvent(this, //Order object
                                                          cardTypeId, cardNumber,
                                                          cardSecurityNumber,
                                                          cardHolderName,
                                                          cardExpiration);
this.AddDomainEvent(orderStartedDomainEvent);
```

<span data-ttu-id="f6d64-213">Обратите внимание, что единственное действие, выполняемое методом AddDomainEvent, — это добавление события в список.</span><span class="sxs-lookup"><span data-stu-id="f6d64-213">Notice that the only thing that the AddDomainEvent method is doing is adding an event to the list.</span></span> <span data-ttu-id="f6d64-214">Пока не отправлено ни одно событие и не вызван ни один обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="f6d64-214">No event is dispatched yet, and no event handler is invoked yet.</span></span>

<span data-ttu-id="f6d64-215">Вы хотите отправить событие позже — при фиксации транзакции в базу данных.</span><span class="sxs-lookup"><span data-stu-id="f6d64-215">You actually want to dispatch the events later on, when you commit the transaction to the database.</span></span> <span data-ttu-id="f6d64-216">Если вы используете Entity Framework Core, этот момент показан в методе SaveChanges в EF DbContext, как видно в следующем коде:</span><span class="sxs-lookup"><span data-stu-id="f6d64-216">If you are using Entity Framework Core, that means in the SaveChanges method of your EF DbContext, as in the following code:</span></span>

```csharp
// EF Core DbContext
public class OrderingContext : DbContext, IUnitOfWork
{
    // ...
    public async Task<bool> SaveEntitiesAsync(CancellationToken cancellationToken = default(CancellationToken))
    {
        // Dispatch Domain Events collection.
        // Choices:
        // A) Right BEFORE committing data (EF SaveChanges) into the DB. This makes
        // a single transaction including side effects from the domain event
        // handlers that are using the same DbContext with Scope lifetime
        // B) Right AFTER committing data (EF SaveChanges) into the DB. This makes
        // multiple transactions. You will need to handle eventual consistency and
        // compensatory actions in case of failures.
        await _mediator.DispatchDomainEventsAsync(this);

        // After this line runs, all the changes (from the Command Handler and Domain
        // event handlers) performed through the DbContext will be committed
        var result = await base.SaveChangesAsync();
    }
}
```

<span data-ttu-id="f6d64-217">Этот код позволяет отправлять события сущностей в соответствующие обработчики событий.</span><span class="sxs-lookup"><span data-stu-id="f6d64-217">With this code, you dispatch the entity events to their respective event handlers.</span></span>

<span data-ttu-id="f6d64-218">Общий результат заключается в том, что вызов события предметной области (простого добавления в список в памяти) разделен от его отправки в обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="f6d64-218">The overall result is that you have decoupled the raising of a domain event (a simple add into a list in memory) from dispatching it to an event handler.</span></span> <span data-ttu-id="f6d64-219">Кроме того, в зависимости от типа используемого диспетчера события можно отправлять синхронно или асинхронно.</span><span class="sxs-lookup"><span data-stu-id="f6d64-219">In addition, depending on what kind of dispatcher you are using, you could dispatch the events synchronously or asynchronously.</span></span>

<span data-ttu-id="f6d64-220">Следует иметь в виду, что здесь начинают играть важную роль транзакционные ограничения.</span><span class="sxs-lookup"><span data-stu-id="f6d64-220">Be aware that transactional boundaries come into significant play here.</span></span> <span data-ttu-id="f6d64-221">Если единица работы и транзакция могут относиться к нескольким агрегатам (как при использовании EF Core и реляционной базы данных), этот вариант может быть успешным.</span><span class="sxs-lookup"><span data-stu-id="f6d64-221">If your unit of work and transaction can span more than one aggregate (as when using EF Core and a relational database), this can work well.</span></span> <span data-ttu-id="f6d64-222">Но если транзакция не может использоваться в агрегатах, например при использовании базы данных NoSQL, такой как Azure CosmosDB, необходимо реализовать дополнительные действия для обеспечения согласованности.</span><span class="sxs-lookup"><span data-stu-id="f6d64-222">But if the transaction cannot span aggregates, such as when you are using a NoSQL database like Azure CosmosDB, you have to implement additional steps to achieve consistency.</span></span> <span data-ttu-id="f6d64-223">Это еще одна причина, по которой пропуск сохраняемости не является универсальным. Он зависит от используемой системы хранения.</span><span class="sxs-lookup"><span data-stu-id="f6d64-223">This is another reason why persistence ignorance is not universal; it depends on the storage system you use.</span></span>

### <a name="single-transaction-across-aggregates-versus-eventual-consistency-across-aggregates"></a><span data-ttu-id="f6d64-224">Одна транзакция между агрегатами и итоговая согласованность между агрегатами</span><span class="sxs-lookup"><span data-stu-id="f6d64-224">Single transaction across aggregates versus eventual consistency across aggregates</span></span>

<span data-ttu-id="f6d64-225">Вопрос о том, нужно ли выполнять одну транзакцию в агрегатах или следует полагаться на итоговую согласованность между этими агрегатами, является противоречивым.</span><span class="sxs-lookup"><span data-stu-id="f6d64-225">The question of whether to perform a single transaction across aggregates versus relying on eventual consistency across those aggregates is a controversial one.</span></span> <span data-ttu-id="f6d64-226">Многие авторы статей по DDD, среди которых Эрик Эванс (Eric Evans) и Вон Вернон (Vaughn Vernon), выступают в поддержку правила о том, что одна транзакция соответствует одному агрегату, и поддерживают итоговую согласованность между агрегатами.</span><span class="sxs-lookup"><span data-stu-id="f6d64-226">Many DDD authors like Eric Evans and Vaughn Vernon advocate the rule that one transaction = one aggregate and therefore argue for eventual consistency across aggregates.</span></span> <span data-ttu-id="f6d64-227">Например, в своей книге *Domain-Driven Design* (Разработка на основе предметной области) Эрик Эванс пишет следующее:</span><span class="sxs-lookup"><span data-stu-id="f6d64-227">For example, in his book *Domain-Driven Design*, Eric Evans says this:</span></span>

> <span data-ttu-id="f6d64-228">"Не следует ожидать, что любое правило, которое распространяется на агрегаты, всегда будет актуальным.</span><span class="sxs-lookup"><span data-stu-id="f6d64-228">Any rule that spans Aggregates will not be expected to be up-to-date at all times.</span></span> <span data-ttu-id="f6d64-229">Применив обработку событий, пакетную обработку или другие механизмы обновления, можно устранить зависимости в установленные конкретные строки".</span><span class="sxs-lookup"><span data-stu-id="f6d64-229">Through event processing, batch processing, or other update mechanisms, other dependencies can be resolved within some specific time.</span></span> <span data-ttu-id="f6d64-230">(стр. 128)</span><span class="sxs-lookup"><span data-stu-id="f6d64-230">(page 128)</span></span>

<span data-ttu-id="f6d64-231">Вон Вернон в своей статье [Effective Aggregate Design. Часть II. Организация совместной работы агрегатов](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span><span class="sxs-lookup"><span data-stu-id="f6d64-231">Vaughn Vernon says the following in [Effective Aggregate Design. Part II: Making Aggregates Work Together](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span></span>

> <span data-ttu-id="f6d64-232">Таким образом, если для выполнения команды в одном экземпляре агрегата требуется выполнить дополнительные бизнес-правила в одном или нескольких агрегатах, используйте итоговую согласованность\[...\] Существует практический способ поддержки итоговой согласованности в модели DDD.</span><span class="sxs-lookup"><span data-stu-id="f6d64-232">Thus, if executing a command on one aggregate instance requires that additional business rules execute on one or more aggregates, use eventual consistency \[...\] There is a practical way to support eventual consistency in a DDD model.</span></span> <span data-ttu-id="f6d64-233">Метод агрегата публикует событие предметной области, которое своевременно доставляется одному или нескольким асинхронным подписчикам.</span><span class="sxs-lookup"><span data-stu-id="f6d64-233">An aggregate method publishes a domain event that is in time delivered to one or more asynchronous subscribers.</span></span>

<span data-ttu-id="f6d64-234">Этот подход основан на применении детальных транзакций вместо транзакций, используемых в нескольких агрегатах или сущностях.</span><span class="sxs-lookup"><span data-stu-id="f6d64-234">This rationale is based on embracing fine-grained transactions instead of transactions spanning many aggregates or entities.</span></span> <span data-ttu-id="f6d64-235">Смысл в том, что во втором случае количество блокировок базы данных будет существенным в крупномасштабных приложениях, требующих высокого уровня масштабируемости.</span><span class="sxs-lookup"><span data-stu-id="f6d64-235">The idea is that in the second case, the number of database locks will be substantial in large-scale applications with high scalability needs.</span></span> <span data-ttu-id="f6d64-236">Признание того факта, что высокомасштабируемым приложениям не нужна мгновенная транзакционная согласованность между несколькими агрегатами, помогает принять концепцию итоговой согласованности.</span><span class="sxs-lookup"><span data-stu-id="f6d64-236">Embracing the fact that highly scalable applications need not have instant transactional consistency between multiple aggregates helps with accepting the concept of eventual consistency.</span></span> <span data-ttu-id="f6d64-237">Как правило, бизнесу не требуются еле заметные изменения, и в любом случае эксперты в предметной области обязаны определить необходимость атомарных транзакций для конкретных операций.</span><span class="sxs-lookup"><span data-stu-id="f6d64-237">Atomic changes are often not needed by the business, and it is in any case the responsibility of the domain experts to say whether particular operations need atomic transactions or not.</span></span> <span data-ttu-id="f6d64-238">Если операции всегда требуется атомарная транзакция между несколькими агрегатами, может возникнуть вопрос об увеличении размера агрегата либо поставлена под сомнение правильность его проектирования.</span><span class="sxs-lookup"><span data-stu-id="f6d64-238">If an operation always needs an atomic transaction between multiple aggregates, you might ask whether your aggregate should be larger or was not correctly designed.</span></span>

<span data-ttu-id="f6d64-239">Однако другие разработчики и архитекторы, такие как Джимми Богард (Jimmy Bogard), нормально относятся к тому факту, что одна транзакция используется для нескольких агрегатов, но только если эти дополнительные агрегаты связаны с побочными эффектами для одной и той же исходной команды.</span><span class="sxs-lookup"><span data-stu-id="f6d64-239">However, other developers and architects like Jimmy Bogard are okay with spanning a single transaction across several aggregates—but only when those additional aggregates are related to side effects for the same original command.</span></span> <span data-ttu-id="f6d64-240">К примеру, в статье [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/) (Лучший шаблон событий предметной области) Богард говорит следующее.</span><span class="sxs-lookup"><span data-stu-id="f6d64-240">For instance, in [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard says this:</span></span>

> <span data-ttu-id="f6d64-241">Как правило, требуется, чтобы побочные эффекты события предметной области возникали в пределах одной логической транзакции, но необязательно в той же области, где происходит событие предметной области \[...\] Мы отправляем события в соответствующие обработчики событий непосредственно перед тем, как зафиксировать транзакцию.</span><span class="sxs-lookup"><span data-stu-id="f6d64-241">Typically, I want the side effects of a domain event to occur within the same logical transaction, but not necessarily in the same scope of raising the domain event \[...\] Just before we commit our transaction, we dispatch our events to their respective handlers.</span></span>

<span data-ttu-id="f6d64-242">Отправка событий *до* фиксации исходной транзакции означает, что побочные эффекты этих событий должны быть включены в ту же транзакцию.</span><span class="sxs-lookup"><span data-stu-id="f6d64-242">If you dispatch the domain events right *before* committing the original transaction, it is because you want the side effects of those events to be included in the same transaction.</span></span> <span data-ttu-id="f6d64-243">Например, при сбое метода SaveChanges EF DbContext транзакция откатит все изменения, включая результат операций побочных эффектов, реализованных связанными обработчиками событий предметной области.</span><span class="sxs-lookup"><span data-stu-id="f6d64-243">For example, if the EF DbContext SaveChanges method fails, the transaction will roll back all changes, including the result of any side effect operations implemented by the related domain event handlers.</span></span> <span data-ttu-id="f6d64-244">Это связано с тем, что область жизни DbContext по умолчанию определена как имеющая заданную область.</span><span class="sxs-lookup"><span data-stu-id="f6d64-244">This is because the DbContext life scope is by default defined as "scoped."</span></span> <span data-ttu-id="f6d64-245">Таким образом, объект DbContext является общим для нескольких объектов репозитория, которые создаются в пределах одной области или графа объектов.</span><span class="sxs-lookup"><span data-stu-id="f6d64-245">Therefore, the DbContext object is shared across multiple repository objects being instantiated within the same scope or object graph.</span></span> <span data-ttu-id="f6d64-246">Это понятие совпадает с областью HttpRequest при разработке веб-API или приложений MVC.</span><span class="sxs-lookup"><span data-stu-id="f6d64-246">This coincides with the HttpRequest scope when developing Web API or MVC apps.</span></span>

<span data-ttu-id="f6d64-247">В действительности правильными могут быть оба подхода (одна атомарная транзакция и итоговая согласованность).</span><span class="sxs-lookup"><span data-stu-id="f6d64-247">Actually, both approaches (single atomic transaction and eventual consistency) can be right.</span></span> <span data-ttu-id="f6d64-248">Это зависит от требований предметной области или бизнес-требований, а также от мнений экспертов в предметной области.</span><span class="sxs-lookup"><span data-stu-id="f6d64-248">It really depends on your domain or business requirements and what the domain experts tell you.</span></span> <span data-ttu-id="f6d64-249">Значение также имеет то, насколько масштабируемой должна быть служба (более детализированные транзакции оказывают меньше влияния на блокировку баз данных).</span><span class="sxs-lookup"><span data-stu-id="f6d64-249">It also depends on how scalable you need the service to be (more granular transactions have less impact with regard to database locks).</span></span> <span data-ttu-id="f6d64-250">Кроме того, важен объем инвестиций, который вы готовы внести в свой код, поскольку для итоговой согласованности требуется более сложный код, позволяющий выявить возможные несоответствия между агрегатами, и необходимость реализации компенсационных действий.</span><span class="sxs-lookup"><span data-stu-id="f6d64-250">And it depends on how much investment you are willing to make in your code, since eventual consistency requires more complex code in order to detect possible inconsistencies across aggregates and the need to implement compensatory actions.</span></span> <span data-ttu-id="f6d64-251">Необходимо учитывать, что, если вы фиксируете изменения в исходном агрегате, а затем, когда при отправке событий возникнет проблема и обработчики событий не смогут зафиксировать свои побочные эффекты, у вас будут несоответствия между агрегатами.</span><span class="sxs-lookup"><span data-stu-id="f6d64-251">Consider that if you commit changes to the original aggregate and afterwards, when the events are being dispatched, if there is an issue and the event handlers cannot commit their side effects, you will have inconsistencies between aggregates.</span></span>

<span data-ttu-id="f6d64-252">Реализация компенсационных действий заключается в сохранении событий предметной области в дополнительных таблицах базы данных, чтобы они могли быть частью исходной транзакции.</span><span class="sxs-lookup"><span data-stu-id="f6d64-252">A way to allow compensatory actions would be to store the domain events in additional database tables so they can be part of the original transaction.</span></span> <span data-ttu-id="f6d64-253">После этого в вашем распоряжении может находиться пакетный процесс, который обнаруживает несоответствия и выполняет компенсационные действия, сравнивая список событий с текущим состоянием агрегатов.</span><span class="sxs-lookup"><span data-stu-id="f6d64-253">Afterwards, you could have a batch process that detects inconsistencies and runs compensatory actions by comparing the list of events with the current state of the aggregates.</span></span> <span data-ttu-id="f6d64-254">Компенсационные действия являются частью сложной темы, которая потребует глубокого анализа и обсуждения вопросов с бизнес-пользователями и экспертами в предметной области.</span><span class="sxs-lookup"><span data-stu-id="f6d64-254">The compensatory actions are part of a complex topic that will require deep analysis from your side, which includes discussing it with the business user and domain experts.</span></span>

<span data-ttu-id="f6d64-255">В любом случае можно выбрать нужный подход.</span><span class="sxs-lookup"><span data-stu-id="f6d64-255">In any case, you can choose the approach you need.</span></span> <span data-ttu-id="f6d64-256">Но первоначальный отложенный подход — создание событий до фиксации и вытекающее отсюда использование одной транзакций — является простейшим при работе с EF Core и реляционной базой данных.</span><span class="sxs-lookup"><span data-stu-id="f6d64-256">But the initial deferred approach—raising the events before committing, so you use a single transaction—is the simplest approach when using EF Core and a relational database.</span></span> <span data-ttu-id="f6d64-257">Его проще всего реализовать, и он является допустимым во многих бизнес-сценариях.</span><span class="sxs-lookup"><span data-stu-id="f6d64-257">It is easier to implement and valid in many business cases.</span></span> <span data-ttu-id="f6d64-258">Он также используется в микрослужбе по оформлению заказов в eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="f6d64-258">It is also the approach used in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="f6d64-259">Но как на самом деле эти события отправляются их соответствующим обработчикам событий?</span><span class="sxs-lookup"><span data-stu-id="f6d64-259">But how do you actually dispatch those events to their respective event handlers?</span></span> <span data-ttu-id="f6d64-260">Что такое объект `_mediator` в предыдущем примере?</span><span class="sxs-lookup"><span data-stu-id="f6d64-260">What's the `_mediator` object you see in the previous example?</span></span> <span data-ttu-id="f6d64-261">Здесь речь идет о методах и артефактах, которые можно использовать для сопоставления событий и их обработчиков событий.</span><span class="sxs-lookup"><span data-stu-id="f6d64-261">It has to do with the techniques and artifacts you use to map between events and their event handlers.</span></span>

### <a name="the-domain-event-dispatcher-mapping-from-events-to-event-handlers"></a><span data-ttu-id="f6d64-262">Диспетчер событий предметной области: сопоставление событий и обработчиков событий</span><span class="sxs-lookup"><span data-stu-id="f6d64-262">The domain event dispatcher: mapping from events to event handlers</span></span>

<span data-ttu-id="f6d64-263">Получив возможность отправки или публикации событий, вам потребуется какой-то артефакт, который будет публиковать событие, чтобы каждый связанный обработчик мог получать его и обрабатывать побочные эффекты, возникающие из-за этого события.</span><span class="sxs-lookup"><span data-stu-id="f6d64-263">Once you're able to dispatch or publish the events, you need some kind of artifact that will publish the event, so that every related handler can get it and process side effects based on that event.</span></span>

<span data-ttu-id="f6d64-264">Одним из вариантов является реальная система обмена сообщениями или даже шина событий, возможно, на основе служебной шины в отличие от событий в памяти.</span><span class="sxs-lookup"><span data-stu-id="f6d64-264">One approach is a real messaging system or even an event bus, possibly based on a service bus as opposed to in-memory events.</span></span> <span data-ttu-id="f6d64-265">Однако в первом случае реальный обмен сообщениями был бы избыточным для обработки событий предметной области, поскольку нужно просто обработать эти события в одном процессе (то есть в пределах одного уровня предметной области и приложения).</span><span class="sxs-lookup"><span data-stu-id="f6d64-265">However, for the first case, real messaging would be overkill for processing domain events, since you just need to process those events within the same process (that is, within the same domain and application layer).</span></span>

<span data-ttu-id="f6d64-266">Другой способ сопоставления событий с несколькими обработчиками событий заключается в использовании регистрации типов в контейнере IoC и позволяет динамически определять место для отправки событий.</span><span class="sxs-lookup"><span data-stu-id="f6d64-266">Another way to map events to multiple event handlers is by using types registration in an IoC container so you can dynamically infer where to dispatch the events.</span></span> <span data-ttu-id="f6d64-267">Иначе говоря, необходимо знать, какие обработчики событий должны получить определенное событие.</span><span class="sxs-lookup"><span data-stu-id="f6d64-267">In other words, you need to know what event handlers need to get a specific event.</span></span> <span data-ttu-id="f6d64-268">На рис. 7-16 показан упрощенный вариант этого подхода.</span><span class="sxs-lookup"><span data-stu-id="f6d64-268">Figure 7-16 shows a simplified approach for this approach.</span></span>

![Схема, на которой показан диспетчер событий предметной области, отправляющий события в соответствующие обработчики.](./media/domain-events-design-implementation/domain-event-dispatcher.png)

<span data-ttu-id="f6d64-270">**Рис. 7-16**.</span><span class="sxs-lookup"><span data-stu-id="f6d64-270">**Figure 7-16**.</span></span> <span data-ttu-id="f6d64-271">Диспетчер событий предметной области, использующий IoC</span><span class="sxs-lookup"><span data-stu-id="f6d64-271">Domain event dispatcher using IoC</span></span>

<span data-ttu-id="f6d64-272">Можно создать все связующие компоненты и артефакты для самостоятельной реализации этого подхода.</span><span class="sxs-lookup"><span data-stu-id="f6d64-272">You can build all the plumbing and artifacts to implement that approach by yourself.</span></span> <span data-ttu-id="f6d64-273">Однако также доступны такие библиотеки, как [MediatR](https://github.com/jbogard/MediatR), которые внутренним образом используют контейнер IoC.</span><span class="sxs-lookup"><span data-stu-id="f6d64-273">However, you can also use available libraries like [MediatR](https://github.com/jbogard/MediatR) that uses your IoC container under the covers.</span></span> <span data-ttu-id="f6d64-274">Поэтому можно напрямую использовать предопределенные интерфейсы и методы публикации и отправки объекта-посредника.</span><span class="sxs-lookup"><span data-stu-id="f6d64-274">You can therefore directly use the predefined interfaces and the mediator object's publish/dispatch methods.</span></span>

<span data-ttu-id="f6d64-275">В коде сначала необходимо зарегистрировать типы обработчиков событий в контейнере IOC, как показано в следующем примере в [микрослужбе по работе с заказами eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs).</span><span class="sxs-lookup"><span data-stu-id="f6d64-275">In code, you first need to register the event handler types in your IoC container, as shown in the following example at [eShopOnContainers Ordering microservice](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs):</span></span>

```csharp
public class MediatorModule : Autofac.Module
{
    protected override void Load(ContainerBuilder builder)
    {
        // Other registrations ...
        // Register the DomainEventHandler classes (they implement IAsyncNotificationHandler<>)
        // in assembly holding the Domain Events
        builder.RegisterAssemblyTypes(typeof(ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler)
                                       .GetTypeInfo().Assembly)
                                         .AsClosedTypesOf(typeof(IAsyncNotificationHandler<>));
        // Other registrations ...
    }
}
```

<span data-ttu-id="f6d64-276">Код сначала идентифицирует сборку, содержащую обработчики событий предметной области, выполняя поиск сборки, содержащей любой из обработчиков (с помощью typeof(ValidateOrAddBuyerAggregateWhenXxxx), хотя можно использовать любой другой обработчик событий).</span><span class="sxs-lookup"><span data-stu-id="f6d64-276">The code first identifies the assembly that contains the domain event handlers by locating the assembly that holds any of the handlers (using typeof(ValidateOrAddBuyerAggregateWhenXxxx), but you could have chosen any other event handler to locate the assembly).</span></span> <span data-ttu-id="f6d64-277">Поскольку все обработчики событий реализуют интерфейс IAsyncNotificationHandler, код просто ищет типы и регистрирует все обработчики событий.</span><span class="sxs-lookup"><span data-stu-id="f6d64-277">Since all the event handlers implement the IAsyncNotificationHandler interface, the code then just searches for those types and registers all the event handlers.</span></span>

### <a name="how-to-subscribe-to-domain-events"></a><span data-ttu-id="f6d64-278">Подписка на события предметной области</span><span class="sxs-lookup"><span data-stu-id="f6d64-278">How to subscribe to domain events</span></span>

<span data-ttu-id="f6d64-279">При работе с посредником MediatR каждый обработчик событий должен использовать тип события, предоставляемый в универсальном параметре интерфейса INotificationHandler, как показано в следующем коде:</span><span class="sxs-lookup"><span data-stu-id="f6d64-279">When you use MediatR, each event handler must use an event type that is provided on the generic parameter of the INotificationHandler interface, as you can see in the following code:</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
  : IAsyncNotificationHandler<OrderStartedDomainEvent>
```

<span data-ttu-id="f6d64-280">На основе связи между событием и обработчиком событий, который можно считать подпиской, артефакт MediatR может обнаруживать все обработчики событий для каждого события и запускать каждый из них.</span><span class="sxs-lookup"><span data-stu-id="f6d64-280">Based on the relationship between event and event handler, which can be considered the subscription, the MediatR artifact can discover all the event handlers for each event and trigger each one of those event handlers.</span></span>

### <a name="how-to-handle-domain-events"></a><span data-ttu-id="f6d64-281">Обработка событий предметной области</span><span class="sxs-lookup"><span data-stu-id="f6d64-281">How to handle domain events</span></span>

<span data-ttu-id="f6d64-282">И, наконец, обработчик событий обычно реализует код уровня приложения, который использует репозитории инфраструктуры для получения необходимых дополнительных агрегатов, а также для выполнения логики предметной области с побочными эффектами.</span><span class="sxs-lookup"><span data-stu-id="f6d64-282">Finally, the event handler usually implements application layer code that uses infrastructure repositories to obtain the required additional aggregates and to execute side-effect domain logic.</span></span> <span data-ttu-id="f6d64-283">Пример реализации демонстрируется в следующем [коде обработчика событий предметной области в eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs).</span><span class="sxs-lookup"><span data-stu-id="f6d64-283">The following [domain event handler code at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs), shows an implementation example.</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
                   : INotificationHandler<OrderStartedDomainEvent>
{
    private readonly ILoggerFactory _logger;
    private readonly IBuyerRepository<Buyer> _buyerRepository;
    private readonly IIdentityService _identityService;

    public ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler(
        ILoggerFactory logger,
        IBuyerRepository<Buyer> buyerRepository,
        IIdentityService identityService)
    {
        // ...Parameter validations...
    }

    public async Task Handle(OrderStartedDomainEvent orderStartedEvent)
    {
        var cardTypeId = (orderStartedEvent.CardTypeId != 0) ? orderStartedEvent.CardTypeId : 1;
        var userGuid = _identityService.GetUserIdentity();
        var buyer = await _buyerRepository.FindAsync(userGuid);
        bool buyerOriginallyExisted = (buyer == null) ? false : true;

        if (!buyerOriginallyExisted)
        {
            buyer = new Buyer(userGuid);
        }

        buyer.VerifyOrAddPaymentMethod(cardTypeId,
                                       $"Payment Method on {DateTime.UtcNow}",
                                       orderStartedEvent.CardNumber,
                                       orderStartedEvent.CardSecurityNumber,
                                       orderStartedEvent.CardHolderName,
                                       orderStartedEvent.CardExpiration,
                                       orderStartedEvent.Order.Id);

        var buyerUpdated = buyerOriginallyExisted ? _buyerRepository.Update(buyer)
                                                                      : _buyerRepository.Add(buyer);

        await _buyerRepository.UnitOfWork
                .SaveEntitiesAsync();

        // Logging code using buyerUpdated info, etc.
    }
}
```

<span data-ttu-id="f6d64-284">Предыдущий код обработчика событий предметной области считается кодом уровня приложения, так как он использует инфраструктуру репозиториев, как описано в следующем разделе об уровне сохраняемости инфраструктуры.</span><span class="sxs-lookup"><span data-stu-id="f6d64-284">The previous domain event handler code is considered application layer code because it uses infrastructure repositories, as explained in the next section on the infrastructure-persistence layer.</span></span> <span data-ttu-id="f6d64-285">Обработчики событий также могут использовать другие компоненты инфраструктуры.</span><span class="sxs-lookup"><span data-stu-id="f6d64-285">Event handlers could also use other infrastructure components.</span></span>

#### <a name="domain-events-can-generate-integration-events-to-be-published-outside-of-the-microservice-boundaries"></a><span data-ttu-id="f6d64-286">События предметной области способны создавать события интеграции за пределами микрослужбы</span><span class="sxs-lookup"><span data-stu-id="f6d64-286">Domain events can generate integration events to be published outside of the microservice boundaries</span></span>

<span data-ttu-id="f6d64-287">В заключение важно отметить, что иногда может потребоваться распространить события в нескольких микрослужбах.</span><span class="sxs-lookup"><span data-stu-id="f6d64-287">Finally, it's important to mention that you might sometimes want to propagate events across multiple microservices.</span></span> <span data-ttu-id="f6d64-288">Такое распространение считается событием интеграции и может быть опубликовано с помощью шины событий из любого конкретного обработчика событий предметной области.</span><span class="sxs-lookup"><span data-stu-id="f6d64-288">That propagation is an integration event, and it could be published through an event bus from any specific domain event handler.</span></span>

## <a name="conclusions-on-domain-events"></a><span data-ttu-id="f6d64-289">Выводы по событиям предметной области</span><span class="sxs-lookup"><span data-stu-id="f6d64-289">Conclusions on domain events</span></span>

<span data-ttu-id="f6d64-290">Как уже говорилось, события предметной области позволяют явно реализовать побочные эффекты изменений в предметной области.</span><span class="sxs-lookup"><span data-stu-id="f6d64-290">As stated, use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="f6d64-291">В соответствии с терминологией DDD события предметной области используются для явной реализации побочных эффектов в одном или нескольких агрегатах.</span><span class="sxs-lookup"><span data-stu-id="f6d64-291">To use DDD terminology, use domain events to explicitly implement side effects across one or multiple aggregates.</span></span> <span data-ttu-id="f6d64-292">Кроме того, итоговая согласованность между агрегатами в рамках одной предметной области обеспечивает улучшенную масштабируемость и оказывает меньшее воздействие на блокировки базы данных.</span><span class="sxs-lookup"><span data-stu-id="f6d64-292">Additionally, and for better scalability and less impact on database locks, use eventual consistency between aggregates within the same domain.</span></span>

<span data-ttu-id="f6d64-293">Эталонное приложение использует [MediatR](https://github.com/jbogard/MediatR) для синхронного распространения событий домена по агрегатам в рамках одной транзакции.</span><span class="sxs-lookup"><span data-stu-id="f6d64-293">The reference app uses [MediatR](https://github.com/jbogard/MediatR) to propagate domain events synchronously across aggregates, within a single transaction.</span></span> <span data-ttu-id="f6d64-294">Тем не менее вы можете также использовать реализацию AMQP, например [RabbitMQ](https://www.rabbitmq.com/) или [Служебная шина Azure](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview), для асинхронного распространения событий предметной области, используя итоговую согласованность, но, как упоминалось выше, необходимо учитывать потребность в компенсаторных действиях в случае сбоев.</span><span class="sxs-lookup"><span data-stu-id="f6d64-294">However, you could also use some AMQP implementation like [RabbitMQ](https://www.rabbitmq.com/) or [Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) to propagate domain events asynchronously, using eventual consistency but, as mentioned above, you have to consider the need for compensatory actions in case of failures.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="f6d64-295">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="f6d64-295">Additional resources</span></span>

- <span data-ttu-id="f6d64-296">**Грег Янг (Greg Young). Что такое событие предметной области?**</span><span class="sxs-lookup"><span data-stu-id="f6d64-296">**Greg Young. What is a Domain Event?**</span></span> \
  <https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf#page=25>

- <span data-ttu-id="f6d64-297">**Ян Стенберг (Jan Stenberg). События предметной области и итоговая согласованность** </span><span class="sxs-lookup"><span data-stu-id="f6d64-297">**Jan Stenberg. Domain Events and Eventual Consistency** </span></span>\
  <https://www.infoq.com/news/2015/09/domain-events-consistency>

- <span data-ttu-id="f6d64-298">**Джимми Богард (Jimmy Bogard). Улучшенный шаблон событий предметной области** </span><span class="sxs-lookup"><span data-stu-id="f6d64-298">**Jimmy Bogard. A better domain events pattern** </span></span>\
  <https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/>

- <span data-ttu-id="f6d64-299">**Вон Вернон (Vaughn Vernon). Эффективная конструкция агрегата. Часть II. Организация совместной работы агрегатов** </span><span class="sxs-lookup"><span data-stu-id="f6d64-299">**Vaughn Vernon. Effective Aggregate Design Part II: Making Aggregates Work Together** </span></span>\
  [https://dddcommunity.org/wp-content/uploads/files/pdf\_articles/Vernon\_2011\_2.pdf](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)

- <span data-ttu-id="f6d64-300">**Джимми Богард (Jimmy Bogard). Усиление предметной области: события предметной области** </span><span class="sxs-lookup"><span data-stu-id="f6d64-300">**Jimmy Bogard. Strengthening your domain: Domain Events** </span></span>\
  <https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/>

- <span data-ttu-id="f6d64-301">**Тони Чыонг (Tony Truong). Пример шаблона событий предметной области** </span><span class="sxs-lookup"><span data-stu-id="f6d64-301">**Tony Truong. Domain Events Pattern Example** </span></span>\
  <https://www.tonytruong.net/domain-events-pattern-example/>

- <span data-ttu-id="f6d64-302">**Уди Дахан (Udi Dahan). Создание полностью инкапсулированных моделей предметной области** </span><span class="sxs-lookup"><span data-stu-id="f6d64-302">**Udi Dahan. How to create fully encapsulated Domain Models** </span></span>\
  <https://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/>

- <span data-ttu-id="f6d64-303">**Уди Дахан (Udi Dahan). События предметной области. Попытка 2** </span><span class="sxs-lookup"><span data-stu-id="f6d64-303">**Udi Dahan. Domain Events – Take 2** </span></span>\
  <https://udidahan.com/2008/08/25/domain-events-take-2/>

- <span data-ttu-id="f6d64-304">**Уди Дахан (Udi Dahan). События предметной области. Спасение** </span><span class="sxs-lookup"><span data-stu-id="f6d64-304">**Udi Dahan. Domain Events – Salvation** </span></span>\
  <https://udidahan.com/2009/06/14/domain-events-salvation/>

- <span data-ttu-id="f6d64-305">**Ян Кронквист (Jan Kronquist). Не публикуйте события предметной области, а возвращайте их!**</span><span class="sxs-lookup"><span data-stu-id="f6d64-305">**Jan Kronquist. Don't publish Domain Events, return them!**</span></span> \
  <https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/>

- <span data-ttu-id="f6d64-306">**Сезар де ла Торре (Cesar de la Torre). События предметной области Интеграция событий в DDD и архитектуры микрослужб** </span><span class="sxs-lookup"><span data-stu-id="f6d64-306">**Cesar de la Torre. Domain Events vs. Integration Events in DDD and microservices architectures** </span></span>\
  <https://devblogs.microsoft.com/cesardelatorre/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/>

>[!div class="step-by-step"]
><span data-ttu-id="f6d64-307">[Назад](client-side-validation.md)
>[Вперед](infrastructure-persistence-layer-design.md)</span><span class="sxs-lookup"><span data-stu-id="f6d64-307">[Previous](client-side-validation.md)
[Next](infrastructure-persistence-layer-design.md)</span></span>
