---
title: Проектирование микрослужбы, ориентированной на DDD
description: Архитектура микрослужб .NET для контейнерных приложений .NET | Понимание структуры микрослужбы заказа, ориентированной на DDD, и ее прикладных уровней.
ms.date: 10/08/2018
ms.openlocfilehash: 303f8909d12dddef93b20604a00b9ea8e8493ee5
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/30/2019
ms.locfileid: "68674351"
---
# <a name="design-a-ddd-oriented-microservice"></a><span data-ttu-id="63040-103">Проектирование микрослужбы, ориентированной на DDD</span><span class="sxs-lookup"><span data-stu-id="63040-103">Design a DDD-oriented microservice</span></span>

<span data-ttu-id="63040-104">Проблемно-ориентированное проектирование (DDD) основано на подходе, при котором классы моделируются на основе реальных бизнес процессов.</span><span class="sxs-lookup"><span data-stu-id="63040-104">Domain-driven design (DDD) advocates modeling based on the reality of business as relevant to your use cases.</span></span> <span data-ttu-id="63040-105">В контексте создания приложений DDD рассматривает проблемы как домены (предметные области).</span><span class="sxs-lookup"><span data-stu-id="63040-105">In the context of building applications, DDD talks about problems as domains.</span></span> <span data-ttu-id="63040-106">Этот подход описывает независимые проблемные области как ограниченные контексты (каждый ограниченный контекст соответствует микрослужбе). Особое внимание уделяется использованию обычного языка для описания проблем.</span><span class="sxs-lookup"><span data-stu-id="63040-106">It describes independent problem areas as Bounded Contexts (each Bounded Context correlates to a microservice), and emphasizes a common language to talk about these problems.</span></span> <span data-ttu-id="63040-107">В DDD также рассматриваются многие технические концепции и шаблоны, такие как объекты с сильными моделями (в отличие от [слабых моделей предметной области](https://martinfowler.com/bliki/AnemicDomainModel.html)), объекты значений, агрегаты и корень агрегации (или корневая сущность) для поддержки внутренней реализации.</span><span class="sxs-lookup"><span data-stu-id="63040-107">It also suggests many technical concepts and patterns, like domain entities with rich models (no [anemic-domain model](https://martinfowler.com/bliki/AnemicDomainModel.html)), value objects, aggregates and aggregate root (or root entity) rules to support the internal implementation.</span></span> <span data-ttu-id="63040-108">Этот раздел описывает проектирование и реализацию этих внутренних шаблонов.</span><span class="sxs-lookup"><span data-stu-id="63040-108">This section introduces the design and implementation of those internal patterns.</span></span>

<span data-ttu-id="63040-109">Иногда технические правила и шаблоны DDD считаются препятствием, поскольку для реализации подхода DDD требуется высокий уровень подготовки.</span><span class="sxs-lookup"><span data-stu-id="63040-109">Sometimes these DDD technical rules and patterns are perceived as obstacles that have a steep learning curve for implementing DDD approaches.</span></span> <span data-ttu-id="63040-110">Однако важны не шаблоны сами по себе, а организация кода, таким образом, чтобы он соответствовал бизнес-проблемам и использовал те же бизнес-термины (единый язык).</span><span class="sxs-lookup"><span data-stu-id="63040-110">But the important part is not the patterns themselves, but organizing the code so it is aligned to the business problems, and using the same business terms (ubiquitous language).</span></span> <span data-ttu-id="63040-111">Кроме того, подход DDD должен применяться только в том случае, когда вы реализуете сложные микрослужбы со сложными бизнес-правилами.</span><span class="sxs-lookup"><span data-stu-id="63040-111">In addition, DDD approaches should be applied only if you are implementing complex microservices with significant business rules.</span></span> <span data-ttu-id="63040-112">Простыми задачами, такими как службы CRUD, можно управлять с помощью более простых подходов.</span><span class="sxs-lookup"><span data-stu-id="63040-112">Simpler responsibilities, like a CRUD service, can be managed with simpler approaches.</span></span>

<span data-ttu-id="63040-113">И именно вопрос о том, где провести границу, является ключевым при разработке и определении микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="63040-113">Where to draw the boundaries is the key task when designing and defining a microservice.</span></span> <span data-ttu-id="63040-114">DDD шаблоны помогают понять сложную структуру предметной области.</span><span class="sxs-lookup"><span data-stu-id="63040-114">DDD patterns help you understand the complexity in the domain.</span></span> <span data-ttu-id="63040-115">В модели предметной области для каждого ограниченного контекста вы задаете и определяете сущности, объекты значений и агрегаты, которые моделируют вашу предметную область.</span><span class="sxs-lookup"><span data-stu-id="63040-115">For the domain model for each Bounded Context, you identify and define the entities, value objects, and aggregates that model your domain.</span></span> <span data-ttu-id="63040-116">Вы строите и детализируете модель предметной области, которая содержится в границах, задающих контекст.</span><span class="sxs-lookup"><span data-stu-id="63040-116">You build and refine a domain model that is contained within a boundary that defines your context.</span></span> <span data-ttu-id="63040-117">Это подход очень хорошо проявляется при использовании микрослужб.</span><span class="sxs-lookup"><span data-stu-id="63040-117">And that is very explicit in the form of a microservice.</span></span> <span data-ttu-id="63040-118">Компоненты в пределах этих границ становятся микрослужбами, хотя в некоторых случаях ограниченный контекст или бизнес-микрослужба могут состоять из нескольких физических служб.</span><span class="sxs-lookup"><span data-stu-id="63040-118">The components within those boundaries end up being your microservices, although in some cases a BC or business microservices can be composed of several physical services.</span></span> <span data-ttu-id="63040-119">DDD описывает границы, а, следовательно, и микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="63040-119">DDD is about boundaries and so are microservices.</span></span>

## <a name="keep-the-microservice-context-boundaries-relatively-small"></a><span data-ttu-id="63040-120">Сохранение границы контекста микрослужбы в относительно небольших пределах</span><span class="sxs-lookup"><span data-stu-id="63040-120">Keep the microservice context boundaries relatively small</span></span>

<span data-ttu-id="63040-121">Задача определения места проведения границы между ограниченными контекстами балансирует между двумя противоположными задачами.</span><span class="sxs-lookup"><span data-stu-id="63040-121">Determining where to place boundaries between Bounded Contexts balances two competing goals.</span></span> <span data-ttu-id="63040-122">Во-первых, необходимо первоначально создать наименьшие из возможных микрослужб, однако это не должно быть основным мотивом. Следует очерчивать границы вокруг вещей, которые должны находиться в единой связке.</span><span class="sxs-lookup"><span data-stu-id="63040-122">First, you want to initially create the smallest possible microservices, although that should not be the main driver; you should create a boundary around things that need cohesion.</span></span> <span data-ttu-id="63040-123">Во-вторых, необходимо избежать "многословного" обмена данными между микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="63040-123">Second, you want to avoid chatty communications between microservices.</span></span> <span data-ttu-id="63040-124">Эти цели могут противоречить друг другу.</span><span class="sxs-lookup"><span data-stu-id="63040-124">These goals can contradict one another.</span></span> <span data-ttu-id="63040-125">Вы должны найти баланс, разделяя систему на столько небольших микрослужб, насколько это возможно, пока не увидите, что после каждой следующей попытки отделить новый ограниченный контекст начинается быстрый рост передачи данных через границы.</span><span class="sxs-lookup"><span data-stu-id="63040-125">You should balance them by decomposing the system into as many small microservices as you can until you see communication boundaries growing quickly with each additional attempt to separate a new Bounded Context.</span></span> <span data-ttu-id="63040-126">Слаженность является ключевым параметром в рамках одного ограниченного контекста.</span><span class="sxs-lookup"><span data-stu-id="63040-126">Cohesion is key within a single bounded context.</span></span>

<span data-ttu-id="63040-127">Это похоже на [запах неуместной близости](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) при реализации классов.</span><span class="sxs-lookup"><span data-stu-id="63040-127">It is similar to the [Inappropriate Intimacy code smell](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) when implementing classes.</span></span> <span data-ttu-id="63040-128">Если необходимо, чтобы две микрослужбы активно взаимодействовали друг с другом, то, скорее всего, они должны быть одной микрослужбой.</span><span class="sxs-lookup"><span data-stu-id="63040-128">If two microservices need to collaborate a lot with each other, they should probably be the same microservice.</span></span>

<span data-ttu-id="63040-129">Другим способом является проверка на автономность.</span><span class="sxs-lookup"><span data-stu-id="63040-129">Another way to look at this is autonomy.</span></span> <span data-ttu-id="63040-130">Если микрослужба должна полагаться на другую службу для обслуживания прямого запроса, то она не является полностью автономной.</span><span class="sxs-lookup"><span data-stu-id="63040-130">If a microservice must rely on another service to directly service a request, it is not truly autonomous.</span></span>

## <a name="layers-in-ddd-microservices"></a><span data-ttu-id="63040-131">Уровни в микрослужбах DDD</span><span class="sxs-lookup"><span data-stu-id="63040-131">Layers in DDD microservices</span></span>

<span data-ttu-id="63040-132">Большинство корпоративных приложений со сложной бизнес-логикой и технической реализацией разделяются на уровни.</span><span class="sxs-lookup"><span data-stu-id="63040-132">Most enterprise applications with significant business and technical complexity are defined by multiple layers.</span></span> <span data-ttu-id="63040-133">Уровни являются логическим артефактом и не относятся к развертыванию службы.</span><span class="sxs-lookup"><span data-stu-id="63040-133">The layers are a logical artifact, and are not related to the deployment of the service.</span></span> <span data-ttu-id="63040-134">Они нужны, чтобы помочь разработчикам управлять сложными процессами в коде.</span><span class="sxs-lookup"><span data-stu-id="63040-134">They exist to help developers manage the complexity in the code.</span></span> <span data-ttu-id="63040-135">Различные уровни (например, уровень модели предметной области, уровень представления данных и т. д.) могут иметь различные типы, между которыми необходимо проводить трансляции.</span><span class="sxs-lookup"><span data-stu-id="63040-135">Different layers (like the domain model layer versus the presentation layer, etc.) might have different types, which mandates translations between those types.</span></span>

<span data-ttu-id="63040-136">Например, сущность может загружаться из базы данных.</span><span class="sxs-lookup"><span data-stu-id="63040-136">For example, an entity could be loaded from the database.</span></span> <span data-ttu-id="63040-137">Затем часть этих сведений, или объединенные данные, включающие данные из других сущностей, могут отправляться в пользовательский интерфейс клиента через веб-API REST.</span><span class="sxs-lookup"><span data-stu-id="63040-137">Then part of that information, or an aggregation of information including additional data from other entities, can be sent to the client UI through a REST Web API.</span></span> <span data-ttu-id="63040-138">Суть в том, что объект содержится в уровне модели предметной области и не должен передаваться в другие области, к которым он не принадлежит, такие как уровень представления данных.</span><span class="sxs-lookup"><span data-stu-id="63040-138">The point here is that the domain entity is contained within the domain model layer and should not be propagated to other areas that it does not belong to, like to the presentation layer.</span></span>

<span data-ttu-id="63040-139">Кроме того, необходимо иметь всегда действительные сущности (см. раздел [Проектирование проверок в уровне модели предметной области](domain-model-layer-validations.md)), контролируемые корнями агрегаций (корневыми сущностями).</span><span class="sxs-lookup"><span data-stu-id="63040-139">Additionally, you need to have always-valid entities (see the [Designing validations in the domain model layer](domain-model-layer-validations.md) section) controlled by aggregate roots (root entities).</span></span> <span data-ttu-id="63040-140">Поэтому сущности не должны быть привязаны к представлениям в клиенте, так как на уровне интерфейса пользователя некоторые данные по-прежнему не могут быть проверены.</span><span class="sxs-lookup"><span data-stu-id="63040-140">Therefore, entities should not be bound to client views, because at the UI level some data might still not be validated.</span></span> <span data-ttu-id="63040-141">Именно для этого предназначена модель ViewModel.</span><span class="sxs-lookup"><span data-stu-id="63040-141">This is what the ViewModel is for.</span></span> <span data-ttu-id="63040-142">ViewModel — это модель данных, предназначенная исключительно для использования в уровне представления.</span><span class="sxs-lookup"><span data-stu-id="63040-142">The ViewModel is a data model exclusively for presentation layer needs.</span></span> <span data-ttu-id="63040-143">Сущности предметной области не принадлежат непосредственно ViewModel.</span><span class="sxs-lookup"><span data-stu-id="63040-143">The domain entities do not belong directly to the ViewModel.</span></span> <span data-ttu-id="63040-144">Вместо этого необходимо выполнять трансляцию между сущностями ViewModels и предметной области и наоборот.</span><span class="sxs-lookup"><span data-stu-id="63040-144">Instead, you need to translate between ViewModels and domain entities and vice versa.</span></span>

<span data-ttu-id="63040-145">При решении сложностей важно иметь модель предметной области, управляемую корнями агрегации. Это гарантирует, что все инварианты и правила, связанные с этой группой сущностей (агрегатом), устанавливаются с помощью одной-единственной точки входа или шлюза — корня агрегации.</span><span class="sxs-lookup"><span data-stu-id="63040-145">When tackling complexity, it is important to have a domain model controlled by aggregate roots that make sure that all the invariants and rules related to that group of entities (aggregate) are performed through a single entry-point or gate, the aggregate root.</span></span>

<span data-ttu-id="63040-146">На рис. 7-5 показана реализация многоуровневой архитектуры в приложении eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="63040-146">Figure 7-5 shows how a layered design is implemented in the eShopOnContainers application.</span></span>

![Три уровня в микрослужбе DDD, например для заказа.](./media/image6.png)

<span data-ttu-id="63040-149">**Рис. 7-5**.</span><span class="sxs-lookup"><span data-stu-id="63040-149">**Figure 7-5**.</span></span> <span data-ttu-id="63040-150">Уровни DDD в микрослужбе заказов в eShopOnContainers</span><span class="sxs-lookup"><span data-stu-id="63040-150">DDD layers in the ordering microservice in eShopOnContainers</span></span>

<span data-ttu-id="63040-151">Необходимо разработать систему таким образом, чтобы каждый уровень взаимодействовал только с некоторыми из других уровней.</span><span class="sxs-lookup"><span data-stu-id="63040-151">You want to design the system so that each layer communicates only with certain other layers.</span></span> <span data-ttu-id="63040-152">Простым решением будет принудительно реализовать уровни в виде отдельных библиотек классов, так как в этом случае вы сможете легко определить, какие зависимости устанавливаются между библиотеками.</span><span class="sxs-lookup"><span data-stu-id="63040-152">That may be easier to enforce if layers are implemented as different class libraries, because you can clearly identify what dependencies are set between libraries.</span></span> <span data-ttu-id="63040-153">Например, уровень модели предметной области не должен иметь зависимостей на любом другом уровне (классы модели предметной области должны быть обычными объектами CLR, т. е. классами [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)).</span><span class="sxs-lookup"><span data-stu-id="63040-153">For instance, the domain model layer should not take a dependency on any other layer (the domain model classes should be Plain Old CLR Objects, or [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), classes).</span></span> <span data-ttu-id="63040-154">Как показано на рис. 7-6, библиотека уровня **Ordering.Domain** имеет зависимости только от библиотек .NET Core и пакетов NuGet, но не от других пользовательских библиотек, таких как библиотека данных или библиотека сохраняемости.</span><span class="sxs-lookup"><span data-stu-id="63040-154">As shown in Figure 7-6, the **Ordering.Domain** layer library has dependencies only on the .NET Core libraries or NuGet packages, but not on any other custom library, such as data library or persistence library.</span></span>

![Представление обозревателя решений для зависимости Ordering.Domain, показывающее зависимость только от библиотек .NET Core.](./media/image7.png)

<span data-ttu-id="63040-156">**Рис. 7-6.**</span><span class="sxs-lookup"><span data-stu-id="63040-156">**Figure 7-6**.</span></span> <span data-ttu-id="63040-157">Уровни, реализованные в виде библиотек, позволяют лучше управлять зависимостями между уровнями</span><span class="sxs-lookup"><span data-stu-id="63040-157">Layers implemented as libraries allow better control of dependencies between layers</span></span>

### <a name="the-domain-model-layer"></a><span data-ttu-id="63040-158">Уровень модели предметной области</span><span class="sxs-lookup"><span data-stu-id="63040-158">The domain model layer</span></span>

<span data-ttu-id="63040-159">В великолепной книге Эрика Эванса [Проблемно-ориентированное проектирование](https://domainlanguage.com/ddd/) об уровне модели предметной области говорится следующее.</span><span class="sxs-lookup"><span data-stu-id="63040-159">Eric Evans's excellent book [Domain Driven Design](https://domainlanguage.com/ddd/) says the following about the domain model layer and the application layer.</span></span>

<span data-ttu-id="63040-160">**Уровень модели предметной области**: отвечает за представления концепции бизнес-процессов, бизнес-правил и сведений о бизнес-ситуации.</span><span class="sxs-lookup"><span data-stu-id="63040-160">**Domain Model Layer**: Responsible for representing concepts of the business, information about the business situation, and business rules.</span></span> <span data-ttu-id="63040-161">Здесь контролируется и используется состояние, которое отражает бизнес-ситуацию, несмотря на то, что технические детали его хранения делегируются инфраструктуре.</span><span class="sxs-lookup"><span data-stu-id="63040-161">State that reflects the business situation is controlled and used here, even though the technical details of storing it are delegated to the infrastructure.</span></span> <span data-ttu-id="63040-162">Этот уровень является сердцем программного обеспечения для бизнеса.</span><span class="sxs-lookup"><span data-stu-id="63040-162">This layer is the heart of business software.</span></span>

<span data-ttu-id="63040-163">Уровень модели предметной области — это уровень, где содержится суть бизнеса.</span><span class="sxs-lookup"><span data-stu-id="63040-163">The domain model layer is where the business is expressed.</span></span> <span data-ttu-id="63040-164">При реализации этого уровня в микрослужбе в среде .NET он создается как библиотека классов с сущностями предметной области, которые получают данные плюс взаимодействие (методы с логикой).</span><span class="sxs-lookup"><span data-stu-id="63040-164">When you implement a microservice domain model layer in .NET, that layer is coded as a class library with the domain entities that capture data plus behavior (methods with logic).</span></span>

<span data-ttu-id="63040-165">Согласно принципам [игнорирования сохраняемости](https://deviq.com/persistence-ignorance/) и [игнорирования инфраструктуры](https://ayende.com/blog/3137/infrastructure-ignorance) этот уровень должен быть полностью безразличен к способу сохранения данных.</span><span class="sxs-lookup"><span data-stu-id="63040-165">Following the [Persistence Ignorance](https://deviq.com/persistence-ignorance/) and the [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, this layer must completely ignore data persistence details.</span></span> <span data-ttu-id="63040-166">Задачи сохранения следует выполнять на уровне инфраструктуры.</span><span class="sxs-lookup"><span data-stu-id="63040-166">These persistence tasks should be performed by the infrastructure layer.</span></span> <span data-ttu-id="63040-167">Таким образом, этот уровень не должен принимать прямых зависимостей от инфраструктуры, из чего следует важное правило: ваши классы сущностей модели предметной области должны быть классами [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object).</span><span class="sxs-lookup"><span data-stu-id="63040-167">Therefore, this layer should not take direct dependencies on the infrastructure, which means that an important rule is that your domain model entity classes should be [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s.</span></span>

<span data-ttu-id="63040-168">Сущности предметной области не должны иметь никаких прямых зависимостей (например, производных от базового класса) ни с какой платформой инфраструктуры доступа к данным, такими как Entity Framework и NHibernate.</span><span class="sxs-lookup"><span data-stu-id="63040-168">Domain entities should not have any direct dependency (like deriving from a base class) on any data access infrastructure framework like Entity Framework or NHibernate.</span></span> <span data-ttu-id="63040-169">В идеальном случае сущности предметной области не должны наследоваться от или являться никаким типом, определенном в каком-либо инфраструктурном фреймворке.</span><span class="sxs-lookup"><span data-stu-id="63040-169">Ideally, your domain entities should not derive from or implement any type defined in any infrastructure framework.</span></span>

<span data-ttu-id="63040-170">Большинство современных ORM платформ, таких как Entity Framework Core, допускают такой подход, при котором классы модели предметной области не привязаны к инфраструктуре.</span><span class="sxs-lookup"><span data-stu-id="63040-170">Most modern ORM frameworks like Entity Framework Core allow this approach, so that your domain model classes are not coupled to the infrastructure.</span></span> <span data-ttu-id="63040-171">Однако наличие сущностей POCO не всегда возможно при использовании определенных баз данных NoSQL и платформ, например субъектов и надежных коллекций в Azure Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="63040-171">However, having POCO entities is not always possible when using certain NoSQL databases and frameworks, like Actors and Reliable Collections in Azure Service Fabric.</span></span>

<span data-ttu-id="63040-172">Даже в том случае, когда важно следовать принципу игнорирования сохраняемости для модели предметной области, вы не должны упускать из виду вопросы сохраняемости.</span><span class="sxs-lookup"><span data-stu-id="63040-172">Even when it is important to follow the Persistence Ignorance principle for your Domain model, you should not ignore persistence concerns.</span></span> <span data-ttu-id="63040-173">По-прежнему очень важно понимать физическую модель данных и то, как она сопоставляется с моделью объекта сущности.</span><span class="sxs-lookup"><span data-stu-id="63040-173">It is still very important to understand the physical data model and how it maps to your entity object model.</span></span> <span data-ttu-id="63040-174">В противном случае может получиться невозможный проект.</span><span class="sxs-lookup"><span data-stu-id="63040-174">Otherwise you can create impossible designs.</span></span>

<span data-ttu-id="63040-175">Кроме того, это не означает, что можно взять модель, разработанную для реляционной базы данных, и без изменений перенести ее на NoSQL или документоориентированную базу данных.</span><span class="sxs-lookup"><span data-stu-id="63040-175">Also, this does not mean you can take a model designed for a relational database and directly move it to a NoSQL or document-oriented database.</span></span> <span data-ttu-id="63040-176">Для некоторых моделей сущностей это возможно, но обычно это не срабатывает.</span><span class="sxs-lookup"><span data-stu-id="63040-176">In some entity models, the model might fit, but usually it does not.</span></span> <span data-ttu-id="63040-177">Все еще существуют ограничения, зависящие от применяемых технологий хранения и ORM, которым должна соответствовать модель сущности.</span><span class="sxs-lookup"><span data-stu-id="63040-177">There are still constraints that your entity model must adhere to, based both on the storage technology and ORM technology.</span></span>

### <a name="the-application-layer"></a><span data-ttu-id="63040-178">Уровень приложения</span><span class="sxs-lookup"><span data-stu-id="63040-178">The application layer</span></span>

<span data-ttu-id="63040-179">Переходя к уровню приложения, мы снова процитируем книгу Эрика Эванса [Проблемно-ориентированное проектирование](https://domainlanguage.com/ddd/):</span><span class="sxs-lookup"><span data-stu-id="63040-179">Moving on to the application layer, we can again cite Eric Evans's book [Domain Driven Design](https://domainlanguage.com/ddd/):</span></span>

<span data-ttu-id="63040-180">**Уровень приложения**: определяет задачи, которые должно выполнять программное обеспечение, и управляет различными объектами предметной области для решения проблем.</span><span class="sxs-lookup"><span data-stu-id="63040-180">**Application Layer:** Defines the jobs the software is supposed to do and directs the expressive domain objects to work out problems.</span></span> <span data-ttu-id="63040-181">Задачи, за которые отвечает этот уровень, являются значимыми для бизнеса или необходимыми для взаимодействия с уровнями приложений других систем.</span><span class="sxs-lookup"><span data-stu-id="63040-181">The tasks this layer is responsible for are meaningful to the business or necessary for interaction with the application layers of other systems.</span></span> <span data-ttu-id="63040-182">Этот уровень является тонким.</span><span class="sxs-lookup"><span data-stu-id="63040-182">This layer is kept thin.</span></span> <span data-ttu-id="63040-183">Он не содержит бизнес-правил или наборов знаний, а только координирует задачи и делегирует выполнение работы объединениям объектов предметной области, расположенным на один уровень ниже.</span><span class="sxs-lookup"><span data-stu-id="63040-183">It does not contain business rules or knowledge, but only coordinates tasks and delegates work to collaborations of domain objects in the next layer down.</span></span> <span data-ttu-id="63040-184">Этот уровень не содержит состояния, отражающего бизнес-ситуацию, но в нем может быть состояние, которое отражает ход выполнения задачи для пользователя или программы.</span><span class="sxs-lookup"><span data-stu-id="63040-184">It does not have state reflecting the business situation, but it can have state that reflects the progress of a task for the user or the program.</span></span>

<span data-ttu-id="63040-185">Часто уровень приложения микрослужбы в .NET реализуется как проект Веб-API ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="63040-185">A microservice’s application layer in .NET is commonly coded as an ASP.NET Core Web API project.</span></span> <span data-ttu-id="63040-186">Этот проект реализует взаимодействие микрослужбы, удаленный доступ к сети и внешние веб-API, используемые из пользовательского интерфейса или клиентских приложений.</span><span class="sxs-lookup"><span data-stu-id="63040-186">The project implements the microservice’s interaction, remote network access, and the external Web APIs used from the UI or client apps.</span></span> <span data-ttu-id="63040-187">При использовании подхода CQRS он включает запросы, принимаемые микрослужбой команды и даже управляемое событиями взаимодействие между микрослужбами (события интеграции).</span><span class="sxs-lookup"><span data-stu-id="63040-187">It includes queries if using a CQRS approach, commands accepted by the microservice, and even the event-driven communication between microservices (integration events).</span></span> <span data-ttu-id="63040-188">Веб-API ASP.NET Core, представляющий уровень приложения, не должен содержать бизнес-правила или наборы знаний предметной области (особенно правила предметной области для транзакции или обновлений), которые должны принадлежать библиотеке классов модели предметной области.</span><span class="sxs-lookup"><span data-stu-id="63040-188">The ASP.NET Core Web API that represents the application layer must not contain business rules or domain knowledge (especially domain rules for transactions or updates); these should be owned by the domain model class library.</span></span> <span data-ttu-id="63040-189">Уровень приложения должен только координировать задачи и не должен содержать или задавать состояние предметной области (модель предметной области).</span><span class="sxs-lookup"><span data-stu-id="63040-189">The application layer must only coordinate tasks and must not hold or define any domain state (domain model).</span></span> <span data-ttu-id="63040-190">Он делегирует выполнение бизнес-правил непосредственно классам модели предметной области (корням агрегации и сущностям предметной области), что в конечном итоге приводит к обновлению данных в этих сущностях предметной области.</span><span class="sxs-lookup"><span data-stu-id="63040-190">It delegates the execution of business rules to the domain model classes themselves (aggregate roots and domain entities), which will ultimately update the data within those domain entities.</span></span>

<span data-ttu-id="63040-191">По сути, логика приложения — это место, где реализованы все сценарии использования, зависящие от данного внешнего интерфейса.</span><span class="sxs-lookup"><span data-stu-id="63040-191">Basically, the application logic is where you implement all use cases that depend on a given front end.</span></span> <span data-ttu-id="63040-192">Например, реализация, относящаяся к службе веб-API.</span><span class="sxs-lookup"><span data-stu-id="63040-192">For example, the implementation related to a Web API service.</span></span>

<span data-ttu-id="63040-193">Целью является то, чтобы логика предметной области находилась в уровне модели предметной области. Его инварианты, модели данных и связанные бизнес-правила должны быть полностью независимы от уровня представления и уровня приложения.</span><span class="sxs-lookup"><span data-stu-id="63040-193">The goal is that the domain logic in the domain model layer, its invariants, the data model, and related business rules must be completely independent from the presentation and application layers.</span></span> <span data-ttu-id="63040-194">Чаще всего уровень модели предметной области не должен напрямую зависеть ни от какой инфраструктурной платформы.</span><span class="sxs-lookup"><span data-stu-id="63040-194">Most of all, the domain model layer must not directly depend on any infrastructure framework.</span></span>

### <a name="the-infrastructure-layer"></a><span data-ttu-id="63040-195">Уровень инфраструктуры</span><span class="sxs-lookup"><span data-stu-id="63040-195">The infrastructure layer</span></span>

<span data-ttu-id="63040-196">Уровень инфраструктуры определяет способ сохранения данных, изначально содержащихся в сущности предметной области (в памяти), в базах данных или других постоянных хранилищах данных.</span><span class="sxs-lookup"><span data-stu-id="63040-196">The infrastructure layer is how the data that is initially held in domain entities (in memory) is persisted in databases or another persistent store.</span></span> <span data-ttu-id="63040-197">В примере используется код Entity Framework Core для реализации классов шаблона репозитория, которые используют класс DBContext для сохранения данных в реляционной базе данных.</span><span class="sxs-lookup"><span data-stu-id="63040-197">An example is using Entity Framework Core code to implement the Repository pattern classes that use a DBContext to persist data in a relational database.</span></span>

<span data-ttu-id="63040-198">В соответствии с ранее упомянутыми принципами [игнорирования сохраняемости](https://deviq.com/persistence-ignorance/) и [игнорирования инфраструктуры](https://ayende.com/blog/3137/infrastructure-ignorance) уровень инфраструктуры не должен "загрязнять" уровень модели предметной области.</span><span class="sxs-lookup"><span data-stu-id="63040-198">In accordance with the previously mentioned [Persistence Ignorance](https://deviq.com/persistence-ignorance/) and [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, the infrastructure layer must not “contaminate” the domain model layer.</span></span> <span data-ttu-id="63040-199">Необходимо сохранять независимость классов модели сущностей предметной области от инфраструктуры, используемой для хранения данных (EF или любой другой платформы), путем избегания жестких зависимостей от этих платформ.</span><span class="sxs-lookup"><span data-stu-id="63040-199">You must keep the domain model entity classes agnostic from the infrastructure that you use to persist data (EF or any other framework) by not taking hard dependencies on frameworks.</span></span> <span data-ttu-id="63040-200">Библиотека классов уровня модели предметной области должна иметь только код предметной области, только классы сущностей [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), являющиеся сердцем вашего программного обеспечения и полностью отделенные от технологий инфраструктуры.</span><span class="sxs-lookup"><span data-stu-id="63040-200">Your domain model layer class library should have only your domain code, just [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) entity classes implementing the heart of your software and completely decoupled from infrastructure technologies.</span></span>

<span data-ttu-id="63040-201">Таким образом, уровни, или библиотеки классов, и проекты должны в конечном счете зависеть от уровня модели предметной области (библиотеки), а не наоборот, как показано на рис. 7-7.</span><span class="sxs-lookup"><span data-stu-id="63040-201">Thus, your layers or class libraries and projects should ultimately depend on your domain model layer (library), not vice versa, as shown in Figure 7-7.</span></span>

![Зависимости в службе DDD: прикладной уровень зависит от предметной области и инфраструктуры, а инфраструктура зависит от предметной области, но предметная область не зависит ни от какого уровня.](./media/image8.png)

<span data-ttu-id="63040-203">**Рис. 7-7**.</span><span class="sxs-lookup"><span data-stu-id="63040-203">**Figure 7-7**.</span></span> <span data-ttu-id="63040-204">Зависимости между уровнями в DDD</span><span class="sxs-lookup"><span data-stu-id="63040-204">Dependencies between layers in DDD</span></span>

<span data-ttu-id="63040-205">Проектирование уровней должно выполняться отдельно для каждой микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="63040-205">This layer design should be independent for each microservice.</span></span> <span data-ttu-id="63040-206">Как отмечалось ранее, вы можете реализовать наиболее сложные микрослужбы по шаблонам DDD, тогда как при реализации простых микрослужб,управляемых данными (простой CRUD в одном уровне), использовать более простые подходы.</span><span class="sxs-lookup"><span data-stu-id="63040-206">As noted earlier, you can implement the most complex microservices following DDD patterns, while implementing simpler data-driven microservices (simple CRUD in a single layer) in a simpler way.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="63040-207">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="63040-207">Additional resources</span></span>

- <span data-ttu-id="63040-208">**DevIQ. Принцип независимости сохраняемости** </span><span class="sxs-lookup"><span data-stu-id="63040-208">**DevIQ. Persistence Ignorance principle** </span></span>\
  <https://deviq.com/persistence-ignorance/>

- <span data-ttu-id="63040-209">**Орен Эйни (Oren Eini). Независимость от инфраструктуры** </span><span class="sxs-lookup"><span data-stu-id="63040-209">**Oren Eini. Infrastructure Ignorance** </span></span>\
  <https://ayende.com/blog/3137/infrastructure-ignorance>

- <span data-ttu-id="63040-210">**Анхель Лопес (Angel Lopez). Многоуровневая архитектура при предметно-ориентированном проектировании** </span><span class="sxs-lookup"><span data-stu-id="63040-210">**Angel Lopez. Layered Architecture In Domain-Driven Design** </span></span>\
  <https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/>

>[!div class="step-by-step"]
><span data-ttu-id="63040-211">[Назад](cqrs-microservice-reads.md)
>[Вперед](microservice-domain-model.md)</span><span class="sxs-lookup"><span data-stu-id="63040-211">[Previous](cqrs-microservice-reads.md)
[Next](microservice-domain-model.md)</span></span>
