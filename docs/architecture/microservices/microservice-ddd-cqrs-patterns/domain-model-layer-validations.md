---
title: Проектирование проверок на уровне модели предметной области
description: Архитектура микрослужб .NET для упакованных в контейнеры приложений .NET | Ключевые понятия проверок на уровне модели предметной области.
ms.date: 10/08/2018
ms.openlocfilehash: d2efc5f3b3267c4573409952791c6e883a01aae2
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2020
ms.locfileid: "80988509"
---
# <a name="design-validations-in-the-domain-model-layer"></a><span data-ttu-id="1ecdf-103">Проектирование проверок на уровне модели предметной области</span><span class="sxs-lookup"><span data-stu-id="1ecdf-103">Design validations in the domain model layer</span></span>

<span data-ttu-id="1ecdf-104">В DDD правила проверки можно рассматривать как инварианты.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-104">In DDD, validation rules can be thought as invariants.</span></span> <span data-ttu-id="1ecdf-105">Главной задачей агрегата является применение инвариантов в изменениях состояния для всех сущностей внутри него.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-105">The main responsibility of an aggregate is to enforce invariants across state changes for all the entities within that aggregate.</span></span>

<span data-ttu-id="1ecdf-106">Сущности предметной области всегда должны быть допустимыми.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-106">Domain entities should always be valid entities.</span></span> <span data-ttu-id="1ecdf-107">Существует определенное количество инвариантов для объекта, которые всегда должны быть истинными.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-107">There are a certain number of invariants for an object that should always be true.</span></span> <span data-ttu-id="1ecdf-108">Например, для объекта позиции заказа всегда должно быть указано количество в виде положительного целого числа, а также название и цена изделия.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-108">For example, an order item object always has to have a quantity that must be a positive integer, plus an article name and price.</span></span> <span data-ttu-id="1ecdf-109">Таким образом, за применение инвариантов отвечают сущности предметной области (особенно для корня агрегата), а право на существование имеет только допустимый объект сущности.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-109">Therefore, invariants enforcement is the responsibility of the domain entities (especially of the aggregate root) and an entity object should not be able to exist without being valid.</span></span> <span data-ttu-id="1ecdf-110">Инвариантные правила выражаются в виде контрактов. При их нарушении вызываются исключения или выводятся уведомления.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-110">Invariant rules are simply expressed as contracts, and exceptions or notifications are raised when they are violated.</span></span>

<span data-ttu-id="1ecdf-111">Это обуславливается тем, что возникает множество ошибок, поскольку объекты находятся в состоянии, в котором они никогда не должны быть.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-111">The reasoning behind this is that many bugs occur because objects are in a state they should never have been in.</span></span> <span data-ttu-id="1ecdf-112">Далее приводится объяснение Грега Янга (Greg Young) в рамках [онлайн-обсуждения](https://jeffreypalermo.com/2009/05/the-fallacy-of-the-always-valid-entity/).</span><span class="sxs-lookup"><span data-stu-id="1ecdf-112">The following is a good explanation from Greg Young in an [online discussion](https://jeffreypalermo.com/2009/05/the-fallacy-of-the-always-valid-entity/):</span></span>

<span data-ttu-id="1ecdf-113">Предположим, что у нас есть служба SendUserCreationEmailService, принимающая UserProfile... Как в этой службе можно рационализировать тот момент, что имя имеет ненулевое значение?</span><span class="sxs-lookup"><span data-stu-id="1ecdf-113">Let's propose we now have a SendUserCreationEmailService that takes a UserProfile ... how can we rationalize in that service that Name is not null?</span></span> <span data-ttu-id="1ecdf-114">Нужно выполнять еще одну проверку?</span><span class="sxs-lookup"><span data-stu-id="1ecdf-114">Do we check it again?</span></span> <span data-ttu-id="1ecdf-115">Или, что более вероятно, вы просто игнорируете проверку и надеетесь на лучшее — вы надеетесь, что до отправки вам проверку выполнил кто-то другой.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-115">Or more likely ... you just don't bother to check and "hope for the best"—you hope that someone bothered to validate it before sending it to you.</span></span> <span data-ttu-id="1ecdf-116">Конечно, в рамках разработки на уровне тестирования один из первых создаваемых тестов должен проверять следующее условие: если сообщение отправляется клиенту с пустым именем, должна возникнуть ошибка.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-116">Of course, using TDD one of the first tests we should be writing is that if I send a customer with a null name that it should raise an error.</span></span> <span data-ttu-id="1ecdf-117">Но как только мы начинаем писать эти виды тестов снова и снова, мы понимаем, что если бы мы не разрешили использовать имя с пустым значением, всех этих тестов не было бы.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-117">But once we start writing these kinds of tests over and over again we realize ... "wait if we never allowed name to become null we wouldn't have all of these tests"</span></span>

## <a name="implement-validations-in-the-domain-model-layer"></a><span data-ttu-id="1ecdf-118">Реализация проверок на уровне модели предметной области</span><span class="sxs-lookup"><span data-stu-id="1ecdf-118">Implement validations in the domain model layer</span></span>

<span data-ttu-id="1ecdf-119">Как правило, проверки обычно реализуются в конструкторах сущностей предметной области или в методах, которые могут обновлять сущность.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-119">Validations are usually implemented in domain entity constructors or in methods that can update the entity.</span></span> <span data-ttu-id="1ecdf-120">Существует несколько способов реализации проверки, например проверка данных и вызов исключений, если проверка завершается ошибкой.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-120">There are multiple ways to implement validations, such as verifying data and raising exceptions if the validation fails.</span></span> <span data-ttu-id="1ecdf-121">Есть более сложные схемы, например использование шаблона спецификации для проверок и шаблона уведомления для возвращения коллекции ошибок вместо возвращения исключений, возникающих при каждой проверке.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-121">There are also more advanced patterns such as using the Specification pattern for validations, and the Notification pattern to return a collection of errors instead of returning an exception for each validation as it occurs.</span></span>

### <a name="validate-conditions-and-throw-exceptions"></a><span data-ttu-id="1ecdf-122">Проверка условий и создание исключений</span><span class="sxs-lookup"><span data-stu-id="1ecdf-122">Validate conditions and throw exceptions</span></span>

<span data-ttu-id="1ecdf-123">В следующем примере кода показан простейший способ проверки сущности предметной области путем создания исключения.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-123">The following code example shows the simplest approach to validation in a domain entity by raising an exception.</span></span> <span data-ttu-id="1ecdf-124">В конце этого раздела приводятся ссылки на более сложные реализации на основе шаблонов, которые обсуждались ранее.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-124">In the references table at the end of this section you can see links to more advanced implementations based on the patterns we have discussed previously.</span></span>

```csharp
public void SetAddress(Address address)
{
    _shippingAddress = address?? throw new ArgumentNullException(nameof(address));
}
```

<span data-ttu-id="1ecdf-125">В более наглядном примере демонстрируется необходимость обеспечить либо неизменность внутреннего состояния, либо возникновение всех изменений для метода.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-125">A better example would demonstrate the need to ensure that either the internal state did not change, or that all the mutations for a method occurred.</span></span> <span data-ttu-id="1ecdf-126">Например, в следующей реализации объект останется в недопустимом состоянии:</span><span class="sxs-lookup"><span data-stu-id="1ecdf-126">For example, the following implementation would leave the object in an invalid state:</span></span>

```csharp
public void SetAddress(string line1, string line2,
    string city, string state, int zip)
{
    _shippingAddress.line1 = line1 ?? throw new ...
    _shippingAddress.line2 = line2;
    _shippingAddress.city = city ?? throw new ...
    _shippingAddress.state = (IsValid(state) ? state : throw new …);
}
```

<span data-ttu-id="1ecdf-127">Если состояние имеет недопустимое значение, значит, первая строка адреса и город уже были изменены.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-127">If the value of the state is invalid, the first address line and the city have already been changed.</span></span> <span data-ttu-id="1ecdf-128">В этом случае адрес может стать недействительным.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-128">That might make the address invalid.</span></span>

<span data-ttu-id="1ecdf-129">Аналогичный подход можно использовать в конструкторе сущности, когда вызывается исключение для проверки допустимости сущности после ее создания.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-129">A similar approach can be used in the entity's constructor, raising an exception to make sure that the entity is valid once it is created.</span></span>

### <a name="use-validation-attributes-in-the-model-based-on-data-annotations"></a><span data-ttu-id="1ecdf-130">Использование атрибутов проверки в модели на основе заметок к данным</span><span class="sxs-lookup"><span data-stu-id="1ecdf-130">Use validation attributes in the model based on data annotations</span></span>

<span data-ttu-id="1ecdf-131">Заметки к данным, например атрибуты Required или MaxLength, можно использовать для настройки свойств полей базы данных EF Core, как подробно описывается в разделе [Сопоставление таблиц](infrastructure-persistence-layer-implemenation-entity-framework-core.md#table-mapping), но [они больше не работают для проверки сущностей в EF Core](https://github.com/dotnet/efcore/issues/3680) (как и метод <xref:System.ComponentModel.DataAnnotations.IValidatableObject.Validate%2A?displayProperty=nameWithType>), как это было с версии EF 4.x в .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-131">Data annotations, like the Required or MaxLength attributes, can be used to configure EF Core database field properties, as explained in detail in the [Table mapping](infrastructure-persistence-layer-implemenation-entity-framework-core.md#table-mapping) section, but [they no longer work for entity validation in EF Core](https://github.com/dotnet/efcore/issues/3680) (neither does the <xref:System.ComponentModel.DataAnnotations.IValidatableObject.Validate%2A?displayProperty=nameWithType> method), as they have done since EF 4.x in .NET Framework.</span></span>

<span data-ttu-id="1ecdf-132">Заметки к данным и интерфейс <xref:System.ComponentModel.DataAnnotations.IValidatableObject> по-прежнему можно использовать для проверки модели во время привязки модели, до вызова действий контроллера, как обычно, но эта модель должна быть моделью представления или DTO, а это задача MVC или API, а не модели предметной области.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-132">Data annotations and the <xref:System.ComponentModel.DataAnnotations.IValidatableObject> interface can still be used for model validation during model binding, prior to the controller's actions invocation as usual, but that model is meant to be a ViewModel or DTO and that's an MVC or API concern not a domain model concern.</span></span>

<span data-ttu-id="1ecdf-133">Учитывая это принципиальное различие, вы по-прежнему можете использовать заметки к данным и `IValidatableObject` в классе сущности для проверки, если ваши действия получают параметр объекта класса сущности, что не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-133">Having made the conceptual difference clear, you can still use data annotations and `IValidatableObject` in the entity class for validation, if your actions receive an entity class object parameter, which is not recommended.</span></span> <span data-ttu-id="1ecdf-134">В этом случае проверка будет проведена после привязки модели, непосредственно перед вызовом действия, и вы можете проверить свойство ModelState.IsValid контроллера для проверки результата, но повторим: это происходит в контроллере, не до сохранения объекта сущности в DbContext, как это было с версией EF 4.x.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-134">In that case, validation will occur upon model binding, just before invoking the action and you can check the controller's ModelState.IsValid property to check the result, but then again, it happens in the controller, not before persisting the entity object in the DbContext, as it had done since EF 4.x.</span></span>

<span data-ttu-id="1ecdf-135">Можно реализовать пользовательскую проверку в классе сущности с помощью заметок к данным и метода `IValidatableObject.Validate` путем переопределения метода SaveChanges для DbContext.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-135">You can still implement custom validation in the entity class using data annotations and the `IValidatableObject.Validate` method, by overriding the DbContext's SaveChanges method.</span></span>

<span data-ttu-id="1ecdf-136">Вы видите пример реализации для проверки сущностей `IValidatableObject` в [этом комментарии на GitHub](https://github.com/dotnet/efcore/issues/3680#issuecomment-155502539).</span><span class="sxs-lookup"><span data-stu-id="1ecdf-136">You can see a sample implementation for validating `IValidatableObject` entities in [this comment on GitHub](https://github.com/dotnet/efcore/issues/3680#issuecomment-155502539).</span></span> <span data-ttu-id="1ecdf-137">В этом примере не выполняются проверки на основе атрибутов, но их легко реализовать с помощью отражения в том же переопределении.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-137">That sample doesn't do attribute-based validations, but they should be easy to implement using reflection in the same override.</span></span>

<span data-ttu-id="1ecdf-138">Однако с точки зрения DDD наилучшая оптимизация модели предметной области достигается за счет использования исключений в методах поведения сущности или при реализации шаблонов спецификации и уведомления для применения правил проверки.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-138">However, from a DDD point of view, the domain model is best kept lean with the use of exceptions in your entity's behavior methods, or by implementing the Specification and Notification patterns to enforce validation rules.</span></span>

<span data-ttu-id="1ecdf-139">Заметки к данным целесообразно использовать на уровне приложения в классах ViewModel (а не в сущностях предметной области), которые будут принимать входные данные, чтобы осуществлять проверку модели на уровне пользовательского интерфейса.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-139">It can make sense to use data annotations at the application layer in ViewModel classes (instead of domain entities) that will accept input, to allow for model validation within the UI layer.</span></span> <span data-ttu-id="1ecdf-140">Однако это не должно происходить при исключении проверки в модели предметной области.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-140">However, this should not be done at the exclusion of validation within the domain model.</span></span>

### <a name="validate-entities-by-implementing-the-specification-pattern-and-the-notification-pattern"></a><span data-ttu-id="1ecdf-141">Проверка сущностей путем реализации шаблона спецификации и шаблона уведомлений</span><span class="sxs-lookup"><span data-stu-id="1ecdf-141">Validate entities by implementing the Specification pattern and the Notification pattern</span></span>

<span data-ttu-id="1ecdf-142">Наконец, более сложный подход к реализации проверок в модели предметной области заключается в реализации шаблона спецификации вместе с шаблоном уведомления, как описано в некоторых приведенных далее дополнительных ресурсах.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-142">Finally, a more elaborate approach to implementing validations in the domain model is by implementing the Specification pattern in conjunction with the Notification pattern, as explained in some of the additional resources listed later.</span></span>

<span data-ttu-id="1ecdf-143">Следует отметить, что можно использовать только один из этих шаблонов. Например, можно выполнять проверки вручную с помощью операторов управления и применять шаблон уведомления для сбора и возвращения списка ошибок, обнаруженных при проверке.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-143">It is worth mentioning that you can also use just one of those patterns—for example, validating manually with control statements, but using the Notification pattern to stack and return a list of validation errors.</span></span>

### <a name="use-deferred-validation-in-the-domain"></a><span data-ttu-id="1ecdf-144">Использование отложенной проверки в предметной области</span><span class="sxs-lookup"><span data-stu-id="1ecdf-144">Use deferred validation in the domain</span></span>

<span data-ttu-id="1ecdf-145">Существуют различные методы обработки отложенных проверок в предметной области.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-145">There are various approaches to deal with deferred validations in the domain.</span></span> <span data-ttu-id="1ecdf-146">Вон Вернон (Vaughn Vernon) рассматривает их в своей книге [Implementing Domain-Driven Design](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577) (Реализация разработки на основе предметной области) в разделе, посвященном проверке.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-146">In his book [Implementing Domain-Driven Design](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577), Vaughn Vernon discusses these in the section on validation.</span></span>

### <a name="two-step-validation"></a><span data-ttu-id="1ecdf-147">Двухэтапная проверка</span><span class="sxs-lookup"><span data-stu-id="1ecdf-147">Two-step validation</span></span>

<span data-ttu-id="1ecdf-148">Рассмотрим двухэтапную проверку.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-148">Also consider two-step validation.</span></span> <span data-ttu-id="1ecdf-149">Используйте проверку на уровне поля для объектов передачи данных (DTO) команд и проверку на уровне предметной области внутри сущностей.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-149">Use field-level validation on your command Data Transfer Objects (DTOs) and domain-level validation inside your entities.</span></span> <span data-ttu-id="1ecdf-150">Это можно сделать путем возвращения результирующего объекта вместо исключений для упрощения работы с ошибками проверки.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-150">You can do this by returning a result object instead of exceptions in order to make it easier to deal with the validation errors.</span></span>

<span data-ttu-id="1ecdf-151">Например, с помощью проверки полей с заметками к данным вы не дублируете определение проверки.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-151">Using field validation with data annotations, for example, you do not duplicate the validation definition.</span></span> <span data-ttu-id="1ecdf-152">Однако при использовании DTO (к примеру, команд и ViewModel) выполнение может осуществляться как на стороне сервера, так и на стороне клиента.</span><span class="sxs-lookup"><span data-stu-id="1ecdf-152">The execution, though, can be both server-side and client-side in the case of DTOs (commands and ViewModels, for instance).</span></span>

## <a name="additional-resources"></a><span data-ttu-id="1ecdf-153">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="1ecdf-153">Additional resources</span></span>

- <span data-ttu-id="1ecdf-154">**Рэйчел Аппель (Rachel Appel). Общие сведения о проверке модели в ASP.NET Core MVC** </span><span class="sxs-lookup"><span data-stu-id="1ecdf-154">**Rachel Appel. Introduction to model validation in ASP.NET Core MVC** </span></span>\
  <https://docs.microsoft.com/aspnet/core/mvc/models/validation>

- <span data-ttu-id="1ecdf-155">**Рик Андерсон (Rick Anderson). Добавление проверки** </span><span class="sxs-lookup"><span data-stu-id="1ecdf-155">**Rick Anderson. Adding validation** </span></span>\
  <https://docs.microsoft.com/aspnet/core/tutorials/first-mvc-app/validation>

- <span data-ttu-id="1ecdf-156">**Мартин Фоулер (Martin Fowler). Замена исключений уведомлениями в проверках** </span><span class="sxs-lookup"><span data-stu-id="1ecdf-156">**Martin Fowler. Replacing Throwing Exceptions with Notification in Validations** </span></span>\
  <https://martinfowler.com/articles/replaceThrowWithNotification.html>

- <span data-ttu-id="1ecdf-157">**Спецификация и шаблоны уведомлений** </span><span class="sxs-lookup"><span data-stu-id="1ecdf-157">**Specification and Notification Patterns** </span></span>\
  <https://www.codeproject.com/Tips/790758/Specification-and-Notification-Patterns>

- <span data-ttu-id="1ecdf-158">**Лев Городинский (Lev Gorodinski). Проверка в проблемно-ориентированном программировании (DDD)**  </span><span class="sxs-lookup"><span data-stu-id="1ecdf-158">**Lev Gorodinski. Validation in Domain-Driven Design (DDD)** </span></span>\
  <http://gorodinski.com/blog/2012/05/19/validation-in-domain-driven-design-ddd/>

- <span data-ttu-id="1ecdf-159">**Колин Джек (Colin Jack) Проверка модели предметной области** </span><span class="sxs-lookup"><span data-stu-id="1ecdf-159">**Colin Jack. Domain Model Validation** </span></span>\
  <https://colinjack.blogspot.com/2008/03/domain-model-validation.html>

- <span data-ttu-id="1ecdf-160">**Джимми Богард (Jimmy Bogard). Проверка в мире DDD** </span><span class="sxs-lookup"><span data-stu-id="1ecdf-160">**Jimmy Bogard. Validation in a DDD world** </span></span>\
  <https://lostechies.com/jimmybogard/2009/02/15/validation-in-a-ddd-world/>

> [!div class="step-by-step"]
> <span data-ttu-id="1ecdf-161">[Назад](enumeration-classes-over-enum-types.md)
> [Вперед](client-side-validation.md)</span><span class="sxs-lookup"><span data-stu-id="1ecdf-161">[Previous](enumeration-classes-over-enum-types.md)
[Next](client-side-validation.md)</span></span>
