---
title: Взаимодействие в архитектуре микрослужб
description: Ознакомьтесь с различными способами взаимодействия между микрослужбами и особенностями синхронных и асинхронных способов.
ms.date: 01/30/2020
ms.openlocfilehash: f2d6e78966bb7d5f481de6db0ab1dcfe2812a1b5
ms.sourcegitcommit: f38e527623883b92010cf4760246203073e12898
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/20/2020
ms.locfileid: "77503304"
---
# <a name="communication-in-a-microservice-architecture"></a><span data-ttu-id="332b5-103">Взаимодействие в архитектуре микрослужб</span><span class="sxs-lookup"><span data-stu-id="332b5-103">Communication in a microservice architecture</span></span>

<span data-ttu-id="332b5-104">В монолитном приложении, управляемом единым процессом, компоненты вызывают друг друга на уровне языка или с помощью вызовов функции.</span><span class="sxs-lookup"><span data-stu-id="332b5-104">In a monolithic application running on a single process, components invoke one another using language-level method or function calls.</span></span> <span data-ttu-id="332b5-105">Они могут быть тесно связаны, если вы создаете объекты с кодом (например, `new ClassName()`), или могут вызываться несвязанно, если вы используете внедрение зависимости, ссылаясь на абстракции, а не на конкретные экземпляры объекта.</span><span class="sxs-lookup"><span data-stu-id="332b5-105">These can be strongly coupled if you're creating objects with code (for example, `new ClassName()`), or can be invoked in a decoupled way if you're using Dependency Injection by referencing abstractions rather than concrete object instances.</span></span> <span data-ttu-id="332b5-106">В любом случае объекты выполняются в одном процессе.</span><span class="sxs-lookup"><span data-stu-id="332b5-106">Either way, the objects are running within the same process.</span></span> <span data-ttu-id="332b5-107">Самая сложная задача при переходе от монолитного приложения к приложению на базе микрослужб заключается в изменении механизма взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="332b5-107">The biggest challenge when changing from a monolithic application to a microservices-based application lies in changing the communication mechanism.</span></span> <span data-ttu-id="332b5-108">Прямое преобразование внутрипроцессных вызовов в вызовы RPC к службам приведет к чрезмерному и неэффективному взаимодействию, не подходящему для распределенных сред.</span><span class="sxs-lookup"><span data-stu-id="332b5-108">A direct conversion from in-process method calls into RPC calls to services will cause a chatty and not efficient communication that won't perform well in distributed environments.</span></span> <span data-ttu-id="332b5-109">Трудности разработки распределенных систем известны так хорошо, что существует свод принципов под названием [Заблуждения о распределенных вычислениях](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing), где перечислены предположения, которые часто делают разработчики при переходе от монолитных к распределенным конструкциям.</span><span class="sxs-lookup"><span data-stu-id="332b5-109">The challenges of designing distributed system properly are well enough known that there's even a canon known as the [Fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) that lists assumptions that developers often make when moving from monolithic to distributed designs.</span></span>

<span data-ttu-id="332b5-110">Единого решения не существует. Их несколько.</span><span class="sxs-lookup"><span data-stu-id="332b5-110">There isn't one solution, but several.</span></span> <span data-ttu-id="332b5-111">Одно из решений — максимальная изоляция бизнес-микрослужб.</span><span class="sxs-lookup"><span data-stu-id="332b5-111">One solution involves isolating the business microservices as much as possible.</span></span> <span data-ttu-id="332b5-112">В этом случае вы используете асинхронное взаимодействие между внутренними микрослужбами и заменяете детальное взаимодействие, типичное для внутрипроцессной связи между объектами, менее детальным.</span><span class="sxs-lookup"><span data-stu-id="332b5-112">You then use asynchronous communication between the internal microservices and replace fine-grained communication that's typical in intra-process communication between objects with coarser-grained communication.</span></span> <span data-ttu-id="332b5-113">Для этого вы группируете вызовы и возвращаете клиенту данные, агрегирующие результаты нескольких внутренних вызовов.</span><span class="sxs-lookup"><span data-stu-id="332b5-113">You can do this by grouping calls, and by returning data that aggregates the results of multiple internal calls, to the client.</span></span>

<span data-ttu-id="332b5-114">Приложение на основе микрослужб представляет собой распределенную систему, работающую на нескольких процессах или службах, иногда даже не нескольких серверах или узлах.</span><span class="sxs-lookup"><span data-stu-id="332b5-114">A microservices-based application is a distributed system running on multiple processes or services, usually even across multiple servers or hosts.</span></span> <span data-ttu-id="332b5-115">Обычно каждый экземпляр службы — это процесс.</span><span class="sxs-lookup"><span data-stu-id="332b5-115">Each service instance is typically a process.</span></span> <span data-ttu-id="332b5-116">Таким образом, службы должны взаимодействовать по протоколу внутрипроцессного взаимодействия, например HTTP, AMQP или двоичному протоколу, такому как TCP, в зависимости от характера каждой службы.</span><span class="sxs-lookup"><span data-stu-id="332b5-116">Therefore, services must interact using an inter-process communication protocol such as HTTP, AMQP, or a binary protocol like TCP, depending on the nature of each service.</span></span>

<span data-ttu-id="332b5-117">Сообщество микрослужб исповедует философию "[умные конечные точки и глупые каналы](https://simplicable.com/new/smart-endpoints-and-dumb-pipes)". Этот слоган рекомендует создавать структуру, где отдельные микрослужбы будут минимально зависеть друг от друга и иметь максимальную внутреннюю согласованность.</span><span class="sxs-lookup"><span data-stu-id="332b5-117">The microservice community promotes the philosophy of "[smart endpoints and dumb pipes](https://simplicable.com/new/smart-endpoints-and-dumb-pipes)" This slogan encourages a design that's as decoupled as possible between microservices, and as cohesive as possible within a single microservice.</span></span> <span data-ttu-id="332b5-118">Как уже говорилось, каждая микрослужба обладает собственными данными и собственной логикой предметной области.</span><span class="sxs-lookup"><span data-stu-id="332b5-118">As explained earlier, each microservice owns its own data and its own domain logic.</span></span> <span data-ttu-id="332b5-119">Но микрослужбы, составляющие цельное приложение, обычно организуются с помощью связей по принципу REST, а не сложных протоколов, таких как WS-\*, и гибких, управляемых событиями взаимодействий вместо централизованных оркестраторов бизнес-процессов.</span><span class="sxs-lookup"><span data-stu-id="332b5-119">But the microservices composing an end-to-end application are usually simply choreographed by using REST communications rather than complex protocols such as WS-\* and flexible event-driven communications instead of centralized business-process-orchestrators.</span></span>

<span data-ttu-id="332b5-120">Обычно используются два протокола — запросы и ответы HTTP с исходными API (в основном для запросов) и легкие асинхронные сообщения при передаче обновлений в несколько микрослужб.</span><span class="sxs-lookup"><span data-stu-id="332b5-120">The two commonly used protocols are HTTP request/response with resource APIs (when querying most of all), and lightweight asynchronous messaging when communicating updates across multiple microservices.</span></span> <span data-ttu-id="332b5-121">Более подробно это описано в следующих разделах.</span><span class="sxs-lookup"><span data-stu-id="332b5-121">These are explained in more detail in the following sections.</span></span>

## <a name="communication-types"></a><span data-ttu-id="332b5-122">Типы связи</span><span class="sxs-lookup"><span data-stu-id="332b5-122">Communication types</span></span>

<span data-ttu-id="332b5-123">Клиент и службы могут взаимодействовать через различные типы связи в зависимости от сценария и целей.</span><span class="sxs-lookup"><span data-stu-id="332b5-123">Client and services can communicate through many different types of communication, each one targeting a different scenario and goals.</span></span> <span data-ttu-id="332b5-124">Эти типы связи можно разделить на два направления.</span><span class="sxs-lookup"><span data-stu-id="332b5-124">Initially, those types of communications can be classified in two axes.</span></span>

<span data-ttu-id="332b5-125">Первая группа определяет, является протокол синхронным или асинхронным:</span><span class="sxs-lookup"><span data-stu-id="332b5-125">The first axis defines if the protocol is synchronous or asynchronous:</span></span>

- <span data-ttu-id="332b5-126">Синхронный протокол.</span><span class="sxs-lookup"><span data-stu-id="332b5-126">Synchronous protocol.</span></span> <span data-ttu-id="332b5-127">HTTP — это синхронный протокол.</span><span class="sxs-lookup"><span data-stu-id="332b5-127">HTTP is a synchronous protocol.</span></span> <span data-ttu-id="332b5-128">Клиент отправляет запрос и ожидает ответа от службы.</span><span class="sxs-lookup"><span data-stu-id="332b5-128">The client sends a request and waits for a response from the service.</span></span> <span data-ttu-id="332b5-129">Это не зависит от выполнения кода клиента, которое может быть синхронным (поток заблокирован) или асинхронным (поток не заблокирован, ответ в конечном итоге будет отправлен).</span><span class="sxs-lookup"><span data-stu-id="332b5-129">That's independent of the client code execution that could be synchronous (thread is blocked) or asynchronous (thread isn't blocked, and the response will reach a callback eventually).</span></span> <span data-ttu-id="332b5-130">Здесь важно, что протокол (HTTP/HTTPS) является синхронным и код клиента сможет продолжить выполнение задачи только после получения ответа от HTTP-сервера.</span><span class="sxs-lookup"><span data-stu-id="332b5-130">The important point here is that the protocol (HTTP/HTTPS) is synchronous and the client code can only continue its task when it receives the HTTP server response.</span></span>

- <span data-ttu-id="332b5-131">Асинхронный протокол.</span><span class="sxs-lookup"><span data-stu-id="332b5-131">Asynchronous protocol.</span></span> <span data-ttu-id="332b5-132">Другие протоколы, например AMQP (протокол, поддерживаемый многими операционными системами и облачными средами), используют асинхронные сообщения.</span><span class="sxs-lookup"><span data-stu-id="332b5-132">Other protocols like AMQP (a protocol supported by many operating systems and cloud environments) use asynchronous messages.</span></span> <span data-ttu-id="332b5-133">Код клиента или отправитель сообщения обычно не ожидает ответа.</span><span class="sxs-lookup"><span data-stu-id="332b5-133">The client code or message sender usually doesn't wait for a response.</span></span> <span data-ttu-id="332b5-134">Он просто отправляет сообщение, как при отправке сообщения в очередь RabbitMQ или другого брокера сообщений.</span><span class="sxs-lookup"><span data-stu-id="332b5-134">It just sends the message as when sending a message to a RabbitMQ queue or any other message broker.</span></span>

<span data-ttu-id="332b5-135">Вторая группа определяет, имеет запрос одного или нескольких получателей:</span><span class="sxs-lookup"><span data-stu-id="332b5-135">The second axis defines if the communication has a single receiver or multiple receivers:</span></span>

- <span data-ttu-id="332b5-136">Один получатель.</span><span class="sxs-lookup"><span data-stu-id="332b5-136">Single receiver.</span></span> <span data-ttu-id="332b5-137">Каждый запрос должен обрабатываться только одним получателем или службой.</span><span class="sxs-lookup"><span data-stu-id="332b5-137">Each request must be processed by exactly one receiver or service.</span></span> <span data-ttu-id="332b5-138">Например, [шаблон Command](https://en.wikipedia.org/wiki/Command_pattern).</span><span class="sxs-lookup"><span data-stu-id="332b5-138">An example of this communication is the [Command pattern](https://en.wikipedia.org/wiki/Command_pattern).</span></span>

- <span data-ttu-id="332b5-139">Несколько получателей.</span><span class="sxs-lookup"><span data-stu-id="332b5-139">Multiple receivers.</span></span> <span data-ttu-id="332b5-140">Каждый запрос может обрабатываться разным количеством получателей — от нуля до нескольких.</span><span class="sxs-lookup"><span data-stu-id="332b5-140">Each request can be processed by zero to multiple receivers.</span></span> <span data-ttu-id="332b5-141">Такой тип взаимодействия должен быть асинхронным.</span><span class="sxs-lookup"><span data-stu-id="332b5-141">This type of communication must be asynchronous.</span></span> <span data-ttu-id="332b5-142">Например, механизм [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern), используемый в таких шаблонах, как [архитектура, управляемая событиями](https://microservices.io/patterns/data/event-driven-architecture.html).</span><span class="sxs-lookup"><span data-stu-id="332b5-142">An example is the [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mechanism used in patterns like [Event-driven architecture](https://microservices.io/patterns/data/event-driven-architecture.html).</span></span> <span data-ttu-id="332b5-143">Он основан на интерфейсе шины событий или брокере сообщений, когда события обновляют данные в нескольких микрослужбах. Обычно это реализуется через служебную шину или подобный объект, например [служебную шину Azure](https://azure.microsoft.com/services/service-bus/), с помощью [тем и подписок](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span><span class="sxs-lookup"><span data-stu-id="332b5-143">This is based on an event-bus interface or message broker when propagating data updates between multiple microservices through events; it's usually implemented through a service bus or similar artifact like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) by using [topics and subscriptions](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span>

<span data-ttu-id="332b5-144">Приложение на базе микрослужб часто использует комбинацию этих стилей взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="332b5-144">A microservice-based application will often use a combination of these communication styles.</span></span> <span data-ttu-id="332b5-145">Наиболее распространенный тип — взаимодействие с одним получателем по синхронному протоколу, например HTTP или HTTPS, при вызове обычной службы веб-API HTTP.</span><span class="sxs-lookup"><span data-stu-id="332b5-145">The most common type is single-receiver communication with a synchronous protocol like HTTP/HTTPS when invoking a regular Web API HTTP service.</span></span> <span data-ttu-id="332b5-146">Для асинхронного взаимодействия между микрослужбами обычно используются протоколы сообщений.</span><span class="sxs-lookup"><span data-stu-id="332b5-146">Microservices also typically use messaging protocols for asynchronous communication between microservices.</span></span>

<span data-ttu-id="332b5-147">Полезно знать об этих направлениях, чтобы разбираться в доступных механизмах взаимодействия, но это не самый важный аспект создания микрослужб.</span><span class="sxs-lookup"><span data-stu-id="332b5-147">These axes are good to know so you have clarity on the possible communication mechanisms, but they're not the important concerns when building microservices.</span></span> <span data-ttu-id="332b5-148">Ни асинхронность выполнения потока клиента, ни асинхронность выбранного протокола не так важна при интеграции микрослужб.</span><span class="sxs-lookup"><span data-stu-id="332b5-148">Neither the asynchronous nature of client thread execution nor the asynchronous nature of the selected protocol are the important points when integrating microservices.</span></span> <span data-ttu-id="332b5-149">Что *важно*, так это возможность асинхронной интеграции микрослужб без ущерба для их независимости, как описывается в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="332b5-149">What *is* important is being able to integrate your microservices asynchronously while maintaining the independence of microservices, as explained in the following section.</span></span>

## <a name="asynchronous-microservice-integration-enforces-microservices-autonomy"></a><span data-ttu-id="332b5-150">Асинхронная интеграция микрослужб способствует их автономности</span><span class="sxs-lookup"><span data-stu-id="332b5-150">Asynchronous microservice integration enforces microservice's autonomy</span></span>

<span data-ttu-id="332b5-151">Как уже упоминалось, при создании приложения на базе микрослужб важно подумать о способе их интеграции.</span><span class="sxs-lookup"><span data-stu-id="332b5-151">As mentioned, the important point when building a microservices-based application is the way you integrate your microservices.</span></span> <span data-ttu-id="332b5-152">В идеале взаимодействие между внутренними микрослужбами необходимо свести к минимуму.</span><span class="sxs-lookup"><span data-stu-id="332b5-152">Ideally, you should try to minimize the communication between the internal microservices.</span></span> <span data-ttu-id="332b5-153">Чем меньше взаимодействия между микрослужбами, тем лучше.</span><span class="sxs-lookup"><span data-stu-id="332b5-153">The fewer communications between microservices, the better.</span></span> <span data-ttu-id="332b5-154">Вам часто придется каким-то образом интегрировать микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="332b5-154">But in many cases, you'll have to somehow integrate the microservices.</span></span> <span data-ttu-id="332b5-155">И когда это необходимо, помните, что взаимодействие между микрослужбами обязательно должно быть асинхронным.</span><span class="sxs-lookup"><span data-stu-id="332b5-155">When you need to do that, the critical rule here is that the communication between the microservices should be asynchronous.</span></span> <span data-ttu-id="332b5-156">Это не означает, что нужно использовать конкретный протокол (например, асинхронный обмен сообщениями, а не синхронный HTTP).</span><span class="sxs-lookup"><span data-stu-id="332b5-156">That doesn't mean that you have to use a specific protocol (for example, asynchronous messaging versus synchronous HTTP).</span></span> <span data-ttu-id="332b5-157">Просто взаимодействие между микрослужбами должно происходить только путем асинхронного распространения данных. Но попытайтесь устранить зависимость от других внутренних микрослужб в начальной операции запроса-ответа HTTP.</span><span class="sxs-lookup"><span data-stu-id="332b5-157">It just means that the communication between microservices should be done only by propagating data asynchronously, but try not to depend on other internal microservices as part of the initial service's HTTP request/response operation.</span></span>

<span data-ttu-id="332b5-158">Если это возможно, никогда не используйте синхронное взаимодействие (запрос-ответ) между несколькими микрослужбами, даже для запросов.</span><span class="sxs-lookup"><span data-stu-id="332b5-158">If possible, never depend on synchronous communication (request/response) between multiple microservices, not even for queries.</span></span> <span data-ttu-id="332b5-159">Каждая микрослужба должна быть автономной и доступной для клиента, даже если другие службы в этом приложении отключены или не работают.</span><span class="sxs-lookup"><span data-stu-id="332b5-159">The goal of each microservice is to be autonomous and available to the client consumer, even if the other services that are part of the end-to-end application are down or unhealthy.</span></span> <span data-ttu-id="332b5-160">Если вы считаете, что одна микрослужба должна обращаться к другой (например, отправлять HTTP-запрос на получение данных), чтобы предоставить ответ клиентскому приложению, вы создадите архитектуру, неустойчивую к сбоям.</span><span class="sxs-lookup"><span data-stu-id="332b5-160">If you think you need to make a call from one microservice to other microservices (like performing an HTTP request for a data query) to be able to provide a response to a client application, you have an architecture that won't be resilient when some microservices fail.</span></span>

<span data-ttu-id="332b5-161">Более того, наличие зависимостей HTTP между микрослужбами, как при создании длинных циклов запрос-ответ с цепочкой HTTP-запросов, как показано в первой части рисунка 4-15, не только нарушит автономность микрослужб, но и повлияет на их производительность, если одна из служб в цепочке не будет работать правильно.</span><span class="sxs-lookup"><span data-stu-id="332b5-161">Moreover, having HTTP dependencies between microservices, like when creating long request/response cycles with HTTP request chains, as shown in the first part of the Figure 4-15, not only makes your microservices not autonomous but also their performance is impacted as soon as one of the services in that chain isn't performing well.</span></span>

<span data-ttu-id="332b5-162">Чем больше синхронных зависимостей между микрослужбами, например запросов, тем больше время отклика в клиентских приложениях.</span><span class="sxs-lookup"><span data-stu-id="332b5-162">The more you add synchronous dependencies between microservices, such as query requests, the worse the overall response time gets for the client apps.</span></span>

![Схема, на которой показано три типа взаимодействия между микрослужбами.](./media/communication-in-microservice-architecture/sync-vs-async-patterns-across-microservices.png)

<span data-ttu-id="332b5-164">**Рис. 4-15**.</span><span class="sxs-lookup"><span data-stu-id="332b5-164">**Figure 4-15**.</span></span> <span data-ttu-id="332b5-165">Антишаблоны и шаблоны при взаимодействии между микрослужбами</span><span class="sxs-lookup"><span data-stu-id="332b5-165">Anti-patterns and patterns in communication between microservices</span></span>

<span data-ttu-id="332b5-166">Как показано на схеме выше, при синхронном обмене данными "цепочка" запросов создается между микрослужбами при обслуживании запроса клиента.</span><span class="sxs-lookup"><span data-stu-id="332b5-166">As shown in the above diagram, in synchronous communication a "chain" of requests is created between microservices while serving the client request.</span></span> <span data-ttu-id="332b5-167">Это антишаблон.</span><span class="sxs-lookup"><span data-stu-id="332b5-167">This is an anti-pattern.</span></span> <span data-ttu-id="332b5-168">В асинхронной связи микрослужбы используют асинхронные сообщения или опрос по HTTP для взаимодействия с другими микрослужбами, но запрос клиента обрабатывается сразу.</span><span class="sxs-lookup"><span data-stu-id="332b5-168">In asynchronous communication microservices use asynchronous messages or http polling to communicate with other microservices, but the client request is served right away.</span></span>

<span data-ttu-id="332b5-169">Если микрослужба должна вызвать дополнительное действие в другой микрослужбе, по возможности не выполняйте это действие синхронно в рамках исходной операции запроса и ответа микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="332b5-169">If your microservice needs to raise an additional action in another microservice, if possible, do not perform that action synchronously and as part of the original microservice request and reply operation.</span></span> <span data-ttu-id="332b5-170">Руководствуйтесь принципом асинхронности (с помощью асинхронного обмена сообщениями или событий интеграции, очередей и т. д.).</span><span class="sxs-lookup"><span data-stu-id="332b5-170">Instead, do it asynchronously (using asynchronous messaging or integration events, queues, etc.).</span></span> <span data-ttu-id="332b5-171">Старайтесь не вызывать действие синхронно в рамках исходной синхронной операции запроса и ответа.</span><span class="sxs-lookup"><span data-stu-id="332b5-171">But, as much as possible, do not invoke the action synchronously as part of the original synchronous request and reply operation.</span></span>

<span data-ttu-id="332b5-172">И, наконец (и именно на этом этапе создания микрослужб возникают проблемы), если исходной микрослужбе нужны данные, принадлежащие другим микрослужбам, не создавайте синхронные запросы этих данных.</span><span class="sxs-lookup"><span data-stu-id="332b5-172">And finally (and this is where most of the issues arise when building microservices), if your initial microservice needs data that's originally owned by other microservices, do not rely on making synchronous requests for that data.</span></span> <span data-ttu-id="332b5-173">Лучше реплицировать или распространять эти данные (только необходимые атрибуты) в базу данных исходной службы, используя итоговую согласованность (обычно с помощью событий интеграции, как описано в следующих разделах).</span><span class="sxs-lookup"><span data-stu-id="332b5-173">Instead, replicate or propagate that data (only the attributes you need) into the initial service's database by using eventual consistency (typically by using integration events, as explained in upcoming sections).</span></span>

<span data-ttu-id="332b5-174">Как уже упоминалось в статье [Определение границ модели предметной области для каждой микрослужбы](identify-microservice-domain-model-boundaries.md), дублирование данных в нескольких микрослужбах допускается. Более того, таким образом вы сможете перевести данные на конкретный язык, используя термины этой области или ограниченного контекста.</span><span class="sxs-lookup"><span data-stu-id="332b5-174">As noted earlier in the [Identifying domain-model boundaries for each microservice](identify-microservice-domain-model-boundaries.md) section, duplicating some data across several microservices isn't an incorrect design—on the contrary, when doing that you can translate the data into the specific language or terms of that additional domain or Bounded Context.</span></span> <span data-ttu-id="332b5-175">Например, в [приложении eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers) есть микрослужба `identity-api`, которая отвечает за большую часть данных пользователя с сущностью, называемой `User`.</span><span class="sxs-lookup"><span data-stu-id="332b5-175">For instance, in the [eShopOnContainers application](https://github.com/dotnet-architecture/eShopOnContainers) you have a microservice named `identity-api` that's in charge of most of the user's data with an entity named `User`.</span></span> <span data-ttu-id="332b5-176">Но если вам нужно хранить данные о пользователе в микрослужбе `Ordering`, вы используете отдельную сущность под названием `Buyer`.</span><span class="sxs-lookup"><span data-stu-id="332b5-176">However, when you need to store data about the user within the `Ordering` microservice, you store it as a different entity named `Buyer`.</span></span> <span data-ttu-id="332b5-177">Сущность `Buyer` имеет тот же идентификатор, что и исходная сущность `User`, но содержит лишь некоторые атрибуты, необходимые для предметной области `Ordering`, а не весь профиль пользователя.</span><span class="sxs-lookup"><span data-stu-id="332b5-177">The `Buyer` entity shares the same identity with the original `User` entity, but it might have only the few attributes needed by the `Ordering` domain, and not the whole user profile.</span></span>

<span data-ttu-id="332b5-178">Вы можете использовать любой протокол для асинхронной передачи и распространения данных в микрослужбах, чтобы достичь итоговой согласованности.</span><span class="sxs-lookup"><span data-stu-id="332b5-178">You might use any protocol to communicate and propagate data asynchronously across microservices in order to have eventual consistency.</span></span> <span data-ttu-id="332b5-179">Как уже упоминалось, можно использовать события интеграции с помощью шины событий или брокера сообщений или даже HTTP, чтобы опрашивать другие службы.</span><span class="sxs-lookup"><span data-stu-id="332b5-179">As mentioned, you could use integration events using an event bus or message broker or you could even use HTTP by polling the other services instead.</span></span> <span data-ttu-id="332b5-180">Это неважно.</span><span class="sxs-lookup"><span data-stu-id="332b5-180">It doesn't matter.</span></span> <span data-ttu-id="332b5-181">Главное правило — не создавать синхронные зависимости между микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="332b5-181">The important rule is to not create synchronous dependencies between your microservices.</span></span>

<span data-ttu-id="332b5-182">В следующих разделах описываются разные стили взаимодействия, которые вы можете использовать в приложении на базе микрослужб.</span><span class="sxs-lookup"><span data-stu-id="332b5-182">The following sections explain the multiple communication styles you can consider using in a microservice-based application.</span></span>

## <a name="communication-styles"></a><span data-ttu-id="332b5-183">Стили взаимодействия</span><span class="sxs-lookup"><span data-stu-id="332b5-183">Communication styles</span></span>

<span data-ttu-id="332b5-184">Вы можете выбирать разные протоколы для взаимодействия в зависимости от желаемого типа взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="332b5-184">There are many protocols and choices you can use for communication, depending on the communication type you want to use.</span></span> <span data-ttu-id="332b5-185">В качестве механизма взаимодействия с помощью синхронных запросов и ответов обычно используются HTTP и REST, особенно если вы публикуете службы за пределами узла Docker или кластера микрослужб.</span><span class="sxs-lookup"><span data-stu-id="332b5-185">If you're using a synchronous request/response-based communication mechanism, protocols such as HTTP and REST approaches are the most common, especially if you're publishing your services outside the Docker host or microservice cluster.</span></span> <span data-ttu-id="332b5-186">Если взаимодействие между службами осуществляется в пределах узла Docker или кластера микрослужб, вы можете использовать двоичный формат взаимодействия (например, WCF с помощью TCP и двоичного формата).</span><span class="sxs-lookup"><span data-stu-id="332b5-186">If you're communicating between services internally (within your Docker host or microservices cluster), you might also want to use binary format communication mechanisms (like WCF using TCP and binary format).</span></span> <span data-ttu-id="332b5-187">Кроме того, вы можете использовать механизмы асинхронного взаимодействия на основе сообщений, например AMQP.</span><span class="sxs-lookup"><span data-stu-id="332b5-187">Alternatively, you can use asynchronous, message-based communication mechanisms such as AMQP.</span></span>

<span data-ttu-id="332b5-188">Существует также несколько форматов сообщений, например JSON или XML, или даже двоичных форматов, которые могут быть более эффективными.</span><span class="sxs-lookup"><span data-stu-id="332b5-188">There are also multiple message formats like JSON or XML, or even binary formats, which can be more efficient.</span></span> <span data-ttu-id="332b5-189">Если вы выбрали нестандартный двоичный формат, возможно, службы с этим форматом не следует публиковать.</span><span class="sxs-lookup"><span data-stu-id="332b5-189">If your chosen binary format isn't a standard, it's probably not a good idea to publicly publish your services using that format.</span></span> <span data-ttu-id="332b5-190">Вы можете использовать нестандартный формат для внутреннего взаимодействия между микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="332b5-190">You could use a non-standard format for internal communication between your microservices.</span></span> <span data-ttu-id="332b5-191">Например, при взаимодействии между микрослужбами на узле Docker или кластере микрослужб (в оркестраторах Docker) или для собственных клиентских приложений, которые обращаются к микрослужбам.</span><span class="sxs-lookup"><span data-stu-id="332b5-191">You might do this when communicating between microservices within your Docker host or microservice cluster (for example, Docker orchestrators), or for proprietary client applications that talk to the microservices.</span></span>

### <a name="requestresponse-communication-with-http-and-rest"></a><span data-ttu-id="332b5-192">Операция запрос-ответ с использованием HTTP и REST</span><span class="sxs-lookup"><span data-stu-id="332b5-192">Request/response communication with HTTP and REST</span></span>

<span data-ttu-id="332b5-193">Если клиент использует взаимодействие типа "запрос-ответ", он посылает запрос к службе, которая обрабатывает этот запрос и отправляет ответ.</span><span class="sxs-lookup"><span data-stu-id="332b5-193">When a client uses request/response communication, it sends a request to a service, then the service processes the request and sends back a response.</span></span> <span data-ttu-id="332b5-194">Взаимодействие типа "запрос-ответ" особенно хорошо подходит для запроса данных от клиентских приложений для пользовательского интерфейса в режиме реального времени.</span><span class="sxs-lookup"><span data-stu-id="332b5-194">Request/response communication is especially well suited for querying data for a real-time UI (a live user interface) from client apps.</span></span> <span data-ttu-id="332b5-195">Поэтому в архитектуре микрослужб лучше всего использовать этот механизм взаимодействия для запросов, как показано на рис. 4-16.</span><span class="sxs-lookup"><span data-stu-id="332b5-195">Therefore, in a microservice architecture you'll probably use this communication mechanism for most queries, as shown in Figure 4-16.</span></span>

![Схема, на которой показано взаимодействие типа "запрос — ответ" для активных запросов и обновлений.](./media/communication-in-microservice-architecture/request-response-comms-live-queries-updates.png)

<span data-ttu-id="332b5-197">**Рис. 4-16**.</span><span class="sxs-lookup"><span data-stu-id="332b5-197">**Figure 4-16**.</span></span> <span data-ttu-id="332b5-198">Использование взаимодействия типа "запрос-ответ" по протоколу HTTP (синхронно или асинхронно)</span><span class="sxs-lookup"><span data-stu-id="332b5-198">Using HTTP request/response communication (synchronous or asynchronous)</span></span>

<span data-ttu-id="332b5-199">Когда клиент использует взаимодействие типа "запрос-ответ", он предполагает, что ответ придет быстро, меньше чем через секунду или максимум через несколько секунд.</span><span class="sxs-lookup"><span data-stu-id="332b5-199">When a client uses request/response communication, it assumes that the response will arrive in a short time, typically less than a second, or a few seconds at most.</span></span> <span data-ttu-id="332b5-200">Если ответ задерживается, необходимо реализовать асинхронное взаимодействие на основе [шаблонов обмена сообщениями](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) и [технологий обмена сообщениями](https://en.wikipedia.org/wiki/Message-oriented_middleware). Этот подход рассматривается в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="332b5-200">For delayed responses, you need to implement asynchronous communication based on [messaging patterns](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) and [messaging technologies](https://en.wikipedia.org/wiki/Message-oriented_middleware), which is a different approach that we explain in the next section.</span></span>

<span data-ttu-id="332b5-201">Популярный стиль архитектуры для взаимодействия типа "запрос-ответ" — это [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span><span class="sxs-lookup"><span data-stu-id="332b5-201">A popular architectural style for request/response communication is [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span></span> <span data-ttu-id="332b5-202">Этот подход основан на [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)-протоколе и тесно связан с ним. Он принимает HTTP-команды, например GET, POST и PUT.</span><span class="sxs-lookup"><span data-stu-id="332b5-202">This approach is based on, and tightly coupled to, the [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protocol, embracing HTTP verbs like GET, POST, and PUT.</span></span> <span data-ttu-id="332b5-203">REST — это самый распространенный архитектурный подход к взаимодействию при создании служб.</span><span class="sxs-lookup"><span data-stu-id="332b5-203">REST is the most commonly used architectural communication approach when creating services.</span></span> <span data-ttu-id="332b5-204">Службы REST можно использовать при разработке служб веб-API ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="332b5-204">You can implement REST services when you develop ASP.NET Core Web API services.</span></span>

<span data-ttu-id="332b5-205">Использование служб HTTP REST в качестве IDL имеет дополнительные преимущества.</span><span class="sxs-lookup"><span data-stu-id="332b5-205">There's additional value when using HTTP REST services as your interface definition language.</span></span> <span data-ttu-id="332b5-206">Например, если вы используете [метаданные Swagger](https://swagger.io/) для описания API службы, вы можете применять средства, создающие заглушки клиента, которые могут обнаруживать и использовать ваши службы напрямую.</span><span class="sxs-lookup"><span data-stu-id="332b5-206">For instance, if you use [Swagger metadata](https://swagger.io/) to describe your service API, you can use tools that generate client stubs that can directly discover and consume your services.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="332b5-207">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="332b5-207">Additional resources</span></span>

- <span data-ttu-id="332b5-208">**Мартин Фоулер (Martin Fowler). Модель зрелости Ричардсона** Описание модели REST.</span><span class="sxs-lookup"><span data-stu-id="332b5-208">**Martin Fowler. Richardson Maturity Model** A description of the REST model.</span></span> \
  <https://martinfowler.com/articles/richardsonMaturityModel.html>

- <span data-ttu-id="332b5-209">**Swagger** Официальный сайт.</span><span class="sxs-lookup"><span data-stu-id="332b5-209">**Swagger** The official site.</span></span> \
  <https://swagger.io/>

### <a name="push-and-real-time-communication-based-on-http"></a><span data-ttu-id="332b5-210">Push-уведомления и связь в режиме реального времени по протоколу HTTP</span><span class="sxs-lookup"><span data-stu-id="332b5-210">Push and real-time communication based on HTTP</span></span>

<span data-ttu-id="332b5-211">Другой вариант (обычно используется не для тех же целей, что и REST) — это связь "один ко многим" в режиме реального времени с платформами более высокого уровня, например [ASP.NET SignalR](https://www.asp.net/signalr), и такими протоколами, как [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span><span class="sxs-lookup"><span data-stu-id="332b5-211">Another possibility (usually for different purposes than REST) is a real-time and one-to-many communication with higher-level frameworks such as [ASP.NET SignalR](https://www.asp.net/signalr) and protocols such as [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span></span>

<span data-ttu-id="332b5-212">Как показано на рисунке 4-17, связь в режиме реального времени по протоколу HTTP означает, что серверный код может принудительно отправлять содержимое подключенным клиентам, когда данные становятся доступны, а не ждать, пока клиент запросит новые данные.</span><span class="sxs-lookup"><span data-stu-id="332b5-212">As Figure 4-17 shows, real-time HTTP communication means that you can have server code pushing content to connected clients as the data becomes available, rather than having the server wait for a client to request new data.</span></span>

![Схема, на которой показана отправка содержимого и взаимодействие в реальном времени на основе службы SignalR.](./media/communication-in-microservice-architecture/one-to-many-communication.png)

<span data-ttu-id="332b5-214">**Рис. 4-17**.</span><span class="sxs-lookup"><span data-stu-id="332b5-214">**Figure 4-17**.</span></span> <span data-ttu-id="332b5-215">Асинхронное взаимодействие один к одному на основе сообщений в режиме реального времени</span><span class="sxs-lookup"><span data-stu-id="332b5-215">One-to-one real-time asynchronous message communication</span></span>

<span data-ttu-id="332b5-216">SignalR — это лучший способ достичь взаимодействия в реальном времени для передачи содержимого клиентам с внутреннего сервера.</span><span class="sxs-lookup"><span data-stu-id="332b5-216">SignalR is a good way to achieve real-time communication for pushing content to the clients from a back-end server.</span></span> <span data-ttu-id="332b5-217">Поскольку взаимодействие происходит в режиме реального времени, изменения отображаются в клиентских приложениях почти моментально.</span><span class="sxs-lookup"><span data-stu-id="332b5-217">Since communication is in real time, client apps show the changes almost instantly.</span></span> <span data-ttu-id="332b5-218">Обычно это обрабатывается таким протоколом, как WebSockets, с помощью множества подключений WebSockets (по одному для каждого клиента).</span><span class="sxs-lookup"><span data-stu-id="332b5-218">This is usually handled by a protocol such as WebSockets, using many WebSockets connections (one per client).</span></span> <span data-ttu-id="332b5-219">Типичный пример — служба передает изменение счета матча множеству клиентских веб-приложений одновременно.</span><span class="sxs-lookup"><span data-stu-id="332b5-219">A typical example is when a service communicates a change in the score of a sports game to many client web apps simultaneously.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="332b5-220">[Назад](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
>[Вперед](asynchronous-message-based-communication.md)</span><span class="sxs-lookup"><span data-stu-id="332b5-220">[Previous](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
[Next](asynchronous-message-based-communication.md)</span></span>
