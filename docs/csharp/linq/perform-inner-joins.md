---
title: Выполнение внутренних соединений (LINQ в C#)
description: Узнайте, как выполнять внутренние соединения с помощью LINQ в C#.
ms.date: 12/01/2016
ms.assetid: 45bceed6-f549-4114-a9b1-b44feb497742
ms.openlocfilehash: a3e8e9bd97ec630797bc48a3302b27ed45d9103e
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "61659843"
---
# <a name="perform-inner-joins"></a>Выполнение внутренних соединений

В терминах реляционных баз данных *внутреннее соединение* формирует результирующий набор, в котором каждый элемент первой коллекции отображается по одному разу для каждого соответствующего элемента во второй коллекции. Если для элемента в первой коллекции нет соответствующих элементов, он не отображается в результирующем наборе. Метод <xref:System.Linq.Enumerable.Join%2A>, который вызывается предложением `join` в C#, реализует внутреннее соединение.

В этой статье показано выполнение четырех видов внутреннего соединения:

- Простое внутреннее соединение, сопоставляющее элементы из двух источников данных на основе простого ключа.

- Внутреннее соединение, сопоставляющее элементы из двух источников данных на основе *составного* ключа. Составной ключ — это ключ, который состоит из нескольких значений, позволяющих сопоставлять элементы на основе сразу нескольких свойств.

- *Множественное соединение*, при котором несколько последовательных операций соединения добавляются друг к другу.

- Внутреннее соединение, реализуемое с помощью группового соединения.

## <a name="example---simple-key-join"></a>Пример соединения по простому ключу

В следующем примере создаются две коллекции, содержащие объекты двух определяемых пользователем типов, `Person` и `Pet`. Запрос включает предложение `join` в C# для сопоставления объектов `Person` с объектами `Pet`, где `Owner` — это `Person`. Предложение `select` в C# определяет, как будут выглядеть результирующие объекты. В этом примере результирующие объекты — это анонимные типы, состоящие из имени владельца и его домашнего животного.

[!code-csharp[CsLINQProgJoining#1](~/samples/snippets/csharp/concepts/linq/how-to-perform-inner-joins_1.cs)]

Обратите внимание на то, что объект `Person`, параметр `LastName` которого имеет значение "Huff", не отображается в результирующем наборе, поскольку нет объекта `Pet`, параметр `Pet.Owner` которого совпадает с этим объектом `Person`.

## <a name="example---composite-key-join"></a>Пример соединения по составному ключу

Вместо сопоставления элементов по одному единственному свойству можно воспользоваться составным ключом и сравнить элементы по нескольким свойствам. Для этого задайте функцию селектора ключа для каждой коллекции, чтобы вернуть анонимный тип, состоящий из свойств, которые вы хотите сравнить. Если свойства помечаются, они должны иметь одинаковую метку в анонимном типе каждого ключа. Кроме того, свойства должны отображаться в одинаковом порядке.

В следующем примере на основе списка объектов `Employee` и списка объектов `Student` определяется, какие работники также являются студентами. Оба этих типа имеют свойства `FirstName` и `LastName` типа <xref:System.String>. Функции, создающие ключи соединения из каждого элемента в списке, возвращают анонимный тип, состоящий из свойств `FirstName` и `LastName` каждого элемента. Операция соединения сравнивает эти составные ключи на предмет равенства и возвращает пары объектов из каждого списка, в которых имя и фамилия совпадают.

[!code-csharp[CsLINQProgJoining#2](~/samples/snippets/csharp/concepts/linq/how-to-perform-inner-joins_2.cs)]

## <a name="example---multiple-join"></a>Пример множественного соединения

Для выполнения множественного соединения можно соединять друг с другом любое количество операций соединения. Каждое предложение `join` в C# сопоставляет указанный источник данных с результатами предыдущего соединения.

В следующем примере создаются три коллекции: список объектов `Person`, список объектов `Cat` и список объектов `Dog`.

Первое предложение `join` в C# сопоставляет людей и кошек, сравнивая объекты `Person``Cat.Owner`. Оно возвращает последовательность анонимных типов, содержащих объект `Person` и `Cat.Name`.

Второе предложение `join` в C# сопоставляет анонимные типы, возвращаемые первым соединением, с объектами `Dog` в предоставленном списке собак на основе ключа, состоящего из свойства `Owner` типа `Person` и первой буквы имени животного. Оно возвращает последовательность анонимных типов, содержащих свойства `Cat.Name` и `Dog.Name` из каждой совпадающей пары. Поскольку это внутреннее соединение, возвращаются только объекты из первого источника данных, имеющие соответствие во втором источнике данных.

[!code-csharp[CsLINQProgJoining#3](~/samples/snippets/csharp/concepts/linq/how-to-perform-inner-joins_3.cs)]

## <a name="example---inner-join-by-using-grouped-join"></a>Пример внутреннего соединения с использованием группового соединения

В следующем примере показано, как реализовать внутреннее соединение с помощью группового соединения.

В `query1` список объектов `Person` группируется со списком объектов `Pet` на основе сравнения свойства объекта `Person` со свойством `Pet.Owner`. Групповое соединение создает коллекцию промежуточных групп, где каждая группа состоит из объекта `Person` и последовательности соответствующих ему объектов `Pet`.

Если в запрос добавляется второе предложение `from`, этот ряд последовательностей объединяется (или сводится) в одну более длинную последовательность. Тип элементов конечной последовательности определяется предложением `select`. В данном примере этот тип является анонимным и состоит из свойств `Person.FirstName` и `Pet.Name` для каждой совпадающей пары.

Результат `query1` эквивалентен результирующему набору, который можно было бы получить, выполнив внутреннее соединение с помощью предложения `join` без предложения `into`. Переменная `query2` демонстрирует этот эквивалентный запрос.

[!code-csharp[CsLINQProgJoining#4](~/samples/snippets/csharp/concepts/linq/how-to-perform-inner-joins_4.cs)]

## <a name="see-also"></a>См. также раздел

- <xref:System.Linq.Enumerable.Join%2A>
- <xref:System.Linq.Enumerable.GroupJoin%2A>
- [Выполнение групповых соединений](perform-grouped-joins.md)
- [Выполнение левых внешних соединений](perform-left-outer-joins.md)
- [Анонимные типы](../programming-guide/classes-and-structs/anonymous-types.md)
