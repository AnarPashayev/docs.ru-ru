---
title: Группирование результатов по смежным ключам (LINQ в C#)
description: Как группировать результаты по смежным ключам с помощью LINQ в C#.
ms.date: 08/14/2018
ms.assetid: cbda9c08-151b-4c9e-82f7-c3d7f3dac66b
ms.openlocfilehash: b5753c85bb07be4fc84b78a299eece961969ff9d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "61659908"
---
# <a name="group-results-by-contiguous-keys"></a>Группирование результатов по смежным ключам

В приведенном ниже примере показано, как сгруппировать элементы в блоки, представляющие последовательности смежных ключей. Например, предположим, что имеется следующая последовательность пар "ключ-значение":

|Ключ|Значение|
|---------|-----------|
|А|Мы|
|А|думаем,|
|А|что|
|С|LINQ|
|C|is|
|А|действительно|
|С|известным|
|С|!|

Следующие группы будут созданы в таком порядке:

1. Мы думаем, что

2. LINQ

3. is

4. действительно

5. известным, !

Решение реализуется как метод расширения, который является потокобезопасным и возвращает результаты потоковым образом. Иными словами, он создает группы по мере прохода по исходной последовательности. В отличие от операторов `group` и `orderby`, он может начать возвращать группы вызывающему объекту до того, как будет прочитана вся последовательность.

Потокобезопасность обеспечивается созданием копии каждой группы или блока по мере итерации исходной последовательности, как указывается в комментариях исходного кода. Если исходная последовательность имеет большой набор смежных элементов, среда CLR может создать исключение <xref:System.OutOfMemoryException>.

## <a name="example"></a>Пример

В приведенном ниже примере показаны метод расширения и использующий его клиентский код:

[!code-csharp[cscsrefContiguousGroups#1](~/samples/snippets/csharp/concepts/linq/how-to-group-results-by-contiguous-keys_1.cs)]

Чтобы использовать метод расширения в своем проекте, скопируйте статический класс `MyExtensions` в новый или существующий файл исходного кода и, если необходимо, добавьте директиву `using` для пространства имен, в котором он находится.

## <a name="see-also"></a>См. также раздел

- [LINQ](index.md)
