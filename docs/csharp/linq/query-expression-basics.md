---
title: Основы выражения запроса (LINQ в C#)
description: Общие сведения о понятиях, относящихся к выражениям запроса
ms.date: 11/30/2016
ms.assetid: 027db1f8-346f-44d2-a16e-043fcea3a4e0
ms.openlocfilehash: 5ebe2163df47c60c677d7ac911ce0f65529835eb
ms.sourcegitcommit: 7bc6887ab658550baa78f1520ea735838249345e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/03/2020
ms.locfileid: "75635864"
---
# <a name="query-expression-basics"></a><span data-ttu-id="62276-103">Основы выражения запроса</span><span class="sxs-lookup"><span data-stu-id="62276-103">Query expression basics</span></span>

<span data-ttu-id="62276-104">В этой статье представлены основные понятия, связанные с выражениями запроса на языке C#.</span><span class="sxs-lookup"><span data-stu-id="62276-104">This article introduces the basic concepts related to query expressions in C#.</span></span>

## <a name="what-is-a-query-and-what-does-it-do"></a><span data-ttu-id="62276-105">Что такое запрос и для чего он нужен</span><span class="sxs-lookup"><span data-stu-id="62276-105">What is a query and what does it do?</span></span>

<span data-ttu-id="62276-106">*Запрос* — это набор инструкций, которые описывают, какие данные необходимо извлечь из указанного источника (или источников) данных, а также описывают форму и организацию извлекаемых данных.</span><span class="sxs-lookup"><span data-stu-id="62276-106">A *query* is a set of instructions that describes what data to retrieve from a given data source (or sources) and what shape and organization the returned data should have.</span></span> <span data-ttu-id="62276-107">Запрос отличается от полученного с его помощью результата.</span><span class="sxs-lookup"><span data-stu-id="62276-107">A query is distinct from the results that it produces.</span></span>

<span data-ttu-id="62276-108">Обычно исходные данные логически организованы как последовательность элементов одного вида.</span><span class="sxs-lookup"><span data-stu-id="62276-108">Generally, the source data is organized logically as a sequence of elements of the same kind.</span></span> <span data-ttu-id="62276-109">Например, таблица базы данных SQL содержит последовательность строк.</span><span class="sxs-lookup"><span data-stu-id="62276-109">For example, a SQL database table contains a sequence of rows.</span></span> <span data-ttu-id="62276-110">В файле XML содержится "последовательность" элементов XML (они организованы иерархически в древовидную структуру).</span><span class="sxs-lookup"><span data-stu-id="62276-110">In an XML file, there is a "sequence" of XML elements (although these are organized hierarchically in a tree structure).</span></span> <span data-ttu-id="62276-111">Коллекция в памяти содержит последовательность объектов.</span><span class="sxs-lookup"><span data-stu-id="62276-111">An in-memory collection contains a sequence of objects.</span></span>

<span data-ttu-id="62276-112">С точки зрения приложения определенные тип и структура оригинальных исходных данных не важны.</span><span class="sxs-lookup"><span data-stu-id="62276-112">From an application's viewpoint, the specific type and structure of the original source data is not important.</span></span> <span data-ttu-id="62276-113">Приложение всегда видит исходные данные в виде коллекции <xref:System.Collections.Generic.IEnumerable%601> или <xref:System.Linq.IQueryable%601>.</span><span class="sxs-lookup"><span data-stu-id="62276-113">The application always sees the source data as an <xref:System.Collections.Generic.IEnumerable%601> or <xref:System.Linq.IQueryable%601> collection.</span></span> <span data-ttu-id="62276-114">Например, в LINQ to XML исходные данные становятся видимыми как `IEnumerable`\<<xref:System.Xml.Linq.XElement>>.</span><span class="sxs-lookup"><span data-stu-id="62276-114">For example, in LINQ to XML, the source data is made visible as an `IEnumerable`\<<xref:System.Xml.Linq.XElement>>.</span></span>

<span data-ttu-id="62276-115">При такой исходной последовательности, запрос может выполнять одно из трех возможных действий.</span><span class="sxs-lookup"><span data-stu-id="62276-115">Given this source sequence, a query may do one of three things:</span></span>

- <span data-ttu-id="62276-116">Извлечение подмножества элементов для получения новой последовательности без изменения отдельных элементов.</span><span class="sxs-lookup"><span data-stu-id="62276-116">Retrieve a subset of the elements to produce a new sequence without modifying the individual elements.</span></span> <span data-ttu-id="62276-117">Затем запрос может отсортировать или сгруппировать возвращаемую последовательность различными способами, как показано в следующем примере (предположим, что `scores` является `int[]`):</span><span class="sxs-lookup"><span data-stu-id="62276-117">The query may then sort or group the returned sequence in various ways, as shown in the following example (assume `scores` is an `int[]`):</span></span>

    [!code-csharp[csrefQueryExpBasics#45](~/samples/snippets/csharp/concepts/linq/query-expression-basics_1.cs)]

- <span data-ttu-id="62276-118">Извлечение последовательности элементов, как и в предыдущем примере, но с преобразованием элементов в новый тип объекта.</span><span class="sxs-lookup"><span data-stu-id="62276-118">Retrieve a sequence of elements as in the previous example but transform them to a new type of object.</span></span> <span data-ttu-id="62276-119">Например, запрос может извлекать только фамилии из определенных записей клиентов в источнике данных.</span><span class="sxs-lookup"><span data-stu-id="62276-119">For example, a query may retrieve only the last names from certain customer records in a data source.</span></span> <span data-ttu-id="62276-120">Запрос также может извлекать полную запись и использовать ее для создания другого типа объекта в памяти или даже данных XML перед созданием заключительной последовательности результатов.</span><span class="sxs-lookup"><span data-stu-id="62276-120">Or it may retrieve the complete record and then use it to construct another in-memory object type or even XML data before generating the final result sequence.</span></span> <span data-ttu-id="62276-121">В следующем примере показана трансформация `int` в `string`.</span><span class="sxs-lookup"><span data-stu-id="62276-121">The following example shows a projection from an `int` to a `string`.</span></span> <span data-ttu-id="62276-122">Обратите внимание на новый тип `highScoresQuery`.</span><span class="sxs-lookup"><span data-stu-id="62276-122">Note the new type of `highScoresQuery`.</span></span>

    [!code-csharp[csrefQueryExpBasics#46](~/samples/snippets/csharp/concepts/linq/query-expression-basics_2.cs)]

- <span data-ttu-id="62276-123">Извлечение одноэлементного значения исходных данных, таких как:</span><span class="sxs-lookup"><span data-stu-id="62276-123">Retrieve a singleton value about the source data, such as:</span></span>

  - <span data-ttu-id="62276-124">Количество элементов, соответствующих определенному условию.</span><span class="sxs-lookup"><span data-stu-id="62276-124">The number of elements that match a certain condition.</span></span>

  - <span data-ttu-id="62276-125">Элемент с наибольшим или наименьшим значением.</span><span class="sxs-lookup"><span data-stu-id="62276-125">The element that has the greatest or least value.</span></span>

  - <span data-ttu-id="62276-126">Первый элемент, соответствующий условию, или сумма определенных значений в указанном наборе элементов.</span><span class="sxs-lookup"><span data-stu-id="62276-126">The first element that matches a condition, or the sum of particular values in a specified set of elements.</span></span> <span data-ttu-id="62276-127">Например, следующий запрос возвращает количество оценок выше 80 из целочисленного массива `scores`:</span><span class="sxs-lookup"><span data-stu-id="62276-127">For example, the following query returns the number of scores greater than 80 from the `scores` integer array:</span></span>

    [!code-csharp[csrefQueryExpBasics#47](~/samples/snippets/csharp/concepts/linq/query-expression-basics_3.cs)]

    <span data-ttu-id="62276-128">В предыдущем примере обратите внимание на использование скобок вокруг выражения запроса перед вызовом метода `Count`.</span><span class="sxs-lookup"><span data-stu-id="62276-128">In the previous example, note the use of parentheses around the query expression before the call to the `Count` method.</span></span> <span data-ttu-id="62276-129">Его также можно выразить, используя новую переменную для сохранения конкретного результата.</span><span class="sxs-lookup"><span data-stu-id="62276-129">You can also express this by using a new variable to store the concrete result.</span></span> <span data-ttu-id="62276-130">Этот метод является более удобочитаемым, так как переменная, в которой хранится запрос, хранится отдельно от запроса, в котором хранится результат.</span><span class="sxs-lookup"><span data-stu-id="62276-130">This technique is more readable because it keeps the variable that stores the query separate from the query that stores a result.</span></span>

    [!code-csharp[csrefQueryExpBasics#48](~/samples/snippets/csharp/concepts/linq/query-expression-basics_4.cs)]

<span data-ttu-id="62276-131">В предыдущем примере запрос выполняется в вызове `Count`, так как `Count` должен выполнить итерацию результатов, чтобы определить количество элементов, возвращенных методом `highScoresQuery`.</span><span class="sxs-lookup"><span data-stu-id="62276-131">In the previous example, the query is executed in the call to `Count`, because `Count` must iterate over the results in order to determine the number of elements returned by `highScoresQuery`.</span></span>

## <a name="what-is-a-query-expression"></a><span data-ttu-id="62276-132">Что такое выражение запроса</span><span class="sxs-lookup"><span data-stu-id="62276-132">What is a query expression?</span></span>

<span data-ttu-id="62276-133">*Выражение запроса* — запрос, выраженный с помощью синтаксиса запроса.</span><span class="sxs-lookup"><span data-stu-id="62276-133">A *query expression* is a query expressed in query syntax.</span></span> <span data-ttu-id="62276-134">Выражение запроса является конструкцией языка первого класса.</span><span class="sxs-lookup"><span data-stu-id="62276-134">A query expression is a first-class language construct.</span></span> <span data-ttu-id="62276-135">Оно похоже на любое другое выражение и может использоваться в любом контексте, в котором выражение C# является допустимым.</span><span class="sxs-lookup"><span data-stu-id="62276-135">It is just like any other expression and can be used in any context in which a C# expression is valid.</span></span> <span data-ttu-id="62276-136">Выражение запроса состоит из набора предложений, написанных в декларативном синтаксисе, аналогичном SQL или XQuery.</span><span class="sxs-lookup"><span data-stu-id="62276-136">A query expression consists of a set of clauses written in a declarative syntax similar to SQL or XQuery.</span></span> <span data-ttu-id="62276-137">Каждое предложение, в свою очередь, содержит одно или несколько выражений C#, которые могут являться выражениями запроса или содержать выражение запроса.</span><span class="sxs-lookup"><span data-stu-id="62276-137">Each clause in turn contains one or more C# expressions, and these expressions may themselves be either a query expression or contain a query expression.</span></span>

<span data-ttu-id="62276-138">Выражение запроса должно начинаться предложением [from](../language-reference/keywords/from-clause.md) и заканчиваться предложением [select](../language-reference/keywords/select-clause.md) или [group](../language-reference/keywords/group-clause.md).</span><span class="sxs-lookup"><span data-stu-id="62276-138">A query expression must begin with a [from](../language-reference/keywords/from-clause.md) clause and must end with a [select](../language-reference/keywords/select-clause.md) or [group](../language-reference/keywords/group-clause.md) clause.</span></span> <span data-ttu-id="62276-139">Между первым предложением `from` и последним предложением `select` или `group` может содержаться одно или несколько необязательных предложений: [where](../language-reference/keywords/where-clause.md), [orderby](../language-reference/keywords/orderby-clause.md), [join](../language-reference/keywords/join-clause.md), [let](../language-reference/keywords/let-clause.md) и даже дополнительных предложений [from](../language-reference/keywords/from-clause.md).</span><span class="sxs-lookup"><span data-stu-id="62276-139">Between the first `from` clause and the last `select` or `group` clause, it can contain one or more of these optional clauses: [where](../language-reference/keywords/where-clause.md), [orderby](../language-reference/keywords/orderby-clause.md), [join](../language-reference/keywords/join-clause.md), [let](../language-reference/keywords/let-clause.md) and even additional [from](../language-reference/keywords/from-clause.md) clauses.</span></span> <span data-ttu-id="62276-140">Можно также использовать ключевое слово [into](../language-reference/keywords/into.md), чтобы результат предложения `join` или `group` мог служить источником дополнительных предложений запроса в том же выражении запроса.</span><span class="sxs-lookup"><span data-stu-id="62276-140">You can also use the [into](../language-reference/keywords/into.md) keyword to enable the result of a `join` or `group` clause to serve as the source for additional query clauses in the same query expression.</span></span>

### <a name="query-variable"></a><span data-ttu-id="62276-141">Переменная запроса</span><span class="sxs-lookup"><span data-stu-id="62276-141">Query variable</span></span>

<span data-ttu-id="62276-142">В LINQ переменная запроса — это любая переменная, сохраняющая *запрос* вместо *результатов* запроса.</span><span class="sxs-lookup"><span data-stu-id="62276-142">In LINQ, a query variable is any variable that stores a *query* instead of the *results* of a query.</span></span> <span data-ttu-id="62276-143">Говоря точнее, переменная запроса всегда является перечислимым типом и производит последовательность элементов, когда она используется в итерации оператора `foreach` или прямом вызове ее метода `IEnumerator.MoveNext`.</span><span class="sxs-lookup"><span data-stu-id="62276-143">More specifically, a query variable is always an enumerable type that will produce a sequence of elements when it is iterated over in a `foreach` statement or a direct call to its `IEnumerator.MoveNext` method.</span></span>

<span data-ttu-id="62276-144">В следующем примере кода показано простое выражение запроса с одним источником данных, одним предложением фильтрации, одним предложением упорядочения и без трансформации исходных элементов.</span><span class="sxs-lookup"><span data-stu-id="62276-144">The following code example shows a simple query expression with one data source, one filtering clause, one ordering clause, and no transformation of the source elements.</span></span> <span data-ttu-id="62276-145">Предложение `select` завершает запрос.</span><span class="sxs-lookup"><span data-stu-id="62276-145">The `select` clause ends the query.</span></span>

[!code-csharp[csrefQueryExpBasics#49](~/samples/snippets/csharp/concepts/linq/query-expression-basics_5.cs)]

<span data-ttu-id="62276-146">В предыдущем примере `scoreQuery` — *переменная запроса*, которую иногда называют просто *запросом*.</span><span class="sxs-lookup"><span data-stu-id="62276-146">In the previous example, `scoreQuery` is a *query variable,* which is sometimes referred to as just a *query*.</span></span> <span data-ttu-id="62276-147">В переменной запроса не хранятся фактические данные результата, которые получаются с помощью цикла `foreach`.</span><span class="sxs-lookup"><span data-stu-id="62276-147">The query variable stores no actual result data, which is produced in the `foreach` loop.</span></span> <span data-ttu-id="62276-148">Когда выполняется оператор `foreach`, результаты запроса не возвращаются с помощью переменной запроса `scoreQuery`.</span><span class="sxs-lookup"><span data-stu-id="62276-148">And when the `foreach` statement executes, the query results are not returned through the query variable `scoreQuery`.</span></span> <span data-ttu-id="62276-149">В этом случае они возвращаются с помощью переменной итерации `testScore`.</span><span class="sxs-lookup"><span data-stu-id="62276-149">Rather, they are returned through the iteration variable `testScore`.</span></span> <span data-ttu-id="62276-150">Итерация переменной `scoreQuery` может выполняться во втором цикле `foreach`.</span><span class="sxs-lookup"><span data-stu-id="62276-150">The `scoreQuery` variable can be iterated in a second `foreach` loop.</span></span> <span data-ttu-id="62276-151">Результаты будет теми же, если ни они, ни источник данных не изменяются.</span><span class="sxs-lookup"><span data-stu-id="62276-151">It will produce the same results as long as neither it nor the data source has been modified.</span></span>

<span data-ttu-id="62276-152">В переменной запроса может храниться запрос, выраженный с помощью синтаксиса запроса или метода запроса, или их комбинации.</span><span class="sxs-lookup"><span data-stu-id="62276-152">A query variable may store a query that is expressed in query syntax or method syntax, or a combination of the two.</span></span> <span data-ttu-id="62276-153">В следующих примерах `queryMajorCities` и `queryMajorCities2` являются переменными запроса.</span><span class="sxs-lookup"><span data-stu-id="62276-153">In the following examples, both `queryMajorCities` and `queryMajorCities2` are query variables:</span></span>

[!code-csharp[csrefQueryExpBasics#50](~/samples/snippets/csharp/concepts/linq/query-expression-basics_6.cs)]

<span data-ttu-id="62276-154">С другой стороны, в следующих примерах показаны переменные, которые не являются переменными запроса даже несмотря на то, что все они инициализируются запросом.</span><span class="sxs-lookup"><span data-stu-id="62276-154">On the other hand, the following two examples show variables that are not query variables even though each is initialized with a query.</span></span> <span data-ttu-id="62276-155">Они не являются переменными запроса, так как в них хранятся результаты.</span><span class="sxs-lookup"><span data-stu-id="62276-155">They are not query variables because they store results:</span></span>

[!code-csharp[csrefQueryExpBasics#51](~/samples/snippets/csharp/concepts/linq/query-expression-basics_7.cs)]

<span data-ttu-id="62276-156">Дополнительные сведения о различных способах выражения запросов см. в разделе [Синтаксис запросов и синтаксис методов в LINQ](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md).</span><span class="sxs-lookup"><span data-stu-id="62276-156">For more information about the different ways to express queries, see [Query syntax and method syntax in LINQ](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md).</span></span>

#### <a name="explicit-and-implicit-typing-of-query-variables"></a><span data-ttu-id="62276-157">Явная и неявная типизация переменных запроса</span><span class="sxs-lookup"><span data-stu-id="62276-157">Explicit and implicit typing of query variables</span></span>

<span data-ttu-id="62276-158">В этой документации обычно явно указывается тип переменной запроса для того, чтобы продемонстрировать типичное отношение между переменной запроса и [предложением select](../language-reference/keywords/select-clause.md).</span><span class="sxs-lookup"><span data-stu-id="62276-158">This documentation usually provides the explicit type of the query variable in order to show the type relationship between the query variable and the [select clause](../language-reference/keywords/select-clause.md).</span></span> <span data-ttu-id="62276-159">Однако можно также использовать ключевое слов [var](../language-reference/keywords/var.md), чтобы указать компилятору вывести тип переменной запроса (или любой другой локальной переменной) во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="62276-159">However, you can also use the [var](../language-reference/keywords/var.md) keyword to instruct the compiler to infer the type of a query variable (or any other local variable) at compile time.</span></span> <span data-ttu-id="62276-160">Например, ранее приведенный в данном разделе пример запроса также может быть выражен путем неявной типизации:</span><span class="sxs-lookup"><span data-stu-id="62276-160">For example, the query example that was shown previously in this topic can also be expressed by using implicit typing:</span></span>

[!code-csharp[csrefQueryExpBasics#52](~/samples/snippets/csharp/concepts/linq/query-expression-basics_8.cs)]

<span data-ttu-id="62276-161">Дополнительные сведения см. в разделах [Неявно типизированные локальные переменные](../programming-guide/classes-and-structs/implicitly-typed-local-variables.md) и [Связи типов в операциях запроса LINQ](../programming-guide/concepts/linq/type-relationships-in-linq-query-operations.md).</span><span class="sxs-lookup"><span data-stu-id="62276-161">For more information, see [Implicitly typed local variables](../programming-guide/classes-and-structs/implicitly-typed-local-variables.md) and [Type relationships in LINQ query operations](../programming-guide/concepts/linq/type-relationships-in-linq-query-operations.md).</span></span>

### <a name="starting-a-query-expression"></a><span data-ttu-id="62276-162">Начало выражения запроса</span><span class="sxs-lookup"><span data-stu-id="62276-162">Starting a query expression</span></span>

<span data-ttu-id="62276-163">Выражение запроса должно начинаться с предложения `from`.</span><span class="sxs-lookup"><span data-stu-id="62276-163">A query expression must begin with a `from` clause.</span></span> <span data-ttu-id="62276-164">Оно задает источник данных вместе с переменной диапазона.</span><span class="sxs-lookup"><span data-stu-id="62276-164">It specifies a data source together with a range variable.</span></span> <span data-ttu-id="62276-165">Переменная диапазона предоставляет каждый последующий элемент в исходной последовательности во время ее обзора.</span><span class="sxs-lookup"><span data-stu-id="62276-165">The range variable represents each successive element in the source sequence as the source sequence is being traversed.</span></span> <span data-ttu-id="62276-166">Переменная диапазона строго типизируется на основе типа элементов в источнике данных.</span><span class="sxs-lookup"><span data-stu-id="62276-166">The range variable is strongly typed based on the type of elements in the data source.</span></span> <span data-ttu-id="62276-167">В следующем примере переменная диапазона типизируется как `countries`, так как `Country` является массивом объектов `Country`.</span><span class="sxs-lookup"><span data-stu-id="62276-167">In the following example, because `countries` is an array of `Country` objects, the range variable is also typed as `Country`.</span></span> <span data-ttu-id="62276-168">Так как переменная диапазона строго типизируется, для доступа к любым доступным элементам типа можно использовать оператор-точку.</span><span class="sxs-lookup"><span data-stu-id="62276-168">Because the range variable is strongly typed, you can use the dot operator to access any available members of the type.</span></span>

[!code-csharp[csrefQueryExpBasics#53](~/samples/snippets/csharp/concepts/linq/query-expression-basics_9.cs)]

<span data-ttu-id="62276-169">Переменная диапазона находится в области до тех пор, пока запрос не завершится с помощью точки с запятой или предложения *continuation*.</span><span class="sxs-lookup"><span data-stu-id="62276-169">The range variable is in scope until the query is exited either with a semicolon or with a *continuation* clause.</span></span>

<span data-ttu-id="62276-170">Выражение запроса может содержать несколько предложений `from`.</span><span class="sxs-lookup"><span data-stu-id="62276-170">A query expression may contain multiple `from` clauses.</span></span> <span data-ttu-id="62276-171">Используйте дополнительные предложения `from`, если каждый элемент в исходной последовательности является коллекцией или содержит коллекцию.</span><span class="sxs-lookup"><span data-stu-id="62276-171">Use additional `from` clauses when each element in the source sequence is itself a collection or contains a collection.</span></span> <span data-ttu-id="62276-172">Например, предположим, что имеется коллекция объектов `Country`, каждый из которых содержит коллекцию объектов `City` с именем `Cities`.</span><span class="sxs-lookup"><span data-stu-id="62276-172">For example, assume that you have a collection of `Country` objects, each of which contains a collection of `City` objects named `Cities`.</span></span> <span data-ttu-id="62276-173">Для выполнения запросов к объектам `City` в каждой коллекции `Country` используйте два предложения `from`, как показано ниже.</span><span class="sxs-lookup"><span data-stu-id="62276-173">To query the `City` objects in each `Country`, use two `from` clauses as shown here:</span></span>

[!code-csharp[csrefQueryExpBasics#54](~/samples/snippets/csharp/concepts/linq/query-expression-basics_10.cs)]

<span data-ttu-id="62276-174">Дополнительные сведения см. в разделе [Предложение from](../language-reference/keywords/from-clause.md).</span><span class="sxs-lookup"><span data-stu-id="62276-174">For more information, see [from clause](../language-reference/keywords/from-clause.md).</span></span>

### <a name="ending-a-query-expression"></a><span data-ttu-id="62276-175">Окончание выражения запроса</span><span class="sxs-lookup"><span data-stu-id="62276-175">Ending a query expression</span></span>

<span data-ttu-id="62276-176">Выражение запроса должно завершаться предложением `group` или `select`.</span><span class="sxs-lookup"><span data-stu-id="62276-176">A query expression must end with either a `group` clause or a `select` clause.</span></span>

#### <a name="group-clause"></a><span data-ttu-id="62276-177">Предложение group</span><span class="sxs-lookup"><span data-stu-id="62276-177">group clause</span></span>

<span data-ttu-id="62276-178">Используйте предложение `group` для получения последовательности групп, упорядоченных по указанному ключу.</span><span class="sxs-lookup"><span data-stu-id="62276-178">Use the `group` clause to produce a sequence of groups organized by a key that you specify.</span></span> <span data-ttu-id="62276-179">Ключом могут быть данные любого типа.</span><span class="sxs-lookup"><span data-stu-id="62276-179">The key can be any data type.</span></span> <span data-ttu-id="62276-180">Например, следующий запрос создает последовательность групп, содержащую один или несколько объектов `Country`, ключ для которых имеет значение `char`.</span><span class="sxs-lookup"><span data-stu-id="62276-180">For example, the following query creates a sequence of groups that contains one or more `Country` objects and whose key is a `char` value.</span></span>

[!code-csharp[csrefQueryExpBasics#55](~/samples/snippets/csharp/concepts/linq/query-expression-basics_11.cs)]

<span data-ttu-id="62276-181">Дополнительные сведения о группировании см. в разделе [Предложение group](../language-reference/keywords/group-clause.md).</span><span class="sxs-lookup"><span data-stu-id="62276-181">For more information about grouping, see [group clause](../language-reference/keywords/group-clause.md).</span></span>

#### <a name="select-clause"></a><span data-ttu-id="62276-182">Предложение select</span><span class="sxs-lookup"><span data-stu-id="62276-182">select clause</span></span>

<span data-ttu-id="62276-183">Используйте предложение `select` для получения всех других типов последовательностей.</span><span class="sxs-lookup"><span data-stu-id="62276-183">Use the `select` clause to produce all other types of sequences.</span></span> <span data-ttu-id="62276-184">Простое предложение `select` просто создает последовательность с тем же типом объектов, что и у объектов, которые содержатся в источнике данных.</span><span class="sxs-lookup"><span data-stu-id="62276-184">A simple `select` clause just produces a sequence of the same type of objects as the objects that are contained in the data source.</span></span> <span data-ttu-id="62276-185">В этом примере источник данных содержит объекты типа `Country`.</span><span class="sxs-lookup"><span data-stu-id="62276-185">In this example, the data source contains `Country` objects.</span></span> <span data-ttu-id="62276-186">Предложение `orderby` просто сортирует элементы в новом порядке, а предложение `select` создает последовательность переупорядоченных объектов `Country`.</span><span class="sxs-lookup"><span data-stu-id="62276-186">The `orderby` clause just sorts the elements into a new order and the `select` clause produces a sequence of the reordered `Country` objects.</span></span>

[!code-csharp[csrefQueryExpBasics#56](~/samples/snippets/csharp/concepts/linq/query-expression-basics_12.cs)]

<span data-ttu-id="62276-187">Предложение `select` может использоваться для преобразования исходных данных в последовательности новых типов.</span><span class="sxs-lookup"><span data-stu-id="62276-187">The `select` clause can be used to transform source data into sequences of new types.</span></span> <span data-ttu-id="62276-188">Такое преобразование также называется *проекцией*.</span><span class="sxs-lookup"><span data-stu-id="62276-188">This transformation is also named a *projection*.</span></span> <span data-ttu-id="62276-189">В следующем примере предложение `select` создает *проекцию* последовательности анонимных типов, которая содержит только подмножество полей оригинального элемента.</span><span class="sxs-lookup"><span data-stu-id="62276-189">In the following example, the `select` clause *projects* a sequence of anonymous types which contains only a subset of the fields in the original element.</span></span> <span data-ttu-id="62276-190">Обратите внимание, что новые объекты инициализируются с помощью инициализатора объекта.</span><span class="sxs-lookup"><span data-stu-id="62276-190">Note that the new objects are initialized by using an object initializer.</span></span>

[!code-csharp[csrefQueryExpBasics#57](~/samples/snippets/csharp/concepts/linq/query-expression-basics_13.cs)]

<span data-ttu-id="62276-191">Дополнительные сведения обо всех методах использования предложения `select` для преобразования исходных данных см. в разделе [Предложение select](../language-reference/keywords/select-clause.md).</span><span class="sxs-lookup"><span data-stu-id="62276-191">For more information about all the ways that a `select` clause can be used to transform source data, see [select clause](../language-reference/keywords/select-clause.md).</span></span>

#### <a name="continuations-with-into"></a><span data-ttu-id="62276-192">Продолжения с использованием ключевого слова "into"</span><span class="sxs-lookup"><span data-stu-id="62276-192">Continuations with "into"</span></span>

<span data-ttu-id="62276-193">Ключевое слово `into` можно использовать в предложении `select` или `group` для создания временного идентификатора, в котором хранится запрос.</span><span class="sxs-lookup"><span data-stu-id="62276-193">You can use the `into` keyword in a `select` or `group` clause to create a temporary identifier that stores a query.</span></span> <span data-ttu-id="62276-194">Это действие рекомендуется выполнять, если требуется выполнить в запросе дополнительные операции запроса после операции группирования или выбора.</span><span class="sxs-lookup"><span data-stu-id="62276-194">Do this when you must perform additional query operations on a query after a grouping or select operation.</span></span> <span data-ttu-id="62276-195">В следующем примере объекты `countries` группируются в соответствии с численностью населения в диапазоны по 10 миллионов.</span><span class="sxs-lookup"><span data-stu-id="62276-195">In the following example `countries` are grouped according to population in ranges of 10 million.</span></span> <span data-ttu-id="62276-196">После создания этих групп дополнительные предложения отфильтровывают некоторые группы, а затем сортируют группы в порядке возрастания.</span><span class="sxs-lookup"><span data-stu-id="62276-196">After these groups are created, additional clauses filter out some groups, and then to sort the groups in ascending order.</span></span> <span data-ttu-id="62276-197">Чтобы выполнить эти дополнительные операции, требуется продолжение, предоставляемое с помощью `countryGroup`.</span><span class="sxs-lookup"><span data-stu-id="62276-197">To perform those additional operations, the continuation represented by `countryGroup` is required.</span></span>

[!code-csharp[csrefQueryExpBasics#58](~/samples/snippets/csharp/concepts/linq/query-expression-basics_14.cs)]

<span data-ttu-id="62276-198">Дополнительные сведения см. в разделе [into](../language-reference/keywords/into.md).</span><span class="sxs-lookup"><span data-stu-id="62276-198">For more information, see [into](../language-reference/keywords/into.md).</span></span>

### <a name="filtering-ordering-and-joining"></a><span data-ttu-id="62276-199">Фильтрация, упорядочение и присоединение</span><span class="sxs-lookup"><span data-stu-id="62276-199">Filtering, ordering, and joining</span></span>

<span data-ttu-id="62276-200">Между открывающим предложением `from` и завершающим предложением `select` или `group` могут размещаться все остальные необязательные предложения (`where`, `join`, `orderby`, `from`, `let`).</span><span class="sxs-lookup"><span data-stu-id="62276-200">Between the starting `from` clause, and the ending `select` or `group` clause, all other clauses (`where`, `join`, `orderby`, `from`, `let`) are optional.</span></span> <span data-ttu-id="62276-201">Любое необязательное предложение может использоваться в теле запроса несколько раз или отсутствовать вообще.</span><span class="sxs-lookup"><span data-stu-id="62276-201">Any of the optional clauses may be used zero times or multiple times in a query body.</span></span>

#### <a name="where-clause"></a><span data-ttu-id="62276-202">Предложение where</span><span class="sxs-lookup"><span data-stu-id="62276-202">where clause</span></span>

<span data-ttu-id="62276-203">Используйте предложение `where` для фильтрации элементов из источника данных по одному или нескольким выражениям предиката.</span><span class="sxs-lookup"><span data-stu-id="62276-203">Use the `where` clause to filter out elements from the source data based on one or more predicate expressions.</span></span> <span data-ttu-id="62276-204">Предложение `where` в следующем примере имеет один предикат с двумя условиями.</span><span class="sxs-lookup"><span data-stu-id="62276-204">The `where` clause in the following example has one predicate with two conditions.</span></span>

[!code-csharp[csrefQueryExpBasics#59](~/samples/snippets/csharp/concepts/linq/query-expression-basics_15.cs)]

<span data-ttu-id="62276-205">Дополнительные сведения см. в разделе [Предложение where](../language-reference/keywords/where-clause.md).</span><span class="sxs-lookup"><span data-stu-id="62276-205">For more information, see [where clause](../language-reference/keywords/where-clause.md).</span></span>

#### <a name="orderby-clause"></a><span data-ttu-id="62276-206">Предложение orderby</span><span class="sxs-lookup"><span data-stu-id="62276-206">orderby clause</span></span>

<span data-ttu-id="62276-207">Используйте `orderby` предложение для сортировки результатов по возрастанию или убыванию.</span><span class="sxs-lookup"><span data-stu-id="62276-207">Use the `orderby` clause to sort the results in either ascending or descending order.</span></span> <span data-ttu-id="62276-208">Также можно задать порядок дополнительной сортировки.</span><span class="sxs-lookup"><span data-stu-id="62276-208">You can also specify secondary sort orders.</span></span> <span data-ttu-id="62276-209">В следующем примере выполняется основная сортировка объектов `country` по свойству `Area`.</span><span class="sxs-lookup"><span data-stu-id="62276-209">The following example performs a primary sort on the `country` objects by using the `Area` property.</span></span> <span data-ttu-id="62276-210">Затем выполняется дополнительная сортировка по свойству `Population`.</span><span class="sxs-lookup"><span data-stu-id="62276-210">It then performs a secondary sort by using the `Population` property.</span></span>

[!code-csharp[csrefQueryExpBasics#60](~/samples/snippets/csharp/concepts/linq/query-expression-basics_16.cs)]

<span data-ttu-id="62276-211">Ключевое слово `ascending` является необязательным, так как сортировка по умолчанию происходит по возрастанию, если не задан порядок сортировки.</span><span class="sxs-lookup"><span data-stu-id="62276-211">The `ascending` keyword is optional; it is the default sort order if no order is specified.</span></span> <span data-ttu-id="62276-212">Дополнительные сведения см. в разделе [Предложение orderby](../language-reference/keywords/orderby-clause.md).</span><span class="sxs-lookup"><span data-stu-id="62276-212">For more information, see [orderby clause](../language-reference/keywords/orderby-clause.md).</span></span>

#### <a name="join-clause"></a><span data-ttu-id="62276-213">Предложение join</span><span class="sxs-lookup"><span data-stu-id="62276-213">join clause</span></span>

<span data-ttu-id="62276-214">Используйте предложение `join` для связи или объединения элементов из одного источника данных с элементами из другого источника данных на основе сравнения на равенство определенных ключей в каждом элементе.</span><span class="sxs-lookup"><span data-stu-id="62276-214">Use the `join` clause to associate and/or combine elements from one data source with elements from another data source based on an equality comparison between specified keys in each element.</span></span> <span data-ttu-id="62276-215">В LINQ операции объединения выполняются в последовательностях объектов, элементы которых относятся к разным типам.</span><span class="sxs-lookup"><span data-stu-id="62276-215">In LINQ, join operations are performed on sequences of objects whose elements are different types.</span></span> <span data-ttu-id="62276-216">После объединения двух последовательностей необходимо использовать оператор `select` или `group`, чтобы указать элемент для сохранения в выходной последовательности.</span><span class="sxs-lookup"><span data-stu-id="62276-216">After you have joined two sequences, you must use a `select` or `group` statement to specify which element to store in the output sequence.</span></span> <span data-ttu-id="62276-217">Также можно использовать анонимный тип, чтобы объединить свойства каждого набора связанных элементов в новый тип для выходной последовательности.</span><span class="sxs-lookup"><span data-stu-id="62276-217">You can also use an anonymous type to combine properties from each set of associated elements into a new type for the output sequence.</span></span> <span data-ttu-id="62276-218">В следующем примере связываются объекты `prod`, свойство `Category` которых соответствует одной из категорий в массиве строк `categories`.</span><span class="sxs-lookup"><span data-stu-id="62276-218">The following example associates `prod` objects whose `Category` property matches one of the categories in the `categories` string array.</span></span> <span data-ttu-id="62276-219">Продукты, свойство `Category` которых не соответствует ни одной строке в `categories`, отфильтровываются. Оператор `select` формирует новый тип, свойства которого берутся как из `cat`, так и из `prod`.</span><span class="sxs-lookup"><span data-stu-id="62276-219">Products whose `Category` does not match any string in `categories` are filtered out. The `select` statement projects a new type whose properties are taken from both `cat` and `prod`.</span></span>

[!code-csharp[csrefQueryExpBasics#61](~/samples/snippets/csharp/concepts/linq/query-expression-basics_17.cs)]

<span data-ttu-id="62276-220">Также можно выполнить групповое соединение путем сохранения результатов операции `join` во временную переменную, используя ключевое слово [into](../language-reference/keywords/into.md).</span><span class="sxs-lookup"><span data-stu-id="62276-220">You can also perform a group join by storing the results of the `join` operation into a temporary variable by using the [into](../language-reference/keywords/into.md) keyword.</span></span> <span data-ttu-id="62276-221">Дополнительные сведения см. в разделе [Предложение join](../language-reference/keywords/join-clause.md).</span><span class="sxs-lookup"><span data-stu-id="62276-221">For more information, see [join clause](../language-reference/keywords/join-clause.md).</span></span>

#### <a name="let-clause"></a><span data-ttu-id="62276-222">Предложение let</span><span class="sxs-lookup"><span data-stu-id="62276-222">let clause</span></span> 

<span data-ttu-id="62276-223">Используйте предложение `let` для сохранения результата выражения, например вызов метода, в новую переменную диапазона.</span><span class="sxs-lookup"><span data-stu-id="62276-223">Use the `let` clause to store the result of an expression, such as a method call, in a new range variable.</span></span> <span data-ttu-id="62276-224">В следующем примере в переменную диапазона `firstName` сохраняется первый элемент массива строк, возвращенного с помощью `Split`.</span><span class="sxs-lookup"><span data-stu-id="62276-224">In the following example, the range variable `firstName` stores the first element of the array of strings that is returned by `Split`.</span></span>

[!code-csharp[csrefQueryExpBasics#62](~/samples/snippets/csharp/concepts/linq/query-expression-basics_18.cs)]

<span data-ttu-id="62276-225">Дополнительные сведения см. в разделе [Предложение let](../language-reference/keywords/let-clause.md).</span><span class="sxs-lookup"><span data-stu-id="62276-225">For more information, see [let clause](../language-reference/keywords/let-clause.md).</span></span>

### <a name="subqueries-in-a-query-expression"></a><span data-ttu-id="62276-226">Вложенные запросы в выражении запроса</span><span class="sxs-lookup"><span data-stu-id="62276-226">Subqueries in a query expression</span></span>

<span data-ttu-id="62276-227">Предложение запроса может само содержать выражение запроса, которое иногда называют *вложенным запросом*.</span><span class="sxs-lookup"><span data-stu-id="62276-227">A query clause may itself contain a query expression, which is sometimes referred to as a *subquery*.</span></span> <span data-ttu-id="62276-228">Каждый вложенный запрос начинается с собственным предложением `from`, которое может указывать на источник данных, отличный от источника данных первого предложения `from`.</span><span class="sxs-lookup"><span data-stu-id="62276-228">Each subquery starts with its own `from` clause that does not necessarily point to the same data source in the first `from` clause.</span></span> <span data-ttu-id="62276-229">Например, в следующем запросе показано выражение запроса, которое используется в операторе "select" для извлечения результатов операции группирования.</span><span class="sxs-lookup"><span data-stu-id="62276-229">For example, the following query shows a query expression that is used in the select statement to retrieve the results of a grouping operation.</span></span>

[!code-csharp[csrefQueryExpBasics#63](~/samples/snippets/csharp/concepts/linq/query-expression-basics_19.cs)]

<span data-ttu-id="62276-230">Дополнительные сведения см. в руководстве по [выполнению вложенного запроса в операции группирования](perform-a-subquery-on-a-grouping-operation.md).</span><span class="sxs-lookup"><span data-stu-id="62276-230">For more information, see [Perform a subquery on a grouping operation](perform-a-subquery-on-a-grouping-operation.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="62276-231">См. также</span><span class="sxs-lookup"><span data-stu-id="62276-231">See also</span></span>

- [<span data-ttu-id="62276-232">Руководство по программированию на C#</span><span class="sxs-lookup"><span data-stu-id="62276-232">C# programming guide</span></span>](../programming-guide/index.md)
- [<span data-ttu-id="62276-233">LINQ</span><span class="sxs-lookup"><span data-stu-id="62276-233">Language Integrated Query (LINQ)</span></span>](index.md)
- [<span data-ttu-id="62276-234">Ключевые слова запросов (LINQ)</span><span class="sxs-lookup"><span data-stu-id="62276-234">Query keywords (LINQ)</span></span>](../language-reference/keywords/query-keywords.md)
- [<span data-ttu-id="62276-235">Общие сведения о стандартных операторах запросов</span><span class="sxs-lookup"><span data-stu-id="62276-235">Standard query operators overview</span></span>](../programming-guide/concepts/linq/standard-query-operators-overview.md)
