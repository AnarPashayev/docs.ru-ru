---
title: Использование модели синтаксиса пакета SDK для .NET Compiler Platform
description: Данный обзор описывает типы, используемые для получения сведений о синтаксических узлах и управления ими.
ms.date: 10/15/2017
ms.custom: mvc
ms.openlocfilehash: fc1b1f5ae5ec985425c8d6aec49ef7f830ea9162
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "75740475"
---
# <a name="work-with-syntax"></a>Работа с синтаксисом

**Дерево синтаксиса** представляет собой базовую структуру данных, предоставляемую API компилятора. Эти деревья представляют лексическую и синтаксическую структуру исходного кода. Они служат для двух важных целей:

1. Чтобы позволить средствам, таким как интегрированная среда разработки, надстройки, средства анализа кода и рефакторинг, просматривать и обрабатывать синтаксической структуры исходного кода в проекте пользователя.
2. Чтобы позволить средствам, таким как рефакторинг и интегрированная среда разработки, создавать, изменять и переупорядочивать исходный код естественным образом без прямых изменений текста. Создавая деревья и управляя ими, средства легко могут создавать и переупорядочивать исходный код.

## <a name="syntax-trees"></a>Деревья синтаксиса

Деревья синтаксиса образуют первичную структуру, используемую для компиляции, анализа кода, привязки, рефакторинга, функций интегрированной среды разработки и создания кода. Любая часть исходного кода становится понятной только после того, как будет идентифицирована и классифицирована по одному из многих известных структурных элементов языка.

Деревья синтаксиса имеют три ключевых атрибута. Первым атрибутом является то, что деревья синтаксиса содержат всех сведения об источнике с полной точностью. Это означает, что дерево синтаксиса содержит всю информацию, отраженную в исходном тексте, каждую грамматическую конструкцию, каждую лексему и все промежуточные элементы, включая пробелы, комментарии и директивы препроцессора. Например, каждый упомянутый в исходном коде литерал представлен точно так, как был указан. Деревья синтаксиса также представляют ошибки в исходном коде, когда программа является неполной или неправильно сформированной, в виде пропущенных или отсутствующих токенов.

Это позволяет реализовать второй атрибут деревьев синтаксиса. Дерево синтаксиса, предоставленное синтаксическим анализатором, позволяет воспроизвести точный текст, на основе которого оно было получено. С любого синтаксического узла можно получить текстовое представление поддерева, являющегося корнем в этом узле. Это означает, что деревья синтаксиса можно использовать для создания и изменения текста исходного кода. Создавая дерево, вы косвенно создаете эквивалентный текст, а изменяя дерево синтаксиса, то есть получая новое дерево на основе изменений существующего, вы фактически редактируете текст.

Третий атрибут деревьев синтаксиса заключается в том, что они неизменяемы и потокобезопасны.  Это означает, что после получения дерево представляет собой моментальный снимок текущего состояния кода и никогда не меняется. Это позволяет нескольким пользователям одновременно взаимодействовать с одним деревом синтаксиса в разных потоках без блокировки или дублирования. Так как деревья являются неизменяемыми, то есть напрямую в них невозможно внести никакие изменения, фабричные методы помогают создавать и изменять деревья синтаксиса путем создания их дополнительных снимков. Деревья эффективно используют базовые узлы повторно, поэтому новую версию можно перестроить быстро и с небольшими затратами памяти.

Дерево синтаксиса фактически является древовидной структурой данных, где нетерминальные структурные элементы являются родительскими для других элементов. Каждое дерево синтаксиса состоит из узлов, токенов и дополнительной синтаксической информации (trivia).

## <a name="syntax-nodes"></a>Синтаксические узлы

Синтаксические узлы являются одним из основных элементов деревьев синтаксиса. Они представляют такие синтаксические конструкции, как объявления, операторы, предложения и выражения. Каждая категория синтаксических узлов представлена отдельным классом, производным от <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>. Набор классов узлов не является расширяемым.

Все синтаксические узлы являются нетерминальными узлами в дереве синтаксиса, значит, всегда имеют дочерние элементы в виде других узлов и токенов. Как дочерний элемент другого узла каждый узел имеет родительский узел, к которому можно обратиться с помощью свойства <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType>. Так как узлы и деревья являются неизменяемыми, родительский элемент узла никогда не меняется. Корень дерева имеет родительский элемент null.

Каждый узел имеет метод <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType>, возвращающий список дочерних узлов в последовательном порядке с учетом их позиции в тексте исходного кода. Этот список не содержит токены. Каждый узел также имеет методы для изучения дочерних объектов, такие как <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A> или <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A>, которые представляют список всех узлов, токенов или дополнительной синтаксической информации, которые присутствуют в поддереве, являющемся корнем этого узла.

Кроме того, каждый подкласс синтаксических узлов предоставляет те же дочерние элементы посредством строго типизированных свойств. Например, класс узлов <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> имеет три дополнительные свойства для отдельных бинарных операторов: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> и <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>. Типом <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> и <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> является <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>, а типом <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> — <xref:Microsoft.CodeAnalysis.SyntaxToken>.

Некоторые синтаксические узлы имеют дополнительные дочерние элементы. Например, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> имеет дополнительный <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>. Если дочерний элемент не указан, свойство возвращает значение null.

## <a name="syntax-tokens"></a>Синтаксические токены

Синтаксические токены являются терминалами грамматики языка, представляющими наименьшие синтаксические фрагменты кода. Они никогда не бывают родителями других узлов или токенов. Синтаксические токены состоят из ключевых слов, идентификаторов, литералов и знаков препинания.

Для повышения эффективности тип <xref:Microsoft.CodeAnalysis.SyntaxToken> является типом значений среды CLR. Таким образом, в отличие от синтаксических узлов существует всего одна структура для всех видов токенов с набором свойств, значение которых зависит от типа представленного токена.

Например, токен целочисленного литерала представляет числовое значение. Кроме необработанного текста исходного кода, охватываемого токеном, токен литерала имеет свойство <xref:Microsoft.CodeAnalysis.SyntaxToken.Value>, сообщающее точное декодированное целочисленное значение. Это свойство имеет тип <xref:System.Object>, так как может быть одним из многих типов-примитивов.

Свойство <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> сообщает те же сведения, что и свойство <xref:Microsoft.CodeAnalysis.SyntaxToken.Value>, однако оно всегда имеет тип <xref:System.String>. Идентификатор в тексте исходного кода C# может включать escape-символы Юникода, при этом синтаксис самой escape-последовательности не считается частью имени идентификатора. Поэтому хотя охватываемый токеном необработанный текст и включает escape-последовательность, свойство <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> ее не содержит. Вместо этого оно включает в себя символы Юникода, определяемые этой escape-последовательностью. Например, если текст исходного кода содержит идентификатор, записанный как `\u03C0`, то свойство <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> для этого токена возвратит `π`.

## <a name="syntax-trivia"></a>Дополнительная синтаксическая информация

Дополнительная синтаксическая информация (syntax trivia) представляет части текста в исходном коде, которые очень мало влияют на понимание кода, например пробелы, комментарии и директивы препроцессора. Как и синтаксические токены, элементы trivia являются типами значений. Для описания всех видов trivia используется один тип <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType>.

Так как элементы trivia не являются частью обычного синтаксиса и могут стоять в любом месте между двумя любыми токенами, они не включаются в дерево синтаксиса в качестве дочернего элемента узла. Хотя, так как они важны при реализации таких функций, как рефакторинг, и обеспечения полного соответствия тексту исходного кода, они входят в состав дерева синтаксиса.

Вы можете обратиться к trivia, просмотрев коллекции <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> или <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> токена. При синтаксическом анализе текста исходного кода последовательности trivia сопоставляются с токенами. Как правило, токену принадлежит любой элемент trivia, расположенный в той же строке до следующего токена. Любой элемент trivia после этой строки сопоставляется со следующим токеном. Первый токен в исходном файле получает все начальные элементы trivia, а последняя последовательность trivia в файле присоединяется к токену конца файла, который в противном случае имеет нулевую ширину.

В отличие от синтаксических узлов и токенов элементы syntax trivia не имеют родительских элементов. Однако, так как они являются частью дерева и каждый из них сопоставлен с одним токеном, к соответствующему токену можно получить доступ с помощью свойства <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType>.

## <a name="spans"></a>Диапазоны

Каждому узлу, токену или элементу trivia известно его место в тексте исходного кода и число символов, из которых он состоит. Положение в тексте представлено в виде 32-разрядного целого числа, являющегося отсчитываемым от нуля индексом `char`. Объект <xref:Microsoft.CodeAnalysis.Text.TextSpan> обозначает начальное положение и количество символов, представленные в виде целых чисел. Если <xref:Microsoft.CodeAnalysis.Text.TextSpan> имеет нулевую длину, он обозначает расположение между двумя символами.

У каждого узла есть два свойства <xref:Microsoft.CodeAnalysis.Text.TextSpan>: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> и <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A>.

Свойство <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> является текстовым диапазоном от начала первого токена в поддереве узла до конца последнего токена. Этот диапазон не включает в себя никакие начальные или конечные элементы trivia.

Свойство <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A> является текстовым диапазоном, включающим в себя обычный диапазон узла, а также диапазон любых начальных или конечных элементов trivia.

Пример:

``` csharp
      if (x > 3)
      {
||        // this is bad
          |throw new Exception("Not right.");|  // better exception?||
      }
```

Узел оператора внутри блока имеет диапазон, обозначаемый отдельными вертикальными чертами (|). Он включает символы `throw new Exception("Not right.");`. Полный диапазон обозначается двойными вертикальными чертами (||). Он содержит те же символы, что и обычный диапазон, а также символы, связанные с начальными или конечными элементами trivia.

## <a name="kinds"></a>Типы

Каждый узел, токен или элемент trivia имеет свойство <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> типа <xref:System.Int32?displayProperty=nameWithType>, определяющее конкретный представленный элемент синтаксиса. Это значение можно привести к перечислению определенного языка. Каждый язык, C# или Visual Basic имеет одно перечисление `SyntaxKind` (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> и <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType> соответственно), содержащее все возможные узлы, токены и другие элементы грамматики. Это преобразование может выполняться автоматически с помощью методов расширения <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A?displayProperty=nameWithType> или <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind%2A?displayProperty=nameWithType>.

Свойство <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> позволяет легко устранить неоднозначность типов синтаксических узлов, которые используют один класс узлов. Для токенов и элементов trivia это свойство является единственным способом отличить один тип элемента от другого.

Например, один класс <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> имеет дочерние элементы <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> и <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>. Свойство <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A> позволяет определить, имеет ли этот синтаксический узел тип <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression> или <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression>.

## <a name="errors"></a>Ошибки

Даже если текст исходного кода содержит синтаксические ошибки, предоставляется полное дерево синтаксиса, которое обеспечивает круговой путь до источника. Когда синтаксический анализатор обнаруживает код, который не соответствует заданному синтаксису языка, для создания дерева синтаксиса используется один из двух способов.

Первый: если синтаксический анализатор ожидает определенный тип токена, но не находит его, он может вставить отсутствующий токен в дерево синтаксиса в том расположении, где он ожидался. Отсутствующий токен представляет фактический ожидаемый токен, однако он имеет пустой диапазон, а его свойство <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> возвращает `true`.

Второй: синтаксический анализатор может пропускать токены, пока не найдет такой, с которого можно продолжить анализ. В этом случае пропущенные токены добавляются в виде узла trivia типа <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.
