---
title: Руководство по программированию на C#. Использование индексаторов
description: Сведения об объявлении и использовании индексатора для класса, структуры или интерфейса при программировании на C#. Эта статья содержит пример кода.
ms.date: 07/15/2020
helpviewer_keywords:
- indexers [C#], about indexers
ms.assetid: df70e1a2-3ce3-4aba-ad80-4b2f3538699f
ms.openlocfilehash: a8a9e05c1d2e44841177a924c6ff51c6c9e6a05a
ms.sourcegitcommit: 6f58a5f75ceeb936f8ee5b786e9adb81a9a3bee9
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/28/2020
ms.locfileid: "87301870"
---
# <a name="using-indexers-c-programming-guide"></a>Использование индексаторов. Руководство по программированию на C#

Применение индексаторов упрощает работу с синтаксисом, позволяя создавать [классы](../../language-reference/keywords/class.md), [структуры](../../language-reference/builtin-types/struct.md) и [интерфейсы](../../language-reference/keywords/interface.md), к которым клиентские приложения могут обращаться так же, как к массиву. В этом случае компилятор создает свойство `Item` (или свойство с другим именем, если присутствует <xref:System.Runtime.CompilerServices.IndexerNameAttribute>) и соответствующие методы доступа. Индексаторы чаще всего реализуются в типах, предназначенных преимущественно для инкапсуляции внутренней коллекции или массива. Допустим, у вас есть класс `TempRecord`, представляющий журнал с 10 измерениями температуры по шкале Фаренгейта за период в 24 часа. Этот класс содержит массив `temps` типа `float[]` для хранения значений температуры. Реализация индексатора в этом классе позволит клиентам получать доступ к значениям температуры в экземпляре `TempRecord`, используя `float temp = tempRecord[4]` вместо `float temp = tempRecord.temps[4]`. Это позволяет не только упростить синтаксис клиентских приложений, но и облегчить понимание кода класса и его предназначения другими разработчиками.

Чтобы объявить индексатор для класса или структуры, используйте ключевое слово [this](../../language-reference/keywords/this.md), как в следующем примере:

```csharp
// Indexer declaration
public int this[int index]
{
    // get and set accessors
}
```

> [!IMPORTANT]
> При объявлении индексатора для объекта автоматически создается свойство с именем `Item`. Свойство `Item` не будет доступно непосредственно из [выражения доступа к члену](../../language-reference/operators/member-access-operators.md#member-access-expression-) экземпляра. Кроме того, если вы добавите к объекту с индексатором собственное свойство `Item`, возникнет [ошибка компилятора CS0102](../../misc/cs0102.md). Чтобы избежать этого, используйте <xref:System.Runtime.CompilerServices.IndexerNameAttribute>, чтобы переименовать индексатор, как описывается ниже.

## <a name="remarks"></a>Примечания

Тип индексатора и типы его параметров должны иметь по крайней мере такой же уровень доступности, как и сам индексатор. Дополнительные сведения об уровнях доступа см. в разделе [Модификаторы доступа](../../language-reference/keywords/access-modifiers.md).

Дополнительные сведения об использовании индексаторов с интерфейсом см. в разделе [Индексаторы интерфейса](./indexers-in-interfaces.md).

Сигнатура индексатора определяет число и типы его формальных параметров. В ней не указываются тип индексатора или имена его формальных параметров. Если для одного класса объявляется несколько индексаторов, они должны иметь разные сигнатуры.

Значение индексатора не классифицируется как переменная и, соответственно, не может передаваться в качестве параметра [ref](../../language-reference/keywords/ref.md) или [out](../../language-reference/keywords/out-parameter-modifier.md).

Чтобы присвоить индексатору имя, которое можно использовать в других языках, используйте <xref:System.Runtime.CompilerServices.IndexerNameAttribute?displayProperty=nameWithType>, как показано в этом примере:

```csharp
// Indexer declaration
[System.Runtime.CompilerServices.IndexerName("TheItem")]
public int this[int index]
{
    // get and set accessors
}
```

Этот индексатор будет иметь имя `TheItem`, поскольку оно переопределено атрибутом имени индексатора. По умолчанию используется имя индексатора `Item`.

## <a name="example-1"></a>Пример 1

В следующем примере показано, как объявить частное поле массива `temps` и индексатор. Индексатор обеспечивает прямой доступ к экземпляру `tempRecord[i]`. Вместо использования индексатора можно объявить массив как элемент [public](../../language-reference/keywords/public.md) и осуществлять доступ к его элементам напрямую (`tempRecord.temps[i]`).

:::code language="csharp" source="snippets/Temperatures/TempRecord.cs":::

Обратите внимание, что при определении прав доступа индексатора, например в инструкции `Console.Write`, вызывается метод доступа [get](../../language-reference/keywords/get.md). Таким образом, если метод доступа `get` отсутствует, возникает ошибка времени компиляции.

:::code language="csharp" source="snippets/Temperatures/Program.cs":::

## <a name="indexing-using-other-values"></a>Индексирование с использованием других значений

В C# тип параметра индексатора не ограничивается целочисленными значениями. Например, в качестве индексатора могут использоваться строки. Такой индексатор можно реализовать путем поиска строки в коллекции с возвратом соответствующего значения. Поскольку методы доступа можно перегружать, строковые и целочисленные версии могут сосуществовать.

## <a name="example-2"></a>Пример 2

Этот пример объявляет класс, который хранит названия дней недели. Метод доступа `get` принимает название дня в виде строкового значения и возвращает соответствующее целое число. Например, для Sunday возвращается значение 0, для Monday — 1 и т. д.

:::code language="csharp" source="snippets/StringIndexers/DayCollection.cs":::

### <a name="consuming-example-2"></a>Пример использования 2

:::code language="csharp" source="snippets/StringIndexers/Program.cs":::

## <a name="example-3"></a>Пример 3

В этом примере объявляется класс, в котором хранятся названия дней недели с использованием перечисления <xref:System.DayOfWeek?displayProperty=fullName>. Метод доступа `get` принимает название дня (`DayOfWeek`) в виде строкового значения и возвращает соответствующее целое число. Например, для `DayOfWeek.Sunday` возвращается 0, для `DayOfWeek.Monday` — 1 и т. д.

:::code language="csharp" source="snippets/DayOfWeekIndexers/DayOfWeekCollection.cs":::

### <a name="consuming-example-3"></a>Пример использования 3

:::code language="csharp" source="snippets/DayOfWeekIndexers/Program.cs":::

## <a name="robust-programming"></a>Отказоустойчивость

Повысить безопасность и надежность индексаторов можно двумя способами:

- Реализуйте стратегию обработки ошибок, предусматривающую действия в ситуациях, когда из клиентского кода передается недопустимое значение индекса. В первом примере из этого раздела класс TempRecord содержит свойство Length, с помощью которого клиентский код проверяет введенное значение, прежде чем передать его в индексатор. Кроме того, код обработки ошибок можно поместить в сам индексатор. Не забудьте задокументировать исключения, которые будут вызываться в методе доступа индексатора, для других пользователей.

- Настройте максимально ограничивающие уровни доступа для методов доступа [get](../../language-reference/keywords/get.md) и [set](../../language-reference/keywords/set.md). Особенно важно сделать это для метода доступа `set`. Дополнительные сведения см. в разделе [Доступность методов доступа](../classes-and-structs/restricting-accessor-accessibility.md).

## <a name="see-also"></a>См. также

- [Руководство по программированию на C#](../index.md)
- [Индексаторы](./index.md)
- [Свойства](../classes-and-structs/properties.md)
