---
title: Руководство по программированию на C#. Использование исключений
ms.date: 07/20/2015
helpviewer_keywords:
- exception handling [C#], about exception handling
- exceptions [C#], about exceptions
ms.assetid: 71472c62-320a-470a-97d2-67995180389d
ms.openlocfilehash: a00259dfd5634ad9b9c951c3cd76da97afe5077d
ms.sourcegitcommit: a241301495a84cc8c64fe972330d16edd619868b
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/01/2020
ms.locfileid: "84241699"
---
# <a name="use-exceptions-c-programming-guide"></a>Использование исключений (руководство по программированию на C#)

В C# ошибки в программе в среде выполнения передаются через программу с помощью механизма, который называется исключениями. Исключения вызываются кодом, который встречает ошибку, и перехватываются кодом, который может ее исправить. Исключения могут вызываться средой выполнения .NET или кодом в программе. Вызванное исключение передается вверх по стеку вызовов, пока не будет найден соответствующий оператор `catch`. Не перехваченные исключения обрабатываются универсальным обработчиком исключений, предоставляемым системой, которая отображает диалоговое окно.  
  
 Исключения представляются классами, производными от <xref:System.Exception>. Этот класс определяет тип исключения и содержит свойства с подробными сведениями об исключении. При вызове исключения создается экземпляр производного класса, а также могут настраиваться свойства исключения. После этого с помощью ключевого слова `throw` вызывается объект. Пример:  
  
 [!code-csharp[csProgGuideExceptions#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExceptions/CS/Exceptions.cs#1)]  
  
 После выдачи исключения среда выполнения проверяет, входит ли текущий оператор в блок `try`. Если да, она проверяет, может ли какой-либо из блоков `catch`, связанных с блоком `try`, перехватить исключение. Блоки `Catch` обычно задают типы исключений; если тип блока `catch` совпадает с типом или базовым классом исключения, блок `catch` может обработать этот метод. Пример:  
  
 [!code-csharp[csProgGuideExceptions#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExceptions/CS/Exceptions.cs#2)]  
  
 Если оператор, который вызывает исключение, не находится в блоке `try` или блок `try`, в который он входит, не имеет соответствующего блока `catch`, среда выполнения проверяет вызывающий метод на наличие оператора `try` и блоков `catch`. Среда выполнения продолжает перебирать стек вызовов в поиска подходящего блока `catch`. После того как блок `catch` будет найден и выполнен, управление передается оператору, следующему после блока `catch`.  
  
 Оператор `try` может содержать не один блок `catch`. Выполняется первый оператор `catch`, который может обработать исключение; все последующие операторы `catch` игнорируются, даже если они совместимы. В связи с этим блоки catch следует располагать в порядке от наиболее конкретных (наиболее производных) до наименее конкретных. Пример:  
  
 [!code-csharp[csProgGuideExceptions#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExceptions/CS/Exceptions.cs#3)]  
  
 Прежде чем выполнять блок `catch`, среда выполнения проверяет наличие блоков `finally`. Блоки `Finally` позволяют программисту удалить любое неоднозначное состояние, которое может остаться после прерванного блока `try`, а также освободить любые внешние ресурсы (включая обработчики графики, соединители баз данных или файловые потоки), не дожидаясь, пока сборщик мусора в среде выполнения завершит объекты. Пример:  
  
 [!code-csharp[csProgGuideExceptions#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExceptions/CS/Exceptions.cs#4)]  
  
 Если `WriteByte()` выдает исключение, код во втором блоке `try`, который пытается открыть файл повторно, завершается ошибкой, если `file.Close()` не вызывается, а файл остается заблокированным. Поскольку блоки `finally` выполняются, даже если выдается исключение, блок `finally` в предыдущем примере обеспечивает правильное закрытие файла и помогает избежать ошибки.  
  
 Если после выдачи исключения обнаружить совместимый блок `catch` в стеке вызовов не удается, происходит одно из трех:  
  
- Если исключение возникает в методе завершения, он прерывается, и вызывается базовый метод завершения (если есть).  
  
- Если стек вызовов содержит статический конструктор или инициализатор статического поля, выдается исключение <xref:System.TypeInitializationException>, а исходное исключение назначается свойству <xref:System.Exception.InnerException%2A> нового исключения.  
  
- Как только достигается начало потока, он прерывается.  
  
## <a name="see-also"></a>См. также

- [Руководство по программированию на C#](../index.md)
- [Исключения и обработка исключений](./index.md)
