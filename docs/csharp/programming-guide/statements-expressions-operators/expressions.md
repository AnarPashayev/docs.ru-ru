---
title: Руководство по программированию на C#. Выражения
ms.date: 05/11/2017
helpviewer_keywords:
- expressions [C#]
- C# language, expressions
ms.assetid: c7d8feb0-0e58-4f94-8bf6-4d070550a832
ms.openlocfilehash: 4bbee8f15c2591e8b172df9a6759449d48697804
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2020
ms.locfileid: "75699097"
---
# <a name="expressions-c-programming-guide"></a><span data-ttu-id="37f80-102">Выражения (Руководство по программированию в C#)</span><span class="sxs-lookup"><span data-stu-id="37f80-102">Expressions (C# Programming Guide)</span></span>

<span data-ttu-id="37f80-103">*Выражение* представляет собой последовательность из одного или нескольких операндов и от нуля до нескольких [операторов](../../language-reference/operators/index.md), которую можно вычислить, получив в результате одно значение, объект, метод или пространство имен.</span><span class="sxs-lookup"><span data-stu-id="37f80-103">An *expression* is a sequence of one or more operands and zero or more [operators](../../language-reference/operators/index.md) that can be evaluated to a single value, object, method, or namespace.</span></span> <span data-ttu-id="37f80-104">Выражение может состоять из литерала, вызова метода, оператора или его операндов, а также из *простого имени*.</span><span class="sxs-lookup"><span data-stu-id="37f80-104">Expressions can consist of a literal value, a method invocation, an operator and its operands, or a *simple name*.</span></span> <span data-ttu-id="37f80-105">Простые имена могут быть именами переменной, элемента типа, параметра метода, пространства имен или типа.</span><span class="sxs-lookup"><span data-stu-id="37f80-105">Simple names can be the name of a variable, type member, method parameter, namespace or type.</span></span>  
  
 <span data-ttu-id="37f80-106">В выражениях могут использоваться операторы, которые, в свою очередь, используют в качестве параметров другие выражения или вызовы методов, параметрами которых являются другие вызовы методов. Таким образом, выражения могут быть как простыми, так и очень сложными.</span><span class="sxs-lookup"><span data-stu-id="37f80-106">Expressions can use operators that in turn use other expressions as parameters, or method calls whose parameters are in turn other method calls, so expressions can range from simple to very complex.</span></span> <span data-ttu-id="37f80-107">Ниже приведено два примера выражений.</span><span class="sxs-lookup"><span data-stu-id="37f80-107">Following are two examples of expressions:</span></span>  
  
```csharp  
((x < 10) && ( x > 5)) || ((x > 20) && (x < 25));

System.Convert.ToInt32("35");  
```  
  
## <a name="expression-values"></a><span data-ttu-id="37f80-108">Значения выражений</span><span class="sxs-lookup"><span data-stu-id="37f80-108">Expression values</span></span>

 <span data-ttu-id="37f80-109">В большинстве контекстов, в которых используются выражения, например, в операторах или в параметрах методов, предполагается, что результатом вычисления выражения будет какое-то значение.</span><span class="sxs-lookup"><span data-stu-id="37f80-109">In most of the contexts in which expressions are used, for example in statements or method parameters, the expression is expected to evaluate to some value.</span></span> <span data-ttu-id="37f80-110">Если x и y — целые числа, результатом вычисления выражения `x + y` будет числовое значение.</span><span class="sxs-lookup"><span data-stu-id="37f80-110">If x and y are integers, the expression `x + y` evaluates to a numeric value.</span></span> <span data-ttu-id="37f80-111">Результатом вычисления выражения `new MyClass()` будет ссылка на новый экземпляр класса `MyClass`.</span><span class="sxs-lookup"><span data-stu-id="37f80-111">The expression `new MyClass()` evaluates to a reference to a new instance of a `MyClass` class.</span></span> <span data-ttu-id="37f80-112">Результатом вычисления выражения `myClass.ToString()` является строка, так как она является возвращаемым типом метода.</span><span class="sxs-lookup"><span data-stu-id="37f80-112">The expression `myClass.ToString()` evaluates to a string because that is the return type of the method.</span></span> <span data-ttu-id="37f80-113">Однако хотя имя пространства имен классифицируется как выражение, значение не будет результатом его вычисления и поэтому никогда не станет конечным результатом какого-либо выражения.</span><span class="sxs-lookup"><span data-stu-id="37f80-113">However, although a namespace name is classified as an expression, it does not evaluate to a value and therefore can never be the final result of any expression.</span></span> <span data-ttu-id="37f80-114">Имя пространства имен нельзя передать параметру метода, или использовать его в новом выражении, или присвоить его переменной.</span><span class="sxs-lookup"><span data-stu-id="37f80-114">You cannot pass a namespace name to a method parameter, or use it in a new expression, or assign it to a variable.</span></span> <span data-ttu-id="37f80-115">Его можно использовать только как часть выражения в более крупном выражении.</span><span class="sxs-lookup"><span data-stu-id="37f80-115">You can only use it as a sub-expression in a larger expression.</span></span> <span data-ttu-id="37f80-116">Это также относится к типам (в отличие от объектов <xref:System.Type?displayProperty=nameWithType>), именам групп методов (в отличие от отдельных методов) и к методам доступа к событиям [add](../../language-reference/keywords/add.md) и [remove](../../language-reference/keywords/remove.md).</span><span class="sxs-lookup"><span data-stu-id="37f80-116">The same is true for types (as distinct from <xref:System.Type?displayProperty=nameWithType> objects), method group names (as distinct from specific methods), and event [add](../../language-reference/keywords/add.md) and [remove](../../language-reference/keywords/remove.md) accessors.</span></span>  
  
 <span data-ttu-id="37f80-117">У каждого значения есть связанный с ним тип.</span><span class="sxs-lookup"><span data-stu-id="37f80-117">Every value has an associated type.</span></span> <span data-ttu-id="37f80-118">Например, если x и y — переменные типа `int`, значение выражения `x + y` также типизируется как `int`.</span><span class="sxs-lookup"><span data-stu-id="37f80-118">For example, if x and y are both variables of type `int`, the value of the expression `x + y` is also typed as `int`.</span></span> <span data-ttu-id="37f80-119">Если значение присвоено переменной другого типа или x и y принадлежат к разным типам, то применяются правила преобразования типов.</span><span class="sxs-lookup"><span data-stu-id="37f80-119">If the value is assigned to a variable of a different type, or if x and y are different types, the rules of type conversion are applied.</span></span> <span data-ttu-id="37f80-120">Дополнительные сведения о работе таких преобразований см. в разделе [Приведение и преобразование типов](../types/casting-and-type-conversions.md).</span><span class="sxs-lookup"><span data-stu-id="37f80-120">For more information about how such conversions work, see [Casting and Type Conversions](../types/casting-and-type-conversions.md).</span></span>  
  
## <a name="overflows"></a><span data-ttu-id="37f80-121">Переполнения</span><span class="sxs-lookup"><span data-stu-id="37f80-121">Overflows</span></span>

 <span data-ttu-id="37f80-122">Числовые выражения могут привести к переполнениям, если значение больше максимального значения типа значения.</span><span class="sxs-lookup"><span data-stu-id="37f80-122">Numeric expressions may cause overflows if the value is larger than the maximum value of the value's type.</span></span> <span data-ttu-id="37f80-123">Дополнительные сведения см. в разделах [Проверяемые и непроверяемые](../../language-reference/keywords/checked-and-unchecked.md) и [Явные числовые преобразования](../../language-reference/builtin-types/numeric-conversions.md#explicit-numeric-conversions) в статье [Встроенные числовые преобразования](../../language-reference/builtin-types/numeric-conversions.md).</span><span class="sxs-lookup"><span data-stu-id="37f80-123">For more information, see [Checked and Unchecked](../../language-reference/keywords/checked-and-unchecked.md) and the [Explicit numeric conversions](../../language-reference/builtin-types/numeric-conversions.md#explicit-numeric-conversions) section of the [Built-in numeric conversions](../../language-reference/builtin-types/numeric-conversions.md) article.</span></span>
  
## <a name="operator-precedence-and-associativity"></a><span data-ttu-id="37f80-124">Приоритет и ассоциативность операторов</span><span class="sxs-lookup"><span data-stu-id="37f80-124">Operator precedence and associativity</span></span>

 <span data-ttu-id="37f80-125">Способ вычисления выражения управляется правилами ассоциативности и приоритетом операторов.</span><span class="sxs-lookup"><span data-stu-id="37f80-125">The manner in which an expression is evaluated is governed by the rules of associativity and operator precedence.</span></span> <span data-ttu-id="37f80-126">Дополнительные сведения см. в разделе [Операторы](../../language-reference/operators/index.md).</span><span class="sxs-lookup"><span data-stu-id="37f80-126">For more information, see [Operators](../../language-reference/operators/index.md).</span></span>  
  
 <span data-ttu-id="37f80-127">Большинство выражений, за исключением выражений назначения и выражений вызова метода, должны быть встроены в оператор.</span><span class="sxs-lookup"><span data-stu-id="37f80-127">Most expressions, except assignment expressions and method invocation expressions, must be embedded in a statement.</span></span> <span data-ttu-id="37f80-128">Дополнительные сведения см. в разделе [Выписки](./statements.md).</span><span class="sxs-lookup"><span data-stu-id="37f80-128">For more information, see [Statements](./statements.md).</span></span>  
  
## <a name="literals-and-simple-names"></a><span data-ttu-id="37f80-129">Литералы и простые имена</span><span class="sxs-lookup"><span data-stu-id="37f80-129">Literals and simple names</span></span>

 <span data-ttu-id="37f80-130">Двумя наиболее простыми типами выражений являются литералы и простые имена.</span><span class="sxs-lookup"><span data-stu-id="37f80-130">The two simplest types of expressions are literals and simple names.</span></span> <span data-ttu-id="37f80-131">Литерал представляет собой постоянное значение, у которого нет имени.</span><span class="sxs-lookup"><span data-stu-id="37f80-131">A literal is a constant value that has no name.</span></span> <span data-ttu-id="37f80-132">Например, в следующем примере `5` и `"Hello World"` являются литералами.</span><span class="sxs-lookup"><span data-stu-id="37f80-132">For example, in the following code example, both `5` and `"Hello World"` are literal values:</span></span>  
  
 [!code-csharp[csProgGuideStatements#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#2)]  
  
 <span data-ttu-id="37f80-133">Дополнительные сведения о литералах см. в разделе [Типы](/dotnet/csharp/language-reference/keywords).</span><span class="sxs-lookup"><span data-stu-id="37f80-133">For more information on literals, see [Types](/dotnet/csharp/language-reference/keywords).</span></span>  
  
 <span data-ttu-id="37f80-134">В предыдущем примере `i` и `s` являются простыми именами, которые определяют локальные переменные.</span><span class="sxs-lookup"><span data-stu-id="37f80-134">In the preceding example, both `i` and `s` are simple names that identify local variables.</span></span> <span data-ttu-id="37f80-135">При использовании таких переменных в выражениях результатом вычисления имени переменной является значение, которое в данное время хранится в расположении переменой в памяти.</span><span class="sxs-lookup"><span data-stu-id="37f80-135">When those variables are used in an expression, the variable name evaluates to the value that is currently stored in the variable's location in memory.</span></span> <span data-ttu-id="37f80-136">Это показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="37f80-136">This is shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStatements#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#3)]

## <a name="invocation-expressions"></a><span data-ttu-id="37f80-137">Выражения вызова</span><span class="sxs-lookup"><span data-stu-id="37f80-137">Invocation expressions</span></span>

 <span data-ttu-id="37f80-138">В следующем примере кода вызов метода `DoWork` является выражением вызова.</span><span class="sxs-lookup"><span data-stu-id="37f80-138">In the following code example, the call to `DoWork` is an invocation expression.</span></span>  
  
```csharp
DoWork();  
```  
  
 <span data-ttu-id="37f80-139">При вызове метода необходимо указать имя метода в явном виде, как было показано в предыдущем примере, или в виде результата другого выражения, после чего в скобках указываются все параметры этого метода.</span><span class="sxs-lookup"><span data-stu-id="37f80-139">A method invocation requires the name of the method, either as a name as in the previous example, or as the result of another expression, followed by parenthesis and any method parameters.</span></span> <span data-ttu-id="37f80-140">Дополнительные сведения см. в статье [Методы](../classes-and-structs/methods.md).</span><span class="sxs-lookup"><span data-stu-id="37f80-140">For more information, see [Methods](../classes-and-structs/methods.md).</span></span> <span data-ttu-id="37f80-141">При вызове делегата указывается имя делегата и параметры метода в скобках.</span><span class="sxs-lookup"><span data-stu-id="37f80-141">A delegate invocation uses the name of a delegate and method parameters in parenthesis.</span></span> <span data-ttu-id="37f80-142">Дополнительные сведения см. в разделе [Делегаты](../delegates/index.md).</span><span class="sxs-lookup"><span data-stu-id="37f80-142">For more information, see [Delegates](../delegates/index.md).</span></span> <span data-ttu-id="37f80-143">Результатом вызова метода или делегата является возвращаемое методом значение, если метод вообще возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="37f80-143">Method invocations and delegate invocations evaluate to the return value of the method, if the method returns a value.</span></span> <span data-ttu-id="37f80-144">В качестве значений в выражениях нельзя использовать методы, возвращающие значение типа void.</span><span class="sxs-lookup"><span data-stu-id="37f80-144">Methods that return void cannot be used in place of a value in an expression.</span></span>  

## <a name="query-expressions"></a><span data-ttu-id="37f80-145">Выражения запросов</span><span class="sxs-lookup"><span data-stu-id="37f80-145">Query expressions</span></span>

 <span data-ttu-id="37f80-146">Аналогичные правила в общем случае применяются и к выражениям запроса.</span><span class="sxs-lookup"><span data-stu-id="37f80-146">The same rules for expressions in general apply to query expressions.</span></span> <span data-ttu-id="37f80-147">Дополнительные сведения см. в статье [LINQ](../../linq/index.md).</span><span class="sxs-lookup"><span data-stu-id="37f80-147">For more information, see [LINQ](../../linq/index.md).</span></span>  
  
## <a name="lambda-expressions"></a><span data-ttu-id="37f80-148">Лямбда-выражения</span><span class="sxs-lookup"><span data-stu-id="37f80-148">Lambda expressions</span></span>

 <span data-ttu-id="37f80-149">Лямбда-выражения представляют собой "встроенные методы", у которых нет имен, но которые могут иметь входные параметры и несколько инструкций.</span><span class="sxs-lookup"><span data-stu-id="37f80-149">Lambda expressions represent "inline methods" that have no name but can have input parameters and multiple statements.</span></span> <span data-ttu-id="37f80-150">Они активно используются в LINQ для передачи аргументов методам.</span><span class="sxs-lookup"><span data-stu-id="37f80-150">They are used extensively in LINQ to pass arguments to methods.</span></span> <span data-ttu-id="37f80-151">Лямбда-выражения компилируются в делегаты или в деревья выражений в зависимости от условий, при которых они используются.</span><span class="sxs-lookup"><span data-stu-id="37f80-151">Lambda expressions are compiled to either delegates or expression trees depending on the context in which they are used.</span></span> <span data-ttu-id="37f80-152">Дополнительные сведения см. в разделе [Лямбда-выражения](lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="37f80-152">For more information, see [Lambda Expressions](lambda-expressions.md).</span></span>  
  
## <a name="expression-trees"></a><span data-ttu-id="37f80-153">Деревья выражений</span><span class="sxs-lookup"><span data-stu-id="37f80-153">Expression trees</span></span>

<span data-ttu-id="37f80-154">Деревья выражения позволяют представлять выражения в виде структур данных.</span><span class="sxs-lookup"><span data-stu-id="37f80-154">Expression trees enable expressions to be represented as data structures.</span></span> <span data-ttu-id="37f80-155">Они широко используются поставщиками LINQ для преобразования выражений запросов в код, имеющий смысл в других контекстах, например в базе данных SQL.</span><span class="sxs-lookup"><span data-stu-id="37f80-155">They are used extensively by LINQ providers to translate query expressions into code that is meaningful in some other context, such as a SQL database.</span></span> <span data-ttu-id="37f80-156">Дополнительные сведения см. в статье [Деревья выражений (C#)](../concepts/expression-trees/index.md).</span><span class="sxs-lookup"><span data-stu-id="37f80-156">For more information, see [Expression Trees (C#)](../concepts/expression-trees/index.md).</span></span>
  
## <a name="expression-body-definitions"></a><span data-ttu-id="37f80-157">Определения текста выражений</span><span class="sxs-lookup"><span data-stu-id="37f80-157">Expression body definitions</span></span>

<span data-ttu-id="37f80-158">C# поддерживает *элементы, воплощающие выражение*, которые позволяют указать итоговое определение текста выражения, методы, конструкторы, методы завершения, свойства и индексаторы.</span><span class="sxs-lookup"><span data-stu-id="37f80-158">C# supports *expression-bodied members*, which allow you to supply a concise expression body definition for methods, constructors, finalizers, properties, and indexers.</span></span> <span data-ttu-id="37f80-159">Дополнительные сведения см. в разделе [Элементы, воплощающие выражение](expression-bodied-members.md).</span><span class="sxs-lookup"><span data-stu-id="37f80-159">For more information, see [Expression-bodied members](expression-bodied-members.md).</span></span>

## <a name="remarks"></a><span data-ttu-id="37f80-160">Примечания</span><span class="sxs-lookup"><span data-stu-id="37f80-160">Remarks</span></span>

 <span data-ttu-id="37f80-161">Если в выражении присутствует переменная, свойство объекта или индексатор объекта, для вычисления выражения используется значение этого элемента.</span><span class="sxs-lookup"><span data-stu-id="37f80-161">Whenever a variable, object property, or object indexer access is identified from an expression, the value of that item is used as the value of the expression.</span></span> <span data-ttu-id="37f80-162">В C# выражение можно использовать везде, где требуется значение или объект, если результат вычисления выражения соответствует требуемому типу.</span><span class="sxs-lookup"><span data-stu-id="37f80-162">An expression can be placed anywhere in C# where a value or object is required, as long as the expression ultimately evaluates to the required type.</span></span>  

## <a name="c-language-specification"></a><span data-ttu-id="37f80-163">Спецификация языка C#</span><span class="sxs-lookup"><span data-stu-id="37f80-163">C# language specification</span></span>

<span data-ttu-id="37f80-164">Дополнительные сведения см. в разделе о [выражениях](~/_csharplang/spec/expressions.md) в [спецификации языка C#](~/_csharplang/spec/introduction.md).</span><span class="sxs-lookup"><span data-stu-id="37f80-164">For more information, see the [Expressions](~/_csharplang/spec/expressions.md) section of the [C# language specification](~/_csharplang/spec/introduction.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="37f80-165">См. также</span><span class="sxs-lookup"><span data-stu-id="37f80-165">See also</span></span>

- [<span data-ttu-id="37f80-166">Руководство по программированию на C#</span><span class="sxs-lookup"><span data-stu-id="37f80-166">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="37f80-167">Инструкции</span><span class="sxs-lookup"><span data-stu-id="37f80-167">Operators</span></span>](../../language-reference/operators/index.md)
- [<span data-ttu-id="37f80-168">Методы</span><span class="sxs-lookup"><span data-stu-id="37f80-168">Methods</span></span>](../classes-and-structs/methods.md)
- [<span data-ttu-id="37f80-169">Делегаты</span><span class="sxs-lookup"><span data-stu-id="37f80-169">Delegates</span></span>](../delegates/index.md)
- [<span data-ttu-id="37f80-170">Типы</span><span class="sxs-lookup"><span data-stu-id="37f80-170">Types</span></span>](../types/index.md)
- [<span data-ttu-id="37f80-171">LINQ</span><span class="sxs-lookup"><span data-stu-id="37f80-171">LINQ</span></span>](../../linq/index.md)
