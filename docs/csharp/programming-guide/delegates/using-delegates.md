---
title: Руководство по программированию на C#. Использование делегатов
description: Сведения об использовании делегатов. Делегат представляет собой объектно-ориентированный, типобезопасный и надежный тип, который безопасно инкапсулирует метод.
ms.date: 07/20/2015
helpviewer_keywords:
- delegates [C#], how to use
ms.assetid: 99a2fc27-a32e-4a34-921c-e65497520eec
ms.openlocfilehash: a9b625b8c0785ed2f446be27c11dc76108bc4bce
ms.sourcegitcommit: 6f58a5f75ceeb936f8ee5b786e9adb81a9a3bee9
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/28/2020
ms.locfileid: "87302156"
---
# <a name="using-delegates-c-programming-guide"></a><span data-ttu-id="a4924-104">Использование делегатов (Руководство по программированию на C#)</span><span class="sxs-lookup"><span data-stu-id="a4924-104">Using Delegates (C# Programming Guide)</span></span>

<span data-ttu-id="a4924-105">[Делегат](../../language-reference/builtin-types/reference-types.md) — это тип, который безопасно инкапсулирует метод, схожий с указателем функции в C и C++.</span><span class="sxs-lookup"><span data-stu-id="a4924-105">A [delegate](../../language-reference/builtin-types/reference-types.md) is a type that safely encapsulates a method, similar to a function pointer in C and C++.</span></span> <span data-ttu-id="a4924-106">В отличие от указателей функций в C делегаты объектно-ориентированы, типобезопасны и безопасны.</span><span class="sxs-lookup"><span data-stu-id="a4924-106">Unlike C function pointers, delegates are object-oriented, type safe, and secure.</span></span> <span data-ttu-id="a4924-107">Тип делегата задается его именем.</span><span class="sxs-lookup"><span data-stu-id="a4924-107">The type of a delegate is defined by the name of the delegate.</span></span> <span data-ttu-id="a4924-108">В следующем примере объявляется делегат с именем `Del`, который может инкапсулировать метод, использующий в качестве аргумента значение [string](../../language-reference/builtin-types/reference-types.md) и возвращающий значение [void](../../language-reference/builtin-types/void.md):</span><span class="sxs-lookup"><span data-stu-id="a4924-108">The following example declares a delegate named `Del` that can encapsulate a method that takes a [string](../../language-reference/builtin-types/reference-types.md) as an argument and returns [void](../../language-reference/builtin-types/void.md):</span></span>

[!code-csharp[csProgGuideDelegates#21](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#21)]

<span data-ttu-id="a4924-109">Объект делегата обычно создается путем указания имени метода, для которого делегат будет служить оболочкой, или с помощью [анонимной функции](../statements-expressions-operators/anonymous-functions.md).</span><span class="sxs-lookup"><span data-stu-id="a4924-109">A delegate object is normally constructed by providing the name of the method the delegate will wrap, or with an [anonymous function](../statements-expressions-operators/anonymous-functions.md).</span></span> <span data-ttu-id="a4924-110">После создания экземпляра делегата вызов метода, выполненный в делегате передается делегатом в этот метод.</span><span class="sxs-lookup"><span data-stu-id="a4924-110">Once a delegate is instantiated, a method call made to the delegate will be passed by the delegate to that method.</span></span> <span data-ttu-id="a4924-111">Параметры, передаваемые делегату вызывающим объектом, передаются в метод, а возвращаемое методом значение (при его наличии) возвращается делегатом в вызывающий объект.</span><span class="sxs-lookup"><span data-stu-id="a4924-111">The parameters passed to the delegate by the caller are passed to the method, and the return value, if any, from the method is returned to the caller by the delegate.</span></span> <span data-ttu-id="a4924-112">Эта процедура называется вызовом делегата.</span><span class="sxs-lookup"><span data-stu-id="a4924-112">This is known as invoking the delegate.</span></span> <span data-ttu-id="a4924-113">Делегат, для которого создан экземпляр, можно вызвать, как если бы это был метод, для которого создается оболочка.</span><span class="sxs-lookup"><span data-stu-id="a4924-113">An instantiated delegate can be invoked as if it were the wrapped method itself.</span></span> <span data-ttu-id="a4924-114">Пример:</span><span class="sxs-lookup"><span data-stu-id="a4924-114">For example:</span></span>

[!code-csharp[csProgGuideDelegates#22](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#22)]  

[!code-csharp[csProgGuideDelegates#23](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#23)]

<span data-ttu-id="a4924-115">Типы делегатов являются производными от класса <xref:System.Delegate> в .NET.</span><span class="sxs-lookup"><span data-stu-id="a4924-115">Delegate types are derived from the <xref:System.Delegate> class in .NET.</span></span> <span data-ttu-id="a4924-116">Типы делегатов являются [запечатанными](../../language-reference/keywords/sealed.md) — от них нельзя наследовать, а от <xref:System.Delegate> нельзя создавать производные пользовательские классы.</span><span class="sxs-lookup"><span data-stu-id="a4924-116">Delegate types are [sealed](../../language-reference/keywords/sealed.md)—they cannot be derived from— and it is not possible to derive custom classes from <xref:System.Delegate>.</span></span> <span data-ttu-id="a4924-117">Поскольку созданный экземпляр делегата является объектом, его можно передавать как параметр или назначать свойству.</span><span class="sxs-lookup"><span data-stu-id="a4924-117">Because the instantiated delegate is an object, it can be passed as a parameter, or assigned to a property.</span></span> <span data-ttu-id="a4924-118">Это позволяет методу принимать делегат в качестве параметра и вызывать делегат в дальнейшем.</span><span class="sxs-lookup"><span data-stu-id="a4924-118">This allows a method to accept a delegate as a parameter, and call the delegate at some later time.</span></span> <span data-ttu-id="a4924-119">Эта процедура называется асинхронным обратным вызовом и обычно используется для уведомления вызывающего объекта о завершении длительной операции.</span><span class="sxs-lookup"><span data-stu-id="a4924-119">This is known as an asynchronous callback, and is a common method of notifying a caller when a long process has completed.</span></span> <span data-ttu-id="a4924-120">Когда делегат используется таким образом, коду, использующему делегат, не требуются сведения о реализации используемого метода.</span><span class="sxs-lookup"><span data-stu-id="a4924-120">When a delegate is used in this fashion, the code using the delegate does not need any knowledge of the implementation of the method being used.</span></span> <span data-ttu-id="a4924-121">Данные функциональные возможности аналогичны возможностям, предоставляемым интерфейсами инкапсуляции.</span><span class="sxs-lookup"><span data-stu-id="a4924-121">The functionality is similar to the encapsulation interfaces provide.</span></span>

<span data-ttu-id="a4924-122">Обратный вызов также часто используется для задания настраиваемого метода сравнения и передачи этого делегата в метод сортировки.</span><span class="sxs-lookup"><span data-stu-id="a4924-122">Another common use of callbacks is defining a custom comparison method and passing that delegate to a sort method.</span></span> <span data-ttu-id="a4924-123">Это позволяет сделать коду вызывающего объекта частью алгоритма сортировки.</span><span class="sxs-lookup"><span data-stu-id="a4924-123">It allows the caller's code to become part of the sort algorithm.</span></span> <span data-ttu-id="a4924-124">В следующем примере метод использует тип `Del` тип в качестве параметра.</span><span class="sxs-lookup"><span data-stu-id="a4924-124">The following example method uses the `Del` type as a parameter:</span></span>

[!code-csharp[csProgGuideDelegates#24](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#24)]

<span data-ttu-id="a4924-125">Затем в данный метод можно передать созданный ранее делегат:</span><span class="sxs-lookup"><span data-stu-id="a4924-125">You can then pass the delegate created above to that method:</span></span>

[!code-csharp[csProgGuideDelegates#25](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#25)]

<span data-ttu-id="a4924-126">и получить следующие выходные данные в окне консоли:</span><span class="sxs-lookup"><span data-stu-id="a4924-126">and receive the following output to the console:</span></span>

```console
The number is: 3
```

<span data-ttu-id="a4924-127">При использовании делегата в качестве абстракции методу `MethodWithCallback` не нужно выполнять непосредственный вызов консоли, то есть его можно создавать без учета консоли.</span><span class="sxs-lookup"><span data-stu-id="a4924-127">Using the delegate as an abstraction, `MethodWithCallback` does not need to call the console directly—it does not have to be designed with a console in mind.</span></span> <span data-ttu-id="a4924-128">Метод `MethodWithCallback` просто подготавливает строку и передает ее в другой метод.</span><span class="sxs-lookup"><span data-stu-id="a4924-128">What `MethodWithCallback` does is simply prepare a string and pass the string to another method.</span></span> <span data-ttu-id="a4924-129">Это очень удобно, так как делегируемый метод может использовать любое количество параметров.</span><span class="sxs-lookup"><span data-stu-id="a4924-129">This is especially powerful since a delegated method can use any number of parameters.</span></span>

<span data-ttu-id="a4924-130">Если делегат создан в качестве оболочки для метода экземпляра, этот делегат ссылается и на экземпляр, и на метод.</span><span class="sxs-lookup"><span data-stu-id="a4924-130">When a delegate is constructed to wrap an instance method, the delegate references both the instance and the method.</span></span> <span data-ttu-id="a4924-131">Делегат не имеет сведений о типе экземпляра, кроме полученных из метода, для которого он является оболочкой, поэтому делегат может ссылаться на любой тип объекта, если для этого объекта есть метод, соответствующий сигнатуре делегата.</span><span class="sxs-lookup"><span data-stu-id="a4924-131">A delegate has no knowledge of the instance type aside from the method it wraps, so a delegate can refer to any type of object as long as there is a method on that object that matches the delegate signature.</span></span> <span data-ttu-id="a4924-132">Если делегат создан в качестве оболочки для статического метода, он ссылается только на метод.</span><span class="sxs-lookup"><span data-stu-id="a4924-132">When a delegate is constructed to wrap a static method, it only references the method.</span></span> <span data-ttu-id="a4924-133">Рассмотрим следующее объявление:</span><span class="sxs-lookup"><span data-stu-id="a4924-133">Consider the following declarations:</span></span>

[!code-csharp[csProgGuideDelegates#26](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#26)]

<span data-ttu-id="a4924-134">Вместе с рассмотренным ранее статическим методом `DelegateMethod` есть три метода, для которых можно создать оболочку с помощью экземпляра `Del`.</span><span class="sxs-lookup"><span data-stu-id="a4924-134">Along with the static `DelegateMethod` shown previously, we now have three methods that can be wrapped by a `Del` instance.</span></span>

<span data-ttu-id="a4924-135">При вызове делегат может вызывать сразу несколько методов.</span><span class="sxs-lookup"><span data-stu-id="a4924-135">A delegate can call more than one method when invoked.</span></span> <span data-ttu-id="a4924-136">Это называется многоадресностью.</span><span class="sxs-lookup"><span data-stu-id="a4924-136">This is referred to as multicasting.</span></span> <span data-ttu-id="a4924-137">Чтобы добавить в список методов делегата (список вызова) дополнительный метод, необходимо просто добавить два делегата с помощью оператора сложения или назначения сложения ("+" или "+=").</span><span class="sxs-lookup"><span data-stu-id="a4924-137">To add an extra method to the delegate's list of methods—the invocation list—simply requires adding two delegates using the addition or addition assignment operators ('+' or '+=').</span></span> <span data-ttu-id="a4924-138">Пример:</span><span class="sxs-lookup"><span data-stu-id="a4924-138">For example:</span></span>

[!code-csharp[csProgGuideDelegates#27](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#27)]

<span data-ttu-id="a4924-139">На данном этапе список вызова делегата `allMethodsDelegate` содержит три метода — `Method1`, `Method2` и `DelegateMethod`.</span><span class="sxs-lookup"><span data-stu-id="a4924-139">At this point `allMethodsDelegate` contains three methods in its invocation list—`Method1`, `Method2`, and `DelegateMethod`.</span></span> <span data-ttu-id="a4924-140">Три исходных делегата `d1`, `d2` и `d3` остаются без изменений.</span><span class="sxs-lookup"><span data-stu-id="a4924-140">The original three delegates, `d1`, `d2`, and `d3`, remain unchanged.</span></span> <span data-ttu-id="a4924-141">При вызове `allMethodsDelegate` все три метода вызываются по порядку.</span><span class="sxs-lookup"><span data-stu-id="a4924-141">When `allMethodsDelegate` is invoked, all three methods are called in order.</span></span> <span data-ttu-id="a4924-142">Если делегат использует параметры, передаваемые по ссылке, эта ссылка передается после каждого из трех методов, а все изменения одного из методов становятся видны в следующем методе.</span><span class="sxs-lookup"><span data-stu-id="a4924-142">If the delegate uses reference parameters, the reference is passed sequentially to each of the three methods in turn, and any changes by one method are visible to the next method.</span></span> <span data-ttu-id="a4924-143">Если любой из методов вызывает неперехваченное исключение, это исключение передается в вызывающий делегат объект, а последующие методы в списке вызова не вызываются.</span><span class="sxs-lookup"><span data-stu-id="a4924-143">When any of the methods throws an exception that is not caught within the method, that exception is passed to the caller of the delegate and no subsequent methods in the invocation list are called.</span></span> <span data-ttu-id="a4924-144">Если делегат имеет возвращаемое значение и (или) выходные параметры, он возвращает возвращаемое значение и параметры последнего вызванного метода.</span><span class="sxs-lookup"><span data-stu-id="a4924-144">If the delegate has a return value and/or out parameters, it returns the return value and parameters of the last method invoked.</span></span> <span data-ttu-id="a4924-145">Чтобы удалить метод из списка вызовов, используйте [вычитание или операторы присваивания вычитания](../../language-reference/operators/subtraction-operator.md) (`-` или `-=`).</span><span class="sxs-lookup"><span data-stu-id="a4924-145">To remove a method from the invocation list, use the [subtraction or subtraction assignment operators](../../language-reference/operators/subtraction-operator.md) (`-` or `-=`).</span></span> <span data-ttu-id="a4924-146">Пример:</span><span class="sxs-lookup"><span data-stu-id="a4924-146">For example:</span></span>

[!code-csharp[csProgGuideDelegates#28](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#28)]

<span data-ttu-id="a4924-147">Поскольку типы делегата являются производными от `System.Delegate`, в делегате можно вызывать методы и свойства, определенные этим классом.</span><span class="sxs-lookup"><span data-stu-id="a4924-147">Because delegate types are derived from `System.Delegate`, the methods and properties defined by that class can be called on the delegate.</span></span> <span data-ttu-id="a4924-148">Например, чтобы определить число методов в списке вызова делегата, можно использовать код:</span><span class="sxs-lookup"><span data-stu-id="a4924-148">For example, to find the number of methods in a delegate's invocation list, you may write:</span></span>

[!code-csharp[csProgGuideDelegates#29](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#29)]

<span data-ttu-id="a4924-149">Делегаты, в списке вызова которых находятся несколько методов, является производным от <xref:System.MulticastDelegate>, являющегося подклассом класса `System.Delegate`.</span><span class="sxs-lookup"><span data-stu-id="a4924-149">Delegates with more than one method in their invocation list derive from <xref:System.MulticastDelegate>, which is a subclass of `System.Delegate`.</span></span> <span data-ttu-id="a4924-150">Приведенный выше код работает в любом из случаев, так как оба класса поддерживают `GetInvocationList`.</span><span class="sxs-lookup"><span data-stu-id="a4924-150">The above code works in either case because both classes support `GetInvocationList`.</span></span>

<span data-ttu-id="a4924-151">Групповые делегаты часто используются при обработке событий.</span><span class="sxs-lookup"><span data-stu-id="a4924-151">Multicast delegates are used extensively in event handling.</span></span> <span data-ttu-id="a4924-152">Объекты источников событий отправляют уведомления объектам получателей, зарегистрированным для получения данного события.</span><span class="sxs-lookup"><span data-stu-id="a4924-152">Event source objects send event notifications to recipient objects that have registered to receive that event.</span></span> <span data-ttu-id="a4924-153">Чтобы зарегистрироваться для получения события, объект получателя создает метод, предназначенный для обработки этого события, затем создает делегат для этого метода и передает его в источник события.</span><span class="sxs-lookup"><span data-stu-id="a4924-153">To register for an event, the recipient creates a method designed to handle the event, then creates a delegate for that method and passes the delegate to the event source.</span></span> <span data-ttu-id="a4924-154">Когда происходит событие, источник вызывает делегат.</span><span class="sxs-lookup"><span data-stu-id="a4924-154">The source calls the delegate when the event occurs.</span></span> <span data-ttu-id="a4924-155">После этого делегат вызывает в объекте получателя обработки события, предоставив ему данные события.</span><span class="sxs-lookup"><span data-stu-id="a4924-155">The delegate then calls the event handling method on the recipient, delivering the event data.</span></span> <span data-ttu-id="a4924-156">Тип делегата для данного события задается источником события.</span><span class="sxs-lookup"><span data-stu-id="a4924-156">The delegate type for a given event is defined by the event source.</span></span> <span data-ttu-id="a4924-157">Дополнительные сведения см. в разделе [События](../events/index.md).</span><span class="sxs-lookup"><span data-stu-id="a4924-157">For more, see [Events](../events/index.md).</span></span>

<span data-ttu-id="a4924-158">Назначение сравнения делегатов двух различных типов во время компиляции вызовет ошибку компиляции.</span><span class="sxs-lookup"><span data-stu-id="a4924-158">Comparing delegates of two different types assigned at compile-time will result in a compilation error.</span></span> <span data-ttu-id="a4924-159">Если экземпляры делегата статически относятся к типу `System.Delegate`, сравнение допустимо, но во время выполнения будет возвращено значение false.</span><span class="sxs-lookup"><span data-stu-id="a4924-159">If the delegate instances are statically of the type `System.Delegate`, then the comparison is allowed, but will return false at run time.</span></span> <span data-ttu-id="a4924-160">Пример:</span><span class="sxs-lookup"><span data-stu-id="a4924-160">For example:</span></span>

[!code-csharp[csProgGuideDelegates#30](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#30)]

## <a name="see-also"></a><span data-ttu-id="a4924-161">См. также</span><span class="sxs-lookup"><span data-stu-id="a4924-161">See also</span></span>

- [<span data-ttu-id="a4924-162">Руководство по программированию на C#</span><span class="sxs-lookup"><span data-stu-id="a4924-162">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="a4924-163">Делегаты</span><span class="sxs-lookup"><span data-stu-id="a4924-163">Delegates</span></span>](./index.md)
- [<span data-ttu-id="a4924-164">Использование расхождения в делегатах</span><span class="sxs-lookup"><span data-stu-id="a4924-164">Using Variance in Delegates</span></span>](../concepts/covariance-contravariance/using-variance-in-delegates.md)
- [<span data-ttu-id="a4924-165">Расхождение в делегатах</span><span class="sxs-lookup"><span data-stu-id="a4924-165">Variance in Delegates</span></span>](../concepts/covariance-contravariance/variance-in-delegates.md)
- [<span data-ttu-id="a4924-166">Использование расхождения в универсальных методах-делегатах Func и Action</span><span class="sxs-lookup"><span data-stu-id="a4924-166">Using Variance for Func and Action Generic Delegates</span></span>](../concepts/covariance-contravariance/using-variance-for-func-and-action-generic-delegates.md)
- [<span data-ttu-id="a4924-167">События</span><span class="sxs-lookup"><span data-stu-id="a4924-167">Events</span></span>](../events/index.md)
