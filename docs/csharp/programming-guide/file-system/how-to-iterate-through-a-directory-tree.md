---
title: Руководство по программированию на C#. Выполнение итерации по дереву папок
description: Узнайте, как выполнить итерацию по дереву папок. Получите доступ к каждому файлу в каждом вложенном каталоге в указанной корневой папке.
ms.date: 07/20/2015
helpviewer_keywords:
- iterating through folders [C#]
- file iteration [C#]
ms.assetid: c4be4a75-6b1b-46a7-9d38-bab353091ed7
ms.openlocfilehash: 9d927e8517ddbdb1c5a9a8aa8ca3c321bf7e8d9c
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/24/2020
ms.locfileid: "91178545"
---
# <a name="how-to-iterate-through-a-directory-tree-c-programming-guide"></a>Руководство по программированию на C#. Выполнение итерации по дереву папок

Под фразой "обход дерева каталогов" подразумевается доступ к каждому файлу в каждом вложенном подкаталоге в заданной корневой папке на любую глубину. Необязательно открывать каждый файл. Можно просто извлечь имя файла или подкаталога в виде значения `string` или получить дополнительную информацию в форме объекта <xref:System.IO.FileInfo?displayProperty=nameWithType> или <xref:System.IO.DirectoryInfo?displayProperty=nameWithType>.  
  
> [!NOTE]
> В Windows термины "каталог" и "папка" являются взаимозаменяемыми. В большинстве документации и в текстах пользовательского интерфейса используется термин "папка", но в библиотеке классов .NET используется термин "каталог".  
  
 В простейшем случае, когда точно известно, что имеются права доступа ко всем каталогам в указанном корне, можно использовать флаг `System.IO.SearchOption.AllDirectories`. Этот флаг возвращает все вложенные подкаталоги, соответствующие заданному шаблону. В приведенном ниже примере показано, как использовать этот флаг.  
  
```csharp  
root.GetDirectories("*.*", System.IO.SearchOption.AllDirectories);  
```  
  
 Слабая сторона такого подхода заключается в том, что если какой-либо из подкаталогов в указанном корне вызовет <xref:System.IO.DirectoryNotFoundException> или <xref:System.UnauthorizedAccessException>, то весь метод не будет выполнен и каталоги не будут возвращены. Это же относится и к использованию метода <xref:System.IO.DirectoryInfo.GetFiles%2A>. Если необходимо обработать эти исключения в определенных вложенных папках, необходимо вручную пройти по дереву каталога, как показано в приведенных ниже примерах.  
  
 При проходе вручную по дереву каталога можно обработать сначала подкаталоги (*обход в прямом порядке*) или файлы (*обход в обратном порядке*). При выполнении обхода в прямом порядке проходится все дерево в текущей папке перед итерацией файлов, которые находятся в самой папке. В приведенных ниже примерах выполняется обход в обратном порядке, но его можно легко изменить на обход в прямом порядке.  
  
 Еще одним параметром является использование рекурсии или обхода на основе стека. В приведенных ниже примерах показаны оба подхода.  
  
 Если необходимо выполнить различные операции с файлами и папками, то можно смоделировать эти примеры путем рефакторинга операции на отдельные функции, которые можно вызвать с помощью одного делегата.  
  
> [!NOTE]
> Файловые системы NTFS могут содержать *точки повторного анализа* в форме *точек соединения*, *символических ссылок* и *жестких связей*. Методы платформы .NET, такие как <xref:System.IO.DirectoryInfo.GetFiles%2A> и <xref:System.IO.DirectoryInfo.GetDirectories%2A>, не возвращают подкаталоги ниже точки повторного анализа. Такое поведение предотвращает риск входа в бесконечный цикл, когда две точки повторного анализа ссылаются друг на друга. Как правило, следует быть предельно осторожными при работе с точками повторного анализа, чтобы избежать случайного изменения или удаления файлов. Если требуется строгий контроль над точками повторного анализа, используйте вызов неуправляемого кода или машинный код для прямого вызова подходящих методов файловой системы Win32.  
  
## <a name="example"></a>Пример  

 В приведенном ниже примере показан проход по дереву каталога с помощью рекурсии. Рекурсивный подход является элегантным, но он потенциально может вызвать исключение переполнения стека, если дерево каталога большое и имеет большой уровень вложения.  
  
 Обрабатываемые исключения и действия, выполняемые с каждым файлом или папкой, предоставляются только в качестве примеров. Этот код следует изменить в соответствии с конкретными требованиями. Дополнительные сведения см. в комментариях в коде.  
  
 [!code-csharp[csFilesandFolders#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csFilesAndFolders/CS/FileIteration.cs#1)]  
  
## <a name="example"></a>Пример  

 В приведенном ниже примере показан обход файлов и папок в дереве папок без использования рекурсии. Этот метод использует универсальный тип коллекции <xref:System.Collections.Generic.Stack%601>, который представляет стек типа "последним пришел — первым вышел" (LIFO).  
  
 Обрабатываемые исключения и действия, выполняемые с каждым файлом или папкой, предоставляются только в качестве примеров. Этот код следует изменить в соответствии с конкретными требованиями. Дополнительные сведения см. в комментариях в коде.  
  
 [!code-csharp[csFilesandFolders#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csFilesAndFolders/CS/FileIteration.cs#2)]  
  
 Обычно проверка каждой папки на наличие у приложения разрешений на ее открытие занимает слишком много времени. Поэтому в примере кода эта часть операции просто включена в блок `try/catch`. Блок `catch` можно изменить так, чтобы при отказе в доступе к папке предпринималась попытка повысить права, а затем повторная попытка получить доступ. Как правило, следует перехватывать только те исключения, которые можно обработать, не оставляя приложение в неопределенном состоянии.  
  
 Если необходимо сохранить содержимое дерева каталога либо в памяти, либо на диске, наилучшим вариантом будет сохранение только свойства <xref:System.IO.FileSystemInfo.FullName%2A> (типа `string`) для каждого файла. Затем можно использовать эту строку для создания объекта <xref:System.IO.FileInfo> или <xref:System.IO.DirectoryInfo> по мере необходимости или открыть любой файл, для которого требуется дополнительная обработка.  
  
## <a name="robust-programming"></a>Отказоустойчивость  

 Надежный код обхода файлов должен учитывать сложности файловой системы. Дополнительные сведения о файловой системе Windows см. в статье [Обзор NTFS](/windows-server/storage/file-server/ntfs-overview).  
  
## <a name="see-also"></a>См. также

- <xref:System.IO>
- [LINQ и каталоги файлов](../concepts/linq/linq-and-file-directories.md)
- [Файловая система и реестр (руководство по программированию на C#)](./index.md)
