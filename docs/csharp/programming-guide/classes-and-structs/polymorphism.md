---
title: Руководство по программированию на C#. Полиморфизм
ms.date: 07/20/2015
helpviewer_keywords:
- C# language, polymorphism
- polymorphism [C#]
ms.assetid: 086af969-29a5-4ce8-a993-0b7d53839dab
ms.openlocfilehash: 4f65082ad5094eb0aab28edeb06790a9af4019c6
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2020
ms.locfileid: "75714733"
---
# <a name="polymorphism-c-programming-guide"></a>Полиморфизм (Руководство по программированию на C#)
Полиморфизм часто называется третьим столпом объектно-ориентированного программирования после инкапсуляции и наследования. Полиморфизм — слово греческого происхождения, означающее "многообразие форм" и имеющее несколько аспектов.  
  
- Во время выполнения объекты производного класса могут обрабатываться как объекты базового класса в таких местах, как параметры метода и коллекции или массивы. Когда это происходит, объявленный тип объекта перестает соответствовать своему типу во время выполнения.  
  
- Базовые классы могут определять и реализовывать [виртуальные](../../language-reference/keywords/virtual.md) *методы*, а производные классы — [переопределять](../../language-reference/keywords/override.md) их, т. е. предоставлять свое собственное определение и реализацию. Во время выполнения, когда клиент вызывает метод, CLR выполняет поиск типа объекта во время выполнения и вызывает перезапись виртуального метода. Таким образом, в исходном коде можно вызвать метод на базовом классе и привести версию производного класса метода, который необходимо выполнить.  
  
 Виртуальные методы позволяют работать с группами связанных объектов универсальным способом. Представим, например, приложение, позволяющее пользователю создавать различные виды фигур на поверхности для рисования. Во время компиляции вы еще не знаете, какие именно виды фигур создаст пользователь. При этом приложению необходимо отслеживать все различные типы создаваемых фигур и обновлять их в ответ на движения мыши. Для решения этой проблемы можно использовать полиморфизм, выполнив два основных действия.  
  
1. Создать иерархию классов, в которой каждый отдельный класс фигур является производным из общего базового класса.  
  
2. Применить виртуальный метод для вызова соответствующего метода на любой производный класс через единый вызов в метод базового класса.  
  
 Для начала создайте базовый класс с именем `Shape` и производные классы, например `Rectangle`, `Circle` и `Triangle`. Присвойте классу `Shape` виртуальный метод с именем `Draw` и переопределите его в каждом производном классе для рисования конкретной фигуры, которую этот класс представляет. Создайте объект `List<Shape>` и добавьте в него круг, треугольник и прямоугольник. Для обновления поверхности рисования используйте цикл [foreach](../../language-reference/keywords/foreach-in.md), чтобы выполнить итерацию списка и вызвать метод `Draw` на каждом объекте `Shape` в списке. Несмотря на то, что каждый объект в списке имеет объявленный тип `Shape`, вызывать будет тип во время выполнения (переопределенная версия метода в каждом производном классе).  
  
 [!code-csharp[csProgGuideInheritance#50](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#50)]  
  
 В C# каждый тип является полиморфным, так как все типы, включая пользовательские, наследуют <xref:System.Object>.  
  
## <a name="polymorphism-overview"></a>Обзор полиморфизма  
  
### <a name="virtual-members"></a>Виртуальные члены  
 Если производный класс наследуется из базового, он получает все методы, поля, свойства и события базового класса. Разработчик производного класса может выбрать следующее:  
  
- переопределение виртуальных членов в базовом классе;  
  
- наследование метода ближайшего базового класса без переопределения;  
  
- определение новой, невиртуальной реализации тех членов, которые скрывают реализации базового класса.  
  
 Производный класс может переопределить член базового класса, только если последний будет объявлен [виртуальным](../../language-reference/keywords/virtual.md) или [абстрактным](../../language-reference/keywords/abstract.md). Производный член должен использовать ключевое слово [override](../../language-reference/keywords/override.md), указывающее, что метод предназначен для участия в виртуальном вызове. Примером является следующий код:  
  
 [!code-csharp[csProgGuideInheritance#20](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#20)]  
  
 Поля не могут быть виртуальными. Виртуальными могут быть только методы, свойства, события и индексаторы. Когда производный класс переопределяет виртуальный член, он вызывается даже в то случае, если доступ к экземпляру этого класса осуществляется в качестве экземпляра базового класса. Примером является следующий код:  
  
 [!code-csharp[csProgGuideInheritance#21](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#21)]  
  
 Виртуальные методы и свойства позволяют производным классам расширять базовый класс без необходимости использовать реализацию базового класса метода. Дополнительные сведения см. в разделе [Управление версиями с помощью ключевых слов Override и New](./versioning-with-the-override-and-new-keywords.md). Еще одну возможность определения метода или набора методов, реализация которых оставлена производным классам, дает интерфейс. Дополнительные сведения см. в разделе [Интерфейсы](../interfaces/index.md).  
  
### <a name="hiding-base-class-members-with-new-members"></a>Сокрытие членов базового класса новыми членами  
 Если вам нужно, чтобы производный член имел такое же имя, как и член в базовом классе, но вы не хотите, чтобы он участвовал в виртуальном вызове, используйте ключевое слово [new](../../language-reference/keywords/new-modifier.md). Ключевое слово `new` вставляется перед типом возвращаемого значения замещаемого члена класса. Примером является следующий код:  
  
 [!code-csharp[csProgGuideInheritance#18](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#18)]  
  
 Доступ к скрытым членам базового класса можно по-прежнему осуществлять из клиентского кода приведением экземпляра производного класса к экземпляру базового класса. Пример:  
  
 [!code-csharp[csProgGuideInheritance#19](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#19)]  
  
### <a name="preventing-derived-classes-from-overriding-virtual-members"></a>Защита виртуальных членов от переопределения производными классами  
 Виртуальные члены остаются виртуальными на неограниченный срок независимо от количества классов, объявленных между виртуальным членом и классом, который объявил его изначально. Если класс А объявляет виртуальный член, класс В производится из класса А, а класс С — из класса В, то класс С наследует виртуальный член и получает возможность переопределить его независимо от того, объявляет ли класс В переопределение этого члена. Примером является следующий код:  
  
 [!code-csharp[csProgGuideInheritance#22](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#22)]  
  
 Производный класс может остановить виртуальное наследование, объявив переопределение как [запечатанное](../../language-reference/keywords/sealed.md). Для этого в объявление члена класса необходимо вставить ключевое слово `sealed` перед ключевым словом `override`. Примером является следующий код:  
  
 [!code-csharp[csProgGuideInheritance#24](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#24)]  
  
 В предыдущем примере метод `DoWork` больше не является виртуальным для любого класса, производного от C. Он по-прежнему будет виртуальным для экземпляров C, даже если они будут приведены к типу B или A. Запечатанные методы можно заменить производными классами с помощью ключевого слова `new`, как показано в следующем примере:  
  
 [!code-csharp[csProgGuideInheritance#25](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#25)]  
  
 В этом случае, если `DoWork` вызывается на D с помощью переменной типа D, вызывается новый `DoWork`. Если переменная типа C, B или A используется для доступа к экземпляру D, вызов `DoWork` будет выполняться по правилам виртуального наследования и направлять эти вызовы на реализацию `DoWork` на классе C.  
  
### <a name="accessing-base-class-virtual-members-from-derived-classes"></a>Доступ к виртуальным членам базового класса из производных классов  
 Производный класс, который заменил или переопределил метод или свойство, может получить доступ к методу или свойству на базовом классе с помощью ключевого слова `base`. Примером является следующий код:  
  
 [!code-csharp[csProgGuideInheritance#26](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#26)]  
  
 Дополнительные сведения см. в разделе [base](../../language-reference/keywords/base.md).  
  
> [!NOTE]
> Рекомендуется, чтобы виртуальные члены использовали `base` для вызова реализации базового класса этого члена в их собственной реализации. Разрешение поведения базового класса позволяет производному классу концентрироваться на реализации поведения, характерного для производного класса. Если реализация базового класса не вызывается, производный класс сопоставляет свое поведение с поведением базового класса по своему усмотрению.  
  
## <a name="in-this-section"></a>В этом разделе  
  
- [Управление версиями с помощью ключевых слов Override и New](./versioning-with-the-override-and-new-keywords.md)  
  
- [Использование ключевых слов Override и New](./knowing-when-to-use-override-and-new-keywords.md)  
  
- [Практическое руководство. Переопределение метода ToString](./how-to-override-the-tostring-method.md)
  
## <a name="see-also"></a>См. также

- [Руководство по программированию на C#](../index.md)
- [Наследование](./inheritance.md)
- [Абстрактные и запечатанные классы и члены классов](./abstract-and-sealed-classes-and-class-members.md)
- [Методы](./methods.md)
- [События](../events/index.md)
- [Свойства](./properties.md)
- [Индексаторы](../indexers/index.md)
- [Типы](../types/index.md)
