---
title: Руководство по программированию на C#. Полиморфизм
description: Узнайте о полиморфизме, ключевом понятии в объектно-ориентированных языках программирования, таких как C#, которое описывает связь между базовым и производным классами.
ms.date: 02/08/2020
helpviewer_keywords:
- C# language, polymorphism
- polymorphism [C#]
ms.assetid: 086af969-29a5-4ce8-a993-0b7d53839dab
ms.openlocfilehash: 59b5f5d2d5a8f274845607aeca370c316670bd68
ms.sourcegitcommit: 40de8df14289e1e05b40d6e5c1daabd3c286d70c
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/22/2020
ms.locfileid: "86925453"
---
# <a name="polymorphism-c-programming-guide"></a><span data-ttu-id="1d415-103">Полиморфизм (Руководство по программированию на C#)</span><span class="sxs-lookup"><span data-stu-id="1d415-103">Polymorphism (C# Programming Guide)</span></span>

<span data-ttu-id="1d415-104">Полиморфизм часто называется третьим столпом объектно-ориентированного программирования после инкапсуляции и наследования.</span><span class="sxs-lookup"><span data-stu-id="1d415-104">Polymorphism is often referred to as the third pillar of object-oriented programming, after encapsulation and inheritance.</span></span> <span data-ttu-id="1d415-105">Полиморфизм — слово греческого происхождения, означающее "многообразие форм" и имеющее несколько аспектов.</span><span class="sxs-lookup"><span data-stu-id="1d415-105">Polymorphism is a Greek word that means "many-shaped" and it has two distinct aspects:</span></span>
  
- <span data-ttu-id="1d415-106">Во время выполнения объекты производного класса могут обрабатываться как объекты базового класса в таких местах, как параметры метода и коллекции или массивы.</span><span class="sxs-lookup"><span data-stu-id="1d415-106">At run time, objects of a derived class may be treated as objects of a base class in places such as method parameters and collections or arrays.</span></span> <span data-ttu-id="1d415-107">Когда возникает полиморфизм, объявленный тип объекта перестает соответствовать своему типу во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="1d415-107">When this polymorphism occurs, the object's declared type is no longer identical to its run-time type.</span></span>
- <span data-ttu-id="1d415-108">Базовые классы могут определять и реализовывать [виртуальные](../../language-reference/keywords/virtual.md) *методы*, а производные классы — [переопределять](../../language-reference/keywords/override.md) их, т. е. предоставлять свое собственное определение и реализацию.</span><span class="sxs-lookup"><span data-stu-id="1d415-108">Base classes may define and implement [virtual](../../language-reference/keywords/virtual.md) *methods*, and derived classes can [override](../../language-reference/keywords/override.md) them, which means they provide their own definition and implementation.</span></span> <span data-ttu-id="1d415-109">Во время выполнения, когда клиент вызывает метод, CLR выполняет поиск типа объекта во время выполнения и вызывает перезапись виртуального метода.</span><span class="sxs-lookup"><span data-stu-id="1d415-109">At run-time, when client code calls the method, the CLR looks up the run-time type of the object, and invokes that override of the virtual method.</span></span> <span data-ttu-id="1d415-110">В исходном коде можно вызвать метод в базовом классе и обеспечить выполнение версии метода, относящейся к производному классу.</span><span class="sxs-lookup"><span data-stu-id="1d415-110">In your source code you can call a method on a base class, and cause a derived class's version of the method to be executed.</span></span>

<span data-ttu-id="1d415-111">Виртуальные методы позволяют работать с группами связанных объектов универсальным способом.</span><span class="sxs-lookup"><span data-stu-id="1d415-111">Virtual methods enable you to work with groups of related objects in a uniform way.</span></span> <span data-ttu-id="1d415-112">Представим, например, приложение, позволяющее пользователю создавать различные виды фигур на поверхности для рисования.</span><span class="sxs-lookup"><span data-stu-id="1d415-112">For example, suppose you have a drawing application that enables a user to create various kinds of shapes on a drawing surface.</span></span> <span data-ttu-id="1d415-113">Во время компиляции вы еще не знаете, какие именно виды фигур создаст пользователь.</span><span class="sxs-lookup"><span data-stu-id="1d415-113">You do not know at compile time which specific types of shapes the user will create.</span></span> <span data-ttu-id="1d415-114">При этом приложению необходимо отслеживать все различные типы создаваемых фигур и обновлять их в ответ на движения мыши.</span><span class="sxs-lookup"><span data-stu-id="1d415-114">However, the application has to keep track of all the various types of shapes that are created, and it has to update them in response to user mouse actions.</span></span> <span data-ttu-id="1d415-115">Для решения этой проблемы можно использовать полиморфизм, выполнив два основных действия.</span><span class="sxs-lookup"><span data-stu-id="1d415-115">You can use polymorphism to solve this problem in two basic steps:</span></span>

1. <span data-ttu-id="1d415-116">Создать иерархию классов, в которой каждый отдельный класс фигур является производным из общего базового класса.</span><span class="sxs-lookup"><span data-stu-id="1d415-116">Create a class hierarchy in which each specific shape class derives from a common base class.</span></span>
1. <span data-ttu-id="1d415-117">Применить виртуальный метод для вызова соответствующего метода на любой производный класс через единый вызов в метод базового класса.</span><span class="sxs-lookup"><span data-stu-id="1d415-117">Use a virtual method to invoke the appropriate method on any derived class through a single call to the base class method.</span></span>

<span data-ttu-id="1d415-118">Для начала создайте базовый класс с именем `Shape` и производные классы, например `Rectangle`, `Circle` и `Triangle`.</span><span class="sxs-lookup"><span data-stu-id="1d415-118">First, create a base class called `Shape`, and derived classes such as `Rectangle`, `Circle`, and `Triangle`.</span></span> <span data-ttu-id="1d415-119">Присвойте классу `Shape` виртуальный метод с именем `Draw` и переопределите его в каждом производном классе для рисования конкретной фигуры, которую этот класс представляет.</span><span class="sxs-lookup"><span data-stu-id="1d415-119">Give the `Shape` class a virtual method called `Draw`, and override it in each derived class to draw the particular shape that the class represents.</span></span> <span data-ttu-id="1d415-120">Создайте объект `List<Shape>` и добавьте в него `Circle`, `Triangle`и `Rectangle`.</span><span class="sxs-lookup"><span data-stu-id="1d415-120">Create a `List<Shape>` object and add a `Circle`, `Triangle`, and `Rectangle` to it.</span></span>

[!code-csharp[Polymorphism overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#PolymorphismOverview)]

<span data-ttu-id="1d415-121">Для обновления поверхности рисования используйте цикл [foreach](../../language-reference/keywords/foreach-in.md), чтобы выполнить итерацию списка и вызвать метод `Draw` на каждом объекте `Shape` в списке.</span><span class="sxs-lookup"><span data-stu-id="1d415-121">To update the drawing surface, use a [foreach](../../language-reference/keywords/foreach-in.md) loop to iterate through the list and call the `Draw` method on each `Shape` object in the list.</span></span> <span data-ttu-id="1d415-122">Несмотря на то, что каждый объект в списке имеет объявленный тип `Shape`, будет вызван тип времени выполнения (переопределенная версия метода в каждом производном классе).</span><span class="sxs-lookup"><span data-stu-id="1d415-122">Even though each object in the list has a declared type of `Shape`, it's the run-time type (the overridden version of the method in each derived class) that will be invoked.</span></span>

[!code-csharp[Polymorphism overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#UsePolymorphism)]

<span data-ttu-id="1d415-123">В C# каждый тип является полиморфным, так как все типы, включая пользовательские, наследуют <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="1d415-123">In C#, every type is polymorphic because all types, including user-defined types, inherit from <xref:System.Object>.</span></span>  

## <a name="polymorphism-overview"></a><span data-ttu-id="1d415-124">Обзор полиморфизма</span><span class="sxs-lookup"><span data-stu-id="1d415-124">Polymorphism overview</span></span>

### <a name="virtual-members"></a><span data-ttu-id="1d415-125">Виртуальные члены</span><span class="sxs-lookup"><span data-stu-id="1d415-125">Virtual members</span></span>

<span data-ttu-id="1d415-126">Если производный класс наследуется от базового, он получает все его методы, поля, свойства и события.</span><span class="sxs-lookup"><span data-stu-id="1d415-126">When a derived class inherits from a base class, it gains all the methods, fields, properties, and events of the base class.</span></span> <span data-ttu-id="1d415-127">Конструктор производного класса может выбирать различные варианты поведения виртуальных методов:</span><span class="sxs-lookup"><span data-stu-id="1d415-127">The designer of the derived class has different choices for the behavior of virtual methods:</span></span>

- <span data-ttu-id="1d415-128">Производный класс может переопределять виртуальные члены в базовом классе, определяя новое поведение.</span><span class="sxs-lookup"><span data-stu-id="1d415-128">The derived class may override virtual members in the base class, defining new behavior.</span></span>
- <span data-ttu-id="1d415-129">Производный класс наследует ближайший метод базового класса без его переопределения, сохраняя существующее поведение, но позволяя дальнейшим производным классам переопределять метод.</span><span class="sxs-lookup"><span data-stu-id="1d415-129">The derived class inherit the closest base class method without overriding it, preserving the existing behavior but enabling further derived classes to override the method.</span></span>
- <span data-ttu-id="1d415-130">Производный класс может определить новую, невиртуальную реализацию тех членов, которые скрывают реализации базового класса.</span><span class="sxs-lookup"><span data-stu-id="1d415-130">The derived class may define new non-virtual implementation of those members that hide the base class implementations.</span></span>

<span data-ttu-id="1d415-131">Производный класс может переопределить член базового класса, только если последний будет объявлен [виртуальным](../../language-reference/keywords/virtual.md) или [абстрактным](../../language-reference/keywords/abstract.md).</span><span class="sxs-lookup"><span data-stu-id="1d415-131">A derived class can override a base class member only if the base class member is declared as [virtual](../../language-reference/keywords/virtual.md) or [abstract](../../language-reference/keywords/abstract.md).</span></span> <span data-ttu-id="1d415-132">Производный член должен использовать ключевое слово [override](../../language-reference/keywords/override.md), указывающее, что метод предназначен для участия в виртуальном вызове.</span><span class="sxs-lookup"><span data-stu-id="1d415-132">The derived member must use the [override](../../language-reference/keywords/override.md) keyword to explicitly indicate that the method is intended to participate in virtual invocation.</span></span> <span data-ttu-id="1d415-133">Примером является следующий код:</span><span class="sxs-lookup"><span data-stu-id="1d415-133">The following code provides an example:</span></span>

[!code-csharp[Virtual overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#VirtualMethods)]

<span data-ttu-id="1d415-134">Поля не могут быть виртуальными. Виртуальными могут быть только методы, свойства, события и индексаторы.</span><span class="sxs-lookup"><span data-stu-id="1d415-134">Fields cannot be virtual; only methods, properties, events, and indexers can be virtual.</span></span> <span data-ttu-id="1d415-135">Когда производный класс переопределяет виртуальный член, он вызывается даже в то случае, если доступ к экземпляру этого класса осуществляется в качестве экземпляра базового класса.</span><span class="sxs-lookup"><span data-stu-id="1d415-135">When a derived class overrides a virtual member, that member is called even when an instance of that class is being accessed as an instance of the base class.</span></span> <span data-ttu-id="1d415-136">Примером является следующий код:</span><span class="sxs-lookup"><span data-stu-id="1d415-136">The following code provides an example:</span></span>

[!code-csharp[Virtual overview example](~/samples/snippets/csharp/objectoriented/Inheritance.cs#SnippetTestVirtualMethods)]

<span data-ttu-id="1d415-137">Виртуальные методы и свойства позволяют производным классам расширять базовый класс без необходимости использовать реализацию базового класса метода.</span><span class="sxs-lookup"><span data-stu-id="1d415-137">Virtual methods and properties enable derived classes to extend a base class without needing to use the base class implementation of a method.</span></span> <span data-ttu-id="1d415-138">Дополнительные сведения см. в разделе [Управление версиями с помощью ключевых слов Override и New](./versioning-with-the-override-and-new-keywords.md).</span><span class="sxs-lookup"><span data-stu-id="1d415-138">For more information, see [Versioning with the Override and New Keywords](./versioning-with-the-override-and-new-keywords.md).</span></span> <span data-ttu-id="1d415-139">Еще одну возможность определения метода или набора методов, реализация которых оставлена производным классам, дает интерфейс.</span><span class="sxs-lookup"><span data-stu-id="1d415-139">An interface provides another way to define a method or set of methods whose implementation is left to derived classes.</span></span> <span data-ttu-id="1d415-140">Дополнительные сведения см. в разделе [Интерфейсы](../interfaces/index.md).</span><span class="sxs-lookup"><span data-stu-id="1d415-140">For more information, see [Interfaces](../interfaces/index.md).</span></span>

### <a name="hide-base-class-members-with-new-members"></a><span data-ttu-id="1d415-141">Сокрытие членов базового класса новыми членами</span><span class="sxs-lookup"><span data-stu-id="1d415-141">Hide base class members with new members</span></span>

<span data-ttu-id="1d415-142">Если вы хотите, чтобы производный класс имел член с тем же именем, что и член в базовом классе, можно использовать ключевое слово [new](../../language-reference/keywords/new-modifier.md), чтобы скрыть член базового класса.</span><span class="sxs-lookup"><span data-stu-id="1d415-142">If you want your derived class to have a member with the same name as a member in a base class, you can use the [new](../../language-reference/keywords/new-modifier.md) keyword to hide the base class member.</span></span> <span data-ttu-id="1d415-143">Ключевое слово `new` вставляется перед типом возвращаемого значения замещаемого члена класса.</span><span class="sxs-lookup"><span data-stu-id="1d415-143">The `new` keyword is put before the return type of a class member that is being replaced.</span></span> <span data-ttu-id="1d415-144">Примером является следующий код:</span><span class="sxs-lookup"><span data-stu-id="1d415-144">The following code provides an example:</span></span>

[!code-csharp[New method overview example](~/samples/snippets/csharp/objectoriented/Inheritance.cs#NewMethods)]

<span data-ttu-id="1d415-145">Доступ к скрытым членам базового класса можно осуществлять из клиентского кода приведением экземпляра производного класса к экземпляру базового класса.</span><span class="sxs-lookup"><span data-stu-id="1d415-145">Hidden base class members may be accessed from client code by casting the instance of the derived class to an instance of the base class.</span></span> <span data-ttu-id="1d415-146">Пример:</span><span class="sxs-lookup"><span data-stu-id="1d415-146">For example:</span></span>

[!code-csharp[New method overview usage](~/samples/snippets/csharp/objectoriented/Inheritance.cs#UseNewMethods)]

### <a name="prevent-derived-classes-from-overriding-virtual-members"></a><span data-ttu-id="1d415-147">Защита виртуальных членов от переопределения производными классами</span><span class="sxs-lookup"><span data-stu-id="1d415-147">Prevent derived classes from overriding virtual members</span></span>  

<span data-ttu-id="1d415-148">Виртуальные члены остаются виртуальными независимо от количества классов, объявленных между виртуальным членом и классом, который объявил его изначально.</span><span class="sxs-lookup"><span data-stu-id="1d415-148">Virtual members remain virtual, regardless of how many classes have been declared between the virtual member and the class that originally declared it.</span></span> <span data-ttu-id="1d415-149">Если класс `A` объявляет виртуальный член, класс `B` является производным от класса `A`, а класс `C` — от класса `B`, то класс `C` наследует виртуальный член и может переопределить его независимо от того, объявляет ли класс `B` переопределение этого члена.</span><span class="sxs-lookup"><span data-stu-id="1d415-149">If class `A` declares a virtual member, and class `B` derives from `A`, and class `C` derives from `B`, class `C` inherits the virtual member, and may override it, regardless of whether class `B` declared an override for that member.</span></span> <span data-ttu-id="1d415-150">Примером является следующий код:</span><span class="sxs-lookup"><span data-stu-id="1d415-150">The following code provides an example:</span></span>

[!code-csharp[Basic hierarchy](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#FirstHierarchy)]

<span data-ttu-id="1d415-151">Производный класс может остановить виртуальное наследование, объявив переопределение как [запечатанное](../../language-reference/keywords/sealed.md).</span><span class="sxs-lookup"><span data-stu-id="1d415-151">A derived class can stop virtual inheritance by declaring an override as [sealed](../../language-reference/keywords/sealed.md).</span></span> <span data-ttu-id="1d415-152">Для остановки наследования в объявление члена класса нужно вставить ключевое слово `sealed` перед ключевым словом `override`.</span><span class="sxs-lookup"><span data-stu-id="1d415-152">Stopping inheritance requires putting the `sealed` keyword before the `override` keyword in the class member declaration.</span></span> <span data-ttu-id="1d415-153">Примером является следующий код:</span><span class="sxs-lookup"><span data-stu-id="1d415-153">The following code provides an example:</span></span>

[!code-csharp[A sealed overridden member](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#SealedOverride)]

<span data-ttu-id="1d415-154">В предыдущем примере метод `DoWork` более не является виртуальным ни для одного класса, производного от класса `C`.</span><span class="sxs-lookup"><span data-stu-id="1d415-154">In the previous example, the method `DoWork` is no longer virtual to any class derived from `C`.</span></span> <span data-ttu-id="1d415-155">Он по-прежнему является виртуальным для экземпляров класса `C`, даже если они приводятся к типу `B` или типу `A`.</span><span class="sxs-lookup"><span data-stu-id="1d415-155">It's still virtual for instances of `C`, even if they're cast to type `B` or type `A`.</span></span> <span data-ttu-id="1d415-156">Запечатанные методы можно заменить производными классами с помощью ключевого слова `new`, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="1d415-156">Sealed methods can be replaced by derived classes by using the `new` keyword, as the following example shows:</span></span>

[!code-csharp[New method declaration](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#NewDeclaration)]

<span data-ttu-id="1d415-157">В этом случае, если `DoWork` вызывается для `D` с помощью переменной типа `D`, вызывается новый `DoWork`.</span><span class="sxs-lookup"><span data-stu-id="1d415-157">In this case, if `DoWork` is called on `D` using a variable of type `D`, the new `DoWork` is called.</span></span> <span data-ttu-id="1d415-158">Если переменная типа `C`, `B` или `A` используется для доступа к экземпляру `D`, вызов `DoWork` будет выполняться по правилам виртуального наследования и направлять эти вызовы в реализацию `DoWork` в классе `C`.</span><span class="sxs-lookup"><span data-stu-id="1d415-158">If a variable of type `C`, `B`, or `A` is used to access an instance of `D`, a call to `DoWork` will follow the rules of virtual inheritance, routing those calls to the implementation of `DoWork` on class `C`.</span></span>

### <a name="access-base-class-virtual-members-from-derived-classes"></a><span data-ttu-id="1d415-159">Доступ к виртуальным членам базового класса из производных классов</span><span class="sxs-lookup"><span data-stu-id="1d415-159">Access base class virtual members from derived classes</span></span>

<span data-ttu-id="1d415-160">Производный класс, который заменил или переопределил метод или свойство, может получить доступ к методу или свойству на базовом классе с помощью ключевого слова `base`.</span><span class="sxs-lookup"><span data-stu-id="1d415-160">A derived class that has replaced or overridden a method or property can still access the method or property on the base class using the `base` keyword.</span></span> <span data-ttu-id="1d415-161">Примером является следующий код:</span><span class="sxs-lookup"><span data-stu-id="1d415-161">The following code provides an example:</span></span>

```csharp
public class Base
{
    public virtual void DoWork() {/*...*/ }
}
public class Derived : Base
{
    public override void DoWork()
    {
        //Perform Derived's work here
        //...
        // Call DoWork on base class
        base.DoWork();
    }
}
```

<span data-ttu-id="1d415-162">Дополнительные сведения см. в разделе [base](../../language-reference/keywords/base.md).</span><span class="sxs-lookup"><span data-stu-id="1d415-162">For more information, see [base](../../language-reference/keywords/base.md).</span></span>

> [!NOTE]
> <span data-ttu-id="1d415-163">Рекомендуется, чтобы виртуальные члены использовали `base` для вызова реализации базового класса этого члена в их собственной реализации.</span><span class="sxs-lookup"><span data-stu-id="1d415-163">It is recommended that virtual members use `base` to call the base class implementation of that member in their own implementation.</span></span> <span data-ttu-id="1d415-164">Разрешение поведения базового класса позволяет производному классу концентрироваться на реализации поведения, характерного для производного класса.</span><span class="sxs-lookup"><span data-stu-id="1d415-164">Letting the base class behavior occur enables the derived class to concentrate on implementing behavior specific to the derived class.</span></span> <span data-ttu-id="1d415-165">Если реализация базового класса не вызывается, производный класс сопоставляет свое поведение с поведением базового класса по своему усмотрению.</span><span class="sxs-lookup"><span data-stu-id="1d415-165">If the base class implementation is not called, it is up to the derived class to make their behavior compatible with the behavior of the base class.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="1d415-166">Содержание раздела</span><span class="sxs-lookup"><span data-stu-id="1d415-166">In this section</span></span>

- [<span data-ttu-id="1d415-167">Управление версиями с помощью ключевых слов Override и New</span><span class="sxs-lookup"><span data-stu-id="1d415-167">Versioning with the Override and New Keywords</span></span>](./versioning-with-the-override-and-new-keywords.md)
- [<span data-ttu-id="1d415-168">Использование ключевых слов Override и New</span><span class="sxs-lookup"><span data-stu-id="1d415-168">Knowing When to Use Override and New Keywords</span></span>](./knowing-when-to-use-override-and-new-keywords.md)
- [<span data-ttu-id="1d415-169">Практическое руководство. Переопределение метода ToString</span><span class="sxs-lookup"><span data-stu-id="1d415-169">How to override the ToString method</span></span>](./how-to-override-the-tostring-method.md)

## <a name="see-also"></a><span data-ttu-id="1d415-170">См. также</span><span class="sxs-lookup"><span data-stu-id="1d415-170">See also</span></span>

- [<span data-ttu-id="1d415-171">Руководство по программированию на C#</span><span class="sxs-lookup"><span data-stu-id="1d415-171">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="1d415-172">Наследование</span><span class="sxs-lookup"><span data-stu-id="1d415-172">Inheritance</span></span>](./inheritance.md)
- [<span data-ttu-id="1d415-173">Абстрактные и запечатанные классы и члены классов</span><span class="sxs-lookup"><span data-stu-id="1d415-173">Abstract and Sealed Classes and Class Members</span></span>](./abstract-and-sealed-classes-and-class-members.md)
- [<span data-ttu-id="1d415-174">Методы</span><span class="sxs-lookup"><span data-stu-id="1d415-174">Methods</span></span>](./methods.md)
- [<span data-ttu-id="1d415-175">События</span><span class="sxs-lookup"><span data-stu-id="1d415-175">Events</span></span>](../events/index.md)
- [<span data-ttu-id="1d415-176">Свойства</span><span class="sxs-lookup"><span data-stu-id="1d415-176">Properties</span></span>](./properties.md)
- [<span data-ttu-id="1d415-177">Индексаторы</span><span class="sxs-lookup"><span data-stu-id="1d415-177">Indexers</span></span>](../indexers/index.md)
- [<span data-ttu-id="1d415-178">Типы</span><span class="sxs-lookup"><span data-stu-id="1d415-178">Types</span></span>](../types/index.md)
