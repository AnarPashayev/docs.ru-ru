---
title: Руководство по программированию на C#. Полиморфизм
ms.custom: seodec18
ms.date: 07/20/2015
helpviewer_keywords:
- C# language, polymorphism
- polymorphism [C#]
ms.assetid: 086af969-29a5-4ce8-a993-0b7d53839dab
ms.openlocfilehash: be075c358d9ca2c36b6d173fca983c16f6b0d78c
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/12/2019
ms.locfileid: "73970342"
---
# <a name="polymorphism-c-programming-guide"></a><span data-ttu-id="67c5f-102">Полиморфизм (Руководство по программированию на C#)</span><span class="sxs-lookup"><span data-stu-id="67c5f-102">Polymorphism (C# Programming Guide)</span></span>
<span data-ttu-id="67c5f-103">Полиморфизм часто называется третьим столпом объектно-ориентированного программирования после инкапсуляции и наследования.</span><span class="sxs-lookup"><span data-stu-id="67c5f-103">Polymorphism is often referred to as the third pillar of object-oriented programming, after encapsulation and inheritance.</span></span> <span data-ttu-id="67c5f-104">Полиморфизм — слово греческого происхождения, означающее "многообразие форм" и имеющее несколько аспектов.</span><span class="sxs-lookup"><span data-stu-id="67c5f-104">Polymorphism is a Greek word that means "many-shaped" and it has two distinct aspects:</span></span>  
  
- <span data-ttu-id="67c5f-105">Во время выполнения объекты производного класса могут обрабатываться как объекты базового класса в таких местах, как параметры метода и коллекции или массивы.</span><span class="sxs-lookup"><span data-stu-id="67c5f-105">At run time, objects of a derived class may be treated as objects of a base class in places such as method parameters and collections or arrays.</span></span> <span data-ttu-id="67c5f-106">Когда это происходит, объявленный тип объекта перестает соответствовать своему типу во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="67c5f-106">When this occurs, the object's declared type is no longer identical to its run-time type.</span></span>  
  
- <span data-ttu-id="67c5f-107">Базовые классы могут определять и реализовывать [виртуальные](../../language-reference/keywords/virtual.md) *методы*, а производные классы — [переопределять](../../language-reference/keywords/override.md) их, т. е. предоставлять свое собственное определение и реализацию.</span><span class="sxs-lookup"><span data-stu-id="67c5f-107">Base classes may define and implement [virtual](../../language-reference/keywords/virtual.md) *methods*, and derived classes can [override](../../language-reference/keywords/override.md) them, which means they provide their own definition and implementation.</span></span> <span data-ttu-id="67c5f-108">Во время выполнения, когда клиент вызывает метод, CLR выполняет поиск типа объекта во время выполнения и вызывает перезапись виртуального метода.</span><span class="sxs-lookup"><span data-stu-id="67c5f-108">At run-time, when client code calls the method, the CLR looks up the run-time type of the object, and invokes that override of the virtual method.</span></span> <span data-ttu-id="67c5f-109">Таким образом, в исходном коде можно вызвать метод на базовом классе и привести версию производного класса метода, который необходимо выполнить.</span><span class="sxs-lookup"><span data-stu-id="67c5f-109">Thus in your source code you can call a method on a base class, and cause a derived class's version of the method to be executed.</span></span>  
  
 <span data-ttu-id="67c5f-110">Виртуальные методы позволяют работать с группами связанных объектов универсальным способом.</span><span class="sxs-lookup"><span data-stu-id="67c5f-110">Virtual methods enable you to work with groups of related objects in a uniform way.</span></span> <span data-ttu-id="67c5f-111">Представим, например, приложение, позволяющее пользователю создавать различные виды фигур на поверхности для рисования.</span><span class="sxs-lookup"><span data-stu-id="67c5f-111">For example, suppose you have a drawing application that enables a user to create various kinds of shapes on a drawing surface.</span></span> <span data-ttu-id="67c5f-112">Во время компиляции вы еще не знаете, какие именно виды фигур создаст пользователь.</span><span class="sxs-lookup"><span data-stu-id="67c5f-112">You do not know at compile time which specific types of shapes the user will create.</span></span> <span data-ttu-id="67c5f-113">При этом приложению необходимо отслеживать все различные типы создаваемых фигур и обновлять их в ответ на движения мыши.</span><span class="sxs-lookup"><span data-stu-id="67c5f-113">However, the application has to keep track of all the various types of shapes that are created, and it has to update them in response to user mouse actions.</span></span> <span data-ttu-id="67c5f-114">Для решения этой проблемы можно использовать полиморфизм, выполнив два основных действия.</span><span class="sxs-lookup"><span data-stu-id="67c5f-114">You can use polymorphism to solve this problem in two basic steps:</span></span>  
  
1. <span data-ttu-id="67c5f-115">Создать иерархию классов, в которой каждый отдельный класс фигур является производным из общего базового класса.</span><span class="sxs-lookup"><span data-stu-id="67c5f-115">Create a class hierarchy in which each specific shape class derives from a common base class.</span></span>  
  
2. <span data-ttu-id="67c5f-116">Применить виртуальный метод для вызова соответствующего метода на любой производный класс через единый вызов в метод базового класса.</span><span class="sxs-lookup"><span data-stu-id="67c5f-116">Use a virtual method to invoke the appropriate method on any derived class through a single call to the base class method.</span></span>  
  
 <span data-ttu-id="67c5f-117">Для начала создайте базовый класс с именем `Shape` и производные классы, например `Rectangle`, `Circle` и `Triangle`.</span><span class="sxs-lookup"><span data-stu-id="67c5f-117">First, create a base class called `Shape`, and derived classes such as `Rectangle`, `Circle`, and `Triangle`.</span></span> <span data-ttu-id="67c5f-118">Присвойте классу `Shape` виртуальный метод с именем `Draw` и переопределите его в каждом производном классе для рисования конкретной фигуры, которую этот класс представляет.</span><span class="sxs-lookup"><span data-stu-id="67c5f-118">Give the `Shape` class a virtual method called `Draw`, and override it in each derived class to draw the particular shape that the class represents.</span></span> <span data-ttu-id="67c5f-119">Создайте объект `List<Shape>` и добавьте в него круг, треугольник и прямоугольник.</span><span class="sxs-lookup"><span data-stu-id="67c5f-119">Create a `List<Shape>` object and add a Circle, Triangle and Rectangle to it.</span></span> <span data-ttu-id="67c5f-120">Для обновления поверхности рисования используйте цикл [foreach](../../language-reference/keywords/foreach-in.md), чтобы выполнить итерацию списка и вызвать метод `Draw` на каждом объекте `Shape` в списке.</span><span class="sxs-lookup"><span data-stu-id="67c5f-120">To update the drawing surface, use a [foreach](../../language-reference/keywords/foreach-in.md) loop to iterate through the list and call the `Draw` method on each `Shape` object in the list.</span></span> <span data-ttu-id="67c5f-121">Несмотря на то, что каждый объект в списке имеет объявленный тип `Shape`, вызывать будет тип во время выполнения (переопределенная версия метода в каждом производном классе).</span><span class="sxs-lookup"><span data-stu-id="67c5f-121">Even though each object in the list has a declared type of `Shape`, it is the run-time type (the overridden version of the method in each derived class) that will be invoked.</span></span>  
  
 [!code-csharp[csProgGuideInheritance#50](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#50)]  
  
 <span data-ttu-id="67c5f-122">В C# каждый тип является полиморфным, так как все типы, включая пользовательские, наследуют <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="67c5f-122">In C#, every type is polymorphic because all types, including user-defined types, inherit from <xref:System.Object>.</span></span>  
  
## <a name="polymorphism-overview"></a><span data-ttu-id="67c5f-123">Обзор полиморфизма</span><span class="sxs-lookup"><span data-stu-id="67c5f-123">Polymorphism Overview</span></span>  
  
### <a name="virtual-members"></a><span data-ttu-id="67c5f-124">Виртуальные члены</span><span class="sxs-lookup"><span data-stu-id="67c5f-124">Virtual Members</span></span>  
 <span data-ttu-id="67c5f-125">Если производный класс наследуется из базового, он получает все методы, поля, свойства и события базового класса.</span><span class="sxs-lookup"><span data-stu-id="67c5f-125">When a derived class inherits from a base class, it gains all the methods, fields, properties and events of the base class.</span></span> <span data-ttu-id="67c5f-126">Разработчик производного класса может выбрать следующее:</span><span class="sxs-lookup"><span data-stu-id="67c5f-126">The designer of the derived class can choose whether to</span></span>  
  
- <span data-ttu-id="67c5f-127">переопределение виртуальных членов в базовом классе;</span><span class="sxs-lookup"><span data-stu-id="67c5f-127">override virtual members in the base class,</span></span>  
  
- <span data-ttu-id="67c5f-128">наследование метода ближайшего базового класса без переопределения;</span><span class="sxs-lookup"><span data-stu-id="67c5f-128">inherit the closest base class method without overriding it</span></span>  
  
- <span data-ttu-id="67c5f-129">определение новой, невиртуальной реализации тех членов, которые скрывают реализации базового класса.</span><span class="sxs-lookup"><span data-stu-id="67c5f-129">define new non-virtual implementation of those members that hide the base class implementations</span></span>  
  
 <span data-ttu-id="67c5f-130">Производный класс может переопределить член базового класса, только если последний будет объявлен [виртуальным](../../language-reference/keywords/virtual.md) или [абстрактным](../../language-reference/keywords/abstract.md).</span><span class="sxs-lookup"><span data-stu-id="67c5f-130">A derived class can override a base class member only if the base class member is declared as [virtual](../../language-reference/keywords/virtual.md) or [abstract](../../language-reference/keywords/abstract.md).</span></span> <span data-ttu-id="67c5f-131">Производный член должен использовать ключевое слово [override](../../language-reference/keywords/override.md), указывающее, что метод предназначен для участия в виртуальном вызове.</span><span class="sxs-lookup"><span data-stu-id="67c5f-131">The derived member must use the [override](../../language-reference/keywords/override.md) keyword to explicitly indicate that the method is intended to participate in virtual invocation.</span></span> <span data-ttu-id="67c5f-132">Примером является следующий код:</span><span class="sxs-lookup"><span data-stu-id="67c5f-132">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#20](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#20)]  
  
 <span data-ttu-id="67c5f-133">Поля не могут быть виртуальными. Виртуальными могут быть только методы, свойства, события и индексаторы.</span><span class="sxs-lookup"><span data-stu-id="67c5f-133">Fields cannot be virtual; only methods, properties, events and indexers can be virtual.</span></span> <span data-ttu-id="67c5f-134">Когда производный класс переопределяет виртуальный член, он вызывается даже в то случае, если доступ к экземпляру этого класса осуществляется в качестве экземпляра базового класса.</span><span class="sxs-lookup"><span data-stu-id="67c5f-134">When a derived class overrides a virtual member, that member is called even when an instance of that class is being accessed as an instance of the base class.</span></span> <span data-ttu-id="67c5f-135">Примером является следующий код:</span><span class="sxs-lookup"><span data-stu-id="67c5f-135">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#21](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#21)]  
  
 <span data-ttu-id="67c5f-136">Виртуальные методы и свойства позволяют производным классам расширять базовый класс без необходимости использовать реализацию базового класса метода.</span><span class="sxs-lookup"><span data-stu-id="67c5f-136">Virtual methods and properties enable derived classes to extend a base class without needing to use the base class implementation of a method.</span></span> <span data-ttu-id="67c5f-137">Дополнительные сведения см. в разделе [Управление версиями с помощью ключевых слов Override и New](./versioning-with-the-override-and-new-keywords.md).</span><span class="sxs-lookup"><span data-stu-id="67c5f-137">For more information, see [Versioning with the Override and New Keywords](./versioning-with-the-override-and-new-keywords.md).</span></span> <span data-ttu-id="67c5f-138">Еще одну возможность определения метода или набора методов, реализация которых оставлена производным классам, дает интерфейс.</span><span class="sxs-lookup"><span data-stu-id="67c5f-138">An interface provides another way to define a method or set of methods whose implementation is left to derived classes.</span></span> <span data-ttu-id="67c5f-139">Дополнительные сведения см. в разделе [Интерфейсы](../interfaces/index.md).</span><span class="sxs-lookup"><span data-stu-id="67c5f-139">For more information, see [Interfaces](../interfaces/index.md).</span></span>  
  
### <a name="hiding-base-class-members-with-new-members"></a><span data-ttu-id="67c5f-140">Сокрытие членов базового класса новыми членами</span><span class="sxs-lookup"><span data-stu-id="67c5f-140">Hiding Base Class Members with New Members</span></span>  
 <span data-ttu-id="67c5f-141">Если вам нужно, чтобы производный член имел такое же имя, как и член в базовом классе, но вы не хотите, чтобы он участвовал в виртуальном вызове, используйте ключевое слово [new](../../language-reference/keywords/new-modifier.md).</span><span class="sxs-lookup"><span data-stu-id="67c5f-141">If you want your derived member to have the same name as a member in a base class, but you do not want it to participate in virtual invocation, you can use the [new](../../language-reference/keywords/new-modifier.md) keyword.</span></span> <span data-ttu-id="67c5f-142">Ключевое слово `new` вставляется перед типом возвращаемого значения замещаемого члена класса.</span><span class="sxs-lookup"><span data-stu-id="67c5f-142">The `new` keyword is put before the return type of a class member that is being replaced.</span></span> <span data-ttu-id="67c5f-143">Примером является следующий код:</span><span class="sxs-lookup"><span data-stu-id="67c5f-143">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#18](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#18)]  
  
 <span data-ttu-id="67c5f-144">Доступ к скрытым членам базового класса можно по-прежнему осуществлять из клиентского кода приведением экземпляра производного класса к экземпляру базового класса.</span><span class="sxs-lookup"><span data-stu-id="67c5f-144">Hidden base class members can still be accessed from client code by casting the instance of the derived class to an instance of the base class.</span></span> <span data-ttu-id="67c5f-145">Например:</span><span class="sxs-lookup"><span data-stu-id="67c5f-145">For example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#19](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#19)]  
  
### <a name="preventing-derived-classes-from-overriding-virtual-members"></a><span data-ttu-id="67c5f-146">Защита виртуальных членов от переопределения производными классами</span><span class="sxs-lookup"><span data-stu-id="67c5f-146">Preventing Derived Classes from Overriding Virtual Members</span></span>  
 <span data-ttu-id="67c5f-147">Виртуальные члены остаются виртуальными на неограниченный срок независимо от количества классов, объявленных между виртуальным членом и классом, который объявил его изначально.</span><span class="sxs-lookup"><span data-stu-id="67c5f-147">Virtual members remain virtual indefinitely, regardless of how many classes have been declared between the virtual member and the class that originally declared it.</span></span> <span data-ttu-id="67c5f-148">Если класс А объявляет виртуальный член, класс В производится из класса А, а класс С — из класса В, то класс С наследует виртуальный член и получает возможность переопределить его независимо от того, объявляет ли класс В переопределение этого члена.</span><span class="sxs-lookup"><span data-stu-id="67c5f-148">If class A declares a virtual member, and class B derives from A, and class C derives from B, class C inherits the virtual member, and has the option to override it, regardless of whether class B declared an override for that member.</span></span> <span data-ttu-id="67c5f-149">Примером является следующий код:</span><span class="sxs-lookup"><span data-stu-id="67c5f-149">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#22](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#22)]  
  
 <span data-ttu-id="67c5f-150">Производный класс может остановить виртуальное наследование, объявив переопределение как [запечатанное](../../language-reference/keywords/sealed.md).</span><span class="sxs-lookup"><span data-stu-id="67c5f-150">A derived class can stop virtual inheritance by declaring an override as [sealed](../../language-reference/keywords/sealed.md).</span></span> <span data-ttu-id="67c5f-151">Для этого в объявление члена класса необходимо вставить ключевое слово `sealed` перед ключевым словом `override`.</span><span class="sxs-lookup"><span data-stu-id="67c5f-151">This requires putting the `sealed` keyword before the `override` keyword in the class member declaration.</span></span> <span data-ttu-id="67c5f-152">Примером является следующий код:</span><span class="sxs-lookup"><span data-stu-id="67c5f-152">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#24](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#24)]  
  
 <span data-ttu-id="67c5f-153">В предыдущем примере метод `DoWork` больше не является виртуальным для любого класса, производного от C. Он по-прежнему будет виртуальным для экземпляров C, даже если они будут приведены к типу B или A. Запечатанные методы можно заменить производными классами с помощью ключевого слова `new`, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="67c5f-153">In the previous example, the method `DoWork` is no longer virtual to any class derived from C. It is still virtual for instances of C, even if they are cast to type B or type A. Sealed methods can be replaced by derived classes by using the `new` keyword, as the following example shows:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#25](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#25)]  
  
 <span data-ttu-id="67c5f-154">В этом случае, если `DoWork` вызывается на D с помощью переменной типа D, вызывается новый `DoWork`.</span><span class="sxs-lookup"><span data-stu-id="67c5f-154">In this case, if `DoWork` is called on D using a variable of type D, the new `DoWork` is called.</span></span> <span data-ttu-id="67c5f-155">Если переменная типа C, B или A используется для доступа к экземпляру D, вызов `DoWork` будет выполняться по правилам виртуального наследования и направлять эти вызовы на реализацию `DoWork` на классе C.</span><span class="sxs-lookup"><span data-stu-id="67c5f-155">If a variable of type C, B, or A is used to access an instance of D, a call to `DoWork` will follow the rules of virtual inheritance, routing those calls to the implementation of `DoWork` on class C.</span></span>  
  
### <a name="accessing-base-class-virtual-members-from-derived-classes"></a><span data-ttu-id="67c5f-156">Доступ к виртуальным членам базового класса из производных классов</span><span class="sxs-lookup"><span data-stu-id="67c5f-156">Accessing Base Class Virtual Members from Derived Classes</span></span>  
 <span data-ttu-id="67c5f-157">Производный класс, который заменил или переопределил метод или свойство, может получить доступ к методу или свойству на базовом классе с помощью ключевого слова `base`.</span><span class="sxs-lookup"><span data-stu-id="67c5f-157">A derived class that has replaced or overridden a method or property can still access the method or property on the base class using the `base` keyword.</span></span> <span data-ttu-id="67c5f-158">Примером является следующий код:</span><span class="sxs-lookup"><span data-stu-id="67c5f-158">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#26](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#26)]  
  
 <span data-ttu-id="67c5f-159">Дополнительные сведения см. в разделе [base](../../language-reference/keywords/base.md).</span><span class="sxs-lookup"><span data-stu-id="67c5f-159">For more information, see [base](../../language-reference/keywords/base.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="67c5f-160">Рекомендуется, чтобы виртуальные члены использовали `base` для вызова реализации базового класса этого члена в их собственной реализации.</span><span class="sxs-lookup"><span data-stu-id="67c5f-160">It is recommended that virtual members use `base` to call the base class implementation of that member in their own implementation.</span></span> <span data-ttu-id="67c5f-161">Разрешение поведения базового класса позволяет производному классу концентрироваться на реализации поведения, характерного для производного класса.</span><span class="sxs-lookup"><span data-stu-id="67c5f-161">Letting the base class behavior occur enables the derived class to concentrate on implementing behavior specific to the derived class.</span></span> <span data-ttu-id="67c5f-162">Если реализация базового класса не вызывается, производный класс сопоставляет свое поведение с поведением базового класса по своему усмотрению.</span><span class="sxs-lookup"><span data-stu-id="67c5f-162">If the base class implementation is not called, it is up to the derived class to make their behavior compatible with the behavior of the base class.</span></span>  
  
## <a name="in-this-section"></a><span data-ttu-id="67c5f-163">В этом разделе</span><span class="sxs-lookup"><span data-stu-id="67c5f-163">In This Section</span></span>  
  
- [<span data-ttu-id="67c5f-164">Управление версиями с помощью ключевых слов Override и New</span><span class="sxs-lookup"><span data-stu-id="67c5f-164">Versioning with the Override and New Keywords</span></span>](./versioning-with-the-override-and-new-keywords.md)  
  
- [<span data-ttu-id="67c5f-165">Использование ключевых слов Override и New</span><span class="sxs-lookup"><span data-stu-id="67c5f-165">Knowing When to Use Override and New Keywords</span></span>](./knowing-when-to-use-override-and-new-keywords.md)  
  
- [<span data-ttu-id="67c5f-166">Практическое руководство. Переопределение метода ToString</span><span class="sxs-lookup"><span data-stu-id="67c5f-166">How to override the ToString method</span></span>](./how-to-override-the-tostring-method.md)
  
## <a name="see-also"></a><span data-ttu-id="67c5f-167">См. также</span><span class="sxs-lookup"><span data-stu-id="67c5f-167">See also</span></span>

- [<span data-ttu-id="67c5f-168">Руководство по программированию на C#</span><span class="sxs-lookup"><span data-stu-id="67c5f-168">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="67c5f-169">Наследование</span><span class="sxs-lookup"><span data-stu-id="67c5f-169">Inheritance</span></span>](./inheritance.md)
- [<span data-ttu-id="67c5f-170">Абстрактные и запечатанные классы и члены классов</span><span class="sxs-lookup"><span data-stu-id="67c5f-170">Abstract and Sealed Classes and Class Members</span></span>](./abstract-and-sealed-classes-and-class-members.md)
- [<span data-ttu-id="67c5f-171">Методы</span><span class="sxs-lookup"><span data-stu-id="67c5f-171">Methods</span></span>](./methods.md)
- [<span data-ttu-id="67c5f-172">События</span><span class="sxs-lookup"><span data-stu-id="67c5f-172">Events</span></span>](../events/index.md)
- [<span data-ttu-id="67c5f-173">Свойства</span><span class="sxs-lookup"><span data-stu-id="67c5f-173">Properties</span></span>](./properties.md)
- [<span data-ttu-id="67c5f-174">Индексаторы</span><span class="sxs-lookup"><span data-stu-id="67c5f-174">Indexers</span></span>](../indexers/index.md)
- [<span data-ttu-id="67c5f-175">Типы</span><span class="sxs-lookup"><span data-stu-id="67c5f-175">Types</span></span>](../types/index.md)
