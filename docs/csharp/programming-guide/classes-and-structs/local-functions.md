---
title: Руководство по программированию на C#. Локальные функции
description: Локальные функции в C# — это частные методы, которые вложены в другой член и могут быть вызваны из их содержащего члена.
ms.date: 10/16/2020
helpviewer_keywords:
- local functions [C#]
ms.openlocfilehash: 75accda2e40443073274ece4d8964c13a0945dad
ms.sourcegitcommit: dfcbc096ad7908cd58a5f0aeabd2256f05266bac
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/21/2020
ms.locfileid: "92332904"
---
# <a name="local-functions-c-programming-guide"></a><span data-ttu-id="c848f-103">Локальные функции (руководство по программированию на C#)</span><span class="sxs-lookup"><span data-stu-id="c848f-103">Local functions (C# Programming Guide)</span></span>

<span data-ttu-id="c848f-104">Начиная с версии 7.0 в языке C# поддерживаются *локальные функции* .</span><span class="sxs-lookup"><span data-stu-id="c848f-104">Starting with C# 7.0, C# supports *local functions* .</span></span> <span data-ttu-id="c848f-105">Локальные функции представляют собой частные методы типа, вложенные в другой элемент.</span><span class="sxs-lookup"><span data-stu-id="c848f-105">Local functions are private methods of a type that are nested in another member.</span></span> <span data-ttu-id="c848f-106">Они могут вызываться только из того элемента, в который вложены.</span><span class="sxs-lookup"><span data-stu-id="c848f-106">They can only be called from their containing member.</span></span> <span data-ttu-id="c848f-107">Ниже перечислены элементы, в которых можно объявлять и из которых можно вызывать локальные функции:</span><span class="sxs-lookup"><span data-stu-id="c848f-107">Local functions can be declared in and called from:</span></span>

- <span data-ttu-id="c848f-108">Методы, в частности методы итератора и асинхронные методы</span><span class="sxs-lookup"><span data-stu-id="c848f-108">Methods, especially iterator methods and async methods</span></span>
- <span data-ttu-id="c848f-109">Конструкторы</span><span class="sxs-lookup"><span data-stu-id="c848f-109">Constructors</span></span>
- <span data-ttu-id="c848f-110">Методы доступа свойств</span><span class="sxs-lookup"><span data-stu-id="c848f-110">Property accessors</span></span>
- <span data-ttu-id="c848f-111">Методы доступа событий</span><span class="sxs-lookup"><span data-stu-id="c848f-111">Event accessors</span></span>
- <span data-ttu-id="c848f-112">Анонимные методы</span><span class="sxs-lookup"><span data-stu-id="c848f-112">Anonymous methods</span></span>
- <span data-ttu-id="c848f-113">Лямбда-выражения</span><span class="sxs-lookup"><span data-stu-id="c848f-113">Lambda expressions</span></span>
- <span data-ttu-id="c848f-114">Методы завершения</span><span class="sxs-lookup"><span data-stu-id="c848f-114">Finalizers</span></span>
- <span data-ttu-id="c848f-115">Другие локальные функции</span><span class="sxs-lookup"><span data-stu-id="c848f-115">Other local functions</span></span>

<span data-ttu-id="c848f-116">Тем не менее локальные функции нельзя объявлять внутри элемента, воплощающего выражение.</span><span class="sxs-lookup"><span data-stu-id="c848f-116">However, local functions can't be declared inside an expression-bodied member.</span></span>

> [!NOTE]
> <span data-ttu-id="c848f-117">В некоторых случаях для реализации возможностей, поддерживаемых локальными функциями, также можно использовать лямбда-выражения.</span><span class="sxs-lookup"><span data-stu-id="c848f-117">In some cases, you can use a lambda expression to implement functionality also supported by a local function.</span></span> <span data-ttu-id="c848f-118">Дополнительные сведения см. в разделе [Локальные функции или лямбда-выражения](#local-functions-vs-lambda-expressions).</span><span class="sxs-lookup"><span data-stu-id="c848f-118">For a comparison, see [Local functions vs. lambda expressions](#local-functions-vs-lambda-expressions).</span></span>

<span data-ttu-id="c848f-119">Применение локальных функций позволяет сделать предназначение кода более понятным.</span><span class="sxs-lookup"><span data-stu-id="c848f-119">Local functions make the intent of your code clear.</span></span> <span data-ttu-id="c848f-120">Другие пользователи, читающие ваш код, смогут видеть, что соответствующий метод вызывается только внутри того метода, в который он вложен.</span><span class="sxs-lookup"><span data-stu-id="c848f-120">Anyone reading your code can see that the method is not callable except by the containing method.</span></span> <span data-ttu-id="c848f-121">В случае с командными проектами это также гарантирует, что другой разработчик не сможет ошибочно вызвать метод напрямую из любого другого места в классе или структуре.</span><span class="sxs-lookup"><span data-stu-id="c848f-121">For team projects, they also make it impossible for another developer to mistakenly call the method directly from elsewhere in the class or struct.</span></span>

## <a name="local-function-syntax"></a><span data-ttu-id="c848f-122">Синтаксис локальной функции</span><span class="sxs-lookup"><span data-stu-id="c848f-122">Local function syntax</span></span>

<span data-ttu-id="c848f-123">Локальная функция определяется как вложенный метод внутри содержащего ее элемента.</span><span class="sxs-lookup"><span data-stu-id="c848f-123">A local function is defined as a nested method inside a containing member.</span></span> <span data-ttu-id="c848f-124">Ниже приведен синтаксис определения локальной функции:</span><span class="sxs-lookup"><span data-stu-id="c848f-124">Its definition has the following syntax:</span></span>

```csharp
<modifiers> <return-type> <method-name> <parameter-list>
```

<span data-ttu-id="c848f-125">С локальной функцией можно использовать следующие модификаторы:</span><span class="sxs-lookup"><span data-stu-id="c848f-125">You can use the following modifiers with a local function:</span></span>

- [`async`](../../language-reference/keywords/async.md)
- [`unsafe`](../../language-reference/keywords/unsafe.md)
- <span data-ttu-id="c848f-126">[`static`](../../language-reference/keywords/static.md) (в C# 8.0 и более поздних версий).</span><span class="sxs-lookup"><span data-stu-id="c848f-126">[`static`](../../language-reference/keywords/static.md) (in C# 8.0 and later).</span></span> <span data-ttu-id="c848f-127">Статическая локальная функция не может сохранять локальные переменные или состояние экземпляра.</span><span class="sxs-lookup"><span data-stu-id="c848f-127">A static local function can't capture local variables or instance state.</span></span>
- <span data-ttu-id="c848f-128">[`extern`](../../language-reference/keywords/extern.md) (в C# 9.0 и более поздних версий).</span><span class="sxs-lookup"><span data-stu-id="c848f-128">[`extern`](../../language-reference/keywords/extern.md) (in C# 9.0 and later).</span></span> <span data-ttu-id="c848f-129">Внешней локальной функцией должна быть `static`.</span><span class="sxs-lookup"><span data-stu-id="c848f-129">An external local function must be `static`.</span></span>

<span data-ttu-id="c848f-130">Все локальные переменные, определенные в содержащем функцию элементе (включая параметры метода), доступны в нестатической локальной функции.</span><span class="sxs-lookup"><span data-stu-id="c848f-130">All local variables that are defined in the containing member, including its method parameters, are accessible in a non-static local function.</span></span>

<span data-ttu-id="c848f-131">В отличие от определения метода, определение локальной функции не может содержать модификатор доступа к элементу.</span><span class="sxs-lookup"><span data-stu-id="c848f-131">Unlike a method definition, a local function definition cannot include the member access modifier.</span></span> <span data-ttu-id="c848f-132">Поскольку все локальные функции являются частными, при использовании модификатора доступа (например, ключевого слова `private`) возникает ошибка компилятора CS0106, "Модификатор "private" недопустим для этого элемента".</span><span class="sxs-lookup"><span data-stu-id="c848f-132">Because all local functions are private, including an access modifier, such as the `private` keyword, generates compiler error CS0106, "The modifier 'private' is not valid for this item."</span></span>

<span data-ttu-id="c848f-133">В следующем примере определяется локальная функция `AppendPathSeparator`, которая является частной для метода `GetText`:</span><span class="sxs-lookup"><span data-stu-id="c848f-133">The following example defines a local function named `AppendPathSeparator` that is private to a method named `GetText`:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="Basic" :::

<span data-ttu-id="c848f-134">Начиная с C# 9.0 можно применять атрибуты к локальной функции, ее параметрам и параметрам типа, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="c848f-134">Beginning with C# 9.0, you can apply attributes to a local function, its parameters and type parameters, as the following example shows:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="WithAttributes" :::

<span data-ttu-id="c848f-135">В предыдущем примере используется [специальный атрибут](../../language-reference/attributes/nullable-analysis.md) для помощи компилятору в статическом анализе в контексте, допускающем значение NULL.</span><span class="sxs-lookup"><span data-stu-id="c848f-135">The preceding example uses a [special attribute](../../language-reference/attributes/nullable-analysis.md) to assist the compiler in static analysis in a nullable context.</span></span>

## <a name="local-functions-and-exceptions"></a><span data-ttu-id="c848f-136">Локальные функции и исключения</span><span class="sxs-lookup"><span data-stu-id="c848f-136">Local functions and exceptions</span></span>

<span data-ttu-id="c848f-137">Полезной особенностью локальных функций является то, что они допускают немедленную обработку исключений.</span><span class="sxs-lookup"><span data-stu-id="c848f-137">One of the useful features of local functions is that they can allow exceptions to surface immediately.</span></span> <span data-ttu-id="c848f-138">В случае с итераторами метода исключения обрабатываются только после перечисления возвращаемой последовательности, а не в момент извлечения итератора.</span><span class="sxs-lookup"><span data-stu-id="c848f-138">For method iterators, exceptions are surfaced only when the returned sequence is enumerated, and not when the iterator is retrieved.</span></span> <span data-ttu-id="c848f-139">В случае с асинхронными методами любые исключения, возникшие в таком методе, наблюдаются в тот момент, когда возвращаемая задача находится в состоянии ожидания.</span><span class="sxs-lookup"><span data-stu-id="c848f-139">For async methods, any exceptions thrown in an async method are observed when the returned task is awaited.</span></span>

<span data-ttu-id="c848f-140">В следующем примере определяется метод `OddSequence`, который перечисляет нечетные числа в заданном диапазоне.</span><span class="sxs-lookup"><span data-stu-id="c848f-140">The following example defines an `OddSequence` method that enumerates odd numbers in a specified range.</span></span> <span data-ttu-id="c848f-141">Поскольку он передает в метод перечислителя `OddSequence` число больше 100, этот метод вызывает исключение <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="c848f-141">Because it passes a number greater than 100 to the `OddSequence` enumerator method, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="c848f-142">Как видно из выходных данных этого примера, исключение обрабатывается только в момент перебора чисел, а не при извлечении перечислителя.</span><span class="sxs-lookup"><span data-stu-id="c848f-142">As the output from the example shows, the exception surfaces only when you iterate the numbers, and not when you retrieve the enumerator.</span></span>

:::code language="csharp" source="snippets/local-functions/IteratorWithoutLocal.cs" :::

<span data-ttu-id="c848f-143">Если поместить логику итератора в локальную функцию, при получении перечислителя вызываются исключения проверки аргументов, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="c848f-143">If you put iterator logic into a local function, argument validation exceptions are thrown when you retrieve the enumerator, as the following example shows:</span></span>

:::code language="csharp" source="snippets/local-functions/IteratorWithLocal.cs" :::

<span data-ttu-id="c848f-144">Аналогичным образом можно использовать локальные функции с асинхронными операциями.</span><span class="sxs-lookup"><span data-stu-id="c848f-144">You can use local functions in a similar way with asynchronous operations.</span></span> <span data-ttu-id="c848f-145">Исключения вызываются в области асинхронного метода при ожидании соответствующей задачи.</span><span class="sxs-lookup"><span data-stu-id="c848f-145">Exceptions thrown in an async method surface when the corresponding task is awaited.</span></span> <span data-ttu-id="c848f-146">Локальная функция реализует моментальный сбой кода, синхронно обеспечивая вызов исключения и наблюдение за ним.</span><span class="sxs-lookup"><span data-stu-id="c848f-146">Local functions allow your code to fail fast and allow your exception to be both thrown and observed synchronously.</span></span>

<span data-ttu-id="c848f-147">В следующем примере асинхронный метод `GetMultipleAsync` выполняет приостановку на указанное число секунд, возвращая значение, представляющее собой произведение случайного множителя на это число секунд.</span><span class="sxs-lookup"><span data-stu-id="c848f-147">The following example uses an asynchronous method named `GetMultipleAsync` to pause for a specified number of seconds and return a value that is a random multiple of that number of seconds.</span></span> <span data-ttu-id="c848f-148">Максимальная задержка составляет 5 с. Результат <xref:System.ArgumentOutOfRangeException> возвращается в том случае, если значение больше 5.</span><span class="sxs-lookup"><span data-stu-id="c848f-148">The maximum delay is 5 seconds; an <xref:System.ArgumentOutOfRangeException> results if the value is greater than 5.</span></span> <span data-ttu-id="c848f-149">Как видно из следующего примера, исключение, которое возникает при передаче в метод `GetMultipleAsync` значения 6, наблюдается только при ожидании задачи.</span><span class="sxs-lookup"><span data-stu-id="c848f-149">As the following example shows, the exception that is thrown when a value of 6 is passed to the `GetMultipleAsync` method is observed only when the task is awaited.</span></span>

:::code language="csharp" source="snippets/local-functions/AsyncWithoutLocal.cs" :::

<span data-ttu-id="c848f-150">Как и в случае с итератором метода, можно выполнить рефакторинг предыдущего примера и разместить код асинхронной операции в локальной функции.</span><span class="sxs-lookup"><span data-stu-id="c848f-150">Like with the method iterator, you can refactor the preceding example and put the code of asynchronous operation in a local function.</span></span> <span data-ttu-id="c848f-151">Как показано в выходных данных следующего примера, <xref:System.ArgumentOutOfRangeException> вызывается сразу же после вызова метода `GetMultiple`.</span><span class="sxs-lookup"><span data-stu-id="c848f-151">As the output from the following example shows, the <xref:System.ArgumentOutOfRangeException> is thrown as soon as the `GetMultiple` method is called.</span></span>

:::code language="csharp" source="snippets/local-functions/AsyncWithLocal.cs" :::

## <a name="local-functions-vs-lambda-expressions"></a><span data-ttu-id="c848f-152">Локальные функции или лямбда-выражения</span><span class="sxs-lookup"><span data-stu-id="c848f-152">Local functions vs. lambda expressions</span></span>

<span data-ttu-id="c848f-153">На первый взгляд, локальные функции и [лямбда-выражения](../../language-reference/operators/lambda-expressions.md) во многом похожи.</span><span class="sxs-lookup"><span data-stu-id="c848f-153">At first glance, local functions and [lambda expressions](../../language-reference/operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="c848f-154">Во многих случаях выбор между использованием лямбда-выражений и локальных функций определяется стилем и личными предпочтениями.</span><span class="sxs-lookup"><span data-stu-id="c848f-154">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="c848f-155">Однако существуют реальные различия в использовании этих сущностей, о которых нужно знать.</span><span class="sxs-lookup"><span data-stu-id="c848f-155">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="c848f-156">Рассмотрим различия в реализации алгоритма вычисления факториала с использованием локальной функции и лямбда-выражения.</span><span class="sxs-lookup"><span data-stu-id="c848f-156">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="c848f-157">В этой версии используется локальная функция:</span><span class="sxs-lookup"><span data-stu-id="c848f-157">Here's the version using a local function:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="FactorialWithLocal" :::

<span data-ttu-id="c848f-158">В этой версии используются лямбда-выражения:</span><span class="sxs-lookup"><span data-stu-id="c848f-158">This version uses lambda expressions:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="FactorialWithLambda" :::

### <a name="naming"></a><span data-ttu-id="c848f-159">Именование</span><span class="sxs-lookup"><span data-stu-id="c848f-159">Naming</span></span>

<span data-ttu-id="c848f-160">Локальные функции явно именуются как методы.</span><span class="sxs-lookup"><span data-stu-id="c848f-160">Local functions are explicitly named like methods.</span></span> <span data-ttu-id="c848f-161">Лямбда-выражения представляют собой анонимные методы и должны назначаться переменным типа `delegate`, как правило, типа `Action` или `Func`.</span><span class="sxs-lookup"><span data-stu-id="c848f-161">Lambda expressions are anonymous methods and need to be assigned to variables of a `delegate` type, typically either `Action` or `Func` types.</span></span> <span data-ttu-id="c848f-162">Процесс объявления локальной функции аналогичен написанию обычного метода: вы объявляете тип возвращаемого значения и сигнатуру функции.</span><span class="sxs-lookup"><span data-stu-id="c848f-162">When you declare a local function, the process is like writing a normal method; you declare a return type and a function signature.</span></span>

### <a name="function-signatures-and-lambda-expression-types"></a><span data-ttu-id="c848f-163">Сигнатуры функций и типы лямбда-выражений</span><span class="sxs-lookup"><span data-stu-id="c848f-163">Function signatures and lambda expression types</span></span>

<span data-ttu-id="c848f-164">Лямбда-выражения используют тип переменной `Action`/`Func`, которой они назначаются, для определения типов аргументов и возвращаемых значений.</span><span class="sxs-lookup"><span data-stu-id="c848f-164">Lambda expressions rely on the type of the `Action`/`Func` variable that they're assigned to determine the argument and return types.</span></span> <span data-ttu-id="c848f-165">Поскольку синтаксис локальных функций во многом аналогичен обычному методу, типы аргументов и возвращаемых значений уже входят в объявление функции.</span><span class="sxs-lookup"><span data-stu-id="c848f-165">In local functions, since the syntax is much like writing a normal method, argument types and return type are already part of the function declaration.</span></span>

### <a name="definite-assignment"></a><span data-ttu-id="c848f-166">Определенное назначение</span><span class="sxs-lookup"><span data-stu-id="c848f-166">Definite assignment</span></span>

<span data-ttu-id="c848f-167">Лямбда-выражения — это объекты, которые объявляются и назначаются во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="c848f-167">Lambda expressions are objects that are declared and assigned at runtime.</span></span> <span data-ttu-id="c848f-168">Чтобы использовать лямбда-выражение, его необходимо определенно назначить: для этого необходимо объявить переменную `Action`/`Func`, которой оно будет назначено, и назначить ей лямбда-выражение.</span><span class="sxs-lookup"><span data-stu-id="c848f-168">In order for a lambda expression to be used, it needs to be definitely assigned: the `Action`/`Func` variable that it will be assigned to must be declared and the lambda expression assigned to it.</span></span> <span data-ttu-id="c848f-169">Обратите внимание на то, что `LambdaFactorial` должно объявить и инициализировать лямбда-выражение `nthFactorial`, прежде чем его определить.</span><span class="sxs-lookup"><span data-stu-id="c848f-169">Notice that `LambdaFactorial` must declare and initialize the lambda expression `nthFactorial` before defining it.</span></span> <span data-ttu-id="c848f-170">В противном случае возникает ошибка компилятора, связанная со ссылкой на объект `nthFactorial`, который еще не был назначен.</span><span class="sxs-lookup"><span data-stu-id="c848f-170">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span>

<span data-ttu-id="c848f-171">Локальные функции определяются во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="c848f-171">Local functions are defined at compile time.</span></span> <span data-ttu-id="c848f-172">Они не назначаются переменным, в связи с чем на них можно ссылаться из любого расположения кода, **в области действия которого они находятся** . В первом примере `LocalFunctionFactorial` мы можем объявить локальную функцию выше или ниже инструкции `return`, и это не приведет к ошибкам компилятора.</span><span class="sxs-lookup"><span data-stu-id="c848f-172">As they're not assigned to variables, they can be referenced from any code location **where it is in scope** ; in our first example `LocalFunctionFactorial`, we could declare our local function either above or below the `return` statement and not trigger any compiler errors.</span></span>

<span data-ttu-id="c848f-173">Эти различия означают, что рекурсивные алгоритмы легче создавать, используя локальные функции.</span><span class="sxs-lookup"><span data-stu-id="c848f-173">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="c848f-174">Можно объявить и определить локальную функцию, которая вызывает саму себя.</span><span class="sxs-lookup"><span data-stu-id="c848f-174">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="c848f-175">Необходимо объявить лямбда-выражения и назначить им значение по умолчанию, прежде чем их можно будет переназначить телу, которое ссылается на то же лямбда-выражение.</span><span class="sxs-lookup"><span data-stu-id="c848f-175">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

### <a name="implementation-as-a-delegate"></a><span data-ttu-id="c848f-176">Реализация в виде делегата</span><span class="sxs-lookup"><span data-stu-id="c848f-176">Implementation as a delegate</span></span>

<span data-ttu-id="c848f-177">Лямбда-выражения преобразуются в делегаты при объявлении.</span><span class="sxs-lookup"><span data-stu-id="c848f-177">Lambda expressions are converted to delegates when they're declared.</span></span> <span data-ttu-id="c848f-178">Локальные функции являются более гибкими и могут определяться в виде традиционного метода *или* делегата.</span><span class="sxs-lookup"><span data-stu-id="c848f-178">Local functions are more flexible in that they can be written like a traditional method *or* as a delegate.</span></span> <span data-ttu-id="c848f-179">Локальные функции преобразуются в делегаты только при ***использовании*** в качестве делегата.</span><span class="sxs-lookup"><span data-stu-id="c848f-179">Local functions are only converted to delegates when ***used*** as a delegate.</span></span>

<span data-ttu-id="c848f-180">Если объявить локальную функцию и сослаться на нее только путем вызова этой функции в качестве метода, она не будет преобразована в делегат.</span><span class="sxs-lookup"><span data-stu-id="c848f-180">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span>

### <a name="variable-capture"></a><span data-ttu-id="c848f-181">Захват переменной</span><span class="sxs-lookup"><span data-stu-id="c848f-181">Variable capture</span></span>

<span data-ttu-id="c848f-182">Правила [определенного назначения](../../../../_csharplang/spec/variables.md#definite-assignment) также влияют на любые переменные, захватываемые локальной функцией или лямбда-выражением.</span><span class="sxs-lookup"><span data-stu-id="c848f-182">The rules of [definite assignment](../../../../_csharplang/spec/variables.md#definite-assignment) also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="c848f-183">Компилятор может выполнять статический анализ, что позволяет локальным функциям определенно назначать захватываемые переменные во включающей области.</span><span class="sxs-lookup"><span data-stu-id="c848f-183">The compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="c848f-184">Рассмотрим следующий пример.</span><span class="sxs-lookup"><span data-stu-id="c848f-184">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="c848f-185">Компилятор может определить, что `LocalFunction` определенно назначает `y` при вызове.</span><span class="sxs-lookup"><span data-stu-id="c848f-185">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="c848f-186">Поскольку `LocalFunction` вызывается перед оператором `return`, `y` определенно назначается в операторе `return`.</span><span class="sxs-lookup"><span data-stu-id="c848f-186">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="c848f-187">Обратите внимание, что когда локальная функция захватывает переменные во включающей области, эта функция реализуется как тип делегата.</span><span class="sxs-lookup"><span data-stu-id="c848f-187">Note that when a local function captures variables in the enclosing scope, the local function is implemented as a delegate type.</span></span>

### <a name="heap-allocations"></a><span data-ttu-id="c848f-188">Распределение куч</span><span class="sxs-lookup"><span data-stu-id="c848f-188">Heap allocations</span></span>

<span data-ttu-id="c848f-189">В зависимости от использования при работе с локальными функциями можно избежать распределения куч, которое всегда необходимо выполнять при работе с лямбда-выражениями.</span><span class="sxs-lookup"><span data-stu-id="c848f-189">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="c848f-190">Если локальная функция никогда не преобразуется в делегат и ни одна из переменных, захваченных локальной функцией, не захвачена другими лямбда-выражениями или локальными функциями, которые преобразуются в делегаты, компилятор может избежать распределения куч.</span><span class="sxs-lookup"><span data-stu-id="c848f-190">If a local function is never converted to a delegate, and none of the variables captured by the local function are captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span>

<span data-ttu-id="c848f-191">Рассмотрим следующий асинхронный пример:</span><span class="sxs-lookup"><span data-stu-id="c848f-191">Consider this async example:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="AsyncWithLambda" :::

<span data-ttu-id="c848f-192">Замыкание для этого лямбда-выражения содержит переменные `address`, `index` и `name`.</span><span class="sxs-lookup"><span data-stu-id="c848f-192">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="c848f-193">При использовании локальных функций объект, который реализует замыкание, может иметь тип `struct`.</span><span class="sxs-lookup"><span data-stu-id="c848f-193">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="c848f-194">Этот тип структуры будет передан в локальную функцию посредством ссылки.</span><span class="sxs-lookup"><span data-stu-id="c848f-194">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="c848f-195">Эта разница в реализации позволяет избежать распределения.</span><span class="sxs-lookup"><span data-stu-id="c848f-195">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="c848f-196">Создание экземпляра, необходимое для лямбда-выражений, означает выделение дополнительной памяти, что в критически важном коде может ухудшить производительность.</span><span class="sxs-lookup"><span data-stu-id="c848f-196">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span> <span data-ttu-id="c848f-197">Локальные функции не создают этой перегрузки.</span><span class="sxs-lookup"><span data-stu-id="c848f-197">Local functions do not incur this overhead.</span></span> <span data-ttu-id="c848f-198">В приведенном выше примере в версии с локальной функцией используется на две операции выделения памяти меньше по сравнению с версией на основе лямбда-выражения.</span><span class="sxs-lookup"><span data-stu-id="c848f-198">In the example above, the local functions version has two fewer allocations than the lambda expression version.</span></span>

<span data-ttu-id="c848f-199">Если известно, что локальная функция не будет преобразована в делегат и ни одна из захватываемых ею переменных не захватывается другими лямбда-выражениями или локальными функциями, которые преобразуются в делегаты, то можно гарантировать, что локальная функция не будет распределяться в куче за счет объявления в качестве локальной функции `static`.</span><span class="sxs-lookup"><span data-stu-id="c848f-199">If you know that your local function won't be converted to a delegate and none of the variables captured by it are captured by other lambdas or local functions that are converted to delegates, you can guarantee that your local function avoids being allocated on the heap by declaring it as a `static` local function.</span></span> <span data-ttu-id="c848f-200">Обратите внимание, что эта возможность доступна в C# 8.0 и более поздних версиях.</span><span class="sxs-lookup"><span data-stu-id="c848f-200">Note that this feature is available in C# 8.0 and newer.</span></span>

> [!NOTE]
> <span data-ttu-id="c848f-201">В эквивалентном этому методе на основе локальной функции также используется класс для замыкания.</span><span class="sxs-lookup"><span data-stu-id="c848f-201">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="c848f-202">Реализация замыкания для локальной функции в формате `class` или `struct` зависит от особенностей реализации.</span><span class="sxs-lookup"><span data-stu-id="c848f-202">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="c848f-203">Локальная функция может использовать `struct`, тогда как в лямбда-выражениях всегда используется `class`.</span><span class="sxs-lookup"><span data-stu-id="c848f-203">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="AsyncWithLocal" :::

### <a name="usage-of-the-yield-keyword"></a><span data-ttu-id="c848f-204">Использование ключевого слова `yield`</span><span class="sxs-lookup"><span data-stu-id="c848f-204">Usage of the `yield` keyword</span></span>

<span data-ttu-id="c848f-205">Еще одно преимущество локальных функций, которое не показано в этом примере, заключается в том, что они могут быть реализованы в качестве итераторов с использованием синтаксиса `yield return` для создания последовательности значений.</span><span class="sxs-lookup"><span data-stu-id="c848f-205">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="YieldReturn" :::

<span data-ttu-id="c848f-206">В лямбда-выражениях не допускается использование инструкции `yield return`. См. описание [ошибки компилятора CS1621](../../misc/cs1621.md).</span><span class="sxs-lookup"><span data-stu-id="c848f-206">The `yield return` statement is not allowed in lambda expressions, see [compiler error CS1621](../../misc/cs1621.md).</span></span>

<span data-ttu-id="c848f-207">Локальные функции могут показаться избыточными для лямбда-выражений, поскольку обычно применяются иначе и в других целях.</span><span class="sxs-lookup"><span data-stu-id="c848f-207">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span> <span data-ttu-id="c848f-208">Локальные функции более эффективны в случаях, когда вам нужно написать функцию, которая будет вызываться только из контекста другого метода.</span><span class="sxs-lookup"><span data-stu-id="c848f-208">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>

## <a name="see-also"></a><span data-ttu-id="c848f-209">См. также</span><span class="sxs-lookup"><span data-stu-id="c848f-209">See also</span></span>

- [<span data-ttu-id="c848f-210">Методы</span><span class="sxs-lookup"><span data-stu-id="c848f-210">Methods</span></span>](methods.md)
