---
title: Руководство по программированию на C#. Локальные функции
description: Локальные функции в C# — это частные методы, которые вложены в другой член и могут быть вызваны из их содержащего члена.
ms.date: 10/16/2020
helpviewer_keywords:
- local functions [C#]
ms.openlocfilehash: 75accda2e40443073274ece4d8964c13a0945dad
ms.sourcegitcommit: dfcbc096ad7908cd58a5f0aeabd2256f05266bac
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/21/2020
ms.locfileid: "92332904"
---
# <a name="local-functions-c-programming-guide"></a>Локальные функции (руководство по программированию на C#)

Начиная с версии 7.0 в языке C# поддерживаются *локальные функции* . Локальные функции представляют собой частные методы типа, вложенные в другой элемент. Они могут вызываться только из того элемента, в который вложены. Ниже перечислены элементы, в которых можно объявлять и из которых можно вызывать локальные функции:

- Методы, в частности методы итератора и асинхронные методы
- Конструкторы
- Методы доступа свойств
- Методы доступа событий
- Анонимные методы
- Лямбда-выражения
- Методы завершения
- Другие локальные функции

Тем не менее локальные функции нельзя объявлять внутри элемента, воплощающего выражение.

> [!NOTE]
> В некоторых случаях для реализации возможностей, поддерживаемых локальными функциями, также можно использовать лямбда-выражения. Дополнительные сведения см. в разделе [Локальные функции или лямбда-выражения](#local-functions-vs-lambda-expressions).

Применение локальных функций позволяет сделать предназначение кода более понятным. Другие пользователи, читающие ваш код, смогут видеть, что соответствующий метод вызывается только внутри того метода, в который он вложен. В случае с командными проектами это также гарантирует, что другой разработчик не сможет ошибочно вызвать метод напрямую из любого другого места в классе или структуре.

## <a name="local-function-syntax"></a>Синтаксис локальной функции

Локальная функция определяется как вложенный метод внутри содержащего ее элемента. Ниже приведен синтаксис определения локальной функции:

```csharp
<modifiers> <return-type> <method-name> <parameter-list>
```

С локальной функцией можно использовать следующие модификаторы:

- [`async`](../../language-reference/keywords/async.md)
- [`unsafe`](../../language-reference/keywords/unsafe.md)
- [`static`](../../language-reference/keywords/static.md) (в C# 8.0 и более поздних версий). Статическая локальная функция не может сохранять локальные переменные или состояние экземпляра.
- [`extern`](../../language-reference/keywords/extern.md) (в C# 9.0 и более поздних версий). Внешней локальной функцией должна быть `static`.

Все локальные переменные, определенные в содержащем функцию элементе (включая параметры метода), доступны в нестатической локальной функции.

В отличие от определения метода, определение локальной функции не может содержать модификатор доступа к элементу. Поскольку все локальные функции являются частными, при использовании модификатора доступа (например, ключевого слова `private`) возникает ошибка компилятора CS0106, "Модификатор "private" недопустим для этого элемента".

В следующем примере определяется локальная функция `AppendPathSeparator`, которая является частной для метода `GetText`:

:::code language="csharp" source="snippets/local-functions/Program.cs" id="Basic" :::

Начиная с C# 9.0 можно применять атрибуты к локальной функции, ее параметрам и параметрам типа, как показано в следующем примере:

:::code language="csharp" source="snippets/local-functions/Program.cs" id="WithAttributes" :::

В предыдущем примере используется [специальный атрибут](../../language-reference/attributes/nullable-analysis.md) для помощи компилятору в статическом анализе в контексте, допускающем значение NULL.

## <a name="local-functions-and-exceptions"></a>Локальные функции и исключения

Полезной особенностью локальных функций является то, что они допускают немедленную обработку исключений. В случае с итераторами метода исключения обрабатываются только после перечисления возвращаемой последовательности, а не в момент извлечения итератора. В случае с асинхронными методами любые исключения, возникшие в таком методе, наблюдаются в тот момент, когда возвращаемая задача находится в состоянии ожидания.

В следующем примере определяется метод `OddSequence`, который перечисляет нечетные числа в заданном диапазоне. Поскольку он передает в метод перечислителя `OddSequence` число больше 100, этот метод вызывает исключение <xref:System.ArgumentOutOfRangeException>. Как видно из выходных данных этого примера, исключение обрабатывается только в момент перебора чисел, а не при извлечении перечислителя.

:::code language="csharp" source="snippets/local-functions/IteratorWithoutLocal.cs" :::

Если поместить логику итератора в локальную функцию, при получении перечислителя вызываются исключения проверки аргументов, как показано в следующем примере:

:::code language="csharp" source="snippets/local-functions/IteratorWithLocal.cs" :::

Аналогичным образом можно использовать локальные функции с асинхронными операциями. Исключения вызываются в области асинхронного метода при ожидании соответствующей задачи. Локальная функция реализует моментальный сбой кода, синхронно обеспечивая вызов исключения и наблюдение за ним.

В следующем примере асинхронный метод `GetMultipleAsync` выполняет приостановку на указанное число секунд, возвращая значение, представляющее собой произведение случайного множителя на это число секунд. Максимальная задержка составляет 5 с. Результат <xref:System.ArgumentOutOfRangeException> возвращается в том случае, если значение больше 5. Как видно из следующего примера, исключение, которое возникает при передаче в метод `GetMultipleAsync` значения 6, наблюдается только при ожидании задачи.

:::code language="csharp" source="snippets/local-functions/AsyncWithoutLocal.cs" :::

Как и в случае с итератором метода, можно выполнить рефакторинг предыдущего примера и разместить код асинхронной операции в локальной функции. Как показано в выходных данных следующего примера, <xref:System.ArgumentOutOfRangeException> вызывается сразу же после вызова метода `GetMultiple`.

:::code language="csharp" source="snippets/local-functions/AsyncWithLocal.cs" :::

## <a name="local-functions-vs-lambda-expressions"></a>Локальные функции или лямбда-выражения

На первый взгляд, локальные функции и [лямбда-выражения](../../language-reference/operators/lambda-expressions.md) во многом похожи. Во многих случаях выбор между использованием лямбда-выражений и локальных функций определяется стилем и личными предпочтениями. Однако существуют реальные различия в использовании этих сущностей, о которых нужно знать.

Рассмотрим различия в реализации алгоритма вычисления факториала с использованием локальной функции и лямбда-выражения. В этой версии используется локальная функция:

:::code language="csharp" source="snippets/local-functions/Program.cs" id="FactorialWithLocal" :::

В этой версии используются лямбда-выражения:

:::code language="csharp" source="snippets/local-functions/Program.cs" id="FactorialWithLambda" :::

### <a name="naming"></a>Именование

Локальные функции явно именуются как методы. Лямбда-выражения представляют собой анонимные методы и должны назначаться переменным типа `delegate`, как правило, типа `Action` или `Func`. Процесс объявления локальной функции аналогичен написанию обычного метода: вы объявляете тип возвращаемого значения и сигнатуру функции.

### <a name="function-signatures-and-lambda-expression-types"></a>Сигнатуры функций и типы лямбда-выражений

Лямбда-выражения используют тип переменной `Action`/`Func`, которой они назначаются, для определения типов аргументов и возвращаемых значений. Поскольку синтаксис локальных функций во многом аналогичен обычному методу, типы аргументов и возвращаемых значений уже входят в объявление функции.

### <a name="definite-assignment"></a>Определенное назначение

Лямбда-выражения — это объекты, которые объявляются и назначаются во время выполнения. Чтобы использовать лямбда-выражение, его необходимо определенно назначить: для этого необходимо объявить переменную `Action`/`Func`, которой оно будет назначено, и назначить ей лямбда-выражение. Обратите внимание на то, что `LambdaFactorial` должно объявить и инициализировать лямбда-выражение `nthFactorial`, прежде чем его определить. В противном случае возникает ошибка компилятора, связанная со ссылкой на объект `nthFactorial`, который еще не был назначен.

Локальные функции определяются во время компиляции. Они не назначаются переменным, в связи с чем на них можно ссылаться из любого расположения кода, **в области действия которого они находятся** . В первом примере `LocalFunctionFactorial` мы можем объявить локальную функцию выше или ниже инструкции `return`, и это не приведет к ошибкам компилятора.

Эти различия означают, что рекурсивные алгоритмы легче создавать, используя локальные функции. Можно объявить и определить локальную функцию, которая вызывает саму себя. Необходимо объявить лямбда-выражения и назначить им значение по умолчанию, прежде чем их можно будет переназначить телу, которое ссылается на то же лямбда-выражение.

### <a name="implementation-as-a-delegate"></a>Реализация в виде делегата

Лямбда-выражения преобразуются в делегаты при объявлении. Локальные функции являются более гибкими и могут определяться в виде традиционного метода *или* делегата. Локальные функции преобразуются в делегаты только при ***использовании*** в качестве делегата.

Если объявить локальную функцию и сослаться на нее только путем вызова этой функции в качестве метода, она не будет преобразована в делегат.

### <a name="variable-capture"></a>Захват переменной

Правила [определенного назначения](../../../../_csharplang/spec/variables.md#definite-assignment) также влияют на любые переменные, захватываемые локальной функцией или лямбда-выражением. Компилятор может выполнять статический анализ, что позволяет локальным функциям определенно назначать захватываемые переменные во включающей области. Рассмотрим следующий пример.

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

Компилятор может определить, что `LocalFunction` определенно назначает `y` при вызове. Поскольку `LocalFunction` вызывается перед оператором `return`, `y` определенно назначается в операторе `return`.

Обратите внимание, что когда локальная функция захватывает переменные во включающей области, эта функция реализуется как тип делегата.

### <a name="heap-allocations"></a>Распределение куч

В зависимости от использования при работе с локальными функциями можно избежать распределения куч, которое всегда необходимо выполнять при работе с лямбда-выражениями. Если локальная функция никогда не преобразуется в делегат и ни одна из переменных, захваченных локальной функцией, не захвачена другими лямбда-выражениями или локальными функциями, которые преобразуются в делегаты, компилятор может избежать распределения куч.

Рассмотрим следующий асинхронный пример:

:::code language="csharp" source="snippets/local-functions/Program.cs" id="AsyncWithLambda" :::

Замыкание для этого лямбда-выражения содержит переменные `address`, `index` и `name`. При использовании локальных функций объект, который реализует замыкание, может иметь тип `struct`. Этот тип структуры будет передан в локальную функцию посредством ссылки. Эта разница в реализации позволяет избежать распределения.

Создание экземпляра, необходимое для лямбда-выражений, означает выделение дополнительной памяти, что в критически важном коде может ухудшить производительность. Локальные функции не создают этой перегрузки. В приведенном выше примере в версии с локальной функцией используется на две операции выделения памяти меньше по сравнению с версией на основе лямбда-выражения.

Если известно, что локальная функция не будет преобразована в делегат и ни одна из захватываемых ею переменных не захватывается другими лямбда-выражениями или локальными функциями, которые преобразуются в делегаты, то можно гарантировать, что локальная функция не будет распределяться в куче за счет объявления в качестве локальной функции `static`. Обратите внимание, что эта возможность доступна в C# 8.0 и более поздних версиях.

> [!NOTE]
> В эквивалентном этому методе на основе локальной функции также используется класс для замыкания. Реализация замыкания для локальной функции в формате `class` или `struct` зависит от особенностей реализации. Локальная функция может использовать `struct`, тогда как в лямбда-выражениях всегда используется `class`.

:::code language="csharp" source="snippets/local-functions/Program.cs" id="AsyncWithLocal" :::

### <a name="usage-of-the-yield-keyword"></a>Использование ключевого слова `yield`

Еще одно преимущество локальных функций, которое не показано в этом примере, заключается в том, что они могут быть реализованы в качестве итераторов с использованием синтаксиса `yield return` для создания последовательности значений.

:::code language="csharp" source="snippets/local-functions/Program.cs" id="YieldReturn" :::

В лямбда-выражениях не допускается использование инструкции `yield return`. См. описание [ошибки компилятора CS1621](../../misc/cs1621.md).

Локальные функции могут показаться избыточными для лямбда-выражений, поскольку обычно применяются иначе и в других целях. Локальные функции более эффективны в случаях, когда вам нужно написать функцию, которая будет вызываться только из контекста другого метода.

## <a name="see-also"></a>См. также

- [Методы](methods.md)
