---
title: Руководство по программированию на C#. Локальные функции
description: Локальные функции в C# — это частные методы, которые вложены в другой член и могут быть вызваны из их содержащего члена.
ms.date: 06/14/2017
helpviewer_keywords:
- local functions [C#]
ms.openlocfilehash: c1c6c6becb3894b05cb9ed89f7f33dcf249b20eb
ms.sourcegitcommit: 1e8382d0ce8b5515864f8fbb178b9fd692a7503f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/10/2020
ms.locfileid: "89656189"
---
# <a name="local-functions-c-programming-guide"></a><span data-ttu-id="c0ad0-103">Локальные функции (руководство по программированию на C#)</span><span class="sxs-lookup"><span data-stu-id="c0ad0-103">Local functions (C# Programming Guide)</span></span>

<span data-ttu-id="c0ad0-104">Начиная с версии 7.0 в языке C# поддерживаются *локальные функции*.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-104">Starting with C# 7.0, C# supports *local functions*.</span></span> <span data-ttu-id="c0ad0-105">Локальные функции представляют собой частные методы типа, вложенные в другой элемент.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-105">Local functions are private methods of a type that are nested in another member.</span></span> <span data-ttu-id="c0ad0-106">Они могут вызываться только из того элемента, в который вложены.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-106">They can only be called from their containing member.</span></span> <span data-ttu-id="c0ad0-107">Ниже перечислены элементы, в которых можно объявлять и из которых можно вызывать локальные функции:</span><span class="sxs-lookup"><span data-stu-id="c0ad0-107">Local functions can be declared in and called from:</span></span>

- <span data-ttu-id="c0ad0-108">Методы, в частности методы итератора и асинхронные методы</span><span class="sxs-lookup"><span data-stu-id="c0ad0-108">Methods, especially iterator methods and async methods</span></span>
- <span data-ttu-id="c0ad0-109">Конструкторы</span><span class="sxs-lookup"><span data-stu-id="c0ad0-109">Constructors</span></span>
- <span data-ttu-id="c0ad0-110">Методы доступа свойств</span><span class="sxs-lookup"><span data-stu-id="c0ad0-110">Property accessors</span></span>
- <span data-ttu-id="c0ad0-111">Методы доступа событий</span><span class="sxs-lookup"><span data-stu-id="c0ad0-111">Event accessors</span></span>
- <span data-ttu-id="c0ad0-112">Анонимные методы</span><span class="sxs-lookup"><span data-stu-id="c0ad0-112">Anonymous methods</span></span>
- <span data-ttu-id="c0ad0-113">Лямбда-выражения</span><span class="sxs-lookup"><span data-stu-id="c0ad0-113">Lambda expressions</span></span>
- <span data-ttu-id="c0ad0-114">Методы завершения</span><span class="sxs-lookup"><span data-stu-id="c0ad0-114">Finalizers</span></span>
- <span data-ttu-id="c0ad0-115">Другие локальные функции</span><span class="sxs-lookup"><span data-stu-id="c0ad0-115">Other local functions</span></span>

<span data-ttu-id="c0ad0-116">Тем не менее локальные функции нельзя объявлять внутри элемента, воплощающего выражение.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-116">However, local functions can't be declared inside an expression-bodied member.</span></span>

> [!NOTE]
> <span data-ttu-id="c0ad0-117">В некоторых случаях для реализации возможностей, поддерживаемых локальными функциями, также можно использовать лямбда-выражения.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-117">In some cases, you can use a lambda expression to implement functionality also supported by a local function.</span></span> <span data-ttu-id="c0ad0-118">Дополнительные сведения см. в разделе [Локальные функции или лямбда-выражения](#local-functions-vs-lambda-expressions).</span><span class="sxs-lookup"><span data-stu-id="c0ad0-118">For a comparison, see [Local functions vs. lambda expressions](#local-functions-vs-lambda-expressions).</span></span>

<span data-ttu-id="c0ad0-119">Применение локальных функций позволяет сделать предназначение кода более понятным.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-119">Local functions make the intent of your code clear.</span></span> <span data-ttu-id="c0ad0-120">Другие пользователи, читающие ваш код, смогут видеть, что соответствующий метод вызывается только внутри того метода, в который он вложен.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-120">Anyone reading your code can see that the method is not callable except by the containing method.</span></span> <span data-ttu-id="c0ad0-121">В случае с командными проектами это также гарантирует, что другой разработчик не сможет ошибочно вызвать метод напрямую из любого другого места в классе или структуре.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-121">For team projects, they also make it impossible for another developer to mistakenly call the method directly from elsewhere in the class or struct.</span></span>

## <a name="local-function-syntax"></a><span data-ttu-id="c0ad0-122">Синтаксис локальной функции</span><span class="sxs-lookup"><span data-stu-id="c0ad0-122">Local function syntax</span></span>

<span data-ttu-id="c0ad0-123">Локальная функция определяется как вложенный метод внутри содержащего ее элемента.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-123">A local function is defined as a nested method inside a containing member.</span></span> <span data-ttu-id="c0ad0-124">Ниже приведен синтаксис определения локальной функции:</span><span class="sxs-lookup"><span data-stu-id="c0ad0-124">Its definition has the following syntax:</span></span>

```csharp
<modifiers: async | unsafe> <return-type> <method-name> <parameter-list>
```

<span data-ttu-id="c0ad0-125">Локальные функции могут использовать модификаторы [async](../../language-reference/keywords/async.md) и [unsafe](../../language-reference/keywords/unsafe.md).</span><span class="sxs-lookup"><span data-stu-id="c0ad0-125">Local functions can use the [async](../../language-reference/keywords/async.md) and [unsafe](../../language-reference/keywords/unsafe.md) modifiers.</span></span>

<span data-ttu-id="c0ad0-126">Обратите внимание, что все локальные переменные, определенные в содержащем функцию элементе (включая параметры метода), доступны в локальной функции.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-126">Note that all local variables that are defined in the containing member, including its method parameters, are accessible in the local function.</span></span>

<span data-ttu-id="c0ad0-127">В отличие от определения метода, определение локальной функции не может содержать модификатор доступа к элементу.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-127">Unlike a method definition, a local function definition cannot include the member access modifier.</span></span> <span data-ttu-id="c0ad0-128">Поскольку все локальные функции являются частными, при использовании модификатора доступа (например, ключевого слова `private`) возникает ошибка компилятора CS0106, "Модификатор "private" недопустим для этого элемента".</span><span class="sxs-lookup"><span data-stu-id="c0ad0-128">Because all local functions are private, including an access modifier, such as the `private` keyword, generates compiler error CS0106, "The modifier 'private' is not valid for this item."</span></span>

> [!NOTE]
> <span data-ttu-id="c0ad0-129">В версиях C# ниже 8.0 локальные функции не могут содержать модификатор `static`.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-129">Prior to C# 8.0, local functions cannot include the `static` modifier.</span></span> <span data-ttu-id="c0ad0-130">При использовании ключевого слова `static` возникает ошибка компилятора CS0106, "Модификатор "static" недопустим для этого элемента" или ошибка компилятора, указывающая, что следует использовать C# 8.0 или более позднюю версию.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-130">Including the `static` keyword generates compiler error CS0106, "The modifier 'static' is not valid for this item.", or a compiler error stating that you should use C# 8.0 or higher.</span></span>

<span data-ttu-id="c0ad0-131">Кроме того, к локальной функции, а также ее параметрам и параметрам типа, нельзя применять атрибуты.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-131">In addition, attributes can't be applied to the local function or to its parameters and type parameters.</span></span>

<span data-ttu-id="c0ad0-132">В следующем примере определяется локальная функция `AppendPathSeparator`, которая является частной для метода `GetText`:</span><span class="sxs-lookup"><span data-stu-id="c0ad0-132">The following example defines a local function named `AppendPathSeparator` that is private to a method named `GetText`:</span></span>

[!code-csharp[LocalFunctionExample](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions1.cs)]  

## <a name="local-functions-and-exceptions"></a><span data-ttu-id="c0ad0-133">Локальные функции и исключения</span><span class="sxs-lookup"><span data-stu-id="c0ad0-133">Local functions and exceptions</span></span>

<span data-ttu-id="c0ad0-134">Полезной особенностью локальных функций является то, что они допускают немедленную обработку исключений.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-134">One of the useful features of local functions is that they can allow exceptions to surface immediately.</span></span> <span data-ttu-id="c0ad0-135">В случае с итераторами метода исключения обрабатываются только после перечисления возвращаемой последовательности, а не в момент извлечения итератора.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-135">For method iterators, exceptions are surfaced only when the returned sequence is enumerated, and not when the iterator is retrieved.</span></span> <span data-ttu-id="c0ad0-136">В случае с асинхронными методами любые исключения, возникшие в таком методе, наблюдаются в тот момент, когда возвращаемая задача находится в состоянии ожидания.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-136">For async methods, any exceptions thrown in an async method are observed when the returned task is awaited.</span></span>

<span data-ttu-id="c0ad0-137">В следующем примере определяется метод `OddSequence`, который перечисляет нечетные числа в заданном диапазоне.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-137">The following example defines an `OddSequence` method that enumerates odd numbers between a specified range.</span></span> <span data-ttu-id="c0ad0-138">Поскольку он передает в метод перечислителя `OddSequence` число больше 100, этот метод вызывает исключение <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-138">Because it passes a number greater than 100 to the `OddSequence` enumerator method, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="c0ad0-139">Как видно из выходных данных этого примера, исключение обрабатывается только в момент перебора чисел, а не при извлечении перечислителя.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-139">As the output from the example shows, the exception surfaces only when you iterate the numbers, and not when you retrieve the enumerator.</span></span>

[!code-csharp[LocalFunctionIterator1](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-iterator1.cs)]

<span data-ttu-id="c0ad0-140">Вместо этого исключение может быть вызвано при выполнении проверки до того, как будет извлечен итератор, путем возврата итератора из локальной функции, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-140">Instead, you can throw an exception when performing validation and before retrieving the iterator by returning the iterator from a local function, as the following example shows.</span></span>

[!code-csharp[LocalFunctionIterator2](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-iterator2.cs)]

<span data-ttu-id="c0ad0-141">Локальные функции можно использовать аналогичным образом для обработки исключений вне асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-141">Local functions can be used in a similar way to handle exceptions outside of the asynchronous operation.</span></span> <span data-ttu-id="c0ad0-142">Как правило, при возникновении исключения в асинхронном методе требуется проверить внутренние исключения в <xref:System.AggregateException>.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-142">Ordinarily, exceptions thrown in async method require that you examine the inner exceptions of an <xref:System.AggregateException>.</span></span> <span data-ttu-id="c0ad0-143">Локальная функция реализует моментальный сбой кода, синхронно обеспечивая вызов исключения и наблюдение за ним.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-143">Local functions allow your code to fail fast and allow your exception to be both thrown and observed synchronously.</span></span>

<span data-ttu-id="c0ad0-144">В следующем примере асинхронный метод `GetMultipleAsync` выполняет приостановку на указанное число секунд, возвращая значение, представляющее собой произведение случайного множителя на это число секунд.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-144">The following example uses an asynchronous method named `GetMultipleAsync` to pause for a specified number of seconds and return a value that is a random multiple of that number of seconds.</span></span> <span data-ttu-id="c0ad0-145">Максимальная задержка составляет 5 с. Результат <xref:System.ArgumentOutOfRangeException> возвращается в том случае, если значение больше 5.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-145">The maximum delay is 5 seconds; an <xref:System.ArgumentOutOfRangeException> results if the value is greater than 5.</span></span> <span data-ttu-id="c0ad0-146">Как видно из следующего примера, исключение, которое возникает при передаче в метод `GetMultipleAsync` значения 6, инкапсулируется в <xref:System.AggregateException> после того, как начинается выполнение метода `GetMultipleAsync`.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-146">As the following example shows, the exception that is thrown when a value of 6 is passed to the `GetMultipleAsync` method is wrapped in an <xref:System.AggregateException> after the `GetMultipleAsync` method begins execution.</span></span>

[!code-csharp[LocalFunctionAsync](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-async1.cs)]

<span data-ttu-id="c0ad0-147">Как и в случае с итератором метода, можно выполнить рефакторинг кода из этого примера таким образом, чтобы реализовать проверку перед вызовом асинхронного метода.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-147">As we did with the method iterator, we can refactor the code from this example to perform the validation before calling the asynchronous method.</span></span> <span data-ttu-id="c0ad0-148">Как видно из результатов следующего примера, <xref:System.ArgumentOutOfRangeException> не инкапсулируется в <xref:System.AggregateException>.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-148">As the output from the following example shows, the <xref:System.ArgumentOutOfRangeException> is not wrapped in a <xref:System.AggregateException>.</span></span>

[!code-csharp[LocalFunctionAsync](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-async2.cs)]

## <a name="local-functions-vs-lambda-expressions"></a><span data-ttu-id="c0ad0-149">Локальные функции или лямбда-выражения</span><span class="sxs-lookup"><span data-stu-id="c0ad0-149">Local functions vs. lambda expressions</span></span>

<span data-ttu-id="c0ad0-150">На первый взгляд, локальные функции и [лямбда-выражения](../../language-reference/operators/lambda-expressions.md) во многом похожи.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-150">At first glance, local functions and [lambda expressions](../../language-reference/operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="c0ad0-151">Во многих случаях выбор между использованием лямбда-выражений и локальных функций определяется стилем и личными предпочтениями.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-151">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="c0ad0-152">Однако существуют реальные различия в использовании этих сущностей, о которых нужно знать.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-152">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="c0ad0-153">Рассмотрим различия в реализации алгоритма вычисления факториала с использованием локальной функции и лямбда-выражения.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-153">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="c0ad0-154">В первой версии используется локальная функция:</span><span class="sxs-lookup"><span data-stu-id="c0ad0-154">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="c0ad0-155">Сравните эту реализацию с версией, в которой используются лямбда-выражения:</span><span class="sxs-lookup"><span data-stu-id="c0ad0-155">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="c0ad0-156">Локальные функции имеют имена.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-156">The local functions have names.</span></span> <span data-ttu-id="c0ad0-157">Лямбда-выражения — это анонимные методы, назначаемые переменным типов `Func` или `Action`.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-157">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="c0ad0-158">При объявлении локальной функции типы аргументов и тип возвращаемого значения являются частью объявления функции.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-158">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="c0ad0-159">Типы аргументов и тип возвращаемого значения не являются частью основной части лямбда-выражения — это часть объявления типа переменной лямбда-выражения.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-159">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="c0ad0-160">Знание этих двух различий поможет в создании более понятного кода.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-160">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="c0ad0-161">Правила определенного назначения у локальных функций и лямбда-выражений различаются.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-161">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="c0ad0-162">На объявление локальной функции можно сослаться из любого расположения кода, находящегося в области охвата.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-162">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="c0ad0-163">Прежде чем к лямбда-выражению можно будет осуществлять доступ, необходимо присвоить его переменной-делегату (или вызвать через делегат, ссылающийся на лямбда-выражение).</span><span class="sxs-lookup"><span data-stu-id="c0ad0-163">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delegate referencing the lambda expression).</span></span> <span data-ttu-id="c0ad0-164">Обратите внимание на то, что версия с использованием лямбда-выражения должна объявить и инициализировать лямбда-выражение `nthFactorial`, прежде чем его определить.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-164">Notice that the version using the lambda expression must declare and initialize the lambda expression `nthFactorial` before defining it.</span></span> <span data-ttu-id="c0ad0-165">В противном случае возникает ошибка компилятора, связанная со ссылкой на объект `nthFactorial`, который еще не был назначен.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-165">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span> <span data-ttu-id="c0ad0-166">Эти различия означают, что рекурсивные алгоритмы легче создавать, используя локальные функции.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-166">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="c0ad0-167">Можно объявить и определить локальную функцию, которая вызывает саму себя.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-167">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="c0ad0-168">Необходимо объявить лямбда-выражения и назначить им значение по умолчанию, прежде чем их можно будет переназначить телу, которое ссылается на то же лямбда-выражение.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-168">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="c0ad0-169">Правила определенного назначения также влияют на любые переменные, собранные локальной функцией или лямбда-выражением.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-169">Definite assignment rules also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="c0ad0-170">Локальные функции и правила лямбда-выражений требуют, чтобы любые захваченные переменные были определенно назначены в точке, где локальная функция или лямбда-выражение преобразуется в делегат.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-170">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="c0ad0-171">Разница в том, что лямбда-выражения преобразуются в делегаты при объявлении.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-171">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="c0ad0-172">Локальные функции преобразуются в делегаты только при использовании в качестве делегата.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-172">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="c0ad0-173">Если объявить локальную функцию и сослаться на нее только путем вызова этой функции в качестве метода, она не будет преобразована в делегат.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-173">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="c0ad0-174">Это правило позволяет объявлять локальную функцию в любом удобном расположении во включающей его области.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-174">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="c0ad0-175">Обычно локальные функции объявляют в конце родительского метода, после всех операторов return.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-175">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="c0ad0-176">В-третьих, компилятор может выполнять статический анализ, что позволяет локальным функциям определенно назначать захваченные переменные во включающей области.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-176">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="c0ad0-177">Рассмотрим следующий пример.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-177">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="c0ad0-178">Компилятор может определить, что `LocalFunction` определенно назначает `y` при вызове.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-178">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="c0ad0-179">Поскольку `LocalFunction` вызывается перед оператором `return`, `y` определенно назначается в операторе `return`.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-179">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="c0ad0-180">Анализ, позволяющий выполнить анализ примера, также иллюстрирует четвертое различие.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-180">The analysis that enables the example analysis enables the fourth difference.</span></span> <span data-ttu-id="c0ad0-181">В зависимости от использования при работе с локальными функциями можно избежать распределения куч, которое всегда необходимо выполнять при работе с лямбда-выражениями.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-181">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="c0ad0-182">Если локальная функция никогда не преобразуется в делегат и ни одна из переменных, захваченных локальной функцией, не захвачена другими лямбда-выражениями или локальными функциями, которые преобразуются в делегаты, компилятор может избежать распределения куч.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-182">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span>

<span data-ttu-id="c0ad0-183">Рассмотрим следующий асинхронный пример:</span><span class="sxs-lookup"><span data-stu-id="c0ad0-183">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="c0ad0-184">Замыкание для этого лямбда-выражения содержит переменные `address`, `index` и `name`.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-184">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="c0ad0-185">При использовании локальных функций объект, который реализует замыкание, может иметь тип `struct`.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-185">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="c0ad0-186">Этот тип структуры будет передан в локальную функцию посредством ссылки.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-186">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="c0ad0-187">Эта разница в реализации позволяет избежать распределения.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-187">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="c0ad0-188">Создание экземпляра, необходимое для лямбда-выражений, означает выделение дополнительной памяти, что в критически важном коде может ухудшить производительность.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-188">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span> <span data-ttu-id="c0ad0-189">Локальные функции не создают этой перегрузки.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-189">Local functions do not incur this overhead.</span></span> <span data-ttu-id="c0ad0-190">В приведенном выше примере в версии с локальной функцией используется на 2 меньше операции выделения памяти по сравнению с версией на основе лямбда-выражения.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-190">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="c0ad0-191">В эквивалентном этому методе на основе локальной функции также используется класс для замыкания.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-191">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="c0ad0-192">Реализация замыкания для локальной функции в формате `class` или `struct` зависит от особенностей реализации.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-192">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="c0ad0-193">Локальная функция может использовать `struct`, тогда как в лямбда-выражениях всегда используется `class`.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-193">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#TaskExample "Task returning method with local function")]

<span data-ttu-id="c0ad0-194">Еще одно преимущество локальных функций, которое не показано в этом примере, заключается в том, что они могут быть реализованы в качестве итераторов с использованием синтаксиса `yield return` для создания последовательности значений.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-194">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="c0ad0-195">В лямбда-выражениях не допускается использование оператора `yield return`.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-195">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="c0ad0-196">Локальные функции могут показаться избыточными для лямбда-выражений, поскольку обычно применяются иначе и в других целях.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-196">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span> <span data-ttu-id="c0ad0-197">Локальные функции более эффективны в случаях, когда вам нужно написать функцию, которая будет вызываться только из контекста другого метода.</span><span class="sxs-lookup"><span data-stu-id="c0ad0-197">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>

## <a name="see-also"></a><span data-ttu-id="c0ad0-198">См. также</span><span class="sxs-lookup"><span data-stu-id="c0ad0-198">See also</span></span>

- [<span data-ttu-id="c0ad0-199">Методы</span><span class="sxs-lookup"><span data-stu-id="c0ad0-199">Methods</span></span>](methods.md)
