---
title: Руководство по программированию на C#. Наследование
ms.date: 02/07/2020
helpviewer_keywords:
- abstract methods [C#]
- abstract classes [C#]
- inheritance [C#]
- derived classes [C#]
- virtual methods [C#]
- C# language, inheritance
ms.assetid: 81d64ee4-50f9-4d6c-a8dc-257c348d2eea
ms.openlocfilehash: 448b1695a4afc50f4afa20383e5fda280b9f12e9
ms.sourcegitcommit: 44a7cd8687f227fc6db3211ccf4783dc20235e51
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/26/2020
ms.locfileid: "77626663"
---
# <a name="inheritance-c-programming-guide"></a>Наследование (Руководство по программированию на C#)

Наследование, вместе с инкапсуляцией и полиморфизмом, является одной из трех основных характеристик объектно-ориентированного программирования. Наследование позволяет создавать новые классы, которые повторно используют, расширяют и изменяют поведение, определенное в других классах. Класс, члены которого наследуются, называется *базовым классом*, а класс, который наследует эти члены, называется *производным классом*. Производный класс может иметь только один прямой базовый класс. Однако наследование является транзитивным. Если `ClassC` является производным от `ClassB`, а `ClassB` — от `ClassA`, `ClassC` наследует члены, объявленные в `ClassB` и `ClassA`.

> [!NOTE]
> Структуры не поддерживают наследование, но могут реализовывать интерфейсы. Дополнительные сведения см. в разделе [Интерфейсы](../interfaces/index.md).

Концептуально производный класс является специализацией базового класса. Например, при наличии базового класса `Animal` возможно наличие одного производного класса, который называется `Mammal`, и еще одного производного класса, который называется `Reptile`. `Mammal` является `Animal` и `Reptile` является `Animal`, но каждый производный класс представляет разные специализации базового класса.

Объявления интерфейса могут определять реализацию по умолчанию для членов. Эти реализации наследуются производными интерфейсами и классами, реализующими эти интерфейсы. Дополнительные сведения о методах интерфейса по умолчанию см. в разделе справочника по языку, посвященном [интерфейсам](../../language-reference/keywords/interface.md).

При определении класса для наследования от другого класса производный класс явно получает все члены базового класса за исключением конструкторов и методов завершения. Производный класс повторно использует код в базовом классе без необходимости его повторной реализации. В производный класс можно добавить дополнительные члены. Производный класс расширяет функциональность базового класса.

На следующем рисунке показан класс `WorkItem`, представляющий рабочий элемент в бизнес-процессе. Как и другие классы, он является производным от <xref:System.Object?displayProperty=nameWithType> и наследует все его методы. В `WorkItem` имеется пять собственных членов. К ним относится конструктор, так как конструкторы не наследуются. Класс `ChangeRequest` наследует от `WorkItem` и представляет конкретный вид рабочего элемента. `ChangeRequest` добавляет еще два члена к членам, унаследованным от `WorkItem` и <xref:System.Object>. Он должен добавить собственный конструктор, и он также добавляет `originalItemID`. Свойство `originalItemID` позволяет `ChangeRequest` связать экземпляр с исходным объектом `WorkItem`, к которому применен запрос на изменение.

![Схема, показывающая наследование классов](./media/inheritance/class-inheritance-diagram.png)

В следующем примере показано, как выражаются в C# отношения между классами, продемонстрированные на предыдущем рисунке. В примере также показано, как `WorkItem` переопределяет виртуальный метод <xref:System.Object.ToString%2A?displayProperty=nameWithType> и как класс `ChangeRequest` наследует `WorkItem` реализацию метода. В первом блоке определяются классы:

[!code-csharp[DefineClasses](~/samples/snippets/csharp/objectoriented/inheritance.cs#Classes)]

В следующем блоке показано, как использовать базовый и производный классы:

[!code-csharp[UseClasses](~/samples/snippets/csharp/objectoriented/inheritance.cs#UseClasses)]

## <a name="abstract-and-virtual-methods"></a>Абстрактные и виртуальные методы

Когда базовый класс объявляет метод как [`virtual`](../../language-reference/keywords/virtual.md), производный класс может [`override`](../../language-reference/keywords/override.md) метод с помощью своей собственной реализации. Если базовый класс объявляет член как [`abstract`](../../language-reference/keywords/abstract.md), этот метод должен быть переопределен в любом неабстрактном классе, который прямо наследует от этого класса. Если производный класс сам является абстрактным, то он наследует абстрактные члены, не реализуя их. Абстрактные и виртуальные члены являются основой для полиморфизма, который является второй основной характеристикой объектно-ориентированного программирования. Дополнительные сведения см. в разделе [Полиморфизм](./polymorphism.md).

## <a name="abstract-base-classes"></a>Абстрактные базовые классы

Можно объявить класс как [абстрактный](../../language-reference/keywords/abstract.md), если необходимо предотвратить прямое создание экземпляров с помощью оператора [new](../../language-reference/operators/new-operator.md). Абстрактный класс можно использовать, только если новый класс является производным от него. Абстрактный класс может содержать один или несколько сигнатур методов, которые сами объявлены в качестве абстрактных. Эти сигнатуры задают параметры и возвращают значение, но не имеют реализации (тела метода). Абстрактному классу необязательно содержать абстрактные члены; однако если класс все же содержит абстрактный член, то сам класс должен быть объявлен в качестве абстрактного. Производные классы, которые сами не являются абстрактными, должны предоставить реализацию для любых абстрактных методов из абстрактного базового класса. Дополнительные сведения см. в статье [Абстрактные и запечатанные классы и члены классов](abstract-and-sealed-classes-and-class-members.md).

## <a name="interfaces"></a>Интерфейсы

*Интерфейс* — это ссылочный тип, определяющий набор членов. Этот набор членов должны реализовать все классы и структуры, реализующие интерфейс. Интерфейс может определять реализацию по умолчанию для любого из этих членов или для них всех. В классе может быть реализовано несколько интерфейсов, хотя производным он может быть только от одного прямого базового класса.

Интерфейсы используются для определения конкретных возможностей для классов, которые не обязательно имеют отношения тождественности. Например, интерфейс <xref:System.IEquatable%601?displayProperty=nameWithType> может быть реализован любым классом или структурой для определения эквивалентности двух объектов типа (однако тип определяет эквивалентность). <xref:System.IEquatable%601> не подразумевает тот же вид отношений тождественности, который существует между базовым и производным классами (например, `Mammal` является `Animal`). Дополнительные сведения см. в разделе [Интерфейсы](../interfaces/index.md).

## <a name="preventing-further-derivation"></a>Предотвращение дальнейшего наследования  

Класс может предотвратить наследование от других классов или наследование от любых его членов, объявив себя или члены как [`sealed`](../../language-reference/keywords/sealed.md). Дополнительные сведения см. в статье [Абстрактные и запечатанные классы и члены классов](./abstract-and-sealed-classes-and-class-members.md).

## <a name="derived-class-hiding-of-base-class-members"></a>Скрытие производного класса членов базового класса  

Производный класс может скрывать члены базового класса путем объявления членов с тем же именем и сигнатурой. Модификатор [`new`](../../language-reference/keywords/new-modifier.md) может использоваться, чтобы явно указать, что член не должен быть переопределением базового члена. Использовать [`new`](../../language-reference/keywords/new-modifier.md) необязательно, но если [`new`](../../language-reference/keywords/new-modifier.md) не используется, будет создано предупреждение компилятора. Дополнительные сведения см. в разделах [Управление версиями с помощью ключевых слов Override и New](./versioning-with-the-override-and-new-keywords.md) и [Использование ключевых слов Override и New](./knowing-when-to-use-override-and-new-keywords.md).

## <a name="see-also"></a>См. также

- [Руководство по программированию на C#](../index.md)
- [Классы и структуры](./index.md)
- [class](../../language-reference/keywords/class.md)
