---
title: Руководство по программированию на C#. Анонимные типы
description: Анонимные типы в C# позволяют инкапсулировать свойства только для чтения в объект без необходимости явного определения типа. Компилятор создает имя.
ms.date: 07/20/2015
helpviewer_keywords:
- anonymous types [C#]
- C# Language, anonymous types
ms.assetid: 59c9d7a4-3b0e-475e-b620-0ab86c088e9b
ms.openlocfilehash: f60c1ea4f3f029ec3b81a4197a711523ec372df9
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/24/2020
ms.locfileid: "91186163"
---
# <a name="anonymous-types-c-programming-guide"></a><span data-ttu-id="46eb5-104">Анонимные типы (Руководство по программированию в C#)</span><span class="sxs-lookup"><span data-stu-id="46eb5-104">Anonymous Types (C# Programming Guide)</span></span>

<span data-ttu-id="46eb5-105">Анонимные типы позволяют легко инкапсулировать свойства только для чтения в один объект без необходимости предварительного определения типа.</span><span class="sxs-lookup"><span data-stu-id="46eb5-105">Anonymous types provide a convenient way to encapsulate a set of read-only properties into a single object without having to explicitly define a type first.</span></span> <span data-ttu-id="46eb5-106">Имя типа создается компилятором и недоступно на уровне исходного кода.</span><span class="sxs-lookup"><span data-stu-id="46eb5-106">The type name is generated by the compiler and is not available at the source code level.</span></span> <span data-ttu-id="46eb5-107">Тип каждого свойства выводится компилятором.</span><span class="sxs-lookup"><span data-stu-id="46eb5-107">The type of each property is inferred by the compiler.</span></span>  
  
 <span data-ttu-id="46eb5-108">Анонимные типы создаются с помощью оператора [new](../../language-reference/operators/new-operator.md) и инициализатора объекта.</span><span class="sxs-lookup"><span data-stu-id="46eb5-108">You create anonymous types by using the [new](../../language-reference/operators/new-operator.md) operator together with an object initializer.</span></span> <span data-ttu-id="46eb5-109">Дополнительные сведения об инициализаторах объектов см. в статье [Инициализаторы объектов и коллекций](./object-and-collection-initializers.md).</span><span class="sxs-lookup"><span data-stu-id="46eb5-109">For more information about object initializers, see [Object and Collection Initializers](./object-and-collection-initializers.md).</span></span>  
  
 <span data-ttu-id="46eb5-110">В следующем примере показан анонимный тип, инициализированный с помощью двух свойств — `Amount` и `Message`.</span><span class="sxs-lookup"><span data-stu-id="46eb5-110">The following example shows an anonymous type that is initialized with two properties named `Amount` and `Message`.</span></span>  
  
```csharp  
var v = new { Amount = 108, Message = "Hello" };  
  
// Rest the mouse pointer over v.Amount and v.Message in the following  
// statement to verify that their inferred types are int and string.  
Console.WriteLine(v.Amount + v.Message);  
```  
  
 <span data-ttu-id="46eb5-111">Обычно анонимные типы используются в предложении [select](../../language-reference/keywords/select-clause.md) выражения запроса для возврата поднабора свойств из каждого объекта в исходной последовательности.</span><span class="sxs-lookup"><span data-stu-id="46eb5-111">Anonymous types typically are used in the [select](../../language-reference/keywords/select-clause.md) clause of a query expression to return a subset of the properties from each object in the source sequence.</span></span> <span data-ttu-id="46eb5-112">Дополнительные сведения о запросах см. в разделе о [LINQ в C#](../../linq/index.md).</span><span class="sxs-lookup"><span data-stu-id="46eb5-112">For more information about queries, see [LINQ in C#](../../linq/index.md).</span></span>  
  
 <span data-ttu-id="46eb5-113">Анонимные типы содержат один или несколько публичных свойств только для чтения.</span><span class="sxs-lookup"><span data-stu-id="46eb5-113">Anonymous types contain one or more public read-only properties.</span></span> <span data-ttu-id="46eb5-114">Другие члены класса, например методы или события, недопустимы.</span><span class="sxs-lookup"><span data-stu-id="46eb5-114">No other kinds of class members, such as methods or events, are valid.</span></span> <span data-ttu-id="46eb5-115">Выражение, которое используется для инициализации свойства, не может быть `null`, анонимной функцией или типом указателя.</span><span class="sxs-lookup"><span data-stu-id="46eb5-115">The expression that is used to initialize a property cannot be `null`, an anonymous function, or a pointer type.</span></span>  
  
 <span data-ttu-id="46eb5-116">Наиболее частый сценарий — это инициализация анонимного типа со свойствами из другого типа.</span><span class="sxs-lookup"><span data-stu-id="46eb5-116">The most common scenario is to initialize an anonymous type with properties from another type.</span></span> <span data-ttu-id="46eb5-117">В следующем примере предполагается, что существует класс с именем `Product`.</span><span class="sxs-lookup"><span data-stu-id="46eb5-117">In the following example, assume that a class exists that is named `Product`.</span></span> <span data-ttu-id="46eb5-118">Класс `Product` включает свойства `Color` и `Price`, а также другие свойства, в которых вы не заинтересованы.</span><span class="sxs-lookup"><span data-stu-id="46eb5-118">Class `Product` includes `Color` and `Price` properties, together with other properties that you are not interested in.</span></span> <span data-ttu-id="46eb5-119">Переменная `products` является коллекцией объектов `Product`.</span><span class="sxs-lookup"><span data-stu-id="46eb5-119">Variable `products` is a collection of `Product` objects.</span></span> <span data-ttu-id="46eb5-120">Объявление анонимного типа запускается с помощью ключевого слова `new`.</span><span class="sxs-lookup"><span data-stu-id="46eb5-120">The anonymous type declaration starts with the `new` keyword.</span></span> <span data-ttu-id="46eb5-121">Объявление инициализирует новый тип, который использует только два свойства из `Product`.</span><span class="sxs-lookup"><span data-stu-id="46eb5-121">The declaration initializes a new type that uses only two properties from `Product`.</span></span> <span data-ttu-id="46eb5-122">Это приводит к тому, что для возврата остается меньшее количество данных.</span><span class="sxs-lookup"><span data-stu-id="46eb5-122">This causes a smaller amount of data to be returned in the query.</span></span>  
  
 <span data-ttu-id="46eb5-123">Если имена членов в анонимном типе не указаны, компилятор присваивает членам анонимного типа такие же имена, как у свойств, используемых для их инициализации.</span><span class="sxs-lookup"><span data-stu-id="46eb5-123">If you do not specify member names in the anonymous type, the compiler gives the anonymous type members the same name as the property being used to initialize them.</span></span> <span data-ttu-id="46eb5-124">Необходимо указать имя для свойства, инициализируемого с помощью выражения, как показано в предыдущем примере.</span><span class="sxs-lookup"><span data-stu-id="46eb5-124">You must provide a name for a property that is being initialized with an expression, as shown in the previous example.</span></span> <span data-ttu-id="46eb5-125">В следующем примере используются имена свойств анонимного типа `Color` и `Price`.</span><span class="sxs-lookup"><span data-stu-id="46eb5-125">In the following example, the names of the properties of the anonymous type are `Color` and `Price`.</span></span>  
  
 [!code-csharp[csRef30Features#81](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csRef30Features/CS/csref30.cs#81)]  
  
 <span data-ttu-id="46eb5-126">Обычно, если для инициализации переменной используется анонимный тип, необходимо обозначить ее как неявно типизированную переменную с помощью функции [var](../../language-reference/keywords/var.md).</span><span class="sxs-lookup"><span data-stu-id="46eb5-126">Typically, when you use an anonymous type to initialize a variable, you declare the variable as an implicitly typed local variable by using [var](../../language-reference/keywords/var.md).</span></span> <span data-ttu-id="46eb5-127">Имя типа не может быть указано в объявлении переменной, так как доступ к базовому имени анонимного типа имеет только компилятор.</span><span class="sxs-lookup"><span data-stu-id="46eb5-127">The type name cannot be specified in the variable declaration because only the compiler has access to the underlying name of the anonymous type.</span></span> <span data-ttu-id="46eb5-128">Дополнительные сведения о `var` см. в разделе [Неявно типизированные локальные переменные](./implicitly-typed-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="46eb5-128">For more information about `var`, see [Implicitly Typed Local Variables](./implicitly-typed-local-variables.md).</span></span>  
  
 <span data-ttu-id="46eb5-129">Вы можете создать массив анонимно типизированных элементов, объединив неявно типизированные локальные переменные и неявно типизированный массив, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="46eb5-129">You can create an array of anonymously typed elements by combining an implicitly typed local variable and an implicitly typed array, as shown in the following example.</span></span>  
  
```csharp  
var anonArray = new[] { new { name = "apple", diam = 4 }, new { name = "grape", diam = 1 }};  
```  
  
## <a name="remarks"></a><span data-ttu-id="46eb5-130">Примечания</span><span class="sxs-lookup"><span data-stu-id="46eb5-130">Remarks</span></span>  

 <span data-ttu-id="46eb5-131">Анонимные типы являются типами [class](../../language-reference/keywords/class.md), прямыми производными от типа [object](../../language-reference/builtin-types/reference-types.md), и не могут быть приведены ни к какому иному типу, кроме [object](../../language-reference/builtin-types/reference-types.md).</span><span class="sxs-lookup"><span data-stu-id="46eb5-131">Anonymous types are [class](../../language-reference/keywords/class.md) types that derive directly from [object](../../language-reference/builtin-types/reference-types.md), and that cannot be cast to any type except [object](../../language-reference/builtin-types/reference-types.md).</span></span> <span data-ttu-id="46eb5-132">Компилятор назначает имя для каждого анонимного типа, несмотря на то что для вашего приложения он недоступен.</span><span class="sxs-lookup"><span data-stu-id="46eb5-132">The compiler provides a name for each anonymous type, although your application cannot access it.</span></span> <span data-ttu-id="46eb5-133">С точки зрения среды CLR анонимный тип не отличается от других ссылочных типов.</span><span class="sxs-lookup"><span data-stu-id="46eb5-133">From the perspective of the common language runtime, an anonymous type is no different from any other reference type.</span></span>  
  
 <span data-ttu-id="46eb5-134">Если два или несколько инициализаторов анонимных объектов в сборке указывают на последовательность свойств, идущих в том же порядке и имеющих те же типы и имена, компилятор обрабатывает объекты как экземпляры одного типа.</span><span class="sxs-lookup"><span data-stu-id="46eb5-134">If two or more anonymous object initializers in an assembly specify a sequence of properties that are in the same order and that have the same names and types, the compiler treats the objects as instances of the same type.</span></span> <span data-ttu-id="46eb5-135">Они используют одни и те же сведения типа, созданные компилятором.</span><span class="sxs-lookup"><span data-stu-id="46eb5-135">They share the same compiler-generated type information.</span></span>  
  
 <span data-ttu-id="46eb5-136">Никакое поле, свойство, событие или тип возвращаемого значения метода невозможно объявить, используя анонимный тип.</span><span class="sxs-lookup"><span data-stu-id="46eb5-136">You cannot declare a field, a property, an event, or the return type of a method as having an anonymous type.</span></span> <span data-ttu-id="46eb5-137">Точно так же нельзя объявить с помощью анонимного типа ни один формальный параметр метода, свойства, конструктора или индексатора.</span><span class="sxs-lookup"><span data-stu-id="46eb5-137">Similarly, you cannot declare a formal parameter of a method, property, constructor, or indexer as having an anonymous type.</span></span> <span data-ttu-id="46eb5-138">Для передачи анонимного типа или коллекции, содержащей анонимные типы, как аргумента для метода можно использовать этот параметр в качестве объекта типа.</span><span class="sxs-lookup"><span data-stu-id="46eb5-138">To pass an anonymous type, or a collection that contains anonymous types, as an argument to a method, you can declare the parameter as type object.</span></span> <span data-ttu-id="46eb5-139">Однако подобное решение противоречит цели строгой типизации.</span><span class="sxs-lookup"><span data-stu-id="46eb5-139">However, doing this defeats the purpose of strong typing.</span></span> <span data-ttu-id="46eb5-140">Если вам нужно сохранить результаты запроса или передать их за пределы метода, используйте вместо анонимного типа структуру или класс, названные обычным образом.</span><span class="sxs-lookup"><span data-stu-id="46eb5-140">If you must store query results or pass them outside the method boundary, consider using an ordinary named struct or class instead of an anonymous type.</span></span>  
  
 <span data-ttu-id="46eb5-141">Так как методы <xref:System.Object.Equals%2A> и <xref:System.Object.GetHashCode%2A> в анонимных типах определяются с точки зрения методов свойств `Equals` и `GetHashCode`, два экземпляра одного и того же анонимного типа равны, только если равны их свойства.</span><span class="sxs-lookup"><span data-stu-id="46eb5-141">Because the <xref:System.Object.Equals%2A> and <xref:System.Object.GetHashCode%2A> methods on anonymous types are defined in terms of the `Equals` and `GetHashCode` methods of the properties, two instances of the same anonymous type are equal only if all their properties are equal.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="46eb5-142">См. также</span><span class="sxs-lookup"><span data-stu-id="46eb5-142">See also</span></span>

- [<span data-ttu-id="46eb5-143">Руководство по программированию на C#</span><span class="sxs-lookup"><span data-stu-id="46eb5-143">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="46eb5-144">Инициализаторы объектов и коллекций</span><span class="sxs-lookup"><span data-stu-id="46eb5-144">Object and Collection Initializers</span></span>](./object-and-collection-initializers.md)
- [<span data-ttu-id="46eb5-145">Приступая к работе с LINQ в C#</span><span class="sxs-lookup"><span data-stu-id="46eb5-145">Getting Started with LINQ in C#</span></span>](../concepts/linq/index.md)
- [<span data-ttu-id="46eb5-146">LINQ в C#</span><span class="sxs-lookup"><span data-stu-id="46eb5-146">LINQ in C#</span></span>](../../linq/index.md)
