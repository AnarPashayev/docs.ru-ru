---
title: Руководство по программированию на C#. Методы расширения
description: Методы расширения в C# позволяют добавлять методы в существующие типы без создания нового производного типа, перекомпиляции и иного изменения первоначального типа.
ms.date: 03/19/2020
helpviewer_keywords:
- methods [C#], adding to existing types
- extension methods [C#]
- methods [C#], extension
ms.assetid: 175ce3ff-9bbf-4e64-8421-faeb81a0bb51
ms.openlocfilehash: 116087ac1aab57f2869b05f436801c7861c56eca
ms.sourcegitcommit: 7476c20d2f911a834a00b8a7f5e8926bae6804d9
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2020
ms.locfileid: "88063709"
---
# <a name="extension-methods-c-programming-guide"></a>Методы расширения (Руководство по программированию в C#)

Методы расширения позволяют "добавлять" методы в существующие типы без создания нового производного типа, перекомпиляции и иного изменения первоначального типа. Методы расширения представляют собой разновидность статического метода, но вызываются так же, как методы экземпляра в расширенном типе. Для клиентского кода, написанного на языках C#, F# и Visual Basic, нет видимого различия между вызовом метода расширения и вызовом методов, определенных в типе.

Самые распространенные методы расширения — стандартные операторы запросов LINQ, которые добавляют функции запросов в существующие типы <xref:System.Collections.IEnumerable?displayProperty=nameWithType> и <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>. Для использования стандартных операторов запросов их необходимо ввести в область действия с помощью директивы `using System.Linq`. Тогда каждый тип, реализующий тип <xref:System.Collections.Generic.IEnumerable%601>, будет иметь методы экземпляра, в частности <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A> и т. д. Эти дополнительные методы можно видеть в завершении операторов IntelliSense при вводе точки после экземпляра типа <xref:System.Collections.Generic.IEnumerable%601>, например <xref:System.Collections.Generic.List%601> или <xref:System.Array>.

### <a name="orderby-example"></a>Пример OrderBy

В следующем примере показано, как вызывать метод стандартного оператора запроса `OrderBy` для массива целых чисел. Выражение в скобках называется лямбда-выражением. Многие стандартные операторы запроса принимают лямбда-выражения в качестве параметров, но это необязательно для методов расширения. Дополнительные сведения см. в разделе [Лямбда-выражения](../../language-reference/operators/lambda-expressions.md).

[!code-csharp[csProgGuideExtensionMethods#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#3)]

Методы расширения определяются как статические методы, но вызываются с помощью синтаксиса обращения к методу экземпляра. Их первый параметр определяет, с каким типом оперирует метод. Параметру предшествует модификатор [this](../../language-reference/keywords/this.md). Методы расширения находятся в области действия, только если пространство имен было явно импортировано в исходный код с помощью директивы `using`.

В приведенном ниже примере показан метод расширения, определенный для класса <xref:System.String?displayProperty=nameWithType>. Этот метод определяется внутри невложенного, неуниверсального статического класса:

[!code-csharp[csProgGuideExtensionMethods#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#4)]

Метод расширения `WordCount` можно ввести в область действия с помощью следующей директивы `using`:

```csharp
using ExtensionMethods;
```

Его можно вызвать из приложения с помощью следующего синтаксиса:

```csharp
string s = "Hello Extension Methods";
int i = s.WordCount();
```

В созданном коде метод расширения вызывается с помощью синтаксиса обращения к методу экземпляра. Промежуточный язык (IL), создаваемый компилятором, преобразует код в вызов статического метода. Принцип инкапсуляции фактически не нарушается. Методы расширения не могут получать доступ к частным переменным типа, для расширения которого они используются.

Дополнительные сведения см. в разделе [Практическое руководство. Реализация и вызов пользовательского метода расширения](./how-to-implement-and-call-a-custom-extension-method.md).

Вообще, обычно гораздо чаще вызываются методы расширения, чем реализуются собственные методы. Так как методы расширения вызываются с помощью синтаксиса обращения к методу экземпляра, для использования их из клиентского кода специальные знания не требуются. Чтобы включить методы расширения для определенного типа, необходимо просто добавить директиву `using` для пространства имен, в котором эти методы определяются. Например, чтобы использовать стандартные операторы запроса, нужно добавить в код следующую директиву `using`:

```csharp
using System.Linq;
```

(Также может потребоваться добавить ссылку на библиотеку System.Core.dll.) Обратите внимание, что стандартные операторы запроса теперь появляются в IntelliSense в виде дополнительных методов, доступных для большинства типов <xref:System.Collections.Generic.IEnumerable%601>.

## <a name="binding-extension-methods-at-compile-time"></a>Привязка методов расширения во время компиляции

Методы расширения можно использовать для расширения класса или интерфейса, но не для их переопределения. Метод расширения, имеющий те же имя и сигнатуру, что и интерфейс или метод класса, никогда не вызывается. Во время компиляции методы расширения всегда имеют более низкий приоритет, чем методы экземпляра, определенные в самом типе. Другими словами, если тип имеет метод `Process(int i)`, а также есть метод расширения с такой же сигнатурой, компилятор будет всегда выполнять привязку к методу экземпляра. Если компилятор обнаруживает вызов метода, он сначала ищет совпадения с методами экземпляра типа. Если такое совпадение не найдено, компилятор выполняет поиск методов расширения, определенных для соответствующего типа, и создает привязку к первому обнаруженному методу расширения. В следующем примере кода демонстрируется, как компилятор определяет, к какому методу расширения или методу экземпляра необходимо выполнить привязку.

## <a name="example"></a>Пример

В следующем примере демонстрируются правила, которые компилятор C# соблюдает при определении того, к чему необходимо привязать вызов метода — к методу экземпляра типа или к методу расширения. Статический класс `Extensions` содержит методы расширения, определяемые для любого типа, реализующего интерфейс `IMyInterface`. Все три класса — `A`, `B` и `C` — реализуют этот интерфейс.

Метод расширения `MethodB` никогда не вызывается, потому что его имя и сигнатура точно совпадают с методами, уже реализованными этими классами.

Если компилятор не может найти метод экземпляра с совпадающей сигнатурой, он выполняет привязку к совпадающему методу расширения, если такой существует.

[!code-csharp[csProgGuideExtensionMethods#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#5)]

## <a name="common-usage-patterns"></a>Общие варианты использования

### <a name="collection-functionality"></a>Функциональные возможности коллекций

В прошлом было распространено создание классов коллекций, которые реализовали интерфейс <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> для данного типа и содержали функциональные возможности, действующие на коллекции этого типа. Хотя в создании этого типа объекта коллекции нет ничего плохого, те же функциональные возможности можно получить, используя расширение <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>. Преимущество расширений заключается в том, что они позволяют вызывать функциональные возможности из любой коллекции, например <xref:System.Array?displayProperty=nameWithType> или <xref:System.Collections.Generic.List%601?displayProperty=nameWithType>, которая реализует <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> для этого типа. Пример использования массива Int32 описан [ранее в этой статье](#orderby-example).

### <a name="layer-specific-functionality"></a>Функциональные возможности конкретного слоя

При использовании многослойной архитектуры или другой многослойной модели приложения обычно используется набор сущностей предметной области или объектов передачи данных, которые можно использовать для обмена данными между границами приложений. Обычно эти объекты содержат только минимальные функциональные возможности (или вовсе их не содержат), применимые ко всем слоям приложения. Методы расширения можно использовать, чтобы добавить функциональные возможности для каждого конкретного слоя приложения без загрузки объекта с помощью методов, которые не нужны или не требуются для других слоев.

```csharp
public class DomainEntity
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}

static class DomainEntityExtensions
{
    static string FullName(this DomainEntity value)
        => $"{value.FirstName} {value.LastName}";
}
```

### <a name="extending-predefined-types"></a>Расширение предопределенных типов

Если необходимо создать многократно используемые функциональные возможности, вы можете расширить существующий тип, например тип .NET или CLR, чтобы не создавать дополнительные объекты. Например, если методы расширения не используются, можно создать класс `Engine` или `Query`, чтобы выполнить запрос к SQL Server, который можно вызвать из нескольких расположений в коде. Однако вместо этого можно расширить класс <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> с помощью методов расширения, чтобы выполнить этот запрос из любого расположения, где установлено подключение с SQL Server. В качестве второго примера можно привести добавление общих функциональных возможностей в класс <xref:System.String?displayProperty=nameWithType>, расширение возможностей обработки данных объектов <xref:System.IO.File?displayProperty=nameWithType> и <xref:System.IO.Stream?displayProperty=nameWithType>, а также объектов <xref:System.Exception?displayProperty=nameWithType> для функциональных возможностей обработки конкретных ошибок. Сценарии использования ограничиваются только воображением и здравым смыслом.

Расширение предопределенных типов с помощью типов `struct` может быть сложным, так как они передаются методам по значению. Это означает, что любые изменения структуры вносятся в ее копию. Эти изменения не отображаются после выхода из метода расширения. Начиная с C# 7.2, вы можете добавить модификатор `ref` к первому аргументу метода расширения. Добавление модификатора `ref` означает, что первый аргумент передается по ссылке. Это позволяет создавать методы расширения, изменяющие состояние расширяемой структуры.

## <a name="general-guidelines"></a>Общие рекомендации

Хотя по-прежнему предпочтительнее добавлять функциональные возможности путем изменения кода объекта или создания производного типа, когда это целесообразно и возможно, методы расширения стали ключевым вариантом для создания многократно используемых функциональных возможностей во всей экосистеме .NET. Методы расширения также являются отличным выбором, если вы не управляете исходным источником, если производный объект недопустим или невозможен или если функциональные возможности должны быть недоступными за пределами применимой области.

Дополнительные сведения о производных типах см. в статье [Наследование (Руководство по программированию на C#)](./inheritance.md).

При использовании метода расширения для расширения типа, исходный код которого невозможно изменить, возникает риск того, что изменение в реализации типа вызовет сбой метода расширения.

В случае реализации методов расширения для какого-либо типа необходимо помнить о следующих фактах:

- Метод расширения никогда не будет вызван, если он имеет ту же сигнатуру, что и метод, определенный в типе.
- Методы расширения вводятся в область действия на уровне пространства имен. Например, при наличии нескольких статических классов, содержащих методы расширения в единственном пространстве имен с именем `Extensions`, все они будут введены в область действия директивой `using Extensions;`.

Для реализованной библиотеки классов не следует использовать методы расширения во избежание увеличения номера версии сборки. Если требуется добавить значительную функциональность в библиотеку, владельцем исходного кода которой вы являетесь, необходимо соблюдать стандартные правила .NET по управлению версиями сборок. Дополнительные сведения см. в разделе [Версии сборок](../../../standard/assembly/versioning.md).

## <a name="see-also"></a>См. также

- [Руководство по программированию на C#](../index.md)
- [Parallel Programming Samples (Образцы параллельного программирования, включают множество примеров методов расширения)](/samples/browse/?products=dotnet-core%2Cdotnet-standard&term=parallel)
- [Лямбда-выражения](../../language-reference/operators/lambda-expressions.md)
- [Общие сведения о стандартных операторах запроса](../concepts/linq/standard-query-operators-overview.md)
- [Conversion Rules for Instance Parameters and their Impact (Правила преобразования для параметров экземпляра и их влияние)](https://docs.microsoft.com/archive/blogs/sreekarc/conversion-rules-for-instance-parameters-and-their-impact)
- [Extension Methods Interoperability between Languages (Взаимодействие между языками с помощью методов расширения)](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-interoperability-between-languages)
- [Extension Methods and Curried Delegates (Методы расширения и каррированные делегаты)](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-and-curried-delegates)
- [Extension method Binding and Error reporting](https://docs.microsoft.com/archive/blogs/sreekarc/extension-method-binding-and-error-reporting)
