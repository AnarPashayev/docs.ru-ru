---
title: Руководство по программированию на C#. Методы завершения
ms.custom: seodec18
ms.date: 10/08/2018
helpviewer_keywords:
- ~ [C#], in finalizers
- C# language, finalizers
- finalizers [C#]
ms.assetid: 1ae6e46d-a4b1-4a49-abe5-b97f53d9e049
ms.openlocfilehash: 87755eadeaebb72c5a8ce147ba2e6faf109e6c12
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2019
ms.locfileid: "64584387"
---
# <a name="finalizers-c-programming-guide"></a>Методы завершения (руководство по программированию в C#)
Методы завершения (также называемые **деструкторами**) используются для любой необходимой окончательной очистки, когда сборщик мусора окончательно удаляет экземпляра класса.  
  
## <a name="remarks"></a>Примечания  
  
- В структурах определение методов завершения невозможно. Они применяются только в классах.  
  
- Каждый класс может иметь только один метод завершения.  
  
- Методы завершения не могут быть унаследованы или перегружены.  
  
- Методы завершения невозможно вызвать. Они запускаются автоматически.  
  
- Метод завершения не принимает модификаторов и не имеет параметров.  
  
 Например, ниже показано объявление метода завершения для класса `Car`.
  
 [!code-csharp[csProgGuideObjects#86](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideObjects/CS/Objects.cs#86)]  

Метод завершения можно также реализовать как определение тела выражения, как показано в следующем примере.

[!code-csharp[expression-bodied-finalizer](../../../../samples/snippets/csharp/programming-guide/classes-and-structs/expr-bodied-destructor.cs#1)]  
  
 Метод завершения неявно вызывает метод <xref:System.Object.Finalize%2A> для базового класса объекта. В связи с этим вызов метода завершения неявно преобразуется в следующий код:  
  
```csharp  
protected override void Finalize()  
{  
    try  
    {  
        // Cleanup statements...  
    }  
    finally  
    {  
        base.Finalize();  
    }  
}  
```  
  
 Это означает, что метод `Finalize` вызывается рекурсивно для всех экземпляров цепочки наследования начиная с самого дальнего и заканчивая самым первым.  
  
> [!NOTE]
>  Пустые методы завершения использовать нельзя. Если класс содержит метод завершения, то в очереди метода `Finalize` создается запись. При вызове метода завершения вызывается сборщик мусора, выполняющий обработку очереди. Если метод завершения пустой, это приводит только к ненужному снижению производительности.  
  
 Программист не может управлять моментом вызова метода завершения, потому что этот момент определяется сборщиком мусора. Сборщик мусора проверяет наличие объектов, которые больше не используются приложением. Если он считает, что какой-либо объект требует уничтожения, то вызывает метод завершения (при наличии) и освобождает память, используемую для хранения этого объекта. 
 
 В приложениях .NET Framework (но не в приложениях .NET Core) методы завершения также вызываются при выходе из программы. 
  
 Сборку мусора можно выполнить принудительно, вызвав метод <xref:System.GC.Collect%2A>, но в большинстве случаев этого следует избегать из-за возможных проблем с производительностью.  
  
## <a name="using-finalizers-to-release-resources"></a>Использование методов завершения для освобождения ресурсов  
 В целом язык C# не требует управления памятью в той степени, в какой это требуется в случае разработки кода на языке, не рассчитанном на среду выполнения со сборкой мусора. Это связано с тем, что сборщик мусора платформы .NET Framework неявным образом управляет выделением и высвобождением памяти для объектов. Однако при инкапсуляции приложением неуправляемых ресурсов, например окон, файлов и сетевых подключений, для высвобождения этих ресурсов следует использовать методы завершения. Если объект допускает завершение, то сборщик мусора выполняет метод `Finalize` этого объекта.  
  
## <a name="explicit-release-of-resources"></a>Освобождение ресурсов явным образом  
 В случае, когда приложением используется ценный внешний ресурс, также рекомендуется обеспечить способ высвобождения этого ресурса явным образом, прежде чем сборщик мусора освободит объект. Для этого реализуется метод `Dispose` интерфейса <xref:System.IDisposable>, который выполняет необходимую для объекта очистку. Это может значительно повысить производительность приложения. Даже в случае использования такого явного управления ресурсами метод завершения становится резервным средством очистки ресурсов, если вызов метода `Dispose` выполнить не удастся.  
  
 Дополнительные сведения об очистке ресурсов см. в следующих разделах:  
  
- [Очистка неуправляемых ресурсов](../../../standard/garbage-collection/unmanaged.md)  
  
- [Реализация метода dispose](../../../standard/garbage-collection/implementing-dispose.md)  
  
- [Оператор using](../../../csharp/language-reference/keywords/using-statement.md)  
  
## <a name="example"></a>Пример  
 В приведенном ниже примере создаются три класса, образующих цепочку наследования. Класс `First` является базовым, класс `Second` является производным от класса `First`, а класс `Third` является производным от класса `Second`. Все три класса имеют методы завершения. В методе `Main` создается экземпляр самого дальнего в цепочке наследования класса. При выполнении программы обратите внимание на то, что методы завершения для всех трех классов вызываются автоматически в порядке от самого дальнего до первого в цепочке наследования.  
  
 [!code-csharp[csProgGuideObjects#85](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideObjects/CS/Objects.cs#85)]  
  
## <a name="c-language-specification"></a>Спецификация языка C#  

Дополнительные сведения см. в разделе [Деструкторы](~/_csharplang/spec/classes.md#destructors) [спецификация языка C# 6.0](../../language-reference/language-specification/index.md).
  
## <a name="see-also"></a>См. также

- <xref:System.IDisposable>
- [Руководство по программированию на C#](../../../csharp/programming-guide/index.md)
- [Конструкторы](../../../csharp/programming-guide/classes-and-structs/constructors.md)
- [Сборка мусора](../../../standard/garbage-collection/index.md)
