---
title: Возможности C#, поддерживающие LINQ
ms.date: 07/20/2015
helpviewer_keywords:
- LINQ [C#], features supporting LINQ
ms.assetid: 524b0078-ebfd-45a7-b390-f2ceb9d84797
ms.openlocfilehash: 32ba8f5e60b3ed2efd813a8ae32e5f4009eb790d
ms.sourcegitcommit: 71b8f5a2108a0f1a4ef1d8d75c5b3e129ec5ca1e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/29/2020
ms.locfileid: "84202409"
---
# <a name="c-features-that-support-linq"></a>Возможности C#, поддерживающие LINQ

В следующем разделе приведены новые конструкции языка, представленные в C# 3.0. Хотя эти новые возможности в некоторой степени используются с запросами LINQ, они не ограничиваются LINQ и могут использоваться в любом контексте, где они будут целесообразны.

## <a name="query-expressions"></a>Выражения запросов

Выражения запросов используют декларативный синтаксис, аналогичный SQL или XQuery, для выполнения запросов к коллекциям IEnumerable. Во время компиляции синтаксис запроса преобразуется в вызовы методов к реализации методов расширения стандартных операторов запросов поставщиком LINQ. Приложения управляют стандартными операторами запросов в области, указывая соответствующее пространство имен с помощью директивы `using`. Следующее выражение запроса принимает массив строк, группирует их в соответствии с первым символом в строке и упорядочивает группы.

```csharp
var query = from str in stringArray
            group str by str[0] into stringGroup
            orderby stringGroup.Key
            select stringGroup;
```

Дополнительные сведения см. в разделе [Выражения запросов LINQ](../../../linq/index.md).

## <a name="implicitly-typed-variables-var"></a>Неявно типизированные переменные (var)

Вместо явного задания типа при объявлении и инициализации переменной можно использовать модификатор [var](../../../language-reference/keywords/var.md), чтобы сообщить компилятору о необходимости определить и присвоить тип, как показано ниже:

```csharp
var number = 5;
var name = "Virginia";
var query = from str in stringArray
            where str[0] == 'm'
            select str;
```

Переменные, объявленные как `var`, так же строго типизированы, как и переменные, тип которых задается явно. Использование `var` делает возможным создание анонимных типов, однако его можно использовать только для локальных переменных. Массивы также могут быть объявлены путем неявной типизации.

Дополнительные сведения см. в статье [Неявно типизированные локальные переменные (руководство по программированию на C#)](../../classes-and-structs/implicitly-typed-local-variables.md).

## <a name="object-and-collection-initializers"></a>Инициализаторы объектов и коллекций

Инициализаторы объектов и коллекций позволяют инициализировать объекты без явного вызова конструктора для объекта. Инициализаторы обычно используются в выражениях запросов при проецировании исходных данных в новый тип данных. При наличии, например, класса с именем `Customer` с общедоступными свойствами `Name` и `Phone` инициализатор объектов можно использовать как в следующем примере кода:

```csharp
var cust = new Customer { Name = "Mike", Phone = "555-1212" };
```

Продолжим рассматривать класс `Customer`. Предположим, что есть источник данных с именем `IncomingOrders` и что для каждого заказа с большим значением `OrderSize` нужно создавать класс `Customer` на основе этого заказа. Можно выполнить запрос LINQ для этого источника данных и использовать инициализацию объекта, чтобы заполнить коллекцию:

```csharp
var newLargeOrderCustomers = from o in IncomingOrders
                            where o.OrderSize > 5
                            select new Customer { Name = o.Name, Phone = o.Phone };
```

У источника данных может быть больше скрытых свойств, чем у класса `Customer`, такого как `OrderSize`. Но инициализация объекта позволяет преобразовать данные, возвращаемые по запросу, в требуемый тип. Мы выберем данные, соответствующие нашему классу. В результате мы заполнили `IEnumerable` новыми классами `Customer`, как и требовалось. Приведенный выше код также можно представить в синтаксисе метода LINQ:

```csharp
var newLargeOrderCustomers = IncomingOrders.Where(x => x.OrderSize > 5).Select(y => new Customer { Name = y.Name, Phone = y.Phone });
```

Дополнительные сведения можно найти в разделе

- [Инициализаторы объектов и коллекций](../../classes-and-structs/object-and-collection-initializers.md)

- [Синтаксис выражений запроса для стандартных операторов запроса](./query-expression-syntax-for-standard-query-operators.md)

## <a name="anonymous-types"></a>Анонимные типы

Анонимный тип создается компилятором, и имя типа доступно только компилятору. Анонимные типы обеспечивают удобный способ временной группировки набора свойств в результатах запроса без необходимости определения отдельного именованного типа. Анонимные типы инициализируются с помощью нового выражения и инициализатора объектов, как показано ниже:

```csharp
select new {name = cust.Name, phone = cust.Phone};
```

Дополнительные сведения см. в статье [Анонимные типы](../../classes-and-structs/anonymous-types.md).

## <a name="extension-methods"></a>Методы расширения

Метод расширения представляет собой статический метод, который может быть связан с типом, чтобы его можно было вызывать, как если бы он являлся методом экземпляра типа. Эта возможность позволяет, по сути, "добавлять" новые методы в существующие типы, фактически не изменяя их. Стандартные операторы запросов — это набор методов расширения, предоставляющий функции запросов LINQ для любого типа, реализующего <xref:System.Collections.Generic.IEnumerable%601>.

Дополнительные сведения см. в разделе [Методы расширения](../../classes-and-structs/extension-methods.md).

## <a name="lambda-expressions"></a>Лямбда-выражения

Лямбда-выражение — это встроенная функция, которая использует оператор => для отделения входных параметров от тела функции и может быть преобразована во время компиляции в делегат или дерево выражения. В программировании LINQ вы столкнетесь с лямбда-выражениями при выполнении прямых вызовов к стандартным операторам запросов.

Дополнительные сведения можно найти в разделе

- [Анонимные функции](../../statements-expressions-operators/anonymous-functions.md)

- [Лямбда-выражения](../../statements-expressions-operators/lambda-expressions.md)

- [Деревья выражений (C#)](../expression-trees/index.md)

## <a name="see-also"></a>См. также

- [LINQ (C#)](./index.md)
