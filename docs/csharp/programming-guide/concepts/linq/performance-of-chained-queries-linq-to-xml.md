---
title: Производительность связанных запросов (LINQ to XML) (C#)
ms.date: 07/20/2015
ms.assetid: b2f1d715-8946-4dc0-8d56-fb3d1bba54a6
ms.openlocfilehash: 7deff9205e6535877efabd85257baa5b3906f41a
ms.sourcegitcommit: 4e2d355baba82814fa53efd6b8bbb45bfe054d11
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/04/2019
ms.locfileid: "70253127"
---
# <a name="performance-of-chained-queries-linq-to-xml-c"></a>Производительность связанных запросов (LINQ to XML) (C#)

Одним из наиболее важных преимуществ LINQ (и LINQ to XML) является возможность эффективного выполнения цепочек запросов наряду с одиночными большими и более сложными запросами.

Цепочкой запросов называется запрос, использующий в качестве источника другой запрос. Например, в следующем простом коде запрос `query2` в качестве источника включает в себя запрос `query1`.

```csharp
XElement root = new XElement("Root",
    new XElement("Child", 1),
    new XElement("Child", 2),
    new XElement("Child", 3),
    new XElement("Child", 4)
);

var query1 = from x in root.Elements("Child")
             where (int)x >= 3
             select x;

var query2 = from e in query1
             where (int)e % 2 == 0
             select e;

foreach (var i in query2)
    Console.WriteLine("{0}", (int)i);
```

В этом примере выводятся следующие данные:

```output
4
```

Эта цепочка запросов по своим показателям производительности аналогична выполнению итераций по связанному списку.

- Производительность оси <xref:System.Xml.Linq.XContainer.Elements%2A> и выполнения итераций по связанному списку практически одинакова. Ось <xref:System.Xml.Linq.XContainer.Elements%2A> реализована в виде итератора с отложенным выполнением. Это означает, что помимо итераций по связанному списку выполняется и другая работа, например, выделяется память для объекта итератора и отслеживается состояние выполнения. Эта работа делится на две категории: работа, выполняемая при настройке итератора, и работа, выполняемая при каждой итерации. Настройка требует небольшого фиксированного объема работы, тогда как объем работы, выполняемой при каждой итерации, пропорционален количеству элементов в исходной коллекции.

- В запросе `query1` предложение `where` вызывает метод <xref:System.Linq.Enumerable.Where%2A>. Этот метод так же реализован в виде итератора. Работа по настройке состоит в создании экземпляра выражения-делегата, которое будет ссылаться на лямбда-выражение, и в выполнении обычной настройки итератора. Выражение-делегат вызывается в каждой итерации для выполнения предиката. Работа по настройке и работа, выполняемая при каждой итерации, аналогична работе, выполняемой при итерациях по оси.

- В запросе `query1` предложение select вызывает метод <xref:System.Linq.Enumerable.Select%2A>. Этот метод имеет такие же показатели производительности, что и метод <xref:System.Linq.Enumerable.Where%2A>.

- В запросе `query2` предложения `where` и `select` имеют такие же показатели производительности, как и в запросе `query1`.

Таким образом, работа итерации по запросу `query2` прямо пропорциональна количеству элементов в источнике первого запроса, то есть имеет линейную зависимость. Соответствующий пример Visual Basic будет иметь те же показатели производительности.

Дополнительные сведения об итерациях см. в разделе [yield](../../../language-reference/keywords/yield.md).

Более подробные сведения об объединении запросов в цепочки см. в разделе [Учебник. Объединение запросов в цепочки](./deferred-execution-and-lazy-evaluation-in-linq-to-xml.md).
