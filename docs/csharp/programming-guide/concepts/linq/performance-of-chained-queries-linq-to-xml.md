---
title: Производительность связанных запросов (LINQ to XML) (C#)
ms.date: 07/20/2015
ms.assetid: b2f1d715-8946-4dc0-8d56-fb3d1bba54a6
ms.openlocfilehash: da01901a8c4208965a339cb3cf446f054f65638b
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2019
ms.locfileid: "64596854"
---
# <a name="performance-of-chained-queries-linq-to-xml-c"></a>Производительность связанных запросов (LINQ to XML) (C#)
Одним из наиболее важных преимуществ LINQ (и LINQ to XML) является возможность эффективного выполнения цепочек запросов наряду с одиночными большими и более сложными запросами.  
  
 Цепочкой запросов называется запрос, использующий в качестве источника другой запрос. Например, в следующем простом коде запрос `query2` в качестве источника включает в себя запрос `query1`.  
  
```csharp  
XElement root = new XElement("Root",  
    new XElement("Child", 1),  
    new XElement("Child", 2),  
    new XElement("Child", 3),  
    new XElement("Child", 4)  
);  
  
var query1 = from x in root.Elements("Child")  
             where (int)x >= 3  
             select x;  
  
var query2 = from e in query1  
             where (int)e % 2 == 0  
             select e;  
  
foreach (var i in query2)  
    Console.WriteLine("{0}", (int)i);  
```  
  
 В этом примере выводятся следующие данные:  
  
```  
4  
```  
  
 Эта цепочка запросов по своим показателям производительности аналогична выполнению итераций по связанному списку.  
  
- Производительность оси <xref:System.Xml.Linq.XContainer.Elements%2A> и выполнения итераций по связанному списку практически одинакова. Ось <xref:System.Xml.Linq.XContainer.Elements%2A> реализована в виде итератора с отложенным выполнением. Это означает, что помимо итераций по связанному списку выполняется и другая работа, например, выделяется память для объекта итератора и отслеживается состояние выполнения. Эта работа делится на две категории: работа, выполняемая при настройке итератора, и работа, выполняемая при каждой итерации. Настройка требует небольшого фиксированного объема работы, тогда как объем работы, выполняемой при каждой итерации, пропорционален количеству элементов в исходной коллекции.  
  
- В запросе `query1` предложение `where` вызывает метод <xref:System.Linq.Enumerable.Where%2A>. Этот метод так же реализован в виде итератора. Работа по настройке состоит в создании экземпляра выражения-делегата, которое будет ссылаться на лямбда-выражение, и в выполнении обычной настройки итератора. Выражение-делегат вызывается в каждой итерации для выполнения предиката. Работа по настройке и работа, выполняемая при каждой итерации, аналогична работе, выполняемой при итерациях по оси.  
  
- В запросе `query1` предложение select вызывает метод <xref:System.Linq.Enumerable.Select%2A>. Этот метод имеет такие же показатели производительности, что и метод <xref:System.Linq.Enumerable.Where%2A>.  
  
- В запросе `query2` предложения `where` и `select` имеют такие же показатели производительности, как и в запросе `query1`.  
  
 Таким образом, работа итерации по запросу `query2` прямо пропорциональна количеству элементов в источнике первого запроса, то есть имеет линейную зависимость. Соответствующий пример Visual Basic будет иметь те же показатели производительности.  
  
 Дополнительные сведения об итерациях см. в разделе [yield](../../../../csharp/language-reference/keywords/yield.md).  
  
 Более подробные сведения об объединении запросов в цепочки см. в разделе [Учебник. Объединение запросов в цепочки](../../../../csharp/programming-guide/concepts/linq/tutorial-chaining-queries-together.md).  
  
## <a name="see-also"></a>См. также

- [Производительность (LINQ to XML) (C#)](../../../../csharp/programming-guide/concepts/linq/performance-linq-to-xml.md)
