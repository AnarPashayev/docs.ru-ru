---
title: Сравнение функционального и Императивное программирование (C#)
description: В этой статье сравнивается функциональное программирование в C# с процедурным программированием. Функциональное программирование обеспечивает неизменность с помощью чистых функций.
ms.date: 07/20/2015
ms.assetid: 5e35c5a0-c949-422a-873b-fca6b2254f57
ms.openlocfilehash: bc421d654e532293b522dab9d43920d0fffd7b92
ms.sourcegitcommit: 04022ca5d00b2074e1b1ffdbd76bec4950697c4c
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/23/2020
ms.locfileid: "87103741"
---
# <a name="functional-programming-vs-imperative-programming-c"></a><span data-ttu-id="27b7d-104">Сравнение функционального и Императивное программирование (C#)</span><span class="sxs-lookup"><span data-stu-id="27b7d-104">Functional Programming vs. Imperative Programming (C#)</span></span>
<span data-ttu-id="27b7d-105">В этом разделе сравнивается и противопоставляется функциональное программирование с традиционным императивным (процедурным) программированием.</span><span class="sxs-lookup"><span data-stu-id="27b7d-105">This topic compares and contrasts functional programming with more traditional imperative (procedural) programming.</span></span>  
  
## <a name="functional-programming-vs-imperative-programming"></a><span data-ttu-id="27b7d-106">Сравнение функционального и Командное программирование</span><span class="sxs-lookup"><span data-stu-id="27b7d-106">Functional Programming vs. Imperative Programming</span></span>  
 <span data-ttu-id="27b7d-107">Принципы *функционального программирования* формулировались специально для поддержки чисто функционального подхода к решению проблем.</span><span class="sxs-lookup"><span data-stu-id="27b7d-107">The *functional programming* paradigm was explicitly created to support a pure functional approach to problem solving.</span></span> <span data-ttu-id="27b7d-108">Функциональное программирование является одной из форм *декларативного программирования*.</span><span class="sxs-lookup"><span data-stu-id="27b7d-108">Functional programming is a form of *declarative programming*.</span></span> <span data-ttu-id="27b7d-109">В отличие от этого, большинство традиционных языков, в том числе такие языки объектно-ориентированного программирования (OOP), как C#, Visual Basic, C++ и Java, разрабатывались в основном для *императивного* (процедурного) программирования.</span><span class="sxs-lookup"><span data-stu-id="27b7d-109">In contrast, most mainstream languages, including object-oriented programming (OOP) languages such as C#, Visual Basic, C++, and Java, were designed to primarily support *imperative* (procedural) programming.</span></span>  
  
 <span data-ttu-id="27b7d-110">При императивном подходе разработчик пишет код, подробно определяющий шаги, которые должен выполнить компьютер для достижения цели.</span><span class="sxs-lookup"><span data-stu-id="27b7d-110">With an imperative approach, a developer writes code that describes in exacting detail the steps that the computer must take to accomplish the goal.</span></span> <span data-ttu-id="27b7d-111">Такое программирование иногда называют *алгоритмическим*.</span><span class="sxs-lookup"><span data-stu-id="27b7d-111">This is sometimes referred to as *algorithmic* programming.</span></span> <span data-ttu-id="27b7d-112">В отличие от него, функциональный подход сводится к составлению решения задачи в виде набора функций, которые должны быть выполнены.</span><span class="sxs-lookup"><span data-stu-id="27b7d-112">In contrast, a functional approach involves composing the problem as a set of functions to be executed.</span></span> <span data-ttu-id="27b7d-113">Разработчик подробно определяет вход каждой функции и возвращаемые ею результаты.</span><span class="sxs-lookup"><span data-stu-id="27b7d-113">You define carefully the input to each function, and what each function returns.</span></span> <span data-ttu-id="27b7d-114">В следующей таблице описаны некоторые важные различия между этими двумя подходами.</span><span class="sxs-lookup"><span data-stu-id="27b7d-114">The following table describes some of the general differences between these two approaches.</span></span>  
  
|<span data-ttu-id="27b7d-115">Характеристика</span><span class="sxs-lookup"><span data-stu-id="27b7d-115">Characteristic</span></span>|<span data-ttu-id="27b7d-116">Императивный подход</span><span class="sxs-lookup"><span data-stu-id="27b7d-116">Imperative approach</span></span>|<span data-ttu-id="27b7d-117">Функциональный подход</span><span class="sxs-lookup"><span data-stu-id="27b7d-117">Functional approach</span></span>|  
|--------------------|-------------------------|-------------------------|  
|<span data-ttu-id="27b7d-118">Основная направленность усилий программиста</span><span class="sxs-lookup"><span data-stu-id="27b7d-118">Programmer focus</span></span>|<span data-ttu-id="27b7d-119">Способы выполнения (алгоритмы) задач и отслеживания изменений в их состоянии.</span><span class="sxs-lookup"><span data-stu-id="27b7d-119">How to perform tasks (algorithms) and how to track changes in state.</span></span>|<span data-ttu-id="27b7d-120">Требуемые данные и преобразования.</span><span class="sxs-lookup"><span data-stu-id="27b7d-120">What information is desired and what transformations are required.</span></span>|  
|<span data-ttu-id="27b7d-121">Изменения состояния</span><span class="sxs-lookup"><span data-stu-id="27b7d-121">State changes</span></span>|<span data-ttu-id="27b7d-122">Важно!</span><span class="sxs-lookup"><span data-stu-id="27b7d-122">Important.</span></span>|<span data-ttu-id="27b7d-123">Не существует.</span><span class="sxs-lookup"><span data-stu-id="27b7d-123">Non-existent.</span></span>|  
|<span data-ttu-id="27b7d-124">Порядок выполнения</span><span class="sxs-lookup"><span data-stu-id="27b7d-124">Order of execution</span></span>|<span data-ttu-id="27b7d-125">Важно!</span><span class="sxs-lookup"><span data-stu-id="27b7d-125">Important.</span></span>|<span data-ttu-id="27b7d-126">Низкая значимость.</span><span class="sxs-lookup"><span data-stu-id="27b7d-126">Low importance.</span></span>|  
|<span data-ttu-id="27b7d-127">Управление основным потоком данных</span><span class="sxs-lookup"><span data-stu-id="27b7d-127">Primary flow control</span></span>|<span data-ttu-id="27b7d-128">Циклы, условия и вызовы функций (методов).</span><span class="sxs-lookup"><span data-stu-id="27b7d-128">Loops, conditionals, and function (method) calls.</span></span>|<span data-ttu-id="27b7d-129">Вызовы функций, включая рекурсивные.</span><span class="sxs-lookup"><span data-stu-id="27b7d-129">Function calls, including recursion.</span></span>|  
|<span data-ttu-id="27b7d-130">Основная единица обработки</span><span class="sxs-lookup"><span data-stu-id="27b7d-130">Primary manipulation unit</span></span>|<span data-ttu-id="27b7d-131">Экземпляры структур или классов.</span><span class="sxs-lookup"><span data-stu-id="27b7d-131">Instances of structures or classes.</span></span>|<span data-ttu-id="27b7d-132">Функции как полноценные объекты и коллекции данных.</span><span class="sxs-lookup"><span data-stu-id="27b7d-132">Functions as first-class objects and data collections.</span></span>|  
  
 <span data-ttu-id="27b7d-133">Безусловно, большинство языков программирования было разработано в целях поддержки определенных подходов к программированию, но многие языки общего назначения являются достаточно гибкими, чтобы поддерживать несколько подходов.</span><span class="sxs-lookup"><span data-stu-id="27b7d-133">Although most languages were designed to support a specific programming paradigm, many general languages are flexible enough to support multiple paradigms.</span></span> <span data-ttu-id="27b7d-134">Например, большинство языков, содержащих указатели на функции, могут использоваться для надежной поддержки функционального программирования.</span><span class="sxs-lookup"><span data-stu-id="27b7d-134">For example, most languages that contain function pointers can be used to credibly support functional programming.</span></span> <span data-ttu-id="27b7d-135">Более того, в C# включены языковые расширения, предназначенные для поддержки функционального программирования, в том числе лямбда-выражения и определения типов.</span><span class="sxs-lookup"><span data-stu-id="27b7d-135">Furthermore, C# includes explicit language extensions to support functional programming, including lambda expressions and type inference.</span></span> <span data-ttu-id="27b7d-136">Одной из форм декларативного, функционального программирования является технология LINQ.</span><span class="sxs-lookup"><span data-stu-id="27b7d-136">LINQ technology is a form of declarative, functional programming.</span></span>  
  
## <a name="functional-programming-using-xslt"></a><span data-ttu-id="27b7d-137">Функциональное программирование с помощью XSLT</span><span class="sxs-lookup"><span data-stu-id="27b7d-137">Functional Programming Using XSLT</span></span>  
 <span data-ttu-id="27b7d-138">Многие разработчики XSLT знакомы с чисто функциональным подходом.</span><span class="sxs-lookup"><span data-stu-id="27b7d-138">Many XSLT developers are familiar with the pure functional approach.</span></span> <span data-ttu-id="27b7d-139">Наиболее эффективный способ разработки таблицы стилей XSLT состоит в том, что каждый шаблон рассматривается как изолированное, составное преобразование.</span><span class="sxs-lookup"><span data-stu-id="27b7d-139">The most effective way to develop an XSLT style sheet is to treat each template as an isolated, composable transformation.</span></span> <span data-ttu-id="27b7d-140">При этом совершенно не приходится задумываться над тем, в каком порядке должны проводиться вычисления.</span><span class="sxs-lookup"><span data-stu-id="27b7d-140">The order of execution is completely de-emphasized.</span></span> <span data-ttu-id="27b7d-141">XSLT исключает побочные эффекты (если не считать того, что применение механизмов экранирования, предназначенных для выполнения процедурного кода, может приводить к получению результатов функций, не соответствующих определениям этих функций).</span><span class="sxs-lookup"><span data-stu-id="27b7d-141">XSLT does not allow side effects (with the exception that escaping mechanisms for executing procedural code can introduce side effects that result in functional impurity).</span></span> <span data-ttu-id="27b7d-142">Таким образом, XSLT является эффективным инструментом, но некоторые его характеристики не оптимальны.</span><span class="sxs-lookup"><span data-stu-id="27b7d-142">However, although XSLT is an effective tool, some of its characteristics are not optimal.</span></span> <span data-ttu-id="27b7d-143">Например, программные конструкции приходится представлять на языке XML, в связи с чем объем кода становится довольно большим, поэтому его сопровождение затрудняется.</span><span class="sxs-lookup"><span data-stu-id="27b7d-143">For example, expressing programming constructs in XML makes code relatively verbose, and therefore difficult to maintain.</span></span> <span data-ttu-id="27b7d-144">Кроме того, в управлении потоком широко применяется рекурсия, что может привести к созданию трудночитаемого кода.</span><span class="sxs-lookup"><span data-stu-id="27b7d-144">Also, the heavy reliance on recursion for flow control can result in code that is hard to read.</span></span> <span data-ttu-id="27b7d-145">Дополнительные сведения об XSLT см. в разделе [Преобразования XSLT](../../../../standard/data/xml/xslt-transformations.md).</span><span class="sxs-lookup"><span data-stu-id="27b7d-145">For more information about XSLT, see [XSLT Transformations](../../../../standard/data/xml/xslt-transformations.md).</span></span>  
  
 <span data-ttu-id="27b7d-146">Тем не менее XSLT доказал свою полезность при чисто функциональном подходе для преобразования XML из одного вида в другой.</span><span class="sxs-lookup"><span data-stu-id="27b7d-146">However, XSLT has proved the value of using a pure functional approach for transforming XML from one shape to another.</span></span> <span data-ttu-id="27b7d-147">Чисто функциональное программирование с помощью LINQ to XML во многом похоже на XSLT.</span><span class="sxs-lookup"><span data-stu-id="27b7d-147">Pure functional programming with LINQ to XML is similar in many ways to XSLT.</span></span> <span data-ttu-id="27b7d-148">Но программные конструкции, вводимые LINQ to XML и в C#, позволяют писать чисто функциональные преобразования, более удобочитаемые и легко обслуживаемые, чем XSLT.</span><span class="sxs-lookup"><span data-stu-id="27b7d-148">However, the programming constructs introduced by LINQ to XML and C#  allow you to write pure functional transformations that are more readable and maintainable than XSLT.</span></span>  
  
## <a name="advantages-of-pure-functions"></a><span data-ttu-id="27b7d-149">Преимущества чистых функций</span><span class="sxs-lookup"><span data-stu-id="27b7d-149">Advantages of Pure Functions</span></span>  
 <span data-ttu-id="27b7d-150">Основная причина реализации функциональных преобразований в виде чистых функций заключается в том, что чистые функции являются компонуемыми, т. е. самодостаточными без сохранения состояния.</span><span class="sxs-lookup"><span data-stu-id="27b7d-150">The primary reason to implement functional transformations as pure functions is that pure functions are composable: that is, self-contained and stateless.</span></span> <span data-ttu-id="27b7d-151">Это дает ряд преимуществ, включая следующие.</span><span class="sxs-lookup"><span data-stu-id="27b7d-151">These characteristics bring a number of benefits, including the following:</span></span>  
  
- <span data-ttu-id="27b7d-152">Повышенная удобочитаемость и обслуживаемость.</span><span class="sxs-lookup"><span data-stu-id="27b7d-152">Increased readability and maintainability.</span></span> <span data-ttu-id="27b7d-153">Это объясняется тем, что каждая функция разрабатывается для выполнения конкретных задач, определяемых аргументами.</span><span class="sxs-lookup"><span data-stu-id="27b7d-153">This is because each function is designed to accomplish a specific task given its arguments.</span></span> <span data-ttu-id="27b7d-154">Функция не зависит от какого-либо внешнего состояния.</span><span class="sxs-lookup"><span data-stu-id="27b7d-154">The function does not rely on any external state.</span></span>  
  
- <span data-ttu-id="27b7d-155">Упрощается разработка, основанная на ранее созданном коде.</span><span class="sxs-lookup"><span data-stu-id="27b7d-155">Easier reiterative development.</span></span> <span data-ttu-id="27b7d-156">Код становится более приемлемым для оптимизации кода, поэтому легче реализовать изменения в проекте.</span><span class="sxs-lookup"><span data-stu-id="27b7d-156">Because the code is easier to refactor, changes to design are often easier to implement.</span></span> <span data-ttu-id="27b7d-157">Например, предположим, что в процессе написания сложного преобразования выясняется, что какой-то код повторяется несколько раз.</span><span class="sxs-lookup"><span data-stu-id="27b7d-157">For example, suppose you write a complicated transformation, and then realize that some code is repeated several times in the transformation.</span></span> <span data-ttu-id="27b7d-158">Если оптимизация кода предусматривает преобразование в чистый метод, то полученный чистый метод можно вызывать в любое время, не беспокоясь о побочных эффектах.</span><span class="sxs-lookup"><span data-stu-id="27b7d-158">If you refactor through a pure method, you can call your pure method at will without worrying about side effects.</span></span>  
  
- <span data-ttu-id="27b7d-159">Упрощаются тестирование и отладка.</span><span class="sxs-lookup"><span data-stu-id="27b7d-159">Easier testing and debugging.</span></span> <span data-ttu-id="27b7d-160">Чистые функции проще тестировать отдельно от основной части кода, поэтому можно написать проверочный код, в котором чистая функция вызывается с типичными значениями, допустимыми краевыми значениями и недопустимыми краевыми значениями.</span><span class="sxs-lookup"><span data-stu-id="27b7d-160">Because pure functions can more easily be tested in isolation, you can write test code that calls the pure function with typical values, valid edge cases, and invalid edge cases.</span></span>  
  
## <a name="transitioning-for-oop-developers"></a><span data-ttu-id="27b7d-161">Освоение нового подхода разработчиками объектно-ориентированных приложений</span><span class="sxs-lookup"><span data-stu-id="27b7d-161">Transitioning for OOP Developers</span></span>  
 <span data-ttu-id="27b7d-162">Традиционное объектно-ориентированное программирование (OOP) является таковым, что большинство разработчиков привыкает писать код в императивном (процедурном) стиле.</span><span class="sxs-lookup"><span data-stu-id="27b7d-162">In traditional object-oriented programming (OOP), most developers are accustomed to programming in the imperative/procedural style.</span></span> <span data-ttu-id="27b7d-163">Переходя к разработке в чисто функциональном стиле, они должны изменить свое мышление и подход к разработке.</span><span class="sxs-lookup"><span data-stu-id="27b7d-163">To switch to developing in a pure functional style, they have to make a transition in their thinking and their approach to development.</span></span>  
  
 <span data-ttu-id="27b7d-164">Чтобы решить задачу, разработчики объектно-ориентированных приложений проектируют иерархии классов, добиваются правильной инкапсуляции и мыслят в терминах контрактов между классами.</span><span class="sxs-lookup"><span data-stu-id="27b7d-164">To solve problems, OOP developers design class hierarchies, focus on proper encapsulation, and think in terms of class contracts.</span></span> <span data-ttu-id="27b7d-165">Для них первостепенное значение имеет обеспечение правильного поведения и состояния типов объектов, а для достижения этого используются такие возможности языка, как классы, интерфейсы, наследование и полиморфизм.</span><span class="sxs-lookup"><span data-stu-id="27b7d-165">The behavior and state of object types are paramount, and language features, such as classes, interfaces, inheritance, and polymorphism, are provided to address these concerns.</span></span>  
  
 <span data-ttu-id="27b7d-166">В отличие от этого, в функциональном программировании применяется подход к вычислительным проблемам как к определению чисто функциональных преобразований коллекции данных.</span><span class="sxs-lookup"><span data-stu-id="27b7d-166">In contrast, functional programming approaches computational problems as an exercise in the evaluation of pure functional transformations of data collections.</span></span> <span data-ttu-id="27b7d-167">В функциональном программировании приходится отказываться от применения состояний и изменяющихся данных, а вместо этого сосредоточиваться на применении функции.</span><span class="sxs-lookup"><span data-stu-id="27b7d-167">Functional programming avoids state and mutable data, and instead emphasizes the application of functions.</span></span>  
  
 <span data-ttu-id="27b7d-168">К счастью, C# не требует резкого перехода на функциональное программирование, поскольку поддерживает как императивный, так и функциональный подход.</span><span class="sxs-lookup"><span data-stu-id="27b7d-168">Fortunately, C# doesn't require the full leap to functional programming, because it supports both imperative and functional programming approaches.</span></span> <span data-ttu-id="27b7d-169">Разработчик может сам выбирать нужный подход в зависимости от конкретного сценария.</span><span class="sxs-lookup"><span data-stu-id="27b7d-169">A developer can choose which approach is most appropriate for a particular scenario.</span></span> <span data-ttu-id="27b7d-170">В действительности в программах часто сочетаются оба стиля.</span><span class="sxs-lookup"><span data-stu-id="27b7d-170">In fact, programs often combine both approaches.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="27b7d-171">См. также</span><span class="sxs-lookup"><span data-stu-id="27b7d-171">See also</span></span>

- [<span data-ttu-id="27b7d-172">Введение в чистые функциональные преобразования (C#)</span><span class="sxs-lookup"><span data-stu-id="27b7d-172">Introduction to Pure Functional Transformations (C#)</span></span>](./introduction-to-pure-functional-transformations.md)
- [<span data-ttu-id="27b7d-173">Преобразования XSLT</span><span class="sxs-lookup"><span data-stu-id="27b7d-173">XSLT Transformations</span></span>](../../../../standard/data/xml/xslt-transformations.md)
- [<span data-ttu-id="27b7d-174">Рефакторинг в чистые функции (C#)</span><span class="sxs-lookup"><span data-stu-id="27b7d-174">Refactoring Into Pure Functions (C#)</span></span>](./refactoring-into-pure-functions.md)
