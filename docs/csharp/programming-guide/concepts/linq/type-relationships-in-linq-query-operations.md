---
title: Отношения между типами в операциях запросов LINQ (C#)
ms.date: 07/20/2015
helpviewer_keywords:
- inferring type information [LINQ in C#]
- data sources [LINQ in C#], type relationships
- queries [LINQ in C#], type relationships
- relationships [LINQ in C#]
- type relationships [LINQ in C#]
- variable relationships [LINQ in C#]
- type information inferred [LINQ in C#]
- data transformations [LINQ in C#]
- LINQ [C#], type relationships
ms.assetid: 99118938-d47c-4d7e-bb22-2657a9f95268
ms.openlocfilehash: b58219a8a4d45ce01f80fd367ed56b13a773e4bc
ms.sourcegitcommit: 155012a8a826ee8ab6aa49b1b3a3b532e7b7d9bd
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/04/2019
ms.locfileid: "66483398"
---
# <a name="type-relationships-in-linq-query-operations-c"></a>Отношения между типами в операциях запросов LINQ (C#)
Для эффективного написания запросов следует понимать, как типы переменных связаны друг с другом в полной операции запроса. Понимание этих связей облегчит усвоение примеров [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] и примеров кода в документации. Более того, можно будет представить, что происходит в фоновом режиме при неявном типизировании переменных с помощью `var`.  
  
 Операции запросов [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] строго типизированы в источнике данных, в самом запросе и при выполнении запроса. Тип переменных в запросе должен быть совместим с типом элементов в источнике данных и с типом переменной итерации в операторе `foreach`. Строгая типизация гарантирует перехват ошибок во время компиляции, когда их можно будет исправить прежде, чем с ними столкнутся пользователи.  
  
 Для демонстрации связи типов большая часть примеров использует явную типизацию для всех переменных. Последний пример показывает применение тех же принципов даже при использовании неявной типизации с помощью [var](../../../../csharp/language-reference/keywords/var.md).  
  
## <a name="queries-that-do-not-transform-the-source-data"></a>Запросы, не выполняющие преобразование исходных данных  
 На следующем рисунке показана операция запроса [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] to Objects, не выполняющая преобразование данных. Источник содержит последовательность строк, результат запроса также является последовательностью строк.  
  
 ![Схема, показывающая отношения между типами данных в запросе LINQ.](./media/type-relationships-in-linq-query-operations/linq-query-data-type-relation.png)  
  
1. Аргумент типа источника данных определяет тип переменной диапазона.  
  
2. Тип выбранного объекта определяет тип переменной запроса. Здесь `name` является строкой. Следовательно, переменная запроса представляет собой `IEnumerable<string>`.  
  
3. Итерация переменной запроса выполняется в операторе `foreach`. Поскольку переменная запроса является последовательностью строк, переменная итерации также является строкой.  
  
## <a name="queries-that-transform-the-source-data"></a>Запросы, выполняющие преобразование исходных данных  
 На следующем рисунке показана операция запроса [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)], выполняющая простое преобразование данных. В качестве входных данных запрос получает последовательность объектов `Customer` и выбирает в результате только свойство `Name`. Поскольку `Name` является строкой, запрос формирует последовательность строк в качестве выходных данных.  
  
 ![Схема, показывающая запрос, преобразующий тип данных.](./media/type-relationships-in-linq-query-operations/linq-query-transform-data-type.png)  
  
1. Аргумент типа источника данных определяет тип переменной диапазона.  
  
2. Оператор `select` возвращает свойство `Name` вместо целого объекта `Customer`. Поскольку `Name` является строкой, аргумент типа `custNameQuery` является `string`, а не `Customer`.  
  
3. Поскольку `custNameQuery` представляет собой последовательность строк, переменная итерации цикла `foreach` также должна быть `string`.  
  
 На следующем рисунке показано немного более сложное преобразование. Оператор `select` возвращает анонимный тип, захватывающий только два члена исходного объекта `Customer`.  
  
 ![Схема, показывающая более сложный запрос, преобразующий тип данных.](./media/type-relationships-in-linq-query-operations/linq-complex-query-transform-data-type.png)  
  
1. Аргумент типа источника данных всегда является типом переменной диапазона в запросе.  
  
2. Так как оператор `select` создает анонимный тип, переменная запроса должна неявно типизирована с помощью `var`.  
  
3. Поскольку тип переменной запроса неявный, переменная итерации в цикле `foreach` также должна быть неявной.  
  
## <a name="letting-the-compiler-infer-type-information"></a>Разрешение компилятору определять сведения о типе  
 Несмотря на то, что необходимо обладать знаниями об отношениях типов в операции запроса, существует возможность передачи выполнения всех действий компилятору. Ключевое слово [var](../../../../csharp/language-reference/keywords/var.md) можно использовать для любой локальной переменной в операции запроса. Следующий рисунок похож на пример 2, рассмотренный выше. Однако компилятор предоставляет строгий тип для каждой переменной в операции запроса.  
  
 ![Схема, показывающая поток для типа с неявной типизацией.](./media/type-relationships-in-linq-query-operations/linq-type-flow-implicit-typing.png)  
  
 Дополнительные сведения о `var` см. в разделе [Неявно типизированные локальные переменные](../../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md).  
