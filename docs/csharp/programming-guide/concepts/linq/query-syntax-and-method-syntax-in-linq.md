---
title: Синтаксис запросов и синтаксис методов в LINQ (C#)
ms.date: 07/20/2015
helpviewer_keywords:
- LINQ [C#], query syntax vs. method syntax
- queries [LINQ in C#], syntax comparisons
ms.assetid: eedd6dd9-fec2-428c-9581-5b8783810ded
ms.openlocfilehash: 17280daaf98010245bbd019652a2a46d7f66ab59
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "75635500"
---
# <a name="query-syntax-and-method-syntax-in-linq-c"></a>Синтаксис запросов и синтаксис методов в LINQ (C#)
Большинство запросов в вводной документации к LINQ написано с использованием декларативного синтаксиса запросов LINQ. Однако синтаксис запроса должен быть преобразован в вызовы методов для среды CLR .NET, когда код компилируется. Эти вызовы метода вызывают стандартные операторы запросов, которые имеют такие имена, как `Where`, `Select`, `GroupBy`, `Join`, `Max` и `Average`. Вместо синтаксиса запросов для их вызова можно использовать синтаксис методов.  
  
 Синтаксис запросов и синтаксис методов семантически идентичны, но многие пользователи найдут синтаксис запросов более простым и более удобным для чтения. Некоторые запросы должны быть выражены как вызовы методов. Например, необходимо использовать вызов метода для выражения запроса, который возвращает число элементов, соответствующих указанным критериям. Вызов метода также необходимо использовать для запроса, который получает элемент с максимальным значением в исходной последовательности. В справочной документации по стандартным операторам запросов в пространствах имен <xref:System.Linq> обычно применяется синтаксис методов. В связи с этим даже на начальном этапе работы с запросами LINQ полезно иметь представление о том, как использовать синтаксис методов в самих запросах и выражениях запросов.  
  
## <a name="standard-query-operator-extension-methods"></a>Методы расширения стандартных операторов запросов  
 В следующем примере показано простое *выражение запроса* и семантически эквивалентный ему запрос, написанный как *запрос, основанный на методе*.  
  
 [!code-csharp[csLINQGettingStarted#22](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQGettingStarted/CS/Class1.cs#22)]  
  
 Оба примера дают одинаковый результат. Видно, что тип переменной запроса в обеих формах одинаковый: <xref:System.Collections.Generic.IEnumerable%601>.  
  
 Чтобы разобраться в запросе, основанном на методе, изучим его более подробно. Обратите внимание на то, что в правой части выражения предложение `where` теперь выражается как метод экземпляра в объекта `numbers`, который, как вы, наверное, помните, имеет тип `IEnumerable<int>`. Если вы знакомы с универсальным интерфейсом <xref:System.Collections.Generic.IEnumerable%601>, то знаете, что в нем отсутствует метод `Where`. При этом, вызвав список завершения IntelliSense в Visual Studio IDE, вы увидите не только метод `Where`, но и многие другие методы, такие как `Select`, `SelectMany`, `Join` и `Orderby`. Все это — стандартные операторы запросов.  
  
 ![Снимок экрана, показывающий все стандартные операторы запросов в Intellisense.](./media/query-syntax-and-method-syntax-in-linq/standard-query-operators.png)  
  
 Может показаться, что класс <xref:System.Collections.Generic.IEnumerable%601> был переопределен и включает дополнительные методы, однако это не так. Стандартные операторы запросов реализуются как новый тип метода, который называется *методы расширения*. Эти методы "расширяют" существующий тип и могут вызываться так, как если бы они являлись методами экземпляра для этого типа. Стандартные операторы запроса расширяют <xref:System.Collections.Generic.IEnumerable%601>, и поэтому вы можете написать `numbers.Where(...)`.  
  
 Чтобы приступить к использованию LINQ, о методах расширения достаточно знать только то, как ввести их в область действия в приложении, используя директивы `using`. С точки зрения приложения метод расширения и обычные методы экземпляров одинаковы.  
  
 Дополнительные сведения о методах расширения см. в разделе [Методы расширения](../../classes-and-structs/extension-methods.md). Дополнительные сведения о стандартных операторах запросов см. в разделе [Общие сведения о стандартных операторах запроса (C#)](./standard-query-operators-overview.md). Некоторые поставщики LINQ, такие как [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] и [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)], помимо <xref:System.Collections.Generic.IEnumerable%601> реализуют собственные стандартные операторы запросов и дополнительные методы расширения для других типов.  
  
## <a name="lambda-expressions"></a>Лямбда-выражения  
 В предыдущем примере обратите внимание на то, что условное выражение (`num % 2 == 0`) передается в метод `Where` как встроенный аргумент: `Where(num => num % 2 == 0).`. Это встроенное выражение называется лямбда-выражением. Это удобный способ написания кода, который иначе пришлось бы записывать более громоздко: как анонимный метод, универсальный метод-делегат или дерево выражения. В C# `=>` представляет собой лямбда-оператор, который читается как "переходит в". `num` слева от оператора — входная переменная, которая соответствует переменной `num` в выражении запроса. Компилятор может вывести тип `num`, поскольку известно, что `numbers` является универсальным типом <xref:System.Collections.Generic.IEnumerable%601>. Тело лямбда-выражения — точно такое же, как выражение в синтаксисе запроса или в любом другом выражении или операторе C#, и может включать вызовы метода и другие сложные логические выражения. "Возвращаемое значение" — результат выражения.  
  
 Чтобы приступить к использованию LINQ, активно использовать лямбда-выражения необязательно. При этом одни запросы могут быть выражены с помощью синтаксиса запроса, в то время как другие требуют лямбда-выражений. После знакомства с лямбда-выражениями станет понятно, что они являются мощными и гибкими элементами в арсенале элементов LINQ. Дополнительные сведения см. в разделе [Лямбда-выражения](../../statements-expressions-operators/lambda-expressions.md).  
  
## <a name="composability-of-queries"></a>Совместимость запросов  
 Обратите внимание на то, что в представленном выше примере кода метод `OrderBy` вызывается с помощью оператора точки при вызове `Where`. `Where` создает отфильтрованную последовательность, а затем `Orderby` ее сортирует. Поскольку запросы возвращают `IEnumerable`, объедините их в синтаксис метода, собрав вызовы методов в цепочку. Компилятор выполняет это действие в фоновом режиме, когда вы пишете запросы, используя синтаксис запросов. А поскольку в переменной запроса результаты запроса не сохраняются, его можно в любое время изменить или использовать как базу для нового запроса даже после выполнения.  
