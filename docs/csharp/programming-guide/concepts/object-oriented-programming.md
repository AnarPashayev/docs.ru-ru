---
title: Объектно ориентированное программирование (C#)
ms.date: 05/13/2020
ms.assetid: 89574786-65ef-4335-88bc-fbacd094f183
ms.openlocfilehash: 83140a9dbd16f60f04f50ba18c71099cdd862f15
ms.sourcegitcommit: 67cf756b033c6173a1bbd1cbd5aef1fccac99e34
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/10/2020
ms.locfileid: "86226638"
---
# <a name="object-oriented-programming-c"></a>Объектно-ориентированное программирование (C#)

C# обеспечивает полную поддержку объектно ориентированного программирования, включая абстракцию, инкапсуляцию, наследование и полиморфизм.

- *Абстракция* означает скрытие ненужных сведений от потребителей типов.
- *Инкапсуляция* означает, что группа связанных свойств, методов и других членов рассматривается как единый элемент или объект.
- *Наследование* описывает возможность создания новых классов на основе существующих классов.
- *Полиморфизм* означает, что можно иметь несколько взаимозаменяемых классов, даже если каждый класс реализует одни и те же свойства или методы разными способами.

## <a name="classes-and-objects"></a>Классы и объекты

Термины *класс* и *объект* описывают *тип* объектов и *экземпляры* классов, соответственно. Поэтому процесс создания объекта называется *созданием экземпляра*. Если использовать сравнение с чертежом, то класс является чертежом, а объект является зданием, построенным по нему.

Определение класса:

```csharp
class SampleClass
{
}
```

C# также предоставляет типы, называемые *структурами*, которые удобно использовать, когда не требуется поддержка наследования или полиморфизма. Дополнительные сведения см. в статье [Выбор между классом и структурой](../../../standard/design-guidelines/choosing-between-class-and-struct.md).

Определение структуры:

```csharp
struct SampleStruct
{
}
```

Дополнительные сведения см. в статьях, посвященных ключевым словам [class](../../language-reference/keywords/class.md) и [struct](../../language-reference/builtin-types/struct.md).

### <a name="class-members"></a>Члены класса

Каждый класс может состоять из различных *членов класса*, которые содержат свойства, описывающие данные класса, методы, задающие поведение класса, и события, обеспечивающие связь между различными классами и объектами.

#### <a name="properties-and-fields"></a>Свойства и поля

Поля и свойства представляют сведения, содержащиеся в объекте. Поля подобны переменным в том, что их можно прочитать или изменить напрямую с использованием применимых модификаторов доступа.

Определение поля, доступ к которому можно получить из экземпляров класса:

```csharp
public class SampleClass
{
    string sampleField;
}
```

Для работы со свойствами используются методы доступа `get` и `set`, которые расширяют возможности управления способом задания и возврата значений.

В языке C# для хранения значения свойства можно создать частное поле (private) или использовать автоматически реализуемые свойства, которые автоматически создают такое поле и обеспечивают базовую логику для процедур свойств.

Определение автоматически реализуемого свойства:

```csharp
class SampleClass
{
    public int SampleProperty { get; set; }
}
```

Если требуется выполнить дополнительные операции чтения и записи применительно к значению свойства, определите поле для хранения значения свойства и затем реализуйте базовую логику для хранения и извлечения этого значения:

```csharp
class SampleClass
{
    private int _sample;
    public int Sample
    {
        // Return the value stored in a field.
        get => _sample;
        // Store the value in the field.
        set =>  _sample = value;
    }
}
```

У большинства свойств есть методы или процедуры для задания и возврата значения свойства. Однако можно создать свойства, доступные только для чтения или только на запись, чтобы запретить изменение или чтение значений свойств. В C# можно опустить метод свойства `get` или `set`. Следует отметить, что автоматически реализуемые свойства не могут быть доступными только для записи. Автоматически реализуемые свойства, доступные только для чтения, можно задать в конструкторах содержащего класса.

Дополнительные сведения можно найти в разделе

- [get](../../language-reference/keywords/get.md)
- [set](../../language-reference/keywords/set.md)

#### <a name="methods"></a>Методы

Действие, которое выполняет объект, называется *методом*.

Определение метода класса:

```csharp
class SampleClass
{
    public int SampleMethod(string sampleParam)
    {
        // Insert code here
    }
}
```

Класс может иметь несколько реализаций или *перегрузок* одного и того же метода, которые отличаются от других числом или типами параметров.

Перегрузка метода:

```csharp
public int SampleMethod(string sampleParam) { }
public int SampleMethod(int sampleParam) { }
```

Как правило, метод объявляется при определении класса. Однако C# также поддерживает *методы расширения*, которые позволяют добавлять методы в существующий класс вне определения класса.

Дополнительные сведения можно найти в разделе

- [Методы](../classes-and-structs/methods.md)
- [Методы расширения](../classes-and-structs/extension-methods.md)

#### <a name="constructors"></a>Конструкторы

Конструкторы — это методы классов, выполняемые автоматически при создании объекта заданного типа. Обычно конструкторы выполняют инициализацию членов данных нового объекта. Конструктор можно запустить только один раз при создании класса. Кроме того, код конструктора всегда выполняется раньше всех остальных частей кода в классе. Следует отметить, что так же, как и для других методов, можно создать несколько перегрузок конструктора.

Определение конструктора для класса:

```csharp
public class SampleClass
{
    public SampleClass()
    {
        // Add code here
    }
}
```

Дополнительные сведения см. в разделе [Конструкторы](../classes-and-structs/constructors.md).

#### <a name="finalizers"></a>Методы завершения

Метод завершения используется для уничтожения экземпляров классов. На платформе .NET сборщик мусора автоматически управляет распределением и освобождением памяти для управляемых объектов приложения. Однако для очистки неуправляемых ресурсов, создаваемых приложением, могут потребоваться методы завершения. На один класс допускается только один метод завершения.

Дополнительные сведения о методах завершения и сборке мусора в .NET см. в статье [Сборка мусора](../../../standard/garbage-collection/index.md).

#### <a name="events"></a>События

События позволяют классу или объекту уведомлять другие классы или объекты о возникновении каких-либо ситуаций. Класс, отправляющий (или порождающий) событие, называется *издателем*, а классы, принимающие (или обрабатывающие) событие, называются *подписчиками*. Дополнительные сведения о том, как порождаются и обрабатываются события, см. в разделе [События](../../../standard/events/index.md).

- Чтобы объявить событие в классе, используйте ключевое слово [event](../../language-reference/keywords/event.md).
- Чтобы породить событие, вызовите делегат события.
- Чтобы подписаться на событие, используйте оператор `+=`. Чтобы отменить подписку на событие, воспользуйтесь оператором `-=`.

#### <a name="nested-classes"></a>Вложенные классы

Класс, определенный внутри другого класса, называется *вложенным*. По умолчанию вложенный класс является частным.

```csharp
class Container
{
    class Nested
    {
        // Add code here.
    }
}
```

Чтобы создать экземпляр вложенного класса, укажите имя класса контейнера и имя вложенного класса, используя в качестве разделителя точку:

```csharp
Container.Nested nestedInstance = new Container.Nested()
```

### <a name="access-modifiers-and-access-levels"></a>Модификаторы доступа и уровни доступа

С помощью *модификаторов доступа* все классы и члены классов могут указывать уровни доступа, предоставляемые другим классам.

Имеющиеся модификаторы доступа указаны в следующей таблице.

| Модификатор C# | Определение |
|--|--|
| [public](../../language-reference/keywords/public.md) | Доступ к типу или члену возможен из любого другого кода в той же сборке или другой сборке, ссылающейся на него. |
| [private](../../language-reference/keywords/private.md) | Доступ к типу или члену можно получить только из кода в том же классе. |
| [protected](../../language-reference/keywords/protected.md) | Доступ к типу или члену можно получить только из кода в том же классе или в производном классе. |
| [internal](../../language-reference/keywords/internal.md) | Доступ к типу или члену возможен из любого кода в той же сборке, но не из другой сборки. |
| [protected internal](../../language-reference/keywords/protected-internal.md) | Доступ к типу или члену возможен из любого кода в той же сборке, или из производного класса в другой сборке. |
| [private protected](../../language-reference/keywords/private-protected.md) | Доступ к типу или члену можно получить из кода в том же классе или в производном классе в сборке базового класса. |

Дополнительные сведения см. в статье [Модификаторы доступа](../classes-and-structs/access-modifiers.md).

### <a name="instantiating-classes"></a>Создание экземпляров классов

Чтобы создать объект, необходимо создать экземпляр класса.

```csharp
SampleClass sampleObject = new SampleClass();
```

После создания экземпляра класса можно присваивать значения свойствам и полям экземпляра и вызывать методы класса.

```csharp
// Set a property value.
sampleObject.sampleProperty = "Sample String";
// Call a method.
sampleObject.SampleMethod();
```

Чтобы назначить значения свойствам в процессе создания экземпляра класса, используйте инициализаторы объектов:

```csharp
// Set a property value.
var sampleObject = new SampleClass
{
    FirstProperty = "A",
    SecondProperty = "B"
};
```

Дополнительные сведения можно найти в разделе

- [Оператор new](../../language-reference/operators/new-operator.md)
- [Инициализаторы объектов и коллекций](../classes-and-structs/object-and-collection-initializers.md)

### <a name="static-classes-and-members"></a>статические классы и их члены;

Статический член класса — это свойство, процедура или поле, которое совместно используется всеми экземплярами класса.

Определение статического члена

```csharp
static class SampleClass
{
    public static string SampleString = "Sample String";
}
```

Чтобы получить доступ к статическому члену, используйте имя класса без создания объекта этого класса:

```csharp
Console.WriteLine(SampleClass.SampleString);
```

Статические классы в C# имеют только статические члены и не могут быть созданы. Статические члены также не могут обращаться к нестатическим свойствам, полям или методам.

Дополнительные сведения см. в разделе [static](../../language-reference/keywords/static.md).

### <a name="anonymous-types"></a>Анонимные типы

Анонимные типы позволяют создавать объекты без написания определения класса для типа данных. Вместо этого компилятор создает класс для вас. Данный класс не имеет имени и содержит свойства, которые указаны при объявлении объекта.

Создание экземпляра анонимного типа:

```csharp
// sampleObject is an instance of a simple anonymous type.
var sampleObject = new
{
    FirstProperty = "A",
    SecondProperty = "B"
};
```

Дополнительные сведения можно найти в разделе  [Анонимные типы](../classes-and-structs/anonymous-types.md).

## <a name="inheritance"></a>Наследование

Наследование позволяет создавать новые классы, которые повторно используют, расширяют и изменяют поведение, определенное в другом классе. Класс, члены которого наследуются, называется *базовым классом*, а класс, который наследует эти члены, называется *производным классом*. Следует учитывать, что все классы в C# неявно наследуются от класса <xref:System.Object>, который поддерживает иерархию классов .NET и предоставляет низкоуровневые службы для всех классов.

> [!NOTE]
> C# не поддерживает множественное наследование. То есть можно указать только один базовый класс для производного класса.

Наследование от базового класса:

```csharp
class DerivedClass:BaseClass { }
```

По умолчанию унаследовать класс можно от любого класса. Однако можно указать, должен ли класс использоваться в качестве базового класса, или создать класс, который может использоваться только в качестве базового.

Указание, что класс не может использоваться в качестве базового класса:

```csharp
public sealed class A { }
```

Указание, что класс может использоваться только в качестве базового класса и нельзя создать экземпляр этого класса:

```csharp
public abstract class B { }
```

Дополнительные сведения можно найти в разделе

- [sealed](../../language-reference/keywords/sealed.md)
- [abstract](../../language-reference/keywords/abstract.md)

### <a name="overriding-members"></a>переопределение членов;

По умолчанию производный класс наследует все члены от своего базового класса. Если необходимо изменить поведение унаследованного члена, необходимо переопределить его. Т. е. в производном классе можно определить новую реализацию метода, свойства или события.

Следующие модификаторы используются для управления переопределением свойств и методов.

| Модификатор C# | Определение |
|--|--|
| [virtual](../../language-reference/keywords/virtual.md) | Разрешает переопределение члена класса в производном классе. |
| [override](../../language-reference/keywords/override.md) | Переопределяет виртуальный (переопределяемый) член в базовом классе. |
| [abstract](../../language-reference/keywords/abstract.md) | Требует, чтобы член класса был переопределен в производном классе. |
| [Модификатор new](../../language-reference/keywords/new-modifier.md) | Скрывает член, наследуемый от базового класса |

## <a name="interfaces"></a>Интерфейсы

Интерфейсы, как и классы, определяют набор свойств, методов и событий. Но, в отличие от классов, интерфейсы не предоставляют реализацию. Они реализуются классами, но определяются как отдельные от классов сущности. Интерфейс представляет собой контракт, в котором класс, реализующий интерфейс, должен реализовывать каждый аспект этого интерфейса в точном соответствии с его определением.

Определение интерфейса:

```csharp
interface ISampleInterface
{
    void DoSomething();
}
```

Реализация интерфейса в классе:

```csharp
class SampleClass : ISampleInterface
{
    void ISampleInterface.DoSomething()
    {
        // Method implementation.
    }
}
```

Дополнительные сведения см. в разделе руководства по программированию, посвященного [интерфейсам](../interfaces/index.md), и в статье справочника по языку, посвященной ключевому слову [interface](../../language-reference/keywords/interface.md).

## <a name="generics"></a>Универсальные шаблоны

Классы, структуры, интерфейсы и методы на платформе .NET могут иметь *параметры типа*, которые определяют типы объектов, которые они могут хранить или использовать. Наиболее распространенным примером универсального шаблона является коллекция, в которой можно указать тип объектов, которые могут в ней храниться.

Определение универсального класса:

```csharp
public class SampleGeneric<T>
{
    public T Field;
}
```

Создание экземпляра универсального класса:

```csharp
var sampleObject = new SampleGeneric<string>();
sampleObject.Field = "Sample string";
```

Дополнительные сведения можно найти в разделе

- [Универсальные шаблоны в .NET](../../../standard/generics/index.md)
- [Универсальные шаблоны. Руководство по программированию на C#](../generics/index.md)

## <a name="delegates"></a>Делегаты

*Делегат* — это тип, который определяет сигнатуру метода и может обеспечивать связь с любым методом с совместимой сигнатурой. Метод можно запустить (или вызвать) с помощью делегата. Делегаты используются для передачи методов в качестве аргументов к другим методам.

> [!NOTE]
> Обработчики событий — это ничто иное, как методы, вызываемые с помощью делегатов. Дополнительные сведения об использовании делегатов при обработке событий см. в разделе [События](../../../standard/events/index.md).

Создание делегата:

```csharp
public delegate void SampleDelegate(string str);
```

Создание ссылки на метод, сигнатура которого соответствует сигнатуре, указанной делегатом:

```csharp
class SampleClass
{
    // Method that matches the SampleDelegate signature.
    public static void SampleMethod(string message)
    {
        // Add code here.
    }

    // Method that instantiates the delegate.
    void SampleDelegate()
    {
        SampleDelegate sd = sampleMethod;
        sd("Sample string");
    }
}
```

Дополнительные сведения см. в разделе руководства по программированию, посвященного [делегатам](../delegates/index.md), и в статье справочника по языку, посвященной ключевому слову [delegate](../../language-reference/builtin-types/reference-types.md).

## <a name="see-also"></a>См. также

- [Руководство по программированию на C#](../index.md)
