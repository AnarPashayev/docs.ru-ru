---
title: Асинхронный доступ к файлам (C#)
description: Узнайте, как использовать функцию Async для доступа к файлам в C#. Можно вызывать асинхронные методы, не прибегая к использованию обратных вызовов или разделению кода между методами.
ms.date: 08/19/2020
ms.assetid: bb018fea-5313-4c80-ab3f-7c24b2145bd9
ms.openlocfilehash: 9a8db6004e8fff2cb39f0c350b403b56ea619e54
ms.sourcegitcommit: 9c45035b781caebc63ec8ecf912dc83fb6723b1f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/25/2020
ms.locfileid: "88812046"
---
# <a name="asynchronous-file-access-c"></a>Асинхронный доступ к файлам (C#)

Для доступа к файлам можно использовать функцию Async. При использовании функции Async вы можете вызывать асинхронные методы без использования обратных вызовов или разделения вашего кода на множество методов или лямбда-выражений. Для выполнения последовательного кода асинхронно просто вызовите асинхронный метод вместо синхронного метода и добавьте несколько ключевых слов в код.

Можно рассмотреть следующие причины для добавления асинхронности для вызовов для доступа к файлам.

> [!div class="checklist"]
>
> - Асинхронность делает приложения пользовательского интерфейса более отзывчивыми, потому что поток пользовательского интерфейса, который запускает операцию, может продолжать выполнять и другую работу. Если поток пользовательского интерфейса должен выполнять код, который занимает много времени (например, более 50 миллисекунд), пользовательский интерфейс можно приостановить до тех пор, пока не будет завершен ввод-вывод, и затем пользовательский интерфейс сможет снова обрабатывать ввод с клавиатуры, мыши и другие события.
> - Асинхронность улучшает масштабируемость ASP.NET и других серверных приложений за счет уменьшения необходимости использования потоков. Если приложение использует выделенный поток на ответ и тысяча запросов приходит одновременно, тысяча потоков не потребуется. Асинхронные операции часто не нуждаются в пользовании потоком во время ожидания. Они пользуются существующим потоком завершения ввода-вывода короткое время в конце.
> - Задержка операции доступа к файлу может быть очень низкой при текущих условиях, но может значительно увеличиться в будущем. Например, файл может быть перемещен на сервер через Интернет.
> - Добавленные издержки при использовании функции Async являются малыми.
> - Асинхронные задачи могут легко выполняться параллельно.

## <a name="use-appropriate-classes"></a>Использование соответствующих классов

В простых примерах в этом разделе демонстрируются <xref:System.IO.File.WriteAllTextAsync%2A?displayProperty=nameWithType> и <xref:System.IO.File.ReadAllTextAsync%2A?displayProperty=nameWithType>. Для конечного контроля над операциями файлового ввода-вывода используйте класс <xref:System.IO.FileStream>, содержащий параметр, который вызывает асинхронный ввод-вывод на уровне операционной системы. С помощью этого параметра можно избежать блокирования пула потоков во многих случаях. Чтобы включить этот параметр, необходимо добавить в вызов конструктора аргумент `useAsync=true` или `options=FileOptions.Asynchronous`.

Этот параметр нельзя использовать с классами <xref:System.IO.StreamReader> и <xref:System.IO.StreamWriter>, если вы открываете их напрямую (указав путь к файлу). При этом параметр можно использовать, если им предоставлен <xref:System.IO.Stream>, открытый классом <xref:System.IO.FileStream>. Асинхронные вызовы выполняются быстрее в приложениях пользовательского интерфейса, даже если поток в пуле потоков блокирован, поскольку поток пользовательского интерфейса не блокирован во время ожидания.

## <a name="write-text"></a>Запись текста

Следующие примеры записывают текст в файл. На каждой точке await происходит немедленный выход из метода. После завершения файлового ввода-вывода метод возобновляет работу с пункта, следующего за await. Модификатор async в определении методов требует наличия await в теле метода.

### <a name="simple-example"></a>Простой пример

:::code language="csharp" source="snippets/file-access/Program.cs" id="SimpleWrite":::

### <a name="finite-control-example"></a>Пример конечного элемента управления

:::code language="csharp" source="snippets/file-access/Program.cs" id="WriteText":::

Первоначальная строка с оператором `await sourceStream.WriteAsync(encodedText, 0, encodedText.Length);` является сокращенной формой записи двух следующих операторов:

```csharp
Task theTask = sourceStream.WriteAsync(encodedText, 0, encodedText.Length);
await theTask;
```

Первый оператор возвращает задачу и вызывает запуск обработки файла. Вторая строка с await немедленно оставляет метод и возвращается в другую задачу. При окончании обработки файла выполнение возвращается в точку выполнения, которая следует за await.

## <a name="read-text"></a>Чтение текста

Следующий пример считывает текст из файла.

### <a name="simple-example"></a>Простой пример

:::code language="csharp" source="snippets/file-access/Program.cs" id="SimpleRead":::

### <a name="finite-control-example"></a>Пример конечного элемента управления

Текст добавляется в буфер обмена, а затем, в данном случае, помещается в <xref:System.Text.StringBuilder>. В отличие от предыдущего примера await выдаёт в результате значение. Метод <xref:System.IO.Stream.ReadAsync%2A> возвращает <xref:System.Threading.Tasks.Task>\<<xref:System.Int32>>, поэтому по завершении операции оценка await выдает значение `Int32` `numRead`. Дополнительные сведения см. в разделе [Асинхронные типы возвращаемых значений (C#)](async-return-types.md).

:::code language="csharp" source="snippets/file-access/Program.cs" id="ReadText":::

## <a name="parallel-asynchronous-io"></a>Параллельный асинхронный ввод-вывод

В следующем примере показана параллельная обработка при записи 10 текстовых файлов.

### <a name="simple-example"></a>Простой пример

:::code language="csharp" source="snippets/file-access/Program.cs" id="SimpleParallelWrite":::

### <a name="finite-control-example"></a>Пример конечного элемента управления

Для каждого файла метод <xref:System.IO.Stream.WriteAsync%2A> возвращает задачу, которая затем добавляется в список задач. Оператор `await Task.WhenAll(tasks);` существует и возобновляется в методе, как только завершается обработка файла для всех задач.

Пример закрывает все экземпляры <xref:System.IO.FileStream> в блоке `finally` после завершения всех задач. Если бы вместо этого каждый `FileStream` был бы создан в операторе `using`, то `FileStream` можно было бы удалить до завершения задачи.

Любое увеличение производительности зависит почти полностью от параллельной, а не асинхронной обработки. Преимущества асинхронности в том, что она не привязана к количеству потоков и не связана с потоком пользовательского интерфейса.

:::code language="csharp" source="snippets/file-access/Program.cs" id="ParallelWriteText":::

При использовании методов <xref:System.IO.Stream.WriteAsync%2A> и <xref:System.IO.Stream.ReadAsync%2A> можно указать <xref:System.Threading.CancellationToken>, который позволяет отменить операцию в середине потока. Подробные сведения см. в статье [Отмена в управляемых потоках](../../../../standard/threading/cancellation-in-managed-threads.md).

## <a name="see-also"></a>См. также раздел

- [Асинхронное программирование с использованием ключевых слов Async и Await (C#)](index.md)
- [Типы возвращаемых значений асинхронных операций (C#)](async-return-types.md)
