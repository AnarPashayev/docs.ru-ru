---
title: Асинхронное программирование на C#
description: Общие сведения о языковой поддержке асинхронного программирования в C# с помощью async, await, задач и Task<T>
ms.date: 05/26/2020
ms.openlocfilehash: 703392ca6ba4e6fb08dd8a88817babc167394788
ms.sourcegitcommit: 03fec33630b46e78d5e81e91b40518f32c4bd7b5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/27/2020
ms.locfileid: "84007966"
---
# <a name="asynchronous-programming-with-async-and-await"></a><span data-ttu-id="386fa-103">Асинхронное программирование с использованием ключевых слов async и await</span><span class="sxs-lookup"><span data-stu-id="386fa-103">Asynchronous programming with async and await</span></span>

<span data-ttu-id="386fa-104">[Модель асинхронного программирования на основе задач (TAP)](task-asynchronous-programming-model.md) предоставляет абстракцию асинхронного кода.</span><span class="sxs-lookup"><span data-stu-id="386fa-104">The [Task asynchronous programming model (TAP)](task-asynchronous-programming-model.md) provides an abstraction over asynchronous code.</span></span> <span data-ttu-id="386fa-105">Вы пишете код как последовательность операторов, как обычно.</span><span class="sxs-lookup"><span data-stu-id="386fa-105">You write code as a sequence of statements, just like always.</span></span> <span data-ttu-id="386fa-106">Вы можете читать этот код, как если бы каждая инструкция завершалась до начала следующей.</span><span class="sxs-lookup"><span data-stu-id="386fa-106">You can read that code as though each statement completes before the next begins.</span></span> <span data-ttu-id="386fa-107">Компилятор выполняет ряд преобразований, так как некоторые из этих инструкций могут начать работу и вернуть <xref:System.Threading.Tasks.Task>, представляющий текущую работу.</span><span class="sxs-lookup"><span data-stu-id="386fa-107">The compiler performs a number of transformations because some of those statements may start work and return a <xref:System.Threading.Tasks.Task> that represents the ongoing work.</span></span>

<span data-ttu-id="386fa-108">Это и есть цель такого синтаксиса: сделать возможным код, который читается как последовательность операторов, но выполняется в гораздо более сложном порядке на основе выделения внешних ресурсов и при завершении задач.</span><span class="sxs-lookup"><span data-stu-id="386fa-108">That's the goal of this syntax: enable code that reads like a sequence of statements, but executes in a much more complicated order based on external resource allocation and when tasks complete.</span></span> <span data-ttu-id="386fa-109">Это аналогично тому, как люди дают инструкции для процессов, которые включают асинхронные задачи.</span><span class="sxs-lookup"><span data-stu-id="386fa-109">It's analogous to how people give instructions for processes that include asynchronous tasks.</span></span> <span data-ttu-id="386fa-110">В этой статье вы будете использовать пример инструкции для приготовления завтрака, чтобы увидеть, как ключевые слова `async` и `await` упрощают понимание кода, который включает в себя серию асинхронных инструкций.</span><span class="sxs-lookup"><span data-stu-id="386fa-110">Throughout this article, you'll use an example of instructions for making a breakfast to see how the `async` and `await` keywords make it easier to reason about code, that includes a series of asynchronous instructions.</span></span> <span data-ttu-id="386fa-111">Можно написать инструкции аналогично следующему списку, чтобы объяснить, как приготовить завтрак.</span><span class="sxs-lookup"><span data-stu-id="386fa-111">You'd write the instructions something like the following list to explain how to make a breakfast:</span></span>

1. <span data-ttu-id="386fa-112">Налить чашку кофе.</span><span class="sxs-lookup"><span data-stu-id="386fa-112">Pour a cup of coffee.</span></span>
1. <span data-ttu-id="386fa-113">Нагреть сковородку, а затем поджарить два яйца.</span><span class="sxs-lookup"><span data-stu-id="386fa-113">Heat up a pan, then fry two eggs.</span></span>
1. <span data-ttu-id="386fa-114">Поджарить три куска бекона.</span><span class="sxs-lookup"><span data-stu-id="386fa-114">Fry three slices of bacon.</span></span>
1. <span data-ttu-id="386fa-115">Сделать два тоста.</span><span class="sxs-lookup"><span data-stu-id="386fa-115">Toast two pieces of bread.</span></span>
1. <span data-ttu-id="386fa-116">Намазать тосты маслом и джемом.</span><span class="sxs-lookup"><span data-stu-id="386fa-116">Add butter and jam to the toast.</span></span>
1. <span data-ttu-id="386fa-117">Налить стакан апельсинового сока.</span><span class="sxs-lookup"><span data-stu-id="386fa-117">Pour a glass of orange juice.</span></span>

<span data-ttu-id="386fa-118">Если у вас есть кулинарный опыт, вы бы выполняли эти инструкции **асинхронно**.</span><span class="sxs-lookup"><span data-stu-id="386fa-118">If you have experience with cooking, you'd execute those instructions **asynchronously**.</span></span> <span data-ttu-id="386fa-119">Сначала вы бы поставили сковородку на огонь, а затем занялись бы беконом.</span><span class="sxs-lookup"><span data-stu-id="386fa-119">You'd start warming the pan for eggs, then start the bacon.</span></span> <span data-ttu-id="386fa-120">Потом бы поставили тосты, а вслед за этим принялись бы за яичницу.</span><span class="sxs-lookup"><span data-stu-id="386fa-120">You'd put the bread in the toaster, then start the eggs.</span></span> <span data-ttu-id="386fa-121">На каждом этапе процесса необходимо запустить задачу, а затем обратить внимание на другие задачи, которые требуют вашего внимания.</span><span class="sxs-lookup"><span data-stu-id="386fa-121">At each step of the process, you'd start a task, then turn your attention to tasks that are ready for your attention.</span></span>

<span data-ttu-id="386fa-122">Приготовление завтрака представляет собой хороший пример асинхронной непараллельной работы.</span><span class="sxs-lookup"><span data-stu-id="386fa-122">Cooking breakfast is a good example of asynchronous work that isn't parallel.</span></span> <span data-ttu-id="386fa-123">Один пользователь (или поток) может обрабатывать все эти задачи.</span><span class="sxs-lookup"><span data-stu-id="386fa-123">One person (or thread) can handle all these tasks.</span></span> <span data-ttu-id="386fa-124">Продолжая аналогию с завтраком, один человек может приготовить завтрак асинхронно путем запуска очередной задачи до завершения предыдущей.</span><span class="sxs-lookup"><span data-stu-id="386fa-124">Continuing the breakfast analogy, one person can make breakfast asynchronously by starting the next task before the first completes.</span></span> <span data-ttu-id="386fa-125">Готовка продолжается вне зависимости от того, следит ли за ней кто-либо.</span><span class="sxs-lookup"><span data-stu-id="386fa-125">The cooking progresses whether or not someone is watching it.</span></span> <span data-ttu-id="386fa-126">Как только вы начали греть сковороду для яичницы, можно заняться обжаркой бекона.</span><span class="sxs-lookup"><span data-stu-id="386fa-126">As soon as you start warming the pan for the eggs, you can begin frying the bacon.</span></span> <span data-ttu-id="386fa-127">Когда бекон будет жариться, можно поместить хлеб в тостер.</span><span class="sxs-lookup"><span data-stu-id="386fa-127">Once the bacon starts, you can put the bread into the toaster.</span></span>

<span data-ttu-id="386fa-128">Для параллельного алгоритма потребовалось бы несколько поваров (или потоков).</span><span class="sxs-lookup"><span data-stu-id="386fa-128">For a parallel algorithm, you'd need multiple cooks (or threads).</span></span> <span data-ttu-id="386fa-129">Один готовит яйца, один — бекон и т. д.</span><span class="sxs-lookup"><span data-stu-id="386fa-129">One would make the eggs, one the bacon, and so on.</span></span> <span data-ttu-id="386fa-130">Каждый из них будет заниматься только одной задачей.</span><span class="sxs-lookup"><span data-stu-id="386fa-130">Each one would be focused on just that one task.</span></span> <span data-ttu-id="386fa-131">Каждый повар (или поток) будет заблокирован синхронным ожиданием готовности бекона или тостов.</span><span class="sxs-lookup"><span data-stu-id="386fa-131">Each cook (or thread) would be blocked synchronously waiting for bacon to be ready to flip, or the toast to pop.</span></span>

<span data-ttu-id="386fa-132">Теперь рассмотрим эти же инструкции, написанные на C#.</span><span class="sxs-lookup"><span data-stu-id="386fa-132">Now, consider those same instructions written as C# statements:</span></span>

:::code language="csharp" source="snippets/index/AsyncBreakfast-starter/Program.cs" highlight="8-27":::

> [!NOTE]
> <span data-ttu-id="386fa-133">Классы `Coffee`, `Egg`, `Bacon`, `Toast` и `Juice` пусты.</span><span class="sxs-lookup"><span data-stu-id="386fa-133">The `Coffee`, `Egg`, `Bacon`, `Toast`, and `Juice` classes are empty.</span></span> <span data-ttu-id="386fa-134">Они просто являются классами меток, используемыми в целях демонстрации, не содержат свойств и не используются для выполнения других задач.</span><span class="sxs-lookup"><span data-stu-id="386fa-134">They are simply marker classes for the purpose of demonstration, contain no properties, and serve no other purpose.</span></span>

<span data-ttu-id="386fa-135">Компьютеры не рассматривают эти инструкции так же, как люди.</span><span class="sxs-lookup"><span data-stu-id="386fa-135">Computers don't interpret those instructions the same way people do.</span></span> <span data-ttu-id="386fa-136">Компьютер будет задерживаться над каждой инструкцией до момента, когда работа будет завершена, прежде чем перейдет к следующему оператору.</span><span class="sxs-lookup"><span data-stu-id="386fa-136">The computer will block on each statement until the work is complete before moving on to the next statement.</span></span> <span data-ttu-id="386fa-137">Вряд ли такой завтрак вас устроит.</span><span class="sxs-lookup"><span data-stu-id="386fa-137">That creates an unsatisfying breakfast.</span></span> <span data-ttu-id="386fa-138">Более поздние задачи не будут начаты до завершения предыдущих.</span><span class="sxs-lookup"><span data-stu-id="386fa-138">The later tasks wouldn't be started until the earlier tasks had completed.</span></span> <span data-ttu-id="386fa-139">Потребуется гораздо больше времени для приготовления завтрака, к тому же часть уже остынет еще до подачи.</span><span class="sxs-lookup"><span data-stu-id="386fa-139">It would take much longer to create the breakfast, and some items would have gotten cold before being served.</span></span>

<span data-ttu-id="386fa-140">Если требуется, чтобы компьютер асинхронно выполнил инструкции выше, необходимо писать асинхронный код.</span><span class="sxs-lookup"><span data-stu-id="386fa-140">If you want the computer to execute the above instructions asynchronously, you must write asynchronous code.</span></span>

<span data-ttu-id="386fa-141">Эти проблемы важны для программ, которые вы пишете уже сегодня.</span><span class="sxs-lookup"><span data-stu-id="386fa-141">These concerns are important for the programs you write today.</span></span> <span data-ttu-id="386fa-142">При написании клиентских программ требуется, чтобы пользовательский интерфейс реагировал на ввод данных пользователем.</span><span class="sxs-lookup"><span data-stu-id="386fa-142">When you write client programs, you want the UI to be responsive to user input.</span></span> <span data-ttu-id="386fa-143">Приложения не должны блокировать телефон при скачивании данных из Интернета.</span><span class="sxs-lookup"><span data-stu-id="386fa-143">Your application shouldn't make a phone appear frozen while it's downloading data from the web.</span></span> <span data-ttu-id="386fa-144">При написании серверных программ не стоит блокировать потоки.</span><span class="sxs-lookup"><span data-stu-id="386fa-144">When you write server programs, you don't want threads blocked.</span></span> <span data-ttu-id="386fa-145">Эти потоки могут обслуживать другие запросы.</span><span class="sxs-lookup"><span data-stu-id="386fa-145">Those threads could be serving other requests.</span></span> <span data-ttu-id="386fa-146">Использование синхронного кода в ситуации, когда существуют асинхронные альтернативы, мешает масштабированию с минимальными затратами.</span><span class="sxs-lookup"><span data-stu-id="386fa-146">Using synchronous code when asynchronous alternatives exist hurts your ability to scale out less expensively.</span></span> <span data-ttu-id="386fa-147">Вы платите за эти заблокированные потоки.</span><span class="sxs-lookup"><span data-stu-id="386fa-147">You pay for those blocked threads.</span></span>

<span data-ttu-id="386fa-148">Успешные современные приложения требуют использования асинхронного кода.</span><span class="sxs-lookup"><span data-stu-id="386fa-148">Successful modern applications require asynchronous code.</span></span> <span data-ttu-id="386fa-149">Без поддержки языком при написании асинхронного кода требуются обратные вызовы, события завершения или другие способы, заслоняющие исходное назначение кода.</span><span class="sxs-lookup"><span data-stu-id="386fa-149">Without language support, writing asynchronous code required callbacks, completion events, or other means that obscured the original intent of the code.</span></span> <span data-ttu-id="386fa-150">Синхронный код удобен тем, что он довольно прост.</span><span class="sxs-lookup"><span data-stu-id="386fa-150">The advantage of the synchronous code is that it's easy to understand.</span></span> <span data-ttu-id="386fa-151">Пошаговые действия упрощают чтение и понимание.</span><span class="sxs-lookup"><span data-stu-id="386fa-151">The step-by-step actions make it easy to scan and understand.</span></span> <span data-ttu-id="386fa-152">Традиционные асинхронные модели заставляют сосредоточиваться на асинхронности кода, а не на фундаментальных действиях в нем.</span><span class="sxs-lookup"><span data-stu-id="386fa-152">Traditional asynchronous models forced you to focus on the asynchronous nature of the code, not on the fundamental actions of the code.</span></span>

## <a name="dont-block-await-instead"></a><span data-ttu-id="386fa-153">Не блокировать, а использовать await</span><span class="sxs-lookup"><span data-stu-id="386fa-153">Don't block, await instead</span></span>

<span data-ttu-id="386fa-154">Приведенный выше код демонстрирует дурную практику: использование синхронного кода для выполнения асинхронных операций.</span><span class="sxs-lookup"><span data-stu-id="386fa-154">The preceding code demonstrates a bad practice: constructing synchronous code to perform asynchronous operations.</span></span> <span data-ttu-id="386fa-155">В таком виде код блокирует выполняющий поток, не позволяя делать другие действия.</span><span class="sxs-lookup"><span data-stu-id="386fa-155">As written, this code blocks the thread executing it from doing any other work.</span></span> <span data-ttu-id="386fa-156">Он не будет прерван, пока задачи выполняются.</span><span class="sxs-lookup"><span data-stu-id="386fa-156">It won't be interrupted while any of the tasks are in progress.</span></span> <span data-ttu-id="386fa-157">Все равно что стоять и смотреть на тостер, пока поджаривается хлеб.</span><span class="sxs-lookup"><span data-stu-id="386fa-157">It would be as though you stared at the toaster after putting the bread in.</span></span> <span data-ttu-id="386fa-158">Пока тост не готов, вы всех игнорируете.</span><span class="sxs-lookup"><span data-stu-id="386fa-158">You'd ignore anyone talking to you until the toast popped.</span></span>

<span data-ttu-id="386fa-159">Давайте начнем менять этот код, чтобы не блокировать поток во время выполнения задачи.</span><span class="sxs-lookup"><span data-stu-id="386fa-159">Let's start by updating this code so that the thread doesn't block while tasks are running.</span></span> <span data-ttu-id="386fa-160">Ключевое слово `await` позволяет обойтись без блокировки для запуска задачи, а затем продолжить выполнение, когда задача завершается.</span><span class="sxs-lookup"><span data-stu-id="386fa-160">The `await` keyword provides a non-blocking way to start a task, then continue execution when that task completes.</span></span> <span data-ttu-id="386fa-161">Простая асинхронная версия кода для приготовления завтрака будет выглядеть так:</span><span class="sxs-lookup"><span data-stu-id="386fa-161">A simple asynchronous version of the make a breakfast code would look like the following snippet:</span></span>

:::code language="csharp" source="snippets/index/AsyncBreakfast-V2/Program.cs" id="SnippetMain":::

> [!TIP]
> <span data-ttu-id="386fa-162">Тексты методов `FryEggsAsync`, `FryBaconAsync` и `ToastBreadAsync` были обновлены так, чтобы возвращать `Task<Egg>`, `Task<Bacon>` и `Task<Toast>`, соответственно.</span><span class="sxs-lookup"><span data-stu-id="386fa-162">The method bodies of the `FryEggsAsync`, `FryBaconAsync`, and `ToastBreadAsync` have all been updated to return `Task<Egg>`, `Task<Bacon>`, and `Task<Toast>` respectively.</span></span> <span data-ttu-id="386fa-163">Методы переименованы и теперь содержат суффикс "Async".</span><span class="sxs-lookup"><span data-stu-id="386fa-163">The methods are renamed from their original version to include the "Async" suffix.</span></span> <span data-ttu-id="386fa-164">Их реализации показаны в составе [окончательной версии](#final-version) далее в этой статье.</span><span class="sxs-lookup"><span data-stu-id="386fa-164">Their implementations are shown as part of the [final version](#final-version) later in this article.</span></span>

<span data-ttu-id="386fa-165">Этот код не блокируется при приготовлении яиц или бекона.</span><span class="sxs-lookup"><span data-stu-id="386fa-165">This code doesn't block while the eggs or the bacon are cooking.</span></span> <span data-ttu-id="386fa-166">Этот код, однако, не запускает других задач.</span><span class="sxs-lookup"><span data-stu-id="386fa-166">This code won't start any other tasks though.</span></span> <span data-ttu-id="386fa-167">По-прежнему придется поместить тост в тостер и смотреть на него, пока он не выскочит.</span><span class="sxs-lookup"><span data-stu-id="386fa-167">You'd still put the toast in the toaster and stare at it until it pops.</span></span> <span data-ttu-id="386fa-168">Но по крайней мере можно отвечать всем, кто хочет вашего внимания.</span><span class="sxs-lookup"><span data-stu-id="386fa-168">But at least, you'd respond to anyone that wanted your attention.</span></span> <span data-ttu-id="386fa-169">В ресторане, где будет размещаться несколько заказов, повар сможет начать готовить другой завтрак, пока первый готовится.</span><span class="sxs-lookup"><span data-stu-id="386fa-169">In a restaurant where multiple orders are placed, the cook could start another breakfast while the first is cooking.</span></span>

<span data-ttu-id="386fa-170">Теперь поток завтрака не блокируется в ожидании любой запущенной задачи, которая еще не завершена.</span><span class="sxs-lookup"><span data-stu-id="386fa-170">Now, the thread working on the breakfast isn't blocked while awaiting any started task that hasn't yet finished.</span></span> <span data-ttu-id="386fa-171">Для некоторых приложений это изменение — все, что требуется.</span><span class="sxs-lookup"><span data-stu-id="386fa-171">For some applications, this change is all that's needed.</span></span> <span data-ttu-id="386fa-172">Приложение с графическим интерфейсом будет отвечать пользователю после этого изменения.</span><span class="sxs-lookup"><span data-stu-id="386fa-172">A GUI application still responds to the user with just this change.</span></span> <span data-ttu-id="386fa-173">Тем не менее в этом сценарии нам нужно больше.</span><span class="sxs-lookup"><span data-stu-id="386fa-173">However, for this scenario, you want more.</span></span> <span data-ttu-id="386fa-174">Нам не требуется последовательное выполнение каждой из задач компонента.</span><span class="sxs-lookup"><span data-stu-id="386fa-174">You don't want each of the component tasks to be executed sequentially.</span></span> <span data-ttu-id="386fa-175">Лучше запускать каждую из задач компонента, не ожидая завершения предыдущей задачи.</span><span class="sxs-lookup"><span data-stu-id="386fa-175">It's better to start each of the component tasks before awaiting the previous task's completion.</span></span>

## <a name="start-tasks-concurrently"></a><span data-ttu-id="386fa-176">Одновременный запуск задач</span><span class="sxs-lookup"><span data-stu-id="386fa-176">Start tasks concurrently</span></span>

<span data-ttu-id="386fa-177">Во многих случаях требуется запускать сразу несколько независимых задач.</span><span class="sxs-lookup"><span data-stu-id="386fa-177">In many scenarios, you want to start several independent tasks immediately.</span></span> <span data-ttu-id="386fa-178">Затем, когда каждая задача завершается, можно продолжить другую работу, которая уже готова к этому.</span><span class="sxs-lookup"><span data-stu-id="386fa-178">Then, as each task finishes, you can continue other work that's ready.</span></span> <span data-ttu-id="386fa-179">В нашей аналогии — так завтрак готовится быстрее.</span><span class="sxs-lookup"><span data-stu-id="386fa-179">In the breakfast analogy, that's how you get breakfast done more quickly.</span></span> <span data-ttu-id="386fa-180">Вы также приготовите все примерно в одно и то же время.</span><span class="sxs-lookup"><span data-stu-id="386fa-180">You also get everything done close to the same time.</span></span> <span data-ttu-id="386fa-181">Вы получите горячий завтрак.</span><span class="sxs-lookup"><span data-stu-id="386fa-181">You'll get a hot breakfast.</span></span>

<span data-ttu-id="386fa-182"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> и связанные типы — это классы, позволяющие делать выводы о задачах, которые находятся в процессе выполнения.</span><span class="sxs-lookup"><span data-stu-id="386fa-182">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and related types are classes you can use to reason about tasks that are in progress.</span></span> <span data-ttu-id="386fa-183">Это позволяет писать код, который точнее определяет, как будет фактически готовиться завтрак.</span><span class="sxs-lookup"><span data-stu-id="386fa-183">That enables you to write code that more closely resembles the way you'd actually create breakfast.</span></span> <span data-ttu-id="386fa-184">Вы начинаете готовить яйца, бекон и тосты примерно в одно и то же время.</span><span class="sxs-lookup"><span data-stu-id="386fa-184">You'd start cooking the eggs, bacon, and toast at the same time.</span></span> <span data-ttu-id="386fa-185">По мере необходимости вы обращаете внимание на отдельные задачи, переходите к другим, а затем ждете третьих, которые нуждаются в обработке.</span><span class="sxs-lookup"><span data-stu-id="386fa-185">As each requires action, you'd turn your attention to that task, take care of the next action, then await for something else that requires your attention.</span></span>

<span data-ttu-id="386fa-186">Вы начинаете задачу и удерживаете объект <xref:System.Threading.Tasks.Task>, представляющий работу.</span><span class="sxs-lookup"><span data-stu-id="386fa-186">You start a task and hold on to the <xref:System.Threading.Tasks.Task> object that represents the work.</span></span> <span data-ttu-id="386fa-187">Вы вызываете `await` для каждой задачи, прежде чем начать работу с ее результатами.</span><span class="sxs-lookup"><span data-stu-id="386fa-187">You'll `await` each task before working with its result.</span></span>

<span data-ttu-id="386fa-188">Давайте внесем эти изменения в код для приготовления завтрака.</span><span class="sxs-lookup"><span data-stu-id="386fa-188">Let's make these changes to the breakfast code.</span></span> <span data-ttu-id="386fa-189">Первым делом сохраним задачи для отдельных операций при их запуске, чтобы не ждать их:</span><span class="sxs-lookup"><span data-stu-id="386fa-189">The first step is to store the tasks for operations when they start, rather than awaiting them:</span></span>

```csharp
Coffee cup = PourCoffee();
Console.WriteLine("coffee is ready");

Task<Egg> eggsTask = FryEggsAsync(2);
Egg eggs = await eggsTask;
Console.WriteLine("eggs are ready");

Task<Bacon> baconTask = FryBaconAsync(3);
Bacon bacon = await baconTask;
Console.WriteLine("bacon is ready");

Task<Toast> toastTask = ToastBreadAsync(2);
Toast toast = await toastTask;
ApplyButter(toast);
ApplyJam(toast);
Console.WriteLine("toast is ready");

Juice oj = PourOJ();
Console.WriteLine("oj is ready");
Console.WriteLine("Breakfast is ready!");
```

<span data-ttu-id="386fa-190">Затем вы можете переместить инструкции `await` для бекона и яиц в конец метода, сразу перед подачей завтрака:</span><span class="sxs-lookup"><span data-stu-id="386fa-190">Next, you can move the `await` statements for the bacon and eggs to the end of the method, before serving breakfast:</span></span>

```csharp
Coffee cup = PourCoffee();
Console.WriteLine("coffee is ready");

Task<Egg> eggsTask = FryEggsAsync(2);
Task<Bacon> baconTask = FryBaconAsync(3);
Task<Toast> toastTask = ToastBreadAsync(2);

Toast toast = await toastTask;
ApplyButter(toast);
ApplyJam(toast);
Console.WriteLine("toast is ready");
Juice oj = PourOJ();
Console.WriteLine("oj is ready");

Egg eggs = await eggsTask;
Console.WriteLine("eggs are ready");
Bacon bacon = await baconTask;
Console.WriteLine("bacon is ready");

Console.WriteLine("Breakfast is ready!");
```

<span data-ttu-id="386fa-191">Предыдущий код работает лучше.</span><span class="sxs-lookup"><span data-stu-id="386fa-191">The preceding code works better.</span></span> <span data-ttu-id="386fa-192">Запуск всех асинхронных задач выполняется за один раз.</span><span class="sxs-lookup"><span data-stu-id="386fa-192">You start all the asynchronous tasks at once.</span></span> <span data-ttu-id="386fa-193">Вы ожидаете каждую задачу только в том случае, когда требуются результаты.</span><span class="sxs-lookup"><span data-stu-id="386fa-193">You await each task only when you need the results.</span></span> <span data-ttu-id="386fa-194">Приведенный выше код может быть похож на код в веб-приложении, который отправляет запросы для разных микрослужб, а затем объединяет результаты в одну страницу.</span><span class="sxs-lookup"><span data-stu-id="386fa-194">The preceding code may be similar to code in a web application that makes requests of different microservices, then combines the results into a single page.</span></span> <span data-ttu-id="386fa-195">Вы отправляете все запросы сразу, а затем вызываете `await`, чтобы соединить все задачи и создать веб-страницу.</span><span class="sxs-lookup"><span data-stu-id="386fa-195">You'll make all the requests immediately, then `await` all those tasks and compose the web page.</span></span>

## <a name="composition-with-tasks"></a><span data-ttu-id="386fa-196">Сочетаемость задач</span><span class="sxs-lookup"><span data-stu-id="386fa-196">Composition with tasks</span></span>

 <span data-ttu-id="386fa-197">У вас все готово для завтрака в одно и то же время, за исключением тостов.</span><span class="sxs-lookup"><span data-stu-id="386fa-197">You have everything ready for breakfast at the same time except the toast.</span></span> <span data-ttu-id="386fa-198">Приготовление тоста — композиция асинхронной операции (поджарить хлеб) и синхронной операции (добавить масло и джем).</span><span class="sxs-lookup"><span data-stu-id="386fa-198">Making the toast is the composition of an asynchronous operation (toasting the bread), and synchronous operations (adding the butter and the jam).</span></span> <span data-ttu-id="386fa-199">Обновление этого кода иллюстрирует важную концепцию:</span><span class="sxs-lookup"><span data-stu-id="386fa-199">Updating this code illustrates an important concept:</span></span>

> [!IMPORTANT]
> <span data-ttu-id="386fa-200">композиция асинхронной операции, за которой следует синхронная задача, является асинхронной операцией.</span><span class="sxs-lookup"><span data-stu-id="386fa-200">The composition of an asynchronous operation followed by synchronous work is an asynchronous operation.</span></span> <span data-ttu-id="386fa-201">Говоря иначе, если какая-либо часть операции является асинхронной, то и вся операция является асинхронной.</span><span class="sxs-lookup"><span data-stu-id="386fa-201">Stated another way, if any portion of an operation is asynchronous, the entire operation is asynchronous.</span></span>

<span data-ttu-id="386fa-202">Приведенный выше код показал, что можно использовать объекты <xref:System.Threading.Tasks.Task> или <xref:System.Threading.Tasks.Task%601> для хранения выполняемых задач.</span><span class="sxs-lookup"><span data-stu-id="386fa-202">The preceding code showed you that you can use <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> objects to hold running tasks.</span></span> <span data-ttu-id="386fa-203">Вы вызываете `await` для каждой задачи, прежде чем использовать ее результат.</span><span class="sxs-lookup"><span data-stu-id="386fa-203">You `await` each task before using its result.</span></span> <span data-ttu-id="386fa-204">Следующим шагом является создание методов, которые представляют сочетание другой работы.</span><span class="sxs-lookup"><span data-stu-id="386fa-204">The next step is to create methods that represent the combination of other work.</span></span> <span data-ttu-id="386fa-205">Перед подачей завтрака требуется дождаться задачи, представляющей поджарку хлеба перед добавлением масла и джема.</span><span class="sxs-lookup"><span data-stu-id="386fa-205">Before serving breakfast, you want to await the task that represents toasting the bread before adding butter and jam.</span></span> <span data-ttu-id="386fa-206">Вы можете представить эту работу следующим кодом:</span><span class="sxs-lookup"><span data-stu-id="386fa-206">You can represent that work with the following code:</span></span>

:::code language="csharp" source="snippets/index/AsyncBreakfast-V3/Program.cs" id="SnippetComposeToastTask":::

<span data-ttu-id="386fa-207">Предыдущий метод имеет `async` модификатор в сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="386fa-207">The preceding method has the `async` modifier in its signature.</span></span> <span data-ttu-id="386fa-208">Он сообщает компилятору, что этот метод содержит инструкцию `await`; она содержит асинхронные операции.</span><span class="sxs-lookup"><span data-stu-id="386fa-208">That signals to the compiler that this method contains an `await` statement; it contains asynchronous operations.</span></span> <span data-ttu-id="386fa-209">Этот метод представляет задачу, в рамках которой поджаривается хлеб, а затем добавляется масло и джем.</span><span class="sxs-lookup"><span data-stu-id="386fa-209">This method represents the task that toasts the bread, then adds butter and jam.</span></span> <span data-ttu-id="386fa-210">Этот метод возвращает <xref:System.Threading.Tasks.Task%601>, представляющий сочетание этих трех операций.</span><span class="sxs-lookup"><span data-stu-id="386fa-210">This method returns a <xref:System.Threading.Tasks.Task%601> that represents the composition of those three operations.</span></span> <span data-ttu-id="386fa-211">Теперь вид основного блока кода будет таким:</span><span class="sxs-lookup"><span data-stu-id="386fa-211">The main block of code now becomes:</span></span>

:::code language="csharp" source="snippets/index/AsyncBreakfast-V3/Program.cs" id="SnippetMain":::

<span data-ttu-id="386fa-212">Предыдущее изменение показывает важную методику для работы с асинхронным кодом.</span><span class="sxs-lookup"><span data-stu-id="386fa-212">The previous change illustrated an important technique for working with asynchronous code.</span></span> <span data-ttu-id="386fa-213">Составные задачи можно создавать, разделяя операции в новом методе, который возвращает задачу.</span><span class="sxs-lookup"><span data-stu-id="386fa-213">You compose tasks by separating the operations into a new method that returns a task.</span></span> <span data-ttu-id="386fa-214">Вы можете выбрать, когда следует ожидать выполнения созданной задачи.</span><span class="sxs-lookup"><span data-stu-id="386fa-214">You can choose when to await that task.</span></span> <span data-ttu-id="386fa-215">Одновременно можно запускать другие задачи.</span><span class="sxs-lookup"><span data-stu-id="386fa-215">You can start other tasks concurrently.</span></span>

## <a name="await-tasks-efficiently"></a><span data-ttu-id="386fa-216">Эффективное ожидание задач</span><span class="sxs-lookup"><span data-stu-id="386fa-216">Await tasks efficiently</span></span>

<span data-ttu-id="386fa-217">Ряд инструкций `await` в конце приведенного выше кода можно улучшить с помощью методов класса `Task`.</span><span class="sxs-lookup"><span data-stu-id="386fa-217">The series of `await` statements at the end of the preceding code can be improved by using methods of the `Task` class.</span></span> <span data-ttu-id="386fa-218">Один из этих API — <xref:System.Threading.Tasks.Task.WhenAll%2A>, который возвращает <xref:System.Threading.Tasks.Task>; она завершается после завершения всех задач в списке аргументов, как показано в следующем коде:</span><span class="sxs-lookup"><span data-stu-id="386fa-218">One of those APIs is <xref:System.Threading.Tasks.Task.WhenAll%2A>, which returns a <xref:System.Threading.Tasks.Task> that completes when all the tasks in its argument list have completed, as shown in the following code:</span></span>

```csharp
await Task.WhenAll(eggsTask, baconTask, toastTask);
Console.WriteLine("eggs are ready");
Console.WriteLine("bacon is ready");
Console.WriteLine("toast is ready");
Console.WriteLine("Breakfast is ready!");
```

<span data-ttu-id="386fa-219">Другой вариант — использовать <xref:System.Threading.Tasks.Task.WhenAny%2A>, который возвращает `Task<Task>`, выполняемый по завершении любого из своих аргументов.</span><span class="sxs-lookup"><span data-stu-id="386fa-219">Another option is to use <xref:System.Threading.Tasks.Task.WhenAny%2A>, which returns a `Task<Task>` that completes when any of its arguments completes.</span></span> <span data-ttu-id="386fa-220">Можно ожидать возвращенной задачи, зная, что она уже завершена.</span><span class="sxs-lookup"><span data-stu-id="386fa-220">You can await the returned task, knowing that it has already finished.</span></span> <span data-ttu-id="386fa-221">В следующем коде показано, как использовать <xref:System.Threading.Tasks.Task.WhenAny%2A> для ожидания первой задачи, чтобы затем обработать ее результат.</span><span class="sxs-lookup"><span data-stu-id="386fa-221">The following code shows how you could use <xref:System.Threading.Tasks.Task.WhenAny%2A> to await the first task to finish and then process its result.</span></span> <span data-ttu-id="386fa-222">После обработки результата завершенной задачи удалим ее из списка задач, передаваемого в `WhenAny`.</span><span class="sxs-lookup"><span data-stu-id="386fa-222">After processing the result from the completed task, you remove that completed task from the list of tasks passed to `WhenAny`.</span></span>

```csharp
var breakfastTasks = new List<Task> { eggsTask, baconTask, toastTask };
while (breakfastTasks.Count > 0)
{
    Task finishedTask = await Task.WhenAny(breakfastTasks);
    if (finishedTask == eggsTask)
    {
        Console.WriteLine("eggs are ready");
    }
    else if (finishedTask == baconTask)
    {
        Console.WriteLine("bacon is ready");
    }
    else if (finishedTask == toastTask)
    {
        Console.WriteLine("toast is ready");
    }
    breakfastTasks.Remove(finishedTask);
}
```

<span data-ttu-id="386fa-223">После всех этих изменений окончательная версия кода выглядит так: <a id="final-version"></a></span><span class="sxs-lookup"><span data-stu-id="386fa-223">After all those changes, the final version of the code looks like this: <a id="final-version"></a></span></span>
:::code language="csharp" source="snippets/index/AsyncBreakfast-final/Program.cs" highlight="9-40":::

<span data-ttu-id="386fa-224">Этот итоговый код выполняется асинхронно.</span><span class="sxs-lookup"><span data-stu-id="386fa-224">This final code is asynchronous.</span></span> <span data-ttu-id="386fa-225">Он более точно отражает, как пользователь будет готовить завтрак.</span><span class="sxs-lookup"><span data-stu-id="386fa-225">It more accurately reflects how a person would cook a breakfast.</span></span> <span data-ttu-id="386fa-226">Сравните предыдущий код с первым примером кода в этой статье.</span><span class="sxs-lookup"><span data-stu-id="386fa-226">Compare the preceding code with the first code sample in this article.</span></span> <span data-ttu-id="386fa-227">Основные действия по-прежнему очевидны при прочтении.</span><span class="sxs-lookup"><span data-stu-id="386fa-227">The core actions are still clear from reading the code.</span></span> <span data-ttu-id="386fa-228">Этот код можно прочитать так же, как указания по приготовлению завтрака в начале этой статьи.</span><span class="sxs-lookup"><span data-stu-id="386fa-228">You can read this code the same way you'd read those instructions for making a breakfast at the beginning of this article.</span></span> <span data-ttu-id="386fa-229">Возможности языка для `async` и `await` делают возможными преобразования, которые любой человек производит, выполняя эти инструкции: запуск задач без блокировки в ожидании их завершения.</span><span class="sxs-lookup"><span data-stu-id="386fa-229">The language features for `async` and `await` provide the translation every person makes to follow those written instructions: start tasks as you can and don't block waiting for tasks to complete.</span></span>

## <a name="next-steps"></a><span data-ttu-id="386fa-230">Следующие шаги</span><span class="sxs-lookup"><span data-stu-id="386fa-230">Next steps</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="386fa-231">Ознакомьтесь с моделью асинхронного программирования</span><span class="sxs-lookup"><span data-stu-id="386fa-231">Learn about the task asynchronous programming model</span></span>](task-asynchronous-programming-model.md)
