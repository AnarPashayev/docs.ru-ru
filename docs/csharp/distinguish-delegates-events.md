---
title: Различия между делегатами и событиями
description: Сведения о различиях между делегатами и событиями, а также о том, когда следует использовать каждый из этих компонентов в .NET Core.
ms.date: 06/20/2016
ms.technology: csharp-fundamentals
ms.assetid: 0fdc8629-2fdb-4a7c-a433-5b9d04eaf911
ms.openlocfilehash: 04738ac2dd82da9c577e88598d0bb737a93333c1
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "79146182"
---
# <a name="distinguishing-delegates-and-events"></a>Различия между делегатами и событиями

[Назад](modern-events.md)

Разработчики, не имеющие опыта работы с платформой .NET Core, часто не могут решить, что следует выбрать: структуру на основе `delegates` или на основе `events`. Это сложный вопрос, так как эти две возможности языка очень похожи. Более того, события основаны на тех же средствах языка, которые обеспечивают поддержку делегатов.

И те и другие обеспечивают сценарии позднего связывания, в которых взаимодействие компонента осуществляется путем вызова метода, известного только во время выполнения. И те и другие поддерживают методы с одним или несколькими подписчиками. Иногда это называют поддержкой одноадресности и многоадресности. Синтаксис добавления и удаления обработчиков в обоих случаях похож. Наконец, при вызове событий и делегатов используется абсолютно одинаковый синтаксис вызова методов. Более того, поддерживается одинаковый синтаксис метода `Invoke()` для использования с оператором `?.`.

Учитывая такое сходство, легко могут возникнуть проблемы с выбором подходящего механизма в той или иной ситуации.

## <a name="listening-to-events-is-optional"></a>Прослушивание событий необязательно

Самым важным фактором при выборе подходящего механизма является обязательность наличия подключенного подписчика. Если ваш код должен вызывать код, предоставленный подписчиком, следует использовать структуру на основе делегатов. Если код может выполнить все задачи, не вызывая подписчики, следует использовать структуру на основе событий.

Обратите внимание на примеры, рассматривавшиеся в этом разделе. Код, который вы создавали с помощью `List.Sort()`, должен содержать функцию сравнения для правильной сортировки элементов. Запросам LINQ необходимо предоставить делегаты для определения элементов, которые следует вернуть. В обоих случаях использовалась структура на основе делегатов.

Рассмотрим событие `Progress`. Оно сообщает о ходе выполнения задачи.
Задача продолжает выполняться вне зависимости от того, есть ли прослушиватели.
Еще один пример — `FileSearcher`. Нахождение всех искомых файлов производится, даже если не подключены обработчики событий.
Элементы управления UX продолжают работать правильно, даже если нет подписчиков, прослушивающих события. В обоих примерах используются структуры на основе событий.

## <a name="return-values-require-delegates"></a>Для возвращаемых значений требуются делегаты

Еще одним аспектом является прототип метода, который требуется для метода делегата. Как вы уже видели, все делегаты, используемые для событий, имеют тип возвращаемого значения void. Вы уже также знаете, что есть идиомы для создания обработчиков событий, которые передают информацию обратно источникам событий, изменяя свойства объекта аргумента события. Хотя такие идиомы работают, они не так естественны, как возвращение значения из метода.

Обратите внимание на то, что часто используются оба этих эвристических метода: если метод делегата возвращает значение, то оно, скорее всего, будет каким-либо образом влиять на алгоритм.

## <a name="event-listeners-often-have-longer-lifetimes"></a>Прослушиватели событий часто имеют более длительный срок существования

Это не столь важный фактор. Однако структура на основе событий может оказаться более естественной, когда источник событий инициирует события в течение длительного периода времени. Примерами могут служить элементы управления UX во многих системах. После подписания на событие источник события может вызывать события в течение всего времени существования программы.
(Когда события больше не нужны, вы можете отменить подписку на них.)

Сравните это с часто встречающимися структурами на основе делегатов, когда делегат применяется в качестве аргумента метода и не используется после того, как метод возвращает управление.

## <a name="evaluate-carefully"></a>Тщательно оценивайте ситуацию

Приведенные выше указания не являются строгими правилами. Они представляют собой лишь рекомендации, которые могут помочь вам выбрать правильный вариант в конкретном случае. Так как эти механизмы схожи, вы можете смоделировать и тот и другой, чтобы проверить, какой из них окажется естественнее. Оба они хорошо подходят для сценариев с поздним связыванием. Используйте тот механизм, который лучше соответствует вашим требованиям.
