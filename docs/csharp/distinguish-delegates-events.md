---
title: Делегаты и события
description: Сведения о различиях между делегатами и событиями, а также о том, когда следует использовать каждый из этих компонентов в .NET Core.
ms.date: 06/20/2016
ms.technology: csharp-fundamentals
ms.assetid: 0fdc8629-2fdb-4a7c-a433-5b9d04eaf911
ms.openlocfilehash: 51d982c9b5b16a5fc28ede5f0318bc100bb33b68
ms.sourcegitcommit: f87ad41b8e62622da126aa928f7640108c4eff98
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/07/2020
ms.locfileid: "80805767"
---
# <a name="distinguishing-delegates-and-events"></a><span data-ttu-id="e1bab-103">Различия между делегатами и событиями</span><span class="sxs-lookup"><span data-stu-id="e1bab-103">Distinguishing Delegates and Events</span></span>

[<span data-ttu-id="e1bab-104">Назад</span><span class="sxs-lookup"><span data-stu-id="e1bab-104">Previous</span></span>](modern-events.md)

<span data-ttu-id="e1bab-105">Разработчики, не имеющие опыта работы с платформой .NET Core, часто не могут решить, что следует выбрать: структуру на основе `delegates` или на основе `events`.</span><span class="sxs-lookup"><span data-stu-id="e1bab-105">Developers that are new to the .NET Core platform often struggle when deciding between a design based on `delegates` and a design based on `events`.</span></span> <span data-ttu-id="e1bab-106">Часто выбор делегатов или событий довольно сложен, так как эти две возможности языка довольно похожи.</span><span class="sxs-lookup"><span data-stu-id="e1bab-106">The choice of delegates or events is often difficult, because the two language features are similar.</span></span> <span data-ttu-id="e1bab-107">Более того, события основаны на тех же средствах языка, которые обеспечивают поддержку делегатов.</span><span class="sxs-lookup"><span data-stu-id="e1bab-107">Events are even built using the language support for delegates.</span></span>

<span data-ttu-id="e1bab-108">И те и другие обеспечивают сценарии позднего связывания, в которых взаимодействие компонента осуществляется путем вызова метода, известного только во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="e1bab-108">They both offer a late binding scenario: they enable scenarios where a component communicates by calling a method that is only known at runtime.</span></span> <span data-ttu-id="e1bab-109">И те и другие поддерживают методы с одним или несколькими подписчиками.</span><span class="sxs-lookup"><span data-stu-id="e1bab-109">They both support single and multiple subscriber methods.</span></span> <span data-ttu-id="e1bab-110">Иногда это называют поддержкой одноадресности и многоадресности.</span><span class="sxs-lookup"><span data-stu-id="e1bab-110">You may find this referred to as singlecast and multicast support.</span></span> <span data-ttu-id="e1bab-111">Синтаксис добавления и удаления обработчиков в обоих случаях похож.</span><span class="sxs-lookup"><span data-stu-id="e1bab-111">They both support similar syntax for adding and removing handlers.</span></span> <span data-ttu-id="e1bab-112">Наконец, при вызове событий и делегатов используется абсолютно одинаковый синтаксис вызова методов.</span><span class="sxs-lookup"><span data-stu-id="e1bab-112">Finally, raising an event and calling a delegate use exactly the same method call syntax.</span></span> <span data-ttu-id="e1bab-113">Более того, поддерживается одинаковый синтаксис метода `Invoke()` для использования с оператором `?.`.</span><span class="sxs-lookup"><span data-stu-id="e1bab-113">They even both support the same `Invoke()` method syntax for use with the `?.` operator.</span></span>

<span data-ttu-id="e1bab-114">Учитывая такое сходство, легко могут возникнуть проблемы с выбором подходящего механизма в той или иной ситуации.</span><span class="sxs-lookup"><span data-stu-id="e1bab-114">With all those similarities, it is easy to have trouble determining when to use which.</span></span>

## <a name="listening-to-events-is-optional"></a><span data-ttu-id="e1bab-115">Прослушивание событий необязательно</span><span class="sxs-lookup"><span data-stu-id="e1bab-115">Listening to Events is Optional</span></span>

<span data-ttu-id="e1bab-116">Самым важным фактором при выборе подходящего механизма является обязательность наличия подключенного подписчика.</span><span class="sxs-lookup"><span data-stu-id="e1bab-116">The most important consideration in determining which language feature to use is whether or not there must be an attached subscriber.</span></span> <span data-ttu-id="e1bab-117">Если ваш код должен вызывать код, предоставленный подписчиком, следует использовать структуру на основе делегатов.</span><span class="sxs-lookup"><span data-stu-id="e1bab-117">If your code must call the code supplied by the subscriber, you should use a design based on delegates.</span></span> <span data-ttu-id="e1bab-118">Если код может выполнить все задачи, не вызывая подписчики, следует использовать структуру на основе событий.</span><span class="sxs-lookup"><span data-stu-id="e1bab-118">If your code can complete all its work without calling any subscribers, you should use a design based on events.</span></span>

<span data-ttu-id="e1bab-119">Обратите внимание на примеры, рассматривавшиеся в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="e1bab-119">Consider the examples built during this section.</span></span> <span data-ttu-id="e1bab-120">Код, который вы создавали с помощью `List.Sort()`, должен содержать функцию сравнения для правильной сортировки элементов.</span><span class="sxs-lookup"><span data-stu-id="e1bab-120">The code you built using `List.Sort()` must be given a comparer function in order to properly sort the elements.</span></span> <span data-ttu-id="e1bab-121">Запросам LINQ необходимо предоставить делегаты для определения элементов, которые следует вернуть.</span><span class="sxs-lookup"><span data-stu-id="e1bab-121">LINQ queries must be supplied with delegates in order to determine what elements to return.</span></span> <span data-ttu-id="e1bab-122">В обоих случаях использовалась структура на основе делегатов.</span><span class="sxs-lookup"><span data-stu-id="e1bab-122">Both used a design built with delegates.</span></span>

<span data-ttu-id="e1bab-123">Рассмотрим событие `Progress`.</span><span class="sxs-lookup"><span data-stu-id="e1bab-123">Consider the `Progress` event.</span></span> <span data-ttu-id="e1bab-124">Оно сообщает о ходе выполнения задачи.</span><span class="sxs-lookup"><span data-stu-id="e1bab-124">It reports progress on a task.</span></span>
<span data-ttu-id="e1bab-125">Задача продолжает выполняться вне зависимости от того, есть ли прослушиватели.</span><span class="sxs-lookup"><span data-stu-id="e1bab-125">The task continues to proceed whether or not there are any listeners.</span></span>
<span data-ttu-id="e1bab-126">Еще один пример — `FileSearcher`.</span><span class="sxs-lookup"><span data-stu-id="e1bab-126">The `FileSearcher` is another example.</span></span> <span data-ttu-id="e1bab-127">Нахождение всех искомых файлов производится, даже если не подключены обработчики событий.</span><span class="sxs-lookup"><span data-stu-id="e1bab-127">It would still search and find all the files that were sought, even with no event subscribers attached.</span></span>
<span data-ttu-id="e1bab-128">Элементы управления UX продолжают работать правильно, даже если нет подписчиков, прослушивающих события.</span><span class="sxs-lookup"><span data-stu-id="e1bab-128">UX controls still work correctly, even when there are no subscribers listening to the events.</span></span> <span data-ttu-id="e1bab-129">В обоих примерах используются структуры на основе событий.</span><span class="sxs-lookup"><span data-stu-id="e1bab-129">They both use designs based on events.</span></span>

## <a name="return-values-require-delegates"></a><span data-ttu-id="e1bab-130">Для возвращаемых значений требуются делегаты</span><span class="sxs-lookup"><span data-stu-id="e1bab-130">Return Values Require Delegates</span></span>

<span data-ttu-id="e1bab-131">Еще одним аспектом является прототип метода, который требуется для метода делегата.</span><span class="sxs-lookup"><span data-stu-id="e1bab-131">Another consideration is the method prototype you would want for your delegate method.</span></span> <span data-ttu-id="e1bab-132">Как вы уже видели, все делегаты, используемые для событий, имеют тип возвращаемого значения void.</span><span class="sxs-lookup"><span data-stu-id="e1bab-132">As you've seen, the delegates used for events all have a void return type.</span></span> <span data-ttu-id="e1bab-133">Вы уже также знаете, что есть идиомы для создания обработчиков событий, которые передают информацию обратно источникам событий, изменяя свойства объекта аргумента события.</span><span class="sxs-lookup"><span data-stu-id="e1bab-133">You've also seen that there are idioms to create event handlers that do pass information back to event sources through modifying properties of the event argument object.</span></span> <span data-ttu-id="e1bab-134">Хотя такие идиомы работают, они не так естественны, как возвращение значения из метода.</span><span class="sxs-lookup"><span data-stu-id="e1bab-134">While these idioms do work, they are not as natural as returning a value from a method.</span></span>

<span data-ttu-id="e1bab-135">Обратите внимание, что часто присутствуют оба исследуемых аспекта. Если метод делегата возвращает значение, скорее всего, это повлияет на алгоритм.</span><span class="sxs-lookup"><span data-stu-id="e1bab-135">Notice that these two heuristics may often both be present: If your delegate method returns a value, it will likely impact the algorithm in some way.</span></span>

## <a name="events-have-private-invocation"></a><span data-ttu-id="e1bab-136">Для событий используется закрытый вызов</span><span class="sxs-lookup"><span data-stu-id="e1bab-136">Events Have Private Invocation</span></span>

<span data-ttu-id="e1bab-137">Классы, отличные от тех, в которых содержится событие, могут только добавлять и удалять прослушиватели событий. Вызывать событие может только класс, содержащий событие.</span><span class="sxs-lookup"><span data-stu-id="e1bab-137">Classes other than the one in which an event is contained can only add and remove event listeners; only the class containing the event can invoke the event.</span></span> <span data-ttu-id="e1bab-138">События обычно являются открытыми членами класса.</span><span class="sxs-lookup"><span data-stu-id="e1bab-138">Events are typically public class members.</span></span>
<span data-ttu-id="e1bab-139">Для сравнения, делегаты часто передаются как параметры и хранятся как закрытые члены класса (если хранятся вообще).</span><span class="sxs-lookup"><span data-stu-id="e1bab-139">By comparison, delegates are often passed as parameters and stored as private class members, if they are stored at all.</span></span>

## <a name="event-listeners-often-have-longer-lifetimes"></a><span data-ttu-id="e1bab-140">Прослушиватели событий часто имеют более длительный срок существования</span><span class="sxs-lookup"><span data-stu-id="e1bab-140">Event Listeners Often Have Longer Lifetimes</span></span>

<span data-ttu-id="e1bab-141">То, что прослушиватели событий имеют более продолжительное время существования, — не столь важный фактор.</span><span class="sxs-lookup"><span data-stu-id="e1bab-141">That event listeners have longer lifetimes is a slightly weaker justification.</span></span> <span data-ttu-id="e1bab-142">Однако структура на основе событий может оказаться более естественной, когда источник событий инициирует события в течение длительного периода времени.</span><span class="sxs-lookup"><span data-stu-id="e1bab-142">However, you may find that event-based designs are more natural when the event source will be raising events over a long period of time.</span></span> <span data-ttu-id="e1bab-143">Примеры структуры на основе событий для элементов управления UX можно найти во многих системах.</span><span class="sxs-lookup"><span data-stu-id="e1bab-143">You can see examples of event-based design for UX controls on many systems.</span></span> <span data-ttu-id="e1bab-144">После подписания на событие источник события может вызывать события в течение всего времени существования программы.</span><span class="sxs-lookup"><span data-stu-id="e1bab-144">Once you subscribe to an event, the event source may raise events throughout the lifetime of the program.</span></span>
<span data-ttu-id="e1bab-145">(Когда события больше не нужны, вы можете отменить подписку на них.)</span><span class="sxs-lookup"><span data-stu-id="e1bab-145">(You can unsubscribe from events when you no longer need them.)</span></span>

<span data-ttu-id="e1bab-146">Сравните это с часто встречающимися структурами на основе делегатов, когда делегат применяется в качестве аргумента метода и не используется после того, как метод возвращает управление.</span><span class="sxs-lookup"><span data-stu-id="e1bab-146">Contrast that with many delegate-based designs, where a delegate is used as an argument to a method, and the delegate is not used after that method returns.</span></span>

## <a name="evaluate-carefully"></a><span data-ttu-id="e1bab-147">Тщательно оценивайте ситуацию</span><span class="sxs-lookup"><span data-stu-id="e1bab-147">Evaluate Carefully</span></span>

<span data-ttu-id="e1bab-148">Приведенные выше указания не являются строгими правилами.</span><span class="sxs-lookup"><span data-stu-id="e1bab-148">The above considerations are not hard and fast rules.</span></span> <span data-ttu-id="e1bab-149">Они представляют собой лишь рекомендации, которые могут помочь вам выбрать правильный вариант в конкретном случае.</span><span class="sxs-lookup"><span data-stu-id="e1bab-149">Instead, they represent guidance that can help you decide which choice is best for your particular usage.</span></span> <span data-ttu-id="e1bab-150">Так как эти механизмы схожи, вы можете смоделировать и тот и другой, чтобы проверить, какой из них окажется естественнее.</span><span class="sxs-lookup"><span data-stu-id="e1bab-150">Because they are similar, you can even prototype both, and consider which would be more natural to work with.</span></span> <span data-ttu-id="e1bab-151">Оба они хорошо подходят для сценариев с поздним связыванием.</span><span class="sxs-lookup"><span data-stu-id="e1bab-151">They both handle late binding scenarios well.</span></span> <span data-ttu-id="e1bab-152">Используйте тот механизм, который лучше соответствует вашим требованиям.</span><span class="sxs-lookup"><span data-stu-id="e1bab-152">Use the one that communicates your design the best.</span></span>
