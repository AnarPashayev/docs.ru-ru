---
title: Свойства
description: Сведения о свойствах в C#, в том числе информация о функциях для проверки, вычисляемых значениях, отложенных вычислениях и уведомлениях об изменении свойств.
ms.technology: csharp-fundamentals
ms.date: 04/25/2018
ms.openlocfilehash: 5306650a10a3de0ff208f7c72c0ba520a527e746
ms.sourcegitcommit: 721c3e4bdbb1ea0bb420818ec944c538fe5c513a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/01/2020
ms.locfileid: "96437935"
---
# <a name="properties"></a><span data-ttu-id="5f81c-103">Свойства</span><span class="sxs-lookup"><span data-stu-id="5f81c-103">Properties</span></span>

<span data-ttu-id="5f81c-104">Свойства являются привилегированными компонентами C#.</span><span class="sxs-lookup"><span data-stu-id="5f81c-104">Properties are first class citizens in C#.</span></span> <span data-ttu-id="5f81c-105">Язык определяет синтаксис, который позволяет разработчикам писать код, отражающий цели их проекта.</span><span class="sxs-lookup"><span data-stu-id="5f81c-105">The language defines syntax that enables developers to write code that accurately expresses their design intent.</span></span>

<span data-ttu-id="5f81c-106">Свойства при обращении к ним ведут себя как поля.</span><span class="sxs-lookup"><span data-stu-id="5f81c-106">Properties behave like fields when they are accessed.</span></span>
<span data-ttu-id="5f81c-107">Однако в отличие от полей свойства реализуются с помощью методов доступа, которые определяют инструкции, выполняемые при обращении к свойству или при его назначении.</span><span class="sxs-lookup"><span data-stu-id="5f81c-107">However, unlike fields, properties are implemented with accessors that define the statements executed when a property is accessed or assigned.</span></span>

## <a name="property-syntax"></a><span data-ttu-id="5f81c-108">Синтаксис свойства</span><span class="sxs-lookup"><span data-stu-id="5f81c-108">Property syntax</span></span>

<span data-ttu-id="5f81c-109">Синтаксис свойств является естественным расширением полей.</span><span class="sxs-lookup"><span data-stu-id="5f81c-109">The syntax for properties is a natural extension to fields.</span></span> <span data-ttu-id="5f81c-110">Поле определяет место хранения:</span><span class="sxs-lookup"><span data-stu-id="5f81c-110">A field defines a storage location:</span></span>

[!code-csharp[Person class with public fields](../../samples/snippets/csharp/properties/Person.cs#1)]

<span data-ttu-id="5f81c-111">Определение свойства содержит объявления для методов доступа `get` и `set`, которые получают и устанавливают значение этого свойства:</span><span class="sxs-lookup"><span data-stu-id="5f81c-111">A property definition contains declarations for a `get` and `set` accessor that retrieves and assigns the value of that property:</span></span>

[!code-csharp[Person class with public properties](../../samples/snippets/csharp/properties/Person.cs#2)]

<span data-ttu-id="5f81c-112">Синтаксис, показанный выше, является синтаксисом *автосвойств*.</span><span class="sxs-lookup"><span data-stu-id="5f81c-112">The syntax shown above is the *auto property* syntax.</span></span> <span data-ttu-id="5f81c-113">Компилятор создает место хранения для поля, поддерживающего свойство.</span><span class="sxs-lookup"><span data-stu-id="5f81c-113">The compiler generates the storage location for the field that backs up the property.</span></span> <span data-ttu-id="5f81c-114">Компилятор также реализует тело методов доступа `get` и `set`.</span><span class="sxs-lookup"><span data-stu-id="5f81c-114">The compiler also implements the body of the `get` and `set` accessors.</span></span>

<span data-ttu-id="5f81c-115">Бывает, что свойство необходимо инициализировать со значением, отличным от значения по умолчанию для его типа.</span><span class="sxs-lookup"><span data-stu-id="5f81c-115">Sometimes, you need to initialize a property to a value other than the default for its type.</span></span>  <span data-ttu-id="5f81c-116">C# позволяет это сделать, указав значение после закрывающей фигурной скобки свойства.</span><span class="sxs-lookup"><span data-stu-id="5f81c-116">C# enables that by setting a value after the closing brace for the property.</span></span> <span data-ttu-id="5f81c-117">В этом случае в качестве начального значения для свойства `FirstName` можно задать пустую строку, а не `null`.</span><span class="sxs-lookup"><span data-stu-id="5f81c-117">You may prefer the initial value for the `FirstName` property to be the empty string rather than `null`.</span></span> <span data-ttu-id="5f81c-118">Для этого используется следующий код:</span><span class="sxs-lookup"><span data-stu-id="5f81c-118">You would specify that as shown below:</span></span>

[!code-csharp[Person class with properties and initializer](../../samples/snippets/csharp/properties/Person.cs#3)]

<span data-ttu-id="5f81c-119">Как вы увидите далее в этой статье, конкретная инициализация особенно полезна для свойств, предназначенных только для чтения.</span><span class="sxs-lookup"><span data-stu-id="5f81c-119">Specific initialization is most useful for read-only properties, as you'll see later in this article.</span></span>

<span data-ttu-id="5f81c-120">Вы можете определить хранилище самостоятельно, как показано ниже:</span><span class="sxs-lookup"><span data-stu-id="5f81c-120">You can also define the storage yourself, as shown below:</span></span>

[!code-csharp[Person class with properties and backing field](../../samples/snippets/csharp/properties/Person.cs#4)]

<span data-ttu-id="5f81c-121">Если реализация свойства представляет собой одиночное выражение, в качестве метода получения или задания можно использовать *элементы, воплощающие выражение*.</span><span class="sxs-lookup"><span data-stu-id="5f81c-121">When a property implementation is a single expression, you can use *expression-bodied members* for the getter or setter:</span></span>

[!code-csharp[Person class with properties and expression bodied getters and setters](../../samples/snippets/csharp/properties/Person.cs#5)]

<span data-ttu-id="5f81c-122">Такой упрощенный синтаксис будет применяться в этой статье везде, где это возможно.</span><span class="sxs-lookup"><span data-stu-id="5f81c-122">This simplified syntax will be used where applicable throughout this article.</span></span>

<span data-ttu-id="5f81c-123">В примере выше определяется свойство для чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="5f81c-123">The property definition shown above is a read-write property.</span></span> <span data-ttu-id="5f81c-124">Обратите внимание на ключевое слово `value` в методе доступа set.</span><span class="sxs-lookup"><span data-stu-id="5f81c-124">Notice the keyword `value` in the set accessor.</span></span> <span data-ttu-id="5f81c-125">Метод доступа `set` всегда имеет один параметр с именем `value`.</span><span class="sxs-lookup"><span data-stu-id="5f81c-125">The `set` accessor always has a single parameter named `value`.</span></span> <span data-ttu-id="5f81c-126">Метод доступа `get` должен возвращать значение, которое можно преобразовать в свойство (`string` в этом примере).</span><span class="sxs-lookup"><span data-stu-id="5f81c-126">The `get` accessor must return a value that is convertible to the type of the property (`string` in this example).</span></span>

<span data-ttu-id="5f81c-127">Это основные сведения о синтаксисе.</span><span class="sxs-lookup"><span data-stu-id="5f81c-127">That's the basics of the syntax.</span></span> <span data-ttu-id="5f81c-128">Существует множество различных вариантов, поддерживающих разные идиомы.</span><span class="sxs-lookup"><span data-stu-id="5f81c-128">There are many different variations that support a variety of different design idioms.</span></span> <span data-ttu-id="5f81c-129">Рассмотрим их, а также соответствующие параметры синтаксиса.</span><span class="sxs-lookup"><span data-stu-id="5f81c-129">Let's explore, and learn the syntax options for each.</span></span>

## <a name="scenarios"></a><span data-ttu-id="5f81c-130">Сценарии</span><span class="sxs-lookup"><span data-stu-id="5f81c-130">Scenarios</span></span>

<span data-ttu-id="5f81c-131">Приведенные выше примеры демонстрируют один из простейших вариантов определения свойств: свойство для чтения и записи без проверки.</span><span class="sxs-lookup"><span data-stu-id="5f81c-131">The examples above showed one of the simplest cases of property definition: a read-write property with no validation.</span></span> <span data-ttu-id="5f81c-132">Путем написания нужного кода в методах доступа `get` и `set` можно реализовать много разных сценариев.</span><span class="sxs-lookup"><span data-stu-id="5f81c-132">By writing the code you want in the `get` and `set` accessors, you can create many different scenarios.</span></span>

### <a name="validation"></a><span data-ttu-id="5f81c-133">Проверка</span><span class="sxs-lookup"><span data-stu-id="5f81c-133">Validation</span></span>

<span data-ttu-id="5f81c-134">Можно написать код в методе доступа `set`, чтобы гарантировать, что значения, представленные свойством, всегда будут допустимыми.</span><span class="sxs-lookup"><span data-stu-id="5f81c-134">You can write code in the `set` accessor to ensure that the values represented by a property are always valid.</span></span> <span data-ttu-id="5f81c-135">Например, предположим, что одно из правил для класса `Person` заключается в том, что имя не может быть пустым или содержать только пробелы.</span><span class="sxs-lookup"><span data-stu-id="5f81c-135">For example, suppose one rule for the `Person` class is that the name cannot be blank or white space.</span></span> <span data-ttu-id="5f81c-136">Это можно реализовать следующим образом:</span><span class="sxs-lookup"><span data-stu-id="5f81c-136">You would write that as follows:</span></span>

[!code-csharp[Validating property setters](../../samples/snippets/csharp/properties/Person.cs#6)]

<span data-ttu-id="5f81c-137">Предыдущий пример можно упростить, воспользовавшись выражением `throw` в рамках проверки метода задания свойства:</span><span class="sxs-lookup"><span data-stu-id="5f81c-137">The preceding example can be simplified by using a `throw` expression as part of the property setter validation:</span></span>

[!code-csharp[Validating property setters](../../samples/snippets/csharp/properties/Person.cs#7)]

<span data-ttu-id="5f81c-138">В приведенном выше примере код применяет правило о том, что имя не может быть пустым или содержать только пробелы.</span><span class="sxs-lookup"><span data-stu-id="5f81c-138">The example above enforces the rule that the first name must not be blank or white space.</span></span> <span data-ttu-id="5f81c-139">Если разработчик пишет</span><span class="sxs-lookup"><span data-stu-id="5f81c-139">If a developer writes</span></span>

```csharp
hero.FirstName = "";
```

<span data-ttu-id="5f81c-140">Это назначение создает исключение `ArgumentException`.</span><span class="sxs-lookup"><span data-stu-id="5f81c-140">That assignment throws an `ArgumentException`.</span></span> <span data-ttu-id="5f81c-141">Поскольку метод доступа set свойства должен иметь тип возвращаемого значения void, чтобы сообщить об ошибках в методе доступа set, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="5f81c-141">Because a property set accessor must have a void return type, you report errors in the set accessor by throwing an exception.</span></span>

<span data-ttu-id="5f81c-142">Этот синтаксис можно расширить для любых компонентов в вашем сценарии.</span><span class="sxs-lookup"><span data-stu-id="5f81c-142">You can extend this same syntax to anything needed in your scenario.</span></span> <span data-ttu-id="5f81c-143">Можно проверить отношения между разными свойствами или соответствие любым внешним условиям.</span><span class="sxs-lookup"><span data-stu-id="5f81c-143">You can check the relationships between different properties, or validate against any external conditions.</span></span> <span data-ttu-id="5f81c-144">Любые допустимые операторы C# являются допустимыми в методе доступа свойства.</span><span class="sxs-lookup"><span data-stu-id="5f81c-144">Any valid C# statements are valid in a property accessor.</span></span>

### <a name="read-only"></a><span data-ttu-id="5f81c-145">Только для чтения</span><span class="sxs-lookup"><span data-stu-id="5f81c-145">Read-only</span></span>

<span data-ttu-id="5f81c-146">До этого момента все примеры определения свойств определяли свойства для чтения и записи с помощью открытых методов доступа.</span><span class="sxs-lookup"><span data-stu-id="5f81c-146">Up to this point, all the property definitions you have seen are read/write properties with public accessors.</span></span> <span data-ttu-id="5f81c-147">Это не единственные операции доступа для свойств.</span><span class="sxs-lookup"><span data-stu-id="5f81c-147">That's not the only valid accessibility for properties.</span></span>
<span data-ttu-id="5f81c-148">Можно создать свойства, доступные только для чтения, или назначить другой уровень доступа для методов set и get.</span><span class="sxs-lookup"><span data-stu-id="5f81c-148">You can create read-only properties, or give different accessibility to the set and get accessors.</span></span> <span data-ttu-id="5f81c-149">Предположим, ваш класс `Person` должен допускать изменение значения свойства `FirstName` только из других методов этого класса.</span><span class="sxs-lookup"><span data-stu-id="5f81c-149">Suppose that your `Person` class should only enable changing the value of the `FirstName` property from other methods in that class.</span></span> <span data-ttu-id="5f81c-150">Вы можете предоставить методу доступа set уровень доступа `private`, а не `public`:</span><span class="sxs-lookup"><span data-stu-id="5f81c-150">You could give the set accessor `private` accessibility instead of `public`:</span></span>

[!code-csharp[Using a private setter for a publicly readonly property](../../samples/snippets/csharp/properties/Person.cs#8)]

<span data-ttu-id="5f81c-151">Теперь к свойству `FirstName` можно получать доступ из любого кода, но назначить его можно только из другого кода в классе `Person`.</span><span class="sxs-lookup"><span data-stu-id="5f81c-151">Now, the `FirstName` property can be accessed from any code, but it can only be assigned from other code in the `Person` class.</span></span>

<span data-ttu-id="5f81c-152">Вы можете добавить любой ограничивающий модификатор доступа для методов доступа set или get.</span><span class="sxs-lookup"><span data-stu-id="5f81c-152">You can add any restrictive access modifier to either the set or get accessors.</span></span> <span data-ttu-id="5f81c-153">Модификатор доступа, установленный для отдельного метода доступа, должен задавать более строгие ограничения, чем модификатор доступа для определения свойства.</span><span class="sxs-lookup"><span data-stu-id="5f81c-153">Any access modifier you place on the individual accessor must be more limited than the access modifier on the property definition.</span></span> <span data-ttu-id="5f81c-154">Приведенный выше пример допустим, так как свойство `FirstName` является открытым (`public`) а метод доступа set — закрытым (`private`).</span><span class="sxs-lookup"><span data-stu-id="5f81c-154">The above is legal because the `FirstName` property is `public`, but the set accessor is `private`.</span></span> <span data-ttu-id="5f81c-155">Нельзя объявить свойство `private` с методом доступа `public`.</span><span class="sxs-lookup"><span data-stu-id="5f81c-155">You could not declare a `private` property with a `public` accessor.</span></span> <span data-ttu-id="5f81c-156">Свойство также можно объявить как `protected`, `internal`, `protected internal` или даже `private`.</span><span class="sxs-lookup"><span data-stu-id="5f81c-156">Property declarations can also be declared `protected`, `internal`, `protected internal`, or, even `private`.</span></span>

<span data-ttu-id="5f81c-157">Также допускается размещение более строгих модификаторов для метода доступа `get`.</span><span class="sxs-lookup"><span data-stu-id="5f81c-157">It is also legal to place the more restrictive modifier on the `get` accessor.</span></span> <span data-ttu-id="5f81c-158">Например, свойство `public` может быть открытым, а метод доступа `get` ограничен типом `private`.</span><span class="sxs-lookup"><span data-stu-id="5f81c-158">For example, you could have a `public` property, but restrict the `get` accessor to `private`.</span></span> <span data-ttu-id="5f81c-159">Этот сценарий редко реализуется на практике.</span><span class="sxs-lookup"><span data-stu-id="5f81c-159">That scenario is rarely done in practice.</span></span>

<span data-ttu-id="5f81c-160">Кроме того, можно ограничить изменения в свойстве, разрешив задавать его только в конструкторе или инициализаторе свойств.</span><span class="sxs-lookup"><span data-stu-id="5f81c-160">You can also restrict modifications to a property so that it can only be set in a constructor or a property initializer.</span></span> <span data-ttu-id="5f81c-161">Внести соответствующие изменения в класс `Person` можно следующим образом:</span><span class="sxs-lookup"><span data-stu-id="5f81c-161">You can modify the `Person` class so as follows:</span></span>

[!code-csharp[A readonly auto implemented property](../../samples/snippets/csharp/properties/Person.cs#9)]

<span data-ttu-id="5f81c-162">Эта функция чаще всего используется для инициализации коллекций, которые представляются как свойства, доступные только для чтения:</span><span class="sxs-lookup"><span data-stu-id="5f81c-162">This feature is most commonly used for initializing collections that are exposed as read-only properties:</span></span>

```csharp
public class Measurements
{
    public ICollection<DataPoint> points { get; } = new List<DataPoint>();
}
```

### <a name="computed-properties"></a><span data-ttu-id="5f81c-163">Вычисляемые свойства</span><span class="sxs-lookup"><span data-stu-id="5f81c-163">Computed properties</span></span>

<span data-ttu-id="5f81c-164">Свойство не обязательно должно просто возвращать значение поля члена.</span><span class="sxs-lookup"><span data-stu-id="5f81c-164">A property does not need to simply return the value of a member field.</span></span> <span data-ttu-id="5f81c-165">Можно создать свойства, возвращающие вычисляемое значение.</span><span class="sxs-lookup"><span data-stu-id="5f81c-165">You can create properties that return a computed value.</span></span> <span data-ttu-id="5f81c-166">Расширим объект `Person` так, чтобы он возвращал полное имя, вычисляемое путем объединения имени и фамилии:</span><span class="sxs-lookup"><span data-stu-id="5f81c-166">Let's expand the `Person` object to return the full name, computed by concatenating the first and last names:</span></span>

[!code-csharp[A computed property](../../samples/snippets/csharp/properties/Person.cs#10)]

<span data-ttu-id="5f81c-167">В примере выше используется функция [интерполяции строк](./language-reference/tokens/interpolated.md) для создания форматированной строки для полного имени.</span><span class="sxs-lookup"><span data-stu-id="5f81c-167">The example above uses the [string interpolation](./language-reference/tokens/interpolated.md) feature to create the formatted string for the full name.</span></span>

<span data-ttu-id="5f81c-168">Можно также использовать *члены, воплощающие выражения*, которые обеспечивают более краткий способ создания вычисляемого свойства `FullName`:</span><span class="sxs-lookup"><span data-stu-id="5f81c-168">You can also use an *expression-bodied member*, which provides a more succinct way to create the computed `FullName` property:</span></span>

[!code-csharp[A computed property using an expression bodied member](../../samples/snippets/csharp/properties/Person.cs#11)]

<span data-ttu-id="5f81c-169">*Члены, воплощающие выражения*, используют синтаксис *лямбда-выражений* для определения метода, который содержит одно выражение.</span><span class="sxs-lookup"><span data-stu-id="5f81c-169">*Expression-bodied members* use the *lambda expression* syntax to define methods that contain a single expression.</span></span> <span data-ttu-id="5f81c-170">Здесь это выражение возвращает полное имя объекта person.</span><span class="sxs-lookup"><span data-stu-id="5f81c-170">Here, that expression returns the full name for the person object.</span></span>

### <a name="cached-evaluated-properties"></a><span data-ttu-id="5f81c-171">Свойства с вычислением в кэше</span><span class="sxs-lookup"><span data-stu-id="5f81c-171">Cached evaluated properties</span></span>

<span data-ttu-id="5f81c-172">Вы можете сочетать концепцию вычисляемого свойства с хранением и созданием *свойства с вычислением в кэше*.</span><span class="sxs-lookup"><span data-stu-id="5f81c-172">You can mix the concept of a computed property with storage and create a *cached evaluated property*.</span></span>  <span data-ttu-id="5f81c-173">Например, можно изменить свойство `FullName` таким образом, чтобы форматирование строки выполнялось только при первом доступе к нему.</span><span class="sxs-lookup"><span data-stu-id="5f81c-173">For example, you could update the `FullName` property so that the string formatting only happened the first time it was accessed:</span></span>

[!code-csharp[Caching the value of a computed property](../../samples/snippets/csharp/properties/Person.cs#12)]

<span data-ttu-id="5f81c-174">Обратите внимание, что приведенный выше код содержит ошибку.</span><span class="sxs-lookup"><span data-stu-id="5f81c-174">The above code contains a bug though.</span></span> <span data-ttu-id="5f81c-175">Если код изменяет значение свойств `FirstName` или `LastName`, ранее вычисленное поле `fullName` является недопустимым.</span><span class="sxs-lookup"><span data-stu-id="5f81c-175">If code updates the value of either the `FirstName` or `LastName` property, the previously evaluated `fullName` field is invalid.</span></span> <span data-ttu-id="5f81c-176">Вам потребуется изменить методы доступа `set` свойств `FirstName` и `LastName`, чтобы вычислить поле `fullName` еще раз:</span><span class="sxs-lookup"><span data-stu-id="5f81c-176">You modify the `set` accessors of the `FirstName` and `LastName` property so that the `fullName` field is calculated again:</span></span>

[!code-csharp[Invalidating the cache correctly](../../samples/snippets/csharp/properties/Person.cs#13)]

<span data-ttu-id="5f81c-177">Эта окончательная версия вычисляет свойство `FullName` только при необходимости.</span><span class="sxs-lookup"><span data-stu-id="5f81c-177">This final version evaluates the `FullName` property only when needed.</span></span>
<span data-ttu-id="5f81c-178">Если ранее вычисленная версия является допустимой, используется она.</span><span class="sxs-lookup"><span data-stu-id="5f81c-178">If the previously calculated version is valid, it's used.</span></span> <span data-ttu-id="5f81c-179">Если другое изменение состояния делает ранее вычисленную версию недействительной, она будет пересчитана.</span><span class="sxs-lookup"><span data-stu-id="5f81c-179">If another state change invalidates the previously calculated version, it will be recalculated.</span></span> <span data-ttu-id="5f81c-180">Разработчикам, использующим этот класс, необязательно знать детали реализации.</span><span class="sxs-lookup"><span data-stu-id="5f81c-180">Developers that use this class do not need to know the details of the implementation.</span></span> <span data-ttu-id="5f81c-181">Ни одно из этих внутренних изменений не влияет на использование объекта person.</span><span class="sxs-lookup"><span data-stu-id="5f81c-181">None of these internal changes affect the use of the Person object.</span></span> <span data-ttu-id="5f81c-182">Это главная причина для использования свойств для предоставления доступа к членам данных объекта.</span><span class="sxs-lookup"><span data-stu-id="5f81c-182">That's the key reason for using Properties to expose data members of an object.</span></span>

### <a name="attaching-attributes-to-auto-implemented-properties"></a><span data-ttu-id="5f81c-183">Присоединение атрибутов к автоматически реализуемым свойствам</span><span class="sxs-lookup"><span data-stu-id="5f81c-183">Attaching attributes to auto-implemented properties</span></span>

<span data-ttu-id="5f81c-184">Начиная с C# 7.3 атрибуты полей можно прикреплять к созданному компилятором резервному полю в автоматически реализуемых свойствах.</span><span class="sxs-lookup"><span data-stu-id="5f81c-184">Beginning with C# 7.3, field attributes can be attached to the compiler generated backing field in auto-implemented properties.</span></span> <span data-ttu-id="5f81c-185">Например, рассмотрим изменение класса `Person`, который добавляет уникальное целочисленное свойство `Id`.</span><span class="sxs-lookup"><span data-stu-id="5f81c-185">For example, consider a revision to the `Person` class that adds a unique integer `Id` property.</span></span>
<span data-ttu-id="5f81c-186">Можно записать свойство `Id` с помощью автоматически реализуемого свойства, но в вашем коде не предусмотрено сохранение свойства `Id`.</span><span class="sxs-lookup"><span data-stu-id="5f81c-186">You write the `Id` property using an auto-implemented property, but your design does not call for persisting the `Id` property.</span></span> <span data-ttu-id="5f81c-187"><xref:System.NonSerializedAttribute> можно прикреплять только к полям, а не свойствам.</span><span class="sxs-lookup"><span data-stu-id="5f81c-187">The <xref:System.NonSerializedAttribute> can only be attached to fields, not properties.</span></span> <span data-ttu-id="5f81c-188">Можно прикрепить <xref:System.NonSerializedAttribute> к резервному полю для свойства `Id` с помощью описателя `field:` в атрибуте, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="5f81c-188">You can attach the <xref:System.NonSerializedAttribute> to the backing field for the `Id` property by using the `field:` specifier on the attribute, as shown in the following example:</span></span>

[!code-csharp[Attaching attributes to a backing field](../../samples/snippets/csharp/properties/Person.cs#14)]

<span data-ttu-id="5f81c-189">Этот способ подходит для любого атрибута, который вы прикрепляете к резервному полю в автоматически реализуемом свойстве.</span><span class="sxs-lookup"><span data-stu-id="5f81c-189">This technique works for any attribute you attach to the backing field on the auto-implemented property.</span></span>

### <a name="implementing-inotifypropertychanged"></a><span data-ttu-id="5f81c-190">Реализация INotifyPropertyChanged</span><span class="sxs-lookup"><span data-stu-id="5f81c-190">Implementing INotifyPropertyChanged</span></span>

<span data-ttu-id="5f81c-191">Последним сценарием, где необходимо написать код в методе доступа к свойству, является поддержка интерфейса <xref:System.ComponentModel.INotifyPropertyChanged>, используемого для уведомления клиентов привязки данных об изменении значения.</span><span class="sxs-lookup"><span data-stu-id="5f81c-191">A final scenario where you need to write code in a property accessor is to support the <xref:System.ComponentModel.INotifyPropertyChanged> interface used to notify data binding clients that a value has changed.</span></span> <span data-ttu-id="5f81c-192">При изменении значения свойства объект вызывает событие <xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged?displayProperty=nameWithType>, указывающее на изменение.</span><span class="sxs-lookup"><span data-stu-id="5f81c-192">When the value of a property changes, the object raises the <xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged?displayProperty=nameWithType> event to indicate the change.</span></span> <span data-ttu-id="5f81c-193">Библиотеки привязки данных, в свою очередь, изменяют отображаемые элементы на основе этого изменения.</span><span class="sxs-lookup"><span data-stu-id="5f81c-193">The data binding libraries, in turn, update display elements based on that change.</span></span> <span data-ttu-id="5f81c-194">В следующем примере кода показано, как можно реализовать свойства `INotifyPropertyChanged` для `FirstName` этого класса person.</span><span class="sxs-lookup"><span data-stu-id="5f81c-194">The code below shows how you would implement `INotifyPropertyChanged` for the `FirstName` property of this person class.</span></span>

[!code-csharp[invalidating the cache correctly](../../samples/snippets/csharp/properties/Person.cs#15)]

<span data-ttu-id="5f81c-195">Оператор `?.` называется оператором *объединения со значением NULL*.</span><span class="sxs-lookup"><span data-stu-id="5f81c-195">The `?.` operator is called the *null conditional operator*.</span></span> <span data-ttu-id="5f81c-196">Он проверяет наличие пустой ссылки перед вычислением правой стороны оператора.</span><span class="sxs-lookup"><span data-stu-id="5f81c-196">It checks for a null reference before evaluating the right side of the operator.</span></span> <span data-ttu-id="5f81c-197">В конечном итоге, если нет подписчиков на событие `PropertyChanged`, код для вызова события не выполняется.</span><span class="sxs-lookup"><span data-stu-id="5f81c-197">The end result is that if there are no subscribers to the `PropertyChanged` event, the code to raise the event doesn't execute.</span></span> <span data-ttu-id="5f81c-198">В этом случае без такой проверки будет создано исключение `NullReferenceException`.</span><span class="sxs-lookup"><span data-stu-id="5f81c-198">It would throw a `NullReferenceException` without this check in that case.</span></span> <span data-ttu-id="5f81c-199">Дополнительные сведения см. на веб-сайте [`events`](events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="5f81c-199">For more information, see [`events`](events-overview.md).</span></span> <span data-ttu-id="5f81c-200">В этом примере также используется новый оператор `nameof` для преобразования символа имени свойства в текстовое представление.</span><span class="sxs-lookup"><span data-stu-id="5f81c-200">This example also uses the new `nameof` operator to convert from the property name symbol to its text representation.</span></span>
<span data-ttu-id="5f81c-201">С помощью `nameof` можно сократить количество ошибок, возникающих при неправильном вводе имени свойства.</span><span class="sxs-lookup"><span data-stu-id="5f81c-201">Using `nameof` can reduce errors where you have mistyped the name of the property.</span></span>

<span data-ttu-id="5f81c-202">Реализация <xref:System.ComponentModel.INotifyPropertyChanged> — это пример случая, когда можно писать код в методах доступа для поддержки необходимых сценариев.</span><span class="sxs-lookup"><span data-stu-id="5f81c-202">Again, implementing <xref:System.ComponentModel.INotifyPropertyChanged> is an example of a case where you can write code in your accessors to support the scenarios you need.</span></span>

## <a name="summing-up"></a><span data-ttu-id="5f81c-203">Подведем итоги</span><span class="sxs-lookup"><span data-stu-id="5f81c-203">Summing up</span></span>

<span data-ttu-id="5f81c-204">Свойства — это своего рода интеллектуальные поля в классе или объекте.</span><span class="sxs-lookup"><span data-stu-id="5f81c-204">Properties are a form of smart fields in a class or object.</span></span> <span data-ttu-id="5f81c-205">Из-за пределов объекта они представляются полями в объекте.</span><span class="sxs-lookup"><span data-stu-id="5f81c-205">From outside the object, they appear like fields in the object.</span></span> <span data-ttu-id="5f81c-206">Однако для реализации свойства можно использовать полную палитру функциональных возможностей C#.</span><span class="sxs-lookup"><span data-stu-id="5f81c-206">However, properties can be implemented using the full palette of C# functionality.</span></span>
<span data-ttu-id="5f81c-207">Вы можете предоставлять разные уровни доступа, выполнять проверки, отложенное вычисление или любые другие требования, необходимые в вашем сценарии.</span><span class="sxs-lookup"><span data-stu-id="5f81c-207">You can provide validation, different accessibility, lazy evaluation, or any requirements your scenarios need.</span></span>
