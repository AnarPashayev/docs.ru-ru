### YamlMime:Tutorial
title: Создание форматированных строк с помощью интерполяции
metadata:
  title: Интерполяция строк. Интерактивное руководство по C#
  description: В этом руководстве вы воспользуетесь браузером для интерактивного ознакомления с функцией интерполяции строк в C#. Вы напишете код C# и сможете просмотреть результаты его компиляции и выполнения непосредственно в браузере.
  audience: Developer
  ms.custom: mvc
  ms.date: 08/24/2018
  level: Beginner
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: 5490176d91a6ed900471e33af6adce1fa3e62d8f
  ms.sourcegitcommit: a3db1a9eafca89f95ccf361bc1833b47fbb2bb30
  ms.translationtype: HT
  ms.contentlocale: ru-RU
  ms.lasthandoff: 04/04/2019
  ms.locfileid: "58921392"
items:
- durationInMinutes: 2
  content: >
    В этом руководстве описывается, как с помощью [интерполяции строк](../../language-reference/tokens/interpolated.md) вставить значения в одну строку. Вы также узнаете, как управлять форматированием текста результирующей строки. Вы напишете и выполните код C# в браузере и сразу же сможете просмотреть результаты.
- title: Создание интерполированной строки
  durationInMinutes: 2
  content: >
    Запустите приведенный ниже код в интерактивном окне. Для этого введите следующий код в интерактивном окне (замените `<name>` своим именем) и нажмите кнопку **Выполнить**:


    ```csharp

    var name = "<name>";

    Console.WriteLine($"Hello, {name}. It's a pleasure to meet you!");

    ```


    При запуске кода в окне **Вывод** отображается строка, которая содержит ваше имя в приветствии. Строковым аргументом в вызове метода <xref:System.Console.WriteLine%2A> является *интерполированная строка*. Это похоже на шаблон, позволяющий создать одну строку (называемую *результирующей строкой*) из строки, содержащей внедренный код. Интерполированные строки особенно удобны при вставке значений в строку или сцеплении (объединении) нескольких строк.


    Приведенный выше пример содержит два элемента, обязательные для каждой интерполированной строки:


    - Строковый литерал, который начинается с символа `$`, стоящего до открывающей кавычки. Между символом `$` и знаком кавычки не должно быть пробелов. (Если вы хотите узнать, что будет при наличии пробела, вставьте его после символа `$` в интерактивном окне и выполните обновленный код. Компилятор C# выдает сообщение "Непредвиденный знак "$"".)


    - Одно или несколько *интерполированных выражений*. Интерполированное выражение обозначено открывающей и закрывающей фигурной скобкой (`{` и `}`). Вы можете указать внутри фигурных скобок любое выражение C#, возвращающее значение (включая `null`).


    Давайте рассмотрим еще несколько примеров интерполяции строк с другими типами данных.


    > [!NOTE]

    > Этот онлайн-интерфейс для написания кода находится на этапе предварительной версии. При возникновении проблем сообщите о них на странице [репозитория dotnet/try](https://github.com/dotnet/try/issues).
- title: Включение разных типов данных
  durationInMinutes: 5
  content: >
    В предыдущем шаге вы использовали интерполяцию строк для вставки одной строки внутрь другой. Однако интерполированное выражение может относиться к любому типу данных. Давайте включим в интерполированную строку значения разных типов данных.


    В приведенном ниже примере сначала мы определим тип данных для [класса](../../programming-guide/classes-and-structs/classes.md) `Vegetable`, обладающего [свойством](../../properties.md) `Name` и [методом](../../methods.md) `ToString`. Этот метод [переопределяет](../../language-reference/keywords/override.md) поведение метода <xref:System.Object.ToString?displayProperty=nameWithType>. [Модификатор доступа ](../../language-reference/keywords/public.md)`public` делает этот метод доступным любому клиентскому коду и позволяет получить строковое представление экземпляра `Vegetable`. В примере метод `Vegetable.ToString` возвращает значение свойства `Name`, которое инициализируется в [конструкторе](../../programming-guide/classes-and-structs/constructors.md) `Vegetable`: `Vegetable(string name) => Name = name;`. Затем создайте экземпляр класса `Vegetable` с именем `item`, воспользовавшись [ключевым словом`new`](../../language-reference/keywords/new-operator.md) и указав параметр имени для конструктора `Vegetable`. Наконец, этот экземпляр включается в интерполированную строку, которая также содержит значение <xref:System.DateTime>, значение <xref:System.Decimal> и значение [перечисления](../../programming-guide/enumeration-types.md) `Unit`. Запустите приведенный ниже код в интерактивном окне.


    ```csharp

    public class Vegetable

    {
       public Vegetable(string name) => Name = name;

       public string Name { get; }

       public override string ToString() => Name;
    }


    public enum Unit { item, kilogram, gram, dozen };


    var item = new Vegetable("eggplant");

    var date = DateTime.Now;

    var price = 1.99m;

    var unit = Unit.item;

    Console.WriteLine($"On {date}, the price of {item} was {price} per {unit}.");

    ```


    Обратите внимание на то, что интерполированное выражение `item` в интерполированной строке разрешается в текст "eggplant" в результирующей строке. Связано это с тем, что если результат выражения не имеет строковый тип, он разрешается в строку описанным ниже образом.


    - Если результатом вычисления интерполированного выражения является `null`, используется пустая строка ("" или <xref:System.String.Empty?displayProperty=nameWithType>).


    - Если результатом вычисления интерполированного выражения не является `null`, обычно вызывается метод `ToString` результирующего типа. Чтобы проверить это, можно изменить реализацию метода `Vegetable.ToString`. Возможно, вам вообще не потребуется реализовывать метод `ToString`, так как его реализация в той или иной форме присутствует в каждом типе. Это можно проверить, закомментировав определение метода `Vegetable.ToString` в примере, для чего перед ним нужно поставить символ комментария (`//`). В выходных данных строка "eggplant" заменяется полным именем типа (пространство имен, определенное REPL, вместе с именем типа), что является стандартным поведением метода <xref:System.Object.ToString?displayProperty=nameWithType>. По умолчанию метод `ToString` возвращает для значения перечисления строковое представление значения.


    В выходных данных этого примера дата является слишком точной (цена на баклажаны не меняется каждую секунду), а в значении цены не указана единица валюты. В следующем шаге вы узнаете, как устранить эти проблемы, управляя форматом строковых представлений результатов выражений.


    > [!NOTE]

    > Этот онлайн-интерфейс для написания кода находится на этапе предварительной версии. При возникновении проблем сообщите о них на странице [репозитория dotnet/try](https://github.com/dotnet/try/issues).
- title: Управление форматированием интерполированных выражений
  durationInMinutes: 5
  content: >
    В предыдущем шаге мы вставили две неправильно отформатированные строки в результирующую строку. Первая была значением даты и времени, при этом допустимой была только дата. Вторая была ценой, в которой отсутствовала единица валюты. Обе эти проблемы легко решить. Интерполяция строк позволяет указывать *строки формата*, управляющие форматированием определенных типов. Измените вызов `Console.WriteLine` из предыдущего примера, включив в него строки формата для выражений даты и цены, как показано в следующей строке:


    ```csharp

    Console.WriteLine($"On {date:d}, the price of {item} was {price:C2} per {unit}.");

    ```


    Задайте строку формата, указав ее после интерполированного выражения через точку с запятой. "d" — это [стандартная строка формата для даты и времени](../../../standard/base-types/standard-date-and-time-format-strings.md#the-short-date-d-format-specifier), представляющая краткий формат. "C2" — это [стандартная строка числового формата](../../../standard/base-types/standard-numeric-format-strings.md#the-currency-c-format-specifier), представляющая число в виде денежной единицы с точностью два знака после запятой.


    Некоторые типы в библиотеках .NET поддерживают предопределенный набор строк формата. К ним относятся все числовые типы, а также типы даты и времени. Полный список типов, поддерживающих строки формата, см. в разделе [Строки формата и типы библиотек классов .NET](../../../standard/base-types/formatting-types.md#stringRef) статьи [Типы форматирования в .NET](../../../standard/base-types/formatting-types.md).


    Попробуйте изменить строки формата в примере, чтобы узнать, как они влияют на форматирование даты и времени, а также числового значения. Измените "d" в `{date:d}` на "t" (чтобы отобразить краткий формат времени), "y" (чтобы отобразить год и месяц) и "yyyy" (чтобы отобразить год в виде четырехзначного числа). Измените "C2" в `{price:C2}` на "e" (для экспоненциального представления) и "F3" (чтобы получить числовое значение с тремя знаками после запятой).


    Кроме форматирования, вы можете управлять шириной поля и выравниванием для форматированных строк, включаемых в результирующую строку. В следующем шаге вы научитесь это делать.


    > [!NOTE]

    > Этот онлайн-интерфейс для написания кода находится на этапе предварительной версии. При возникновении проблем сообщите о них на странице [репозитория dotnet/try](https://github.com/dotnet/try/issues).
- title: Управление шириной поля и выравниванием для интерполированных выражений
  durationInMinutes: 6
  content: >
    Как правило, когда результат интерполированного выражения форматируется как строка, эта строка включается в результирующую без начальных или конечных пробелов. Особенно когда вы работаете с набором данных, возможность управления шириной поля и выравниванием помогает получить более понятные выходные данные. Это можно продемонстрировать на приведенном ниже примере кода.


    ```csharp
      var inventory = new Dictionary<string, int>()
      {
          ["hammer, ball pein"] = 18,
          ["hammer, cross pein"] = 5,
          ["screwdriver, Phillips #2"] = 14
      };

      Console.WriteLine($"Inventory on {DateTime.Now:d}");
      Console.WriteLine(" ");
      Console.WriteLine($"|{"Item",-25}|{"Quantity",10}|");
      foreach (var item in inventory)
         Console.WriteLine($"|{item.Key,-25}|{item.Value,10}|");
    ```


    Имена элементов выровнены по левому краю, а их количества — по правому. Вы можете указать выравнивание, добавив запятую (",") после интерполированного выражения и назначив *минимальную* ширину поля. Если указанное значение является положительным числом, то поле выравнивается по правому краю. Если оно является отрицательным числом, то поле выравнивается по левому краю.


    Попробуйте удалить знаки "минус" из кода `{"Item",-25}` и `{item.Key,-25}`, а затем снова выполните пример. На этот раз имена элементов выровнены по правому краю.


    Вы можете совмещать описатель выравнивания и строку формата в одном интерполированном выражении. Для этого сначала укажите выравнивание, а затем через двоеточие строку формата. Попробуйте выполнить приведенный ниже код, который выводит три отформатированные строки с заданной шириной поля.


    ```csharp

    Console.WriteLine($"[{DateTime.Now,-20:d}] Hour [{DateTime.Now,-10:HH}] [{1063.342,15:N2}] feet");

    ```


    > [!NOTE]

    > Этот онлайн-интерфейс для написания кода находится на этапе предварительной версии. При возникновении проблем сообщите о них на странице [репозитория dotnet/try](https://github.com/dotnet/try/issues).
- content: >-
    Вы завершили работу с интерактивным руководством по интерполяции строк. Вы можете выбрать ссылку **Коллекции в C#** ниже, чтобы запустить следующее интерактивное руководство, либо посетить [сайт .NET](https://www.microsoft.com/net/learn/dotnet/hello-world-tutorial), чтобы скачать пакет SDK для .NET Core, создать проект на своем компьютере и продолжить написание кода. На шаге "Продолжение обучения" вы вернетесь к этим учебникам.


    Дополнительные сведения см. в разделе [Интерполяция строк](../../language-reference/tokens/interpolated.md).
