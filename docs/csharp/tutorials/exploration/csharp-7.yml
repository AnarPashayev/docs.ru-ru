### YamlMime:Tutorial
title: Изучите C# 7.0 — интерактивный учебник по C#
metadata:
  title: Изучите C# 7.0 — испытайте новые возможности C# 7.0 в интерактивном режиме с помощью браузера
  description: В этом руководстве для интерактивного изучения C# 7.0 используется браузер. Изучите новые идиомы, которые можно использовать с C# 7.0; они делают код более кратким и удобочитаемым.
  audience: Developer
  level: intermediate
  ms.date: 03/20/2019
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: 7cec35e0749ea0b38162244171459f311d27cb25
  ms.sourcegitcommit: a8d3504f0eae1a40bda2b06bd441ba01f1631ef0
  ms.translationtype: HT
  ms.contentlocale: ru-RU
  ms.lasthandoff: 06/18/2019
  ms.locfileid: "67170223"
items:
- durationInMinutes: 1
  content: >
    Это руководство поможет в интерактивном изучении C# 7.0. С помощью браузера вы напишете код на C# и сможете просмотреть результаты его компиляции и выполнения. Оно содержит ряд уроков, которые заменят более ранние рекомендации по C# на более новые и краткие возможности C# 7.0. В оставшейся части этой статьи приведены общие сведения о каждой из этих функций со ссылкой для изучения каждого компонента.
- title: Объявления исходящих переменных в месте назначения
  durationInMinutes: 2
  content: "Существующий синтаксис, поддерживающий параметры `out`, в этой версии был улучшен. Нажмите кнопку *Войти в режим фокусировки*, расположенную в нижней части этой страницы, а затем запустите этот код в интерактивном окне: \n\n[!code-csharp[OutVariableOldStyle](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableOldStyle \"classic out variable declaration\")]\n\nПеременные `out` можно объявлять в списке аргументов в вызове метода, не записывая отдельный оператор объявления: Объявление можно переместить в вызов метода. Добавьте следующий код в нижней части интерактивного окна:\n\n[!code-csharp[OutVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableDeclarations \"Out variable declarations\")]\n\nВы можете заменить объявление `int` на объявление `var`. Добавьте приведенный ниже код в интерактивном окне.\n\n[!code-csharp[OutVarVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVarVariableDeclarations \"Implicitly typed Out variable\")]\n\nНовый синтаксис дает два важных преимущества по сравнению с существующим:\n\n* Код проще читать. \n    - Переменная out объявляется при использовании, а не в другой, вышестоящей строке.\n* Назначать начальное значение не нужно.\n    - Объявляя переменную `out`, когда она используется при вызове метода, ее нельзя случайно использовать прежде, чем она будет назначена.\n\nОбласть видимости объявленной переменной является областью, в которой стоит инструкция `if`. Это позволяет использовать переменную позднее. Замените последний блок `if`, как показано в следующем фрагменте.\n\n```csharp\nif (!int.TryParse(input, out int result))\n{    \n    return null;\n}\n\nConsole.WriteLine(result);\n```\n"
- title: Кортежи — облегченные структуры данных
  durationInMinutes: 1
  content: "Кортежи — это упрощенные структуры данных, содержащие несколько полей для представления элементов данных. Поля не проверяются, и собственные методы определять невозможно.\n\n> [!NOTE]\n> Кортежи существовали и в версиях C#, предшествовавших версии 7.0, но были неэффективны и не имели языковой поддержки. Это означает, что ссылки на элементы кортежа можно было задавать только в виде `Item1`, `Item2` и т. д. В C# 7.0 реализуется языковая поддержка кортежей, что позволяет работать с семантическими именами полей кортежа с использованием новых, более эффективных типов кортежей.\n\nЧтобы создать кортеж, назначьте значение каждому именованному элементу:\n\n[!code-csharp[NamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#NamedTuple \"Named tuple\")]\n\nКортеж `namedLetters` содержит поля, которые называются `Alpha` и `Beta`. Эти имена существуют только во время компиляции и не сохраняются во время выполнения (например, при проверке кортежа посредством отражения во время выполнения).\n\nВ назначении кортежа можно также указать имена полей в правой части назначения: \n\n[!code-csharp[ImplicitNamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#ImplicitNamedTuple \"Implicitly named tuple\")]\n\nВы можете задать имена для полей как в левой, так и в правой части присваивания, но имена справа игнорируются.\n\nКортежи наиболее полезны в качестве типов возвращаемых значений для методов `private` и `internal`. Они позволяют использовать простой синтаксис для возвращения нескольких дискретных значений в этих методах.\n\nГораздо эффективнее и результативнее создать кортеж, чем класс или структуру. Это позволяет определять структуру данных, содержащую больше одного значения, используя более простой, облегченный синтаксис. В следующем примере метод возвращает минимальное и максимальное значения в последовательности целых чисел. Добавьте приведенный ниже код в браузер, чтобы посмотреть на результат:\n\n[!code-csharp[TupleReturningMethod](~/samples/snippets/csharp/new-in-7/program.cs#TupleReturningMethod \"Tuple returning method\")]\n\nВ некоторых случаях элементы возвращаемого методом кортежа необходимо распаковать.  С этой целью для каждого значения в этом кортеже объявляется отдельная переменная. Это называется *деконструкцией* кортежа. Добавьте приведенный ниже код в браузер, чтобы посмотреть на результат:\n\n[!code-csharp[CallingWithDeconstructor](~/samples/snippets/csharp/new-in-7/program.cs#CallingWithDeconstructor \"Deconstructing a tuple\")]\n\nПри работе с кортежами часто происходит так, что вы используете не все члены результирующего кортежа. Когда это происходит, вы можете отбросить часть несколько возвращаемых значений, задав `_` вместо переменной. Добавьте приведенный ниже код в браузер, чтобы посмотреть на результат:\n\n[!code-csharp[DiscardTupleMember](~/samples/snippets/csharp/new-in-7/program.cs#DiscardMember \"Discard a tuple member\")]\n\nДополнительные сведения о кортежах см. в [статье о кортежах](../../tuples.md).\nДополнительные сведения о пустых переменных см. в [статье про пустые переменные](../../discards.md).\n"
- title: Используйте шаблон типа с выражением is
  durationInMinutes: 2
  content: >
    Выражение шаблона `is` позволяет использовать знакомый [оператор `is`](../../language-reference/keywords/is.md#pattern-matching-with-is) для запроса объектов без учета их типов.


    Добавьте приведенный ниже код в браузер:


    [!code-csharp[SimpleIs](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleIsPattern "Simple Is pattern")]


    Измените объявление переменной на строковую:


    ```csharp

    object count = "5";

    ```


    Теперь `is` выражение имеет значение false, поэтому исполняется ветвь `else`. Попробуйте изменить `count` на `number` в ветви else:


    ```csharp

    Console.WriteLine($"{number} is not an integer");

    ```


    Код выше не будет компилироваться, поскольку `number` не назначается в ветви `else`. Оно назначается только в ветви `true` инструкции `if`.


    Выражения шаблона типа `is` полезны, если есть небольшое количество типов, которые нужно проверять. Часто может потребоваться проверить несколько типов. Это требует инструкции для сопоставления по шаблону `switch`.
- title: Сопоставление шаблонов в инструкции switch
  durationInMinutes: 2
  content: >
    *Выражение сопоставления* имеет знакомый синтаксис, основанный на операторе `switch`, который уже является частью языка C#. Давайте начнем с небольшого примере на основе синтаксиса выражений `is`, которые вы изучили на предыдущей странице:


    [!code-csharp[SimpleSwitch](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleSwitchPattern "simple switch")]


    Приведенный выше код проверяет наличие `int` или `null`. Любые другие типы дадут вариант по умолчанию. Добавьте следующие две строки для проверки поведения:


    [!code-csharp[AddLongCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestLong "Add a case for long")]


    Выражение `switch` преобразует тип, допускающий значение NULL, в соответствующий тип. Добавьте для проверки следующее:


    [!code-csharp[NullableCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#NullableSwitch "Add a nullable case")]


    В инструкции switch можно добавить любое количество других выражений для шаблона типа. Добавьте следующее перед вариантом `null`:


    [!code-csharp[MoreTypeCases](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreCases "Add more type cases")]


    Убедитесь, что это работает, добавив следующие проверки:


    [!code-csharp[AddMoreTests](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreTests "Add more type tests")]


    Кроме того, выражения сопоставления поддерживают константы. Это позволяет экономить время, выделяя простые варианты:


    [!code-csharp[ConstantCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#ConstantCase "Add a constant case")]


    Необходимо добавить предыдущий вариант *перед* выражением `case int:`. Если добавить его после, компилятор выдает предупреждение о том, что он уже обрабатывается предыдущей меткой case.


    Вы можете добавить предложение `when` в любой вариант с шаблоном; таким образом, вы можете проверять другие условия помимо типа или константы. Попробуйте эту возможность, добавив следующий вариант выше общего `string`:


    [!code-csharp[WhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#WhenClause "Add a when clause")]


    Для проверки добавьте примерно следующее:


    [!code-csharp[TestWhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestWhenClause "Test the when clause")]


    Новый синтаксис для выражений сопоставления шаблонов упрощает процесс создания алгоритмов ветвления на основе типа или других свойств объекта, позволяя использовать ясный и четкий синтаксис. Выражения сопоставления шаблонов включают эти конструкции для типов данных, не связанных наследованием.


    Дополнительные сведения о сопоставлении шаблонов см. в статье, посвященной [сопоставлению шаблонов в C#](../../pattern-matching.md).
- title: Оптимизация памяти хранилища, использующая ссылочные локальные переменные и возвращаемые значения
  durationInMinutes: 2
  content: >
    Эта функция активирует алгоритмы, которые используют и возвращают ссылки на переменные, определенные в другом месте. В качестве примера можно привести работу с большими матрицами и поиск одного местоположения с определенными характеристиками. Один метод возвращает два индекса для одного местоположения в матрице:


    [!code-csharp[EverythingByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#EverythingByValue "return indices by value")]


    Этот код можно проверить с помощью следующего кода:


    [!code-csharp[TestByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#TestByValue "test code for return indices by value")]



    Этот метод `Find` возвращает индексы в элемент матрицы. В результате вызывающие объекты записывают код, который использует эти индексы, чтобы разыменовать матрицу и изменить отдельный элемент. Вместо этого лучше написать метод, возвращающий *ссылку* на элемент матрицы, который нужно изменить.


    Рассмотрим подробно ряд изменений, чтобы продемонстрировать локальную функцию ref и показать, каким образом создается метод, возвращающий ссылку на внутреннее хранилище. Параллельно вы узнаете правила возвращаемого значения ref и локальной функции ref, которая защищает вас от случайных ошибок в его использовании.


    Для начала изменим объявление метода `Find` таким образом, чтобы вместо кортежа он возвращал `ref int`.


    ```csharp

    ref int Find(int[,] matrix, Func<int, bool> predicate)

    ```


    Измените инструкцию return для возвращения элемента с правильными индексами:


    ```csharp

    return matrix[i,j];

    ```


    Измените итоговый return, чтобы порождалось исключение:


    ```csharp

    throw new InvalidOperationException("Not found");

    ```


    Обратите внимание, что это не будет компилироваться. В объявлении метода указывается возврат `ref`, но инструкция return указывает возвращаемое значение. Необходимо добавить ключевое слово `ref` в каждый return. Это обозначает возврат по ссылке и позволяет разработчикам, которые будут читать код позднее, запомнить, что метод возвращается по ссылке:


    ```csharp

    return ref matrix[i,j];

    ```


    Теперь, когда метод возвращает ссылку на целочисленное значение в матрице, необходимо изменить место его вызова. Объявление `var` означает, что `valItem` теперь не кортеж, а `int`. Измените вызывающий код следующим образом:


    ```csharp

    var valItem = Find(matrix, (val) => val == 42);

    Console.WriteLine(valItem);

    valItem = 24;

    Console.WriteLine(matrix[4, 2]);

    ```


    Второй оператор `WriteLine` в приведенном выше примере выводит на экран значение `42`, а не `24`. Переменная `valItem` — это `int`, а не `ref int`. Ключевое слово `var` дает компилятору возможность указать тип, но не позволяет неявно добавить модификатор `ref`. Вместо этого значение, на которое ссылается `ref return`, *копируется* в переменную в левой части назначения. Переменная не является локальной переменной `ref`.


    Для изменения возвращенной ссылки необходимо добавить модификатор `ref` в объявление локальной переменной перед вызовом `Find`, чтобы в случае, если возвращаемое значение является ссылкой, переменная стала ссылкой. Измените проверочный код в браузере в соответствии со следующим:


    [!code-csharp[TestByRef](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#TestByRef "test code for return object by reference")]


    Второй оператор `WriteLine` в приведенном выше примере выводит на экран значение `24`, показывая, что хранилище в матрице было изменено. Локальная переменная объявлена с помощью модификатора `ref` и принимает возвращаемое значение `ref`. Переменную `ref` необходимо инициализировать при объявлении, отделять объявление от инициализации нельзя.


    Язык C# включает три других правила, которые защищают вас от неправильного использования возвращаемых значений и локальных переменных `ref`.


    * Присвоить локальной переменной `ref` стандартное возвращаемое значение метода нельзя.

    * Переменную `ref` нельзя возвращать переменной, которая продолжает существовать даже после того, как метод будет выполнен.

    * Возвращаемые значения и локальные переменные `ref` не могут использоваться с асинхронными методами.


    Добавление локальных переменных и возвращаемых значений ref дает возможность использовать более эффективные алгоритмы, поскольку избавляет от необходимости многократно копировать значения или выполнять операции разыменования.


    Дополнительные сведения см. в статье [ref (Справочник по C#)](../../language-reference/keywords/ref.md).
- title: Ограничение доступа к коду с помощью локальных функций
  durationInMinutes: 2
  content: "Теперь можно объявлять локальные функции, вложенные в другие функции. Это позволяет свести к минимуму видимость этих функций. Существует три очевидных варианта использования локальных функций:\n\n- Рекурсивные функции.\n- Методы итератора.\n- Асинхронные методы.\n\nДавайте начнем с рекурсивных методов. Добавьте следующий код в браузере, чтобы вычислить `6!` (факториал):\n\n```csharp\nint LocalFunctionFactorial(int n)\n{\n    return nthFactorial(n);\n\n    int nthFactorial(int number) => (number < 2) ? \n        1 : number * nthFactorial(number - 1);\n}\n\nConsole.WriteLine(LocalFunctionFactorial(6));\n```\n\nЛокальные функции являются отличным способом реализации рекурсивных алгоритмов. Другие распространенные варианты — открытые методы итератора и открытые асинхронные методы. Оба эти типа методов создают код, который сообщает об ошибках позднее, чем могут ожидать программисты. В случае методов итератора исключения наблюдаются только при вызове кода, перечисляющего возвращенную последовательность. В случае асинхронных методов исключения наблюдаются только при ожидании возвращаемого объекта `Task`.\n\nМетоды итератора легче просматривать в браузере, так что давайте использовать их в этом обзоре. Попробуйте выполнить следующий код, который вызывает метод итератора в браузере:\n\n[!code-csharp[IteratorMethod](~/samples/snippets/csharp/new-in-7/Iterator.cs#SnippetIteratorMethod \"Iterator method\")]\n\nВыполните код. Обратите внимание, что исключение порождается, когда код начинается итерацию по второму результирующему набору. Код, который выполняет итерацию по первому результирующему набору, уже выполнен. Это небольшой пример, где структуры данных не изменяются, так что он безвреден и его легко исправить. Но в более крупной программе, где два объекта итератора могут быть созданы разными дочерними методами, корневую причину может быть трудно найти. Если первый метод итератора изменит состояние данных, он может даже вызвать повреждение данных. Вы бы предпочли получить исключение немедленно, перед выполнением какой-либо дальнейшей работы. Вы можете выполнить рефакторинг кода, чтобы открытый метод проверял все аргументы, а локальная функция выполняла перечисление:\n\n[!code-csharp[IteratorMethodRefactored](~/samples/snippets/csharp/new-in-7/Iterator.cs#IteratorMethodLocalInteractive \"Iterator method refactored\")]\n\nПриведенная выше версия поясняет, что ссылка на локальный метод возможна только в контексте внешнего метода. Кроме того, правила для локальных функций не позволяют разработчику случайно вызвать локальную функцию из другого места в классе и обойти проверку аргументов.\n\nТа же методика может применяться с методами `async` для того, чтобы исключения, возникающие при проверке параметров, выдавались до начала асинхронной работы.\n\n> [!NOTE]\n> Некоторые из макетов, поддерживаемых локальными функциями, также могут выполняться с помощью *лямбда-выражений*. Если вам интересно, [прочтите более подробные сведения о различиях](../../local-functions-vs-lambdas.md).\n"
- content: Мы завершили подробное описание новых важных функций в C# 7. Теперь попробуйте их самостоятельно в ваших приложениях. Вы найдете полный список в статье [Новые возможности C# 7](../../whats-new/csharp-7.md).
