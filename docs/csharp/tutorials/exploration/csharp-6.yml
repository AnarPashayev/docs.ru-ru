### YamlMime:Tutorial
title: <span data-ttu-id="009ba-101">Изучите C# 6 — интерактивный учебник по C#</span><span class="sxs-lookup"><span data-stu-id="009ba-101">Explore C# 6 - C# interactive C# tutorial</span></span>
metadata:
  title: Изучите C# 6 — испытайте новые возможности C# 6 в интерактивном режиме с помощью браузера
  description: В этом руководстве для интерактивного изучения C# 6 используется браузер. Изучите новые идиомы, которые можно использовать с C# 6; они делают код более кратким и удобочитаемым.
  audience: Developer
  level: intermediate
  ms.date: 12/11/2018
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: e1414c17cefd0fb31bb782a311e11dbd4cc056bb
  ms.sourcegitcommit: 093571de904fc7979e85ef3c048547d0accb1d8a
  ms.translationtype: HT
  ms.contentlocale: ru-RU
  ms.lasthandoff: 09/06/2019
  ms.locfileid: "70394087"
items:
- durationInMinutes: 1
  content: >
    <span data-ttu-id="009ba-105">Это руководство поможет в интерактивном изучении C# 6. С помощью браузера вы напишете код на C# и сможете просмотреть результаты его компиляции и выполнения.</span><span class="sxs-lookup"><span data-stu-id="009ba-105">This tutorial lets you explore C# 6 interactively, using your browser to write C# and see the results of compiling and running your code.</span></span> <span data-ttu-id="009ba-106">Оно содержит ряд уроков, которые заменят более ранние рекомендации по C# на более новые и краткие возможности C# 6.</span><span class="sxs-lookup"><span data-stu-id="009ba-106">It contains a series of lessons that modify earlier C# practices to use newer, more concise C# 6 features.</span></span> <span data-ttu-id="009ba-107">В оставшейся части этой статьи приведены общие сведения о каждой из этих функций со ссылкой для изучения каждого компонента.</span><span class="sxs-lookup"><span data-stu-id="009ba-107">The rest of this article provides an overview of each of these features, with a link to explore each feature.</span></span>
- title: <span data-ttu-id="009ba-108">Автосвойства только для чтения позволяют реализовать типы "только для чтения"</span><span class="sxs-lookup"><span data-stu-id="009ba-108">Read-only auto-properties enable read-only types</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"009ba-109\">Два расширения синтаксиса автосвойств позволяют упростить их использование в новых местах: это автосвойства только для чтения и инициализаторы автосвойств.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-109\">Two enhancements to auto-property syntax make it easier to use auto-properties in more places: read-only auto-properties and auto-property initializers.</span></span> <span data-ttu-id=\"009ba-110\">Рассмотрим следующую небольшую программу:</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-110\">Consider this small program:</span></span>\n\n[!code-csharp[Starter](../../../../samples/csharp/tutorials/exploration/csharp6-starter/Program.cs)]  \n\n    \n <span data-ttu-id=\"009ba-111\">Запустите режим фокусировки и скопируйте приведенный выше код в интерактивное окно C#.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-111\">Enter Focus mode, copy the preceding code into the C# interactive window.</span></span> <span data-ttu-id=\"009ba-112\">Затем нажмите кнопку *Запуск*, чтобы увидеть, что делает код.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-112\">Then, click *Run* to see what the code does.</span></span> <span data-ttu-id=\"009ba-113\">`AllCaps` имеет нежелательный побочный эффект изменения значений свойств, а также возвращает строку в верхнем регистре.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-113\">`AllCaps` has the undesirable side effect of modifying the property values along with returning the uppercase string.</span></span> <span data-ttu-id=\"009ba-114\">Автор класса `Person` хотел сделать строки `FirstName` и `LastName` доступными только для чтения.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-114\">The author of the `Person` class intended the strings for `FirstName` and `LastName` to be read-only.</span></span> <span data-ttu-id=\"009ba-115\">С помощью C# 6 можно сделать это намерение явным.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-115\">With C# 6, you can make that intent clear.</span></span> <span data-ttu-id=\"009ba-116\">Удалите `private set` из обоих свойств, чтобы создать автосвойство только для чтения.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-116\">Remove the `private set` from both properties to create a read-only auto property.</span></span> <span data-ttu-id=\"009ba-117\">Нажмите кнопку *Запуск*, чтобы увидеть, что компилятор отметит два места, где свойства `FirstName` и `LastName` изменяются в том случае, когда это не требовалось.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-117\">Click *Run* to see that the compiler spots the two locations where the `FirstName` and `LastName` properties are changed when they should not have been.</span></span> <span data-ttu-id=\"009ba-118\">Вы можете заменить метод `AllCaps` на следующий код, чтобы устранить эту ошибку компилятора:</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-118\">You can change the `AllCaps` method to the following code to fix the compiler error:</span></span>\n\n```csharp\npublic string AllCaps()\n{\n  return ToString().ToUpper();\n}\n```\n\n<span data-ttu-id=\"009ba-119\">При использовании этого нового синтаксиса компилятор гарантирует, что свойства являются неизменяемыми.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-119\">Using this new syntax, the compiler ensures that the properties are immutable.</span></span>\n"
- title: <span data-ttu-id="009ba-120">Инициализация резервных полей для автосвойств</span><span class="sxs-lookup"><span data-stu-id="009ba-120">Initialize backing fields for auto-properties</span></span>
  durationInMinutes: 1
  content: "<span data-ttu-id=\"009ba-121\">Новый синтаксис в C# 6 позволяет использовать инициализаторы для автосвойств.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-121\">New syntax in C# 6 enables you to use initializers for auto-properties.</span></span> <span data-ttu-id=\"009ba-122\">Это становится все более важно по мере появления новых возможностей классов.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-122\">This becomes more important as classes grow new capabilities.</span></span> <span data-ttu-id=\"009ba-123\">Добавим свойство для отчества и новый конструктор, принимающий три строки для вашего класса `Person`:</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-123\">Add a middle name property, and a new constructor that takes three strings to your `Person` class:</span></span>\n\n[!code-csharp[MiddleName](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#MiddleName)]  \n\n<span data-ttu-id=\"009ba-124\">Присваивание свойству `MiddleName` — это инициализатор.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-124\">The assignment on the `MiddleName` property is an initializer.</span></span> <span data-ttu-id=\"009ba-125\">Он инициализирует созданное компилятором резервное поле для отчества.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-125\">It initializes the compiler-generated backing field for the middle name.</span></span>\n"
- title: <span data-ttu-id="009ba-126">Элементы, воплощающие выражение</span><span class="sxs-lookup"><span data-stu-id="009ba-126">Expression-bodied members</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="009ba-127">Элементы, воплощающие выражение, предоставляют упрощенный синтаксис для упрощенных методов.</span><span class="sxs-lookup"><span data-stu-id="009ba-127">Expression-bodied members provide a lightweight syntax for lightweight methods.</span></span> <span data-ttu-id="009ba-128">В классе `Person` есть два оптимальных кандидата.</span><span class="sxs-lookup"><span data-stu-id="009ba-128">The `Person` class has two great candidates.</span></span> <span data-ttu-id="009ba-129">Посмотрите на объявление `ToString`:</span><span class="sxs-lookup"><span data-stu-id="009ba-129">Look at the declaration of `ToString`:</span></span>


    ```csharp

    public override string ToString()

    {
        return FirstName + " " + LastName;
    }

    ```


    <span data-ttu-id="009ba-130">Замените объявление `ToString` следующим кодом:</span><span class="sxs-lookup"><span data-stu-id="009ba-130">Replace that declaration of `ToString` with the following code:</span></span>


    ```csharp

    public override string ToString() => FirstName + " " + LastName;

    ```


    <span data-ttu-id="009ba-131">Повторите то же самое с методом `AllCaps`.</span><span class="sxs-lookup"><span data-stu-id="009ba-131">Try the same with the `AllCaps` method.</span></span> <span data-ttu-id="009ba-132">Это незначительное улучшение, но при рациональном использовании оно создает гораздо более удобочитаемый код, особенно для объектов передачи данных (DTO) и других типов с минимальными поведением.</span><span class="sxs-lookup"><span data-stu-id="009ba-132">This is a small improvement, but when used wisely it creates much more readable code, especially for Data Transfer Objects (DTOs) and other types with minimal behavior.</span></span>
- title: <span data-ttu-id="009ba-133">Импорт одиночного класса</span><span class="sxs-lookup"><span data-stu-id="009ba-133">Importing a single class</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"009ba-134\">Если постоянно использовать статические методы одного класса во всем коде, включение имени класса каждый раз искажает смысл кода.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-134\">If you repeatedly use one class' static methods throughout your code, including the class name each time obscures the meaning of your code.</span></span> <span data-ttu-id=\"009ba-135\">Класс `Person` в настоящее время импортирует пространство имен `System` несмотря на то, что используется только <xref:System.Console?displayProperty=nameWithType>.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-135\">The `Person` class currently imports the `System` namespace, even though only <xref:System.Console?displayProperty=nameWithType> is used.</span></span> <span data-ttu-id=\"009ba-136\">Измените оператор `using` следующим образом:</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-136\">Modify the `using` statement as follows:</span></span>\n\n[!code-csharp[MiddleName](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#UsingStatic)]  \n\n<span data-ttu-id=\"009ba-137\">Оператор `static using` лучше подходит для более крупных программ, активно использующих один класс со множеством статических методов, таких как класс [`string`](xref:System.String) или <xref:System.Math?displayProperty=nameWithType>.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-137\">The `static using` statement becomes more useful in larger programs that make extensive use of a single class with many static methods, like the [`string`](xref:System.String) class or the <xref:System.Math?displayProperty=nameWithType> class.</span></span>\n"
- title: <span data-ttu-id="009ba-138">Улучшенный формат строк</span><span class="sxs-lookup"><span data-stu-id="009ba-138">A better string format</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"009ba-139\">C# версии 6 содержит новый синтаксис для составления строк из строки и встроенных выражений, вычисление которых позволяет получить другие строковые значения.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-139\">C# 6 contains new syntax for composing strings from a string and embedded expressions that are evaluated to produce other string values.</span></span> <span data-ttu-id=\"009ba-140\">Вы можете изменить методы `ToString` и `AllCaps`, используя следующий синтаксис:</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-140\">You can change the `ToString` and `AllCaps` methods to use this syntax:</span></span>\n\n[!code-csharp[StringInterpolation](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#StringInterpolation)]  \n\n<span data-ttu-id=\"009ba-141\">Вместо позиционных аргументов между `{` и `}` пишите выражения на C# напрямую.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-141\">Instead of positional arguments between the `{` and `}`, you write C# expressions directly.</span></span> <span data-ttu-id=\"009ba-142\">То же самое можно сделать и с методом `Main`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-142\">You can do the same in the `Main` method.</span></span> <span data-ttu-id=\"009ba-143\">Замените существующий код следующим кодом:</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-143\">Replace the existing code with the following:</span></span>\n\n[!code-csharp[InterpolationMain](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#InterpolationMain)]  \n\n<span data-ttu-id=\"009ba-144\">В этих выражениях можно указать более одной переменной.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-144\">You're not limited to a single variable in these expressions.</span></span> <span data-ttu-id=\"009ba-145\">Начнем с нового примера и изменим его, чтобы продемонстрировать другие выражения, которые можно использовать с интерполяцией строк.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-145\">Let's start with a new example and modify it to demonstrate other expressions you can use with string interpolation.</span></span> <span data-ttu-id=\"009ba-146\">Вставьте приведенный ниже код в интерактивном окне в метод `Main`:</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-146\">Paste the following code into the interactive window in the `Main` method:</span></span>\n\n[!code-csharp[Phrases](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#Phrases)]  \n<span data-ttu-id=\"009ba-147\">При этом используется LINQ, поэтому необходимо добавить следующую инструкцию использования в верхнюю часть интерактивного окна:</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-147\">That uses LINQ, so you'll need to add the following using statement to the top of the interactive window:</span></span>\n\n```csharp\nusing System.Linq;\n```\n\n<span data-ttu-id=\"009ba-148\">Можно удалить локальную переменную `average` и выполнить это вычисление как часть выражения интерполированной строки.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-148\">You can remove the local variable `average` and perform that calculation as part of the interpolated string expression.</span></span> <span data-ttu-id=\"009ba-149\">Замените две последние строки на следующее:</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-149\">Replace the last two lines with the following:</span></span>\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average()}\");\n```\n\n<span data-ttu-id=\"009ba-150\">Выполняя предыдущий пример, вы могли увидеть, что выходные данные для `Average` имеют больше десятичных разрядов, чем хотелось бы.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-150\">Running the preceding example, you would find that the output for `Average` has more decimal places than you would like.</span></span> <span data-ttu-id=\"009ba-151\">Синтаксис интерполяции строк поддерживает все строки формата, доступные с помощью методов форматирования прежних версий.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-151\">The string interpolation syntax supports all the format strings available using earlier formatting methods.</span></span> <span data-ttu-id=\"009ba-152\">Строки формата заключаются в фигурные скобки.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-152\">You specify the format string inside the braces.</span></span> <span data-ttu-id=\"009ba-153\">Добавьте `:`, за которым следует форматируемое выражение:</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-153\">Add a `:` following the expression to format:</span></span>\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average():F2}\");\n```\n"
- title: <span data-ttu-id="009ba-154">Быстрые и простые проверки значений NULL</span><span class="sxs-lookup"><span data-stu-id="009ba-154">Quick and easy null checks</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"009ba-155\">Оператор `?.` (условный оператор NULL) упрощает написание логики, которая опирается на значения `null`, без проблем и без дополнительной проверки `if`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-155\">The `?.` (null conditional) operator makes it easier to write logic that takes `null` values into account seamlessly, without extra `if` checks.</span></span> <span data-ttu-id=\"009ba-156\">Чтобы изучить эту возможность, сначала скопируйте следующий код в интерактивном окне, чтобы попробовать:</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-156\">To explore the feature, start by copying the following code into the interactive window to try it:</span></span>\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n      string s = null;\n      Console.WriteLine(s.Length);\n    }\n}\n```\n\n<span data-ttu-id=\"009ba-157\">Он порождает <xref:System.NullReferenceException> при выполнении примера.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-157\">It throws a <xref:System.NullReferenceException> when you run the sample.</span></span> <span data-ttu-id=\"009ba-158\">Измените оператор доступа к члену `.` на **условный оператор NULL**:</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-158\">Change the `.` member access operator to the **null conditional operator**:</span></span>\n\n```csharp\nConsole.WriteLine(s?.Length);\n``` \n\n<span data-ttu-id=\"009ba-159\">После этого изменения выходные данные отсутствуют.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-159\">After this change, there's no output.</span></span> <span data-ttu-id=\"009ba-160\">Причина в том, что результат `s?.Length` — `int?`, когда результат `s.Length` — `int`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-160\">That's because the result of `s?.Length` is an `int?` when the result of `s.Length` is an `int`.</span></span> <span data-ttu-id=\"009ba-161\">В этом примере `s?.Length` — `null`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-161\">In this example, `s?.Length` is `null`.</span></span> <span data-ttu-id=\"009ba-162\">`?.` возвращает `null`, если левый операнд является `null`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-162\">The `?.` returns `null` if its left operand is `null`.</span></span> <span data-ttu-id=\"009ba-163\">Если тип правого операнда является типом значения, оператор `?.` возвращает обнуляемый тип для этого типа.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-163\">If the type of the right operand is a value type, the `?.` operator returns a nullable type for that type.</span></span> <span data-ttu-id=\"009ba-164\">В дополнение к `?.` можно использовать `?[]` для доступа к массиву или индексатору.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-164\">In addition to `?.` you can use `?[]` for array or indexer access.</span></span> <span data-ttu-id=\"009ba-165\">Запустите этот код в интерактивном окне:</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-165\">Try the following code in the interactive window:</span></span>\n\n ```csharp\n char? c = s?[0];\n Console.WriteLine(c.HasValue);\n ```\n\n <span data-ttu-id=\"009ba-166\">Несколько условных операторов могут быть объединены в одном выражении.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-166\">Multiple conditional operators can be combined into a single expression.</span></span> <span data-ttu-id=\"009ba-167\">Левый операнд `null` возвращает результат `null`, что позволяет легко избежать вложения условных операторов для доступа к членам элементов.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-167\">A `null` left operand produces a `null` result, making it easy to avoid nested if clauses to access members of members.</span></span> <span data-ttu-id=\"009ba-168\">Например, запустите этот код в интерактивном окне:</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-168\">For example, try the following code in the interactive window:</span></span>\n\n ```csharp\n string s = null;\n bool? hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext();\n Console.WriteLine(hasMore.HasValue);\n ```\n\n <span data-ttu-id=\"009ba-169\">Предыдущий пример можно упростить с помощью **оператора объединения NUL**, чтобы предоставлять значение по умолчанию:</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-169\">The preceding example can be simplified by using the **null coalescing operator** to provide a default value:</span></span>\n\n ```csharp\n bool hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext() ?? false;\n Console.WriteLine(hasMore);\n ```\n\n <span data-ttu-id=\"009ba-170\">**Условный оператор NULL** помогает писать код, который упрощает вашу основную логику, в то же время прозрачно проверяя наличие значений `null`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-170\">The **null conditional operator** helps you write code that makes your core logic clear while seamlessly testing for `null` values.</span></span>\n"
- title: <span data-ttu-id="009ba-171">Фильтры исключений</span><span class="sxs-lookup"><span data-stu-id="009ba-171">Exception filters</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"009ba-172\">Фильтры исключений позволяют перехватывать исключения на основе некоторых условий.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-172\">Exception filters enable you to catch an exception based on some condition.</span></span> <span data-ttu-id=\"009ba-173\">Обычное использование — создание метода фильтра, который записывает исключения в журнал, но никогда не обрабатывает их.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-173\">A typical use is to create a filter method that logs exceptions, but never handles those exceptions.</span></span> <span data-ttu-id=\"009ba-174\">Фильтр исключений — это логическое выражение, которое равно `true`, когда предложение `catch` должно быть выполнено, и `false`, когда исключение не должно перехватываться предложением `catch`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-174\">An exception filter is a boolean expression that is `true` when the `catch` clause should be executed, and `false` when the exception should not be caught by the `catch` clause.</span></span> <span data-ttu-id=\"009ba-175\">Запустите этот код в интерактивном окне: Он выводит тип исключения и сообщение на консоль.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-175\">Try the following code in the interactive window: It logs the exception type and message to the console.</span></span> <span data-ttu-id=\"009ba-176\">Он возвращает значение `false`, что означает, что исключение не может быть обработано.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-176\">It returns `false` which indicates that the exception can't be handled.</span></span> <span data-ttu-id=\"009ba-177\">Выполните программу в интерактивном окне.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-177\">Try the program in the interactive window.</span></span>\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        try \n        {\n            string s = null;\n            Console.WriteLine(s.Length);\n\n        } catch (Exception e) when (LogException(e))\n        {\n        }\n        Console.WriteLine(\"Exception must have been handled\");\n    }\n\n    private static bool LogException(Exception e)\n    {\n        Console.WriteLine($\"\\tIn the log routine. Caught {e.GetType()}\");\n        Console.WriteLine($\"\\tMessage: {e.Message}\");\n        return false;\n    }\n}\n```\n\n<span data-ttu-id=\"009ba-178\">Вы должны увидеть сообщение из метода `LogException`, за которым следует сообщение об исключении по умолчанию.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-178\">You should see the message from the `LogException` method, followed by the default exception message.</span></span> <span data-ttu-id=\"009ba-179\">Поставим эксперимент и изменим оператор `return false` на `return true`, а затем выполним это снова.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-179\">Just to experiment, change the `return false` statement to `return true` and run this again.</span></span> <span data-ttu-id=\"009ba-180\">Теперь исключение перехватывается и программа выполняется до завершения.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-180\">Now, the exception is caught and the program runs to completion.</span></span>\n\n<span data-ttu-id=\"009ba-181\">За пределами сценариев ведения журнала фильтры исключений могут быть наиболее полезны, когда свойство исключения определяет, какое действие следует предпринять.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-181\">Beyond logging scenarios, exception filters can be most useful when a property of the exception determines what action to take.</span></span> <span data-ttu-id=\"009ba-182\">Например, можно заглянуть внутрь <xref:System.AggregateException>, чтобы узнать, какие в него вложены исключения, и принять соответствующие меры в зависимости от конкретного исключения.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-182\">For example, you can look inside an <xref:System.AggregateException> to see what the contained exceptions are and take some appropriate action depending on the specific exception.</span></span>\n"
- title: <span data-ttu-id="009ba-183">Использование nameof</span><span class="sxs-lookup"><span data-stu-id="009ba-183">Using nameof</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"009ba-184\">Оператор `nameof` возвращает имя любой переменной, типа или члена типа.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-184\">The `nameof` operator returns the name of any variable, a type, or a type's member.</span></span> <span data-ttu-id=\"009ba-185\">Запустите следующий код в интерактивном окне и посмотрите на результат:</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-185\">Try the following code in the interactive window to see how it works:</span></span>\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Console.WriteLine(nameof(System.String));\n        int j = 5;\n        Console.WriteLine(nameof(j));\n        List<string> names = new List<string>();\n        Console.WriteLine(nameof(names));\n    }\n}\n```\n\n<span data-ttu-id=\"009ba-186\">Вывод содержит имя переменной или типа.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-186\">The output matches the name of the variable or type.</span></span> <span data-ttu-id=\"009ba-187\">Даже если указано полное имя типа (например, `System.String`), оператор `nameof` возвращает неполное имя.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-187\">Even when you provided the fully qualified type name (such as `System.String`) the `nameof` operator returns the unqualified name.</span></span> <span data-ttu-id=\"009ba-188\">Эта функция особенно полезна, когда необходимо преобразовать в строку имя параметра или свойства.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-188\">This feature is most useful when you need to convert a parameter or property name to a string.</span></span> <span data-ttu-id=\"009ba-189\">Примеры включают запись имени аргумента для генерации <xref:System.ArgumentNullException> или <xref:System.ArgumentException> либо запись имени измененного свойства при реализации <xref:System.ComponentModel.INotifyPropertyChanged>.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-189\">Examples include capturing the name of an argument for throwing a <xref:System.ArgumentNullException> or <xref:System.ArgumentException>, or capturing the name of a changed property when implementing <xref:System.ComponentModel.INotifyPropertyChanged>.</span></span> \n"
- title: <span data-ttu-id="009ba-190">Новый синтаксис инициализации объектов</span><span class="sxs-lookup"><span data-stu-id="009ba-190">New object initialization syntax</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"009ba-191\">Синтаксис инициализатора объекта теперь поддерживает инициализацию *индексаторов*, а также свойства и поля.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-191\">Object initializer syntax now supports initializing *indexers* as well as properties and fields.</span></span> <span data-ttu-id=\"009ba-192\">Это дополнение упрощает инициализацию словарей и других типов.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-192\">This addition makes it easier to initialize dictionaries and other types.</span></span> <span data-ttu-id=\"009ba-193\">Начнем со словаря.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-193\">Start with a dictionary.</span></span> <span data-ttu-id=\"009ba-194\">Запустите приведенный ниже код в интерактивном окне.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-194\">Run the following code in the interactive window:</span></span>\n\n```csharp\nvar messages = new Dictionary<int, string>\n{\n    [404] = \"Page not Found\",\n    [302] = \"Page moved, but left a forwarding address.\",\n    [500] = \"The web server can't come out to play today.\"\n};\n\nConsole.WriteLine(messages[302]);\n```\n\n<span data-ttu-id=\"009ba-195\">Этот синтаксис, который устанавливает значение в индексаторе, можно использоваться для любого типа, у которого есть доступный метод доступа set в индексаторе.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-195\">This syntax, which sets a value in an indexer, can be used for any type that has an accessible set accessor on an indexer.</span></span>\n\n<span data-ttu-id=\"009ba-196\">Второе изменение упрощает включение синтаксиса инициализатора для типов, представляющих последовательности.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-196\">A second change makes it easier to enable initializer syntax for types that represent sequences.</span></span> <span data-ttu-id=\"009ba-197\">Инициализаторы коллекций можно использовать в любом классе, который реализует <xref:System.Collections.IEnumerable> и имеет общедоступный метод `Add`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-197\">Collection initializers can be used on any class that implements <xref:System.Collections.IEnumerable> and has a publicly accessible `Add` method.</span></span> <span data-ttu-id=\"009ba-198\">Этот метод `Add` теперь может быть методом расширения.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-198\">That `Add` method can now be an extension method.</span></span> \n\n<span data-ttu-id=\"009ba-199\">В следующем примере показан один из сценариев для данного синтаксиса.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-199\">The following example shows one scenario for this syntax.</span></span> <span data-ttu-id=\"009ba-200\">Он создает класс `Path`, который реализует `IEnumerable<Point3D>` и имеет метод для добавления точек, принимающих три аргумента.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-200\">It creates a `Path` class that implements `IEnumerable<Point3D>` and has a method to add points that take three arguments.</span></span> <span data-ttu-id=\"009ba-201\">Класс `Extensions` создает дополнительный метод `Add`, чтобы добавить новую точку из трех компонентов.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-201\">The `Extensions` class creates an additional `Add` method to add a new point from its three components.</span></span> <span data-ttu-id=\"009ba-202\">В данный момент этот пример не выполняется в интерактивном режиме из-за ограничений в среде.</span><span class=\"sxs-lookup\"><span data-stu-id=\"009ba-202\">This sample does not currently run interactively due to restrictions in the environment.</span></span>\n\n```csharp\npublic class Path : IEnumerable<Point3D>\n{\n    private List<Point3D> points = new List<Point3D>();\n    public IEnumerator<Point3D> GetEnumerator() => points.GetEnumerator();\n    IEnumerator IEnumerable.GetEnumerator() => points.GetEnumerator();\n\n    public void Add(Point3D pt) => points.Add(pt);\n}\n\npublic static class Extensions\n{\n    public static void Add(this Path path, double x, double y, double z) => path.Add(new Point3D(x, y, z));\n}\n```\n"
- content: <span data-ttu-id="009ba-203">Мы завершили подробное описание новых функций в C# 6.</span><span class="sxs-lookup"><span data-stu-id="009ba-203">You've completed an exploration of the new features in C# 6.</span></span> <span data-ttu-id="009ba-204">Теперь попробуйте их самостоятельно в ваших приложениях.</span><span class="sxs-lookup"><span data-stu-id="009ba-204">Now try them yourself in your applications.</span></span>
