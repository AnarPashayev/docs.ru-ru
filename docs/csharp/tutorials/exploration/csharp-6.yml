### YamlMime:Tutorial
title: Изучите C# 6 — интерактивный учебник по C#
metadata:
  title: Изучите C# 6 — испытайте новые возможности C# 6 в интерактивном режиме с помощью браузера
  description: В этом руководстве для интерактивного изучения C# 6 используется браузер. Изучите новые идиомы, которые можно использовать с C# 6; они делают код более кратким и удобочитаемым.
  audience: Developer
  level: intermediate
  ms.date: 12/11/2018
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: 594ae1530ac9ef41d6f3200b3e218db026552b95
  ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
  ms.translationtype: HT
  ms.contentlocale: ru-RU
  ms.lasthandoff: 03/14/2020
  ms.locfileid: "78240406"
items:
- durationInMinutes: 1
  content: >
    Это руководство поможет в интерактивном изучении C# 6. С помощью браузера вы напишете код на C# и сможете просмотреть результаты его компиляции и выполнения. Оно содержит ряд уроков, которые заменят более ранние рекомендации по C# на более новые и краткие возможности C# 6. В оставшейся части этой статьи приведены общие сведения о каждой из этих функций со ссылкой для изучения каждого компонента.
- title: Автосвойства только для чтения позволяют реализовать типы "только для чтения"
  durationInMinutes: 2
  content: "Два расширения синтаксиса автосвойств позволяют упростить их использование в новых местах: это автосвойства только для чтения и инициализаторы автосвойств. Рассмотрим следующую небольшую программу:\n\n[!code-csharp[Starter](../../../../samples/snippets/csharp/tutorials/exploration/csharp6-starter/Program.cs)]  \n\n    \n Запустите режим фокусировки и скопируйте приведенный выше код в интерактивное окно C#. Затем нажмите кнопку *Запуск*, чтобы увидеть, что делает код. `AllCaps` имеет нежелательный побочный эффект изменения значений свойств, а также возвращает строку в верхнем регистре. Автор класса `Person` хотел сделать строки `FirstName` и `LastName` доступными только для чтения. С помощью C# 6 можно сделать это намерение явным. Удалите `private set` из обоих свойств, чтобы создать автосвойство только для чтения. Нажмите кнопку *Запуск*, чтобы увидеть, что компилятор отметит два места, где свойства `FirstName` и `LastName` изменяются в том случае, когда это не требовалось. Вы можете заменить метод `AllCaps` на следующий код, чтобы устранить эту ошибку компилятора:\n\n```csharp\npublic string AllCaps()\n{\n  return ToString().ToUpper();\n}\n```\n\nПри использовании этого нового синтаксиса компилятор гарантирует, что свойства являются неизменяемыми.\n"
- title: Инициализация резервных полей для автосвойств
  durationInMinutes: 1
  content: "Новый синтаксис в C# 6 позволяет использовать инициализаторы для автосвойств. Это становится все более важно по мере появления новых возможностей классов. Добавим свойство для отчества и новый конструктор, принимающий три строки для вашего класса `Person`:\n\n[!code-csharp[MiddleName](../../../../samples/snippets/csharp/tutorials/exploration/csharp6-finished/Program.cs#MiddleName)]  \n\nПрисваивание свойству `MiddleName` — это инициализатор. Он инициализирует созданное компилятором резервное поле для отчества.\n"
- title: Элементы, воплощающие выражение
  durationInMinutes: 2
  content: >
    Элементы, воплощающие выражение, предоставляют упрощенный синтаксис для упрощенных методов. В классе `Person` есть два оптимальных кандидата. Посмотрите на объявление `ToString`:


    ```csharp

    public override string ToString()

    {
        return FirstName + " " + LastName;
    }

    ```


    Замените объявление `ToString` следующим кодом:


    ```csharp

    public override string ToString() => FirstName + " " + LastName;

    ```


    Повторите то же самое с методом `AllCaps`. Это незначительное улучшение, но при рациональном использовании оно создает гораздо более удобочитаемый код, особенно для объектов передачи данных (DTO) и других типов с минимальными поведением.
- title: Импорт одиночного класса
  durationInMinutes: 2
  content: "Если постоянно использовать статические методы одного класса во всем коде, включение имени класса каждый раз искажает смысл кода. Класс `Person` в настоящее время импортирует пространство имен `System` несмотря на то, что используется только <xref:System.Console?displayProperty=nameWithType>. Измените оператор `using` следующим образом:\n\n[!code-csharp[MiddleName](../../../../samples/snippets/csharp/tutorials/exploration/csharp6-finished/Program.cs#UsingStatic)]  \n\nОператор `static using` лучше подходит для более крупных программ, активно использующих один класс со множеством статических методов, таких как класс [`string`](xref:System.String) или <xref:System.Math?displayProperty=nameWithType>.\n"
- title: Улучшенный формат строк
  durationInMinutes: 2
  content: "C# версии 6 содержит новый синтаксис для составления строк из строки и встроенных выражений, вычисление которых позволяет получить другие строковые значения. Вы можете изменить методы `ToString` и `AllCaps`, используя следующий синтаксис:\n\n[!code-csharp[StringInterpolation](../../../../samples/snippets/csharp/tutorials/exploration/csharp6-finished/Program.cs#StringInterpolation)]  \n\nВместо позиционных аргументов между `{` и `}` пишите выражения на C# напрямую. То же самое можно сделать и с методом `Main`. Замените существующий код следующим кодом:\n\n[!code-csharp[InterpolationMain](../../../../samples/snippets/csharp/tutorials/exploration/csharp6-finished/Program.cs#InterpolationMain)]  \n\nВ этих выражениях можно указать более одной переменной. Начнем с нового примера и изменим его, чтобы продемонстрировать другие выражения, которые можно использовать с интерполяцией строк. Вставьте приведенный ниже код в интерактивном окне в метод `Main`:\n\n[!code-csharp[Phrases](../../../../samples/snippets/csharp/tutorials/exploration/csharp6-finished/Program.cs#Phrases)]  \nПри этом используется LINQ, поэтому необходимо добавить следующую инструкцию использования в верхнюю часть интерактивного окна:\n\n```csharp\nusing System.Linq;\n```\n\nМожно удалить локальную переменную `average` и выполнить это вычисление как часть выражения интерполированной строки. Замените две последние строки на следующее:\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average()}\");\n```\n\nВыполняя предыдущий пример, вы могли увидеть, что выходные данные для `Average` имеют больше десятичных разрядов, чем хотелось бы. Синтаксис интерполяции строк поддерживает все строки формата, доступные с помощью методов форматирования прежних версий. Строки формата заключаются в фигурные скобки. Добавьте `:`, за которым следует форматируемое выражение:\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average():F2}\");\n```\n"
- title: Быстрые и простые проверки значений NULL
  durationInMinutes: 2
  content: "Оператор `?.` (условный оператор NULL) упрощает написание логики, которая опирается на значения `null`, без проблем и без дополнительной проверки `if`. Чтобы изучить эту возможность, сначала скопируйте следующий код в интерактивном окне, чтобы попробовать:\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n      string s = null;\n      Console.WriteLine(s.Length);\n    }\n}\n```\n\nОн порождает <xref:System.NullReferenceException> при выполнении примера. Измените оператор доступа к члену `.` на **условный оператор NULL**:\n\n```csharp\nConsole.WriteLine(s?.Length);\n``` \n\nПосле этого изменения выходные данные отсутствуют. Причина в том, что результат `s?.Length` — `int?`, когда результат `s.Length` — `int`. В этом примере `s?.Length` — `null`. `?.` возвращает `null`, если левый операнд является `null`. Если тип правого операнда является типом значения, оператор `?.` возвращает обнуляемый тип для этого типа. В дополнение к `?.` можно использовать `?[]` для доступа к массиву или индексатору. Запустите этот код в интерактивном окне:\n\n ```csharp\n char? c = s?[0];\n Console.WriteLine(c.HasValue);\n ```\n\n Несколько условных операторов могут быть объединены в одном выражении. Левый операнд `null` возвращает результат `null`, что позволяет легко избежать вложения условных операторов для доступа к членам элементов. Например, запустите этот код в интерактивном окне:\n\n ```csharp\n string s = null;\n bool? hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext();\n Console.WriteLine(hasMore.HasValue);\n ```\n\n Предыдущий пример можно упростить с помощью **оператора объединения NUL**, чтобы предоставлять значение по умолчанию:\n\n ```csharp\n bool hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext() ?? false;\n Console.WriteLine(hasMore);\n ```\n\n **Условный оператор NULL** помогает писать код, который упрощает вашу основную логику, в то же время прозрачно проверяя наличие значений `null`.\n"
- title: Фильтры исключений
  durationInMinutes: 2
  content: "Фильтры исключений позволяют перехватывать исключения на основе некоторых условий. Обычное использование — создание метода фильтра, который записывает исключения в журнал, но никогда не обрабатывает их. Фильтр исключений — это логическое выражение, которое равно `true`, когда предложение `catch` должно быть выполнено, и `false`, когда исключение не должно перехватываться предложением `catch`. Запустите этот код в интерактивном окне: Он выводит тип исключения и сообщение на консоль. Он возвращает значение `false`, что означает, что исключение не может быть обработано. Выполните программу в интерактивном окне.\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        try \n        {\n            string s = null;\n            Console.WriteLine(s.Length);\n\n        } catch (Exception e) when (LogException(e))\n        {\n        }\n        Console.WriteLine(\"Exception must have been handled\");\n    }\n\n    private static bool LogException(Exception e)\n    {\n        Console.WriteLine($\"\\tIn the log routine. Caught {e.GetType()}\");\n        Console.WriteLine($\"\\tMessage: {e.Message}\");\n        return false;\n    }\n}\n```\n\nВы должны увидеть сообщение из метода `LogException`, за которым следует сообщение об исключении по умолчанию. Поставим эксперимент и изменим оператор `return false` на `return true`, а затем выполним это снова. Теперь исключение перехватывается и программа выполняется до завершения.\n\nЗа пределами сценариев ведения журнала фильтры исключений могут быть наиболее полезны, когда свойство исключения определяет, какое действие следует предпринять. Например, можно заглянуть внутрь <xref:System.AggregateException>, чтобы узнать, какие в него вложены исключения, и принять соответствующие меры в зависимости от конкретного исключения.\n"
- title: Использование nameof
  durationInMinutes: 2
  content: "Оператор `nameof` возвращает имя любой переменной, типа или члена типа. Запустите следующий код в интерактивном окне и посмотрите на результат:\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Console.WriteLine(nameof(System.String));\n        int j = 5;\n        Console.WriteLine(nameof(j));\n        List<string> names = new List<string>();\n        Console.WriteLine(nameof(names));\n    }\n}\n```\n\nВывод содержит имя переменной или типа. Даже если указано полное имя типа (например, `System.String`), оператор `nameof` возвращает неполное имя. Эта функция особенно полезна, когда необходимо преобразовать в строку имя параметра или свойства. Примеры включают запись имени аргумента для генерации <xref:System.ArgumentNullException> или <xref:System.ArgumentException> либо запись имени измененного свойства при реализации <xref:System.ComponentModel.INotifyPropertyChanged>. \n"
- title: Новый синтаксис инициализации объектов
  durationInMinutes: 2
  content: "Синтаксис инициализатора объекта теперь поддерживает инициализацию *индексаторов*, а также свойства и поля. Это дополнение упрощает инициализацию словарей и других типов. Начнем со словаря. Запустите приведенный ниже код в интерактивном окне.\n\n```csharp\nvar messages = new Dictionary<int, string>\n{\n    [404] = \"Page not Found\",\n    [302] = \"Page moved, but left a forwarding address.\",\n    [500] = \"The web server can't come out to play today.\"\n};\n\nConsole.WriteLine(messages[302]);\n```\n\nЭтот синтаксис, который устанавливает значение в индексаторе, можно использоваться для любого типа, у которого есть доступный метод доступа set в индексаторе.\n\nВторое изменение упрощает включение синтаксиса инициализатора для типов, представляющих последовательности. Инициализаторы коллекций можно использовать в любом классе, который реализует <xref:System.Collections.IEnumerable> и имеет общедоступный метод `Add`. Этот метод `Add` теперь может быть методом расширения. \n\nВ следующем примере показан один из сценариев для данного синтаксиса. Он создает класс `Path`, который реализует `IEnumerable<Point3D>` и имеет метод для добавления точек, принимающих три аргумента. Класс `Extensions` создает дополнительный метод `Add`, чтобы добавить новую точку из трех компонентов. В данный момент этот пример не выполняется в интерактивном режиме из-за ограничений в среде.\n\n```csharp\npublic class Path : IEnumerable<Point3D>\n{\n    private List<Point3D> points = new List<Point3D>();\n    public IEnumerator<Point3D> GetEnumerator() => points.GetEnumerator();\n    IEnumerator IEnumerable.GetEnumerator() => points.GetEnumerator();\n\n    public void Add(Point3D pt) => points.Add(pt);\n}\n\npublic static class Extensions\n{\n    public static void Add(this Path path, double x, double y, double z) => path.Add(new Point3D(x, y, z));\n}\n```\n"
- content: Мы завершили подробное описание новых функций в C# 6. Теперь попробуйте их самостоятельно в ваших приложениях.
