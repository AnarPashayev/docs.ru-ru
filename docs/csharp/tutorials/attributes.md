---
title: Атрибуты. Язык C#
description: Узнайте, как работают атрибуты в C#.
author: mgroves
ms.date: 03/06/2017
ms.assetid: b152cf36-76e4-43a5-b805-1a1952e53b79
ms.openlocfilehash: 3141c1bf7ddcf3fd3426290428f9eeeb54b3c872
ms.sourcegitcommit: 0be8a279af6d8a43e03141e349d3efd5d35f8767
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/18/2019
ms.locfileid: "59481235"
---
# <a name="using-attributes-in-c"></a><span data-ttu-id="6a4d2-103">Использование атрибутов в C\#</span><span class="sxs-lookup"><span data-stu-id="6a4d2-103">Using Attributes in C\#</span></span>

<span data-ttu-id="6a4d2-104">Атрибуты предоставляют возможность декларативно связать информацию с кодом.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-104">Attributes provide a way of associating information with code in a declarative way.</span></span> <span data-ttu-id="6a4d2-105">Также этот элемент можно многократно использовать повторно для разнообразных целевых объектов.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-105">They can also provide a reusable element that can be applied to a variety of targets.</span></span>

<span data-ttu-id="6a4d2-106">Рассмотрим для примера атрибут `[Obsolete]`.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-106">Consider the `[Obsolete]` attribute.</span></span> <span data-ttu-id="6a4d2-107">Его можно применять к классам, структурам, методам, конструкторам и т. д.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-107">It can be applied to classes, structs, methods, constructors, and more.</span></span> <span data-ttu-id="6a4d2-108">Он _объявляет_, что соответствующий элемент является устаревшим.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-108">It _declares_ that the element is obsolete.</span></span> <span data-ttu-id="6a4d2-109">Компилятор C# проверят наличие этого атрибута и выполняет некоторые действия, если он присутствует.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-109">It's then up to the C# compiler to look for this attribute, and do some action in response.</span></span>

<span data-ttu-id="6a4d2-110">В этом руководстве мы покажем вам, как можно добавить атрибуты в код, как создавать и применять собственные атрибуты, а также использовать некоторые встроенные атрибуты .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-110">In this tutorial, you'll be introduced to how to add attributes to your code, how to create and use your own attributes, and how to use some attributes that are built into .NET Core.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="6a4d2-111">Предварительные требования</span><span class="sxs-lookup"><span data-stu-id="6a4d2-111">Prerequisites</span></span>
<span data-ttu-id="6a4d2-112">Компьютер должен быть настроен для выполнения .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-112">You’ll need to setup your machine to run .NET core.</span></span> <span data-ttu-id="6a4d2-113">Инструкции по установке см. на странице [.NET Core](https://www.microsoft.com/net/core).</span><span class="sxs-lookup"><span data-stu-id="6a4d2-113">You can find the installation instructions on the [.NET Core](https://www.microsoft.com/net/core) page.</span></span>
<span data-ttu-id="6a4d2-114">Это приложение можно запустить в ОС Windows, Ubuntu Linux, macOS или в контейнере Docker.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-114">You can run this application on Windows, Ubuntu Linux, macOS or in a Docker container.</span></span> <span data-ttu-id="6a4d2-115">Вам потребуется редактор кода, но вы можете выбрать любой привычный для вас.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-115">You’ll need to install your favorite code editor.</span></span> <span data-ttu-id="6a4d2-116">В примерах ниже используется кроссплатформенный редактор [Visual Studio Code](https://code.visualstudio.com/) с открытым исходным кодом.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-116">The descriptions below use [Visual Studio Code](https://code.visualstudio.com/) which is an open source, cross platform editor.</span></span> <span data-ttu-id="6a4d2-117">Вы можете заменить его на любое другое средство, с которым вам удобно работать.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-117">However, you can use whatever tools you are comfortable with.</span></span>

## <a name="create-the-application"></a><span data-ttu-id="6a4d2-118">Создание приложения</span><span class="sxs-lookup"><span data-stu-id="6a4d2-118">Create the Application</span></span>

<span data-ttu-id="6a4d2-119">Теперь, когда вы установили все нужные средства, создайте новое приложение .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-119">Now that you've installed all the tools, create a new .NET Core application.</span></span> <span data-ttu-id="6a4d2-120">Чтобы использовать генератор из командной строки, выполните следующую команду в любой оболочке:</span><span class="sxs-lookup"><span data-stu-id="6a4d2-120">To use the command line generator, execute the following command in your favorite shell:</span></span>

`dotnet new console`

<span data-ttu-id="6a4d2-121">Эта команда создает скелет файлов проекта для .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-121">This command will create barebones .NET core project files.</span></span> <span data-ttu-id="6a4d2-122">Нужно также выполнить команду `dotnet restore`, чтобы восстановить зависимости, необходимые для компиляции проекта.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-122">You will need to execute `dotnet restore` to restore the dependencies needed to compile this project.</span></span>

[!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]

<span data-ttu-id="6a4d2-123">Чтобы выполнить программу, используйте `dotnet run`.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-123">To execute the program, use `dotnet run`.</span></span> <span data-ttu-id="6a4d2-124">Она выведет в консоль сообщение "Hello, World".</span><span class="sxs-lookup"><span data-stu-id="6a4d2-124">You should see "Hello, World" output to the console.</span></span>

## <a name="how-to-add-attributes-to-code"></a><span data-ttu-id="6a4d2-125">Добавление атрибутов к коду</span><span class="sxs-lookup"><span data-stu-id="6a4d2-125">How to add attributes to code</span></span>

<span data-ttu-id="6a4d2-126">В C# атрибуты представляют собой классы, наследующие от базового класса `Attribute`.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-126">In C#, attributes are classes that inherit from the `Attribute` base class.</span></span> <span data-ttu-id="6a4d2-127">Любой класс, который наследует от `Attribute`, можно использовать как своего рода "тег" на другие части кода.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-127">Any class that inherits from `Attribute` can be used as a sort of "tag" on other pieces of code.</span></span>
<span data-ttu-id="6a4d2-128">Например, существует атрибут с именем `ObsoleteAttribute`.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-128">For instance, there is an attribute called `ObsoleteAttribute`.</span></span> <span data-ttu-id="6a4d2-129">С его помощью можно обозначить, что код устарел и больше не должен использоваться.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-129">This is used to signal that code is obsolete and shouldn't be used anymore.</span></span> <span data-ttu-id="6a4d2-130">Этот атрибут можно поместить в класс, используя квадратные скобки.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-130">You can place this attribute on a class, for instance, by using square brackets.</span></span>

[!code-csharp[Obsolete attribute example](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#ObsoleteExample1)]  

<span data-ttu-id="6a4d2-131">Обратите внимание, что полное название класса — `ObsoleteAttribute`, но в коде достаточно указать только `[Obsolete]`.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-131">Note that while the class is called `ObsoleteAttribute`, it's only necessary to use `[Obsolete]` in the code.</span></span> <span data-ttu-id="6a4d2-132">Это стандартное соглашение в C#.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-132">This is a convention that C# follows.</span></span>
<span data-ttu-id="6a4d2-133">При желании вы можете использовать полное имя `[ObsoleteAttribute]`.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-133">You can use the full name `[ObsoleteAttribute]` if you choose.</span></span>

<span data-ttu-id="6a4d2-134">Когда вы отмечаете класс как устаревший, желательно предоставить некоторые сведения о том, *почему* он устарел и (или) *что* можно использовать вместо него.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-134">When marking a class obsolete, it's a good idea to provide some information as to *why* it's obsolete, and/or *what* to use instead.</span></span> <span data-ttu-id="6a4d2-135">Для этого передайте в атрибут Obsolete строковый параметр.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-135">Do this by passing a string parameter to the Obsolete attribute.</span></span>

[!code-csharp[Obsolete attribute example with parameters](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#ObsoleteExample2)]

<span data-ttu-id="6a4d2-136">Эта строка передается в качестве аргумента в конструктор `ObsoleteAttribute`, как если бы вы использовали синтаксис `var attr = new ObsoleteAttribute("some string")`.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-136">The string is being passed as an argument to an `ObsoleteAttribute` constructor, just as if you were writing `var attr = new ObsoleteAttribute("some string")`.</span></span>

<span data-ttu-id="6a4d2-137">В конструкторе атрибута можно использовать в качестве параметров только простые типы и литералы `bool, int, double, string, Type, enums, etc` и массивы этих типов.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-137">Parameters to an attribute constructor are limited to simple types/literals: `bool, int, double, string, Type, enums, etc` and arrays of those types.</span></span>
<span data-ttu-id="6a4d2-138">Нельзя использовать переменные или выражения.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-138">You can not use an expression or a variable.</span></span> <span data-ttu-id="6a4d2-139">Но вы можете свободно использовать позиционные или именованные параметры.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-139">You are free to use positional or named parameters.</span></span>

## <a name="how-to-create-your-own-attribute"></a><span data-ttu-id="6a4d2-140">Как создать собственный атрибут</span><span class="sxs-lookup"><span data-stu-id="6a4d2-140">How to create your own attribute</span></span>

<span data-ttu-id="6a4d2-141">Чтобы создать собственный атрибут, достаточно унаследовать его от базового класса `Attribute`.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-141">Creating an attribute is as simple as inheriting from the `Attribute` base class.</span></span>

[!code-csharp[Create your own attribute](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#CreateAttributeExample1)]

<span data-ttu-id="6a4d2-142">Добавив такой код, вы сможете использовать `[MySpecial]` (или `[MySpecialAttribute]`) в качестве атрибута в любом месте кода.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-142">With the above, I can now use `[MySpecial]` (or `[MySpecialAttribute]`) as an attribute elsewhere in the code base.</span></span>

[!code-csharp[Using your own attribute](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#CreateAttributeExample2)]

<span data-ttu-id="6a4d2-143">Атрибуты в библиотеке базовых классов .NET, например `ObsoleteAttribute`, активируют определенный действия компилятора.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-143">Attributes in the .NET base class library like `ObsoleteAttribute` trigger certain behaviors within the compiler.</span></span> <span data-ttu-id="6a4d2-144">Но созданные вами атрибуты сами по себе лишь выполняют роль метаданных и не влекут за собой исполнение какого-либо кода в классе атрибута.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-144">However, any attribute you create acts only as metadata, and doesn't result in any code within the attribute class being executed.</span></span> <span data-ttu-id="6a4d2-145">Вы должны проверять эти метаданные и выполнять необходимые действия в другой части кода (подробнее об этом написано дальше в этом руководстве).</span><span class="sxs-lookup"><span data-stu-id="6a4d2-145">It's up to you to act on that metadata elsewhere in your code (more on that later in the tutorial).</span></span>

<span data-ttu-id="6a4d2-146">Здесь есть один подвох, которого следует остерегаться.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-146">There is a 'gotcha' here to watch out for.</span></span> <span data-ttu-id="6a4d2-147">Как упоминалось выше, в качестве аргументов при использовании атрибутов можно передавать только некоторые определенные типы.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-147">As mentioned above, only certain types are allowed to be passed as arguments when using attributes.</span></span> <span data-ttu-id="6a4d2-148">Но компилятор C# не помешает вам указать другие параметры при создании типа атрибута.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-148">However, when creating an attribute type, the C# compiler won't stop you from creating those parameters.</span></span> <span data-ttu-id="6a4d2-149">В следующем примере кода я создаю атрибут с конструктором, который отлично компилируется.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-149">In the below example, I've created an attribute with a constructor that compiles just fine.</span></span>

[!code-csharp[Valid constructor used in an attribute](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#AttributeGothca1)]

<span data-ttu-id="6a4d2-150">Но объект с таким конструктором вы не сможете использовать в роли атрибута.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-150">However, you will be unable to use this constructor with attribute syntax.</span></span>

[!code-csharp[Invalid attempt to use the attribute constructor](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#AttributeGotcha2)]

<span data-ttu-id="6a4d2-151">Такой код вызовет ошибку компиляции, например такую: `Attribute constructor parameter 'myClass' has type 'Foo', which is not a valid attribute parameter type`</span><span class="sxs-lookup"><span data-stu-id="6a4d2-151">The above will cause a compiler error like `Attribute constructor parameter 'myClass' has type 'Foo', which is not a valid attribute parameter type`</span></span>

## <a name="how-to-restrict-attribute-usage"></a><span data-ttu-id="6a4d2-152">Как ограничить использование атрибута</span><span class="sxs-lookup"><span data-stu-id="6a4d2-152">How to restrict attribute usage</span></span>

<span data-ttu-id="6a4d2-153">Атрибуты можно использовать для разных целевых объектов.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-153">Attributes can be used on a number of "targets".</span></span> <span data-ttu-id="6a4d2-154">В примере выше мы применили их для классов, но целевым объектом может быть любой из этого списка:</span><span class="sxs-lookup"><span data-stu-id="6a4d2-154">The above examples show them on classes, but they can also be used on:</span></span>

* <span data-ttu-id="6a4d2-155">Assembly</span><span class="sxs-lookup"><span data-stu-id="6a4d2-155">Assembly</span></span>
* <span data-ttu-id="6a4d2-156">Класс</span><span class="sxs-lookup"><span data-stu-id="6a4d2-156">Class</span></span>
* <span data-ttu-id="6a4d2-157">Конструктор</span><span class="sxs-lookup"><span data-stu-id="6a4d2-157">Constructor</span></span>
* <span data-ttu-id="6a4d2-158">делегат</span><span class="sxs-lookup"><span data-stu-id="6a4d2-158">Delegate</span></span>
* <span data-ttu-id="6a4d2-159">Enum</span><span class="sxs-lookup"><span data-stu-id="6a4d2-159">Enum</span></span>
* <span data-ttu-id="6a4d2-160">событие</span><span class="sxs-lookup"><span data-stu-id="6a4d2-160">Event</span></span>
* <span data-ttu-id="6a4d2-161">Поле</span><span class="sxs-lookup"><span data-stu-id="6a4d2-161">Field</span></span>
* <span data-ttu-id="6a4d2-162">универсальный параметр;</span><span class="sxs-lookup"><span data-stu-id="6a4d2-162">GenericParameter</span></span>
* <span data-ttu-id="6a4d2-163">Интерфейс</span><span class="sxs-lookup"><span data-stu-id="6a4d2-163">Interface</span></span>
* <span data-ttu-id="6a4d2-164">Метод</span><span class="sxs-lookup"><span data-stu-id="6a4d2-164">Method</span></span>
* <span data-ttu-id="6a4d2-165">Module</span><span class="sxs-lookup"><span data-stu-id="6a4d2-165">Module</span></span>
* <span data-ttu-id="6a4d2-166">Параметр</span><span class="sxs-lookup"><span data-stu-id="6a4d2-166">Parameter</span></span>
* <span data-ttu-id="6a4d2-167">Свойство.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-167">Property</span></span>
* <span data-ttu-id="6a4d2-168">Возвращаемое значение</span><span class="sxs-lookup"><span data-stu-id="6a4d2-168">ReturnValue</span></span>
* <span data-ttu-id="6a4d2-169">Структура</span><span class="sxs-lookup"><span data-stu-id="6a4d2-169">Struct</span></span>

<span data-ttu-id="6a4d2-170">Когда вы создаете класс атрибута, C# по умолчанию позволяет использовать этот атрибут для любого из допустимых целевых объектов.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-170">When you create an attribute class, by default, C# will allow you to use that attribute on any of the possible attribute targets.</span></span> <span data-ttu-id="6a4d2-171">Если вы хотите, чтобы атрибут можно было использовать только для некоторых из целевых объектов, используйте `AttributeUsageAttribute` в классе атрибута.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-171">If you want to restrict your attribute to certain targets, you can do so by using the `AttributeUsageAttribute` on your attribute class.</span></span> <span data-ttu-id="6a4d2-172">Да-да, именно так, атрибут для атрибута!</span><span class="sxs-lookup"><span data-stu-id="6a4d2-172">That's right, an attribute on an attribute!</span></span>

[!code-csharp[Using your own attribute](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#AttributeUsageExample1)]

<span data-ttu-id="6a4d2-173">Если вы попробуете применить описанный выше атрибут для сущности, которая не является классом или структурой, вы получите ошибку компиляции такого рода: `Attribute 'MyAttributeForClassAndStructOnly' is not valid on this declaration type. It is only valid on 'class, struct' declarations`</span><span class="sxs-lookup"><span data-stu-id="6a4d2-173">If you attempt to put the above attribute on something that's not a class or a struct, you will get a compiler error like `Attribute 'MyAttributeForClassAndStructOnly' is not valid on this declaration type. It is only valid on 'class, struct' declarations`</span></span>

[!code-csharp[Using your own attribute](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#AttributeUsageExample2)]

## <a name="how-to-use-attributes-attached-to-a-code-element"></a><span data-ttu-id="6a4d2-174">Как использовать атрибуты, прикрепленные к элементу кода</span><span class="sxs-lookup"><span data-stu-id="6a4d2-174">How to use attributes attached to a code element</span></span>

<span data-ttu-id="6a4d2-175">Атрибуты выполняют роль метаданных.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-175">Attributes act as metadata.</span></span> <span data-ttu-id="6a4d2-176">Без применения внешних сил они по сути ничего не делают.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-176">Without some outward force, they won't actually do anything.</span></span>

<span data-ttu-id="6a4d2-177">Чтобы находить атрибуты и реагировать на них, обычно используется [отражение](../programming-guide/concepts/reflection.md).</span><span class="sxs-lookup"><span data-stu-id="6a4d2-177">To find and act on attributes, [Reflection](../programming-guide/concepts/reflection.md) is generally needed.</span></span> <span data-ttu-id="6a4d2-178">Мы не будем здесь подробно описывать отражения, ограничимся лишь основной идеей: отражение позволяет написать на C# код, который проверяет другой код.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-178">I won't cover Reflection in-depth in this tutorial, but the basic idea is that Reflection allows you to write code in C# that examines other code.</span></span>

<span data-ttu-id="6a4d2-179">Например, с помощью отражения можно получить сведения о классе (добавьте `using System.Reflection;` в начало кода):</span><span class="sxs-lookup"><span data-stu-id="6a4d2-179">For instance, you can use Reflection to get information about a class(add `using System.Reflection;` at the head of your code):</span></span> 

[!code-csharp[Getting type information with Reflection](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#ReflectionExample1)]

<span data-ttu-id="6a4d2-180">Этот код выведет такие данные: `The assembly qualified name of MyClass is ConsoleApplication.MyClass, attributes, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null`</span><span class="sxs-lookup"><span data-stu-id="6a4d2-180">That will print out something like: `The assembly qualified name of MyClass is ConsoleApplication.MyClass, attributes, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null`</span></span>

<span data-ttu-id="6a4d2-181">Если у вас есть объект `TypeInfo` (или `MemberInfo`, `FieldInfo` и т. д.), вы можете использовать метод `GetCustomAttributes`.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-181">Once you have a `TypeInfo` object (or a `MemberInfo`, `FieldInfo`, etc), you can use the `GetCustomAttributes` method.</span></span> <span data-ttu-id="6a4d2-182">Он возвращает коллекцию объектов `Attribute`.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-182">This will return a collection of `Attribute` objects.</span></span>
<span data-ttu-id="6a4d2-183">Можно также использовать `GetCustomAttribute`, указав тип атрибута.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-183">You can also use `GetCustomAttribute` and specify an Attribute type.</span></span>

<span data-ttu-id="6a4d2-184">Ниже вы видите пример использования `GetCustomAttributes` для экземпляра `MemberInfo` класса `MyClass` (как мы продемонстрировали ранее, он имеет атрибут `[Obsolete]`).</span><span class="sxs-lookup"><span data-stu-id="6a4d2-184">Here's an example of using `GetCustomAttributes` on a `MemberInfo` instance for `MyClass` (which we saw earlier has an `[Obsolete]` attribute on it).</span></span>

[!code-csharp[Getting type information with Reflection](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#ReflectionExample2)]

<span data-ttu-id="6a4d2-185">Этот код выведет в консоль текст: `Attribute on MyClass: ObsoleteAttribute`.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-185">That will print to console: `Attribute on MyClass: ObsoleteAttribute`.</span></span> <span data-ttu-id="6a4d2-186">Попробуйте добавить другие атрибуты для `MyClass`.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-186">Try adding other attributes to `MyClass`.</span></span>

<span data-ttu-id="6a4d2-187">Обратите особое внимание, что к таким объектам `Attribute` применяется отложенное создание экземпляров.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-187">It's important to note that these `Attribute` objects are instantiated lazily.</span></span> <span data-ttu-id="6a4d2-188">При вызове `GetCustomAttribute` или `GetCustomAttributes` экземпляры не создаются.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-188">That is, they won't be instantiated until you use `GetCustomAttribute` or `GetCustomAttributes`.</span></span>
<span data-ttu-id="6a4d2-189">Кроме того, они создаются заново при каждом обращении.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-189">They are also instantiated each time.</span></span> <span data-ttu-id="6a4d2-190">Выполнив `GetCustomAttributes` два раза подряд, вы получите два различных экземпляра `ObsoleteAttribute`.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-190">Calling `GetCustomAttributes` twice in a row will return two different instances of `ObsoleteAttribute`.</span></span>

## <a name="common-attributes-in-the-base-class-library-bcl"></a><span data-ttu-id="6a4d2-191">Популярные атрибуты в библиотеке базовых классов (BCL)</span><span class="sxs-lookup"><span data-stu-id="6a4d2-191">Common attributes in the base class library (BCL)</span></span>

<span data-ttu-id="6a4d2-192">Атрибуты используются многими средствами и платформами.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-192">Attributes are used by many tools and frameworks.</span></span> <span data-ttu-id="6a4d2-193">NUnit использует такие атрибуты, как `[Test]` и `[TestFixture]`, которые нужны для средства тестового запуска NUnit.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-193">NUnit uses attributes like `[Test]` and `[TestFixture]` that are used by the NUnit test runner.</span></span> <span data-ttu-id="6a4d2-194">ASP.NET MVC использует такие атрибуты, как `[Authorize]`, и предоставляет платформу фильтра действий, которая позволяет использовать перекрестные функции для действий MVC.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-194">ASP.NET MVC uses attributes like `[Authorize]` and provides an action filter framework to perform cross-cutting concerns on MVC actions.</span></span> <span data-ttu-id="6a4d2-195">[PostSharp](https://www.postsharp.net) использует синтаксис атрибутов для реализации аспектно-ориентированного программирования на языке C#.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-195">[PostSharp](https://www.postsharp.net) uses the attribute syntax to allow aspect-oriented programming in C#.</span></span>

<span data-ttu-id="6a4d2-196">Ниже приведены несколько важных атрибутов, используемых в библиотеках базовых классов .NET Core.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-196">Here are a few notable attributes built into the .NET Core base class libraries:</span></span>

* <span data-ttu-id="6a4d2-197">`[Obsolete]`.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-197">`[Obsolete]`.</span></span> <span data-ttu-id="6a4d2-198">Этот атрибут мы уже использовали в примерах выше. Он размещен в пространстве имен `System`.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-198">This one was used in the above examples, and it lives in the `System` namespace.</span></span> <span data-ttu-id="6a4d2-199">С его помощью удобно создавать декларативную документацию об изменении кодовой базы.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-199">It is useful to provide declarative documentation about a changing code base.</span></span> <span data-ttu-id="6a4d2-200">К нему можно добавить строковое сообщение, а дополнительный логический параметр позволяет повысить уровень сообщений компилятора с предупреждения до ошибки.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-200">A message can be provided in the form of a string, and another boolean parameter can be used to escalate from a compiler warning to a compiler error.</span></span>

* <span data-ttu-id="6a4d2-201">`[Conditional]`.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-201">`[Conditional]`.</span></span> <span data-ttu-id="6a4d2-202">Этот атрибут находится в пространстве имен `System.Diagnostics`.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-202">This attribute is in the `System.Diagnostics` namespace.</span></span> <span data-ttu-id="6a4d2-203">Его может применять к методам или классам атрибутов.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-203">This attribute can be applied to methods (or attribute classes).</span></span> <span data-ttu-id="6a4d2-204">В его конструктор необходимо передать строку.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-204">You must pass a string to the constructor.</span></span>
<span data-ttu-id="6a4d2-205">Если эта строка не совпадает с директивой `#define`, то компилятор C# будет удалять все вызовы этого метода (но не сам метод).</span><span class="sxs-lookup"><span data-stu-id="6a4d2-205">If that string doesn't match a `#define` directive, then any calls to that method (but not the method itself) will be removed by the C# compiler.</span></span> <span data-ttu-id="6a4d2-206">Обычно это используется для целей отладки или диагностики.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-206">Typically this is used for debugging (diagnostics) purposes.</span></span>

* <span data-ttu-id="6a4d2-207">`[CallerMemberName]`.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-207">`[CallerMemberName]`.</span></span> <span data-ttu-id="6a4d2-208">Этот атрибут можно применить для параметров. Он размещен в пространства имен `System.Runtime.CompilerServices`.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-208">This attribute can be used on parameters, and lives in the `System.Runtime.CompilerServices` namespace.</span></span> <span data-ttu-id="6a4d2-209">Этот атрибут позволяет передать имя метода добавления, который вызывает другой метод.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-209">This is an attribute that is used to inject the name of the method that is calling another method.</span></span> <span data-ttu-id="6a4d2-210">Обычно он используется для устранения "волшебных строк" при реализации INotifyPropertyChanged в различных платформах взаимодействия с пользователем.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-210">This is typically used as a way to eliminate 'magic strings' when implementing INotifyPropertyChanged in various UI frameworks.</span></span> <span data-ttu-id="6a4d2-211">Вот пример:</span><span class="sxs-lookup"><span data-stu-id="6a4d2-211">As an example:</span></span>

[!code-csharp[Using CallerMemberName when implementing INotifyPropertyChanged](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#CallerMemberName1)]

<span data-ttu-id="6a4d2-212">В приведенном выше коде не обязательно использовать литеральную строку `"Name"`.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-212">In the above code, you don't have to have a literal `"Name"` string.</span></span> <span data-ttu-id="6a4d2-213">Это помогает предотвратить ошибки, связанные с опечатками, а также позволяет плавно выполнять рефакторинг и (или) переименование.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-213">This can help prevent typo-related bugs and also makes for smoother refactoring/renaming.</span></span>

## <a name="summary"></a><span data-ttu-id="6a4d2-214">Сводка</span><span class="sxs-lookup"><span data-stu-id="6a4d2-214">Summary</span></span>

<span data-ttu-id="6a4d2-215">Атрибуты позволяют реализовать в C# возможности декларативного синтаксиса. Но они являются разновидностью метаданных и сами по себе не выполняют действия.</span><span class="sxs-lookup"><span data-stu-id="6a4d2-215">Attributes bring declarative power to C#, but they are a meta-data form of code and don't act by themselves.</span></span>
