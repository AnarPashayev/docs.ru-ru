---
title: Атрибуты. Язык C#
description: Узнайте, как работают атрибуты в C#.
author: mgroves
ms.technology: csharp-fundamentals
ms.date: 03/06/2017
ms.assetid: b152cf36-76e4-43a5-b805-1a1952e53b79
ms.openlocfilehash: 9f08e362ada032e7193d83a73fbbf05259bd2259
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2020
ms.locfileid: "75694560"
---
# <a name="use-attributes-in-c"></a>Использование атрибутов в C\#

Атрибуты предоставляют возможность декларативно связать информацию с кодом. Также этот элемент можно многократно использовать повторно для разнообразных целевых объектов.

Рассмотрим для примера атрибут `[Obsolete]`. Его можно применять к классам, структурам, методам, конструкторам и т. д. Он _объявляет_, что соответствующий элемент является устаревшим. Компилятор C# проверят наличие этого атрибута и выполняет некоторые действия, если он присутствует.

В этом руководстве мы покажем вам, как можно добавить атрибуты в код, как создавать и применять собственные атрибуты, а также использовать некоторые встроенные атрибуты .NET Core.

## <a name="prerequisites"></a>Предварительные требования
Компьютер должен быть настроен для выполнения .NET Core. Инструкции по установке см. на странице [скачиваемых файлов .NET Core](https://dotnet.microsoft.com/download).
Это приложение можно запустить в ОС Windows, Ubuntu Linux, macOS или в контейнере Docker.
Вам потребуется редактор кода, но вы можете выбрать любой привычный для вас. В примерах ниже используется кроссплатформенный редактор [Visual Studio Code](https://code.visualstudio.com/) с открытым исходным кодом. Вы можете заменить его на любое другое средство, с которым вам удобно работать.

## <a name="create-the-application"></a>Создание приложения

Теперь, когда вы установили все нужные средства, создайте новое приложение .NET Core. Чтобы использовать генератор из командной строки, выполните следующую команду в любой оболочке:

`dotnet new console`

Эта команда создает простые файлы проекта для .NET Core. Нужно также выполнить команду `dotnet restore`, чтобы восстановить зависимости, необходимые для компиляции проекта.

[!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]

Чтобы выполнить программу, используйте `dotnet run`. Она выведет в консоль сообщение "Hello, World".

## <a name="how-to-add-attributes-to-code"></a>Добавление атрибутов к коду

В C# атрибуты представляют собой классы, наследующие от базового класса `Attribute`. Любой класс, который наследует от `Attribute`, можно использовать как своего рода "тег" на другие части кода.
Например, существует атрибут с именем `ObsoleteAttribute`. С его помощью можно обозначить, что код устарел и больше не должен использоваться. Этот атрибут можно поместить в класс, используя квадратные скобки.

[!code-csharp[Obsolete attribute example](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#ObsoleteExample1)]

Обратите внимание, что полное название класса — `ObsoleteAttribute`, но в коде достаточно указать только `[Obsolete]`. Это стандартное соглашение в C#.
При желании вы можете использовать полное имя `[ObsoleteAttribute]`.

Когда вы отмечаете класс как устаревший, желательно предоставить некоторые сведения о том, *почему* он устарел и (или) *что* можно использовать вместо него. Для этого передайте в атрибут Obsolete строковый параметр.

[!code-csharp[Obsolete attribute example with parameters](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#ObsoleteExample2)]

Эта строка передается в качестве аргумента в конструктор `ObsoleteAttribute`, как если бы вы использовали синтаксис `var attr = new ObsoleteAttribute("some string")`.

В конструкторе атрибута можно использовать в качестве параметров только простые типы и литералы `bool, int, double, string, Type, enums, etc` и массивы этих типов.
Нельзя использовать переменные или выражения. Но вы можете свободно использовать позиционные или именованные параметры.

## <a name="how-to-create-your-own-attribute"></a>Как создать собственный атрибут

Чтобы создать собственный атрибут, достаточно унаследовать его от базового класса `Attribute`.

[!code-csharp[Create your own attribute](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#CreateAttributeExample1)]

Добавив такой код, вы сможете использовать `[MySpecial]` (или `[MySpecialAttribute]`) в качестве атрибута в любом месте кода.

[!code-csharp[Using your own attribute](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#CreateAttributeExample2)]

Атрибуты в библиотеке базовых классов .NET, например `ObsoleteAttribute`, активируют определенный действия компилятора. Но созданные вами атрибуты сами по себе лишь выполняют роль метаданных и не влекут за собой исполнение какого-либо кода в классе атрибута. Вы должны проверять эти метаданные и выполнять необходимые действия в другой части кода (подробнее об этом написано дальше в этом руководстве).

Здесь есть один подвох, которого следует остерегаться. Как упоминалось выше, в качестве аргументов при использовании атрибутов можно передавать только некоторые определенные типы. Но компилятор C# не помешает вам указать другие параметры при создании типа атрибута. В следующем примере кода я создаю атрибут с конструктором, который отлично компилируется.

[!code-csharp[Valid constructor used in an attribute](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#AttributeGothca1)]

Но объект с таким конструктором вы не сможете использовать в роли атрибута.

[!code-csharp[Invalid attempt to use the attribute constructor](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#AttributeGotcha2)]

Такой код вызовет ошибку компиляции, например такую: `Attribute constructor parameter 'myClass' has type 'Foo', which is not a valid attribute parameter type`

## <a name="how-to-restrict-attribute-usage"></a>Как ограничить использование атрибута

Атрибуты можно использовать для разных целевых объектов. В примере выше мы применили их для классов, но целевым объектом может быть любой из этого списка:

* Assembly
* Класс
* Конструктор
* делегат
* Enum
* событие
* Поле
* универсальный параметр;
* Интерфейс
* Метод
* Module
* Параметр
* Свойство.
* Возвращаемое значение
* Структура

Когда вы создаете класс атрибута, C# по умолчанию позволяет использовать этот атрибут для любого из допустимых целевых объектов. Если вы хотите, чтобы атрибут можно было использовать только для некоторых из целевых объектов, используйте `AttributeUsageAttribute` в классе атрибута. Да-да, именно так, атрибут для атрибута!

[!code-csharp[Using your own attribute](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#AttributeUsageExample1)]

Если вы попробуете применить описанный выше атрибут для сущности, которая не является классом или структурой, вы получите ошибку компиляции такого рода: `Attribute 'MyAttributeForClassAndStructOnly' is not valid on this declaration type. It is only valid on 'class, struct' declarations`

[!code-csharp[Using your own attribute](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#AttributeUsageExample2)]

## <a name="how-to-use-attributes-attached-to-a-code-element"></a>Как использовать атрибуты, прикрепленные к элементу кода

Атрибуты выполняют роль метаданных. Без применения внешних сил они по сути ничего не делают.

Чтобы находить атрибуты и реагировать на них, обычно используется [отражение](../programming-guide/concepts/reflection.md). Мы не будем здесь подробно описывать отражения, ограничимся лишь основной идеей: отражение позволяет написать на C# код, который проверяет другой код.

Например, с помощью отражения можно получить сведения о классе (добавьте `using System.Reflection;` в начало кода):

[!code-csharp[Getting type information with Reflection](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#ReflectionExample1)]

Этот код выведет такие данные: `The assembly qualified name of MyClass is ConsoleApplication.MyClass, attributes, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null`

Если у вас есть объект `TypeInfo` (или `MemberInfo`, `FieldInfo` и т. д.), вы можете использовать метод `GetCustomAttributes`. Он возвращает коллекцию объектов `Attribute`.
Можно также использовать `GetCustomAttribute`, указав тип атрибута.

Ниже вы видите пример использования `GetCustomAttributes` для экземпляра `MemberInfo` класса `MyClass` (как мы продемонстрировали ранее, он имеет атрибут `[Obsolete]`).

[!code-csharp[Getting type information with Reflection](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#ReflectionExample2)]

Этот код выведет в консоль текст: `Attribute on MyClass: ObsoleteAttribute`. Попробуйте добавить другие атрибуты для `MyClass`.

Обратите особое внимание, что к таким объектам `Attribute` применяется отложенное создание экземпляров. При вызове `GetCustomAttribute` или `GetCustomAttributes` экземпляры не создаются.
Кроме того, они создаются заново при каждом обращении. Выполнив `GetCustomAttributes` два раза подряд, вы получите два различных экземпляра `ObsoleteAttribute`.

## <a name="common-attributes-in-the-base-class-library-bcl"></a>Популярные атрибуты в библиотеке базовых классов (BCL)

Атрибуты используются многими средствами и платформами. NUnit использует такие атрибуты, как `[Test]` и `[TestFixture]`, которые нужны для средства тестового запуска NUnit. ASP.NET MVC использует такие атрибуты, как `[Authorize]`, и предоставляет платформу фильтра действий, которая позволяет использовать перекрестные функции для действий MVC. [PostSharp](https://www.postsharp.net) использует синтаксис атрибутов для реализации аспектно-ориентированного программирования на языке C#.

Ниже приведены несколько важных атрибутов, используемых в библиотеках базовых классов .NET Core.

* `[Obsolete]`. Этот атрибут мы уже использовали в примерах выше. Он размещен в пространстве имен `System`. С его помощью удобно создавать декларативную документацию об изменении кодовой базы. К нему можно добавить строковое сообщение, а дополнительный логический параметр позволяет повысить уровень сообщений компилятора с предупреждения до ошибки.

* `[Conditional]`. Этот атрибут находится в пространстве имен `System.Diagnostics`. Его может применять к методам или классам атрибутов. В его конструктор необходимо передать строку.
Если эта строка не совпадает с директивой `#define`, то компилятор C# будет удалять все вызовы этого метода (но не сам метод). Обычно это используется для целей отладки или диагностики.

* `[CallerMemberName]`. Этот атрибут можно применить для параметров. Он размещен в пространства имен `System.Runtime.CompilerServices`. Этот атрибут позволяет передать имя метода добавления, который вызывает другой метод. Обычно он используется для устранения "волшебных строк" при реализации INotifyPropertyChanged в различных платформах взаимодействия с пользователем. Вот пример:

[!code-csharp[Using CallerMemberName when implementing INotifyPropertyChanged](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#CallerMemberName1)]

В приведенном выше коде не обязательно использовать литеральную строку `"Name"`. Это помогает предотвратить ошибки, связанные с опечатками, а также позволяет плавно выполнять рефакторинг и (или) переименование.

## <a name="summary"></a>Сводка

Атрибуты позволяют реализовать в C# возможности декларативного синтаксиса. Но они являются разновидностью метаданных и сами по себе не выполняют действия.
