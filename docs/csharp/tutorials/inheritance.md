---
title: Наследование в C#
description: Сведения об использовании наследования в библиотеках и приложениях C#.
ms.date: 07/05/2018
ms.technology: csharp-fundamentals
ms.assetid: aeb68c74-0ea0-406f-9fbe-2ce02d47ef31
ms.openlocfilehash: b72badb7833e018dfcbf5d2583b17f17c800c382
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "79156757"
---
# <a name="inheritance-in-c-and-net"></a><span data-ttu-id="3211d-103">Наследование в C# и .NET</span><span class="sxs-lookup"><span data-stu-id="3211d-103">Inheritance in C# and .NET</span></span>

<span data-ttu-id="3211d-104">В этом руководстве вы познакомитесь с концепцией наследования в C#.</span><span class="sxs-lookup"><span data-stu-id="3211d-104">This tutorial introduces you to inheritance in C#.</span></span> <span data-ttu-id="3211d-105">Наследование является ключевой функцией объектно-ориентированных языков программирования. Оно позволяет определить базовый класс для определенных функций (доступа к данным или действий), а затем создавать производные классы, которые наследуют или переопределяют функции базового класса.</span><span class="sxs-lookup"><span data-stu-id="3211d-105">Inheritance is a feature of object-oriented programming languages that allows you to define a base class that provides specific functionality (data and behavior) and to define derived classes that either inherit or override that functionality.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="3211d-106">Предварительные требования</span><span class="sxs-lookup"><span data-stu-id="3211d-106">Prerequisites</span></span>

<span data-ttu-id="3211d-107">В этом руководстве предполагается, что вы уже установили пакет SDK для .NET Core.</span><span class="sxs-lookup"><span data-stu-id="3211d-107">This tutorial assumes that you've installed the .NET Core SDK.</span></span> <span data-ttu-id="3211d-108">Чтобы скачать его, перейдите на страницу [скачиваемых файлов .NET Core](https://dotnet.microsoft.com/download).</span><span class="sxs-lookup"><span data-stu-id="3211d-108">Visit the [.NET Core Downloads](https://dotnet.microsoft.com/download) page to download it.</span></span> <span data-ttu-id="3211d-109">Также вам потребуется редактор кода.</span><span class="sxs-lookup"><span data-stu-id="3211d-109">You also need a code editor.</span></span> <span data-ttu-id="3211d-110">В этом руководстве используется [Visual Studio Code](https://code.visualstudio.com), но вы можете использовать любой другой редактор на свой выбор.</span><span class="sxs-lookup"><span data-stu-id="3211d-110">This tutorial uses [Visual Studio Code](https://code.visualstudio.com), although you can use any code editor of your choice.</span></span>

## <a name="running-the-examples"></a><span data-ttu-id="3211d-111">Выполнение примеров</span><span class="sxs-lookup"><span data-stu-id="3211d-111">Running the examples</span></span>

<span data-ttu-id="3211d-112">Чтобы создать и запустить примеры, представленные в этом руководстве, используйте служебную программу [dotnet](../../core/tools/dotnet.md), выполняемую из командной строки.</span><span class="sxs-lookup"><span data-stu-id="3211d-112">To create and run the examples in this tutorial, you use the [dotnet](../../core/tools/dotnet.md) utility from the command line.</span></span> <span data-ttu-id="3211d-113">Выполните следующие действия для каждого примера.</span><span class="sxs-lookup"><span data-stu-id="3211d-113">Follow these steps for each example:</span></span>

1. <span data-ttu-id="3211d-114">Создайте каталог для хранения примера.</span><span class="sxs-lookup"><span data-stu-id="3211d-114">Create a directory to store the example.</span></span>
1. <span data-ttu-id="3211d-115">Введите в командной строке команду [dotnet new console](../../core/tools/dotnet-new.md), чтобы создать новый проект .NET Core.</span><span class="sxs-lookup"><span data-stu-id="3211d-115">Enter the [dotnet new console](../../core/tools/dotnet-new.md) command at a command prompt to create a new .NET Core project.</span></span>
1. <span data-ttu-id="3211d-116">Скопируйте код примера и вставьте его в файл с помощью редактора кода.</span><span class="sxs-lookup"><span data-stu-id="3211d-116">Copy and paste the code from the example into your code editor.</span></span>
1. <span data-ttu-id="3211d-117">Введите в командной строке команду [dotnet restore](../../core/tools/dotnet-restore.md), чтобы загрузить или восстановить зависимости проекта.</span><span class="sxs-lookup"><span data-stu-id="3211d-117">Enter the [dotnet restore](../../core/tools/dotnet-restore.md) command from the command line to load or restore the project's dependencies.</span></span>

  [!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]

1. <span data-ttu-id="3211d-118">Введите команду [dotnet run](../../core/tools/dotnet-run.md), чтобы скомпилировать и выполнить пример.</span><span class="sxs-lookup"><span data-stu-id="3211d-118">Enter the [dotnet run](../../core/tools/dotnet-run.md) command to compile and execute the example.</span></span>

## <a name="background-what-is-inheritance"></a><span data-ttu-id="3211d-119">Справочная информация. Что такое наследование?</span><span class="sxs-lookup"><span data-stu-id="3211d-119">Background: What is inheritance?</span></span>

<span data-ttu-id="3211d-120">*Наследование* является одним из фундаментальных атрибутов объектно-ориентированного программирования.</span><span class="sxs-lookup"><span data-stu-id="3211d-120">*Inheritance* is one of the fundamental attributes of object-oriented programming.</span></span> <span data-ttu-id="3211d-121">Оно позволяет определить дочерний класс, который использует (наследует), расширяет или изменяет возможности родительского класса.</span><span class="sxs-lookup"><span data-stu-id="3211d-121">It allows you to define a child class that reuses (inherits), extends, or modifies the behavior of a parent class.</span></span> <span data-ttu-id="3211d-122">Класс, члены которого наследуются, называется *базовым классом*.</span><span class="sxs-lookup"><span data-stu-id="3211d-122">The class whose members are inherited is called the *base class*.</span></span> <span data-ttu-id="3211d-123">Класс, который наследует члены базового класса, называется *производным классом*.</span><span class="sxs-lookup"><span data-stu-id="3211d-123">The class that inherits the members of the base class is called the *derived class*.</span></span>

<span data-ttu-id="3211d-124">C# и .NET поддерживают только *одиночное наследование*.</span><span class="sxs-lookup"><span data-stu-id="3211d-124">C# and .NET support *single inheritance* only.</span></span> <span data-ttu-id="3211d-125">Это означает, что каждый класс может наследовать члены только одного класса.</span><span class="sxs-lookup"><span data-stu-id="3211d-125">That is, a class can only inherit from a single class.</span></span> <span data-ttu-id="3211d-126">Но зато поддерживается транзитивное наследование, которое позволяет определить иерархию наследования для набора типов.</span><span class="sxs-lookup"><span data-stu-id="3211d-126">However, inheritance is transitive, which allows you to define an inheritance hierarchy for a set of types.</span></span> <span data-ttu-id="3211d-127">Другими словами, тип `D` может наследовать возможности типа `C`, который в свою очередь наследует от типа `B`, который наследует от базового класса `A`.</span><span class="sxs-lookup"><span data-stu-id="3211d-127">In other words, type `D` can inherit from type `C`, which inherits from type `B`, which inherits from the base class type `A`.</span></span> <span data-ttu-id="3211d-128">Благодаря транзитивности наследования члены типа `A` будут доступны для типа `D`.</span><span class="sxs-lookup"><span data-stu-id="3211d-128">Because inheritance is transitive, the members of type `A` are available to type `D`.</span></span>

<span data-ttu-id="3211d-129">Не все члены базового класса наследуются производными классами.</span><span class="sxs-lookup"><span data-stu-id="3211d-129">Not all members of a base class are inherited by derived classes.</span></span> <span data-ttu-id="3211d-130">Следующие члены не наследуются.</span><span class="sxs-lookup"><span data-stu-id="3211d-130">The following members are not inherited:</span></span>

- <span data-ttu-id="3211d-131">[Статические конструкторы](../programming-guide/classes-and-structs/static-constructors.md), которые инициализируют статические данные класса.</span><span class="sxs-lookup"><span data-stu-id="3211d-131">[Static constructors](../programming-guide/classes-and-structs/static-constructors.md), which initialize the static data of a class.</span></span>

- <span data-ttu-id="3211d-132">[Конструкторы экземпляров](../programming-guide/classes-and-structs/constructors.md), которые вызываются для создания нового экземпляра класса.</span><span class="sxs-lookup"><span data-stu-id="3211d-132">[Instance constructors](../programming-guide/classes-and-structs/constructors.md), which you call to create a new instance of the class.</span></span> <span data-ttu-id="3211d-133">Каждый класс должен определять собственные конструкторы.</span><span class="sxs-lookup"><span data-stu-id="3211d-133">Each class must define its own constructors.</span></span>

- <span data-ttu-id="3211d-134">[Методы завершения](../programming-guide/classes-and-structs/destructors.md), которые вызываются сборщиком мусора среды выполнения для уничтожения экземпляров класса.</span><span class="sxs-lookup"><span data-stu-id="3211d-134">[Finalizers](../programming-guide/classes-and-structs/destructors.md), which are called by the runtime's garbage collector to destroy instances of a class.</span></span>

<span data-ttu-id="3211d-135">Все остальные члены базового класса наследуются производными классами, но их видимость не зависит от доступности.</span><span class="sxs-lookup"><span data-stu-id="3211d-135">While all other members of a base class are inherited by derived classes, whether they are visible or not depends on their accessibility.</span></span> <span data-ttu-id="3211d-136">Доступность членов влияет на видимость для производных классов следующим образом.</span><span class="sxs-lookup"><span data-stu-id="3211d-136">A member's accessibility affects its visibility for derived classes as follows:</span></span>

- <span data-ttu-id="3211d-137">[Закрытые](../language-reference/keywords/private.md) члены являются видимыми только в производных классах, которые вложены в базовый класс.</span><span class="sxs-lookup"><span data-stu-id="3211d-137">[Private](../language-reference/keywords/private.md) members are visible only in derived classes that are nested in their base class.</span></span> <span data-ttu-id="3211d-138">Для других производных классов они невидимы.</span><span class="sxs-lookup"><span data-stu-id="3211d-138">Otherwise, they are not visible in derived classes.</span></span> <span data-ttu-id="3211d-139">В следующем примере класс `A.B` является вложенным и производным от `A`, а `C` является производным от `A`.</span><span class="sxs-lookup"><span data-stu-id="3211d-139">In the following example, `A.B` is a nested class that derives from `A`, and `C` derives from `A`.</span></span> <span data-ttu-id="3211d-140">Закрытое поле `A.value` является видимым в классе A.B.</span><span class="sxs-lookup"><span data-stu-id="3211d-140">The private `A.value` field is visible in A.B.</span></span> <span data-ttu-id="3211d-141">Но если раскомментировать строки метода `C.GetValue`, то при компиляции этого примера возникнет ошибка CS0122: "'A.value' недоступен из-за его уровня защиты".</span><span class="sxs-lookup"><span data-stu-id="3211d-141">However, if you remove the comments from the `C.GetValue` method and attempt to compile the example, it produces compiler error CS0122: "'A.value' is inaccessible due to its protection level."</span></span>

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/private.cs#1)]

- <span data-ttu-id="3211d-142">[Защищенные](../language-reference/keywords/protected.md) члены являются видимыми только в производных классах.</span><span class="sxs-lookup"><span data-stu-id="3211d-142">[Protected](../language-reference/keywords/protected.md) members are visible only in derived classes.</span></span>

- <span data-ttu-id="3211d-143">[Внутренние](../language-reference/keywords/internal.md) члены являются видимыми только в производных классах, которые находятся в той же сборке, что и базовый класс.</span><span class="sxs-lookup"><span data-stu-id="3211d-143">[Internal](../language-reference/keywords/internal.md) members are visible only in derived classes that are located in the same assembly as the base class.</span></span> <span data-ttu-id="3211d-144">Они не будут видимыми в производных классах, расположенных в других сборках.</span><span class="sxs-lookup"><span data-stu-id="3211d-144">They are not visible in derived classes located in a different assembly from the base class.</span></span>

- <span data-ttu-id="3211d-145">[Открытые](../language-reference/keywords/public.md) члены являются видимыми в производных классах, а также входят в общедоступный интерфейс производных классов.</span><span class="sxs-lookup"><span data-stu-id="3211d-145">[Public](../language-reference/keywords/public.md) members are visible in derived classes and are part of the derived class' public interface.</span></span> <span data-ttu-id="3211d-146">Унаследованные открытые члены можно вызывать так же, как если бы они были определены в самом производном классе.</span><span class="sxs-lookup"><span data-stu-id="3211d-146">Public inherited members can be called just as if they are defined in the derived class.</span></span> <span data-ttu-id="3211d-147">В следующем примере класс `A` определяет метод с именем `Method1`, а класс `B` наследует от класса `A`.</span><span class="sxs-lookup"><span data-stu-id="3211d-147">In the following example, class `A` defines a method named `Method1`, and class `B` inherits from class `A`.</span></span> <span data-ttu-id="3211d-148">В нашем примере `Method1` вызывается так, как если бы это был метод класса `B`.</span><span class="sxs-lookup"><span data-stu-id="3211d-148">The example then calls `Method1` as if it were an instance method on `B`.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/basics.cs#1)]

<span data-ttu-id="3211d-149">Производные классы могут также *переопределять* унаследованные члены, то есть предоставлять альтернативную реализацию.</span><span class="sxs-lookup"><span data-stu-id="3211d-149">Derived classes can also *override* inherited members by providing an alternate implementation.</span></span> <span data-ttu-id="3211d-150">Переопределить можно только те члены, которые в базовом классе отмечены ключевым словом [virtual](../language-reference/keywords/virtual.md) (виртуальный).</span><span class="sxs-lookup"><span data-stu-id="3211d-150">In order to be able to override a member, the member in the base class must be marked with the [virtual](../language-reference/keywords/virtual.md) keyword.</span></span> <span data-ttu-id="3211d-151">По умолчанию нельзя переопределять члены базового класса, не отмеченные ключевым словом `virtual`.</span><span class="sxs-lookup"><span data-stu-id="3211d-151">By default, base class members are not marked as `virtual` and cannot be overridden.</span></span> <span data-ttu-id="3211d-152">Попытка переопределить член, не являющийся виртуальным, как в следующем примере, вызывает ошибку компилятора CS0506: "\<член>: невозможно переопределить наследуемый член \<член>, так как он не помечен как виртуальный (virtual), абстрактный (abstract) или переопределяющий (override)".</span><span class="sxs-lookup"><span data-stu-id="3211d-152">Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: "\<member> cannot override inherited member \<member> because it is not marked virtual, abstract, or override.</span></span>

```csharp
public class A
{
    public void Method1()
    {
        // Do something.
    }
}

public class B : A
{
    public override void Method1() // Generates CS0506.
    {
        // Do something else.
    }
}
```

<span data-ttu-id="3211d-153">В некоторых случаях производный класс *обязан* переопределять реализацию базового класса.</span><span class="sxs-lookup"><span data-stu-id="3211d-153">In some cases, a derived class *must* override the base class implementation.</span></span> <span data-ttu-id="3211d-154">Члены базового класса, отмеченные ключевым словом [abstract](../language-reference/keywords/abstract.md) (абстрактный), обязательно должны переопределяться в производных классах.</span><span class="sxs-lookup"><span data-stu-id="3211d-154">Base class members marked with the [abstract](../language-reference/keywords/abstract.md) keyword require that derived classes override them.</span></span> <span data-ttu-id="3211d-155">При попытке компиляции следующего примера возникнет ошибка компилятора CS0534, "&lt;class&gt; не реализует наследуемый абстрактный член &lt;member&gt;", поскольку класс `B` не предоставляет реализации для `A.Method1`.</span><span class="sxs-lookup"><span data-stu-id="3211d-155">Attempting to compile the following example generates compiler error CS0534, "&lt;class&gt; does not implement inherited abstract member &lt;member&gt;", because class `B` provides no implementation for `A.Method1`.</span></span>

```csharp
public abstract class A
{
    public abstract void Method1();
}

public class B : A // Generates CS0534.
{
    public void Method3()
    {
        // Do something.
    }
}
```

<span data-ttu-id="3211d-156">Наследование применяется только для классов и интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="3211d-156">Inheritance applies only to classes and interfaces.</span></span> <span data-ttu-id="3211d-157">Другие категории типов (структуры, делегаты и перечисления) не поддерживают наследование.</span><span class="sxs-lookup"><span data-stu-id="3211d-157">Other type categories (structs, delegates, and enums) do not support inheritance.</span></span> <span data-ttu-id="3211d-158">Из-за этих правил попытка компиляции кода из следующего примера приводит к ошибке компилятора CS0527: "Тип 'ValueType' в списке интерфейсов не является интерфейсом".</span><span class="sxs-lookup"><span data-stu-id="3211d-158">Because of these rules, attempting to compile code like the following example produces compiler error CS0527: "Type 'ValueType' in interface list is not an interface."</span></span> <span data-ttu-id="3211d-159">Такое сообщение об ошибке означает, что наследование не поддерживается, несмотря на возможность определить интерфейсы, реализуемые в структуре.</span><span class="sxs-lookup"><span data-stu-id="3211d-159">The error message indicates that, although you can define the interfaces that a struct implements, inheritance is not supported.</span></span>

```csharp
using System;

public struct ValueStructure : ValueType // Generates CS0527.
{
}
```

## <a name="implicit-inheritance"></a><span data-ttu-id="3211d-160">Неявное наследование</span><span class="sxs-lookup"><span data-stu-id="3211d-160">Implicit inheritance</span></span>

<span data-ttu-id="3211d-161">Помимо тех типов, которые наследуются через механизм одиночного наследования, все типы в системе типов .NET неявно наследуются от типа <xref:System.Object> или его производного типа.</span><span class="sxs-lookup"><span data-stu-id="3211d-161">Besides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from <xref:System.Object> or a type derived from it.</span></span> <span data-ttu-id="3211d-162">Общие функции <xref:System.Object> доступны любому типу.</span><span class="sxs-lookup"><span data-stu-id="3211d-162">The common functionality of <xref:System.Object> is available to any type.</span></span>

<span data-ttu-id="3211d-163">Чтобы продемонстрировать неявное наследование, давайте определим новый класс `SimpleClass`, определение которого будет пустым.</span><span class="sxs-lookup"><span data-stu-id="3211d-163">To see what implicit inheritance means, let's define a new class, `SimpleClass`, that is simply an empty class definition:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#1)]

<span data-ttu-id="3211d-164">После этого с помощью отражения (которое позволяет проверить метаданные типа для получения сведений о нем) мы получим список членов, принадлежащих типу `SimpleClass`.</span><span class="sxs-lookup"><span data-stu-id="3211d-164">You can then use reflection (which lets you inspect a type's metadata to get information about that type) to get a list of the members that belong to the `SimpleClass` type.</span></span> <span data-ttu-id="3211d-165">Выходные данные этого примера возвращают нам девять членов класса `SimpleClass`, хотя мы не определяли ни один из них.</span><span class="sxs-lookup"><span data-stu-id="3211d-165">Although you haven't defined any members in your `SimpleClass` class, output from the example indicates that it actually has nine members.</span></span> <span data-ttu-id="3211d-166">Один из членов является вызываемым без параметров конструктором по умолчанию, который автоматически предоставляется для типа `SimpleClass` компилятором C#.</span><span class="sxs-lookup"><span data-stu-id="3211d-166">One of these members is a parameterless (or default) constructor that is automatically supplied for the `SimpleClass` type by the C# compiler.</span></span> <span data-ttu-id="3211d-167">Остальные восемь являются членами типа <xref:System.Object>, от которого неявным образом наследуются все классы и интерфейсы в системе типов .NET.</span><span class="sxs-lookup"><span data-stu-id="3211d-167">The remaining eight are members of <xref:System.Object>, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#2)]

<span data-ttu-id="3211d-168">Неявное наследование от класса <xref:System.Object> делает доступными для класса `SimpleClass` следующие методы.</span><span class="sxs-lookup"><span data-stu-id="3211d-168">Implicit inheritance from the <xref:System.Object> class makes these methods available to the `SimpleClass` class:</span></span>

- <span data-ttu-id="3211d-169">Открытый метод `ToString`, который преобразует объект `SimpleClass` в строковое представление, возвращает полное имя типа.</span><span class="sxs-lookup"><span data-stu-id="3211d-169">The public `ToString` method, which converts a `SimpleClass` object to its string representation, returns the fully qualified type name.</span></span> <span data-ttu-id="3211d-170">В нашем примере метод `ToString` возвращает строку SimpleClass.</span><span class="sxs-lookup"><span data-stu-id="3211d-170">In this case, the `ToString` method returns the string "SimpleClass".</span></span>

- <span data-ttu-id="3211d-171">Три метода, которые проверяют равенство двух объектов: открытый метод экземпляра `Equals(Object)`, открытый статический метод `Equals(Object, Object)` и открытый статический метод `ReferenceEquals(Object, Object)`.</span><span class="sxs-lookup"><span data-stu-id="3211d-171">Three methods that test for equality of two objects: the public instance `Equals(Object)` method, the public static `Equals(Object, Object)` method, and the public static `ReferenceEquals(Object, Object)` method.</span></span> <span data-ttu-id="3211d-172">По умолчанию эти методы проверяют ссылочное равенство. Это означает, что две переменные, содержащие объекты, должны ссылаться на один и тот же объект, чтобы считаться равными.</span><span class="sxs-lookup"><span data-stu-id="3211d-172">By default, these methods test for reference equality; that is, to be equal, two object variables must refer to the same object.</span></span>

- <span data-ttu-id="3211d-173">Открытый метод `GetHashCode`, который вычисляет значение, позволяющее использовать экземпляр типа в хэшированных коллекциях.</span><span class="sxs-lookup"><span data-stu-id="3211d-173">The public `GetHashCode` method, which computes a value that allows an instance of the type to be used in hashed collections.</span></span>

- <span data-ttu-id="3211d-174">Открытый метод `GetType`, который возвращает объект <xref:System.Type>, представляющий тип `SimpleClass`.</span><span class="sxs-lookup"><span data-stu-id="3211d-174">The public `GetType` method, which returns a <xref:System.Type> object that represents the `SimpleClass` type.</span></span>

- <span data-ttu-id="3211d-175">Защищенный метод <xref:System.Object.Finalize%2A>, который должен освобождать неуправляемые ресурсы перед тем, как сборщик мусора освободит память объекта.</span><span class="sxs-lookup"><span data-stu-id="3211d-175">The protected <xref:System.Object.Finalize%2A> method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector.</span></span>

- <span data-ttu-id="3211d-176">Защищенный метод <xref:System.Object.MemberwiseClone%2A>, который создает неполную копию текущего объекта.</span><span class="sxs-lookup"><span data-stu-id="3211d-176">The protected <xref:System.Object.MemberwiseClone%2A> method, which creates a shallow clone of the current object.</span></span>

<span data-ttu-id="3211d-177">Неявное наследование позволяет вызвать любой наследуемый член объекта `SimpleClass` точно так же, как если бы он был определен в самом классе `SimpleClass`.</span><span class="sxs-lookup"><span data-stu-id="3211d-177">Because of implicit inheritance, you can call any inherited member from a `SimpleClass` object just as if it was actually a member defined in the `SimpleClass` class.</span></span> <span data-ttu-id="3211d-178">Например, следующий пример вызывает метод `SimpleClass.ToString`, который `SimpleClass` наследует от <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="3211d-178">For instance, the following example calls the `SimpleClass.ToString` method, which `SimpleClass` inherits from <xref:System.Object>.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass2.cs#1)]

<span data-ttu-id="3211d-179">В следующей таблице перечислены категории типов, которые можно создавать на языке C#, и указаны типы, от которых они неявно наследуют.</span><span class="sxs-lookup"><span data-stu-id="3211d-179">The following table lists the categories of types that you can create in C# and the types from which they implicitly inherit.</span></span> <span data-ttu-id="3211d-180">Каждый из базовых типов предоставляет всем типам, которые неявно наследуют от него, разные наборы членов.</span><span class="sxs-lookup"><span data-stu-id="3211d-180">Each base type makes a different set of members available through inheritance to implicitly derived types.</span></span>

| <span data-ttu-id="3211d-181">Категория типа</span><span class="sxs-lookup"><span data-stu-id="3211d-181">Type category</span></span> | <span data-ttu-id="3211d-182">Неявно наследует от</span><span class="sxs-lookup"><span data-stu-id="3211d-182">Implicitly inherits from</span></span>                                                      |
| ------------- | ----------------------------------------------------------------------------- |
| <span data-ttu-id="3211d-183">class</span><span class="sxs-lookup"><span data-stu-id="3211d-183">class</span></span>         | <xref:System.Object>                                                          |
| <span data-ttu-id="3211d-184">struct</span><span class="sxs-lookup"><span data-stu-id="3211d-184">struct</span></span>        | <span data-ttu-id="3211d-185"><xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="3211d-185"><xref:System.ValueType>, <xref:System.Object></span></span>                                 |
| <span data-ttu-id="3211d-186">enum</span><span class="sxs-lookup"><span data-stu-id="3211d-186">enum</span></span>          | <span data-ttu-id="3211d-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="3211d-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span></span>             |
| <span data-ttu-id="3211d-188">delegate</span><span class="sxs-lookup"><span data-stu-id="3211d-188">delegate</span></span>      | <span data-ttu-id="3211d-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="3211d-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span></span> |

## <a name="inheritance-and-an-is-a-relationship"></a><span data-ttu-id="3211d-190">Наследование и связь "является"</span><span class="sxs-lookup"><span data-stu-id="3211d-190">Inheritance and an "is a" relationship</span></span>

<span data-ttu-id="3211d-191">Обычно наследование выражает связь вида "is a" (является) между базовым классом и одним или несколькими производными классами. Производные классы рассматриваются как специализированные версии базового класса, то есть как подтипы базового класса.</span><span class="sxs-lookup"><span data-stu-id="3211d-191">Ordinarily, inheritance is used to express an "is a" relationship between a base class and one or more derived classes, where the derived classes are specialized versions of the base class; the derived class is a type of the base class.</span></span> <span data-ttu-id="3211d-192">Например класс `Publication` представляет публикации любого рода, а классы `Book` и `Magazine` представляют публикации определенных типов.</span><span class="sxs-lookup"><span data-stu-id="3211d-192">For example, the `Publication` class represents a publication of any kind, and the `Book` and `Magazine` classes represent specific types of publications.</span></span>

> [!NOTE]
> <span data-ttu-id="3211d-193">Класс или структура могут реализовывать один или несколько интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="3211d-193">A class or struct can implement one or more interfaces.</span></span> <span data-ttu-id="3211d-194">Реализация интерфейсов часто рассматривается как метод для обхода ограничений одиночного наследования или для реализации наследования структур. Но его основным назначением является выражение связи другого рода между интерфейсом и реализующим его типом. Эта связь называется "can do" (может выполнять) и она отличается от связи наследования.</span><span class="sxs-lookup"><span data-stu-id="3211d-194">While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a "can do" relationship) between an interface and its implementing type than inheritance.</span></span> <span data-ttu-id="3211d-195">Интерфейс определяет подмножество функций (например, проверка равенства, сравнение и сортировка объектов, или поддержка синтаксического анализа и форматирования с учетом языка и региональных параметров). Интерфейс предоставляет эти функции всем типам, которые его реализуют.</span><span class="sxs-lookup"><span data-stu-id="3211d-195">An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.</span></span>

<span data-ttu-id="3211d-196">Обратите внимание, что связь "является" выражает также связь между типом и конкретным экземпляром этого типа.</span><span class="sxs-lookup"><span data-stu-id="3211d-196">Note that "is a" also expresses the relationship between a type and a specific instantiation of that type.</span></span> <span data-ttu-id="3211d-197">В следующем примере представлен класс `Automobile` с тремя уникальными свойствами только для чтения: `Make` определяет производителя автомобиля, `Model` определяет тип автомобиля, а `Year` — год выпуска.</span><span class="sxs-lookup"><span data-stu-id="3211d-197">In the following example, `Automobile` is a class that has three unique read-only properties: `Make`, the manufacturer of the automobile; `Model`, the kind of automobile; and `Year`, its year of manufacture.</span></span> <span data-ttu-id="3211d-198">Этот класс `Automobile` также содержит конструктор, аргументы которого назначаются значениям свойств. Еще в нем переопределен метод <xref:System.Object.ToString%2A?displayProperty=nameWithType>, который теперь возвращает строку, однозначно определяющую экземпляр `Automobile`, а не класс `Automobile`.</span><span class="sxs-lookup"><span data-stu-id="3211d-198">Your `Automobile` class also has a constructor whose arguments are assigned to the property values, and it overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to produce a string that uniquely identifies the `Automobile` instance rather than the `Automobile` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#1)]

<span data-ttu-id="3211d-199">В этом примере не следует использовать наследование для представления определенных производителей и моделей автомобилей.</span><span class="sxs-lookup"><span data-stu-id="3211d-199">In this case, you shouldn't rely on inheritance to represent specific car makes and models.</span></span> <span data-ttu-id="3211d-200">Например, вам не нужно определять тип `Packard`, который будет представлять автомобили, произведенные компанией Packard Motor Car.</span><span class="sxs-lookup"><span data-stu-id="3211d-200">For example, you don't need to define a `Packard` type to represent automobiles manufactured by the Packard Motor Car Company.</span></span> <span data-ttu-id="3211d-201">Для этого представления вы создадите объект `Automobile` и передадите конструктору этого класса соответствующие значения, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="3211d-201">Instead, you can represent them by creating an `Automobile` object with the appropriate values passed to its class constructor, as the following example does.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#2)]

<span data-ttu-id="3211d-202">Основанную на наследовании связь "является" лучше всего использовать для базовых классов и производных классов, которые добавляют дополнительные члены или используют дополнительные функции, отсутствующие в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="3211d-202">An is-a relationship based on inheritance is best applied to a base class and to derived classes that add additional members to the base class or that require additional functionality not present in the base class.</span></span>

## <a name="designing-the-base-class-and-derived-classes"></a><span data-ttu-id="3211d-203">Разработка базового класса и его производных классов</span><span class="sxs-lookup"><span data-stu-id="3211d-203">Designing the base class and derived classes</span></span>

<span data-ttu-id="3211d-204">Давайте рассмотрим процесс создания базового класса и его производных классов.</span><span class="sxs-lookup"><span data-stu-id="3211d-204">Let's look at the process of designing a base class and its derived classes.</span></span> <span data-ttu-id="3211d-205">В этом разделе вы определите базовый класс `Publication`, который представляет публикацию любого типа (книга, журнал, газета, статья и т. д.). Также вы определите класс `Book`, который наследует от класса `Publication`.</span><span class="sxs-lookup"><span data-stu-id="3211d-205">In this section, you'll define a base class, `Publication`, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. You'll also define a `Book` class that derives from `Publication`.</span></span> <span data-ttu-id="3211d-206">Этот пример легко расширить, определив другие производные классы, например `Magazine`, `Journal`, `Newspaper` и `Article`.</span><span class="sxs-lookup"><span data-stu-id="3211d-206">You could easily extend the example to define other derived classes, such as `Magazine`, `Journal`, `Newspaper`, and `Article`.</span></span>

### <a name="the-base-publication-class"></a><span data-ttu-id="3211d-207">Базовый класс Publication</span><span class="sxs-lookup"><span data-stu-id="3211d-207">The base Publication class</span></span>

<span data-ttu-id="3211d-208">При разработке класса `Publication` нужно принять несколько решений по его структуре.</span><span class="sxs-lookup"><span data-stu-id="3211d-208">In designing your `Publication` class, you need to make several design decisions:</span></span>

- <span data-ttu-id="3211d-209">Какие члены следует включить в базовый класс `Publication` и будут ли члены `Publication` реализовывать нужные методы? Или же базовый класс `Publication` лучше сделать абстрактным, то есть шаблоном для производных классов?</span><span class="sxs-lookup"><span data-stu-id="3211d-209">What members to include in your base `Publication` class, and whether the `Publication` members provide method implementations or whether `Publication` is an abstract base class that serves as a template for its derived classes.</span></span>

  <span data-ttu-id="3211d-210">В нашем примере класс `Publication` будет предоставлять реализации методов.</span><span class="sxs-lookup"><span data-stu-id="3211d-210">In this case, the `Publication` class will provide method implementations.</span></span> <span data-ttu-id="3211d-211">Раздел [Разработка абстрактных базовых классов и их производных классов](#abstract) содержит пример, в котором абстрактный базовый класс определяет методы, переопределяемые в производных классах.</span><span class="sxs-lookup"><span data-stu-id="3211d-211">The [Designing abstract base classes and their derived classes](#abstract) section contains an example that uses an abstract base class to define the methods that derived classes must override.</span></span> <span data-ttu-id="3211d-212">Производные классы могут использовать любую реализацию, применимую для конкретного производного типа.</span><span class="sxs-lookup"><span data-stu-id="3211d-212">Derived classes are free to provide any implementation that is suitable for the derived type.</span></span>

  <span data-ttu-id="3211d-213">Важным преимуществом неабстрактных базовых классов является возможность повторно использовать код (несколько производных классов используют объявления и реализации методов из базового класса, и могут не переопределять их).</span><span class="sxs-lookup"><span data-stu-id="3211d-213">The ability to reuse code (that is, multiple derived classes share the declaration and implementation of base class methods and do not need to override them) is an advantage of non-abstract base classes.</span></span> <span data-ttu-id="3211d-214">Таким образом, в `Publication` следует включать такие члены, которые с высокой долей вероятности будут использоваться в неизменном виде несколькими специализированными типами `Publication`.</span><span class="sxs-lookup"><span data-stu-id="3211d-214">Therefore, you should add members to `Publication` if their code is likely to be shared by some or most specialized `Publication` types.</span></span> <span data-ttu-id="3211d-215">Если вам не удастся эффективно предоставить реализации базового класса, вам придется создавать идентичные реализации членов в производных классах вместо того, чтобы использовать одну реализацию в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="3211d-215">If you fail to provide base class implementations efficiently, you'll end up having to provide largely identical member implementations in derived classes rather a single implementation in the base class.</span></span> <span data-ttu-id="3211d-216">Необходимость поддерживать несколько копий идентичного кода в нескольких местах станет потенциальным источником ошибок.</span><span class="sxs-lookup"><span data-stu-id="3211d-216">The need to maintain duplicated code in multiple locations is a potential source of bugs.</span></span>

  <span data-ttu-id="3211d-217">Чтобы оптимизировать повторное использование кода и создать логичную и интуитивно понятную иерархию наследования, необходимо включать в класс `Publication` только такие данные и функции, которые используются для большинства публикаций.</span><span class="sxs-lookup"><span data-stu-id="3211d-217">Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, you want to be sure that you include in the `Publication` class only the data and functionality that is common to all or to most publications.</span></span> <span data-ttu-id="3211d-218">Затем в производных классах реализуются уникальные члены для каждого вида публикаций, которые они представляют.</span><span class="sxs-lookup"><span data-stu-id="3211d-218">Derived classes then implement members that are unique to the particular kinds of publication that they represent.</span></span>

- <span data-ttu-id="3211d-219">Насколько глубокой будет иерархия классов?</span><span class="sxs-lookup"><span data-stu-id="3211d-219">How far to extend your class hierarchy.</span></span> <span data-ttu-id="3211d-220">Хотите ли вы включить в иерархию три или больше уровней классов или обойдетесь одним базовым классом с несколькими производными?</span><span class="sxs-lookup"><span data-stu-id="3211d-220">Do you want to develop a hierarchy of three or more classes, rather than simply a base class and one or more derived classes?</span></span> <span data-ttu-id="3211d-221">Например `Publication` может являться базовым классом для `Periodical`, от которого будут наследовать классы `Magazine`, `Journal` и `Newspaper`.</span><span class="sxs-lookup"><span data-stu-id="3211d-221">For example, `Publication` could be a base class of `Periodical`, which in turn is a base class of `Magazine`, `Journal` and `Newspaper`.</span></span>

  <span data-ttu-id="3211d-222">В вашем примере вы будете использовать небольшую иерархию, состоящую из класса `Publication` и одного производного класса `Book`.</span><span class="sxs-lookup"><span data-stu-id="3211d-222">For your example, you'll use the small hierarchy of a `Publication` class and a single derived class, `Book`.</span></span> <span data-ttu-id="3211d-223">Вы можете легко расширить пример, включив несколько дополнительных производных от `Publication`, например `Magazine` и `Article`.</span><span class="sxs-lookup"><span data-stu-id="3211d-223">You could easily extend the example to create a number of additional   classes that derive from `Publication`, such as `Magazine` and `Article`.</span></span>

- <span data-ttu-id="3211d-224">Нужны ли нам экземпляры базового класса?</span><span class="sxs-lookup"><span data-stu-id="3211d-224">Whether it makes sense to instantiate the base class.</span></span> <span data-ttu-id="3211d-225">Если нет, то для этого класса следует указать ключевое слово [abstract](../language-reference/keywords/abstract.md).</span><span class="sxs-lookup"><span data-stu-id="3211d-225">If it does not, you should apply the [abstract](../language-reference/keywords/abstract.md) keyword to the class.</span></span> <span data-ttu-id="3211d-226">В противном случае можно будет создать экземпляр класса `Publication`, вызвав конструктор этого класса.</span><span class="sxs-lookup"><span data-stu-id="3211d-226">Otherwise, your `Publication` class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="3211d-227">При попытке создать экземпляр класса с ключевым словом `abstract` путем прямого вызова конструктора класса компилятор C# возвращает ошибку CS0144: "Не удается создать экземпляр абстрактного класса или интерфейса".</span><span class="sxs-lookup"><span data-stu-id="3211d-227">If an attempt is made to instantiate a class marked with the `abstract` keyword by a direct call to its class constructor, the C# compiler generates error CS0144, "Cannot create an instance of the abstract class or interface."</span></span> <span data-ttu-id="3211d-228">Если попытаться создать экземпляр такого класса с помощью отражения, метод отражения создает исключение <xref:System.MemberAccessException>.</span><span class="sxs-lookup"><span data-stu-id="3211d-228">If an attempt is made to instantiate the class by using reflection, the reflection method throws a <xref:System.MemberAccessException>.</span></span>

  <span data-ttu-id="3211d-229">По умолчанию есть возможность создать экземпляр, вызвав конструктор базового класса.</span><span class="sxs-lookup"><span data-stu-id="3211d-229">By default, a base class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="3211d-230">Конструктор класса необязательно определять явным образом.</span><span class="sxs-lookup"><span data-stu-id="3211d-230">You do not have to explicitly define a class constructor.</span></span> <span data-ttu-id="3211d-231">Если конструктор отсутствует в исходном коде базового класса, компилятор C# автоматически предоставляет конструктор по умолчанию (без параметров).</span><span class="sxs-lookup"><span data-stu-id="3211d-231">If one is not present in the base class' source code, the C# compiler automatically provides a default (parameterless) constructor.</span></span>

  <span data-ttu-id="3211d-232">В вашем примере следует обозначить класс `Publication` как [абстрактный](../language-reference/keywords/abstract.md), и для него нельзя будет создавать экземпляры.</span><span class="sxs-lookup"><span data-stu-id="3211d-232">For your example, you'll mark the `Publication` class as [abstract](../language-reference/keywords/abstract.md) so that it cannot be instantiated.</span></span>  <span data-ttu-id="3211d-233">Класс `abstract` без методов `abstract` указывает, что этот класс представляет абстрактное понятие, которое является общим для нескольких конкретных классов (таких как `Book`, `Journal`).</span><span class="sxs-lookup"><span data-stu-id="3211d-233">An `abstract` class without any `abstract` methods indicates that this class represents an abstract concept that is shared among several concrete classes (like a `Book`, `Journal`).</span></span>

- <span data-ttu-id="3211d-234">Должны ли производные классы наследовать реализацию членов базового класса? Или же они могут переопределить реализацию базового класса? Или они должны предоставлять реализацию?</span><span class="sxs-lookup"><span data-stu-id="3211d-234">Whether derived classes must inherit the base class implementation of particular members, whether they have the option to override the base class implementation, or whether they must provide an implementation.</span></span> <span data-ttu-id="3211d-235">Используйте ключевое слово [abstract](../language-reference/keywords/abstract.md), чтобы производные классы принудительно предоставляли реализацию.</span><span class="sxs-lookup"><span data-stu-id="3211d-235">You use the [abstract](../language-reference/keywords/abstract.md) keyword to force derived classes to provide an implementation.</span></span> <span data-ttu-id="3211d-236">Чтобы производные классы могли переопределять методы базового класса, используйте ключевое слово [virtual](../language-reference/keywords/virtual.md).</span><span class="sxs-lookup"><span data-stu-id="3211d-236">You use the [virtual](../language-reference/keywords/virtual.md) keyword to allow derived classes to override a base class method.</span></span> <span data-ttu-id="3211d-237">По умолчанию методы, определенные в базовом классе, переопределять *нельзя*.</span><span class="sxs-lookup"><span data-stu-id="3211d-237">By default, methods defined in the base class are *not* overridable.</span></span>

 <span data-ttu-id="3211d-238">Класс `Publication` не имеет методов `abstract`, но сам класс помечен как `abstract`.</span><span class="sxs-lookup"><span data-stu-id="3211d-238">The `Publication` class does not have any `abstract` methods, but the class itself is `abstract`.</span></span>

- <span data-ttu-id="3211d-239">Будет ли производный класс последним в иерархии наследования (то есть его нельзя будет использовать в качестве базового класса для дополнительных производных классов)?</span><span class="sxs-lookup"><span data-stu-id="3211d-239">Whether a derived class represents the final class in the inheritance hierarchy and cannot itself be used as a base class for additional derived classes.</span></span> <span data-ttu-id="3211d-240">По умолчанию любой класс можно использовать в качестве базового класса.</span><span class="sxs-lookup"><span data-stu-id="3211d-240">By default, any class can serve as a base class.</span></span> <span data-ttu-id="3211d-241">Если указать ключевое слово [sealed](../language-reference/keywords/sealed.md) (запечатан), то класс нельзя будет использовать как базовый класс для дополнительных производных классов.</span><span class="sxs-lookup"><span data-stu-id="3211d-241">You can apply the [sealed](../language-reference/keywords/sealed.md) keyword to indicate that a class cannot serve as a base class for any additional classes.</span></span> <span data-ttu-id="3211d-242">При попытке наследовать запечатанный класс создается ошибка компилятора CS0509: "нельзя наследовать от запечатанного типа \<имя_типа>".</span><span class="sxs-lookup"><span data-stu-id="3211d-242">Attempting to derive from a sealed class generated compiler error CS0509, "cannot derive from sealed type \<typeName>".</span></span>

  <span data-ttu-id="3211d-243">В вашем примере обозначьте производный класс как `sealed`.</span><span class="sxs-lookup"><span data-stu-id="3211d-243">For your example, you'll mark your derived class as `sealed`.</span></span>

<span data-ttu-id="3211d-244">В следующем примере представлен исходный код для класса `Publication`, а также перечисление `PublicationType`, возвращаемое свойством `Publication.PublicationType`.</span><span class="sxs-lookup"><span data-stu-id="3211d-244">The following example shows the source code for the `Publication` class, as well as a `PublicationType` enumeration that is returned by the `Publication.PublicationType` property.</span></span> <span data-ttu-id="3211d-245">Помимо элементов, которые он наследует от <xref:System.Object>, класс `Publication` определяет и переопределяет следующие члены.</span><span class="sxs-lookup"><span data-stu-id="3211d-245">In addition to the members that it inherits from <xref:System.Object>, the `Publication` class defines the following unique members and member overrides:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#1)]

- <span data-ttu-id="3211d-246">Конструктор</span><span class="sxs-lookup"><span data-stu-id="3211d-246">A constructor</span></span>

  <span data-ttu-id="3211d-247">Поскольку класс `Publication` имеет обозначение `abstract`, для него нельзя напрямую создать экземпляр из кода, как в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="3211d-247">Because the `Publication` class is `abstract`, it cannot be instantiated directly from code like the following example:</span></span>

  ```csharp
  var publication = new Publication("Tiddlywinks for Experts", "Fun and Games",
                                    PublicationType.Book);
  ```

  <span data-ttu-id="3211d-248">Но при этом его конструктор для создания экземпляров можно напрямую вызвать из конструкторов производных классов, как показано в исходном коде для класса `Book`.</span><span class="sxs-lookup"><span data-stu-id="3211d-248">However, its instance constructor can be called directly from derived class constructors, as the source code for the `Book` class shows.</span></span>

- <span data-ttu-id="3211d-249">Два свойства, относящиеся к публикации</span><span class="sxs-lookup"><span data-stu-id="3211d-249">Two publication-related properties</span></span>

  <span data-ttu-id="3211d-250">Свойство `Title` доступно только для чтения и имеет тип <xref:System.String>. Его значение предоставляется путем вызова конструктора `Publication`.</span><span class="sxs-lookup"><span data-stu-id="3211d-250">`Title` is a read-only <xref:System.String> property whose value is supplied by calling the `Publication` constructor.</span></span>

  <span data-ttu-id="3211d-251">Свойство `Pages` доступно для чтения и записи и имеет тип <xref:System.Int32>. Значение этого свойства показывает, сколько всего страниц имеет эта публикация.</span><span class="sxs-lookup"><span data-stu-id="3211d-251">`Pages` is a read-write <xref:System.Int32> property that indicates how many total pages the publication has.</span></span> <span data-ttu-id="3211d-252">Это значение хранится в скрытом поле с именем `totalPages`.</span><span class="sxs-lookup"><span data-stu-id="3211d-252">The value is stored in a private field named `totalPages`.</span></span> <span data-ttu-id="3211d-253">В качестве значения принимается положительное число. В противном случае создается исключение <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="3211d-253">It must be a positive number or an <xref:System.ArgumentOutOfRangeException> is thrown.</span></span>

- <span data-ttu-id="3211d-254">Члены, связанные с издателем</span><span class="sxs-lookup"><span data-stu-id="3211d-254">Publisher-related members</span></span>

  <span data-ttu-id="3211d-255">Два свойства только для чтения: `Publisher` и `Type`.</span><span class="sxs-lookup"><span data-stu-id="3211d-255">Two read-only properties, `Publisher` and `Type`.</span></span> <span data-ttu-id="3211d-256">Эти значения изначально предоставляются путем вызова конструктора класса `Publication`.</span><span class="sxs-lookup"><span data-stu-id="3211d-256">The values are originally supplied by the call to the `Publication` class constructor.</span></span>

- <span data-ttu-id="3211d-257">Элементы, связанные с публикацией</span><span class="sxs-lookup"><span data-stu-id="3211d-257">Publishing-related members</span></span>

  <span data-ttu-id="3211d-258">Два метода, `Publish` и `GetPublicationDate`, которые устанавливают и возвращают дату публикации.</span><span class="sxs-lookup"><span data-stu-id="3211d-258">Two methods, `Publish` and `GetPublicationDate`, set and return the publication date.</span></span> <span data-ttu-id="3211d-259">Метод `Publish` устанавливает закрытый флаг `published` в значение `true` и присваивает переданную ему дату в качестве аргумента для закрытого поля `datePublished`.</span><span class="sxs-lookup"><span data-stu-id="3211d-259">The `Publish` method sets a private  `published` flag to `true` when it is called and assigns the date passed to it as an argument to the private `datePublished` field.</span></span> <span data-ttu-id="3211d-260">Метод `GetPublicationDate` возвращает строку "NYP", если флаг `published` имеет значение `false`, или значение поля `datePublished`, если флаг имеет значение `true`.</span><span class="sxs-lookup"><span data-stu-id="3211d-260">The `GetPublicationDate` method returns the string "NYP" if the `published` flag is `false`, and the value of the `datePublished` field if it is `true`.</span></span>

- <span data-ttu-id="3211d-261">Члены, связанные с авторскими правами</span><span class="sxs-lookup"><span data-stu-id="3211d-261">Copyright-related members</span></span>

  <span data-ttu-id="3211d-262">Метод `Copyright` принимает в качестве аргументов имя владельца авторских прав и год создания авторских прав, и назначает их свойствам `CopyrightName` и `CopyrightDate`.</span><span class="sxs-lookup"><span data-stu-id="3211d-262">The `Copyright` method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the `CopyrightName` and `CopyrightDate` properties.</span></span>

- <span data-ttu-id="3211d-263">Переопределение метода `ToString`</span><span class="sxs-lookup"><span data-stu-id="3211d-263">An override of the `ToString` method</span></span>

  <span data-ttu-id="3211d-264">Если метод <xref:System.Object.ToString%2A?displayProperty=nameWithType> не переопределяется в типе, он возвращает полное имя типа, которое не позволяет отличать экземпляры друг от друга.</span><span class="sxs-lookup"><span data-stu-id="3211d-264">If a type does not override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another.</span></span> <span data-ttu-id="3211d-265">Класс `Publication` переопределяет метод <xref:System.Object.ToString%2A?displayProperty=nameWithType>, чтобы он возвращал значение свойства `Title`.</span><span class="sxs-lookup"><span data-stu-id="3211d-265">The `Publication` class overrides <xref:System.Object.ToString%2A?displayProperty=nameWithType> to return the value of the `Title` property.</span></span>

<span data-ttu-id="3211d-266">Следующий рисунок иллюстрирует связь между базовым классом `Publication` и неявно унаследованным от него классом <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="3211d-266">The following figure illustrates the relationship between your base `Publication` class and its implicitly inherited <xref:System.Object> class.</span></span>

![Классы Object и Publication](media/publication-class.jpg)

### <a name="the-book-class"></a><span data-ttu-id="3211d-268">Класс `Book`</span><span class="sxs-lookup"><span data-stu-id="3211d-268">The `Book` class</span></span>

<span data-ttu-id="3211d-269">Класс `Book` представляет книгу как специализированный тип публикации.</span><span class="sxs-lookup"><span data-stu-id="3211d-269">The `Book` class represents a book as a specialized type of publication.</span></span> <span data-ttu-id="3211d-270">В следующем примере показан исходный код класса `Book`.</span><span class="sxs-lookup"><span data-stu-id="3211d-270">The following example shows the source code for the `Book` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#2)]

<span data-ttu-id="3211d-271">Помимо элементов, которые он наследует от `Publication`, класс `Book` определяет и переопределяет следующие члены.</span><span class="sxs-lookup"><span data-stu-id="3211d-271">In addition to the members that it inherits from `Publication`, the `Book` class defines the following unique members and member overrides:</span></span>

- <span data-ttu-id="3211d-272">Два конструктора</span><span class="sxs-lookup"><span data-stu-id="3211d-272">Two constructors</span></span>

  <span data-ttu-id="3211d-273">Два конструктора `Book` используют три общих параметра.</span><span class="sxs-lookup"><span data-stu-id="3211d-273">The two `Book` constructors share three common parameters.</span></span> <span data-ttu-id="3211d-274">Два из них, *header* и *publisher*, соответствуют параметрам конструктора `Publication`.</span><span class="sxs-lookup"><span data-stu-id="3211d-274">Two, *title* and *publisher*, correspond to parameters of the `Publication` constructor.</span></span> <span data-ttu-id="3211d-275">Третий — это *author*, который хранится в общедоступном неизменяемом свойстве `Author`.</span><span class="sxs-lookup"><span data-stu-id="3211d-275">The third is *author*, which is stored to a public immutable `Author` property.</span></span> <span data-ttu-id="3211d-276">Один конструктор использует параметр *isbn*, который хранится в автосвойстве `ISBN`.</span><span class="sxs-lookup"><span data-stu-id="3211d-276">One constructor includes an *isbn* parameter, which is stored in the `ISBN` auto-property.</span></span>

  <span data-ttu-id="3211d-277">Первый конструктор использует ключевое слово [this](../language-reference/keywords/this.md) для вызова второго конструктора.</span><span class="sxs-lookup"><span data-stu-id="3211d-277">The first constructor uses the [this](../language-reference/keywords/this.md) keyword to call the other constructor.</span></span> <span data-ttu-id="3211d-278">Создание цепочки конструкторов — это обычный метод определения конструкторов.</span><span class="sxs-lookup"><span data-stu-id="3211d-278">Constructor chaining is a common pattern in defining constructors.</span></span> <span data-ttu-id="3211d-279">Конструкторы с меньшим числом параметров используют значения по умолчанию, вызывая конструкторы с большим числом параметров.</span><span class="sxs-lookup"><span data-stu-id="3211d-279">Constructors with fewer parameters provide default values when calling the constructor with the greatest number of parameters.</span></span>

  <span data-ttu-id="3211d-280">Второй конструктор использует ключевое слово [base](../language-reference/keywords/base.md), чтобы передать заголовок и имя издателя в конструктор базового класса.</span><span class="sxs-lookup"><span data-stu-id="3211d-280">The second constructor uses the [base](../language-reference/keywords/base.md) keyword to pass the title and publisher name to the base class constructor.</span></span> <span data-ttu-id="3211d-281">Если вы не используете явный вызов конструктора базового класса в исходном коде, компилятор C# автоматически добавляет вызов конструктора по умолчанию (без параметров) для базового класса.</span><span class="sxs-lookup"><span data-stu-id="3211d-281">If you don't make an explicit call to a base class constructor in your source code, the C# compiler automatically supplies a call to the base class' default or parameterless constructor.</span></span>

- <span data-ttu-id="3211d-282">Свойство `ISBN`, доступное только для чтения, которое возвращает международный стандартный номер книги (уникальное 10- или 13-значное число) для объекта `Book`.</span><span class="sxs-lookup"><span data-stu-id="3211d-282">A read-only `ISBN` property, which returns the `Book` object's International Standard Book Number, a unique 10- or 13-digit number.</span></span> <span data-ttu-id="3211d-283">Номер ISBN передается в качестве аргумента одному из конструкторов `Book`.</span><span class="sxs-lookup"><span data-stu-id="3211d-283">The ISBN is supplied as an argument to one of the `Book` constructors.</span></span> <span data-ttu-id="3211d-284">Он сохраняется в закрытом резервном поле, автоматически создаваемым компилятором.</span><span class="sxs-lookup"><span data-stu-id="3211d-284">The ISBN is stored in a private backing field, which is auto-generated by the compiler.</span></span>

- <span data-ttu-id="3211d-285">Свойство `Author`, доступное только для чтения.</span><span class="sxs-lookup"><span data-stu-id="3211d-285">A read-only `Author` property.</span></span> <span data-ttu-id="3211d-286">Имя автора передается в качестве аргумента обоим конструкторам `Book` и сохраняется в свойстве.</span><span class="sxs-lookup"><span data-stu-id="3211d-286">The author name is supplied as an argument to both `Book` constructors and is stored in the property.</span></span>

- <span data-ttu-id="3211d-287">Два свойства, `Price` и `Currency`, с информацией о цене, доступные только для чтения.</span><span class="sxs-lookup"><span data-stu-id="3211d-287">Two read-only price-related properties, `Price` and `Currency`.</span></span> <span data-ttu-id="3211d-288">Значения этих свойств передаются в качестве аргументов при вызове метода `SetPrice`.</span><span class="sxs-lookup"><span data-stu-id="3211d-288">Their values are provided as arguments in a `SetPrice` method call.</span></span> <span data-ttu-id="3211d-289">Свойство `Currency` содержит трехзначное обозначение валюты по стандарту ISO (например, USD обозначает доллар США).</span><span class="sxs-lookup"><span data-stu-id="3211d-289">The `Currency` property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar).</span></span> <span data-ttu-id="3211d-290">Обозначение валюты по стандарту ISO можно получить из свойства <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A>.</span><span class="sxs-lookup"><span data-stu-id="3211d-290">ISO currency symbols can be retrieved from the <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> property.</span></span> <span data-ttu-id="3211d-291">Оба эти свойства доступны для чтения извне, но их можно задать в коде в классе `Book`.</span><span class="sxs-lookup"><span data-stu-id="3211d-291">Both of these properties are externally read-only, but both can be set by code in the `Book` class.</span></span>

- <span data-ttu-id="3211d-292">Метод `SetPrice`, который задает значения для свойств `Price` и `Currency`.</span><span class="sxs-lookup"><span data-stu-id="3211d-292">A `SetPrice` method, which sets the values of the `Price` and `Currency` properties.</span></span> <span data-ttu-id="3211d-293">Эти значения возвращаются теми же свойствами.</span><span class="sxs-lookup"><span data-stu-id="3211d-293">Those values are returned by those same properties.</span></span>

- <span data-ttu-id="3211d-294">Переопределение метода `ToString`, унаследованного от `Publication`, а также методов <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> и <xref:System.Object.GetHashCode%2A>, унаследованных от <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="3211d-294">Overrides to the `ToString` method (inherited from `Publication`) and the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> and <xref:System.Object.GetHashCode%2A> methods (inherited from <xref:System.Object>).</span></span>

  <span data-ttu-id="3211d-295">Если метод <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> не переопределен, он проверяет ссылочное равенство.</span><span class="sxs-lookup"><span data-stu-id="3211d-295">Unless it is overridden, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method tests for reference equality.</span></span> <span data-ttu-id="3211d-296">Это означает, что две объектные переменные считаются равными, если ссылаются на один и тот же объект.</span><span class="sxs-lookup"><span data-stu-id="3211d-296">That is, two object variables are considered to be equal if they refer to the same object.</span></span> <span data-ttu-id="3211d-297">С другой стороны, в классе `Book` два объекта `Book` должны считаться равными, если они имеют одинаковые номера ISBN.</span><span class="sxs-lookup"><span data-stu-id="3211d-297">In the `Book` class, on the other hand, two `Book` objects should be equal if they have the same ISBN.</span></span>

  <span data-ttu-id="3211d-298">Переопределив метод <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, необходимо также переопределить метод <xref:System.Object.GetHashCode%2A>, который возвращает значение, используемое средой выполнения для хранения элементов в хэшированных коллекциях для быстрого извлечения.</span><span class="sxs-lookup"><span data-stu-id="3211d-298">When you override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, you must also override the <xref:System.Object.GetHashCode%2A> method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval.</span></span> <span data-ttu-id="3211d-299">Возвращаемое значение хэш-кода должно согласовываться с проверкой на равенство.</span><span class="sxs-lookup"><span data-stu-id="3211d-299">The hash code should return a value that's consistent with the test for equality.</span></span> <span data-ttu-id="3211d-300">Поскольку теперь новый метод <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> возвращает `true`, если у двух объектов `Book` равны свойства ISBN, при расчете хэш-кода вы будете вызывать метод <xref:System.String.GetHashCode%2A> для строки, полученной из свойства `ISBN`.</span><span class="sxs-lookup"><span data-stu-id="3211d-300">Since you've overridden <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to return `true` if the ISBN properties of two `Book` objects are equal, you return the hash code computed by calling the <xref:System.String.GetHashCode%2A> method of the string returned by the `ISBN` property.</span></span>

<span data-ttu-id="3211d-301">Следующий рисунок иллюстрирует связь между классом `Book` и классом `Publication`, который является для него базовым.</span><span class="sxs-lookup"><span data-stu-id="3211d-301">The following figure illustrates the relationship between the `Book` class and `Publication`, its base class.</span></span>

![Классы Publication и Book](media/book-class.jpg)

<span data-ttu-id="3211d-303">Теперь вы можете создавать экземпляры объекта `Book`, вызывать его уникальные и унаследованные члены, а также передавать его в качестве аргумента в любой метод, принимающий параметры типа `Publication` или `Book`, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="3211d-303">You can now instantiate a `Book` object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type `Publication` or of type `Book`, as the following example shows.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/use-publication.cs#1)]

## <a name="designing-abstract-base-classes-and-their-derived-classes"></a><span data-ttu-id="3211d-304">Разработка абстрактных базовых классов и их производных классов</span><span class="sxs-lookup"><span data-stu-id="3211d-304">Designing abstract base classes and their derived classes</span></span>
<a name="abstract"></a>

<span data-ttu-id="3211d-305">В предыдущем примере вы определили базовый класс, который предоставляет реализацию нескольких методов, обеспечивая совместное использование кода в производных классах.</span><span class="sxs-lookup"><span data-stu-id="3211d-305">In the previous example, you defined a base class that provided an implementation for a number of methods to allow derived classes to share code.</span></span> <span data-ttu-id="3211d-306">Но во многих случаях базовый класс не должен предоставлять реализацию.</span><span class="sxs-lookup"><span data-stu-id="3211d-306">In many cases, however, the base class is not expected to provide an implementation.</span></span> <span data-ttu-id="3211d-307">Такой базовый класс будет являться *абстрактным классом*, который объявляет *абстрактные методы*. Он выступает в качестве шаблона и определяет члены, которые каждый производный класс должен реализовывать самостоятельно.</span><span class="sxs-lookup"><span data-stu-id="3211d-307">Instead, the base class is an *abstract class* that declares *abstract methods*; it serves as a template that defines the members that each derived class must implement.</span></span> <span data-ttu-id="3211d-308">При использовании абстрактного базового класса реализация каждого из производных типов обычно уникальна для конкретного типа.</span><span class="sxs-lookup"><span data-stu-id="3211d-308">Typically in an abstract base class, the implementation of each derived type is unique to that type.</span></span> <span data-ttu-id="3211d-309">Вы отметили класс ключевым словом abstract, так как не имело смысла создавать экземпляр объекта `Publication`, хотя класс предоставлял реализации функций, общих для публикаций.</span><span class="sxs-lookup"><span data-stu-id="3211d-309">You marked the class with the abstract keyword because it made no sense to instantiate a `Publication` object, although the class did provide implementations of functionality common to publications.</span></span>

<span data-ttu-id="3211d-310">Например, каждая замкнутая геометрическая фигура в двумерном пространстве имеет два свойства: площадь внутренней поверхности и длину ее границ (периметр).</span><span class="sxs-lookup"><span data-stu-id="3211d-310">For example, each closed two-dimensional geometric shape includes two properties: area, the inner extent of the shape; and perimeter, or the distance along the edges of the shape.</span></span> <span data-ttu-id="3211d-311">Но при этом методы вычисления этих свойств полностью зависят от конкретной фигуры.</span><span class="sxs-lookup"><span data-stu-id="3211d-311">The way in which these properties are calculated, however, depends completely on the specific shape.</span></span> <span data-ttu-id="3211d-312">Например, формула вычисления периметра (длины окружности) для круга отличается от формулы для треугольника.</span><span class="sxs-lookup"><span data-stu-id="3211d-312">The formula for calculating the perimeter (or circumference) of a circle, for example, is different from that of a triangle.</span></span> <span data-ttu-id="3211d-313">Класс `Shape` является классом `abstract` с методами `abstract`.</span><span class="sxs-lookup"><span data-stu-id="3211d-313">The `Shape` class is an `abstract` class with `abstract` methods.</span></span> <span data-ttu-id="3211d-314">Это означает, что производные классы имеют одинаковые функции, но эти производные классы иначе реализуют эти функции.</span><span class="sxs-lookup"><span data-stu-id="3211d-314">That indicates derived classes share the same functionality, but those derived classes implement that functionality differently.</span></span>

<span data-ttu-id="3211d-315">Следующий пример определяет абстрактный базовый класс с именем `Shape` и два его свойства: `Area` и `Perimeter`.</span><span class="sxs-lookup"><span data-stu-id="3211d-315">The following example defines an abstract base class named `Shape` that defines two properties: `Area` and `Perimeter`.</span></span> <span data-ttu-id="3211d-316">Ключевым словом [abstract](../language-reference/keywords/abstract.md) помечается не только сам класс. Каждый член экземпляра также получает метку [abstract](../language-reference/keywords/abstract.md).</span><span class="sxs-lookup"><span data-stu-id="3211d-316">In addition to marking the class with the [abstract](../language-reference/keywords/abstract.md) keyword, each instance member is also marked with the [abstract](../language-reference/keywords/abstract.md) keyword.</span></span> <span data-ttu-id="3211d-317">Кроме того, в классе `Shape` мы снова переопределяем метод <xref:System.Object.ToString%2A?displayProperty=nameWithType>, чтобы он возвращал имя типа, а не полное имя типа.</span><span class="sxs-lookup"><span data-stu-id="3211d-317">In this case, `Shape` also overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the name of the type, rather than its fully qualified name.</span></span> <span data-ttu-id="3211d-318">Еще мы определяем два статических члена `GetArea` и `GetPerimeter`, которые позволяют вызывающим объектам легко получить площадь и периметр для конкретного экземпляра любого производного класса.</span><span class="sxs-lookup"><span data-stu-id="3211d-318">And it defines two static members, `GetArea` and `GetPerimeter`, that allow callers to easily retrieve the area and perimeter of an instance of any derived class.</span></span> <span data-ttu-id="3211d-319">Когда вы передаете в любой из этих методов экземпляр производного класса, среда выполнения вызывает переопределенные методы из соответствующего производного класса.</span><span class="sxs-lookup"><span data-stu-id="3211d-319">When you pass an instance of a derived class to either of these methods, the runtime calls the method override of the derived class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#1)]

<span data-ttu-id="3211d-320">Теперь вы можете создать несколько классов, производных от `Shape`, которые будут представлять разные геометрические фигуры.</span><span class="sxs-lookup"><span data-stu-id="3211d-320">You can then derive some classes from `Shape` that represent specific shapes.</span></span> <span data-ttu-id="3211d-321">В следующем примере определяются три класса: `Triangle`, `Rectangle` и `Circle`.</span><span class="sxs-lookup"><span data-stu-id="3211d-321">The following example defines three classes, `Triangle`, `Rectangle`, and `Circle`.</span></span> <span data-ttu-id="3211d-322">В каждом из них используются уникальные формулы для вычисления площади и периметра, соответствующие типу фигуры.</span><span class="sxs-lookup"><span data-stu-id="3211d-322">Each uses a formula unique for that particular shape to compute the area and perimeter.</span></span> <span data-ttu-id="3211d-323">Также некоторые из производных классов определяют дополнительные свойства, например `Rectangle.Diagonal` и `Circle.Diameter`, которые уникальны для фигуры, представляемой этим классом.</span><span class="sxs-lookup"><span data-stu-id="3211d-323">Some of the derived classes also define properties, such as `Rectangle.Diagonal` and `Circle.Diameter`, that are unique to the shape that they represent.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#2)]

<span data-ttu-id="3211d-324">Следующий пример использует объекты, производные от `Shape`.</span><span class="sxs-lookup"><span data-stu-id="3211d-324">The following example uses objects derived from `Shape`.</span></span> <span data-ttu-id="3211d-325">Он создает массив объектов, производных от `Shape`, и вызывает статические методы для класса `Shape`, которые служат оболочкой для обращения к значениям свойств `Shape`.</span><span class="sxs-lookup"><span data-stu-id="3211d-325">It instantiates an array of objects derived from `Shape` and calls the static methods of the `Shape` class, which wraps return `Shape` property values.</span></span> <span data-ttu-id="3211d-326">Среда выполнения извлекает значения переопределенных свойств для производных типов.</span><span class="sxs-lookup"><span data-stu-id="3211d-326">The runtime retrieves values from the overridden properties of the derived types.</span></span> <span data-ttu-id="3211d-327">Также в этом примере каждый объект `Shape` из созданного массива приводится к производному типу. Если это приведение выполняется успешно, выполняется обращение к свойствам, определенным для конкретного подкласса базового класса `Shape`.</span><span class="sxs-lookup"><span data-stu-id="3211d-327">The example also casts each `Shape` object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of `Shape`.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#3)]

## <a name="see-also"></a><span data-ttu-id="3211d-328">См. также</span><span class="sxs-lookup"><span data-stu-id="3211d-328">See also</span></span>

- [<span data-ttu-id="3211d-329">Классы и объекты</span><span class="sxs-lookup"><span data-stu-id="3211d-329">Classes and objects</span></span>](../tour-of-csharp/classes-and-objects.md)
- [<span data-ttu-id="3211d-330">Наследование (руководство по программированию на C#)</span><span class="sxs-lookup"><span data-stu-id="3211d-330">Inheritance (C# Programming Guide)</span></span>](../programming-guide/classes-and-structs/inheritance.md)
