---
title: Наследование в C#
description: Сведения об использовании наследования в библиотеках и приложениях C#.
ms.date: 07/05/2018
ms.technology: csharp-fundamentals
ms.assetid: aeb68c74-0ea0-406f-9fbe-2ce02d47ef31
ms.openlocfilehash: 8e24ad3e93dcd11f39ae979a3acda4c4ada13dc5
ms.sourcegitcommit: 03fec33630b46e78d5e81e91b40518f32c4bd7b5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/27/2020
ms.locfileid: "84007732"
---
# <a name="inheritance-in-c-and-net"></a>Наследование в C# и .NET

В этом руководстве вы познакомитесь с концепцией наследования в C#. Наследование является ключевой функцией объектно-ориентированных языков программирования. Оно позволяет определить базовый класс для определенных функций (доступа к данным или действий), а затем создавать производные классы, которые наследуют или переопределяют функции базового класса.

## <a name="prerequisites"></a>Предварительные требования

В этом руководстве предполагается, что вы уже установили пакет SDK для .NET Core. Чтобы скачать его, перейдите на страницу [скачиваемых файлов .NET Core](https://dotnet.microsoft.com/download). Также вам потребуется редактор кода. В этом руководстве используется [Visual Studio Code](https://code.visualstudio.com), но вы можете использовать любой другой редактор на свой выбор.

## <a name="running-the-examples"></a>Выполнение примеров

Чтобы создать и запустить примеры, представленные в этом руководстве, используйте служебную программу [dotnet](../../core/tools/dotnet.md), выполняемую из командной строки. Выполните следующие действия для каждого примера.

1. Создайте каталог для хранения примера.
1. Введите в командной строке команду [dotnet new console](../../core/tools/dotnet-new.md), чтобы создать новый проект .NET Core.
1. Скопируйте код примера и вставьте его в файл с помощью редактора кода.
1. Введите в командной строке команду [dotnet restore](../../core/tools/dotnet-restore.md), чтобы загрузить или восстановить зависимости проекта.

   [!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]

1. Введите команду [dotnet run](../../core/tools/dotnet-run.md), чтобы скомпилировать и выполнить пример.

## <a name="background-what-is-inheritance"></a>Справочная информация. Что такое наследование?

*Наследование* является одним из фундаментальных атрибутов объектно-ориентированного программирования. Оно позволяет определить дочерний класс, который использует (наследует), расширяет или изменяет возможности родительского класса. Класс, члены которого наследуются, называется *базовым классом*. Класс, который наследует члены базового класса, называется *производным классом*.

C# и .NET поддерживают только *одиночное наследование*. Это означает, что каждый класс может наследовать члены только одного класса. Но зато поддерживается транзитивное наследование, которое позволяет определить иерархию наследования для набора типов. Другими словами, тип `D` может наследовать возможности типа `C`, который в свою очередь наследует от типа `B`, который наследует от базового класса `A`. Благодаря транзитивности наследования члены типа `A` будут доступны для типа `D`.

Не все члены базового класса наследуются производными классами. Следующие члены не наследуются.

- [Статические конструкторы](../programming-guide/classes-and-structs/static-constructors.md), которые инициализируют статические данные класса.

- [Конструкторы экземпляров](../programming-guide/classes-and-structs/constructors.md), которые вызываются для создания нового экземпляра класса. Каждый класс должен определять собственные конструкторы.

- [Методы завершения](../programming-guide/classes-and-structs/destructors.md), которые вызываются сборщиком мусора среды выполнения для уничтожения экземпляров класса.

Все остальные члены базового класса наследуются производными классами, но их видимость не зависит от доступности. Доступность членов влияет на видимость для производных классов следующим образом.

- [Закрытые](../language-reference/keywords/private.md) члены являются видимыми только в производных классах, которые вложены в базовый класс. Для других производных классов они невидимы. В следующем примере класс `A.B` является вложенным и производным от `A`, а `C` является производным от `A`. Закрытое поле `A.value` является видимым в классе A.B. Но если раскомментировать строки метода `C.GetValue`, то при компиляции этого примера возникнет ошибка CS0122: "'A.value' недоступен из-за его уровня защиты".

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/private.cs#1)]

- [Защищенные](../language-reference/keywords/protected.md) члены являются видимыми только в производных классах.

- [Внутренние](../language-reference/keywords/internal.md) члены являются видимыми только в производных классах, которые находятся в той же сборке, что и базовый класс. Они не будут видимыми в производных классах, расположенных в других сборках.

- [Открытые](../language-reference/keywords/public.md) члены являются видимыми в производных классах, а также входят в общедоступный интерфейс производных классов. Унаследованные открытые члены можно вызывать так же, как если бы они были определены в самом производном классе. В следующем примере класс `A` определяет метод с именем `Method1`, а класс `B` наследует от класса `A`. В нашем примере `Method1` вызывается так, как если бы это был метод класса `B`.

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/basics.cs#1)]

Производные классы могут также *переопределять* унаследованные члены, то есть предоставлять альтернативную реализацию. Переопределить можно только те члены, которые в базовом классе отмечены ключевым словом [virtual](../language-reference/keywords/virtual.md) (виртуальный). По умолчанию нельзя переопределять члены базового класса, не отмеченные ключевым словом `virtual`. Попытка переопределить член, не являющийся виртуальным, как в следующем примере, вызывает ошибку компилятора CS0506: "\<member> : невозможно переопределить наследуемый член \<member>, так как он не помечен как virtual, abstract или override".

```csharp
public class A
{
    public void Method1()
    {
        // Do something.
    }
}

public class B : A
{
    public override void Method1() // Generates CS0506.
    {
        // Do something else.
    }
}
```

В некоторых случаях производный класс *обязан* переопределять реализацию базового класса. Члены базового класса, отмеченные ключевым словом [abstract](../language-reference/keywords/abstract.md) (абстрактный), обязательно должны переопределяться в производных классах. При попытке компиляции следующего примера возникнет ошибка компилятора CS0534, "&lt;class&gt; не реализует наследуемый абстрактный член &lt;member&gt;", поскольку класс `B` не предоставляет реализации для `A.Method1`.

```csharp
public abstract class A
{
    public abstract void Method1();
}

public class B : A // Generates CS0534.
{
    public void Method3()
    {
        // Do something.
    }
}
```

Наследование применяется только для классов и интерфейсов. Другие категории типов (структуры, делегаты и перечисления) не поддерживают наследование. Из-за этих правил попытка компиляции кода из следующего примера приводит к ошибке компилятора CS0527: "Тип 'ValueType' в списке интерфейсов не является интерфейсом". Такое сообщение об ошибке означает, что наследование не поддерживается, несмотря на возможность определить интерфейсы, реализуемые в структуре.

```csharp
using System;

public struct ValueStructure : ValueType // Generates CS0527.
{
}
```

## <a name="implicit-inheritance"></a>Неявное наследование

Помимо тех типов, которые наследуются через механизм одиночного наследования, все типы в системе типов .NET неявно наследуются от типа <xref:System.Object> или его производного типа. Общие функции <xref:System.Object> доступны любому типу.

Чтобы продемонстрировать неявное наследование, давайте определим новый класс `SimpleClass`, определение которого будет пустым.

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#1)]

После этого с помощью отражения (которое позволяет проверить метаданные типа для получения сведений о нем) мы получим список членов, принадлежащих типу `SimpleClass`. Выходные данные этого примера возвращают нам девять членов класса `SimpleClass`, хотя мы не определяли ни один из них. Один из членов является вызываемым без параметров конструктором по умолчанию, который автоматически предоставляется для типа `SimpleClass` компилятором C#. Остальные восемь являются членами типа <xref:System.Object>, от которого неявным образом наследуются все классы и интерфейсы в системе типов .NET.

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#2)]

Неявное наследование от класса <xref:System.Object> делает доступными для класса `SimpleClass` следующие методы.

- Открытый метод `ToString`, который преобразует объект `SimpleClass` в строковое представление, возвращает полное имя типа. В нашем примере метод `ToString` возвращает строку SimpleClass.

- Три метода, которые проверяют равенство двух объектов: открытый метод экземпляра `Equals(Object)`, открытый статический метод `Equals(Object, Object)` и открытый статический метод `ReferenceEquals(Object, Object)`. По умолчанию эти методы проверяют ссылочное равенство. Это означает, что две переменные, содержащие объекты, должны ссылаться на один и тот же объект, чтобы считаться равными.

- Открытый метод `GetHashCode`, который вычисляет значение, позволяющее использовать экземпляр типа в хэшированных коллекциях.

- Открытый метод `GetType`, который возвращает объект <xref:System.Type>, представляющий тип `SimpleClass`.

- Защищенный метод <xref:System.Object.Finalize%2A>, который должен освобождать неуправляемые ресурсы перед тем, как сборщик мусора освободит память объекта.

- Защищенный метод <xref:System.Object.MemberwiseClone%2A>, который создает неполную копию текущего объекта.

Неявное наследование позволяет вызвать любой наследуемый член объекта `SimpleClass` точно так же, как если бы он был определен в самом классе `SimpleClass`. Например, следующий пример вызывает метод `SimpleClass.ToString`, который `SimpleClass` наследует от <xref:System.Object>.

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass2.cs#1)]

В следующей таблице перечислены категории типов, которые можно создавать на языке C#, и указаны типы, от которых они неявно наследуют. Каждый из базовых типов предоставляет всем типам, которые неявно наследуют от него, разные наборы членов.

| Категория типа | Неявно наследует от                                                      |
| ------------- | ----------------------------------------------------------------------------- |
| class         | <xref:System.Object>                                                          |
| struct        | <xref:System.ValueType>, <xref:System.Object>                                 |
| enum          | <xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object>             |
| delegate      | <xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object> |

## <a name="inheritance-and-an-is-a-relationship"></a>Наследование и связь "является"

Обычно наследование выражает связь вида "is a" (является) между базовым классом и одним или несколькими производными классами. Производные классы рассматриваются как специализированные версии базового класса, то есть как подтипы базового класса. Например класс `Publication` представляет публикации любого рода, а классы `Book` и `Magazine` представляют публикации определенных типов.

> [!NOTE]
> Класс или структура могут реализовывать один или несколько интерфейсов. Реализация интерфейсов часто рассматривается как метод для обхода ограничений одиночного наследования или для реализации наследования структур. Но его основным назначением является выражение связи другого рода между интерфейсом и реализующим его типом. Эта связь называется "can do" (может выполнять) и она отличается от связи наследования. Интерфейс определяет подмножество функций (например, проверка равенства, сравнение и сортировка объектов, или поддержка синтаксического анализа и форматирования с учетом языка и региональных параметров). Интерфейс предоставляет эти функции всем типам, которые его реализуют.

Обратите внимание, что связь "является" выражает также связь между типом и конкретным экземпляром этого типа. В следующем примере представлен класс `Automobile` с тремя уникальными свойствами только для чтения: `Make` определяет производителя автомобиля, `Model` определяет тип автомобиля, а `Year` — год выпуска. Этот класс `Automobile` также содержит конструктор, аргументы которого назначаются значениям свойств. Еще в нем переопределен метод <xref:System.Object.ToString%2A?displayProperty=nameWithType>, который теперь возвращает строку, однозначно определяющую экземпляр `Automobile`, а не класс `Automobile`.

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#1)]

В этом примере не следует использовать наследование для представления определенных производителей и моделей автомобилей. Например, вам не нужно определять тип `Packard`, который будет представлять автомобили, произведенные компанией Packard Motor Car. Для этого представления вы создадите объект `Automobile` и передадите конструктору этого класса соответствующие значения, как показано в следующем примере.

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#2)]

Основанную на наследовании связь "является" лучше всего использовать для базовых классов и производных классов, которые добавляют дополнительные члены или используют дополнительные функции, отсутствующие в базовом классе.

## <a name="designing-the-base-class-and-derived-classes"></a>Разработка базового класса и его производных классов

Давайте рассмотрим процесс создания базового класса и его производных классов. В этом разделе вы определите базовый класс `Publication`, который представляет публикацию любого типа (книга, журнал, газета, статья и т. д.). Также вы определите класс `Book`, который наследует от класса `Publication`. Этот пример легко расширить, определив другие производные классы, например `Magazine`, `Journal`, `Newspaper` и `Article`.

### <a name="the-base-publication-class"></a>Базовый класс Publication

При разработке класса `Publication` нужно принять несколько решений по его структуре.

- Какие члены следует включить в базовый класс `Publication` и будут ли члены `Publication` реализовывать нужные методы? Или же базовый класс `Publication` лучше сделать абстрактным, то есть шаблоном для производных классов?

  В нашем примере класс `Publication` будет предоставлять реализации методов. Раздел [Разработка абстрактных базовых классов и их производных классов](#abstract) содержит пример, в котором абстрактный базовый класс определяет методы, переопределяемые в производных классах. Производные классы могут использовать любую реализацию, применимую для конкретного производного типа.

  Важным преимуществом неабстрактных базовых классов является возможность повторно использовать код (несколько производных классов используют объявления и реализации методов из базового класса, и могут не переопределять их). Таким образом, в `Publication` следует включать такие члены, которые с высокой долей вероятности будут использоваться в неизменном виде несколькими специализированными типами `Publication`. Если вам не удастся эффективно предоставить реализации базового класса, вам придется создавать идентичные реализации членов в производных классах вместо того, чтобы использовать одну реализацию в базовом классе. Необходимость поддерживать несколько копий идентичного кода в нескольких местах станет потенциальным источником ошибок.

  Чтобы оптимизировать повторное использование кода и создать логичную и интуитивно понятную иерархию наследования, необходимо включать в класс `Publication` только такие данные и функции, которые используются для большинства публикаций. Затем в производных классах реализуются уникальные члены для каждого вида публикаций, которые они представляют.

- Насколько глубокой будет иерархия классов? Хотите ли вы включить в иерархию три или больше уровней классов или обойдетесь одним базовым классом с несколькими производными? Например `Publication` может являться базовым классом для `Periodical`, от которого будут наследовать классы `Magazine`, `Journal` и `Newspaper`.

  В вашем примере вы будете использовать небольшую иерархию, состоящую из класса `Publication` и одного производного класса `Book`. Вы можете с легкостью расширить пример, включив несколько дополнительных производных от `Publication`, например `Magazine` и `Article`.

- Нужны ли нам экземпляры базового класса? Если нет, то для этого класса следует указать ключевое слово [abstract](../language-reference/keywords/abstract.md). В противном случае можно будет создать экземпляр класса `Publication`, вызвав конструктор этого класса. При попытке создать экземпляр класса с ключевым словом `abstract` путем прямого вызова конструктора класса компилятор C# возвращает ошибку CS0144: "Не удается создать экземпляр абстрактного класса или интерфейса". Если попытаться создать экземпляр такого класса с помощью отражения, метод отражения создает исключение <xref:System.MemberAccessException>.

  По умолчанию есть возможность создать экземпляр, вызвав конструктор базового класса. Конструктор класса необязательно определять явным образом. Если конструктор отсутствует в исходном коде базового класса, компилятор C# автоматически предоставляет конструктор по умолчанию (без параметров).

  В вашем примере следует обозначить класс `Publication` как [абстрактный](../language-reference/keywords/abstract.md), и для него нельзя будет создавать экземпляры.  Класс `abstract` без методов `abstract` указывает, что этот класс представляет абстрактное понятие, которое является общим для нескольких конкретных классов (таких как `Book`, `Journal`).

- Должны ли производные классы наследовать реализацию членов базового класса? Или же они могут переопределить реализацию базового класса? Или они должны предоставлять реализацию? Используйте ключевое слово [abstract](../language-reference/keywords/abstract.md), чтобы производные классы принудительно предоставляли реализацию. Чтобы производные классы могли переопределять методы базового класса, используйте ключевое слово [virtual](../language-reference/keywords/virtual.md). По умолчанию методы, определенные в базовом классе, переопределять *нельзя*.

  Класс `Publication` не имеет методов `abstract`, но сам класс помечен как `abstract`.

- Будет ли производный класс последним в иерархии наследования (то есть его нельзя будет использовать в качестве базового класса для дополнительных производных классов)? По умолчанию любой класс можно использовать в качестве базового класса. Если указать ключевое слово [sealed](../language-reference/keywords/sealed.md) (запечатан), то класс нельзя будет использовать как базовый класс для дополнительных производных классов. При попытке наследовать запечатанный класс создается ошибка компилятора CS0509: "нельзя наследовать от запечатанного типа \<typeName>".

  В вашем примере обозначьте производный класс как `sealed`.

В следующем примере представлен исходный код для класса `Publication`, а также перечисление `PublicationType`, возвращаемое свойством `Publication.PublicationType`. Помимо элементов, которые он наследует от <xref:System.Object>, класс `Publication` определяет и переопределяет следующие члены.

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#1)]

- Конструктор

  Поскольку класс `Publication` имеет обозначение `abstract`, для него нельзя напрямую создать экземпляр из кода, как в следующем примере:

  ```csharp
  var publication = new Publication("Tiddlywinks for Experts", "Fun and Games",
                                    PublicationType.Book);
  ```

  Но при этом его конструктор для создания экземпляров можно напрямую вызвать из конструкторов производных классов, как показано в исходном коде для класса `Book`.

- Два свойства, относящиеся к публикации

  Свойство `Title` доступно только для чтения и имеет тип <xref:System.String>. Его значение предоставляется путем вызова конструктора `Publication`.

  Свойство `Pages` доступно для чтения и записи и имеет тип <xref:System.Int32>. Значение этого свойства показывает, сколько всего страниц имеет эта публикация. Это значение хранится в скрытом поле с именем `totalPages`. В качестве значения принимается положительное число. В противном случае создается исключение <xref:System.ArgumentOutOfRangeException>.

- Члены, связанные с издателем

  Два свойства только для чтения: `Publisher` и `Type`. Эти значения изначально предоставляются путем вызова конструктора класса `Publication`.

- Элементы, связанные с публикацией

  Два метода, `Publish` и `GetPublicationDate`, которые устанавливают и возвращают дату публикации. Метод `Publish` устанавливает закрытый флаг `published` в значение `true` и присваивает переданную ему дату в качестве аргумента для закрытого поля `datePublished`. Метод `GetPublicationDate` возвращает строку "NYP", если флаг `published` имеет значение `false`, или значение поля `datePublished`, если флаг имеет значение `true`.

- Члены, связанные с авторскими правами

  Метод `Copyright` принимает в качестве аргументов имя владельца авторских прав и год создания авторских прав, и назначает их свойствам `CopyrightName` и `CopyrightDate`.

- Переопределение метода `ToString`

  Если метод <xref:System.Object.ToString%2A?displayProperty=nameWithType> не переопределяется в типе, он возвращает полное имя типа, которое не позволяет отличать экземпляры друг от друга. Класс `Publication` переопределяет метод <xref:System.Object.ToString%2A?displayProperty=nameWithType>, чтобы он возвращал значение свойства `Title`.

Следующий рисунок иллюстрирует связь между базовым классом `Publication` и неявно унаследованным от него классом <xref:System.Object>.

![Классы Object и Publication](media/publication-class.jpg)

### <a name="the-book-class"></a>Класс `Book`

Класс `Book` представляет книгу как специализированный тип публикации. В следующем примере показан исходный код класса `Book`.

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#2)]

Помимо элементов, которые он наследует от `Publication`, класс `Book` определяет и переопределяет следующие члены.

- Два конструктора

  Два конструктора `Book` используют три общих параметра. Два из них, *header* и *publisher*, соответствуют параметрам конструктора `Publication`. Третий — это *author*, который хранится в общедоступном неизменяемом свойстве `Author`. Один конструктор использует параметр *isbn*, который хранится в автосвойстве `ISBN`.

  Первый конструктор использует ключевое слово [this](../language-reference/keywords/this.md) для вызова второго конструктора. Создание цепочки конструкторов — это обычный метод определения конструкторов. Конструкторы с меньшим числом параметров используют значения по умолчанию, вызывая конструкторы с большим числом параметров.

  Второй конструктор использует ключевое слово [base](../language-reference/keywords/base.md), чтобы передать заголовок и имя издателя в конструктор базового класса. Если вы не используете явный вызов конструктора базового класса в исходном коде, компилятор C# автоматически добавляет вызов конструктора по умолчанию (без параметров) для базового класса.

- Свойство `ISBN`, доступное только для чтения, которое возвращает международный стандартный номер книги (уникальное 10- или 13-значное число) для объекта `Book`. Номер ISBN передается в качестве аргумента одному из конструкторов `Book`. Он сохраняется в закрытом резервном поле, автоматически создаваемым компилятором.

- Свойство `Author`, доступное только для чтения. Имя автора передается в качестве аргумента обоим конструкторам `Book` и сохраняется в свойстве.

- Два свойства, `Price` и `Currency`, с информацией о цене, доступные только для чтения. Значения этих свойств передаются в качестве аргументов при вызове метода `SetPrice`. Свойство `Currency` содержит трехзначное обозначение валюты по стандарту ISO (например, USD обозначает доллар США). Обозначение валюты по стандарту ISO можно получить из свойства <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A>. Оба эти свойства доступны для чтения извне, но их можно задать в коде в классе `Book`.

- Метод `SetPrice`, который задает значения для свойств `Price` и `Currency`. Эти значения возвращаются теми же свойствами.

- Переопределение метода `ToString`, унаследованного от `Publication`, а также методов <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> и <xref:System.Object.GetHashCode%2A>, унаследованных от <xref:System.Object>.

  Если метод <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> не переопределен, он проверяет ссылочное равенство. Это означает, что две объектные переменные считаются равными, если ссылаются на один и тот же объект. С другой стороны, в классе `Book` два объекта `Book` должны считаться равными, если они имеют одинаковые номера ISBN.

  Переопределив метод <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, необходимо также переопределить метод <xref:System.Object.GetHashCode%2A>, который возвращает значение, используемое средой выполнения для хранения элементов в хэшированных коллекциях для быстрого извлечения. Возвращаемое значение хэш-кода должно согласовываться с проверкой на равенство. Поскольку теперь новый метод <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> возвращает `true`, если у двух объектов `Book` равны свойства ISBN, при расчете хэш-кода вы будете вызывать метод <xref:System.String.GetHashCode%2A> для строки, полученной из свойства `ISBN`.

Следующий рисунок иллюстрирует связь между классом `Book` и классом `Publication`, который является для него базовым.

![Классы Publication и Book](media/book-class.jpg)

Теперь вы можете создавать экземпляры объекта `Book`, вызывать его уникальные и унаследованные члены, а также передавать его в качестве аргумента в любой метод, принимающий параметры типа `Publication` или `Book`, как показано в следующем примере.

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/use-publication.cs#1)]

## <a name="designing-abstract-base-classes-and-their-derived-classes"></a>Разработка абстрактных базовых классов и их производных классов
<a name="abstract"></a>

В предыдущем примере вы определили базовый класс, который предоставляет реализацию нескольких методов, обеспечивая совместное использование кода в производных классах. Но во многих случаях базовый класс не должен предоставлять реализацию. Такой базовый класс будет являться *абстрактным классом*, который объявляет *абстрактные методы*. Он выступает в качестве шаблона и определяет члены, которые каждый производный класс должен реализовывать самостоятельно. При использовании абстрактного базового класса реализация каждого из производных типов обычно уникальна для конкретного типа. Вы отметили класс ключевым словом abstract, так как не имело смысла создавать экземпляр объекта `Publication`, хотя класс предоставлял реализации функций, общих для публикаций.

Например, каждая замкнутая геометрическая фигура в двумерном пространстве имеет два свойства: площадь внутренней поверхности и длину ее границ (периметр). Но при этом методы вычисления этих свойств полностью зависят от конкретной фигуры. Например, формула вычисления периметра (длины окружности) для круга отличается от формулы для треугольника. Класс `Shape` является классом `abstract` с методами `abstract`. Это означает, что производные классы имеют одинаковые функции, но эти производные классы иначе реализуют эти функции.

Следующий пример определяет абстрактный базовый класс с именем `Shape` и два его свойства: `Area` и `Perimeter`. Ключевым словом [abstract](../language-reference/keywords/abstract.md) помечается не только сам класс. Каждый член экземпляра также получает метку [abstract](../language-reference/keywords/abstract.md). Кроме того, в классе `Shape` мы снова переопределяем метод <xref:System.Object.ToString%2A?displayProperty=nameWithType>, чтобы он возвращал имя типа, а не полное имя типа. Еще мы определяем два статических члена `GetArea` и `GetPerimeter`, которые позволяют вызывающим объектам легко получить площадь и периметр для конкретного экземпляра любого производного класса. Когда вы передаете в любой из этих методов экземпляр производного класса, среда выполнения вызывает переопределенные методы из соответствующего производного класса.

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#1)]

Теперь вы можете создать несколько классов, производных от `Shape`, которые будут представлять разные геометрические фигуры. В следующем примере определяются три класса: `Triangle`, `Rectangle` и `Circle`. В каждом из них используются уникальные формулы для вычисления площади и периметра, соответствующие типу фигуры. Также некоторые из производных классов определяют дополнительные свойства, например `Rectangle.Diagonal` и `Circle.Diameter`, которые уникальны для фигуры, представляемой этим классом.

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#2)]

Следующий пример использует объекты, производные от `Shape`. Он создает массив объектов, производных от `Shape`, и вызывает статические методы для класса `Shape`, которые служат оболочкой для обращения к значениям свойств `Shape`. Среда выполнения извлекает значения переопределенных свойств для производных типов. Также в этом примере каждый объект `Shape` из созданного массива приводится к производному типу. Если это приведение выполняется успешно, выполняется обращение к свойствам, определенным для конкретного подкласса базового класса `Shape`.

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#3)]

## <a name="see-also"></a>См. также

- [Классы и объекты](../tour-of-csharp/classes-and-objects.md)
- [Наследование (руководство по программированию на C#)](../programming-guide/classes-and-structs/inheritance.md)
