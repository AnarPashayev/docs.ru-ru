---
title: Общие сведения о событиях
description: Сведения о событиях в .NET Core и наших задачах по разработке языка для них.
ms.date: 06/20/2016
ms.assetid: 9b8d2a00-1584-4a5b-8994-5003d54d8e0c
ms.openlocfilehash: e2944100d648d90e7aa5ea5798a351b8fd382cf7
ms.sourcegitcommit: 7e129d879ddb42a8b4334eee35727afe3d437952
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/23/2019
ms.locfileid: "66051941"
---
# <a name="introduction-to-events"></a>Общие сведения о событиях

[Назад](delegates-patterns.md)

События, так же как и делегаты, представляют собой механизм *позднего связывания*. На самом деле события основаны на тех же средствах языка, которые обеспечивают поддержку делегатов.

С помощью событий объект может сообщить всем компонентам системы, которым это необходимо, о том, что что-то произошло. Любой другой компонент может подписаться на событие, чтобы получать уведомления о его наступлении.

Возможно, вы уже пользовались событиями при программировании. Во многих графических системах есть модель событий, которая позволяет сообщать о действиях пользователей. Такие события сообщают о перемещениях мыши, нажатиях кнопок и иных подобных действиях. Это наиболее распространенный, но, безусловно, не единственный вариант использования событий.

Вы можете определить события, которые должны вызываться для классов. Важным моментом при работе с событиями является то, что для определенного события не может быть зарегистрирован объект. Код необходимо писать так, чтобы он не вызывал событий, если прослушиватели не настроены.

При подписке на событие также создается взаимосвязь между двумя объектами (источником события и приемником событий). Если приемник событий больше не должен получать события, необходимо отменить его подписку на источник события.

## <a name="design-goals-for-event-support"></a>Цели при проектировании поддержки событий

Ниже перечислены цели модели событий, реализуемой в языке.

Во-первых, между источником события и приемником событий должна быть минимальная взаимосвязь. Эти два компонента могут создаваться разными организациями и даже обновляться по совершенно разным графикам.

Во-вторых, подписка на событие и отмена подписки на него должны производиться максимально просто.

Наконец, источники событий должны поддерживать несколько подписчиков на события. Кроме того, должен поддерживаться сценарий, когда подписчики на события не подключены.

Как можно увидеть, цели в отношении событий очень похожи на цели в отношении делегатов.
Вот почему языковая поддержка событий основана на механизмах поддержки делегатов.

## <a name="language-support-for-events"></a>Языковая поддержка событий

Синтаксис определения событий, а также подписки и отмены подписки на них является расширением синтаксиса для делегатов.

Для определения события используется ключевое слово `event`.

```csharp
public event EventHandler<FileListArgs> Progress;
```

Тип события (в этом примере `EventHandler<FileListArgs>`) должен быть типом делегата. При объявлении события должен соблюдаться ряд соглашений. Как правило, тип делегата события имеет возвращаемый тип void.
Объявление события должно представлять собой глагол или глагольное словосочетание.
Если событие сообщает о том, что уже произошло, используйте прошедшее время (как в этом примере). Для сообщения о том, что должно произойти, используйте глагол в настоящем времени (например, `Closing`). Настоящее время часто указывает на то, что класс поддерживает какую-либо настройку. Одна из самых распространенных ситуаций — поддержка отмены. Например, событие `Closing` может иметь аргумент, который указывает на то, должна ли продолжаться операция закрытия.  В других ситуациях вызывающим объектам может предоставляться возможность изменения поведения путем изменения свойств аргументов события. Событие может вызываться для указания действия, которое алгоритму предлагается выполнить в следующую очередь. Обработчик событий может предписать выполнение другого действия, изменив свойства аргумента события.

Если нужно инициировать событие, то следует вызвать соответствующий обработчик событий с помощью синтаксиса вызова делегатов:

```csharp
Progress?.Invoke(this, new FileListArgs(file));
```

Как описано в разделе, посвященном [делегатам](delegates-patterns.md), оператор ?.
позволяет легко предотвратить попытки вызова события, если на него нет подписчиков.
 
Подписка на событие производится с помощью оператора `+=`:

```csharp
EventHandler<FileListArgs> onProgress = (sender, eventArgs) => 
    Console.WriteLine(eventArgs.FoundFile);

fileLister.Progress += onProgress;
```

Имя метода обработчика обычно содержит имя события с префиксом "On", как показано выше.

Для отмены подписки на событие служит оператор `-=`:

```csharp
fileLister.Progress -= onProgress;
```

Важно отметить, что для выражения, представляющего обработчик событий, была объявлена локальная переменная. Благодаря этому при отмене подписки обработчик удаляется.
Если вместо этого использовалось тело лямбда-выражения, то производится попытка удалить обработчик, который не был подключен, что не приводит ни к какому результату.

В следующей статье вы узнаете больше о типичных шаблонах событий и ознакомитесь с вариантами этого примера.

[Вперед](event-pattern.md)
