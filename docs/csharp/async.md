---
title: Асинхронное программирование на C#
description: Сведения о модели асинхронного программирования на уровне языка C#, которая реализуется в .NET Core.
author: cartermp
ms.date: 06/20/2016
ms.technology: csharp-async
ms.assetid: b878c34c-a78f-419e-a594-a2b44fa521a4
ms.openlocfilehash: 38d7c856e9a536db9ef26349175ad440a49f5fe2
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "75713953"
---
# <a name="asynchronous-programming"></a>Асинхронное программирование

Для решения задач, связанных с вводом-выводом (например, для запроса данных из сети или доступа к базе данных), желательно использовать асинхронное программирование.  Если у вас есть код, ограниченный ресурсами процессора, например выполняющий сложные вычисления, то это также подходящий сценарий для асинхронного программирования.

В C# имеется модель асинхронного программирования, реализованная на уровне языка, которая позволяет легко писать асинхронный код, не прибегая к обратным вызовам или библиотекам, которые поддерживают асинхронность. Она строится на принципах [асинхронной модели на основе задач (TAP)](../standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).

## <a name="basic-overview-of-the-asynchronous-model"></a>Общий обзор асинхронной модели

В основе асинхронного программирования лежат объекты `Task` и `Task<T>`, которые моделируют асинхронные операции.  Они поддерживаются ключевыми словами `async` и `await`.  В большинстве случаев модель достаточно проста.

Для кода, ограниченного производительностью ввода-вывода, с помощью `await` выполняется операция, которая возвращает объект `Task` или `Task<T>` внутри метода `async`.

Для кода, ограниченного ресурсами процессора, с помощью `await` выполняется операция, которая запускается в фоновом потоке методом `Task.Run`.

Именно с помощью ключевого слова `await` творится вся магия. Оно передает управление вызывающему объекту метода, который выполнил `await`, позволяя, таким образом, пользовательскому интерфейсу или службе отвечать на запросы.

Есть и другие подходы к написанию асинхронного кода без использования ключевых слов `async` и `await`. Их описание можно найти в приведенной выше статье, посвященной TAP. Однако далее в этом документе будут рассматриваться конструкции на уровне языка.

### <a name="io-bound-example-downloading-data-from-a-web-service"></a>Пример с ограниченной производительностью ввода-вывода: скачивание данных из веб-службы

При нажатии кнопки может требоваться скачать некоторые данные из веб-службы, не блокируя поток пользовательского интерфейса. Это можно сделать очень просто:

```csharp
private readonly HttpClient _httpClient = new HttpClient();

downloadButton.Clicked += async (o, e) =>
{
    // This line will yield control to the UI as the request
    // from the web service is happening.
    //
    // The UI thread is now free to perform other work.
    var stringData = await _httpClient.GetStringAsync(URL);
    DoSomethingWithData(stringData);
};
```

Вот и все! В коде выражается намерение (скачивание некоторых данных в асинхронном режиме), и при этом не приходится выполнять запутанные операции с объектами Task.

### <a name="cpu-bound-example-performing-a-calculation-for-a-game"></a>Пример с ограниченными ресурсами процессора: выполнение вычислений для игры

Предположим, вы разрабатываете игру для мобильных устройств, в которой при нажатии кнопки может наноситься урон множеству противников на экране.  Расчет урона может потреблять много ресурсов. Если производить его в потоке пользовательского интерфейса, то на это время игра может приостанавливаться!

Оптимальный способ — запустить фоновый поток, который выполняет задачу с помощью `Task.Run`, а затем ожидает результат с помощью `await`.  Таким образом обеспечится плавная работа пользовательского интерфейса в процессе вычисления.

```csharp
private DamageResult CalculateDamageDone()
{
    // Code omitted:
    //
    // Does an expensive calculation and returns
    // the result of that calculation.
}

calculateButton.Clicked += async (o, e) =>
{
    // This line will yield control to the UI while CalculateDamageDone()
    // performs its work.  The UI thread is free to perform other work.
    var damageResult = await Task.Run(() => CalculateDamageDone());
    DisplayDamage(damageResult);
};
```

Вот и все!  В этом коде четко выражается назначение события нажатия кнопки, фоновым потоком не требуется управлять вручную, и он выполняется без блокировки.

### <a name="what-happens-under-the-covers"></a>Что происходит на внутреннем уровне

Выполнение асинхронных операций связано со множеством элементов.  Если вы хотите знать внутренние принципы работы объектов `Task` и `Task<T>`, обратитесь за дополнительными сведениями к статье [Подробный обзор асинхронного программирования](../standard/async-in-depth.md).

С точки зрения C#, компилятор преобразовывает код в конечный автомат, который контролирует такие моменты, как передача выполнения при достижении `await` и возобновление выполнения после завершения фонового задания.

Если вас интересует теория, это реализация [модели асинхронности на основе обещаний](https://en.wikipedia.org/wiki/Futures_and_promises).

## <a name="key-pieces-to-understand"></a>Ключевые моменты для понимания

* Асинхронный код можно использовать как при ограниченной производительности ввода-вывода, так и при ограниченных ресурсах процессора, но по-разному в каждом случае.
* В асинхронном коде используются конструкции `Task<T>` и `Task`, которые служат для моделирования задач, выполняемых в фоновом режиме.
* Ключевое слово `async` делает метод асинхронным, что позволяет использовать в его теле ключевое слово `await`.
* Когда применяется ключевое слово `await`, оно приостанавливает выполнение вызывающего метода и передает управление обратно вызывающему объекту, пока не будет завершена ожидаемая задача.
* `await` можно использовать только внутри асинхронного метода.

## <a name="recognize-cpu-bound-and-io-bound-work"></a>Определение задач, ограниченных ресурсами процессора и производительностью ввода-вывода

В первых двух примерах этого руководства было показано, как можно использовать `async` и `await` для выполнения задач, ограниченных производительностью ввода-вывода и ресурсами процессора.  Крайне важно уметь идентифицировать такие задачи, так как они могут существенно повлиять на производительность кода и привести к неправильному использованию некоторых конструкций.

Перед написанием любого кода нужно ответить на два вопроса.

1. Будет ли код "ожидать" чего-либо, например данных из базы данных?

    Если ответ утвердительный, то ваша задача **ограничена производительностью ввода-вывода**.

2. Будет ли код выполнять очень сложные вычисления?

    Если ответ утвердительный, то задача **ограничена ресурсами процессора**.

Если ваша задача **ограничена производительностью ввода-вывода**, используйте `async` и `await` *без* `Task.Run`.  Библиотеку параллельных задач использовать *не следует*.  Причина этого указана в статье [Подробный обзор асинхронного программирования](../standard/async-in-depth.md).

Если ваша задача **ограничена ресурсами процессора** и вам важна скорость реагирования, используйте `async` и `await`, но перенесите выполнение задачи в другой поток *с* `Task.Run`.  Если к задаче применим параллелизм, также следует рассмотреть возможность использования [библиотеки параллельных задач](../standard/parallel-programming/task-parallel-library-tpl.md).

Кроме того, всегда следует оценивать выполнение кода.  Например, затраты на выполнение задачи, ограниченной ресурсами процессора, могут оказаться не столь высокими, как накладные расходы, связанные с переключениями контекста при многопоточности.  Каждый вариант имеет свои недостатки, поэтому следует выбрать наиболее компромиссный вариант в вашей ситуации.

## <a name="more-examples"></a>Дополнительные примеры

В приведенных ниже примерах демонстрируются различные способы написания асинхронного кода на C#.  Они охватывают несколько сценариев, с которыми вы можете столкнуться.

### <a name="extracting-data-from-a-network"></a>Извлечение данных из сети

Этот фрагмент кода скачивает код HTML с главной страницы [сайта www.dotnetfoundation.org](https://www.dotnetfoundation.org) и подсчитывает число вхождений в него строки ".NET".  С помощью ASP.NET MVC определяется метод веб-контроллера, который выполняет эту задачу, и возвращается число.

> [!NOTE]
> Если вы планируете проанализировать HTML в рабочем коде, не используйте регулярные выражения. Используйте библиотеку анализа.

```csharp
private readonly HttpClient _httpClient = new HttpClient();

[HttpGet]
[Route("DotNetCount")]
public async Task<int> GetDotNetCountAsync()
{
    // Suspends GetDotNetCountAsync() to allow the caller (the web server)
    // to accept another request, rather than blocking on this one.
    var html = await _httpClient.GetStringAsync("https://dotnetfoundation.org");

    return Regex.Matches(html, @"\.NET").Count;
}
```

Вот аналогичный код для универсального приложения для Windows, который выполняет ту же задачу при нажатии кнопки:

```csharp
private readonly HttpClient _httpClient = new HttpClient();

private async void SeeTheDotNets_Click(object sender, RoutedEventArgs e)
{
    // Capture the task handle here so we can await the background task later.
    var getDotNetFoundationHtmlTask = _httpClient.GetStringAsync("https://www.dotnetfoundation.org");

    // Any other work on the UI thread can be done here, such as enabling a Progress Bar.
    // This is important to do here, before the "await" call, so that the user
    // sees the progress bar before execution of this method is yielded.
    NetworkProgressBar.IsEnabled = true;
    NetworkProgressBar.Visibility = Visibility.Visible;

    // The await operator suspends SeeTheDotNets_Click, returning control to its caller.
    // This is what allows the app to be responsive and not block the UI thread.
    var html = await getDotNetFoundationHtmlTask;
    int count = Regex.Matches(html, @"\.NET").Count;

    DotNetCountLabel.Text = $"Number of .NETs on dotnetfoundation.org: {count}";

    NetworkProgressBar.IsEnabled = false;
    NetworkProgressBar.Visibility = Visibility.Collapsed;
}
```

### <a name="waiting-for-multiple-tasks-to-complete"></a>Ожидание выполнения нескольких задач

Может возникнуть ситуация, когда несколько фрагментов данных должны извлекаться одновременно.  Интерфейс API `Task` содержит два метода, `Task.WhenAll` и `Task.WhenAny`, которые позволяют писать асинхронный код, выполняющий неблокирующее ожидание для нескольких фоновых заданий.

В этом примере показано, как можно получить данные `User` для набора `userId`.

```csharp
public async Task<User> GetUserAsync(int userId)
{
    // Code omitted:
    //
    // Given a user Id {userId}, retrieves a User object corresponding
    // to the entry in the database with {userId} as its Id.
}

public static async Task<IEnumerable<User>> GetUsersAsync(IEnumerable<int> userIds)
{
    var getUserTasks = new List<Task<User>>();

    foreach (int userId in userIds)
    {
        getUserTasks.Add(GetUserAsync(userId));
    }

    return await Task.WhenAll(getUserTasks);
}
```

Вот более лаконичный вариант этого кода, написанный с использованием LINQ:

```csharp
public async Task<User> GetUserAsync(int userId)
{
    // Code omitted:
    //
    // Given a user Id {userId}, retrieves a User object corresponding
    // to the entry in the database with {userId} as its Id.
}

public static async Task<User[]> GetUsersAsync(IEnumerable<int> userIds)
{
    var getUserTasks = userIds.Select(id => GetUserAsync(id));
    return await Task.WhenAll(getUserTasks);
}
```

Хотя размер кода меньше, будьте осторожны при использовании LINQ в сочетании с асинхронным кодом.  Так как в LINQ используется отложенное выполнение, асинхронные вызовы будут выполняться не немедленно, как в цикле `foreach()`, если только вы не производите принудительную итерацию созданной последовательности с помощью вызова `.ToList()` или `.ToArray()`.

## <a name="important-info-and-advice"></a>Важные сведения и советы

Хотя принципы асинхронного программирования сравнительно просты, необходимо учитывать ряд моментов, чтобы избежать непредвиденных результатов.

* `async`В методах  **должно присутствовать ключевое слово** `await` **. В противном случае результат не будет получен.**

Это важно помнить.  Если ключевое слово `await` не используется в теле метода `async`, компилятор C# выдаст предупреждение, но код скомпилируется и будет выполняться, как обычный метод.  Обратите также внимание на то, что это очень неэффективно, так как конечный автомат, созданный компилятором C# для асинхронного метода, не будет выполнять никакой работы.

* **К имени каждого создаваемого асинхронного метода следует добавлять суффикс Async.**

Это соглашение применяется в .NET для различения синхронных и асинхронных методов. Обратите внимание, что это необязательно для некоторых методов, которые не вызываются в вашем коде явным образом (например, для обработчиков событий или методов веб-контроллеров). Так как они не вызываются в коде явно, требования к их именованию не так строги.

* `async void` **следует использовать только для обработчиков событий.**

`async void` — это единственный способ обеспечить работу асинхронных обработчиков событий, так как у событий нет типов возвращаемых значений (поэтому они не могут использовать `Task` и `Task<T>`). Любые иные способы применения `async void` не предусмотрены моделью TAP и могут создавать указанные ниже проблемы.

* Исключения, вызываемые в методе `async void`, невозможно перехватывать вне этого метода.
* Методы `async void` очень трудно тестировать.
* Методы `async void` могут иметь негативные побочные эффекты, если вызывающий объект не предполагает, что они являются асинхронными.

* **Будьте осторожны при использовании асинхронных лямбда-выражений в выражениях LINQ**

Для лямбда-выражений в LINQ применяется отложенное выполнение. Это означает, что код может прекратить выполнение в тот момент, когда вы этого не ожидаете. Неправильное использование блокирующих задач при этом может привести к взаимоблокировке. Кроме того, вложение такого асинхронного кода может усложнить анализ выполнения кода. Асинхронное выполнение и LINQ — эффективные средства, но использовать их следует с максимальной осторожностью и ясным пониманием того, что вы делаете.

* **При написании кода ожидание задач следует реализовывать без блокирования**

Блокирование текущего потока в целях ожидания завершения задачи может привести к взаимоблокировкам и блокированию потоков контекста, из-за чего может требоваться значительно более сложная обработка ошибок. В приведенной ниже таблице даются рекомендации по реализации ожидания задач без блокировки.

| Рекомендуемый способ | Нерекомендуемый способ | Задача |
| --- | --- | --- |
| `await` | `Task.Wait` или `Task.Result` | Получение результата фоновой задачи |
| `await Task.WhenAny` | `Task.WaitAny` | Ожидание завершения выполнения любой задачи |
| `await Task.WhenAll` | `Task.WaitAll` | Ожидание завершения выполнения всех задач |
| `await Task.Delay` | `Thread.Sleep` | Ожидание в течение заданного времени |

* **Пишите код с менее строгим отслеживанием состояния**

Старайтесь, чтобы выполнение кода не зависело от состояния глобальных объектов или выполнения определенных методов. Оно должно зависеть только от возвращаемых методами значений. Почему?

* Код будет проще анализировать.
* Код будет проще тестировать.
* Гораздо проще будет сочетать асинхронный и синхронный код.
* Как правило, можно полностью избежать состояний гонки.
* Зависимость от возвращаемых значений упрощает согласование асинхронного кода.
* Дополнительным преимуществом является то, что такой код хорошо работает с внедрением зависимостей.

Следует стремиться к достижению полной или почти полной [ссылочной прозрачности](https://en.wikipedia.org/wiki/Referential_transparency_%28computer_science%29) в коде. Результатом будет высокий уровень предсказуемости базы кода, а также ее пригодности для тестирования и обслуживания.

## <a name="other-resources"></a>Другие ресурсы

* В статье [Подробный обзор асинхронного программирования](../standard/async-in-depth.md) приводятся дополнительные сведения о принципах работы задач.
* [Асинхронное программирование с использованием ключевых слов Async и Await (C#)](./programming-guide/concepts/async/index.md)
* Эпизод [Six Essential Tips for Async](https://channel9.msdn.com/Series/Three-Essential-Tips-for-Async) (Шесть важных советов по асинхронному программированию) с Лусианом Вышиком (Lucian Wischik) — это отличный ресурс по асинхронному программированию.
