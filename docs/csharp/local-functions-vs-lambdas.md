---
title: Локальные функции или лямбда-выражения
description: Узнайте, чем локальные функции могут быть лучше лямбда-выражений.
ms.date: 06/27/2016
ms.technology: csharp-advanced-concepts
ms.assetid: 368d1752-3659-489a-97b4-f15d87e49ae3
ms.openlocfilehash: 13cc3fe47bbcd6a465347a6c991b2006586c78fa
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "79173345"
---
# <a name="local-functions-compared-to-lambda-expressions"></a>Сравнение локальных функций и лямбда-выражений

На первый взгляд [локальные функции](programming-guide/classes-and-structs/local-functions.md) и [лямбда-выражения](./programming-guide/statements-expressions-operators/lambda-expressions.md) во многом похожи. Во многих случаях выбор между использованием лямбда-выражений и локальных функций определяется стилем и личными предпочтениями. Однако существуют реальные различия в использовании этих сущностей, о которых нужно знать.

Рассмотрим различия в реализации алгоритма вычисления факториала с использованием локальной функции и лямбда-выражения. В первой версии используется локальная функция:

[!code-csharp[LocalFunctionFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

Сравните эту реализацию с версией, в которой используются лямбда-выражения:

[!code-csharp[26_LambdaFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

Локальные функции имеют имена. Лямбда-выражения — это анонимные методы, назначаемые переменным типов `Func` или `Action`. При объявлении локальной функции типы аргументов и тип возвращаемого значения являются частью объявления функции. Типы аргументов и тип возвращаемого значения не являются частью основной части лямбда-выражения — это часть объявления типа переменной лямбда-выражения. Знание этих двух различий поможет в создании более понятного кода.

Правила определенного назначения у локальных функций и лямбда-выражений различаются. На объявление локальной функции можно сослаться из любого расположения кода, находящегося в области охвата. Прежде чем к лямбда-выражению можно будет осуществлять доступ, необходимо присвоить его переменной-делегату (или вызвать через делегат, ссылающийся на лямбда-выражение). Обратите внимание на то, что версия с использованием лямбда-выражения должна объявить и инициализировать лямбда-выражение `nthFactorial`, прежде чем его определить. В противном случае возникает ошибка компилятора, связанная со ссылкой на объект `nthFactorial`, который еще не был назначен.
Эти различия означают, что рекурсивные алгоритмы легче создавать, используя локальные функции. Можно объявить и определить локальную функцию, которая вызывает саму себя. Необходимо объявить лямбда-выражения и назначить им значение по умолчанию, прежде чем их можно будет переназначить телу, которое ссылается на то же лямбда-выражение.

Правила определенного назначения также влияют на любые переменные, собранные локальной функцией или лямбда-выражением. Локальные функции и правила лямбда-выражений требуют, чтобы любые захваченные переменные были определенно назначены в точке, где локальная функция или лямбда-выражение преобразуется в делегат. Разница в том, что лямбда-выражения преобразуются в делегаты при объявлении. Локальные функции преобразуются в делегаты только при использовании в качестве делегата. Если объявить локальную функцию и сослаться на нее только путем вызова этой функции в качестве метода, она не будет преобразована в делегат. Это правило позволяет объявлять локальную функцию в любом удобном расположении во включающей его области. Обычно локальные функции объявляют в конце родительского метода, после всех операторов return.

В-третьих, компилятор может выполнять статический анализ, что позволяет локальным функциям определенно назначать захваченные переменные во включающей области. Рассмотрим следующий пример.

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

Компилятор может определить, что `LocalFunction` определенно назначает `y` при вызове. Поскольку `LocalFunction` вызывается перед оператором `return`, `y` определенно назначается в операторе `return`.

Анализ, позволяющий выполнить анализ примера, также иллюстрирует четвертое различие.
В зависимости от использования при работе с локальными функциями можно избежать распределения куч, которое всегда необходимо выполнять при работе с лямбда-выражениями. Если локальная функция никогда не преобразуется в делегат и ни одна из переменных, захваченных локальной функцией, не захвачена другими лямбда-выражениями или локальными функциями, которые преобразуются в делегаты, компилятор может избежать распределения куч.

Рассмотрим следующий асинхронный пример:

[!code-csharp[TaskLambdaExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

Замыкание для этого лямбда-выражения содержит переменные `address`, `index` и `name`. При использовании локальных функций объект, который реализует замыкание, может иметь тип `struct`. Этот тип структуры будет передан в локальную функцию посредством ссылки. Эта разница в реализации позволяет избежать распределения.

Создание экземпляра, необходимое для лямбда-выражений, означает выделение дополнительной памяти, что в критически важном коде может ухудшить производительность.
Локальные функции не создают этой перегрузки. В приведенном выше примере в версии с локальной функцией используется на 2 меньше операции выделения памяти по сравнению с версией на основе лямбда-выражения.

> [!NOTE]
> В эквивалентном этому методе на основе локальной функции также используется класс для замыкания. Реализация замыкания для локальной функции в формате `class` или `struct` зависит от особенностей реализации. Локальная функция может использовать `struct`, тогда как в лямбда-выражениях всегда используется `class`.

[!code-csharp[TaskLocalFunctionExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#TaskExample "Task returning method with local function")]

Еще одно преимущество локальных функций, которое не показано в этом примере, заключается в том, что они могут быть реализованы в качестве итераторов с использованием синтаксиса `yield return` для создания последовательности значений. В лямбда-выражениях не допускается использование оператора `yield return`.

Локальные функции могут показаться избыточными для лямбда-выражений, поскольку обычно применяются иначе и в других целях.
Локальные функции более эффективны в случаях, когда вам нужно написать функцию, которая будет вызываться только из контекста другого метода.
