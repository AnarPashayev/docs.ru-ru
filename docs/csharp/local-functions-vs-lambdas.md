---
title: Локальные функции или лямбда-выражения
description: Узнайте, чем локальные функции могут быть лучше лямбда-выражений.
ms.date: 06/27/2016
ms.technology: csharp-advanced-concepts
ms.assetid: 368d1752-3659-489a-97b4-f15d87e49ae3
ms.openlocfilehash: 13cc3fe47bbcd6a465347a6c991b2006586c78fa
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "79173345"
---
# <a name="local-functions-compared-to-lambda-expressions"></a><span data-ttu-id="0d607-103">Сравнение локальных функций и лямбда-выражений</span><span class="sxs-lookup"><span data-stu-id="0d607-103">Local functions compared to lambda expressions</span></span>

<span data-ttu-id="0d607-104">На первый взгляд [локальные функции](programming-guide/classes-and-structs/local-functions.md) и [лямбда-выражения](./programming-guide/statements-expressions-operators/lambda-expressions.md) во многом похожи.</span><span class="sxs-lookup"><span data-stu-id="0d607-104">At first glance, [local functions](programming-guide/classes-and-structs/local-functions.md) and [lambda expressions](./programming-guide/statements-expressions-operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="0d607-105">Во многих случаях выбор между использованием лямбда-выражений и локальных функций определяется стилем и личными предпочтениями.</span><span class="sxs-lookup"><span data-stu-id="0d607-105">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="0d607-106">Однако существуют реальные различия в использовании этих сущностей, о которых нужно знать.</span><span class="sxs-lookup"><span data-stu-id="0d607-106">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="0d607-107">Рассмотрим различия в реализации алгоритма вычисления факториала с использованием локальной функции и лямбда-выражения.</span><span class="sxs-lookup"><span data-stu-id="0d607-107">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="0d607-108">В первой версии используется локальная функция:</span><span class="sxs-lookup"><span data-stu-id="0d607-108">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="0d607-109">Сравните эту реализацию с версией, в которой используются лямбда-выражения:</span><span class="sxs-lookup"><span data-stu-id="0d607-109">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="0d607-110">Локальные функции имеют имена.</span><span class="sxs-lookup"><span data-stu-id="0d607-110">The local functions have names.</span></span> <span data-ttu-id="0d607-111">Лямбда-выражения — это анонимные методы, назначаемые переменным типов `Func` или `Action`.</span><span class="sxs-lookup"><span data-stu-id="0d607-111">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="0d607-112">При объявлении локальной функции типы аргументов и тип возвращаемого значения являются частью объявления функции.</span><span class="sxs-lookup"><span data-stu-id="0d607-112">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="0d607-113">Типы аргументов и тип возвращаемого значения не являются частью основной части лямбда-выражения — это часть объявления типа переменной лямбда-выражения.</span><span class="sxs-lookup"><span data-stu-id="0d607-113">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="0d607-114">Знание этих двух различий поможет в создании более понятного кода.</span><span class="sxs-lookup"><span data-stu-id="0d607-114">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="0d607-115">Правила определенного назначения у локальных функций и лямбда-выражений различаются.</span><span class="sxs-lookup"><span data-stu-id="0d607-115">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="0d607-116">На объявление локальной функции можно сослаться из любого расположения кода, находящегося в области охвата.</span><span class="sxs-lookup"><span data-stu-id="0d607-116">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="0d607-117">Прежде чем к лямбда-выражению можно будет осуществлять доступ, необходимо присвоить его переменной-делегату (или вызвать через делегат, ссылающийся на лямбда-выражение). Обратите внимание на то, что версия с использованием лямбда-выражения должна объявить и инициализировать лямбда-выражение `nthFactorial`, прежде чем его определить.</span><span class="sxs-lookup"><span data-stu-id="0d607-117">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delegate referencing the lambda expression.) Notice that the version using the lambda expression must declare and initialize the lambda expression, `nthFactorial` before defining it.</span></span> <span data-ttu-id="0d607-118">В противном случае возникает ошибка компилятора, связанная со ссылкой на объект `nthFactorial`, который еще не был назначен.</span><span class="sxs-lookup"><span data-stu-id="0d607-118">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span>
<span data-ttu-id="0d607-119">Эти различия означают, что рекурсивные алгоритмы легче создавать, используя локальные функции.</span><span class="sxs-lookup"><span data-stu-id="0d607-119">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="0d607-120">Можно объявить и определить локальную функцию, которая вызывает саму себя.</span><span class="sxs-lookup"><span data-stu-id="0d607-120">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="0d607-121">Необходимо объявить лямбда-выражения и назначить им значение по умолчанию, прежде чем их можно будет переназначить телу, которое ссылается на то же лямбда-выражение.</span><span class="sxs-lookup"><span data-stu-id="0d607-121">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="0d607-122">Правила определенного назначения также влияют на любые переменные, собранные локальной функцией или лямбда-выражением.</span><span class="sxs-lookup"><span data-stu-id="0d607-122">Definite assignment rules also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="0d607-123">Локальные функции и правила лямбда-выражений требуют, чтобы любые захваченные переменные были определенно назначены в точке, где локальная функция или лямбда-выражение преобразуется в делегат.</span><span class="sxs-lookup"><span data-stu-id="0d607-123">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="0d607-124">Разница в том, что лямбда-выражения преобразуются в делегаты при объявлении.</span><span class="sxs-lookup"><span data-stu-id="0d607-124">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="0d607-125">Локальные функции преобразуются в делегаты только при использовании в качестве делегата.</span><span class="sxs-lookup"><span data-stu-id="0d607-125">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="0d607-126">Если объявить локальную функцию и сослаться на нее только путем вызова этой функции в качестве метода, она не будет преобразована в делегат.</span><span class="sxs-lookup"><span data-stu-id="0d607-126">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="0d607-127">Это правило позволяет объявлять локальную функцию в любом удобном расположении во включающей его области.</span><span class="sxs-lookup"><span data-stu-id="0d607-127">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="0d607-128">Обычно локальные функции объявляют в конце родительского метода, после всех операторов return.</span><span class="sxs-lookup"><span data-stu-id="0d607-128">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="0d607-129">В-третьих, компилятор может выполнять статический анализ, что позволяет локальным функциям определенно назначать захваченные переменные во включающей области.</span><span class="sxs-lookup"><span data-stu-id="0d607-129">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="0d607-130">Рассмотрим следующий пример.</span><span class="sxs-lookup"><span data-stu-id="0d607-130">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="0d607-131">Компилятор может определить, что `LocalFunction` определенно назначает `y` при вызове.</span><span class="sxs-lookup"><span data-stu-id="0d607-131">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="0d607-132">Поскольку `LocalFunction` вызывается перед оператором `return`, `y` определенно назначается в операторе `return`.</span><span class="sxs-lookup"><span data-stu-id="0d607-132">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="0d607-133">Анализ, позволяющий выполнить анализ примера, также иллюстрирует четвертое различие.</span><span class="sxs-lookup"><span data-stu-id="0d607-133">The analysis that enables the example analysis enables the fourth difference.</span></span>
<span data-ttu-id="0d607-134">В зависимости от использования при работе с локальными функциями можно избежать распределения куч, которое всегда необходимо выполнять при работе с лямбда-выражениями.</span><span class="sxs-lookup"><span data-stu-id="0d607-134">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="0d607-135">Если локальная функция никогда не преобразуется в делегат и ни одна из переменных, захваченных локальной функцией, не захвачена другими лямбда-выражениями или локальными функциями, которые преобразуются в делегаты, компилятор может избежать распределения куч.</span><span class="sxs-lookup"><span data-stu-id="0d607-135">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span>

<span data-ttu-id="0d607-136">Рассмотрим следующий асинхронный пример:</span><span class="sxs-lookup"><span data-stu-id="0d607-136">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="0d607-137">Замыкание для этого лямбда-выражения содержит переменные `address`, `index` и `name`.</span><span class="sxs-lookup"><span data-stu-id="0d607-137">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="0d607-138">При использовании локальных функций объект, который реализует замыкание, может иметь тип `struct`.</span><span class="sxs-lookup"><span data-stu-id="0d607-138">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="0d607-139">Этот тип структуры будет передан в локальную функцию посредством ссылки.</span><span class="sxs-lookup"><span data-stu-id="0d607-139">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="0d607-140">Эта разница в реализации позволяет избежать распределения.</span><span class="sxs-lookup"><span data-stu-id="0d607-140">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="0d607-141">Создание экземпляра, необходимое для лямбда-выражений, означает выделение дополнительной памяти, что в критически важном коде может ухудшить производительность.</span><span class="sxs-lookup"><span data-stu-id="0d607-141">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span>
<span data-ttu-id="0d607-142">Локальные функции не создают этой перегрузки.</span><span class="sxs-lookup"><span data-stu-id="0d607-142">Local functions do not incur this overhead.</span></span> <span data-ttu-id="0d607-143">В приведенном выше примере в версии с локальной функцией используется на 2 меньше операции выделения памяти по сравнению с версией на основе лямбда-выражения.</span><span class="sxs-lookup"><span data-stu-id="0d607-143">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="0d607-144">В эквивалентном этому методе на основе локальной функции также используется класс для замыкания.</span><span class="sxs-lookup"><span data-stu-id="0d607-144">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="0d607-145">Реализация замыкания для локальной функции в формате `class` или `struct` зависит от особенностей реализации.</span><span class="sxs-lookup"><span data-stu-id="0d607-145">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="0d607-146">Локальная функция может использовать `struct`, тогда как в лямбда-выражениях всегда используется `class`.</span><span class="sxs-lookup"><span data-stu-id="0d607-146">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#TaskExample "Task returning method with local function")]

<span data-ttu-id="0d607-147">Еще одно преимущество локальных функций, которое не показано в этом примере, заключается в том, что они могут быть реализованы в качестве итераторов с использованием синтаксиса `yield return` для создания последовательности значений.</span><span class="sxs-lookup"><span data-stu-id="0d607-147">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="0d607-148">В лямбда-выражениях не допускается использование оператора `yield return`.</span><span class="sxs-lookup"><span data-stu-id="0d607-148">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="0d607-149">Локальные функции могут показаться избыточными для лямбда-выражений, поскольку обычно применяются иначе и в других целях.</span><span class="sxs-lookup"><span data-stu-id="0d607-149">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span>
<span data-ttu-id="0d607-150">Локальные функции более эффективны в случаях, когда вам нужно написать функцию, которая будет вызываться только из контекста другого метода.</span><span class="sxs-lookup"><span data-stu-id="0d607-150">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>
