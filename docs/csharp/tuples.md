---
title: Типы кортежей — руководство по C#
description: Сведения о типах именованных и неименованных кортежей в C#
ms.date: 05/15/2018
ms.assetid: ee8bf7c3-aa3e-4c9e-a5c6-e05cc6138baa
ms.openlocfilehash: 00330af38044b07128551b7dc74c7d831c7a5626
ms.sourcegitcommit: 6f28b709592503d27077b16fff2e2eacca569992
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/28/2019
ms.locfileid: "70105894"
---
# <a name="c-tuple-types"></a>Типы кортежей в C#

Кортежи в C# — эти типы, которые определяются с помощью упрощенного синтаксиса. Преимущества: более простой синтаксис, правила преобразований с учетом количества (так называемой кратности) и типов элементов, а также единые правила для копий, тестов на равенство и назначений. При этом кортежи не поддерживают некоторые объектно-ориентированные идиомы, связанные с наследованием. Общие сведения см. в разделе "Кортежи" статьи [Новые возможности C# 7.0](whats-new/csharp-7.md#tuples).

В этой статье вы узнаете, какие правила языка регулируют кортежи в C# версии 7.0 и более поздних и каким образом их можно использовать, а также получите вводные рекомендации по работе с кортежами.

> [!NOTE]
> Для новых функций кортежа требуются типы <xref:System.ValueTuple>.
> Для использования на платформах, которые не включают эти типы, необходимо добавить пакет NuGet [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/).
>
> Это похоже на другие функции языка, использующие типы, предоставляемые на платформе. В качестве примеров можно привести функции `async` и `await`, использующие интерфейс `INotifyCompletion`, а также LINQ на базе `IEnumerable<T>`. Тем не менее по мере увеличения степени независимости .NET от платформы механизм доставки изменяется. Периодичность поставки новых выпусков .NET Framework не всегда совпадает с выпусками обновлений для компилятора языка. Если новые функции языка используют новые типы, эти типы будут предоставляться в виде пакетов NuGet при выпуске таких новых функций. Как только эти новые типы будут добавлены в стандартный API-интерфейс .NET и включены в состав платформы, требование обязательно использовать пакет NuGet будет снято.

Для начала обсудим, почему была добавлена поддержка кортежей. Методы возвращают один объект. Кортежи позволяют легко упаковать в этот объект сразу несколько значений.

Платформа .NET Framework уже включает универсальные классы `Tuple`, которые, однако, имеют два серьезных ограничения. Например, классы `Tuple` присваивают своим свойствам имена `Item1`, `Item2` и т. д. Никакой семантической информации в этих именах нет. Эти типы `Tuple` не позволяют сообщить пользователю значение каждого из свойств. Новые функции языка позволяют объявить и использовать семантически значимые имена для элементов в кортеже.

Классы `Tuple` вызывают несколько проблем с производительностью, так как они имеют ссылочный тип. При использовании типов `Tuple` происходит распределение объектов. В критических путях выделение множества небольших объектов может заметно влиять на производительность приложения. Следовательно, при поддержке языков для кортежей используются новые структуры `ValueTuple`.

Чтобы избежать этих недостатков, можно создать `class` или `struct`, включающие несколько элементов. К сожалению, это означает дополнительную работу и искажает цель вашего проекта. Создание `struct` или `class` означает, что определение типа включает и данные, и поведение. Во многих случаях все, что вам нужно, — это сохранить в одном объекте несколько значений.

Возможности языка и универсальные структуры `ValueTuple` обеспечивают соблюдение правила, запрещающего добавлять поведение (методы) в эти типы кортежей.
Все типы `ValueTuple` представляют собой *изменяемые структуры*. Все поля членов открыты, что делает их очень простыми. В то же время это означает, что кортежи не стоит использовать в случаях, когда важна неизменность.

Кортежи — это более простые и более гибкие контейнеры данных, чем типы `class` и `struct`. Рассмотрим эти различия.

## <a name="named-and-unnamed-tuples"></a>Именованные и неименованные кортежи

Структура `ValueTuple` включает поля с именами `Item1`, `Item2`, `Item3` и т. д., аналогичные свойствам, определенным в существующих типах `Tuple`.
Только эти имена можно использовать для *неименованных кортежей*. Если никакие альтернативные имена полей кортежу не предоставлены, значит, вы создали неименованный кортеж:

[!code-csharp[UnnamedTuple](../../samples/snippets/csharp/tuples/program.cs#01_UnNamedTuple "Unnamed tuple")]

Кортеж в предыдущем примере был инициализирован с помощью констант-литералов, и в нем не будут созданы имена элементов с помощью *проекций имен полей кортежа* на C# 7.1.

В то же время при инициализации кортежа можно использовать новые возможности языка, позволяющие присваивать всем полям более понятные имена. При этом создается *именованный кортеж*.
Именованные кортежи тоже содержат имена с элементами `Item1`, `Item2`, `Item3` и т. д.
В то же время у них есть синонимы для всех элементов, которым вы присвоили имена.
Для создания именованного кортежа необходимо указать имя для каждого элемента. Один из способов — указать имена в процессе инициализации кортежа:

[!code-csharp[NamedTuple](../../samples/snippets/csharp/tuples/program.cs#02_NamedTuple "Named tuple")]

Эти синонимы обрабатываются компилятором и языком, что позволяет эффективно использовать именованные кортежи. Интегрированные среды разработки и редакторы читают эти семантические имена с помощью API Roslyn. Вы можете ссылаться на элементы именованного кортежа по семантическим именам в любой части сборки. При создании компилированных выходных данных компилятор заменяет имена, определенные с помощью эквивалентов `Item*`. Скомпилированный MSIL не включает имена, которые вы присвоили этим элементам.

Начиная с C# 7.1, имена полей для кортежа могут быть получены из переменных, которые используются для его инициализации. Они называются **[инициализаторами проекций кортежа](#tuple-projection-initializers)** . Следующий код создает кортеж `accumulation` с элементами `count` (целое значение) и `sum` (значение double).

[!code-csharp[ProjectedTuple](../../samples/snippets/csharp/tuples/program.cs#ProjectedTupleNames "Named tuple")]

Компилятор должен передавать созданные вами имена для кортежей, возвращаемых открытыми методами и свойствами. В подобных случаях компилятор добавляет к методу атрибут <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute>. Этот атрибут содержит свойство списка <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames>, которое содержит имена, присвоенные каждому элементу в кортеже.

> [!NOTE]
> Средства разработки, такие как Visual Studio, также считывают эти метаданные и предоставляют IntelliSense и другие возможности, используя имена полей метаданных.

Знать основы работы с новыми кортежами и типом `ValueTuple` необходимо для того, чтобы понимать правила назначения именованных кортежей друг другу.

## <a name="tuple-projection-initializers"></a>Инициализаторы проекций кортежа

Как правило, инициализаторы проекций кортежа работают с использованием переменной или имен полей в правой части оператора инициализации кортежа.
Если задано явное имя, оно имеет приоритет над именем проекции. Например, в следующем инициализаторе элементы имеют значения `explicitFieldOne` и `explicitFieldTwo`, а не `localVariableOne` и `localVariableTwo`:

[!code-csharp[ExplicitNamedTuple](../../samples/snippets/csharp/tuples/program.cs#ProjectionExample_Explicit "Explicitly named tuple")]

Во всех полях, где не указано явное имя, проецируется применимое неявное имя. Необязательно указывать семантические имена как явно, так и неявно. Следующий инициализатор имеет имена полей `Item1` со значением `42` и `stringContent` ("Ответ на все вопросы"):

[!code-csharp[MixedTuple](../../samples/snippets/csharp/tuples/program.cs#MixedTuple "mixed tuple")]

Существуют два условия, при которых имена полей кандидата не проецируются в поле кортежа.

1. Имя кандидата является зарезервированным именем кортежа. К примерам относятся `Item3`, `ToString` и `Rest`.
1. Имя кандидата является дубликатом другого имени поля кортежа, явного или неявного.

Эти условия позволяют избежать неоднозначности. Эти имена вызывали бы неоднозначность, если бы использовались в качестве имен полей для поля в кортеже. Ни одно из этих условий не вызовет ошибки времени компиляции. Семантические имена элементов без проецируемых имен не будут проецироваться.  Все это показано в приведенных ниже примерах.

[!code-csharp-interactive[Ambiguity](../../samples/snippets/csharp/tuples/program.cs#ProjectionAmbiguities "tuples where projections are not performed")]

Эти ситуации не вызывают ошибок компилятора, так как это стало бы критическим изменением кода, написанного на C# 7.0, где проекции имен полей кортежа были недоступны.

## <a name="equality-and-tuples"></a>Равенство и кортежи

Начиная с C# 7.3, типы кортежей поддерживают операторы `==` и `!=`. Эти операторы работают путем сравнения каждого элемента левого аргумента с каждым элементом правого аргумента по порядку. Это сокращенные сравнения. Они перестанут сравнивать элементы, как только будет обнаружена неравная пара. В следующем примере кода используется оператор `==`, но все правила сравнения применяются к оператору `!=`. В следующем примере кода показано сравнение двух пар целых чисел на равенство:

[!code-csharp-interactive[TupleEquality](../../samples/snippets/csharp/tuples/program.cs#Equality "Testing tuples for equality")]

Существует несколько правил, которые упрощают тесты на равенство кортежей. Если один из кортежей допускает значение NULL, как показано в следующем коде, функция проверки кортежей на равенство выполняет [преобразования для использования форм, допускающих значение NULL](~/_csharplang/spec/conversions.md#lifted-conversion-operators):

[!code-csharp-interactive[NullableTupleEquality](../../samples/snippets/csharp/tuples/program.cs#NullableEquality "Comparing Tuples and nullable tuples")]

Функция проверки кортежей на равенство также выполняет неявное преобразование каждого элемента обоих кортежей. К ним относятся преобразования для использования форм, допускающих значение NULL, расширяющие преобразования и другие неявные преобразования. В следующих примерах показано, что кортеж из 2 элементов типа "целое число" можно сравнить с кортежем из 2 элементов типа "длинное целое" в связи с неявным преобразованием из целого числа в длинное целое:

[!code-csharp-interactive[SnippetMemberConversions](../../samples/snippets/csharp/tuples/program.cs#SnippetMemberConversions "converting tuples for equality tests")]

Имена элементов кортежей не участвуют в тестах на равенство. Тем не менее если один из операндов является литералом кортежа с явными именами, компилятор генерирует предупреждение CS8383 в случае несовпадения этих имен с именами второго операнда.
В случае, когда оба операнда являются литералами кортежей, предупреждение находится возле правого операнда, как показано в следующем примере:

[!code-csharp-interactive[MemberNames](../../samples/snippets/csharp/tuples/program.cs#SnippetMemberNames "Tuple member names do not participate in equality tests")]

Наконец, кортежи могут содержать вложенные кортежи. Функция проверки кортежей на равенство сравнивает "форму" каждого операнда по вложенным кортежам, как показано в следующем примере:

[!code-csharp-interactive[NestedTuples](../../samples/snippets/csharp/tuples/program.cs#SnippetNestedTuples "Tuples may contain nested tuples that participate in tuple equality.")]

Это ошибка времени компиляции для сравнения двух кортежей на равенство (или неравенство) при наличии разных фигур. Компилятор не пытается выполнить деконструкцию вложенных кортежей, чтобы сравнить их.

## <a name="assignment-and-tuples"></a>Назначение и кортежи

Язык поддерживает назначение между типами кортежей с одинаковым количеством элементов, где каждый расположенный справа элемент может быть неявно преобразован в соответствующий элемент, расположенный слева. Другие преобразования в контексте назначений не учитываются. Это ошибки времени компиляции для назначения одного кортежа другому при наличии различных фигур. Компилятор не будет пытаться выполнить любую деконструкцию вложенных кортежей для их назначения.
Рассмотрим возможные виды назначений между типами кортежей.

В приведенных ниже примерах можно использовать указанные переменные:

[!code-csharp[VariableCreation](../../samples/snippets/csharp/tuples/program.cs#03_VariableCreation "Variable creation")]

В первых двух переменных, `unnamed` и `anonymous`, семантические имена элементам не назначены. Имена полей — `Item1` и `Item2`.
Последние две переменные, `named` и `differentName`, включают назначенные элементам семантические имена. Элементы в этих двух кортежах называются по-разному.

Все четыре этих кортежа имеют одинаковое число элементов (так называемую кратность), а типы этих элементов идентичны. Таким образом, все эти назначения работают:

[!code-csharp[VariableAssignment](../../samples/snippets/csharp/tuples/program.cs#04_VariableAssignment "Variable assignment")]

Обратите внимание на то, что имена кортежей не назначаются. Значения элементов назначаются в соответствии с порядком элементов в кортеже.

Кортежи различных типов или с различным количеством элементов не назначаются.

```csharp
// Does not compile.
// CS0029: Cannot assign Tuple(int,int,int) to Tuple(int, string)
var differentShape = (1, 2, 3);
named = differentShape;
```

## <a name="tuples-as-method-return-values"></a>Кортежи как возвращаемые значения методов

Чаще всего кортежи используются как возвращаемое методом значение. Разберем конкретный пример. Рассмотрим метод, который вычисляет стандартное отклонение для последовательности чисел:

[!code-csharp[StandardDeviation](../../samples/snippets/csharp/tuples/statistics.cs#05_StandardDeviation "Compute Standard Deviation")]

> [!NOTE]
> Код в этих примерах вычисляет стандартное отклонение неисправленной выборки.
> Формула стандартного отклонения исправленной выборки делит сумму квадратов разности со средним значением на (N-1), как и метод расширения `Average`. Дополнительные сведения о различиях между этими формулами для расчета стандартного отклонения см. в тексте по статистике.

Приведенный выше код соответствует учебной формуле для стандартного отклонения. Она позволяет получить правильный ответ, однако эта реализация неэффективна. Этот метод перечисляет последовательность дважды. Один раз для получения среднего значения, а второй — для получения среднего значения квадратов разницы со средним.
(Запомните, что запросы LINQ вычисляются в отложенном режиме, поэтому разница со средним значением и среднее этих разниц вычисляются в один прием.)

Существует альтернативная формула, которая вычисляет стандартное отклонение, используя только одно перечисление последовательности.  В результате этого вычисления выдаются два значения, поскольку оно перечисляет последовательность: сумма всех элементов в последовательности и сумма квадратов всех значений:

[!code-csharp[SumOfSquaresFormula](../../samples/snippets/csharp/tuples/statistics.cs#06_SumOfSquaresFormula "Compute Standard Deviation using the sum of squares")]

Эта версия перечисляет последовательность ровно один раз. В то же время этот код нельзя повторно использовать. По мере работы вы узнаете, что во многих статистических вычислениях используется число элементов в последовательности, сумма последовательности и сумма квадратов последовательности. Выполним рефакторинг этого метода и напишем служебный метод, выдающий все три из этих значений. Все три значения могут быть возвращены в виде кортежа.

Обновим этот метод таким образом, чтобы все три значения, вычисляемые при перечислении, сохранялись в кортеж. В результате создается следующая версия:

[!code-csharp[TupleVersion](../../samples/snippets/csharp/tuples/statistics.cs#07_TupleVersion "Refactor to use tuples")]

Поддержка рефакторинга в Visual Studio позволяет легко извлекать функции основной статистики в закрытый метод. В результате вы получаете метод `private static`, возвращающий тип кортежа с тремя значениями — `Sum`, `SumOfSquares` и `Count`:

[!code-csharp[TupleMethodVersion](../../samples/snippets/csharp/tuples/statistics.cs#08_TupleMethodVersion "After extracting utility method")]
 
Язык позволяет использовать несколько дополнительных параметров, с помощью которых можно внести несколько быстрых изменений вручную. Во-первых, объявление `var` можно использовать для инициализации результата кортежа из вызова метода `ComputeSumAndSumOfSquares`. Кроме того, в методе `ComputeSumAndSumOfSquares` можно создать три дискретные переменные. Итоговая версия показана в следующем коде:

[!code-csharp[CleanedTupleVersion](../../samples/snippets/csharp/tuples/statistics.cs#09_CleanedTupleVersion "After final cleanup")]

Окончательную версию можно применять к любому методу, которому требуются эти три значения, а также к любому их подмножеству.

Язык поддерживает другие варианты управления именами элементов в методах, возвращающих кортежи.

Имена полей можно удалить из объявления возвращаемого значения и вернуть неименованный кортеж:

```csharp
private static (double, double, int) ComputeSumAndSumOfSquares(IEnumerable<double> sequence)
{
    double sum = 0;
    double sumOfSquares = 0;
    int count = 0;

    foreach (var item in sequence)
    {
        count++;
        sum += item;
        sumOfSquares += item * item;
    }

    return (sum, sumOfSquares, count);
}
```

Поля этого кортежа называются `Item1`, `Item2` и `Item3`.
Для элементов кортежей, возвращаемых из методов, рекомендуется указывать семантические имена.

Еще одна идиома, в которой кортежи могут быть полезны, связана с созданием запросов LINQ. Итоговый проецируемый результат часто содержит некоторые, но не все свойства выбранных объектов.

Обычно результаты запроса проецируются в последовательность объектов анонимного типа. С этим связано множество ограничений, в первую очередь потому, что анонимным типам нельзя присваивать удобные имена в возвращаемом типе для метода. Альтернативные варианты с типом результата `object` или `dynamic` вызывают серьезные потери в производительности.

Вернуть последовательность с типом кортежа легко, а имена и типы элементов можно получить во время компиляции и с помощью средств IDE.
В качестве примера рассмотрим приложение ToDo. Определите класс следующего вида — он будет представлять одну запись в списке дел ToDo:

[!code-csharp[ToDoItem](../../samples/snippets/csharp/tuples/projectionsample.cs#14_ToDoItem "To Do Item")]

Мобильные приложения могут поддерживать компактную форму текущих пунктов в списке дел, когда отображается только заголовок. Этот запрос LINQ выполняет проекцию, включающую только идентификатор и заголовок. Эту модель хорошо демонстрирует метод, возвращающий последовательность кортежей:

[!code-csharp[QueryReturningTuple](../../samples/snippets/csharp/tuples/projectionsample.cs#15_QueryReturningTuple "Query returning a tuple")]

> [!NOTE]
> В C# 7.1 проекции кортежей позволяют создавать именованные кортежи с помощью элементов аналогично именованию свойств в анонимных типах. В коде выше оператор `select` в проекции запросов создает кортеж с элементами `ID` и `Title`.

Именованный кортеж может быть частью сигнатуры. Это позволяет компилятору и средствам IDE статически проверять, правильно ли используются результаты. Именованный кортеж также несет в себе данные статического типа, избавляя от необходимости использовать для работы с результатами дорогостоящие функции среды выполнения, такие как отражение или динамическая привязка.

## <a name="deconstruction"></a>Деконструкция

Все элементы в кортеже можно распаковать, выполнив *деконструкцию* возвращаемого методом кортежа. Деконструкцию кортежей можно выполнять тремя различными способами.  Во-первых, можно явно объявить тип каждого поля, заключив его в круглые скобки, чтобы создать дискретные переменные для каждого элемента в кортеже:

[!code-csharp[Deconstruct](../../samples/snippets/csharp/tuples/statistics.cs#10_Deconstruct "Deconstruct")]

Типизированные переменные для каждого поля в кортеже можно также объявить неявно, используя ключевое слово `var` за скобками:

[!code-csharp[DeconstructToVar](../../samples/snippets/csharp/tuples/statistics.cs#11_DeconstructToVar "Deconstruct to Var")]

Кроме того, в объявлении одной или всех переменных можно также свободно использовать ключевое слово `var`, заключив его в скобки. 

```csharp
(double sum, var sumOfSquares, var count) = ComputeSumAndSumOfSquares(sequence);
```

Определенный тип использовать за скобками нельзя, даже если каждое поле в кортеже имеет одинаковый тип.

Можно также выполнить деконструкцию кортежей с существующими объявлениями:

```csharp
public class Point
{
    public int X { get; set; }
    public int Y { get; set; }

    public Point(int x, int y) => (X, Y) = (x, y);
}
```

> [!WARNING]
> Нельзя смешивать существующие объявления с объявлениями в круглых скобках. Например, следующее выражение является недопустимым: `(var x, y) = MyMethod();`. В результате возникает ошибка CS8184, так как переменная *x* объявлена внутри скобок, а переменная *y* объявлена ранее в другом месте.

### <a name="deconstructing-user-defined-types"></a>Деконструкция пользовательских типов

Любой тип кортежа можно деконструировать, как показано выше. Деконструкцию можно легко активировать для любого пользовательского типа (классов, структур и даже интерфейсов).

Автор типа может определить один или несколько методов `Deconstruct`, присваивающих значения любому количеству переменных `out`, которые представляют составляющие этот тип элементы данных. Например, следующий тип `Person` определяет метод `Deconstruct`, который деконструирует объект person в элементы, представляющие имя и фамилию:

[!code-csharp[TypeWithDeconstructMethod](../../samples/snippets/csharp/tuples/person.cs#12_TypeWithDeconstructMethod "Type with a deconstruct method")]

Метод deconstruct позволяет выполнять назначение из объекта `Person` в две строки, представляющие свойства `FirstName` и `LastName`:

[!code-csharp[Deconstruct Type](../../samples/snippets/csharp/tuples/program.cs#12A_DeconstructType "Deconstruct a class type")]

Вы можете включить деконструкцию даже для типов, которые не создавали.
Метод `Deconstruct` может быть методом расширения, который распаковывает доступные элементы данных в объекте. В следующем примере показан тип `Student`, производный от типа `Person`, и метод расширения, который разбивает `Student` на три переменные, представляющие `FirstName`, `LastName` и `GPA`:

[!code-csharp[ExtensionDeconstructMethod](../../samples/snippets/csharp/tuples/person.cs#13_ExtensionDeconstructMethod "Type with a deconstruct extension method")]

Теперь у объекта `Student` есть два доступных метода `Deconstruct`: метод расширения, объявленный для типов `Student`, и элемент типа `Person`. Оба из них входят в область, что позволяет разбить `Student` либо на две, либо на три переменные.
Если учащийся назначается трем переменным, возвращается все — имя, фамилия и GPA. Если учащийся назначается двум переменным, возвращаются только имя и фамилия.

[!code-csharp[Deconstruct extension method](../../samples/snippets/csharp/tuples/program.cs#13A_DeconstructExtension "Deconstruct a class type using an extension method")]

Определять несколько методов `Deconstruct` в классе или иерархии классов необходимо с осторожностью. Несколько методов `Deconstruct` с одинаковым числом параметров `out` могут быстро вызвать неоднозначность. В итоге вызывающие объекты могут лишиться возможности вызвать желаемый метод `Deconstruct`.

В этом примере вероятность неоднозначного вызова минимальна, поскольку метод `Deconstruct` для `Person` имеет два параметра вывода, а метод `Deconstruct` для `Student` — три.

Операторы деконструкции не участвуют в проверке равенства. Следующий пример создает ошибку компилятора CS0019.

```csharp
Person p = new Person("Althea", "Goodwin");
if (("Althea", "Goodwin") == p)
    Console.WriteLine(p);
```

Метод `Deconstruct` может преобразовать объект `Person` `p` в кортеж, содержащий две строки, но он неприменим в контексте проверок на равенство.

## <a name="conclusion"></a>Заключение 

Добавленная в язык и библиотеку поддержка именованных кортежей значительно упрощает работу с проектами, в которых используются структуры данных, хранящие несколько элементов, но не определяющие поведение подобно классам или структурам. Для этих типов удобно использовать кортежи. Они дают вам все преимущества статической поддержки типов и в то же время избавляют от необходимости создавать типы с использованием более подробного синтаксиса `class` или `struct`. И все же наибольшую пользу они приносят при использовании со служебными методами, имеющими атрибут `private` или `internal`. Создавайте пользовательские типы, `class` или `struct`, если ваши открытые методы возвращают значение с несколькими элементами.
