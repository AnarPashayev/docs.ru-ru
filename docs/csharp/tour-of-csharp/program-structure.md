---
title: Структура программы в C#. Краткий обзор языка C#
description: Узнайте, из каких блоков составляется программа на C#
ms.date: 08/10/2016
ms.assetid: 984f0314-507f-47a0-af56-9011243f5e65
ms.openlocfilehash: 5e095e71549ed3eec6c73e6a134fdb5a64fb63c0
ms.sourcegitcommit: 68a4b28242da50e1d25aab597c632767713a6f81
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/06/2019
ms.locfileid: "74884388"
---
# <a name="program-structure"></a>Структура программы

В C# основными понятиями организационной структуры являются ***программы***, ***пространства имен***, ***типы***, ***члены*** и ***сборки***. Программа на языке C# состоит из одного или нескольких файлов. В программе объявляются типы, которые содержат члены. Эти типы можно организовать в пространства имен. Примерами типов являются классы и интерфейсы. К членам относятся поля, методы, свойства и события. При компиляции программы на C# упаковываются в сборки. Сборка — это файл, обычно с расширением `.exe` или `.dll`, если она реализует ***приложение*** или ***библиотеку***, соответственно.

Этот пример кода объявляет класс с именем `Stack` в пространство имен с именем `Acme.Collections`:

[!code-csharp[Stack](../../../samples/snippets/csharp/tour/program-structure/program.cs#L1-L34)]

Полное имя этого класса: `Acme.Collections.Stack`. Этот класс содержит несколько членов: поле с именем `top`, два метода с именами `Push` и `Pop`, а также вложенный класс с именем `Entry`. Класс `Entry`, в свою очередь, содержит три члена: поле с именем `next`, поле с именем `data` и конструктор. Если мы сохраним исходный код этого примера в файле `acme.cs`, то для его компиляции нужно выполнить такую командную строку:

```console
csc /t:library acme.cs
```

Результатом компиляции будет библиотека (код без точки входа `Main`), сохраненная в сборке с именем `acme.dll`.

> [!IMPORTANT]
> В приведенных выше примерах используется компилятор командной строки `csc` для C#. Он существует в виде исполняемого файла Windows. Чтобы использовать C# на других платформах, вам понадобятся средства для .NET Core. Экосистема .NET Core использует `dotnet` CLI для управления сборкой из командной строки. Она позволяет управлять зависимостями и вызывать компилятор C#. [В этом руководстве](../../core/tutorials/cli-create-console-app.md) вы найдете полное описание средств для всех платформ, поддерживаемых .NET Core.

Сборки содержат исполняемый код в виде инструкций промежуточного языка (IL) и символьную информацию в виде метаданных. Перед выполнением сборки ее код на языке IL автоматически преобразуется в код для конкретного процессора. Эту задачу выполняет JIT-компилятор среды .NET CLR (Common Language Runtime).

Cборка полностью описывает сама себя и содержит весь код и метаданные, поэтому в C# не используются директивы `#include` и файлы заголовков. Чтобы использовать в программе C# открытые типы и члены, содержащиеся в определенной сборке, вам достаточно указать ссылку на эту сборку при компиляции программы. Например, эта программа использует класс `Acme.Collections.Stack` из сборки `acme.dll`:

[!code-csharp[UsingStack](../../../samples/snippets/csharp/tour/program-structure/Program.cs#L38-L52)]

Если на момент компиляции `example.cs` программа хранится в файле `example.cs`, то ссылка на сборку acme.dll с использованием параметра компилятора /r будет выглядеть так:

```console
csc /r:acme.dll example.cs
```

Эта команда создает исполняемую сборку с именем `example.exe`, которая при запуске возвращает такие данные:

```console
100
10
1
```

В C# исходный текст программы можно хранить в нескольких исходных файлах. При компиляции многофайловой программы на C# все исходные файлы обрабатываются вместе, и все они могут свободно ссылаться друг на друга. По сути обработка выполняется так, как если бы все исходные файлы были объединены в один большой файл. В C# никогда не используются опережающие объявления, поскольку порядок объявления, за редким исключением, не играет никакой роли. В C# нет требований объявлять только один открытый тип в одном исходном файле, а также имя исходного файла не обязано совпадать с типом, объявляемом в этом файле.

>[!div class="step-by-step"]
>[Назад](index.md)
>[Вперед](types-and-variables.md)
