---
title: Определение типов и их элементов — обзор C#
description: Типы — это стандартные блоки, из которых состоят программы. Узнайте, как создавать классы, структуры, интерфейсы и многое другое в C#.
ms.date: 08/06/2020
ms.openlocfilehash: b1ce24611fec6fdf01d5ecb8d6ae974e147c78c5
ms.sourcegitcommit: 68c9d9d9a97aab3b59d388914004b5474cf1dbd7
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2021
ms.locfileid: "99216607"
---
# <a name="types-and-members"></a>Типы и элементы

C# является объектно-ориентированным языком, а значит поддерживает инкапсуляцию, наследование и полиморфизм. Класс наследуется непосредственно из одного родительского класса. Он может реализовывать любое число интерфейсов. Методы, которые переопределяют виртуальные методы родительского класса, должны содержать ключевое слово `override`, чтобы исключить случайное переопределение. В языке C# структура похожа на облегченный класс: это тип, распределяемый в стеке и реализующий интерфейсы, но не поддерживающий наследование. C# также предоставляет записи. Запись — это тип класса, основное назначение которого заключается в хранении данных.

## <a name="classes-and-objects"></a>Классы и объекты

*Классы* являются основным типом в языке C#. Класс представляет собой структуру данных, которая объединяет в себе значения (поля) и действия (методы и другие функции-члены). Класс предоставляет определение для *экземпляров* класса, которые также именуются *объектами*. Классы поддерживают механизмы *наследования* и *полиморфизма*, которые позволяют создавать *производные классы*, расширяющие и уточняющие определения *базовых классов*.

Новые классы создаются с помощью объявлений классов. Объявление класса начинается с заголовка. Заголовок указывает:

- Атрибуты и модификаторы класса
- Имя класса
- Базовый класс (при наследовании от [базового класса](#base-classes))
- Интерфейсы, реализуемые классом.

За заголовком между разделителями `{` и `}` следует тело класса, в котором последовательно объявляются все члены класса.

Следующий код является простым примером объявления класса с именем `Point`:

:::code language="csharp" source="./snippets/shared/Types.cs" ID="PointClass":::

Экземпляры классов создаются с помощью оператора `new`, который выделяет память для нового экземпляра, вызывает конструктор для инициализации этого экземпляра и возвращает ссылку на экземпляр. Следующие инструкции создают два объекта `Point` и сохраняют ссылки на эти объекты в двух переменных:

:::code language="csharp" source="./snippets/shared/Types.cs" ID="CreatePoints":::

Занимаемая объектом память автоматически освобождается, когда объект становится недоступен. В C# нет ни необходимости, ни возможности освобождать память объектов явным образом.

### <a name="type-parameters"></a>Параметры типа

Универсальные классы определяют [***параметры типа** _](../programming-guide/generics/index.md). Параметры типа — это список имен параметров типа, заключенных в угловые скобки. Параметры типа следуют за именем класса. Параметры типа можно использовать в теле класса в определениях, описывающих члены класса. В следующем примере для класса `Pair` заданы параметры типа `TFirst` и `TSecond`:

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DefinePairClass":::

Тип класса, для которого объявлены параметры типа, называется _универсальным типом класса*. Типы структуры, интерфейса и делегата также могут быть универсальными.
Если вы используете универсальный класс, необходимо указать аргумент типа для каждого параметра типа, вот так:

:::code language="csharp" source="./snippets/shared/Types.cs" ID="CreatePairObject":::

Универсальный тип, для которого указаны аргументы типа, как `Pair<int,string>` в примере выше, называется *сконструированным типом*.

### <a name="base-classes"></a>базовых классов;

В объявлении класса может быть указан базовый класс. Имя базового класса указывается после имени класса и параметров типа и отделяется от них двоеточием. Если спецификация базового класса не указана, класс наследуется от типа `object`. В следующем примере `Point3D` имеет базовый класс `Point`. В первом примере `Point` имеет базовый класс `object`:

:::code language="csharp" source="./snippets/shared/Types.cs" ID="Create3DPoint":::

Класс наследует члены базового класса. Наследование означает, что класс неявно содержит почти все элементы базового класса. Класс не наследует экземпляры, статические конструкторы и метод завершения. Производный класс может добавлять новые члены к наследуемым, но не может удалить определение для наследуемого члена. В предыдущем примере `Point3D` наследует члены `X` и `Y` из `Point`, и каждый экземпляр `Point3D` содержит три свойства: `X`, `Y` и `Z`.

Используется неявное преобразование из типа класса к любому из типов соответствующего базового класса. Переменная типа класса может ссылаться как на экземпляр этого класса, так и на экземпляры любого производного класса. Например, если мы используем описанные выше объявления классов, то переменная типа `Point` может ссылаться на `Point` или `Point3D`:

:::code language="csharp" source="./snippets/shared/Types.cs" ID="ImplicitCastToBase":::

## <a name="structs"></a>Структуры

Классы определяют типы, поддерживающие наследование и полиморфизм. Они позволяют создавать сложные расширения функциональности на основе иерархий производных классов. В отличие от них, типы [***struct** _](../language-reference/builtin-types/struct.md) — это простые типы, основное назначение которых — хранить значения данных. В структурах не может быть объявлен базовый тип; они неявно наследуются от <xref:System.ValueType?displayProperty=nameWithType>. От типа `struct` не могут быть унаследованы другие типы `struct`. Они неявно запечатаны.

:::code language="csharp" source="./snippets/shared/Types.cs" ID="PointStruct":::

## <a name="interfaces"></a>интерфейсов,

[_*_Интерфейс_*_](../programming-guide/interfaces/index.md) определяет контракт, который может быть реализован классами и структурами. Интерфейс может содержать методы, свойства, события и индексаторы. Интерфейс обычно не предоставляет реализацию элементов, которые в нем определены. Он лишь перечисляет элементы, которые должны быть определены в классах или структурах, реализующих этот интерфейс.

Интерфейсы могут применять _*_множественное наследование_*_. В следующем примере интерфейс `IComboBox` наследует одновременно от `ITextBox` и `IListBox`.

:::code language="csharp" source="./snippets/shared/Types.cs" ID="FirstInterfaces":::

Классы и структуры могут реализовывать несколько интерфейсов. В следующем примере класс `EditBox` реализует одновременно `IControl` и `IDataBound`.

:::code language="csharp" source="./snippets/shared/Types.cs" ID="ImplementInterfaces":::

Если класс или структура реализует конкретный интерфейс, любой экземпляр этого класса или структуры можно неявно преобразовать в такой тип интерфейса. Например.

:::code language="csharp" source="./snippets/shared/Types.cs" ID="UseInterfaces":::

## <a name="enums"></a>Перечисления

Тип [_*_Enum_*_](../language-reference/builtin-types/enum.md) определяет набор константных значений. В следующем объявлении `enum` определяются константы, соответствующие различным корнеплодам:

:::code language="csharp" source="./snippets/shared/Types.cs" ID="EnumDeclaration":::

Также можно определить `enum`, которое будет использоваться в виде сочетания флагов. В следующем объявлении определяется набор флагов для четырех времен года. Можно применить любое сочетание времен года, в том числе значение `All`, включающее все времена года:

:::code language="csharp" source="./snippets/shared/Types.cs" ID="FlagsEnumDeclaration":::

В следующем примере показаны объявления для обоих указанных выше перечислений:

:::code language="csharp" source="./snippets/shared/Types.cs" ID="UsingEnums":::

## <a name="nullable-types"></a>Типы, допускающие значение NULL

Переменные любого типа могут быть объявлены как _*_не допускающие значение NULL_*_ или _*_допускающие значение NULL_*_. Переменная, допускающая значение NULL, может содержать дополнительное значение `null`, указывающее на отсутствие значения. Типы значений, допускающие значение NULL (структуры или перечисления), представляются <xref:System.Nullable%601?displayProperty=nameWithType>. Ссылочные типы, не допускающие значение NULL и допускающие значение NULL, представляются базовым ссылочным типом. Различие представляется метаданными, которые считываются компилятором и некоторыми библиотеками. Если ссылки, допускающие значение NULL, разыменовываются без предварительной проверки значения на `null`, компилятор выдает предупреждения. Компилятор также выдает предупреждения, если ссылкам, не допускающим значение NULL, присваивается значение, которое может быть равно `null`. В следующем примере объявляется _*_переменная целочисленного типа, допускающая значение NULL_*_, и эта переменная инициализируется значением `null`. Затем ей присваивается значение `5`. Затем те же действия выполняются для _*_строки, допускающей значение NULL_*_. Дополнительные сведения см. в статьях [Типы значений, допускающие значение NULL](../language-reference/builtin-types/nullable-value-types.md) и [Ссылочные типы, допускающие значение NULL](../nullable-references.md).

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DeclareNullable":::

## <a name="tuples"></a>Кортежи

C# поддерживает [_ *_кортежи_**](../language-reference/builtin-types/value-tuples.md), которые предоставляют краткий синтаксис для группирования нескольких элементов данных в упрощенную структуру данных. Чтобы создать экземпляр кортежа, необходимо объявить типы и имена элементов между `(` и `)`, как показано в следующем примере:

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DeclareTuples":::

Кортежи являются альтернативой для структуры данных с несколькими элементами. В них не используются стандартные блоки, описанные в следующей статье.

>[!div class="step-by-step"]
>[Назад](index.md)
>[Вперед](program-building-blocks.md)
