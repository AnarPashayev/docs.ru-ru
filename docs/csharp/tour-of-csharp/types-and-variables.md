---
title: Типы и переменные в C#. Краткий обзор языка C#
description: Сведения о типах и об объявлении переменных в C#
ms.date: 08/10/2016
ms.assetid: f8a8051e-0049-43f1-b594-9c84cc7b1224
ms.openlocfilehash: ae44dd273a2460e5718adc7324fae324e3de5bba
ms.sourcegitcommit: 0be8a279af6d8a43e03141e349d3efd5d35f8767
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2019
ms.locfileid: "59672372"
---
# <a name="types-and-variables"></a><span data-ttu-id="27f7e-103">Типы и переменные</span><span class="sxs-lookup"><span data-stu-id="27f7e-103">Types and variables</span></span>

<span data-ttu-id="27f7e-104">В C# существуют две разновидности типов: *ссылочные типы* и *типы значений*.</span><span class="sxs-lookup"><span data-stu-id="27f7e-104">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="27f7e-105">Переменные типа значений содержат непосредственно данные, а в переменных ссылочных типов хранятся ссылки на нужные данные, которые именуются объектами.</span><span class="sxs-lookup"><span data-stu-id="27f7e-105">Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="27f7e-106">Две переменные ссылочного типа могут ссылаться на один и тот же объект, поэтому может случиться так, что операции над одной переменной затронут объект, на который ссылается другая переменная.</span><span class="sxs-lookup"><span data-stu-id="27f7e-106">With reference types, it is possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="27f7e-107">Каждая переменная типа значения имеет собственную копию данных, и операции над одной переменной не могут затрагивать другую (за исключением переменных параметров `ref` и `out`).</span><span class="sxs-lookup"><span data-stu-id="27f7e-107">With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other (except in the case of `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="27f7e-108">Типы значений в C# подразделяются на *простые типы*, *типы перечисления*, *типы структур* и *типы, допускающие значение Null*.</span><span class="sxs-lookup"><span data-stu-id="27f7e-108">C#’s value types are further divided into *simple types*, *enum types*, *struct types*, and *nullable value types*.</span></span> <span data-ttu-id="27f7e-109">Ссылочные типы в C# подразделяются на *типы классов*, *типы интерфейсов*, *типы массивов* и *типы делегатов*.</span><span class="sxs-lookup"><span data-stu-id="27f7e-109">C#’s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="27f7e-110">Далее представлены общие сведения о системе типов в C#.</span><span class="sxs-lookup"><span data-stu-id="27f7e-110">The following provides an overview of C#’s type system.</span></span>

* <span data-ttu-id="27f7e-111">[Типы значений][ValueTypes]</span><span class="sxs-lookup"><span data-stu-id="27f7e-111">[Value types][ValueTypes]</span></span>
  - <span data-ttu-id="27f7e-112">[Простые типы][SimpleTypes]</span><span class="sxs-lookup"><span data-stu-id="27f7e-112">[Simple types][SimpleTypes]</span></span>
    * <span data-ttu-id="27f7e-113">Целочисленный со знаком: `sbyte`, `short`, `int`,`long`</span><span class="sxs-lookup"><span data-stu-id="27f7e-113">Signed integral: `sbyte`, `short`, `int`, `long`</span></span>
    * <span data-ttu-id="27f7e-114">Целочисленный без знака: `byte`, `ushort`, `uint`,`ulong`</span><span class="sxs-lookup"><span data-stu-id="27f7e-114">Unsigned integral: `byte`, `ushort`, `uint`, `ulong`</span></span>
    * <span data-ttu-id="27f7e-115">Символы Юникода: `char`</span><span class="sxs-lookup"><span data-stu-id="27f7e-115">Unicode characters: `char`</span></span>
    * <span data-ttu-id="27f7e-116">IEEE-представление с плавающей запятой: `float`, `double`</span><span class="sxs-lookup"><span data-stu-id="27f7e-116">IEEE floating point: `float`, `double`</span></span>
    * <span data-ttu-id="27f7e-117">Десятичный с повышенной точностью: `decimal`</span><span class="sxs-lookup"><span data-stu-id="27f7e-117">High-precision decimal: `decimal`</span></span>
    * <span data-ttu-id="27f7e-118">Логическое значение: `bool`</span><span class="sxs-lookup"><span data-stu-id="27f7e-118">Boolean: `bool`</span></span>
  - <span data-ttu-id="27f7e-119">[Типы перечисления][EnumTypes]</span><span class="sxs-lookup"><span data-stu-id="27f7e-119">[Enum types][EnumTypes]</span></span>
    * <span data-ttu-id="27f7e-120">Пользовательские типы в формате `enum E {...}`</span><span class="sxs-lookup"><span data-stu-id="27f7e-120">User-defined types of the form `enum E {...}`</span></span>
  - <span data-ttu-id="27f7e-121">[Типы структур][StructTypes]</span><span class="sxs-lookup"><span data-stu-id="27f7e-121">[Struct types][StructTypes]</span></span>
    * <span data-ttu-id="27f7e-122">Пользовательские типы в формате `struct S {...}`</span><span class="sxs-lookup"><span data-stu-id="27f7e-122">User-defined types of the form `struct S {...}`</span></span>
  - <span data-ttu-id="27f7e-123">[Типы значений, допускающие значение NULL][NullableTypes]</span><span class="sxs-lookup"><span data-stu-id="27f7e-123">[Nullable value types][NullableTypes]</span></span>
    * <span data-ttu-id="27f7e-124">Расширения других типов значений, допускающие значение `null`</span><span class="sxs-lookup"><span data-stu-id="27f7e-124">Extensions of all other value types with a `null` value</span></span>
* <span data-ttu-id="27f7e-125">[Ссылочные типы][ReferenceTypes]</span><span class="sxs-lookup"><span data-stu-id="27f7e-125">[Reference types][ReferenceTypes]</span></span>
  - <span data-ttu-id="27f7e-126">[Типы классов][ClassTypes]</span><span class="sxs-lookup"><span data-stu-id="27f7e-126">[Class types][ClassTypes]</span></span>
    * <span data-ttu-id="27f7e-127">Исходный базовым классом для всех типов: `object`</span><span class="sxs-lookup"><span data-stu-id="27f7e-127">Ultimate base class of all other types: `object`</span></span>
    * <span data-ttu-id="27f7e-128">Строки Юникода: `string`</span><span class="sxs-lookup"><span data-stu-id="27f7e-128">Unicode strings: `string`</span></span>
    * <span data-ttu-id="27f7e-129">Пользовательские типы в формате `class C {...}`</span><span class="sxs-lookup"><span data-stu-id="27f7e-129">User-defined types of the form `class C {...}`</span></span>
  - <span data-ttu-id="27f7e-130">[Типы интерфейса][InterfaceTypes]</span><span class="sxs-lookup"><span data-stu-id="27f7e-130">[Interface types][InterfaceTypes]</span></span>
    * <span data-ttu-id="27f7e-131">Пользовательские типы в формате `interface I {...}`</span><span class="sxs-lookup"><span data-stu-id="27f7e-131">User-defined types of the form `interface I {...}`</span></span>
  - <span data-ttu-id="27f7e-132">[Типы массивов][ArrayTypes]</span><span class="sxs-lookup"><span data-stu-id="27f7e-132">[Array types][ArrayTypes]</span></span>
    * <span data-ttu-id="27f7e-133">Одно- и многомерные, например, `int[]` и `int[,]`</span><span class="sxs-lookup"><span data-stu-id="27f7e-133">Single- and multi-dimensional, for example, `int[]` and `int[,]`</span></span>
  - <span data-ttu-id="27f7e-134">[Тип делегатов][DelegateTypes]</span><span class="sxs-lookup"><span data-stu-id="27f7e-134">[Delegate types][DelegateTypes]</span></span>
    * <span data-ttu-id="27f7e-135">Пользовательские типы в формате `delegate int D(...)`</span><span class="sxs-lookup"><span data-stu-id="27f7e-135">User-defined types of the form `delegate int D(...)`</span></span>

[ValueTypes]: ../language-reference/keywords/value-types-table.md
[SimpleTypes]: ../language-reference/keywords/value-types.md#simple-types
[EnumTypes]: ../language-reference/keywords/enum.md
[StructTypes]: ../language-reference/keywords/struct.md
[NullableTypes]: ../programming-guide/nullable-types/index.md
[ReferenceTypes]: ../language-reference/keywords/reference-types.md
[ClassTypes]: ../language-reference/keywords/class.md
[InterfaceTypes]: ../language-reference/keywords/interface.md
[DelegateTypes]: ../language-reference/keywords/delegate.md
[ArrayTypes]: ../programming-guide/arrays/index.md

<span data-ttu-id="27f7e-136">Восемь целочисленных типов обеспечивают поддержку 8-разрядных, 16-разрядных, 32-разрядных и 64-разрядных значений со знаком или без знака.</span><span class="sxs-lookup"><span data-stu-id="27f7e-136">The eight integral types provide support for 8-bit, 16-bit, 32-bit, and 64-bit values in signed or unsigned form.</span></span>

<span data-ttu-id="27f7e-137">Два типа чисел с плавающей запятой, `float` и `double`, представляются в следующих форматах IEC 60559: 32-разрядный одиночной точности и 64-разрядный двойной точности.</span><span class="sxs-lookup"><span data-stu-id="27f7e-137">The two floating-point types, `float` and `double`, are represented using the 32-bit single-precision and 64-bit double-precision IEC-60559 formats, respectively.</span></span>

<span data-ttu-id="27f7e-138">Тип `decimal` — это 128-разрядный тип данных для финансовых и денежных расчетов.</span><span class="sxs-lookup"><span data-stu-id="27f7e-138">The `decimal` type is a 128-bit data type suitable for financial and monetary calculations.</span></span>

<span data-ttu-id="27f7e-139">Тип `bool` в C# используется для представления логических значений, которые могут иметь значение `true` или `false`.</span><span class="sxs-lookup"><span data-stu-id="27f7e-139">C#’s `bool` type is used to represent Boolean values—values that are either `true` or `false`.</span></span>

<span data-ttu-id="27f7e-140">Обработка знаков и строк в C# выполняется в кодировке Юникода.</span><span class="sxs-lookup"><span data-stu-id="27f7e-140">Character and string processing in C# uses Unicode encoding.</span></span> <span data-ttu-id="27f7e-141">Тип `char` представляет элемент в кодировке UTF-16, а тип `string` представляет последовательность элементов в кодировке UTF-16.</span><span class="sxs-lookup"><span data-stu-id="27f7e-141">The `char` type represents a UTF-16 code unit, and the `string` type represents a sequence of UTF-16 code units.</span></span>

<span data-ttu-id="27f7e-142">Полный список числовых типов в C#.</span><span class="sxs-lookup"><span data-stu-id="27f7e-142">This summarizes C#’s numeric types.</span></span>

* <span data-ttu-id="27f7e-143">Целочисленный со знаком</span><span class="sxs-lookup"><span data-stu-id="27f7e-143">Signed Integral</span></span>
  - <span data-ttu-id="27f7e-144">`sbyte`:  8  бит, в диапазоне от -128 до 127</span><span class="sxs-lookup"><span data-stu-id="27f7e-144">`sbyte`:  8 bits, range from -128 to 127</span></span>
  - <span data-ttu-id="27f7e-145">`short`: 16 бит, в диапазоне от -32 768 до 32 767</span><span class="sxs-lookup"><span data-stu-id="27f7e-145">`short`: 16 bits, range from -32,768 to 32,767</span></span>
  - <span data-ttu-id="27f7e-146">`int`: 32 бита, в диапазоне от -2 147 483 648 до 2 147 483 647</span><span class="sxs-lookup"><span data-stu-id="27f7e-146">`int`  : 32 bits, range from -2,147,483,648 to 2,147,483,647</span></span>
  - <span data-ttu-id="27f7e-147">`long`: 64 бита, в диапазоне от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807</span><span class="sxs-lookup"><span data-stu-id="27f7e-147">`long` : 64 bits, range from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</span></span>
* <span data-ttu-id="27f7e-148">Целочисленный без знака</span><span class="sxs-lookup"><span data-stu-id="27f7e-148">Unsigned integral</span></span>
  - <span data-ttu-id="27f7e-149">`byte`:  8  бит, в диапазоне от 0 до 255</span><span class="sxs-lookup"><span data-stu-id="27f7e-149">`byte`   :  8 bits, range from 0 to 255</span></span>
  - <span data-ttu-id="27f7e-150">`ushort`: 16 бит, в диапазоне от -0 до 65 535</span><span class="sxs-lookup"><span data-stu-id="27f7e-150">`ushort` : 16 bits, range from 0 to 65,535</span></span>
  - <span data-ttu-id="27f7e-151">`uint`: 32 бита, в диапазоне от 0 до 4 294 967 295</span><span class="sxs-lookup"><span data-stu-id="27f7e-151">`uint`   : 32 bits, range from 0 to 4,294,967,295</span></span>
  - <span data-ttu-id="27f7e-152">`ulong`: 64 бита, в диапазоне от 0 до 18 446 744 073 709  551 615</span><span class="sxs-lookup"><span data-stu-id="27f7e-152">`ulong`  : 64 bits, range from 0 to 18,446,744,073,709,551,615</span></span>
* <span data-ttu-id="27f7e-153">С плавающей запятой</span><span class="sxs-lookup"><span data-stu-id="27f7e-153">Floating point</span></span>
  - <span data-ttu-id="27f7e-154">`float`: 32 бита, в диапазоне от 1,5 × 10<sup>-45</sup> до 3,4 × 10<sup>38</sup>, с точностью до 7 цифр</span><span class="sxs-lookup"><span data-stu-id="27f7e-154">`float`  : 32 bits, range from 1.5 × 10<sup>-45</sup> to 3.4 × 10<sup>38</sup>,    7-digit precision</span></span>
  - <span data-ttu-id="27f7e-155">`double`: 64 бита, в диапазоне от 5,0 × 10<sup>-324</sup> до 1,7 × 10<sup>308</sup>, с точностью до 15 цифр</span><span class="sxs-lookup"><span data-stu-id="27f7e-155">`double` : 64 bits, range from 5.0 × 10<sup>-324</sup> to 1.7 × 10<sup>308</sup>, 15-digit precision</span></span>
* <span data-ttu-id="27f7e-156">Десятичное число</span><span class="sxs-lookup"><span data-stu-id="27f7e-156">Decimal</span></span>
  - <span data-ttu-id="27f7e-157">`decimal`: 128 бит, в диапазоне по крайней мере от -7,9 × 10<sup>-28</sup> до 7,9 × 10<sup>28</sup>, с точностью не менее 28 цифр</span><span class="sxs-lookup"><span data-stu-id="27f7e-157">`decimal` : 128 bits, range is at least -7.9 × 10<sup>-28</sup> to 7.9 × 10<sup>28</sup>, with at least 28-digit precision</span></span>

<span data-ttu-id="27f7e-158">Программы C# используют *объявления типов* для создания новых типов.</span><span class="sxs-lookup"><span data-stu-id="27f7e-158">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="27f7e-159">В объявлении типа указываются имя и члены нового типа.</span><span class="sxs-lookup"><span data-stu-id="27f7e-159">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="27f7e-160">Пять категорий типов в C# определяются пользователем: типы классов, типы структур, типы интерфейсов, типы перечисления и типы делегатов.</span><span class="sxs-lookup"><span data-stu-id="27f7e-160">Five of C#’s categories of types are user-definable: class types, struct types, interface types, enum types, and delegate types.</span></span>

<span data-ttu-id="27f7e-161">Тип `class` определяет структуру данных, которая содержит данные-члены (поля) и функции-члены (методы, свойства и т. д.).</span><span class="sxs-lookup"><span data-stu-id="27f7e-161">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="27f7e-162">Классы поддерживают механизмы одиночного наследования и полиморфизма, которые позволяют создавать производные классы, расширяющие и уточняющие определения базовых классов.</span><span class="sxs-lookup"><span data-stu-id="27f7e-162">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>

<span data-ttu-id="27f7e-163">Тип `struct` похож на тип класса тем, что он представляет структуру с данными-членами и функциями-членами.</span><span class="sxs-lookup"><span data-stu-id="27f7e-163">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="27f7e-164">Но в отличие от классов, структуры являются типами значений и обычно не требуют выделения памяти из кучи.</span><span class="sxs-lookup"><span data-stu-id="27f7e-164">However, unlike classes, structs are value types and do not typically require heap allocation.</span></span> <span data-ttu-id="27f7e-165">Типы структуры не поддерживают определяемое пользователем наследование, и все типы структуры неявно наследуют от типа `object`.</span><span class="sxs-lookup"><span data-stu-id="27f7e-165">Struct types do not support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>

<span data-ttu-id="27f7e-166">Тип `interface` (интерфейс) определяет контракт в виде именованного набора открытых функций-членов.</span><span class="sxs-lookup"><span data-stu-id="27f7e-166">An `interface` type defines a contract as a named set of public function members.</span></span> <span data-ttu-id="27f7e-167">Объект типа `class` или `struct`, реализующий `interface`, должен предоставить реализации для всех функций-членов интерфейса.</span><span class="sxs-lookup"><span data-stu-id="27f7e-167">A `class` or `struct` that implements an `interface` must provide implementations of the interface’s function members.</span></span> <span data-ttu-id="27f7e-168">Тип `interface` может наследовать от нескольких базовых интерфейсов, а `class` или `struct` могут реализовывать несколько интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="27f7e-168">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>

<span data-ttu-id="27f7e-169">Тип `delegate` (делегат) представляющий ссылки на методы с конкретным списком параметров и типом возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="27f7e-169">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="27f7e-170">Делегаты позволяют использовать методы как сущности, сохраняя их в переменные и передавая в качестве параметров.</span><span class="sxs-lookup"><span data-stu-id="27f7e-170">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="27f7e-171">Делегаты аналогичны типам функций, которые используются в функциональных языках.</span><span class="sxs-lookup"><span data-stu-id="27f7e-171">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="27f7e-172">Также принцип их работы близок к указателям функций из некоторых языков, но в отличие от указателей функций делегаты являются объектно-ориентированными и строго типизированными.</span><span class="sxs-lookup"><span data-stu-id="27f7e-172">They are also similar to the concept of function pointers found in some other languages, but unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="27f7e-173">Типы `class`, `struct`, `interface` и `delegate` поддерживают универсальные шаблоны, которые позволяют передавать им другие типы в качестве параметров.</span><span class="sxs-lookup"><span data-stu-id="27f7e-173">The `class`, `struct`, `interface` and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="27f7e-174">Тип `enum` является отдельным типом со списком именованных констант.</span><span class="sxs-lookup"><span data-stu-id="27f7e-174">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="27f7e-175">Каждый тип `enum` имеет базовый тип, в роли которого выступает один из восьми целочисленных типов.</span><span class="sxs-lookup"><span data-stu-id="27f7e-175">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="27f7e-176">Набор значений типа `enum` аналогичен набору значений его базового типа.</span><span class="sxs-lookup"><span data-stu-id="27f7e-176">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>

<span data-ttu-id="27f7e-177">C# поддерживает одно- и многомерные массивы любого типа.</span><span class="sxs-lookup"><span data-stu-id="27f7e-177">C# supports single- and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="27f7e-178">В отличие от перечисленных выше типов, типы массивов не требуется объявлять перед использованием.</span><span class="sxs-lookup"><span data-stu-id="27f7e-178">Unlike the types listed above, array types do not have to be declared before they can be used.</span></span> <span data-ttu-id="27f7e-179">Типы массивов можно сформировать, просто введя квадратные скобки после имени типа.</span><span class="sxs-lookup"><span data-stu-id="27f7e-179">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="27f7e-180">Например, `int[]` является одномерным массивом значений типа `int`, а `int[,]` — двумерным массивом значений типа `int`, тогда как `int[][]` представляет собой одномерный массив одномерных массивов значений типа `int`.</span><span class="sxs-lookup"><span data-stu-id="27f7e-180">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional array of `int`.</span></span>

<span data-ttu-id="27f7e-181">Типы значений, допускающие значение Null, также не нужно отдельно объявлять перед использованием.</span><span class="sxs-lookup"><span data-stu-id="27f7e-181">Nullable value types also do not have to be declared before they can be used.</span></span> <span data-ttu-id="27f7e-182">Для каждого обычного типа значений `T`, который не допускает значение Null, существует идентичный тип `T?`, который отличается только тем, что может содержать значение `null`.</span><span class="sxs-lookup"><span data-stu-id="27f7e-182">For each non-nullable value type `T` there is a corresponding nullable value type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="27f7e-183">Например `int?` — это тип, который может содержать любое 32-разрядное целое число или значение `null`.</span><span class="sxs-lookup"><span data-stu-id="27f7e-183">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`.</span></span>

<span data-ttu-id="27f7e-184">Система типов в C# унифицирована таким образом, что значение любого типа можно рассматривать как `object` (объект).</span><span class="sxs-lookup"><span data-stu-id="27f7e-184">C#’s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="27f7e-185">Каждый тип в C# является прямо или косвенно производным от типа класса `object`, и этот тип `object` является исходным базовым классом для всех типов.</span><span class="sxs-lookup"><span data-stu-id="27f7e-185">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="27f7e-186">Чтобы значения ссылочного типа обрабатывались как объекты, им просто присваивается тип `object`.</span><span class="sxs-lookup"><span data-stu-id="27f7e-186">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="27f7e-187">Чтобы значения типов значений обрабатывались как объекты, выполняются операции *упаковки-преобразования* и *распаковки-преобразования*.</span><span class="sxs-lookup"><span data-stu-id="27f7e-187">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="27f7e-188">В следующем примере значение `int` преобразуется в `object`, а затем обратно в `int`.</span><span class="sxs-lookup"><span data-stu-id="27f7e-188">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

[!code-csharp[Boxing](../../../samples/snippets/csharp/tour/types-and-variables/Program.cs#L1-L10)]

<span data-ttu-id="27f7e-189">Если значение для типа значения преобразуется в тип `object`, то для хранения этого значения выделяется экземпляр `object`, который также называется "упаковкой", и значение копируется в эту упаковку.</span><span class="sxs-lookup"><span data-stu-id="27f7e-189">When a value of a value type is converted to type `object`, an `object` instance, also called a "box", is allocated to hold the value, and the value is copied into that box.</span></span> <span data-ttu-id="27f7e-190">И наоборот, если ссылка типа `object` используется для типа значения, для соответствующего `object` выполняется проверка, является ли он упаковкой правильного типа. Если эта проверка завершается успешно, копируется значение этой упаковки.</span><span class="sxs-lookup"><span data-stu-id="27f7e-190">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type, and, if the check succeeds, the value in the box is copied out.</span></span>

<span data-ttu-id="27f7e-191">Унифицированная система типов C# фактически позволяет преобразовывать типы значений в объекты "по требованию".</span><span class="sxs-lookup"><span data-stu-id="27f7e-191">C#’s unified type system effectively means that value types can become objects "on demand."</span></span> <span data-ttu-id="27f7e-192">Такая унификация позволяет применять универсальные библиотеки, использующие тип `object`, как со ссылочными типами, так и с типами значений.</span><span class="sxs-lookup"><span data-stu-id="27f7e-192">Because of the unification, general-purpose libraries that use type `object` can be used with both reference types and value types.</span></span>

<span data-ttu-id="27f7e-193">В C# существует несколько типов *переменных*, в том числе поля, элементы массива, локальные переменные и параметры.</span><span class="sxs-lookup"><span data-stu-id="27f7e-193">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="27f7e-194">Переменные представляют места хранения, и каждая переменная имеет тип, который определяет допустимые значения для хранения в этой переменной. Примеры представлены ниже.</span><span class="sxs-lookup"><span data-stu-id="27f7e-194">Variables represent storage locations, and every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

* <span data-ttu-id="27f7e-195">Тип значения, не допускающий значения Null</span><span class="sxs-lookup"><span data-stu-id="27f7e-195">Non-nullable value type</span></span>
  - <span data-ttu-id="27f7e-196">Значение такого типа</span><span class="sxs-lookup"><span data-stu-id="27f7e-196">A value of that exact type</span></span>
* <span data-ttu-id="27f7e-197">Тип значения, допускающий значение Null</span><span class="sxs-lookup"><span data-stu-id="27f7e-197">Nullable value type</span></span>
  - <span data-ttu-id="27f7e-198">Значение `null` или значение такого типа</span><span class="sxs-lookup"><span data-stu-id="27f7e-198">A `null` value or a value of that exact type</span></span>
* <span data-ttu-id="27f7e-199">object</span><span class="sxs-lookup"><span data-stu-id="27f7e-199">object</span></span>
  - <span data-ttu-id="27f7e-200">Ссылка `null`, ссылка на объект любого ссылочного типа или ссылка на упакованное значение любого типа значения</span><span class="sxs-lookup"><span data-stu-id="27f7e-200">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
* <span data-ttu-id="27f7e-201">Тип класса</span><span class="sxs-lookup"><span data-stu-id="27f7e-201">Class type</span></span>
  - <span data-ttu-id="27f7e-202">Ссылка `null`, ссылка на экземпляр такого типа класса или ссылка на экземпляр любого класса, производного от такого типа класса</span><span class="sxs-lookup"><span data-stu-id="27f7e-202">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
* <span data-ttu-id="27f7e-203">Тип интерфейса</span><span class="sxs-lookup"><span data-stu-id="27f7e-203">Interface type</span></span>
  - <span data-ttu-id="27f7e-204">Ссылка `null`, ссылка на экземпляр типа класса, который реализует такой тип интерфейса, или ссылка на упакованное значение типа значения, которое реализует такой тип интерфейса</span><span class="sxs-lookup"><span data-stu-id="27f7e-204">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
* <span data-ttu-id="27f7e-205">Тип массива</span><span class="sxs-lookup"><span data-stu-id="27f7e-205">Array type</span></span>
  - <span data-ttu-id="27f7e-206">Ссылка `null`, ссылка на экземпляр такого типа массива или ссылка на экземпляр любого совместимого типа массива</span><span class="sxs-lookup"><span data-stu-id="27f7e-206">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
* <span data-ttu-id="27f7e-207">Тип делегата</span><span class="sxs-lookup"><span data-stu-id="27f7e-207">Delegate type</span></span>
  - <span data-ttu-id="27f7e-208">Ссылка `null` или ссылка на экземпляр совместимого типа делегата</span><span class="sxs-lookup"><span data-stu-id="27f7e-208">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="27f7e-209">[Назад](program-structure.md)
> [Вперед](expressions.md)</span><span class="sxs-lookup"><span data-stu-id="27f7e-209">[Previous](program-structure.md)
[Next](expressions.md)</span></span>
