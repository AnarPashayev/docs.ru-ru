---
title: Классы и объекты в C#. Краткий обзор языка C#
description: Вы еще не знакомы с C#? Этот обзор познакомит вас с понятиями классов, объектов и наследования
ms.date: 02/27/2020
ms.assetid: 63a89bde-0f05-4bc4-b0cd-4f693854f0cd
ms.openlocfilehash: c178e11b5667905f75538555c8a309e2fdb4a9ef
ms.sourcegitcommit: 00aa62e2f469c2272a457b04e66b4cc3c97a800b
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/28/2020
ms.locfileid: "78159186"
---
# <a name="classes-and-objects"></a><span data-ttu-id="4d06a-104">Классы и объекты</span><span class="sxs-lookup"><span data-stu-id="4d06a-104">Classes and objects</span></span>

<span data-ttu-id="4d06a-105">*Классы* являются основным типом в языке C#.</span><span class="sxs-lookup"><span data-stu-id="4d06a-105">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="4d06a-106">Класс представляет собой структуру данных, которая объединяет в себе значения (поля) и действия (методы и другие функции-члены).</span><span class="sxs-lookup"><span data-stu-id="4d06a-106">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="4d06a-107">Класс предоставляет определение для динамически создаваемых *экземпляров* класса, которые также именуются *объектами*.</span><span class="sxs-lookup"><span data-stu-id="4d06a-107">A class provides a definition for dynamically created *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="4d06a-108">Классы поддерживают механизмы *наследования* и *полиморфизма*, которые позволяют создавать *производные классы*, расширяющие и уточняющие определения *базовых классов*.</span><span class="sxs-lookup"><span data-stu-id="4d06a-108">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="4d06a-109">Новые классы создаются с помощью объявлений классов.</span><span class="sxs-lookup"><span data-stu-id="4d06a-109">New classes are created using class declarations.</span></span> <span data-ttu-id="4d06a-110">Объявление класса начинается с заголовка, в котором указаны атрибуты и модификаторы класса, имя класса, базовый класс (если есть) и интерфейсы, реализуемые этим классом.</span><span class="sxs-lookup"><span data-stu-id="4d06a-110">A class declaration starts with a header that specifies the attributes and modifiers of the class, the name of the class, the base class (if given), and the interfaces implemented by the class.</span></span> <span data-ttu-id="4d06a-111">За заголовком между разделителями `{` и `}` следует тело класса, в котором последовательно объявляются все члены класса.</span><span class="sxs-lookup"><span data-stu-id="4d06a-111">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="4d06a-112">Следующий код является простым примером объявления класса с именем `Point`:</span><span class="sxs-lookup"><span data-stu-id="4d06a-112">The following code shows a declaration of a simple class named `Point`:</span></span>

[!code-csharp[PointClass](~/samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L11)]

<span data-ttu-id="4d06a-113">Экземпляры классов создаются с помощью оператора `new`, который выделяет память для нового экземпляра, вызывает конструктор для инициализации этого экземпляра и возвращает ссылку на экземпляр.</span><span class="sxs-lookup"><span data-stu-id="4d06a-113">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="4d06a-114">Следующие инструкции создают два объекта Point и сохраняют ссылки на них в две переменные:</span><span class="sxs-lookup"><span data-stu-id="4d06a-114">The following statements create two Point objects and store references to those objects in two variables:</span></span>

[!code-csharp[PointExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L9-L10)]

<span data-ttu-id="4d06a-115">Занимаемая объектом память автоматически освобождается, когда объект становится недоступен.</span><span class="sxs-lookup"><span data-stu-id="4d06a-115">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="4d06a-116">В C# нет ни необходимости, ни возможности освобождать память объектов явным образом.</span><span class="sxs-lookup"><span data-stu-id="4d06a-116">It's neither necessary nor possible to explicitly deallocate objects in C#.</span></span>

## <a name="members"></a><span data-ttu-id="4d06a-117">Участники</span><span class="sxs-lookup"><span data-stu-id="4d06a-117">Members</span></span>

<span data-ttu-id="4d06a-118">Члены класса могут быть статическими членами или членами экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4d06a-118">The members of a class are either static members or instance members.</span></span> <span data-ttu-id="4d06a-119">Статические члены принадлежат классу в целом, а члены экземпляра принадлежат конкретным объектам (экземплярам классов).</span><span class="sxs-lookup"><span data-stu-id="4d06a-119">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="4d06a-120">Ниже перечислены виды членов, которые могут содержаться в классе.</span><span class="sxs-lookup"><span data-stu-id="4d06a-120">The following list provides an overview of the kinds of members a class can contain.</span></span>

- <span data-ttu-id="4d06a-121">Константы</span><span class="sxs-lookup"><span data-stu-id="4d06a-121">Constants</span></span>
  - <span data-ttu-id="4d06a-122">Константные значения, связанные с классом.</span><span class="sxs-lookup"><span data-stu-id="4d06a-122">Constant values associated with the class</span></span>
- <span data-ttu-id="4d06a-123">Поля</span><span class="sxs-lookup"><span data-stu-id="4d06a-123">Fields</span></span>
  - <span data-ttu-id="4d06a-124">Переменные класса.</span><span class="sxs-lookup"><span data-stu-id="4d06a-124">Variables of the class</span></span>
- <span data-ttu-id="4d06a-125">Методы</span><span class="sxs-lookup"><span data-stu-id="4d06a-125">Methods</span></span>
  - <span data-ttu-id="4d06a-126">Вычисления и действия, которые может выполнять класс.</span><span class="sxs-lookup"><span data-stu-id="4d06a-126">Computations and actions that can be performed by the class</span></span>
- <span data-ttu-id="4d06a-127">Свойства</span><span class="sxs-lookup"><span data-stu-id="4d06a-127">Properties</span></span>
  - <span data-ttu-id="4d06a-128">Действия, связанные с чтением и записью именованных свойств класса.</span><span class="sxs-lookup"><span data-stu-id="4d06a-128">Actions associated with reading and writing named properties of the class</span></span>
- <span data-ttu-id="4d06a-129">Индексаторы</span><span class="sxs-lookup"><span data-stu-id="4d06a-129">Indexers</span></span>
  - <span data-ttu-id="4d06a-130">Действия, реализующие индексирование экземпляров класса, чтобы обращаться к ним как к массиву.</span><span class="sxs-lookup"><span data-stu-id="4d06a-130">Actions associated with indexing instances of the class like an array</span></span>
- <span data-ttu-id="4d06a-131">События</span><span class="sxs-lookup"><span data-stu-id="4d06a-131">Events</span></span>
  - <span data-ttu-id="4d06a-132">Уведомления, которые могут быть созданы этим классом.</span><span class="sxs-lookup"><span data-stu-id="4d06a-132">Notifications that can be generated by the class</span></span>
- <span data-ttu-id="4d06a-133">Операторы</span><span class="sxs-lookup"><span data-stu-id="4d06a-133">Operators</span></span>
  - <span data-ttu-id="4d06a-134">Поддерживаемые классом операторы преобразования и выражения.</span><span class="sxs-lookup"><span data-stu-id="4d06a-134">Conversions and expression operators supported by the class</span></span>
- <span data-ttu-id="4d06a-135">Конструкторы</span><span class="sxs-lookup"><span data-stu-id="4d06a-135">Constructors</span></span>
  - <span data-ttu-id="4d06a-136">Действия, необходимые для инициализации экземпляров класса или класса в целом.</span><span class="sxs-lookup"><span data-stu-id="4d06a-136">Actions required to initialize instances of the class or the class itself</span></span>
- <span data-ttu-id="4d06a-137">Методы завершения</span><span class="sxs-lookup"><span data-stu-id="4d06a-137">Finalizers</span></span>
  - <span data-ttu-id="4d06a-138">Действия, выполняемые перед окончательным удалением экземпляров класса.</span><span class="sxs-lookup"><span data-stu-id="4d06a-138">Actions to perform before instances of the class are permanently discarded</span></span>
- <span data-ttu-id="4d06a-139">Типы</span><span class="sxs-lookup"><span data-stu-id="4d06a-139">Types</span></span>
  - <span data-ttu-id="4d06a-140">Вложенные типы, объявленные в классе.</span><span class="sxs-lookup"><span data-stu-id="4d06a-140">Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="4d06a-141">Специальные возможности</span><span class="sxs-lookup"><span data-stu-id="4d06a-141">Accessibility</span></span>

<span data-ttu-id="4d06a-142">Каждый член класса имеет определенный уровень доступности. Он определяет, из какой области программы можно обращаться к этому члену.</span><span class="sxs-lookup"><span data-stu-id="4d06a-142">Each member of a class has an associated accessibility, which controls the regions of program text that can access the member.</span></span> <span data-ttu-id="4d06a-143">Существует шесть уровней доступности.</span><span class="sxs-lookup"><span data-stu-id="4d06a-143">There are six possible forms of accessibility.</span></span> <span data-ttu-id="4d06a-144">Ниже приведены модификаторы доступа.</span><span class="sxs-lookup"><span data-stu-id="4d06a-144">The access modifiers are summarized below.</span></span>

- `public`
  - <span data-ttu-id="4d06a-145">Доступ не ограничен.</span><span class="sxs-lookup"><span data-stu-id="4d06a-145">Access isn't limited.</span></span>
- `protected`
  - <span data-ttu-id="4d06a-146">Доступ возможен из этого класса и из классов, производных от него.</span><span class="sxs-lookup"><span data-stu-id="4d06a-146">Access is limited to this class or classes derived from this class.</span></span>
- `internal`
  - <span data-ttu-id="4d06a-147">Доступ ограничен только текущей сборкой (EXE, DLL и т. д.).</span><span class="sxs-lookup"><span data-stu-id="4d06a-147">Access is limited to the current assembly (.exe, .dll, and so on.).</span></span>
- `protected internal`
  - <span data-ttu-id="4d06a-148">Доступ ограничен содержащим классом, классами, производными от содержащего класса, либо классами в той же сборке.</span><span class="sxs-lookup"><span data-stu-id="4d06a-148">Access is limited to the containing class, classes derived from the containing class, or classes within the same assembly.</span></span>
- `private`
  - <span data-ttu-id="4d06a-149">Доступ возможен только из этого класса.</span><span class="sxs-lookup"><span data-stu-id="4d06a-149">Access is limited to this class.</span></span>
- `private protected`
  - <span data-ttu-id="4d06a-150">Доступ ограничен содержащим классом или классами, которые являются производными от содержащего типа в той же сборке.</span><span class="sxs-lookup"><span data-stu-id="4d06a-150">Access is limited to the containing class or classes derived from the containing type within the same assembly.</span></span>

## <a name="type-parameters"></a><span data-ttu-id="4d06a-151">Параметры типа</span><span class="sxs-lookup"><span data-stu-id="4d06a-151">Type parameters</span></span>

<span data-ttu-id="4d06a-152">Определение класса может задать набор параметров типа. Список имен параметров типа указывается в угловых скобках после имени класса.</span><span class="sxs-lookup"><span data-stu-id="4d06a-152">A class definition may specify a set of type parameters by following the class name with angle brackets enclosing a list of type parameter names.</span></span> <span data-ttu-id="4d06a-153">Параметры типа можно использовать в теле класса в определениях, описывающих члены класса.</span><span class="sxs-lookup"><span data-stu-id="4d06a-153">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="4d06a-154">В следующем примере для класса `Pair` заданы параметры типа `TFirst` и `TSecond`:</span><span class="sxs-lookup"><span data-stu-id="4d06a-154">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

[!code-csharp[Pair](~/samples/snippets/csharp/tour/classes-and-objects/Pair.cs#L3-L7)]

<span data-ttu-id="4d06a-155">Тип класса, для которого объявлены параметры типа, называется *универсальным типом класса*.</span><span class="sxs-lookup"><span data-stu-id="4d06a-155">A class type that is declared to take type parameters is called a *generic class type*.</span></span> <span data-ttu-id="4d06a-156">Типы структуры, интерфейса и делегата также могут быть универсальными.</span><span class="sxs-lookup"><span data-stu-id="4d06a-156">Struct, interface, and delegate types can also be generic.</span></span>
<span data-ttu-id="4d06a-157">Если вы используете универсальный класс, необходимо указать аргумент типа для каждого параметра типа, вот так:</span><span class="sxs-lookup"><span data-stu-id="4d06a-157">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

[!code-csharp[PairExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L15-L17)]

<span data-ttu-id="4d06a-158">Универсальный тип, для которого указаны аргументы типа, как `Pair<int,string>` в примере выше, называется *сконструированным типом*.</span><span class="sxs-lookup"><span data-stu-id="4d06a-158">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

## <a name="base-classes"></a><span data-ttu-id="4d06a-159">базовых классов;</span><span class="sxs-lookup"><span data-stu-id="4d06a-159">Base classes</span></span>

<span data-ttu-id="4d06a-160">В объявлении класса можно указать базовый класс, включив имя базового класса после имени класса и параметров типа, и отделив его двоеточием.</span><span class="sxs-lookup"><span data-stu-id="4d06a-160">A class declaration may specify a base class by following the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="4d06a-161">Если спецификация базового класса не указана, класс наследуется от типа `object`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-161">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="4d06a-162">В следующем примере `Point3D` имеет базовый класс `Point`, а `Point` — базовый класс `object`:</span><span class="sxs-lookup"><span data-stu-id="4d06a-162">In the following example, the base class of `Point3D` is `Point`, and the base class of `Point` is `object`:</span></span>

[!code-csharp[Point3DClass](~/samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L20)]

<span data-ttu-id="4d06a-163">Класс наследует члены базового класса.</span><span class="sxs-lookup"><span data-stu-id="4d06a-163">A class inherits the members of its base class.</span></span> <span data-ttu-id="4d06a-164">Наследование означает, что класс неявно содержит все члены своего базового класса, за исключением конструкторов экземпляра, статических конструкторов и методов завершения базового класса.</span><span class="sxs-lookup"><span data-stu-id="4d06a-164">Inheritance means that a class implicitly contains all members of its base class, except for the instance and static constructors, and the finalizers of the base class.</span></span> <span data-ttu-id="4d06a-165">Производный класс может добавлять новые члены к наследуемым, но не может удалить определение для наследуемого члена.</span><span class="sxs-lookup"><span data-stu-id="4d06a-165">A derived class can add new members to those members it inherits, but it can't remove the definition of an inherited member.</span></span> <span data-ttu-id="4d06a-166">В предыдущем примере `Point3D` наследует поля `x` и `y` из `Point`, и каждый экземпляр `Point3D` содержит три поля: `x`, `y` и `z`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-166">In the previous example, `Point3D` inherits the `x` and `y` fields from `Point`, and every `Point3D` instance contains three fields, `x`, `y`, and `z`.</span></span>

<span data-ttu-id="4d06a-167">Используется неявное преобразование из типа класса к любому из типов соответствующего базового класса.</span><span class="sxs-lookup"><span data-stu-id="4d06a-167">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="4d06a-168">Переменная типа класса может ссылаться как на экземпляр этого класса, так и на экземпляры любого производного класса.</span><span class="sxs-lookup"><span data-stu-id="4d06a-168">A variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="4d06a-169">Например, если мы используем описанные выше объявления классов, то переменная типа `Point` может ссылаться на `Point` или `Point3D`:</span><span class="sxs-lookup"><span data-stu-id="4d06a-169">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

[!code-csharp[Point3DExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L22-L23)]

## <a name="fields"></a><span data-ttu-id="4d06a-170">Поля</span><span class="sxs-lookup"><span data-stu-id="4d06a-170">Fields</span></span>

<span data-ttu-id="4d06a-171">*Поле* является переменной, связанной с определенным классом или экземпляром класса.</span><span class="sxs-lookup"><span data-stu-id="4d06a-171">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="4d06a-172">Поле, объявленное с модификатором static, является статическим.</span><span class="sxs-lookup"><span data-stu-id="4d06a-172">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="4d06a-173">Статическое поле определяет строго одно место хранения.</span><span class="sxs-lookup"><span data-stu-id="4d06a-173">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="4d06a-174">Независимо от того, сколько будет создано экземпляров этого класса, существует только одна копия статического поля.</span><span class="sxs-lookup"><span data-stu-id="4d06a-174">No matter how many instances of a class are created, there's only ever one copy of a static field.</span></span>

<span data-ttu-id="4d06a-175">Поле, объявленное без модификатора static, является полем экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4d06a-175">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="4d06a-176">Каждый экземпляр класса содержит отдельные копии всех полей экземпляра, определенных для этого класса.</span><span class="sxs-lookup"><span data-stu-id="4d06a-176">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="4d06a-177">В следующем примере каждый экземпляр класса `Color` содержит отдельную копию полей экземпляра `r`, `g` и `b`, но для каждого из статических полей `Black`, `White`, `Red`, `Green` и `Blue` существует только одна копия:</span><span class="sxs-lookup"><span data-stu-id="4d06a-177">In the following example, each instance of the `Color` class has a separate copy of the `r`, `g`, and `b` instance fields, but there's only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

[!code-csharp[ColorClass](~/samples/snippets/csharp/tour/classes-and-objects/Color.cs#L3-L17)]

<span data-ttu-id="4d06a-178">Как показано в предыдущем примере, можно объявить *поля только для чтения*, используя модификатор `readonly`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-178">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="4d06a-179">Присвоение значения полю `readonly` может происходить только при объявлении этого поля или в конструкторе этого класса.</span><span class="sxs-lookup"><span data-stu-id="4d06a-179">Assignment to a `readonly` field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="4d06a-180">Методы</span><span class="sxs-lookup"><span data-stu-id="4d06a-180">Methods</span></span>

<span data-ttu-id="4d06a-181">*Метод* — это член, реализующий вычисление или действие, которое может выполнять объект или класс.</span><span class="sxs-lookup"><span data-stu-id="4d06a-181">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="4d06a-182">Доступ к *статическим методам* осуществляется через класс.</span><span class="sxs-lookup"><span data-stu-id="4d06a-182">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="4d06a-183">Доступ к *методам экземпляра* осуществляется через экземпляр класса.</span><span class="sxs-lookup"><span data-stu-id="4d06a-183">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="4d06a-184">Для метода можно определить список *параметров*, которые представляют переданные методу значения или ссылки на переменные, а также *возвращаемый тип*, который задает тип значения, вычисляемого и возвращаемого методом.</span><span class="sxs-lookup"><span data-stu-id="4d06a-184">Methods may have a list of *parameters*, which represent values or variable references passed to the method, and a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="4d06a-185">Если метод не возвращает значение, для него устанавливается тип возвращаемого значения `void`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-185">A method’s return type is `void` if it doesn't return a value.</span></span>

<span data-ttu-id="4d06a-186">Как и типы, методы могут иметь набор параметров типа, для которых при вызове метода необходимо указывать аргументы типа.</span><span class="sxs-lookup"><span data-stu-id="4d06a-186">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="4d06a-187">В отличие от типов, аргументы типа зачастую могут выводиться из аргументов вызова метода, и тогда их не обязательно задавать явным образом.</span><span class="sxs-lookup"><span data-stu-id="4d06a-187">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="4d06a-188">*Сигнатура* метода должна быть уникальной в пределах класса, в котором объявлен этот метод.</span><span class="sxs-lookup"><span data-stu-id="4d06a-188">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="4d06a-189">Сигнатура метода включает имя метода, количество параметров типа, а также количество, модификаторы и типы параметров метода.</span><span class="sxs-lookup"><span data-stu-id="4d06a-189">The signature of a method consists of the name of the method, the number of type parameters and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="4d06a-190">Сигнатура метода не включает тип возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="4d06a-190">The signature of a method doesn't include the return type.</span></span>

### <a name="parameters"></a><span data-ttu-id="4d06a-191">Параметры</span><span class="sxs-lookup"><span data-stu-id="4d06a-191">Parameters</span></span>

<span data-ttu-id="4d06a-192">Параметры позволяют передать в метод значения или ссылки на переменные.</span><span class="sxs-lookup"><span data-stu-id="4d06a-192">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="4d06a-193">Фактические значения параметрам метода присваиваются на основе *аргументов*, заданных при вызове метода.</span><span class="sxs-lookup"><span data-stu-id="4d06a-193">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="4d06a-194">Существует четыре типа параметров: параметры значения, ссылочные параметры, параметры вывода и массивы параметров.</span><span class="sxs-lookup"><span data-stu-id="4d06a-194">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="4d06a-195">*Параметр значения* используется для передачи входных аргументов.</span><span class="sxs-lookup"><span data-stu-id="4d06a-195">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="4d06a-196">Параметр значения сопоставляется с локальной переменной, которая получит начальное значение из значения аргумента, переданного в этом параметре.</span><span class="sxs-lookup"><span data-stu-id="4d06a-196">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="4d06a-197">Изменения параметра значения не влияют на аргумент, переданный для этого параметра.</span><span class="sxs-lookup"><span data-stu-id="4d06a-197">Modifications to a value parameter don't affect the argument that was passed for the parameter.</span></span>

<span data-ttu-id="4d06a-198">Параметры значения можно сделать необязательными, указав для них значения по умолчанию. Тогда соответствующие аргументы можно не указывать.</span><span class="sxs-lookup"><span data-stu-id="4d06a-198">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="4d06a-199">*Ссылочный параметр* используется для передачи аргументов по ссылке.</span><span class="sxs-lookup"><span data-stu-id="4d06a-199">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="4d06a-200">Аргумент, передаваемый в качестве ссылочного параметра, должен представлять собой переменную с определенным значением. При выполнении метода ссылочный параметр указывает на то же место хранения, в котором размещена переменная аргумента.</span><span class="sxs-lookup"><span data-stu-id="4d06a-200">The argument passed for a reference parameter must be a variable with a definite value, and during execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="4d06a-201">Чтобы объявить ссылочный параметр, используйте модификатор `ref`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-201">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="4d06a-202">Следующий пример кода демонстрирует использование параметров `ref`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-202">The following example shows the use of `ref` parameters.</span></span>

[!code-csharp[swapExample](~/samples/snippets/csharp/tour/classes-and-objects/RefExample.cs#L3-L18)]

<span data-ttu-id="4d06a-203">*Параметр вывода* используется для передачи аргументов по ссылке.</span><span class="sxs-lookup"><span data-stu-id="4d06a-203">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="4d06a-204">Он похож на ссылочный параметр, однако не требует явно присваивать значение аргумента, предоставляемого вызывающим объектом.</span><span class="sxs-lookup"><span data-stu-id="4d06a-204">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="4d06a-205">Чтобы объявить параметр вывода, используйте модификатор `out`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-205">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="4d06a-206">В следующем примере показано использование параметров `out` с помощью синтаксиса, появившегося в C# 7.</span><span class="sxs-lookup"><span data-stu-id="4d06a-206">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

[!code-csharp[OutExample](~/samples/snippets/csharp/tour/classes-and-objects/OutExample.cs#L3-L17)]

<span data-ttu-id="4d06a-207">*Массив параметров* позволяет передавать в метод переменное число аргументов.</span><span class="sxs-lookup"><span data-stu-id="4d06a-207">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="4d06a-208">Чтобы объявить массив параметров, используйте модификатор `params`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-208">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="4d06a-209">Массив параметров может быть только последним параметром в методе. Для него можно использовать только тип одномерного массива.</span><span class="sxs-lookup"><span data-stu-id="4d06a-209">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="4d06a-210">В качестве примера правильного использования массива параметров можно назвать методы Write и WriteLine, реализованные в классе <xref:System.Console?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4d06a-210">The Write and WriteLine methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="4d06a-211">Ниже представлены объявления этих методов.</span><span class="sxs-lookup"><span data-stu-id="4d06a-211">They're declared as follows.</span></span>

[!code-csharp[ConsoleExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L78-L83)]

<span data-ttu-id="4d06a-212">Внутри метода массив параметров полностью идентичен обычному параметру типа массив.</span><span class="sxs-lookup"><span data-stu-id="4d06a-212">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="4d06a-213">Но зато при вызове метода, использующего массив параметров, ему можно передать либо один аргумент типа массив, либо любое количество аргументов типа элемент для массива параметров.</span><span class="sxs-lookup"><span data-stu-id="4d06a-213">However, in an invocation of a method with a parameter array, it's possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="4d06a-214">В последнем случае экземпляр массива автоматически создается и инициализируется с заданными аргументами.</span><span class="sxs-lookup"><span data-stu-id="4d06a-214">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="4d06a-215">Код из этого примера...</span><span class="sxs-lookup"><span data-stu-id="4d06a-215">This example</span></span>

[!code-csharp[StringFormat](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L55-L55)]

<span data-ttu-id="4d06a-216">...эквивалентен следующей конструкции:</span><span class="sxs-lookup"><span data-stu-id="4d06a-216">is equivalent to writing the following.</span></span>

[!code-csharp[StringFormat2](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L30-L35)]

### <a name="method-body-and-local-variables"></a><span data-ttu-id="4d06a-217">Тело метода и локальные переменные</span><span class="sxs-lookup"><span data-stu-id="4d06a-217">Method body and local variables</span></span>

<span data-ttu-id="4d06a-218">Тело метода содержит инструкции, которые будут выполнены при вызове метода.</span><span class="sxs-lookup"><span data-stu-id="4d06a-218">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="4d06a-219">В теле метода можно объявлять переменные, относящиеся к выполнению этого метода.</span><span class="sxs-lookup"><span data-stu-id="4d06a-219">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="4d06a-220">Такие переменные называются *локальными переменными*.</span><span class="sxs-lookup"><span data-stu-id="4d06a-220">Such variables are called *local variables*.</span></span> <span data-ttu-id="4d06a-221">В объявлении локальной переменной нужно указать имя типа и имя переменной. Также можно задать ее начальное значение.</span><span class="sxs-lookup"><span data-stu-id="4d06a-221">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="4d06a-222">Следующий пример кода объявляет локальную переменную `i` с нулевым начальным значением, и еще одну локальную переменную `j` без начального значения.</span><span class="sxs-lookup"><span data-stu-id="4d06a-222">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

[!code-csharp[Squares](~/samples/snippets/csharp/tour/classes-and-objects/Squares.cs#L3-L17)]

<span data-ttu-id="4d06a-223">C# требует, чтобы локальной переменной было *явно присвоено значение*, прежде чем можно будет получить это значение.</span><span class="sxs-lookup"><span data-stu-id="4d06a-223">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="4d06a-224">Например, если в предложенное выше объявление `i` не включить начальное значение, компилятор сообщит об ошибке при последующем использовании `i`, так как для `i` нет явно присвоенного значения.</span><span class="sxs-lookup"><span data-stu-id="4d06a-224">For example, if the declaration of the previous `i` didn't include an initial value, the compiler would report an error for the subsequent usages of `i` because `i` wouldn't be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="4d06a-225">Метод может использовать инструкцию `return`, чтобы вернуть управление вызывающему объекту.</span><span class="sxs-lookup"><span data-stu-id="4d06a-225">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="4d06a-226">Если метод возвращает `void`, инструкции `return` не могут указывать выражение.</span><span class="sxs-lookup"><span data-stu-id="4d06a-226">In a method returning `void`, `return` statements can't specify an expression.</span></span> <span data-ttu-id="4d06a-227">В методе, выходное значение которого имеет любой другой тип, инструкции `return` должны содержать выражение, которое вычисляет возвращаемое значение.</span><span class="sxs-lookup"><span data-stu-id="4d06a-227">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="4d06a-228">Статические методы и методы экземпляра</span><span class="sxs-lookup"><span data-stu-id="4d06a-228">Static and instance methods</span></span>

<span data-ttu-id="4d06a-229">Метод, объявленный с модификатором static, является *статическим методом*.</span><span class="sxs-lookup"><span data-stu-id="4d06a-229">A method declared with a static modifier is a *static method*.</span></span> <span data-ttu-id="4d06a-230">Статический метод не работает с конкретным экземпляром и может напрямую обращаться только к статическим членам.</span><span class="sxs-lookup"><span data-stu-id="4d06a-230">A static method doesn't operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="4d06a-231">Метод, объявленный без модификатора static, является *методом экземпляра*.</span><span class="sxs-lookup"><span data-stu-id="4d06a-231">A method declared without a static modifier is an *instance method*.</span></span> <span data-ttu-id="4d06a-232">Метод экземпляра работает в определенном экземпляре и может обращаться как к статическим методам, так и к методам этого экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4d06a-232">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="4d06a-233">В методе можно напрямую обратиться к экземпляру, для которого этот метод был вызван, используя дескриптор `this`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-233">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="4d06a-234">Использование ссылки на `this` в статическом методе является недопустимым.</span><span class="sxs-lookup"><span data-stu-id="4d06a-234">It's an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="4d06a-235">Следующий класс `Entity` содержит статические члены и члены экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4d06a-235">The following `Entity` class has both static and instance members.</span></span>

[!code-csharp[Entity](~/samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L16-L36)]

<span data-ttu-id="4d06a-236">Каждый экземпляр `Entity` содержит серийный номер (и может содержать другие данные, которые здесь не показаны).</span><span class="sxs-lookup"><span data-stu-id="4d06a-236">Each `Entity` instance contains a serial number (and presumably some other information that isn't shown here).</span></span> <span data-ttu-id="4d06a-237">Конструктор объекта `Entity` (который рассматривается как метод экземпляра) задает для нового экземпляра следующий доступный серийный номер.</span><span class="sxs-lookup"><span data-stu-id="4d06a-237">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="4d06a-238">Поскольку конструктор является членом экземпляра, он может обращаться как к полю экземпляра `serialNo`, так и к статическому полю `nextSerialNo`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-238">Because the constructor is an instance member, it's permitted to access both the `serialNo` instance field and the `nextSerialNo` static field.</span></span>

<span data-ttu-id="4d06a-239">Статические методы `GetNextSerialNo` и `SetNextSerialNo` могут обращаться к статическому полю `nextSerialNo`, но прямое обращение из них к полю экземпляра `serialNo` приводит к ошибке.</span><span class="sxs-lookup"><span data-stu-id="4d06a-239">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `nextSerialNo` static field, but it would be an error for them to directly access the `serialNo` instance field.</span></span>

<span data-ttu-id="4d06a-240">В следующем примере показано использование класса Entity.</span><span class="sxs-lookup"><span data-stu-id="4d06a-240">The following example shows the use of the Entity class.</span></span>

[!code-csharp[EntityExample](~/samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L3-L15)]

<span data-ttu-id="4d06a-241">Статические методы `SetNextSerialNo` и `GetNextSerialNo` вызываются для класса, а метод экземпляра `GetSerialNo` вызывается для экземпляров класса.</span><span class="sxs-lookup"><span data-stu-id="4d06a-241">The `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="4d06a-242">Виртуальные, переопределяющие и абстрактные методы</span><span class="sxs-lookup"><span data-stu-id="4d06a-242">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="4d06a-243">Если объявление метода экземпляра включает модификатор `virtual`, такой метод называется *виртуальным методом*.</span><span class="sxs-lookup"><span data-stu-id="4d06a-243">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="4d06a-244">Если модификатор virtual отсутствует, метод считается *невиртуальным*.</span><span class="sxs-lookup"><span data-stu-id="4d06a-244">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="4d06a-245">При вызове виртуального метода могут быть вызваны разные его реализации в зависимости от того, какой *тип среды выполнения* имеет экземпляр, для которого вызван этот метод.</span><span class="sxs-lookup"><span data-stu-id="4d06a-245">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="4d06a-246">При вызове невиртуального метода решающим фактором является *тип во время компиляции* для этого экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4d06a-246">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="4d06a-247">Виртуальный метод можно *переопределить* в производном классе.</span><span class="sxs-lookup"><span data-stu-id="4d06a-247">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="4d06a-248">Если объявление метода экземпляра содержит модификатор override, этот метод переопределяет унаследованный виртуальный метод с такой же сигнатурой.</span><span class="sxs-lookup"><span data-stu-id="4d06a-248">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="4d06a-249">Изначальное объявление виртуального метода создает новый метод, а переопределение этого метода создает специализированный виртуальный метод с новой реализацией взамен унаследованного виртуального метода.</span><span class="sxs-lookup"><span data-stu-id="4d06a-249">Whereas a virtual method declaration introduces a new method, an override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="4d06a-250">*Абстрактным методом* называется виртуальный метод без реализации.</span><span class="sxs-lookup"><span data-stu-id="4d06a-250">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="4d06a-251">Абстрактный метод объявляется с модификатором abstract. Его можно объявить только в классе, который также объявлен абстрактным.</span><span class="sxs-lookup"><span data-stu-id="4d06a-251">An abstract method is declared with the abstract modifier and is permitted only in a class that is also declared abstract.</span></span> <span data-ttu-id="4d06a-252">Абстрактный метод должен обязательно переопределяться в каждом производном классе, не являющемся абстрактным.</span><span class="sxs-lookup"><span data-stu-id="4d06a-252">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="4d06a-253">Следующий пример кода объявляет абстрактный класс `Expression`, который представляет узел дерева выражений, а также три производных класса: `Constant`, `VariableReference` и `Operation`, которые реализуют узлы дерева выражений для констант, ссылок на переменные и арифметических операций.</span><span class="sxs-lookup"><span data-stu-id="4d06a-253">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="4d06a-254">(Этот пример похож на типы дерева выражений, но не следует их путать.)</span><span class="sxs-lookup"><span data-stu-id="4d06a-254">(This example is similar to, but not to be confused with the expression tree types).</span></span>

[!code-csharp[ExpressionClass](~/samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L3-L61)]

<span data-ttu-id="4d06a-255">Четыре приведенных выше класса можно использовать для моделирования арифметических выражений.</span><span class="sxs-lookup"><span data-stu-id="4d06a-255">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="4d06a-256">Например, с помощью экземпляров этих классов выражение `x + 3` можно представить следующим образом.</span><span class="sxs-lookup"><span data-stu-id="4d06a-256">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

[!code-csharp[ExpressionExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L40-L43)]

<span data-ttu-id="4d06a-257">Метод `Evaluate` экземпляра `Expression` вызывается для вычисления данного выражения и создает значение `double`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-257">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="4d06a-258">Этот метод принимает аргумент `Dictionary`, который содержит имена переменных (в качестве ключей записей) и значения переменных (в качестве значений записей).</span><span class="sxs-lookup"><span data-stu-id="4d06a-258">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="4d06a-259">Так как `Evaluate` — абстрактный метод, то в неабстрактных классах, производных от `Expression`, необходимо переопределить `Evaluate`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-259">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="4d06a-260">В `Constant` реализация метода `Evaluate` просто возвращает хранимую константу.</span><span class="sxs-lookup"><span data-stu-id="4d06a-260">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="4d06a-261">В `VariableReference` реализация этого метода выполняет поиск имени переменной в словаре и возвращает полученное значение.</span><span class="sxs-lookup"><span data-stu-id="4d06a-261">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="4d06a-262">В `Operation` реализация этого метода сначала вычисляет левый и правый операнды (рекурсивно вызывая их методы `Evaluate`), а затем выполняет предоставленную арифметическую операцию.</span><span class="sxs-lookup"><span data-stu-id="4d06a-262">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="4d06a-263">В следующей программе классы `Expression` используются для вычисления выражения `x * (y + 2)` с различными значениями `x` и `y`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-263">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

[!code-csharp[ExpressionUsage](~/samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L66-L89)]

### <a name="method-overloading"></a><span data-ttu-id="4d06a-264">Перегрузка методов</span><span class="sxs-lookup"><span data-stu-id="4d06a-264">Method overloading</span></span>

<span data-ttu-id="4d06a-265">*Перегрузка* метода позволяет использовать в одном классе несколько методов с одинаковыми именами, если они имеют уникальные сигнатуры.</span><span class="sxs-lookup"><span data-stu-id="4d06a-265">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="4d06a-266">Когда при компиляции встречается вызов перегруженного метода, компилятор использует принцип *разрешения перегрузки*, чтобы определить, какой из методов следует вызвать.</span><span class="sxs-lookup"><span data-stu-id="4d06a-266">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="4d06a-267">Разрешение перегрузки выбирает из методов тот, который лучше всего соответствует предоставленным аргументам, или возвращает ошибку, если не удается выбрать конкретный подходящий метод.</span><span class="sxs-lookup"><span data-stu-id="4d06a-267">Overload resolution finds the one method that best matches the arguments or reports an error if no single best match can be found.</span></span> <span data-ttu-id="4d06a-268">В следующем примере показано, как работает разрешение перегрузки.</span><span class="sxs-lookup"><span data-stu-id="4d06a-268">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="4d06a-269">Комментарий к каждому вызову метода `UsageExample` указывает, какой именно метод вызывается.</span><span class="sxs-lookup"><span data-stu-id="4d06a-269">The comment for each invocation in the `UsageExample` method shows which method is invoked.</span></span>

[!code-csharp[OverloadUsage](~/samples/snippets/csharp/tour/classes-and-objects/Overloading.cs#L3-L41)]

<span data-ttu-id="4d06a-270">Как видно из этого примера, вы всегда можете выбрать конкретный метод, явным образом приведя типы аргументов к соответствующим типам параметров, и (или) явно предоставив аргументы нужного типа.</span><span class="sxs-lookup"><span data-stu-id="4d06a-270">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and/or explicitly supplying type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="4d06a-271">Другие функции-члены</span><span class="sxs-lookup"><span data-stu-id="4d06a-271">Other function members</span></span>

<span data-ttu-id="4d06a-272">Все члены класса, содержащие исполняемый код, совокупно называются *функции-члены*.</span><span class="sxs-lookup"><span data-stu-id="4d06a-272">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="4d06a-273">В предыдущем разделе описаны основные варианты методов, используемых в качестве функций-членов.</span><span class="sxs-lookup"><span data-stu-id="4d06a-273">The preceding section describes methods, which are the primary types of function members.</span></span> <span data-ttu-id="4d06a-274">В этом разделе описываются другие типы функций-членов, поддерживаемые в языке C#: конструкторы, свойства, индексаторы, события, операторы и методы завершения.</span><span class="sxs-lookup"><span data-stu-id="4d06a-274">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="4d06a-275">В следующем примере показан универсальный класс с именем `MyList<T>`, который реализует расширяемый список объектов.</span><span class="sxs-lookup"><span data-stu-id="4d06a-275">The following example shows a generic class called `MyList<T>`, which implements a growable list of objects.</span></span> <span data-ttu-id="4d06a-276">Этот класс содержит несколько наиболее распространенных типов функций-членов.</span><span class="sxs-lookup"><span data-stu-id="4d06a-276">The class contains several examples of the most common kinds of function members.</span></span>

> [!NOTE]
> <span data-ttu-id="4d06a-277">В этом примере создается класс `MyList`, который отличается от стандартного <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> в .NET.</span><span class="sxs-lookup"><span data-stu-id="4d06a-277">This example creates a `MyList` class, which is not the same as the .NET standard <xref:System.Collections.Generic.List%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4d06a-278">Здесь показаны основные понятия, необходимые для этого руководства, но они не заменят собой этот класс.</span><span class="sxs-lookup"><span data-stu-id="4d06a-278">It does illustrate the concepts needed for this tour, but is not a replacement for that class.</span></span>

[!code-csharp[ListClass](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L4-L89)]

### <a name="constructors"></a><span data-ttu-id="4d06a-279">Конструкторы</span><span class="sxs-lookup"><span data-stu-id="4d06a-279">Constructors</span></span>

<span data-ttu-id="4d06a-280">C# поддерживает конструкторы экземпляров и статические конструкторы.</span><span class="sxs-lookup"><span data-stu-id="4d06a-280">C# supports both instance and static constructors.</span></span> <span data-ttu-id="4d06a-281">*Конструктор экземпляра* является членом, который реализует действия для инициализации нового экземпляра класса.</span><span class="sxs-lookup"><span data-stu-id="4d06a-281">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="4d06a-282">*Статический конструктор* является членом, который реализует действия для инициализации самого класса при первоначальной его загрузке.</span><span class="sxs-lookup"><span data-stu-id="4d06a-282">A *static constructor* is a member that implements the actions required to initialize a class itself when it's first loaded.</span></span>

<span data-ttu-id="4d06a-283">Конструктор объявляется в виде метода без возвращаемого типа, имя которого совпадает с именем класса, в котором он определен.</span><span class="sxs-lookup"><span data-stu-id="4d06a-283">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="4d06a-284">Если объявление конструктора содержит модификатор static, создается статический конструктор.</span><span class="sxs-lookup"><span data-stu-id="4d06a-284">If a constructor declaration includes a static modifier, it declares a static constructor.</span></span> <span data-ttu-id="4d06a-285">В противном случае это объявление считается конструктором экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4d06a-285">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="4d06a-286">Конструкторы экземпляров можно перегружать, и для них можно указать необязательные параметры.</span><span class="sxs-lookup"><span data-stu-id="4d06a-286">Instance constructors can be overloaded and can have optional parameters.</span></span> <span data-ttu-id="4d06a-287">Например, класс `MyList<T>` объявляет один конструктор экземпляра с одним необязательным параметром `int`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-287">For example, the `MyList<T>` class declares one instance constructor with a single optional `int` parameter.</span></span> <span data-ttu-id="4d06a-288">Конструкторы экземпляров вызываются с помощью оператора `new`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-288">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="4d06a-289">Следующий пример кода выделяет два экземпляра `MyList<string>` с помощью конструкторов класса `MyList`: один с необязательным аргументом, а второй — без.</span><span class="sxs-lookup"><span data-stu-id="4d06a-289">The following statements allocate two `MyList<string>` instances using the constructor of the `MyList` class with and without the optional argument.</span></span>

[!code-csharp[ListExample1](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L95-L96)]

<span data-ttu-id="4d06a-290">В отличие от других членов, конструкторы экземпляров не наследуются, и класс не имеет конструкторов экземпляров, кроме объявленных в этом классе.</span><span class="sxs-lookup"><span data-stu-id="4d06a-290">Unlike other members, instance constructors aren't inherited, and a class has no instance constructors other than those constructors actually declared in the class.</span></span> <span data-ttu-id="4d06a-291">Если в классе не объявлен конструктор экземпляра, для него автоматически создается пустой конструктор без параметров.</span><span class="sxs-lookup"><span data-stu-id="4d06a-291">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="4d06a-292">Свойства</span><span class="sxs-lookup"><span data-stu-id="4d06a-292">Properties</span></span>

<span data-ttu-id="4d06a-293">*Свойства* естественным образом дополняют поля.</span><span class="sxs-lookup"><span data-stu-id="4d06a-293">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="4d06a-294">И те, и другие являются именованными членами со связанными типами, и для доступа к ним используется одинаковый синтаксис.</span><span class="sxs-lookup"><span data-stu-id="4d06a-294">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="4d06a-295">Однако свойства, в отличие от полей, не указывают места хранения.</span><span class="sxs-lookup"><span data-stu-id="4d06a-295">However, unlike fields, properties don't denote storage locations.</span></span> <span data-ttu-id="4d06a-296">Вместо этого свойства содержат *методы доступа*, в которых описаны инструкции для выполнения при чтении или записи значений.</span><span class="sxs-lookup"><span data-stu-id="4d06a-296">Instead, properties have *accessors* that specify the statements to be executed when their values are read or written.</span></span>

<span data-ttu-id="4d06a-297">Свойство объявляется так же, как поле, за исключением того, что объявление заканчивается не точкой с запятой, а парой разделителей `{` и `}`, между которыми указаны акцессоры get для чтения и (или) set для записи.</span><span class="sxs-lookup"><span data-stu-id="4d06a-297">A property is declared like a field, except that the declaration ends with a get accessor and/or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="4d06a-298">Свойство, для которого определены акцессоры get и set, является свойством *для чтения и записи*. Если в свойстве есть только акцессор get, оно является *свойством только для чтения*, и если только акцессор set — *свойством только для записи*.</span><span class="sxs-lookup"><span data-stu-id="4d06a-298">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="4d06a-299">Акцессор get оформляется как метод без параметров, у которого тип возвращаемого значения совпадает с типом, установленным для этого свойства.</span><span class="sxs-lookup"><span data-stu-id="4d06a-299">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="4d06a-300">Во всех ситуациях, кроме использования в качестве назначения в операторе присваивания, для вычисления значения свойства вызывается акцессор get.</span><span class="sxs-lookup"><span data-stu-id="4d06a-300">Except as the target of an assignment, when a property is referenced in an expression, the get accessor of the property is invoked to compute the value of the property.</span></span>

<span data-ttu-id="4d06a-301">Метод доступа set соответствует методу с одним именованным значением параметра и без возвращаемого типа.</span><span class="sxs-lookup"><span data-stu-id="4d06a-301">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="4d06a-302">При ссылке на свойство в качестве назначения в операторе присваивания или в качестве операнда для ++ или -- вызывается метод доступа set с аргументом, предоставляющим новое значение.</span><span class="sxs-lookup"><span data-stu-id="4d06a-302">When a property is referenced as the target of an assignment or as the operand of ++ or --, the set accessor is invoked with an argument that provides the new value.</span></span>

<span data-ttu-id="4d06a-303">Класс `MyList<T>` объявляет два свойства: `Count` (только для чтения) и `Capacity` (только для записи).</span><span class="sxs-lookup"><span data-stu-id="4d06a-303">The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="4d06a-304">Следующий код содержит пример использования этих свойств:</span><span class="sxs-lookup"><span data-stu-id="4d06a-304">The following code is an example of use of these properties:</span></span>

[!code-csharp[ListExample2](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L101-L104)]

<span data-ttu-id="4d06a-305">Как и в отношении полей и методов, C# поддерживает свойства экземпляра и статические свойства.</span><span class="sxs-lookup"><span data-stu-id="4d06a-305">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="4d06a-306">Статические свойства объявляются с модификатором static, а свойства экземпляра — без него.</span><span class="sxs-lookup"><span data-stu-id="4d06a-306">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="4d06a-307">Акцессоры свойства могут быть виртуальными.</span><span class="sxs-lookup"><span data-stu-id="4d06a-307">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="4d06a-308">Если объявление свойства содержит модификатор `virtual`, `abstract` или `override`, этот модификатор применяется к акцессорам свойства.</span><span class="sxs-lookup"><span data-stu-id="4d06a-308">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="4d06a-309">Индексаторы</span><span class="sxs-lookup"><span data-stu-id="4d06a-309">Indexers</span></span>

<span data-ttu-id="4d06a-310">*Индексатор* является членом, позволяющим индексировать объекты так, как будто они включены в массив.</span><span class="sxs-lookup"><span data-stu-id="4d06a-310">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="4d06a-311">Индексатор объявляется так же, как свойство, за исключением того, что именем элемента является `this`, а за этим именем следует список параметров, находящийся между разделителями `[` и `]`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-311">An indexer is declared like a property except that the name of the member is `this` followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="4d06a-312">Эти параметры доступны в акцессорах индексатора.</span><span class="sxs-lookup"><span data-stu-id="4d06a-312">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="4d06a-313">Как и свойства, можно объявить индексаторы для чтения и записи, только для чтения или только для записи. Кроме того, поддерживаются виртуальные акцессоры индексатора.</span><span class="sxs-lookup"><span data-stu-id="4d06a-313">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="4d06a-314">Класс `MyList<T>` объявляет один индексатор для чтения и записи, который принимает параметр `int`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-314">The `MyList<T>` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="4d06a-315">Индексатор позволяет индексировать экземпляры `MyList<T>` значениями с типом `int`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-315">The indexer makes it possible to index `MyList<T>` instances with `int` values.</span></span> <span data-ttu-id="4d06a-316">Пример:</span><span class="sxs-lookup"><span data-stu-id="4d06a-316">For example:</span></span>

[!code-csharp[ListExample3](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L109-L117)]

<span data-ttu-id="4d06a-317">Индексаторы можно перегружать, то есть в одном классе можно объявить несколько индексаторов, если у них различаются количество или типы параметров.</span><span class="sxs-lookup"><span data-stu-id="4d06a-317">Indexers can be overloaded, meaning that a class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="4d06a-318">События</span><span class="sxs-lookup"><span data-stu-id="4d06a-318">Events</span></span>

<span data-ttu-id="4d06a-319">*Событие* — это член, с помощью которого класс или объект предоставляют уведомления.</span><span class="sxs-lookup"><span data-stu-id="4d06a-319">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="4d06a-320">Объявление события выглядит так же, как объявление поля, но содержит ключевое слово event и обязано иметь тип делегата.</span><span class="sxs-lookup"><span data-stu-id="4d06a-320">An event is declared like a field except that the declaration includes an event keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="4d06a-321">В классе, который объявляет член события, это событие действует как обычное поле с типом делегата (если это событие не является абстрактным и не объявляет методы доступа).</span><span class="sxs-lookup"><span data-stu-id="4d06a-321">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event isn't abstract and doesn't declare accessors).</span></span> <span data-ttu-id="4d06a-322">Это поле хранит ссылку на делегат, который представляет добавленные к событию обработчики событий.</span><span class="sxs-lookup"><span data-stu-id="4d06a-322">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="4d06a-323">Если обработчики событий отсутствуют, это поле имеет значение `null`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-323">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="4d06a-324">Класс `MyList<T>` объявляет один член события с именем `Changed`, который обрабатывает добавление нового элемента.</span><span class="sxs-lookup"><span data-stu-id="4d06a-324">The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="4d06a-325">Событие Changed вызывается виртуальным методом `OnChanged`, который сначала проверяет, не имеет ли это событие значение `null` (это означает, что обработчики отсутствуют).</span><span class="sxs-lookup"><span data-stu-id="4d06a-325">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="4d06a-326">Концепция создания события в точности соответствует вызову делегата, представленного этим событием. Это позволяет обойтись без особой языковой конструкции для создания событий.</span><span class="sxs-lookup"><span data-stu-id="4d06a-326">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event—thus, there are no special language constructs for raising events.</span></span>

<span data-ttu-id="4d06a-327">Клиенты реагируют на события посредством *обработчиков событий*.</span><span class="sxs-lookup"><span data-stu-id="4d06a-327">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="4d06a-328">Обработчики событий можно подключать с помощью оператора `+=` и удалять с помощью оператора `-=`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-328">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="4d06a-329">Следующий пример кода подключает обработчик события `Changed` к событию `MyList<string>`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-329">The following example attaches an event handler to the `Changed` event of a `MyList<string>`.</span></span>

[!code-csharp[EventExample](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L132-L148)]

<span data-ttu-id="4d06a-330">Для более сложных сценариев, требующих контроля над базовым хранилищем события, в объявлении события можно явным образом предоставить методы доступа `add` и `remove`. Они будут действовать аналогично методу доступа `set` для свойства.</span><span class="sxs-lookup"><span data-stu-id="4d06a-330">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="4d06a-331">Операторы</span><span class="sxs-lookup"><span data-stu-id="4d06a-331">Operators</span></span>

<span data-ttu-id="4d06a-332">*Оператор* является членом, который определяет правила применения определенного выражения к экземплярам класса.</span><span class="sxs-lookup"><span data-stu-id="4d06a-332">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="4d06a-333">Вы можете определить операторы трех типов: унарные операторы, двоичные операторы и операторы преобразования.</span><span class="sxs-lookup"><span data-stu-id="4d06a-333">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="4d06a-334">Все операторы объявляются с модификаторами `public` и `static`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-334">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="4d06a-335">Класс `MyList<T>` объявляет два оператора: `operator ==` и `operator !=`. Это позволяет определить новое значение для выражений, которые применяют эти операторы к экземплярам `MyList`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-335">The `MyList<T>` class declares two operators, `operator ==` and `operator !=`, and thus gives new meaning to expressions that apply those operators to `MyList` instances.</span></span> <span data-ttu-id="4d06a-336">В частности, эти операторы определяют, что равенство двух экземпляров `MyList<T>` проверяется путем сравнения всех содержащихся в них объектов с помощью определенных для них методов Equals.</span><span class="sxs-lookup"><span data-stu-id="4d06a-336">Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their Equals methods.</span></span> <span data-ttu-id="4d06a-337">Следующий пример кода использует оператор `==` для сравнения двух экземпляров `MyList<int>`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-337">The following example uses the `==` operator to compare two `MyList<int>` instances.</span></span>

[!code-csharp[OperatorExample](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L121-L129)]

<span data-ttu-id="4d06a-338">Первый `Console.WriteLine` выводит `True`, поскольку два списка содержат одинаковое число объектов с одинаковыми значениями в том же порядке.</span><span class="sxs-lookup"><span data-stu-id="4d06a-338">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="4d06a-339">Если бы в `MyList<T>` не было определения `operator ==`, первый `Console.WriteLine` возвращал бы `False`, поскольку `a` и `b` указывают на различные экземпляры `MyList<int>`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-339">Had `MyList<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `MyList<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="4d06a-340">Методы завершения</span><span class="sxs-lookup"><span data-stu-id="4d06a-340">Finalizers</span></span>

<span data-ttu-id="4d06a-341">*Метод завершения* является членом, который реализует действия для завершения существования экземпляра класса.</span><span class="sxs-lookup"><span data-stu-id="4d06a-341">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="4d06a-342">Методы завершения не могут иметь параметры, не могут содержать модификаторы доступа, и их невозможно вызвать явным образом.</span><span class="sxs-lookup"><span data-stu-id="4d06a-342">Finalizers can't have parameters, they can't have accessibility modifiers, and they can't be invoked explicitly.</span></span> <span data-ttu-id="4d06a-343">Метод завершения для экземпляра вызывается автоматически в процессе сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="4d06a-343">The finalizer for an instance is invoked automatically during garbage collection.</span></span>

<span data-ttu-id="4d06a-344">Сборщик мусора имеет широкую степень свободы в выборе времени уничтожения объектов и вызова методов завершения.</span><span class="sxs-lookup"><span data-stu-id="4d06a-344">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="4d06a-345">В частности, время вызова методов завершения не является детерминированным, и эти методы могут выполняться в любом потоке.</span><span class="sxs-lookup"><span data-stu-id="4d06a-345">Specifically, the timing of finalizer invocations isn't deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="4d06a-346">По этим и некоторым другим причинам методы завершения следует использовать в классах только в крайнем случае, когда невозможны другие решения.</span><span class="sxs-lookup"><span data-stu-id="4d06a-346">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="4d06a-347">Уничтожение объектов лучше контролировать с помощью инструкции `using`.</span><span class="sxs-lookup"><span data-stu-id="4d06a-347">The `using` statement provides a better approach to object destruction.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="4d06a-348">[Назад](statements.md)
> [Вперед](arrays.md)</span><span class="sxs-lookup"><span data-stu-id="4d06a-348">[Previous](statements.md)
[Next](arrays.md)</span></span>
