---
title: Обзор языка C# — руководство по C#
description: Вы еще не знакомы с C#? Изучите основы этого языка. Начните с этого обзора.
ms.date: 01/28/2021
ms.openlocfilehash: 016edf331d8cbdca2902cb033963b6aea11df513
ms.sourcegitcommit: 68c9d9d9a97aab3b59d388914004b5474cf1dbd7
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2021
ms.locfileid: "99216646"
---
# <a name="a-tour-of-the-c-language"></a><span data-ttu-id="55975-105">Краткий обзор языка C#</span><span class="sxs-lookup"><span data-stu-id="55975-105">A tour of the C# language</span></span>

<span data-ttu-id="55975-106">C# (произносится как "си шарп") — современный объектно-ориентированный и типобезопасный язык программирования.</span><span class="sxs-lookup"><span data-stu-id="55975-106">C# (pronounced "See Sharp") is a modern, object-oriented, and type-safe programming language.</span></span> <span data-ttu-id="55975-107">C# позволяет разработчикам создавать множество типов безопасных и надежных приложений, работающих в экосистеме .NET.</span><span class="sxs-lookup"><span data-stu-id="55975-107">C# enables developers to build many types of secure and robust applications that run in the .NET ecosystem.</span></span> <span data-ttu-id="55975-108">C# относится к широко известному семейству языков C, и покажется хорошо знакомым любому, кто работал с C, C++, Java или JavaScript.</span><span class="sxs-lookup"><span data-stu-id="55975-108">C# has its roots in the C family of languages and will be immediately familiar to C, C++, Java, and JavaScript programmers.</span></span> <span data-ttu-id="55975-109">Здесь представлен обзор основных компонентов языка C# 8 и более ранних версий.</span><span class="sxs-lookup"><span data-stu-id="55975-109">This tour provides an overview of the major components of the language in C# 8 and earlier.</span></span> <span data-ttu-id="55975-110">Если вы хотите изучить язык с помощью интерактивных примеров, рекомендуем поработать с [вводными руководствами по C#](../tutorials/intro-to-csharp/index.md).</span><span class="sxs-lookup"><span data-stu-id="55975-110">If you want to explore the language through interactive examples, try the [introduction to C#](../tutorials/intro-to-csharp/index.md) tutorials.</span></span>

<span data-ttu-id="55975-111">C# — это объектно- и \***компонентно-ориентированный** _ язык программирования.</span><span class="sxs-lookup"><span data-stu-id="55975-111">C# is an object-oriented, \***component-oriented** _ programming language.</span></span> <span data-ttu-id="55975-112">C# предоставляет языковые конструкции для непосредственной поддержки такой концепции работы. Благодаря этому C# подходит для создания и применения программных компонентов.</span><span class="sxs-lookup"><span data-stu-id="55975-112">C# provides language constructs to directly support these concepts, making C# a natural language in which to create and use software components.</span></span> <span data-ttu-id="55975-113">С момента создания язык C# обогатился функциями для поддержки новых рабочих нагрузок и современными рекомендациями по разработке ПО.</span><span class="sxs-lookup"><span data-stu-id="55975-113">Since its origin, C# has added features to support new workloads and emerging software design practices.</span></span>

<span data-ttu-id="55975-114">Вот лишь несколько функций языка C#, которые позволяют создавать надежные и устойчивые приложения.</span><span class="sxs-lookup"><span data-stu-id="55975-114">Several C# features help create robust and durable applications.</span></span> <span data-ttu-id="55975-115">[_\*_Сборка мусора_\*_](../../standard/garbage-collection/index.md) автоматически освобождает память, занятую недостижимыми неиспользуемыми объектами.</span><span class="sxs-lookup"><span data-stu-id="55975-115">[_*_Garbage collection_*_](../../standard/garbage-collection/index.md) automatically reclaims memory occupied by unreachable unused objects.</span></span> <span data-ttu-id="55975-116">[_\*_Типы, допускающие значение null,_\*_](../nullable-references.md) обеспечивают защиту от переменных, которые не ссылаются на выделенные объекты.</span><span class="sxs-lookup"><span data-stu-id="55975-116">[_*_Nullable types_*_](../nullable-references.md) guard against variables that don't refer to allocated objects.</span></span> <span data-ttu-id="55975-117">[_\*_Обработка исключений_\*_](../programming-guide/exceptions/index.md) предоставляет структурированный и расширяемый подход к обнаружению ошибок и восстановлению после них.</span><span class="sxs-lookup"><span data-stu-id="55975-117">[_*_Exception handling_*_](../programming-guide/exceptions/index.md) provides a structured and extensible approach to error detection and recovery.</span></span> <span data-ttu-id="55975-118">[_\*_Лямбда-выражения_\*_](../language-reference/operators/lambda-expressions.md) поддерживают приемы функционального программирования.</span><span class="sxs-lookup"><span data-stu-id="55975-118">[_*_Lambda expressions_*_](../language-reference/operators/lambda-expressions.md) support functional programming techniques.</span></span> <span data-ttu-id="55975-119">[_\*_Синтаксис LINQ_\*_](../linq/index.md) создает общий шаблон для работы с данными из любого источника.</span><span class="sxs-lookup"><span data-stu-id="55975-119">[_*_Language Integrated Query (LINQ)_*_](../linq/index.md) syntax creates a common pattern for working with data from any source.</span></span> <span data-ttu-id="55975-120">Поддержка языков для [_\*_асинхронных операций_\*_](../programming-guide/concepts/async/index.md) предоставляет синтаксис для создания распределенных систем.</span><span class="sxs-lookup"><span data-stu-id="55975-120">Language support for [_*_asynchronous operations_*_](../programming-guide/concepts/async/index.md) provides syntax for building distributed systems.</span></span> <span data-ttu-id="55975-121">В C# действует [_\*_единая система типов_\*_](../programming-guide/types/index.md).</span><span class="sxs-lookup"><span data-stu-id="55975-121">C# has a [_*_unified type system_*_](../programming-guide/types/index.md).</span></span> <span data-ttu-id="55975-122">Все типы C#, включая типы-примитивы, такие как `int` и `double`, наследуют от одного корневого типа `object`.</span><span class="sxs-lookup"><span data-stu-id="55975-122">All C# types, including primitive types such as `int` and `double`, inherit from a single root `object` type.</span></span> <span data-ttu-id="55975-123">Все типы используют общий набор операций,</span><span class="sxs-lookup"><span data-stu-id="55975-123">All types share a set of common operations.</span></span> <span data-ttu-id="55975-124">а значения любого типа можно хранить, передавать и обрабатывать схожим образом.</span><span class="sxs-lookup"><span data-stu-id="55975-124">Values of any type can be stored, transported, and operated upon in a consistent manner.</span></span> <span data-ttu-id="55975-125">Более того, C# поддерживает как определяемые пользователями [ссылочные типы](../language-reference/builtin-types/reference-types.md), так и [типы значений](../language-reference/builtin-types/value-types.md).</span><span class="sxs-lookup"><span data-stu-id="55975-125">Furthermore, C# supports both user-defined [reference types](../language-reference/builtin-types/reference-types.md) and [value types](../language-reference/builtin-types/value-types.md).</span></span> <span data-ttu-id="55975-126">C# позволяет динамически выделять объекты и хранить упрощенные структуры в стеке.</span><span class="sxs-lookup"><span data-stu-id="55975-126">C# allows dynamic allocation of objects and in-line storage of lightweight structures.</span></span> <span data-ttu-id="55975-127">C# поддерживает универсальные методы и типы, обеспечивающие повышенную безопасность типов и производительность.</span><span class="sxs-lookup"><span data-stu-id="55975-127">C# supports generic methods and types, which provide increased type safety and performance.</span></span> <span data-ttu-id="55975-128">C# предоставляет итераторы, которые позволяют разработчикам классов коллекций определять пользовательские варианты поведения для клиентского кода.</span><span class="sxs-lookup"><span data-stu-id="55975-128">C# provides iterators, which enable implementers of collection classes to define custom behaviors for client code.</span></span>

<span data-ttu-id="55975-129">В C# особое внимание уделяется _\*_управлению версиями_\*_ для обеспечения совместимости программ и библиотек при их изменении.</span><span class="sxs-lookup"><span data-stu-id="55975-129">C# emphasizes _*_versioning_*_ to ensure programs and libraries can evolve over time in a compatible manner.</span></span> <span data-ttu-id="55975-130">Вопросы управления версиями существенно повлияли на такие аспекты разработки C#, как раздельные модификаторы `virtual` и `override`, правила разрешения перегрузки методов и поддержка явного объявления членов интерфейса.</span><span class="sxs-lookup"><span data-stu-id="55975-130">Aspects of C#'s design that were directly influenced by versioning considerations include the separate `virtual` and `override` modifiers, the rules for method overload resolution, and support for explicit interface member declarations.</span></span>

## <a name="net-architecture"></a><span data-ttu-id="55975-131">Архитектура .NET</span><span class="sxs-lookup"><span data-stu-id="55975-131">.NET architecture</span></span>

<span data-ttu-id="55975-132">Программы C# выполняются в .NET, виртуальной системе выполнения, вызывающей общеязыковую среду выполнения (CLR) и набор библиотек классов.</span><span class="sxs-lookup"><span data-stu-id="55975-132">C# programs run on .NET, a virtual execution system called the common language runtime (CLR) and a set of class libraries.</span></span> <span data-ttu-id="55975-133">Среда CLR — это реализация общеязыковой инфраструктуры языка (CLI), являющейся международным стандартом, от корпорации Майкрософт.</span><span class="sxs-lookup"><span data-stu-id="55975-133">The CLR is the implementation by Microsoft of the common language infrastructure (CLI), an international standard.</span></span> <span data-ttu-id="55975-134">CLI является основой для создания сред выполнения и разработки, в которых языки и библиотеки прозрачно работают друг с другом.</span><span class="sxs-lookup"><span data-stu-id="55975-134">The CLI is the basis for creating execution and development environments in which languages and libraries work together seamlessly.</span></span>

<span data-ttu-id="55975-135">Исходный код, написанный на языке C# компилируется в [промежуточный язык (IL)](../../standard/managed-code.md), который соответствует спецификациям CLI.</span><span class="sxs-lookup"><span data-stu-id="55975-135">Source code written in C# is compiled into an [intermediate language (IL)](../../standard/managed-code.md) that conforms to the CLI specification.</span></span> <span data-ttu-id="55975-136">Код на языке IL и ресурсы, в том числе точечные рисунки и строки, сохраняются в сборке, обычно с расширением _.dll\*.</span><span class="sxs-lookup"><span data-stu-id="55975-136">The IL code and resources, such as bitmaps and strings, are stored in an assembly, typically with an extension of _.dll\*.</span></span> <span data-ttu-id="55975-137">Сборка содержит манифест с информацией о типах, версии, языке и региональных параметрах для этой сборки.</span><span class="sxs-lookup"><span data-stu-id="55975-137">An assembly contains a manifest that provides information about the assembly's types, version, and culture.</span></span>

<span data-ttu-id="55975-138">При выполнении программы C# сборка загружается в среду CLR.</span><span class="sxs-lookup"><span data-stu-id="55975-138">When the C# program is executed, the assembly is loaded into the CLR.</span></span> <span data-ttu-id="55975-139">Среда CLR выполняет JIT-компиляцию из кода на языке IL в инструкции машинного языка.</span><span class="sxs-lookup"><span data-stu-id="55975-139">The CLR performs Just-In-Time (JIT) compilation to convert the IL code to native machine instructions.</span></span> <span data-ttu-id="55975-140">Среда CLR также выполняет другие операции, например, автоматическую сборку мусора, обработку исключений и управление ресурсами.</span><span class="sxs-lookup"><span data-stu-id="55975-140">The CLR provides other services related to automatic garbage collection, exception handling, and resource management.</span></span> <span data-ttu-id="55975-141">Код, выполняемый средой CLR, иногда называют "управляемым кодом", чтобы подчеркнуть отличия этого подхода от "неуправляемого кода", который сразу компилируется в машинный язык для определенной платформы.</span><span class="sxs-lookup"><span data-stu-id="55975-141">Code that's executed by the CLR is sometimes referred to as "managed code," in contrast to "unmanaged code," which is compiled into native machine language that targets a specific platform.</span></span>

<span data-ttu-id="55975-142">Обеспечение взаимодействия между языками является ключевой особенностью .NET.</span><span class="sxs-lookup"><span data-stu-id="55975-142">Language interoperability is a key feature of .NET.</span></span> <span data-ttu-id="55975-143">Код IL, созданный компилятором C#, соответствует спецификации общих типов (CTS).</span><span class="sxs-lookup"><span data-stu-id="55975-143">IL code produced by the C# compiler conforms to the Common Type Specification (CTS).</span></span> <span data-ttu-id="55975-144">Код IL, созданный из кода на C# , может взаимодействовать с кодом, созданным из версий .NET для языков F# , Visual Basic, C++ и любых других из более чем 20 языков, совместимых с CTS.</span><span class="sxs-lookup"><span data-stu-id="55975-144">IL code generated from C# can interact with code that was generated from the .NET versions of F#, Visual Basic, C++, or any of more than 20 other CTS-compliant languages.</span></span> <span data-ttu-id="55975-145">Одна сборка может содержать несколько модулей, написанных на разных языках .NET, и все типы могут ссылаться друг на друга, как если бы они были написаны на одном языке.</span><span class="sxs-lookup"><span data-stu-id="55975-145">A single assembly may contain multiple modules written in different .NET languages, and the types can reference each other as if they were written in the same language.</span></span>

<span data-ttu-id="55975-146">В дополнение к службам времени выполнения .NET также включает расширенные библиотеки.</span><span class="sxs-lookup"><span data-stu-id="55975-146">In addition to the run time services, .NET also includes extensive libraries.</span></span> <span data-ttu-id="55975-147">Эти библиотеки поддерживают множество различных рабочих нагрузок.</span><span class="sxs-lookup"><span data-stu-id="55975-147">These libraries support many different workloads.</span></span> <span data-ttu-id="55975-148">Они упорядочены по пространствам имен, которые предоставляют разные полезные возможности: от операций файлового ввода и вывода до управления строками и синтаксического анализа XML, от платформ веб-приложений до элементов управления Windows Forms.</span><span class="sxs-lookup"><span data-stu-id="55975-148">They're organized into namespaces that provide a wide variety of useful functionality for everything from file input and output to string manipulation to XML parsing, to web application frameworks to Windows Forms controls.</span></span> <span data-ttu-id="55975-149">Обычно приложение C# активно используют библиотеку классов .NET для решения типовых задач.</span><span class="sxs-lookup"><span data-stu-id="55975-149">The typical C# application uses the .NET class library extensively to handle common "plumbing" chores.</span></span>

<span data-ttu-id="55975-150">Дополнительные сведения о .NET, см. в статье [Обзор .NET](../../core/introduction.md).</span><span class="sxs-lookup"><span data-stu-id="55975-150">For more information about .NET, see [Overview of .NET](../../core/introduction.md).</span></span>

## <a name="hello-world"></a><span data-ttu-id="55975-151">Здравствуй, мир</span><span class="sxs-lookup"><span data-stu-id="55975-151">Hello world</span></span>

<span data-ttu-id="55975-152">Для первого знакомства с языком программирования традиционно используется программа "Hello, World".</span><span class="sxs-lookup"><span data-stu-id="55975-152">The "Hello, World" program is traditionally used to introduce a programming language.</span></span> <span data-ttu-id="55975-153">Вот ее пример на C#:</span><span class="sxs-lookup"><span data-stu-id="55975-153">Here it is in C#:</span></span>

:::code language="csharp" interactive="try-dotnet" source="./snippets/shared/HelloWorld.cs":::

<span data-ttu-id="55975-154">Программа "Hello, World" начинается с директивы `using`, которая ссылается на пространство имен `System`.</span><span class="sxs-lookup"><span data-stu-id="55975-154">The "Hello, World" program starts with a `using` directive that references the `System` namespace.</span></span> <span data-ttu-id="55975-155">Пространства имен позволяют иерархически упорядочивать программы и библиотеки C#.</span><span class="sxs-lookup"><span data-stu-id="55975-155">Namespaces provide a hierarchical means of organizing C# programs and libraries.</span></span> <span data-ttu-id="55975-156">Пространства имен содержат типы и другие пространства имен. Например, пространство имен `System` содержит несколько типов (в том числе используемый в нашей программе класс `Console`) и несколько других пространств имен, таких как `IO` и `Collections`.</span><span class="sxs-lookup"><span data-stu-id="55975-156">Namespaces contain types and other namespaces—for example, the `System` namespace contains a number of types, such as the `Console` class referenced in the program, and a number of other namespaces, such as `IO` and `Collections`.</span></span> <span data-ttu-id="55975-157">Директива `using`, которая ссылается на пространство имен, позволяет использовать типы из этого пространства имен без указания полного имени.</span><span class="sxs-lookup"><span data-stu-id="55975-157">A `using` directive that references a given namespace enables unqualified use of the types that are members of that namespace.</span></span> <span data-ttu-id="55975-158">Благодаря директиве `using` в коде программы можно использовать сокращенное имя `Console.WriteLine` вместо полного варианта `System.Console.WriteLine`.</span><span class="sxs-lookup"><span data-stu-id="55975-158">Because of the `using` directive, the program can use `Console.WriteLine` as shorthand for `System.Console.WriteLine`.</span></span>

<span data-ttu-id="55975-159">Класс `Hello`, объявленный в программе "Hello, World", имеет только один член — это метод с именем `Main`.</span><span class="sxs-lookup"><span data-stu-id="55975-159">The `Hello` class declared by the "Hello, World" program has a single member, the method named `Main`.</span></span> <span data-ttu-id="55975-160">Метод `Main` объявлен с модификатором `static`.</span><span class="sxs-lookup"><span data-stu-id="55975-160">The `Main` method is declared with the `static` modifier.</span></span> <span data-ttu-id="55975-161">Методы экземпляра могут ссылаться на конкретный экземпляр объекта, используя ключевое слово `this`, а статические методы работают без ссылки на конкретный объект.</span><span class="sxs-lookup"><span data-stu-id="55975-161">While instance methods can reference a particular enclosing object instance using the keyword `this`, static methods operate without reference to a particular object.</span></span> <span data-ttu-id="55975-162">По стандартному соглашению точкой входа программы C# является статический метод с именем `Main`.</span><span class="sxs-lookup"><span data-stu-id="55975-162">By convention, a static method named `Main` serves as the entry point of a C# program.</span></span>

<span data-ttu-id="55975-163">Выходные данные программы создаются в методе `WriteLine` класса `Console` из пространства имен `System`.</span><span class="sxs-lookup"><span data-stu-id="55975-163">The output of the program is produced by the `WriteLine` method of the `Console` class in the `System` namespace.</span></span> <span data-ttu-id="55975-164">Этот класс предоставляется библиотеками стандартных классов, ссылки на которые компилятор по умолчанию добавляет автоматически.</span><span class="sxs-lookup"><span data-stu-id="55975-164">This class is provided by the standard class libraries, which, by default, are automatically referenced by the compiler.</span></span>

## <a name="types-and-variables"></a><span data-ttu-id="55975-165">Типы и переменные</span><span class="sxs-lookup"><span data-stu-id="55975-165">Types and variables</span></span>

<span data-ttu-id="55975-166">В C# существуют две разновидности типов: *ссылочные типы* и *типы значений*.</span><span class="sxs-lookup"><span data-stu-id="55975-166">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="55975-167">Переменные типа значений содержат непосредственно данные,</span><span class="sxs-lookup"><span data-stu-id="55975-167">Variables of value types directly contain their data.</span></span> <span data-ttu-id="55975-168">а в переменных ссылочных типов хранятся ссылки на нужные данные, которые именуются объектами.</span><span class="sxs-lookup"><span data-stu-id="55975-168">Variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="55975-169">Две переменные ссылочного типа могут ссылаться на один и тот же объект, поэтому может случиться так, что операции над одной переменной затронут объект, на который ссылается другая переменная.</span><span class="sxs-lookup"><span data-stu-id="55975-169">With reference types, it's possible for two variables to reference the same object and possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="55975-170">Каждая переменная типа значения имеет собственную копию данных, и операции над одной переменной не могут затрагивать другую (за исключением переменных параметров `ref` и `out`).</span><span class="sxs-lookup"><span data-stu-id="55975-170">With value types, the variables each have their own copy of the data, and it isn't possible for operations on one to affect the other (except for `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="55975-171">\***Идентификатор** _ является именем переменной.</span><span class="sxs-lookup"><span data-stu-id="55975-171">An \***identifier** _ is a variable name.</span></span> <span data-ttu-id="55975-172">Идентификатор — это последовательность символов Юникода без пробелов.</span><span class="sxs-lookup"><span data-stu-id="55975-172">An identifier is a sequence of unicode characters without any whitespace.</span></span> <span data-ttu-id="55975-173">Идентификатор может быть зарезервированным словом C#, если он имеет префикс `@`.</span><span class="sxs-lookup"><span data-stu-id="55975-173">An identifier may be a C# reserved word, if it's prefixed by `@`.</span></span> <span data-ttu-id="55975-174">При взаимодействии с другими языками в качестве идентификатора может быть полезно использовать зарезервированное слово.</span><span class="sxs-lookup"><span data-stu-id="55975-174">Using a reserved word as an identifier can be useful when interacting with other languages.</span></span>

<span data-ttu-id="55975-175">Типы значений в C# подразделяются на _простые типы\*, *типы перечисления*, *типы структур*, *типы, допускающие значение NULL,* и *типы значений кортежей*.</span><span class="sxs-lookup"><span data-stu-id="55975-175">C#'s value types are further divided into _simple types\*, *enum types*, *struct types*, *nullable value types*, and *tuple value types*.</span></span> <span data-ttu-id="55975-176">Ссылочные типы в C# подразделяются на *типы классов*, *типы интерфейсов*, *типы массивов* и *типы делегатов*.</span><span class="sxs-lookup"><span data-stu-id="55975-176">C#'s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="55975-177">Далее представлены общие сведения о системе типов в C#.</span><span class="sxs-lookup"><span data-stu-id="55975-177">The following outline provides an overview of C#'s type system.</span></span>

- [<span data-ttu-id="55975-178">Типы значений</span><span class="sxs-lookup"><span data-stu-id="55975-178">Value types</span></span>](../language-reference/builtin-types/value-types.md)
  - [<span data-ttu-id="55975-179">Простые типы</span><span class="sxs-lookup"><span data-stu-id="55975-179">Simple types</span></span>](../language-reference/builtin-types/value-types.md#built-in-value-types)
    - <span data-ttu-id="55975-180">[Целочисленный со знаком](../language-reference/builtin-types/integral-numeric-types.md): `sbyte`, `short`, `int`, `long`.</span><span class="sxs-lookup"><span data-stu-id="55975-180">[Signed integral](../language-reference/builtin-types/integral-numeric-types.md): `sbyte`, `short`, `int`, `long`</span></span>
    - <span data-ttu-id="55975-181">[Целочисленный без знака](../language-reference/builtin-types/integral-numeric-types.md): `byte`, `ushort`, `uint`, `ulong`.</span><span class="sxs-lookup"><span data-stu-id="55975-181">[Unsigned integral](../language-reference/builtin-types/integral-numeric-types.md): `byte`, `ushort`, `uint`, `ulong`</span></span>
    - <span data-ttu-id="55975-182">[Символы Юникода](../../standard/base-types/character-encoding-introduction.md): `char`, который представляет блок кода в кодировке UTF-16.</span><span class="sxs-lookup"><span data-stu-id="55975-182">[Unicode characters](../../standard/base-types/character-encoding-introduction.md): `char`, which represents a UTF-16 code unit</span></span>
    - <span data-ttu-id="55975-183">[Бинарный оператор IEEE с плавающей запятой](../language-reference/builtin-types/floating-point-numeric-types.md): `float`, `double`.</span><span class="sxs-lookup"><span data-stu-id="55975-183">[IEEE binary floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `float`, `double`</span></span>
    - <span data-ttu-id="55975-184">[Десятичное значение с повышенной точностью и плавающей запятой](../language-reference/builtin-types/floating-point-numeric-types.md): `decimal`.</span><span class="sxs-lookup"><span data-stu-id="55975-184">[High-precision decimal floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `decimal`</span></span>
    - <span data-ttu-id="55975-185">Логический: `bool`, используется для представления логических значений, которые могут иметь значение `true` или `false`.</span><span class="sxs-lookup"><span data-stu-id="55975-185">Boolean: `bool`, which represents Boolean values—values that are either `true` or `false`</span></span>
  - [<span data-ttu-id="55975-186">Типы перечисления</span><span class="sxs-lookup"><span data-stu-id="55975-186">Enum types</span></span>](../language-reference/builtin-types/enum.md)
    - <span data-ttu-id="55975-187">Пользовательские типы в формате `enum E {...}`.</span><span class="sxs-lookup"><span data-stu-id="55975-187">User-defined types of the form `enum E {...}`.</span></span> <span data-ttu-id="55975-188">Тип `enum` является отдельным типом со списком именованных констант.</span><span class="sxs-lookup"><span data-stu-id="55975-188">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="55975-189">Каждый тип `enum` имеет базовый тип, в роли которого выступает один из восьми целочисленных типов.</span><span class="sxs-lookup"><span data-stu-id="55975-189">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="55975-190">Набор значений типа `enum` аналогичен набору значений его базового типа.</span><span class="sxs-lookup"><span data-stu-id="55975-190">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>
  - [<span data-ttu-id="55975-191">Типы структур</span><span class="sxs-lookup"><span data-stu-id="55975-191">Struct types</span></span>](../language-reference/builtin-types/struct.md)
    - <span data-ttu-id="55975-192">Пользовательские типы в формате `struct S {...}`</span><span class="sxs-lookup"><span data-stu-id="55975-192">User-defined types of the form `struct S {...}`</span></span>
  - [<span data-ttu-id="55975-193">Типы значений, допускающие значение NULL</span><span class="sxs-lookup"><span data-stu-id="55975-193">Nullable value types</span></span>](../language-reference/builtin-types/nullable-value-types.md)
    - <span data-ttu-id="55975-194">Расширения других типов значений, допускающие значение `null`</span><span class="sxs-lookup"><span data-stu-id="55975-194">Extensions of all other value types with a `null` value</span></span>
  - [<span data-ttu-id="55975-195">Типы значений кортежей</span><span class="sxs-lookup"><span data-stu-id="55975-195">Tuple value types</span></span>](../language-reference/builtin-types/value-tuples.md)
    - <span data-ttu-id="55975-196">Пользовательские типы в формате `(T1, T2, ...)`</span><span class="sxs-lookup"><span data-stu-id="55975-196">User-defined types of the form `(T1, T2, ...)`</span></span>
- [<span data-ttu-id="55975-197">Ссылочные типы</span><span class="sxs-lookup"><span data-stu-id="55975-197">Reference types</span></span>](../language-reference/keywords/reference-types.md)
  - [<span data-ttu-id="55975-198">Типы классов</span><span class="sxs-lookup"><span data-stu-id="55975-198">Class types</span></span>](../language-reference/keywords/class.md)
    - <span data-ttu-id="55975-199">Исходный базовым классом для всех типов: `object`</span><span class="sxs-lookup"><span data-stu-id="55975-199">Ultimate base class of all other types: `object`</span></span>
    - <span data-ttu-id="55975-200">[Строки в Юникоде](../../standard/base-types/character-encoding-introduction.md): `string`, который представляет последовательность блоков кода в кодировке UTF-16.</span><span class="sxs-lookup"><span data-stu-id="55975-200">[Unicode strings](../../standard/base-types/character-encoding-introduction.md): `string`, which represents a sequence of UTF-16 code units</span></span>
    - <span data-ttu-id="55975-201">Пользовательские типы в формате `class C {...}`</span><span class="sxs-lookup"><span data-stu-id="55975-201">User-defined types of the form `class C {...}`</span></span>
  - [<span data-ttu-id="55975-202">Типы интерфейсов</span><span class="sxs-lookup"><span data-stu-id="55975-202">Interface types</span></span>](../language-reference/keywords/interface.md)
    - <span data-ttu-id="55975-203">Пользовательские типы в формате `interface I {...}`</span><span class="sxs-lookup"><span data-stu-id="55975-203">User-defined types of the form `interface I {...}`</span></span>
  - [<span data-ttu-id="55975-204">Типы массивов</span><span class="sxs-lookup"><span data-stu-id="55975-204">Array types</span></span>](../programming-guide/arrays/index.md)
    - <span data-ttu-id="55975-205">Одномерные, многомерные массивы и массивы массивов.</span><span class="sxs-lookup"><span data-stu-id="55975-205">Single-dimensional, multi-dimensional, and jagged.</span></span> <span data-ttu-id="55975-206">Например, `int[]`, `int[,]` и `int[][]`.</span><span class="sxs-lookup"><span data-stu-id="55975-206">For example: `int[]`, `int[,]`, and `int[][]`</span></span>
  - [<span data-ttu-id="55975-207">Типы делегатов</span><span class="sxs-lookup"><span data-stu-id="55975-207">Delegate types</span></span>](../language-reference/builtin-types/reference-types.md#the-delegate-type)
    - <span data-ttu-id="55975-208">Пользовательские типы в формате `delegate int D(...)`</span><span class="sxs-lookup"><span data-stu-id="55975-208">User-defined types of the form `delegate int D(...)`</span></span>

<span data-ttu-id="55975-209">Программы C# используют *объявления типов* для создания новых типов.</span><span class="sxs-lookup"><span data-stu-id="55975-209">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="55975-210">В объявлении типа указываются имя и члены нового типа.</span><span class="sxs-lookup"><span data-stu-id="55975-210">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="55975-211">Шесть категорий типов в C# определяются пользователем: типы классов, типы структур, типы интерфейсов, типы перечисления, типы делегатов и типы значений кортежей.</span><span class="sxs-lookup"><span data-stu-id="55975-211">Six of C#'s categories of types are user-definable: class types, struct types, interface types, enum types, delegate types, and tuple value types.</span></span>

- <span data-ttu-id="55975-212">Тип `class` определяет структуру данных, которая содержит данные-члены (поля) и функции-члены (методы, свойства и т. д.).</span><span class="sxs-lookup"><span data-stu-id="55975-212">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="55975-213">Классы поддерживают механизмы одиночного наследования и полиморфизма, которые позволяют создавать производные классы, расширяющие и уточняющие определения базовых классов.</span><span class="sxs-lookup"><span data-stu-id="55975-213">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>
- <span data-ttu-id="55975-214">Тип `struct` похож на тип класса тем, что он представляет структуру с данными-членами и функциями-членами.</span><span class="sxs-lookup"><span data-stu-id="55975-214">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="55975-215">Но, в отличие от классов, структуры являются типами значений и обычно не требуют выделения памяти из кучи.</span><span class="sxs-lookup"><span data-stu-id="55975-215">However, unlike classes, structs are value types and don't typically require heap allocation.</span></span> <span data-ttu-id="55975-216">Типы структуры не поддерживают определяемое пользователем наследование, и все типы структуры неявно наследуют от типа `object`.</span><span class="sxs-lookup"><span data-stu-id="55975-216">Struct types don't support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>
- <span data-ttu-id="55975-217">Тип `interface` определяет контракт в виде именованного набора открытых элементов.</span><span class="sxs-lookup"><span data-stu-id="55975-217">An `interface` type defines a contract as a named set of public members.</span></span> <span data-ttu-id="55975-218">Объект типа `class` или `struct`, реализующий `interface`, должен предоставить реализации для всех элементов интерфейса.</span><span class="sxs-lookup"><span data-stu-id="55975-218">A `class` or `struct` that implements an `interface` must provide implementations of the interface's members.</span></span> <span data-ttu-id="55975-219">Тип `interface` может наследовать от нескольких базовых интерфейсов, а `class` или `struct` могут реализовывать несколько интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="55975-219">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>
- <span data-ttu-id="55975-220">Тип `delegate` (делегат) представляющий ссылки на методы с конкретным списком параметров и типом возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="55975-220">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="55975-221">Делегаты позволяют использовать методы как сущности, сохраняя их в переменные и передавая в качестве параметров.</span><span class="sxs-lookup"><span data-stu-id="55975-221">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="55975-222">Делегаты аналогичны типам функций, которые используются в функциональных языках.</span><span class="sxs-lookup"><span data-stu-id="55975-222">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="55975-223">Их принцип работы близок к указателям функций из некоторых языков.</span><span class="sxs-lookup"><span data-stu-id="55975-223">They're also similar to the concept of function pointers found in some other languages.</span></span> <span data-ttu-id="55975-224">В отличие от указателей функций, делегаты являются объектно-ориентированными и типобезопасными.</span><span class="sxs-lookup"><span data-stu-id="55975-224">Unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="55975-225">Типы `class`, `struct`, `interface` и `delegate` поддерживают универсальные шаблоны, которые позволяют передавать им другие типы в качестве параметров.</span><span class="sxs-lookup"><span data-stu-id="55975-225">The `class`, `struct`, `interface`, and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="55975-226">C# поддерживает одномерные и многомерные массивы любого типа.</span><span class="sxs-lookup"><span data-stu-id="55975-226">C# supports single-dimensional and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="55975-227">В отличие от перечисленных выше типов, типы массивов не требуется объявлять перед использованием.</span><span class="sxs-lookup"><span data-stu-id="55975-227">Unlike the types listed above, array types don't have to be declared before they can be used.</span></span> <span data-ttu-id="55975-228">Типы массивов можно сформировать, просто введя квадратные скобки после имени типа.</span><span class="sxs-lookup"><span data-stu-id="55975-228">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="55975-229">Например, `int[]` является одномерным массивом значений типа `int`, а `int[,]` — двумерным массивом значений типа `int`, тогда как `int[][]` представляет собой одномерный массив одномерных массивов (или массив массивов) значений типа `int`.</span><span class="sxs-lookup"><span data-stu-id="55975-229">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional arrays, or a "jagged" array, of `int`.</span></span>

<span data-ttu-id="55975-230">Типы, допускающие значение NULL, не требуют отдельного определения.</span><span class="sxs-lookup"><span data-stu-id="55975-230">Nullable types don't require a separate definition.</span></span> <span data-ttu-id="55975-231">Для каждого обычного типа `T`, который не допускает значение NULL, существует идентичный тип `T?`, который отличается только тем, что может содержать дополнительное значение `null`.</span><span class="sxs-lookup"><span data-stu-id="55975-231">For each non-nullable type `T`, there's a corresponding nullable type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="55975-232">Например, `int?` является типом, который может содержать любое 32-разрядное целое число или значение `null`, а `string?` — любое значение `string` или `null`.</span><span class="sxs-lookup"><span data-stu-id="55975-232">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`, and `string?` is a type that can hold any `string` or the value `null`.</span></span>

<span data-ttu-id="55975-233">Система типов в C# унифицирована таким образом, что значение любого типа можно рассматривать как `object` (объект).</span><span class="sxs-lookup"><span data-stu-id="55975-233">C#'s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="55975-234">Каждый тип в C# является прямо или косвенно производным от типа класса `object`, и этот тип `object` является исходным базовым классом для всех типов.</span><span class="sxs-lookup"><span data-stu-id="55975-234">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="55975-235">Чтобы значения ссылочного типа обрабатывались как объекты, им просто присваивается тип `object`.</span><span class="sxs-lookup"><span data-stu-id="55975-235">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="55975-236">Чтобы значения типов значений обрабатывались как объекты, выполняются операции *упаковки-преобразования* и *распаковки-преобразования*.</span><span class="sxs-lookup"><span data-stu-id="55975-236">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="55975-237">В следующем примере значение `int` преобразуется в `object`, а затем обратно в `int`.</span><span class="sxs-lookup"><span data-stu-id="55975-237">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

:::code language="csharp" source="./snippets/shared/Program.cs" ID="boxing" :::

<span data-ttu-id="55975-238">Если значение типа назначается ссылке `object`, для хранения значения выделяется упаковка.</span><span class="sxs-lookup"><span data-stu-id="55975-238">When a value of a value type is assigned to an `object` reference, a "box" is allocated to hold the value.</span></span> <span data-ttu-id="55975-239">Эта упаковка является экземпляром ссылочного типа, и в нее копируется значение.</span><span class="sxs-lookup"><span data-stu-id="55975-239">That box is an instance of a reference type, and the value is copied into that box.</span></span> <span data-ttu-id="55975-240">И наоборот, если ссылка типа `object` используется для типа значения, для соответствующего `object` выполняется проверка, является ли он упаковкой правильного типа.</span><span class="sxs-lookup"><span data-stu-id="55975-240">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type.</span></span> <span data-ttu-id="55975-241">Если эта проверка завершается успешно, копируется значение этой упаковки.</span><span class="sxs-lookup"><span data-stu-id="55975-241">If the check succeeds, the value in the box is copied to the value type.</span></span>

<span data-ttu-id="55975-242">Унифицированная система типов C# фактически позволяет преобразовывать типы значений в ссылки `object` "по требованию".</span><span class="sxs-lookup"><span data-stu-id="55975-242">C#'s unified type system effectively means that value types are treated as `object` references "on demand."</span></span> <span data-ttu-id="55975-243">Такая унификация позволяет применять универсальные библиотеки, использующие тип `object`, со всеми типами, производными от `object`, включая как ссылочные типы, так и с типы значений.</span><span class="sxs-lookup"><span data-stu-id="55975-243">Because of the unification, general-purpose libraries that use type `object` can be used with all types that derive from `object`, including both reference types and value types.</span></span>

<span data-ttu-id="55975-244">В C# существует несколько типов *переменных*, в том числе поля, элементы массива, локальные переменные и параметры.</span><span class="sxs-lookup"><span data-stu-id="55975-244">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="55975-245">Переменные представляют собой места хранения,</span><span class="sxs-lookup"><span data-stu-id="55975-245">Variables represent storage locations.</span></span> <span data-ttu-id="55975-246">и каждая переменная имеет тип, который определяет допустимые значения для хранения в этой переменной. Примеры представлены ниже.</span><span class="sxs-lookup"><span data-stu-id="55975-246">Every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

- <span data-ttu-id="55975-247">Тип значения, не допускающий значения Null</span><span class="sxs-lookup"><span data-stu-id="55975-247">Non-nullable value type</span></span>
  - <span data-ttu-id="55975-248">Значение такого типа</span><span class="sxs-lookup"><span data-stu-id="55975-248">A value of that exact type</span></span>
- <span data-ttu-id="55975-249">Тип значения, допускающий значение Null</span><span class="sxs-lookup"><span data-stu-id="55975-249">Nullable value type</span></span>
  - <span data-ttu-id="55975-250">Значение `null` или значение такого типа</span><span class="sxs-lookup"><span data-stu-id="55975-250">A `null` value or a value of that exact type</span></span>
- <span data-ttu-id="55975-251">object</span><span class="sxs-lookup"><span data-stu-id="55975-251">object</span></span>
  - <span data-ttu-id="55975-252">Ссылка `null`, ссылка на объект любого ссылочного типа или ссылка на упакованное значение любого типа значения</span><span class="sxs-lookup"><span data-stu-id="55975-252">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
- <span data-ttu-id="55975-253">Тип класса</span><span class="sxs-lookup"><span data-stu-id="55975-253">Class type</span></span>
  - <span data-ttu-id="55975-254">Ссылка `null`, ссылка на экземпляр такого типа класса или ссылка на экземпляр любого класса, производного от такого типа класса</span><span class="sxs-lookup"><span data-stu-id="55975-254">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
- <span data-ttu-id="55975-255">Тип интерфейса</span><span class="sxs-lookup"><span data-stu-id="55975-255">Interface type</span></span>
  - <span data-ttu-id="55975-256">Ссылка `null`, ссылка на экземпляр типа класса, который реализует такой тип интерфейса, или ссылка на упакованное значение типа значения, которое реализует такой тип интерфейса</span><span class="sxs-lookup"><span data-stu-id="55975-256">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
- <span data-ttu-id="55975-257">Тип массива</span><span class="sxs-lookup"><span data-stu-id="55975-257">Array type</span></span>
  - <span data-ttu-id="55975-258">Ссылка `null`, ссылка на экземпляр такого типа массива или ссылка на экземпляр любого совместимого типа массива</span><span class="sxs-lookup"><span data-stu-id="55975-258">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
- <span data-ttu-id="55975-259">Тип делегата</span><span class="sxs-lookup"><span data-stu-id="55975-259">Delegate type</span></span>
  - <span data-ttu-id="55975-260">Ссылка `null` или ссылка на экземпляр совместимого типа делегата</span><span class="sxs-lookup"><span data-stu-id="55975-260">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

## <a name="program-structure"></a><span data-ttu-id="55975-261">Структура программы</span><span class="sxs-lookup"><span data-stu-id="55975-261">Program structure</span></span>

<span data-ttu-id="55975-262">В C# основными понятиями организационной структуры являются [\***программы** _](../programming-guide/inside-a-program/index.md), [_\*_пространства имен_\*_](../programming-guide/namespaces/index.md), [_\*_типы_\*_](../programming-guide/types/index.md), [_\*_элементы_\*_](../programming-guide/classes-and-structs/members.md) и [_\*_сборки_\*_ ](../../standard/assembly/index.md).</span><span class="sxs-lookup"><span data-stu-id="55975-262">The key organizational concepts in C# are [\***programs** _](../programming-guide/inside-a-program/index.md), [_*_namespaces_*_](../programming-guide/namespaces/index.md), [_*_types_*_](../programming-guide/types/index.md), [_*_members_*_](../programming-guide/classes-and-structs/members.md), and [_*_assemblies_*_](../../standard/assembly/index.md).</span></span> <span data-ttu-id="55975-263">В программе объявляются типы, которые содержат члены. Эти типы можно организовать в пространства имен.</span><span class="sxs-lookup"><span data-stu-id="55975-263">Programs declare types, which contain members and can be organized into namespaces.</span></span> <span data-ttu-id="55975-264">Примерами типов являются классы, структуры и интерфейсы.</span><span class="sxs-lookup"><span data-stu-id="55975-264">Classes, structs, and interfaces are examples of types.</span></span> <span data-ttu-id="55975-265">К членам относятся поля, методы, свойства и события.</span><span class="sxs-lookup"><span data-stu-id="55975-265">Fields, methods, properties, and events are examples of members.</span></span> <span data-ttu-id="55975-266">При компиляции программы на C# упаковываются в сборки.</span><span class="sxs-lookup"><span data-stu-id="55975-266">When C# programs are compiled, they're physically packaged into assemblies.</span></span> <span data-ttu-id="55975-267">Сборка — это файл, обычно с расширением `.exe` или `.dll`, если она реализует _\*_приложение_\*_ или _\*_библиотеку_\*_, соответственно.</span><span class="sxs-lookup"><span data-stu-id="55975-267">Assemblies typically have the file extension `.exe` or `.dll`, depending on whether they implement _*_applications_*_ or _*_libraries_*_, respectively.</span></span>

<span data-ttu-id="55975-268">В качестве небольшого примера рассмотрим сборку, содержащую следующий код:</span><span class="sxs-lookup"><span data-stu-id="55975-268">As a small example, consider an assembly that contains the following code:</span></span>

:::code language="csharp" source="./snippets/shared/AcmeStack.cs":::

<span data-ttu-id="55975-269">Полное имя этого класса: `Acme.Collections.Stack`.</span><span class="sxs-lookup"><span data-stu-id="55975-269">The fully qualified name of this class is `Acme.Collections.Stack`.</span></span> <span data-ttu-id="55975-270">Этот класс содержит несколько членов: поле с именем `top`, два метода с именами `Push` и `Pop`, а также вложенный класс с именем `Entry`.</span><span class="sxs-lookup"><span data-stu-id="55975-270">The class contains several members: a field named `top`, two methods named `Push` and `Pop`, and a nested class named `Entry`.</span></span> <span data-ttu-id="55975-271">Класс `Entry`, в свою очередь, содержит три члена: поле с именем `next`, поле с именем `data` и конструктор.</span><span class="sxs-lookup"><span data-stu-id="55975-271">The `Entry` class further contains three members: a field named `next`, a field named `data`, and a constructor.</span></span> <span data-ttu-id="55975-272">`Stack` — это _универсальный\* класс.</span><span class="sxs-lookup"><span data-stu-id="55975-272">The `Stack` is a _generic\* class.</span></span> <span data-ttu-id="55975-273">Он имеет параметр одного типа `T`, который замещается конкретным типом при использовании.</span><span class="sxs-lookup"><span data-stu-id="55975-273">It has one type parameter, `T` that is replaced with a concrete type when it's used.</span></span>

> [!NOTE]
> <span data-ttu-id="55975-274">*Стек* — это коллекция типа FILO (прибыл первым — обслужен последним).</span><span class="sxs-lookup"><span data-stu-id="55975-274">A *stack* is a "first in - last out" (FILO) collection.</span></span> <span data-ttu-id="55975-275">Новые элементы добавляются в верх стека.</span><span class="sxs-lookup"><span data-stu-id="55975-275">New elements are added to the top of the stack.</span></span> <span data-ttu-id="55975-276">При удалении элемента он удаляется из верха стека.</span><span class="sxs-lookup"><span data-stu-id="55975-276">When an element is removed, it is removed from the top of the stack.</span></span>

<span data-ttu-id="55975-277">Сборки содержат исполняемый код в виде инструкций промежуточного языка (IL) и символьную информацию в виде метаданных.</span><span class="sxs-lookup"><span data-stu-id="55975-277">Assemblies contain executable code in the form of Intermediate Language (IL) instructions, and symbolic information in the form of metadata.</span></span> <span data-ttu-id="55975-278">Перед выполнением JIT-компилятор среды CLR .NET преобразует код IL в сборке в код, зависящий от процессора.</span><span class="sxs-lookup"><span data-stu-id="55975-278">Before it's executed, the Just-In-Time (JIT) compiler of .NET Common Language Runtime converts the IL code in an assembly to processor-specific code.</span></span>

<span data-ttu-id="55975-279">Сборка полностью описывает сама себя и содержит весь код и метаданные, поэтому в C# не используются директивы `#include` и файлы заголовков.</span><span class="sxs-lookup"><span data-stu-id="55975-279">Because an assembly is a self-describing unit of functionality containing both code and metadata, there's no need for `#include` directives and header files in C#.</span></span> <span data-ttu-id="55975-280">Чтобы использовать в программе C# открытые типы и члены, содержащиеся в определенной сборке, вам достаточно указать ссылку на эту сборку при компиляции программы.</span><span class="sxs-lookup"><span data-stu-id="55975-280">The public types and members contained in a particular assembly are made available in a C# program simply by referencing that assembly when compiling the program.</span></span> <span data-ttu-id="55975-281">Например, эта программа использует класс `Acme.Collections.Stack` из сборки `acme.dll`:</span><span class="sxs-lookup"><span data-stu-id="55975-281">For example, this program uses the `Acme.Collections.Stack` class from the `acme.dll` assembly:</span></span>

:::code language="csharp" source="./snippets/shared/StackUsage.cs":::

<span data-ttu-id="55975-282">Для компиляции программы вам потребуется создать *ссылку* на сборку, содержащую класс стека, определенный в примере выше.</span><span class="sxs-lookup"><span data-stu-id="55975-282">To compile this program, you would need to *reference* the assembly containing the stack class defined in the earlier example.</span></span>

<span data-ttu-id="55975-283">Программы C# можно хранить в нескольких исходных файлах.</span><span class="sxs-lookup"><span data-stu-id="55975-283">C# programs can be stored in several source files.</span></span> <span data-ttu-id="55975-284">При компиляции программы C# все исходные файлы обрабатываются вместе, при этом они могут свободно ссылаться друг на друга.</span><span class="sxs-lookup"><span data-stu-id="55975-284">When a C# program is compiled, all of the source files are processed together, and the source files can freely reference each other.</span></span> <span data-ttu-id="55975-285">По сути, это аналогично тому, как если бы все исходные файлы были объединены в один большой файл перед обработкой.</span><span class="sxs-lookup"><span data-stu-id="55975-285">Conceptually, it's as if all the source files were concatenated into one large file before being processed.</span></span> <span data-ttu-id="55975-286">В C# никогда не используются опережающие объявления, так как порядок объявления, за редким исключением, не играет никакой роли.</span><span class="sxs-lookup"><span data-stu-id="55975-286">Forward declarations are never needed in C# because, with few exceptions, declaration order is insignificant.</span></span> <span data-ttu-id="55975-287">В C# нет требований объявлять только один открытый тип в одном исходном файле, а также имя исходного файла не обязано совпадать с типом, объявляемом в этом файле.</span><span class="sxs-lookup"><span data-stu-id="55975-287">C# doesn't limit a source file to declaring only one public type nor does it require the name of the source file to match a type declared in the source file.</span></span>

<span data-ttu-id="55975-288">Такие организационные блоки описываются в других статьях этого обзора.</span><span class="sxs-lookup"><span data-stu-id="55975-288">Further articles in this tour explain these organizational blocks.</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="55975-289">Вперед</span><span class="sxs-lookup"><span data-stu-id="55975-289">Next</span></span>](types.md)
