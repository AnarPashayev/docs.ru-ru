---
title: Обзор языка C# — руководство по C#
description: Вы еще не знакомы с C#? Изучите основы этого языка.
ms.date: 08/06/2020
ms.openlocfilehash: 84775a436deb0958d3c05ec7d0207e76be28f27c
ms.sourcegitcommit: e7acba36517134238065e4d50bb4a1cfe47ebd06
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/04/2020
ms.locfileid: "89465004"
---
# <a name="a-tour-of-the-c-language"></a>Краткий обзор языка C#

C# (произносится как "си шарп") — современный объектно-ориентированный и типобезопасный язык программирования. C# относится к широко известному семейству языков C, и покажется хорошо знакомым любому, кто работал с C, C++, Java или JavaScript. Здесь представлен обзор основных компонентов языка C# 8 и более ранних версий. Если вы хотите изучить язык с помощью интерактивных примеров, рекомендуем поработать с [вводными руководствами по C#](../tutorials/intro-to-csharp/index.md).

C# — это объектно- и ***компонентно-ориентированный*** язык программирования. C# предоставляет языковые конструкции для непосредственной поддержки такой концепции работы. Благодаря этому C# подходит для создания и применения программных компонентов. С момента создания язык C# обогатился функциями для поддержки новых рабочих нагрузок и современными рекомендациями по разработке ПО.

Вот лишь несколько функций языка C#, обеспечивающих надежность и устойчивость приложений. [***Сборка мусора***](../../standard/garbage-collection/index.md) автоматически освобождает память, занятую недостижимыми неиспользуемыми объектами. [***Обработка исключений***](../programming-guide/exceptions/index.md) предоставляет структурированный и расширяемый подход к обнаружению ошибок и восстановлению после них. [***Лямбда-выражения***](../language-reference/operators/lambda-expressions.md) поддерживают приемы функционального программирования. [***Синтаксис запросов***](../linq/index.md) создает общий шаблон для работы с данными из любого источника. Поддержка языков для [***асинхронных операций***](../programming-guide/concepts/async/index.md) предоставляет синтаксис для создания распределенных систем. [***Сопоставление шаблонов***](..//pattern-matching.md) предоставляет синтаксис для простого разделения данных из алгоритмов в современных распределенных системах. В C# действует [***единая система типов***](../programming-guide/types/index.md). Все типы C#, включая типы-примитивы, такие как `int` и `double`, наследуют от одного корневого типа `object`. Все типы используют общий набор операций, а значения любого типа можно хранить, передавать и обрабатывать схожим образом. Более того, C# поддерживает как определяемые пользователями ссылочные типы, так и типы значений. C# позволяет динамически выделять объекты и хранить упрощенные структуры в стеке.

В C# особое внимание уделяется ***управлению версиями*** для обеспечения совместимости программ и библиотек при их изменении. Вопросы управления версиями существенно повлияли на такие аспекты разработки C#, как раздельные модификаторы `virtual` и `override`, правила разрешения перегрузки методов и поддержка явного объявления членов интерфейса.

## <a name="hello-world"></a>Здравствуй, мир

Для первого знакомства с языком программирования традиционно используется программа "Hello, World". Вот ее пример на C#:

:::code language="csharp" interactive="try-dotnet" source="./snippets/shared/HelloWorld.cs":::

Программа "Hello, World" начинается с директивы `using`, которая ссылается на пространство имен `System`. Пространства имен позволяют иерархически упорядочивать программы и библиотеки C#. Пространства имен содержат типы и другие пространства имен. Например, пространство имен `System` содержит несколько типов (в том числе используемый в нашей программе класс `Console`) и несколько других пространств имен, таких как `IO` и `Collections`. Директива `using`, которая ссылается на пространство имен, позволяет использовать типы из этого пространства имен без указания полного имени. Благодаря директиве `using` в коде программы можно использовать сокращенное имя `Console.WriteLine` вместо полного варианта `System.Console.WriteLine`.

Класс `Hello`, объявленный в программе "Hello, World", имеет только один член — это метод с именем `Main`. Метод `Main` объявлен с модификатором `static`. Методы экземпляра могут ссылаться на конкретный экземпляр объекта, используя ключевое слово `this`, а статические методы работают без ссылки на конкретный объект. По стандартному соглашению точкой входа программы C# является статический метод с именем `Main`.

Выходные данные программы создаются в методе `WriteLine` класса `Console` из пространства имен `System`. Этот класс предоставляется библиотеками стандартных классов, ссылки на которые компилятор по умолчанию добавляет автоматически.

## <a name="types-and-variables"></a>Типы и переменные

В C# существуют две разновидности типов: *ссылочные типы* и *типы значений*. Переменные типа значений содержат непосредственно данные, а в переменных ссылочных типов хранятся ссылки на нужные данные, которые именуются объектами. Две переменные ссылочного типа могут ссылаться на один и тот же объект, поэтому может случиться так, что операции над одной переменной затронут объект, на который ссылается другая переменная. Каждая переменная типа значения имеет собственную копию данных, и операции над одной переменной не могут затрагивать другую (за исключением переменных параметров `ref` и `out`).

***Идентификатор*** является именем переменной. Идентификатор — это последовательность символов Юникода без пробелов. Идентификатор может быть зарезервированным словом C#, если он имеет префикс `@`. Это может быть полезно при взаимодействии с другими языками.

Типы значений в C# подразделяются на *простые типы*, *типы перечисления*, *типы структур*, *типы, допускающие значение NULL,* и *типы значений кортежей*. Ссылочные типы в C# подразделяются на *типы классов*, *типы интерфейсов*, *типы массивов* и *типы делегатов*.

Далее представлены общие сведения о системе типов в C#.

- [Типы значений](../language-reference/builtin-types/value-types.md)
  - [Простые типы](../language-reference/builtin-types/value-types.md#built-in-value-types)
    - [Целочисленный со знаком](../language-reference/builtin-types/integral-numeric-types.md): `sbyte`, `short`, `int`, `long`.
    - [Целочисленный без знака](../language-reference/builtin-types/integral-numeric-types.md): `byte`, `ushort`, `uint`, `ulong`.
    - [Символы Юникода](../../standard/base-types/character-encoding-introduction.md): `char`, который представляет блок кода в кодировке UTF-16.
    - [Бинарный оператор IEEE с плавающей запятой](../language-reference/builtin-types/floating-point-numeric-types.md): `float`, `double`.
    - [Десятичное значение с повышенной точностью и плавающей запятой](../language-reference/builtin-types/floating-point-numeric-types.md): `decimal`.
    - Логический: `bool`, используется для представления логических значений, которые могут иметь значение `true` или `false`.
  - [Типы перечисления](../language-reference/builtin-types/enum.md)
    - Пользовательские типы в формате `enum E {...}`. Тип `enum` является отдельным типом со списком именованных констант. Каждый тип `enum` имеет базовый тип, в роли которого выступает один из восьми целочисленных типов. Набор значений типа `enum` аналогичен набору значений его базового типа.
  - [Типы структур](../language-reference/builtin-types/struct.md)
    - Пользовательские типы в формате `struct S {...}`
  - [Типы значений, допускающие значение NULL](../language-reference/builtin-types/nullable-value-types.md)
    - Расширения других типов значений, допускающие значение `null`
  - [Типы значений кортежей](../language-reference/builtin-types/value-tuples.md)
    - Пользовательские типы в формате `(T1, T2, ...)`
- [Ссылочные типы](../language-reference/keywords/reference-types.md)
  - [Типы классов](../language-reference/keywords/class.md)
    - Исходный базовым классом для всех типов: `object`
    - [Строки в Юникоде](../../standard/base-types/character-encoding-introduction.md): `string`, который представляет последовательность блоков кода в кодировке UTF-16.
    - Пользовательские типы в формате `class C {...}`
  - [Типы интерфейсов](../language-reference/keywords/interface.md)
    - Пользовательские типы в формате `interface I {...}`
  - [Типы массивов](../programming-guide/arrays/index.md)
    - Одномерные, многомерные массивы и массивы массивов. Например, `int[]`, `int[,]` и `int[][]`.
  - [Типы делегатов](../language-reference/builtin-types/reference-types.md#the-delegate-type)
    - Пользовательские типы в формате `delegate int D(...)`

Программы C# используют *объявления типов* для создания новых типов. В объявлении типа указываются имя и члены нового типа. Шесть категорий типов в C# определяются пользователем: типы классов, типы структур, типы интерфейсов, типы перечисления, типы делегатов и типы значений кортежей.

- Тип `class` определяет структуру данных, которая содержит данные-члены (поля) и функции-члены (методы, свойства и т. д.). Классы поддерживают механизмы одиночного наследования и полиморфизма, которые позволяют создавать производные классы, расширяющие и уточняющие определения базовых классов.
- Тип `struct` похож на тип класса тем, что он представляет структуру с данными-членами и функциями-членами. Но, в отличие от классов, структуры являются типами значений и обычно не требуют выделения памяти из кучи. Типы структуры не поддерживают определяемое пользователем наследование, и все типы структуры неявно наследуют от типа `object`.
- Тип `interface` определяет контракт в виде именованного набора открытых элементов. Объект типа `class` или `struct`, реализующий `interface`, должен предоставить реализации для всех элементов интерфейса. Тип `interface` может наследовать от нескольких базовых интерфейсов, а `class` или `struct` могут реализовывать несколько интерфейсов.
- Тип `delegate` (делегат) представляющий ссылки на методы с конкретным списком параметров и типом возвращаемого значения. Делегаты позволяют использовать методы как сущности, сохраняя их в переменные и передавая в качестве параметров. Делегаты аналогичны типам функций, которые используются в функциональных языках. Их принцип работы близок к указателям функций из некоторых языков. В отличие от указателей функций, делегаты являются объектно-ориентированными и типобезопасными.

Типы `class`, `struct`, `interface` и `delegate` поддерживают универсальные шаблоны, которые позволяют передавать им другие типы в качестве параметров.

C# поддерживает одномерные и многомерные массивы любого типа. В отличие от перечисленных выше типов, типы массивов не требуется объявлять перед использованием. Типы массивов можно сформировать, просто введя квадратные скобки после имени типа. Например, `int[]` является одномерным массивом значений типа `int`, а `int[,]` — двумерным массивом значений типа `int`, тогда как `int[][]` представляет собой одномерный массив одномерных массивов (или массив массивов) значений типа `int`.

Типы, допускающие значение NULL, не требуют отдельного определения. Для каждого обычного типа `T`, который не допускает значение NULL, существует идентичный тип `T?`, который отличается только тем, что может содержать дополнительное значение `null`. Например, `int?` является типом, который может содержать любое 32-разрядное целое число или значение `null`, а `string?` — любое значение `string` или `null`.

Система типов в C# унифицирована таким образом, что значение любого типа можно рассматривать как `object` (объект). Каждый тип в C# является прямо или косвенно производным от типа класса `object`, и этот тип `object` является исходным базовым классом для всех типов. Чтобы значения ссылочного типа обрабатывались как объекты, им просто присваивается тип `object`. Чтобы значения типов значений обрабатывались как объекты, выполняются операции *упаковки-преобразования* и *распаковки-преобразования*. В следующем примере значение `int` преобразуется в `object`, а затем обратно в `int`.

:::code language="csharp" source="./snippets/shared/Program.cs" ID="boxing" :::

Если значение типа назначается ссылке `object`, для хранения значения выделяется упаковка. Эта упаковка является экземпляром ссылочного типа, и в нее копируется значение. И наоборот, если ссылка типа `object` используется для типа значения, для соответствующего `object` выполняется проверка, является ли он упаковкой правильного типа. Если эта проверка завершается успешно, копируется значение этой упаковки.

Унифицированная система типов C# фактически позволяет преобразовывать типы значений в ссылки `object` "по требованию". Такая унификация позволяет применять универсальные библиотеки, использующие тип `object`, со всеми типами, производными от `object`, включая как ссылочные типы, так и с типы значений.

В C# существует несколько типов *переменных*, в том числе поля, элементы массива, локальные переменные и параметры. Переменные представляют собой места хранения, и каждая переменная имеет тип, который определяет допустимые значения для хранения в этой переменной. Примеры представлены ниже.

- Тип значения, не допускающий значения Null
  - Значение такого типа
- Тип значения, допускающий значение Null
  - Значение `null` или значение такого типа
- object
  - Ссылка `null`, ссылка на объект любого ссылочного типа или ссылка на упакованное значение любого типа значения
- Тип класса
  - Ссылка `null`, ссылка на экземпляр такого типа класса или ссылка на экземпляр любого класса, производного от такого типа класса
- Тип интерфейса
  - Ссылка `null`, ссылка на экземпляр типа класса, который реализует такой тип интерфейса, или ссылка на упакованное значение типа значения, которое реализует такой тип интерфейса
- Тип массива
  - Ссылка `null`, ссылка на экземпляр такого типа массива или ссылка на экземпляр любого совместимого типа массива
- Тип делегата
  - Ссылка `null` или ссылка на экземпляр совместимого типа делегата

## <a name="program-structure"></a>Структура программы

В C# основными понятиями организационной структуры являются [***программы***](../programming-guide/inside-a-program/index.md), [***пространства имен***](../programming-guide/namespaces/index.md), [***типы***](../programming-guide/types/index.md), [***элементы***](../programming-guide/classes-and-structs/members.md) и [***сборки***](../../standard/assembly/index.md). В программе объявляются типы, которые содержат члены. Эти типы можно организовать в пространства имен. Примерами типов являются классы, структуры и интерфейсы. К членам относятся поля, методы, свойства и события. При компиляции программы на C# упаковываются в сборки. Сборка — это файл, обычно с расширением `.exe` или `.dll`, если она реализует ***приложение*** или ***библиотеку***, соответственно.

В качестве небольшого примера рассмотрим сборку, содержащую следующий код:

:::code language="csharp" source="./snippets/shared/AcmeStack.cs":::

Полное имя этого класса: `Acme.Collections.Stack`. Этот класс содержит несколько членов: поле с именем `top`, два метода с именами `Push` и `Pop`, а также вложенный класс с именем `Entry`. Класс `Entry`, в свою очередь, содержит три члена: поле с именем `next`, поле с именем `data` и конструктор. `Stack` — это *универсальный* класс. Он имеет параметр одного типа `T`, который замещается конкретным типом при использовании.

> [!NOTE]
> *Стек* — это коллекция типа FILO (прибыл первым — обслужен последним). Новые элементы добавляются в верх стека. При удалении элемента он удаляется из верха стека.

Сборки содержат исполняемый код в виде инструкций промежуточного языка (IL) и символьную информацию в виде метаданных. Перед выполнением JIT-компилятор среды CLR .NET преобразует код IL в сборке в код, зависящий от процессора.

Сборка полностью описывает сама себя и содержит весь код и метаданные, поэтому в C# не используются директивы `#include` и файлы заголовков. Чтобы использовать в программе C# открытые типы и члены, содержащиеся в определенной сборке, вам достаточно указать ссылку на эту сборку при компиляции программы. Например, эта программа использует класс `Acme.Collections.Stack` из сборки `acme.dll`:

:::code language="csharp" source="./snippets/shared/StackUsage.cs":::

Для компиляции программы вам потребуется создать *ссылку* на сборку, содержащую класс стека, определенный в примере выше.

Программы C# можно хранить в нескольких исходных файлах. При компиляции программы C# все исходные файлы обрабатываются вместе, при этом они могут свободно ссылаться друг на друга. По сути, это аналогично тому, как если бы все исходные файлы были объединены в один большой файл перед обработкой. В C# никогда не используются опережающие объявления, так как порядок объявления, за редким исключением, не играет никакой роли. В C# нет требований объявлять только один открытый тип в одном исходном файле, а также имя исходного файла не обязано совпадать с типом, объявляемом в этом файле.

Такие организационные блоки описываются в других статьях этого обзора.

>[!div class="step-by-step"]
>[Вперед](types.md)
