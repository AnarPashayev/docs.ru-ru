---
title: Обзор языка C# — руководство по C#
description: Вы еще не знакомы с C#? Изучите основы этого языка.
ms.date: 08/06/2020
ms.openlocfilehash: 9fa292e8e85832d831f36cf0f21512aa0cf32580
ms.sourcegitcommit: c4a15c6c4ecbb8a46ad4e67d9b3ab9b8b031d849
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "88656232"
---
# <a name="a-tour-of-the-c-language"></a><span data-ttu-id="a51f4-104">Краткий обзор языка C#</span><span class="sxs-lookup"><span data-stu-id="a51f4-104">A tour of the C# language</span></span>

<span data-ttu-id="a51f4-105">C# (произносится как "си шарп") — современный объектно-ориентированный и типобезопасный язык программирования.</span><span class="sxs-lookup"><span data-stu-id="a51f4-105">C# (pronounced "See Sharp") is a modern, object-oriented, and type-safe programming language.</span></span> <span data-ttu-id="a51f4-106">C# относится к широко известному семейству языков C, и покажется хорошо знакомым любому, кто работал с C, C++, Java или JavaScript.</span><span class="sxs-lookup"><span data-stu-id="a51f4-106">C# has its roots in the C family of languages and will be immediately familiar to C, C++, Java, and JavaScript programmers.</span></span> <span data-ttu-id="a51f4-107">Здесь представлен обзор основных компонентов языка C# 8 и более ранних версий.</span><span class="sxs-lookup"><span data-stu-id="a51f4-107">This tour provides an overview of the major components of the language in C# 8 and earlier.</span></span> <span data-ttu-id="a51f4-108">Если вы хотите изучить язык с помощью интерактивных примеров, рекомендуем поработать с [вводными руководствами по C#](../tutorials/intro-to-csharp/index.md).</span><span class="sxs-lookup"><span data-stu-id="a51f4-108">If you want to explore the language through interactive examples, try the [introduction to C#](../tutorials/intro-to-csharp/index.md) tutorials.</span></span>

<span data-ttu-id="a51f4-109">C# — это объектно- и ***компонентно-ориентированный*** язык программирования.</span><span class="sxs-lookup"><span data-stu-id="a51f4-109">C# is an object-oriented, ***component-oriented*** programming language.</span></span> <span data-ttu-id="a51f4-110">C# предоставляет языковые конструкции для непосредственной поддержки такой концепции работы. Благодаря этому C# подходит для создания и применения программных компонентов.</span><span class="sxs-lookup"><span data-stu-id="a51f4-110">C# provides language constructs to directly support these concepts, making C# a natural language in which to create and use software components.</span></span> <span data-ttu-id="a51f4-111">С момента создания язык C# обогатился функциями для поддержки новых рабочих нагрузок и современными рекомендациями по разработке ПО.</span><span class="sxs-lookup"><span data-stu-id="a51f4-111">Since its origin, C# has added features to support new workloads and emerging software design practices.</span></span>

<span data-ttu-id="a51f4-112">Вот лишь несколько функций языка C#, обеспечивающих надежность и устойчивость приложений.</span><span class="sxs-lookup"><span data-stu-id="a51f4-112">Several C# features aid in the construction of robust and durable applications.</span></span> <span data-ttu-id="a51f4-113">[***Сборка мусора***](../../standard/garbage-collection/index.md) автоматически освобождает память, занятую недостижимыми неиспользуемыми объектами.</span><span class="sxs-lookup"><span data-stu-id="a51f4-113">[***Garbage collection***](../../standard/garbage-collection/index.md) automatically reclaims memory occupied by unreachable unused objects.</span></span> <span data-ttu-id="a51f4-114">[***Обработка исключений***](../programming-guide/exceptions/index.md) предоставляет структурированный и расширяемый подход к обнаружению ошибок и восстановлению после них.</span><span class="sxs-lookup"><span data-stu-id="a51f4-114">[***Exception handling***](../programming-guide/exceptions/index.md) provides a structured and extensible approach to error detection and recovery.</span></span> <span data-ttu-id="a51f4-115">[***Лямбда-выражения***](../language-reference/operators/lambda-expressions.md) поддерживают приемы функционального программирования.</span><span class="sxs-lookup"><span data-stu-id="a51f4-115">[***Lambda expressions***](../language-reference/operators/lambda-expressions.md) support functional programming techniques.</span></span> <span data-ttu-id="a51f4-116">[***Синтаксис запросов***](../linq/index.md) создает общий шаблон для работы с данными из любого источника.</span><span class="sxs-lookup"><span data-stu-id="a51f4-116">[***Query syntax***](../linq/index.md) creates a common pattern for working with data from any source.</span></span> <span data-ttu-id="a51f4-117">Поддержка языков для [***асинхронных операций***](../programming-guide/concepts/async/index.md) предоставляет синтаксис для создания распределенных систем.</span><span class="sxs-lookup"><span data-stu-id="a51f4-117">Language support for [***asynchronous operations***](../programming-guide/concepts/async/index.md) provides syntax for building distributed systems.</span></span> <span data-ttu-id="a51f4-118">[***Сопоставление шаблонов***](..//pattern-matching.md) предоставляет синтаксис для простого разделения данных из алгоритмов в современных распределенных системах.</span><span class="sxs-lookup"><span data-stu-id="a51f4-118">[***Pattern matching***](..//pattern-matching.md) provides syntax to easily separate data from algorithms in modern distributed systems.</span></span> <span data-ttu-id="a51f4-119">В C# действует [***единая система типов***](../programming-guide/types/index.md).</span><span class="sxs-lookup"><span data-stu-id="a51f4-119">C# has a [***unified type system***](../programming-guide/types/index.md).</span></span> <span data-ttu-id="a51f4-120">Все типы C#, включая типы-примитивы, такие как `int` и `double`, наследуют от одного корневого типа `object`.</span><span class="sxs-lookup"><span data-stu-id="a51f4-120">All C# types, including primitive types such as `int` and `double`, inherit from a single root `object` type.</span></span> <span data-ttu-id="a51f4-121">Все типы используют общий набор операций,</span><span class="sxs-lookup"><span data-stu-id="a51f4-121">All types share a set of common operations.</span></span> <span data-ttu-id="a51f4-122">а значения любого типа можно хранить, передавать и обрабатывать схожим образом.</span><span class="sxs-lookup"><span data-stu-id="a51f4-122">Values of any type can be stored, transported, and operated upon in a consistent manner.</span></span> <span data-ttu-id="a51f4-123">Более того, C# поддерживает как определяемые пользователями ссылочные типы, так и типы значений.</span><span class="sxs-lookup"><span data-stu-id="a51f4-123">Furthermore, C# supports both user-defined reference types and value types.</span></span> <span data-ttu-id="a51f4-124">C# позволяет динамически выделять объекты и хранить упрощенные структуры в стеке.</span><span class="sxs-lookup"><span data-stu-id="a51f4-124">C# allows dynamic allocation of objects and in-line storage of lightweight structures.</span></span>

<span data-ttu-id="a51f4-125">В C# особое внимание уделяется ***управлению версиями*** для обеспечения совместимости программ и библиотек при их изменении.</span><span class="sxs-lookup"><span data-stu-id="a51f4-125">C# emphasizes ***versioning*** to ensure programs and libraries can evolve over time in a compatible manner.</span></span> <span data-ttu-id="a51f4-126">Вопросы управления версиями существенно повлияли на такие аспекты разработки C#, как раздельные модификаторы `virtual` и `override`, правила разрешения перегрузки методов и поддержка явного объявления членов интерфейса.</span><span class="sxs-lookup"><span data-stu-id="a51f4-126">Aspects of C#'s design that were directly influenced by versioning considerations include the separate `virtual` and `override` modifiers, the rules for method overload resolution, and support for explicit interface member declarations.</span></span>

## <a name="hello-world"></a><span data-ttu-id="a51f4-127">Здравствуй, мир</span><span class="sxs-lookup"><span data-stu-id="a51f4-127">Hello world</span></span>

<span data-ttu-id="a51f4-128">Для первого знакомства с языком программирования традиционно используется программа "Hello, World".</span><span class="sxs-lookup"><span data-stu-id="a51f4-128">The "Hello, World" program is traditionally used to introduce a programming language.</span></span> <span data-ttu-id="a51f4-129">Вот ее пример на C#:</span><span class="sxs-lookup"><span data-stu-id="a51f4-129">Here it is in C#:</span></span>

:::code language="csharp" interactive="try-dotnet" source="./snippets/shared/HelloWorld.cs":::

<span data-ttu-id="a51f4-130">Программа "Hello, World" начинается с директивы `using`, которая ссылается на пространство имен `System`.</span><span class="sxs-lookup"><span data-stu-id="a51f4-130">The "Hello, World" program starts with a `using` directive that references the `System` namespace.</span></span> <span data-ttu-id="a51f4-131">Пространства имен позволяют иерархически упорядочивать программы и библиотеки C#.</span><span class="sxs-lookup"><span data-stu-id="a51f4-131">Namespaces provide a hierarchical means of organizing C# programs and libraries.</span></span> <span data-ttu-id="a51f4-132">Пространства имен содержат типы и другие пространства имен. Например, пространство имен `System` содержит несколько типов (в том числе используемый в нашей программе класс `Console`) и несколько других пространств имен, таких как `IO` и `Collections`.</span><span class="sxs-lookup"><span data-stu-id="a51f4-132">Namespaces contain types and other namespaces—for example, the `System` namespace contains a number of types, such as the `Console` class referenced in the program, and a number of other namespaces, such as `IO` and `Collections`.</span></span> <span data-ttu-id="a51f4-133">Директива `using`, которая ссылается на пространство имен, позволяет использовать типы из этого пространства имен без указания полного имени.</span><span class="sxs-lookup"><span data-stu-id="a51f4-133">A `using` directive that references a given namespace enables unqualified use of the types that are members of that namespace.</span></span> <span data-ttu-id="a51f4-134">Благодаря директиве `using` в коде программы можно использовать сокращенное имя `Console.WriteLine` вместо полного варианта `System.Console.WriteLine`.</span><span class="sxs-lookup"><span data-stu-id="a51f4-134">Because of the `using` directive, the program can use `Console.WriteLine` as shorthand for `System.Console.WriteLine`.</span></span>

<span data-ttu-id="a51f4-135">Класс `Hello`, объявленный в программе "Hello, World", имеет только один член — это метод с именем `Main`.</span><span class="sxs-lookup"><span data-stu-id="a51f4-135">The `Hello` class declared by the "Hello, World" program has a single member, the method named `Main`.</span></span> <span data-ttu-id="a51f4-136">Метод `Main` объявлен с модификатором `static`.</span><span class="sxs-lookup"><span data-stu-id="a51f4-136">The `Main` method is declared with the `static` modifier.</span></span> <span data-ttu-id="a51f4-137">Методы экземпляра могут ссылаться на конкретный экземпляр объекта, используя ключевое слово `this`, а статические методы работают без ссылки на конкретный объект.</span><span class="sxs-lookup"><span data-stu-id="a51f4-137">While instance methods can reference a particular enclosing object instance using the keyword `this`, static methods operate without reference to a particular object.</span></span> <span data-ttu-id="a51f4-138">По стандартному соглашению точкой входа программы C# является статический метод с именем `Main`.</span><span class="sxs-lookup"><span data-stu-id="a51f4-138">By convention, a static method named `Main` serves as the entry point of a C# program.</span></span>

<span data-ttu-id="a51f4-139">Выходные данные программы создаются в методе `WriteLine` класса `Console` из пространства имен `System`.</span><span class="sxs-lookup"><span data-stu-id="a51f4-139">The output of the program is produced by the `WriteLine` method of the `Console` class in the `System` namespace.</span></span> <span data-ttu-id="a51f4-140">Этот класс предоставляется библиотеками стандартных классов, ссылки на которые компилятор по умолчанию добавляет автоматически.</span><span class="sxs-lookup"><span data-stu-id="a51f4-140">This class is provided by the standard class libraries, which, by default, are automatically referenced by the compiler.</span></span>

## <a name="types-and-variables"></a><span data-ttu-id="a51f4-141">Типы и переменные</span><span class="sxs-lookup"><span data-stu-id="a51f4-141">Types and variables</span></span>

<span data-ttu-id="a51f4-142">В C# существуют две разновидности типов: *ссылочные типы* и *типы значений*.</span><span class="sxs-lookup"><span data-stu-id="a51f4-142">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="a51f4-143">Переменные типа значений содержат непосредственно данные, а в переменных ссылочных типов хранятся ссылки на нужные данные, которые именуются объектами.</span><span class="sxs-lookup"><span data-stu-id="a51f4-143">Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="a51f4-144">Две переменные ссылочного типа могут ссылаться на один и тот же объект, поэтому может случиться так, что операции над одной переменной затронут объект, на который ссылается другая переменная.</span><span class="sxs-lookup"><span data-stu-id="a51f4-144">With reference types, it's possible for two variables to reference the same object and possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="a51f4-145">Каждая переменная типа значения имеет собственную копию данных, и операции над одной переменной не могут затрагивать другую (за исключением переменных параметров `ref` и `out`).</span><span class="sxs-lookup"><span data-stu-id="a51f4-145">With value types, the variables each have their own copy of the data, and it isn't possible for operations on one to affect the other (except for `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="a51f4-146">***Идентификатор*** является именем переменной.</span><span class="sxs-lookup"><span data-stu-id="a51f4-146">An ***identifier*** is a variable name.</span></span> <span data-ttu-id="a51f4-147">Идентификатор — это последовательность символов Юникода без пробелов.</span><span class="sxs-lookup"><span data-stu-id="a51f4-147">An identifier is a sequence of unicode characters without any whitespace.</span></span> <span data-ttu-id="a51f4-148">Идентификатор может быть зарезервированным словом C#, если он имеет префикс `@`.</span><span class="sxs-lookup"><span data-stu-id="a51f4-148">An identifier may be a C# reserved word, if it is prefixed by `@`.</span></span> <span data-ttu-id="a51f4-149">Это может быть полезно при взаимодействии с другими языками.</span><span class="sxs-lookup"><span data-stu-id="a51f4-149">That can be useful when interacting with other languages.</span></span>

<span data-ttu-id="a51f4-150">Типы значений в C# подразделяются на *простые типы*, *типы перечисления*, *типы структур* и *типы, допускающие значение NULL*.</span><span class="sxs-lookup"><span data-stu-id="a51f4-150">C#'s value types are further divided into *simple types*, *enum types*, *struct types*, and *nullable value types*.</span></span> <span data-ttu-id="a51f4-151">Ссылочные типы в C# подразделяются на *типы классов*, *типы интерфейсов*, *типы массивов* и *типы делегатов*.</span><span class="sxs-lookup"><span data-stu-id="a51f4-151">C#'s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="a51f4-152">Далее представлены общие сведения о системе типов в C#.</span><span class="sxs-lookup"><span data-stu-id="a51f4-152">The following outline provides an overview of C#'s type system.</span></span>

- [<span data-ttu-id="a51f4-153">Типы значений</span><span class="sxs-lookup"><span data-stu-id="a51f4-153">Value types</span></span>](../language-reference/builtin-types/value-types.md)
  - [<span data-ttu-id="a51f4-154">Простые типы</span><span class="sxs-lookup"><span data-stu-id="a51f4-154">Simple types</span></span>](../language-reference/builtin-types/value-types.md#built-in-value-types)
    - <span data-ttu-id="a51f4-155">[Целочисленный со знаком](../language-reference/builtin-types/integral-numeric-types.md): `sbyte`, `short`, `int`, `long`.</span><span class="sxs-lookup"><span data-stu-id="a51f4-155">[Signed integral](../language-reference/builtin-types/integral-numeric-types.md): `sbyte`, `short`, `int`, `long`</span></span>
    - <span data-ttu-id="a51f4-156">[Целочисленный без знака](../language-reference/builtin-types/integral-numeric-types.md): `byte`, `ushort`, `uint`, `ulong`.</span><span class="sxs-lookup"><span data-stu-id="a51f4-156">[Unsigned integral](../language-reference/builtin-types/integral-numeric-types.md): `byte`, `ushort`, `uint`, `ulong`</span></span>
    - <span data-ttu-id="a51f4-157">[Символы Юникода](../../standard/base-types/character-encoding-introduction.md): `char`, который представляет блок кода в кодировке UTF-16.</span><span class="sxs-lookup"><span data-stu-id="a51f4-157">[Unicode characters](../../standard/base-types/character-encoding-introduction.md): `char`, which represents a UTF-16 code unit</span></span>
    - <span data-ttu-id="a51f4-158">[Бинарный оператор IEEE с плавающей запятой](../language-reference/builtin-types/floating-point-numeric-types.md): `float`, `double`.</span><span class="sxs-lookup"><span data-stu-id="a51f4-158">[IEEE binary floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `float`, `double`</span></span>
    - <span data-ttu-id="a51f4-159">[Десятичное значение с повышенной точностью и плавающей запятой](../language-reference/builtin-types/floating-point-numeric-types.md): `decimal`.</span><span class="sxs-lookup"><span data-stu-id="a51f4-159">[High-precision decimal floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `decimal`</span></span>
    - <span data-ttu-id="a51f4-160">Логический: `bool`, используется для представления логических значений, которые могут иметь значение `true` или `false`.</span><span class="sxs-lookup"><span data-stu-id="a51f4-160">Boolean: `bool`, which represents Boolean values—values that are either `true` or `false`</span></span>
  - [<span data-ttu-id="a51f4-161">Типы перечисления</span><span class="sxs-lookup"><span data-stu-id="a51f4-161">Enum types</span></span>](../language-reference/builtin-types/enum.md)
    - <span data-ttu-id="a51f4-162">Пользовательские типы в формате `enum E {...}`.</span><span class="sxs-lookup"><span data-stu-id="a51f4-162">User-defined types of the form `enum E {...}`.</span></span> <span data-ttu-id="a51f4-163">Тип `enum` является отдельным типом со списком именованных констант.</span><span class="sxs-lookup"><span data-stu-id="a51f4-163">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="a51f4-164">Каждый тип `enum` имеет базовый тип, в роли которого выступает один из восьми целочисленных типов.</span><span class="sxs-lookup"><span data-stu-id="a51f4-164">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="a51f4-165">Набор значений типа `enum` аналогичен набору значений его базового типа.</span><span class="sxs-lookup"><span data-stu-id="a51f4-165">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>
  - [<span data-ttu-id="a51f4-166">Типы структур</span><span class="sxs-lookup"><span data-stu-id="a51f4-166">Struct types</span></span>](../language-reference/builtin-types/struct.md)
    - <span data-ttu-id="a51f4-167">Пользовательские типы в формате `struct S {...}`</span><span class="sxs-lookup"><span data-stu-id="a51f4-167">User-defined types of the form `struct S {...}`</span></span>
  - [<span data-ttu-id="a51f4-168">Типы значений, допускающие значение NULL</span><span class="sxs-lookup"><span data-stu-id="a51f4-168">Nullable value types</span></span>](../language-reference/builtin-types/nullable-value-types.md)
    - <span data-ttu-id="a51f4-169">Расширения других типов значений, допускающие значение `null`</span><span class="sxs-lookup"><span data-stu-id="a51f4-169">Extensions of all other value types with a `null` value</span></span>
  - [<span data-ttu-id="a51f4-170">Типы значений кортежей</span><span class="sxs-lookup"><span data-stu-id="a51f4-170">Tuple value types</span></span>](../language-reference/builtin-types/value-tuples.md)
    - <span data-ttu-id="a51f4-171">Пользовательские типы в формате `(T1, T2, ...)`</span><span class="sxs-lookup"><span data-stu-id="a51f4-171">User-defined types of the form `(T1, T2, ...)`</span></span>
- [<span data-ttu-id="a51f4-172">Ссылочные типы</span><span class="sxs-lookup"><span data-stu-id="a51f4-172">Reference types</span></span>](../language-reference/keywords/reference-types.md)
  - [<span data-ttu-id="a51f4-173">Типы классов</span><span class="sxs-lookup"><span data-stu-id="a51f4-173">Class types</span></span>](../language-reference/keywords/class.md)
    - <span data-ttu-id="a51f4-174">Исходный базовым классом для всех типов: `object`</span><span class="sxs-lookup"><span data-stu-id="a51f4-174">Ultimate base class of all other types: `object`</span></span>
    - <span data-ttu-id="a51f4-175">[Строки в Юникоде](../../standard/base-types/character-encoding-introduction.md): `string`, который представляет последовательность блоков кода в кодировке UTF-16.</span><span class="sxs-lookup"><span data-stu-id="a51f4-175">[Unicode strings](../../standard/base-types/character-encoding-introduction.md): `string`, which represents a sequence of UTF-16 code units</span></span>
    - <span data-ttu-id="a51f4-176">Пользовательские типы в формате `class C {...}`</span><span class="sxs-lookup"><span data-stu-id="a51f4-176">User-defined types of the form `class C {...}`</span></span>
  - [<span data-ttu-id="a51f4-177">Типы интерфейсов</span><span class="sxs-lookup"><span data-stu-id="a51f4-177">Interface types</span></span>](../language-reference/keywords/interface.md)
    - <span data-ttu-id="a51f4-178">Пользовательские типы в формате `interface I {...}`</span><span class="sxs-lookup"><span data-stu-id="a51f4-178">User-defined types of the form `interface I {...}`</span></span>
  - [<span data-ttu-id="a51f4-179">Типы массивов</span><span class="sxs-lookup"><span data-stu-id="a51f4-179">Array types</span></span>](../programming-guide/arrays/index.md)
    - <span data-ttu-id="a51f4-180">Одно-мерные, многомерные массивы и массивы массивов, например `int[]`, `int[,]` и `int[][]`.</span><span class="sxs-lookup"><span data-stu-id="a51f4-180">Single- and multi-dimensional and jagged, for example, `int[]`, `int[,]`, and `int[][]`</span></span>
  - [<span data-ttu-id="a51f4-181">Типы делегатов</span><span class="sxs-lookup"><span data-stu-id="a51f4-181">Delegate types</span></span>](../language-reference/builtin-types/reference-types.md#the-delegate-type)
    - <span data-ttu-id="a51f4-182">Пользовательские типы в формате `delegate int D(...)`</span><span class="sxs-lookup"><span data-stu-id="a51f4-182">User-defined types of the form `delegate int D(...)`</span></span>

<span data-ttu-id="a51f4-183">Программы C# используют *объявления типов* для создания новых типов.</span><span class="sxs-lookup"><span data-stu-id="a51f4-183">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="a51f4-184">В объявлении типа указываются имя и члены нового типа.</span><span class="sxs-lookup"><span data-stu-id="a51f4-184">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="a51f4-185">Пять категорий типов в C# определяются пользователем: типы классов, типы структур, типы интерфейсов, типы перечисления и типы делегатов.</span><span class="sxs-lookup"><span data-stu-id="a51f4-185">Five of C#'s categories of types are user-definable: class types, struct types, interface types, enum types, and delegate types.</span></span>

- <span data-ttu-id="a51f4-186">Тип `class` определяет структуру данных, которая содержит данные-члены (поля) и функции-члены (методы, свойства и т. д.).</span><span class="sxs-lookup"><span data-stu-id="a51f4-186">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="a51f4-187">Классы поддерживают механизмы одиночного наследования и полиморфизма, которые позволяют создавать производные классы, расширяющие и уточняющие определения базовых классов.</span><span class="sxs-lookup"><span data-stu-id="a51f4-187">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>
- <span data-ttu-id="a51f4-188">Тип `struct` похож на тип класса тем, что он представляет структуру с данными-членами и функциями-членами.</span><span class="sxs-lookup"><span data-stu-id="a51f4-188">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="a51f4-189">Но, в отличие от классов, структуры являются типами значений и обычно не требуют выделения памяти из кучи.</span><span class="sxs-lookup"><span data-stu-id="a51f4-189">However, unlike classes, structs are value types and don't typically require heap allocation.</span></span> <span data-ttu-id="a51f4-190">Типы структуры не поддерживают определяемое пользователем наследование, и все типы структуры неявно наследуют от типа `object`.</span><span class="sxs-lookup"><span data-stu-id="a51f4-190">Struct types don't support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>
- <span data-ttu-id="a51f4-191">Тип `interface` определяет контракт в виде именованного набора открытых элементов.</span><span class="sxs-lookup"><span data-stu-id="a51f4-191">An `interface` type defines a contract as a named set of public members.</span></span> <span data-ttu-id="a51f4-192">Объект типа `class` или `struct`, реализующий `interface`, должен предоставить реализации для всех элементов интерфейса.</span><span class="sxs-lookup"><span data-stu-id="a51f4-192">A `class` or `struct` that implements an `interface` must provide implementations of the interface's members.</span></span> <span data-ttu-id="a51f4-193">Тип `interface` может наследовать от нескольких базовых интерфейсов, а `class` или `struct` могут реализовывать несколько интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="a51f4-193">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>
- <span data-ttu-id="a51f4-194">Тип `delegate` (делегат) представляющий ссылки на методы с конкретным списком параметров и типом возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="a51f4-194">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="a51f4-195">Делегаты позволяют использовать методы как сущности, сохраняя их в переменные и передавая в качестве параметров.</span><span class="sxs-lookup"><span data-stu-id="a51f4-195">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="a51f4-196">Делегаты аналогичны типам функций, которые используются в функциональных языках.</span><span class="sxs-lookup"><span data-stu-id="a51f4-196">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="a51f4-197">Их принцип работы близок к указателям функций из некоторых языков.</span><span class="sxs-lookup"><span data-stu-id="a51f4-197">They're also similar to the concept of function pointers found in some other languages.</span></span> <span data-ttu-id="a51f4-198">В отличие от указателей функций, делегаты являются объектно-ориентированными и типобезопасными.</span><span class="sxs-lookup"><span data-stu-id="a51f4-198">Unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="a51f4-199">Типы `class`, `struct`, `interface` и `delegate` поддерживают универсальные шаблоны, которые позволяют передавать им другие типы в качестве параметров.</span><span class="sxs-lookup"><span data-stu-id="a51f4-199">The `class`, `struct`, `interface`, and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="a51f4-200">C# поддерживает одно- и многомерные массивы любого типа.</span><span class="sxs-lookup"><span data-stu-id="a51f4-200">C# supports single- and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="a51f4-201">В отличие от перечисленных выше типов, типы массивов не требуется объявлять перед использованием.</span><span class="sxs-lookup"><span data-stu-id="a51f4-201">Unlike the types listed above, array types don't have to be declared before they can be used.</span></span> <span data-ttu-id="a51f4-202">Типы массивов можно сформировать, просто введя квадратные скобки после имени типа.</span><span class="sxs-lookup"><span data-stu-id="a51f4-202">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="a51f4-203">Например, `int[]` является одномерным массивом значений типа `int`, а `int[,]` — двумерным массивом значений типа `int`, тогда как `int[][]` представляет собой одномерный массив одномерных массивов (или массив массивов) значений типа `int`.</span><span class="sxs-lookup"><span data-stu-id="a51f4-203">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional array or "jagged" array of `int`.</span></span>

<span data-ttu-id="a51f4-204">Типы, допускающие значение NULL, не требуют отдельного определения.</span><span class="sxs-lookup"><span data-stu-id="a51f4-204">Nullable types don't require a separate definition.</span></span> <span data-ttu-id="a51f4-205">Для каждого обычного типа `T`, который не допускает значение NULL, существует идентичный тип `T?`, который отличается только тем, что может содержать дополнительное значение `null`.</span><span class="sxs-lookup"><span data-stu-id="a51f4-205">For each non-nullable type `T`, there's a corresponding nullable type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="a51f4-206">Например, `int?` является типом, который может содержать любое 32-разрядное целое число или значение `null`, а `string?` — любое значение `string` или `null`.</span><span class="sxs-lookup"><span data-stu-id="a51f4-206">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`, and `string?` is a type that can hold any `string` or the value `null`.</span></span>

<span data-ttu-id="a51f4-207">Система типов в C# унифицирована таким образом, что значение любого типа можно рассматривать как `object` (объект).</span><span class="sxs-lookup"><span data-stu-id="a51f4-207">C#'s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="a51f4-208">Каждый тип в C# является прямо или косвенно производным от типа класса `object`, и этот тип `object` является исходным базовым классом для всех типов.</span><span class="sxs-lookup"><span data-stu-id="a51f4-208">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="a51f4-209">Чтобы значения ссылочного типа обрабатывались как объекты, им просто присваивается тип `object`.</span><span class="sxs-lookup"><span data-stu-id="a51f4-209">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="a51f4-210">Чтобы значения типов значений обрабатывались как объекты, выполняются операции *упаковки-преобразования* и *распаковки-преобразования*.</span><span class="sxs-lookup"><span data-stu-id="a51f4-210">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="a51f4-211">В следующем примере значение `int` преобразуется в `object`, а затем обратно в `int`.</span><span class="sxs-lookup"><span data-stu-id="a51f4-211">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

:::code language="csharp" source="./snippets/shared/Program.cs" ID="boxing" :::

<span data-ttu-id="a51f4-212">Если значение типа назначается ссылке `object`, для хранения значения выделяется упаковка.</span><span class="sxs-lookup"><span data-stu-id="a51f4-212">When a value of a value type is assigned to an `object` reference, a "box" is allocated to hold the value.</span></span> <span data-ttu-id="a51f4-213">Эта упаковка является экземпляром ссылочного типа, и в нее копируется значение.</span><span class="sxs-lookup"><span data-stu-id="a51f4-213">That box is an instance of a reference type, and the value is copied into that box.</span></span> <span data-ttu-id="a51f4-214">И наоборот, если ссылка типа `object` используется для типа значения, для соответствующего `object` выполняется проверка, является ли он упаковкой правильного типа.</span><span class="sxs-lookup"><span data-stu-id="a51f4-214">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type.</span></span> <span data-ttu-id="a51f4-215">Если эта проверка завершается успешно, копируется значение этой упаковки.</span><span class="sxs-lookup"><span data-stu-id="a51f4-215">If the check succeeds, the value in the box is copied to the value type.</span></span>

<span data-ttu-id="a51f4-216">Унифицированная система типов C# фактически позволяет преобразовывать типы значений в ссылки `object` "по требованию".</span><span class="sxs-lookup"><span data-stu-id="a51f4-216">C#'s unified type system effectively means that value types are treated as `object` references "on demand."</span></span> <span data-ttu-id="a51f4-217">Такая унификация позволяет применять универсальные библиотеки, использующие тип `object`, со всеми типами, производными от `object`, включая как ссылочные типы, так и с типы значений.</span><span class="sxs-lookup"><span data-stu-id="a51f4-217">Because of the unification, general-purpose libraries that use type `object` can be used with all types that derive from `object`, including both reference types and value types.</span></span>

<span data-ttu-id="a51f4-218">В C# существует несколько типов *переменных*, в том числе поля, элементы массива, локальные переменные и параметры.</span><span class="sxs-lookup"><span data-stu-id="a51f4-218">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="a51f4-219">Переменные представляют собой места хранения,</span><span class="sxs-lookup"><span data-stu-id="a51f4-219">Variables represent storage locations.</span></span> <span data-ttu-id="a51f4-220">и каждая переменная имеет тип, который определяет допустимые значения для хранения в этой переменной. Примеры представлены ниже.</span><span class="sxs-lookup"><span data-stu-id="a51f4-220">Every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

- <span data-ttu-id="a51f4-221">Тип значения, не допускающий значения Null</span><span class="sxs-lookup"><span data-stu-id="a51f4-221">Non-nullable value type</span></span>
  - <span data-ttu-id="a51f4-222">Значение такого типа</span><span class="sxs-lookup"><span data-stu-id="a51f4-222">A value of that exact type</span></span>
- <span data-ttu-id="a51f4-223">Тип значения, допускающий значение Null</span><span class="sxs-lookup"><span data-stu-id="a51f4-223">Nullable value type</span></span>
  - <span data-ttu-id="a51f4-224">Значение `null` или значение такого типа</span><span class="sxs-lookup"><span data-stu-id="a51f4-224">A `null` value or a value of that exact type</span></span>
- <span data-ttu-id="a51f4-225">object</span><span class="sxs-lookup"><span data-stu-id="a51f4-225">object</span></span>
  - <span data-ttu-id="a51f4-226">Ссылка `null`, ссылка на объект любого ссылочного типа или ссылка на упакованное значение любого типа значения</span><span class="sxs-lookup"><span data-stu-id="a51f4-226">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
- <span data-ttu-id="a51f4-227">Тип класса</span><span class="sxs-lookup"><span data-stu-id="a51f4-227">Class type</span></span>
  - <span data-ttu-id="a51f4-228">Ссылка `null`, ссылка на экземпляр такого типа класса или ссылка на экземпляр любого класса, производного от такого типа класса</span><span class="sxs-lookup"><span data-stu-id="a51f4-228">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
- <span data-ttu-id="a51f4-229">Тип интерфейса</span><span class="sxs-lookup"><span data-stu-id="a51f4-229">Interface type</span></span>
  - <span data-ttu-id="a51f4-230">Ссылка `null`, ссылка на экземпляр типа класса, который реализует такой тип интерфейса, или ссылка на упакованное значение типа значения, которое реализует такой тип интерфейса</span><span class="sxs-lookup"><span data-stu-id="a51f4-230">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
- <span data-ttu-id="a51f4-231">Тип массива</span><span class="sxs-lookup"><span data-stu-id="a51f4-231">Array type</span></span>
  - <span data-ttu-id="a51f4-232">Ссылка `null`, ссылка на экземпляр такого типа массива или ссылка на экземпляр любого совместимого типа массива</span><span class="sxs-lookup"><span data-stu-id="a51f4-232">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
- <span data-ttu-id="a51f4-233">Тип делегата</span><span class="sxs-lookup"><span data-stu-id="a51f4-233">Delegate type</span></span>
  - <span data-ttu-id="a51f4-234">Ссылка `null` или ссылка на экземпляр совместимого типа делегата</span><span class="sxs-lookup"><span data-stu-id="a51f4-234">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

## <a name="program-structure"></a><span data-ttu-id="a51f4-235">Структура программы</span><span class="sxs-lookup"><span data-stu-id="a51f4-235">Program structure</span></span>

<span data-ttu-id="a51f4-236">В C# основными понятиями организационной структуры являются [***программы***](../programming-guide/inside-a-program/index.md), [***пространства имен***](../programming-guide/namespaces/index.md), [***типы***](../programming-guide/types/index.md), [***элементы***](../programming-guide/classes-and-structs/members.md) и [***сборки***](../../standard/assembly/index.md).</span><span class="sxs-lookup"><span data-stu-id="a51f4-236">The key organizational concepts in C# are [***programs***](../programming-guide/inside-a-program/index.md), [***namespaces***](../programming-guide/namespaces/index.md), [***types***](../programming-guide/types/index.md), [***members***](../programming-guide/classes-and-structs/members.md), and [***assemblies***](../../standard/assembly/index.md).</span></span> <span data-ttu-id="a51f4-237">В программе объявляются типы, которые содержат члены. Эти типы можно организовать в пространства имен.</span><span class="sxs-lookup"><span data-stu-id="a51f4-237">Programs declare types, which contain members and can be organized into namespaces.</span></span> <span data-ttu-id="a51f4-238">Примерами типов являются классы, структуры и интерфейсы.</span><span class="sxs-lookup"><span data-stu-id="a51f4-238">Classes, structs, and interfaces are examples of types.</span></span> <span data-ttu-id="a51f4-239">К членам относятся поля, методы, свойства и события.</span><span class="sxs-lookup"><span data-stu-id="a51f4-239">Fields, methods, properties, and events are examples of members.</span></span> <span data-ttu-id="a51f4-240">При компиляции программы на C# упаковываются в сборки.</span><span class="sxs-lookup"><span data-stu-id="a51f4-240">When C# programs are compiled, they're physically packaged into assemblies.</span></span> <span data-ttu-id="a51f4-241">Сборка — это файл, обычно с расширением `.exe` или `.dll`, если она реализует ***приложение*** или ***библиотеку***, соответственно.</span><span class="sxs-lookup"><span data-stu-id="a51f4-241">Assemblies typically have the file extension `.exe` or `.dll`, depending on whether they implement ***applications*** or ***libraries***, respectively.</span></span>

<span data-ttu-id="a51f4-242">В качестве небольшого примера рассмотрим сборку, содержащую следующий код:</span><span class="sxs-lookup"><span data-stu-id="a51f4-242">As a small example, consider an assembly that contains the following code:</span></span>

:::code language="csharp" source="./snippets/shared/AcmeStack.cs":::

<span data-ttu-id="a51f4-243">Полное имя этого класса: `Acme.Collections.Stack`.</span><span class="sxs-lookup"><span data-stu-id="a51f4-243">The fully qualified name of this class is `Acme.Collections.Stack`.</span></span> <span data-ttu-id="a51f4-244">Этот класс содержит несколько членов: поле с именем `top`, два метода с именами `Push` и `Pop`, а также вложенный класс с именем `Entry`.</span><span class="sxs-lookup"><span data-stu-id="a51f4-244">The class contains several members: a field named `top`, two methods named `Push` and `Pop`, and a nested class named `Entry`.</span></span> <span data-ttu-id="a51f4-245">Класс `Entry`, в свою очередь, содержит три члена: поле с именем `next`, поле с именем `data` и конструктор.</span><span class="sxs-lookup"><span data-stu-id="a51f4-245">The `Entry` class further contains three members: a field named `next`, a field named `data`, and a constructor.</span></span> <span data-ttu-id="a51f4-246">`Stack` — это *универсальный* класс.</span><span class="sxs-lookup"><span data-stu-id="a51f4-246">The `Stack` is a *generic* class.</span></span> <span data-ttu-id="a51f4-247">Он имеет параметр одного типа `T`, который замещается конкретным типом при использовании.</span><span class="sxs-lookup"><span data-stu-id="a51f4-247">It has one type parameter, `T` that is replaced with a concrete type when it's used.</span></span>

> [!NOTE]
> <span data-ttu-id="a51f4-248">*Стек* — это коллекция типа FILO (прибыл первым — обслужен последним).</span><span class="sxs-lookup"><span data-stu-id="a51f4-248">A *stack* is a "first in - last out" (FILO) collection.</span></span> <span data-ttu-id="a51f4-249">Новые элементы добавляются в верх стека.</span><span class="sxs-lookup"><span data-stu-id="a51f4-249">New elements are added to the top of the stack.</span></span> <span data-ttu-id="a51f4-250">При удалении элемента он удаляется из верха стека.</span><span class="sxs-lookup"><span data-stu-id="a51f4-250">When an element is removed, it is removed from the top of the stack.</span></span>

<span data-ttu-id="a51f4-251">Сборки содержат исполняемый код в виде инструкций промежуточного языка (IL) и символьную информацию в виде метаданных.</span><span class="sxs-lookup"><span data-stu-id="a51f4-251">Assemblies contain executable code in the form of Intermediate Language (IL) instructions, and symbolic information in the form of metadata.</span></span> <span data-ttu-id="a51f4-252">Перед выполнением JIT-компилятор среды CLR .NET преобразует код IL в сборке в код, зависящий от процессора.</span><span class="sxs-lookup"><span data-stu-id="a51f4-252">Before it's executed, the Just-In-Time (JIT) compiler of .NET Common Language Runtime converts the IL code in an assembly to processor-specific code.</span></span>

<span data-ttu-id="a51f4-253">Сборка полностью описывает сама себя и содержит весь код и метаданные, поэтому в C# не используются директивы `#include` и файлы заголовков.</span><span class="sxs-lookup"><span data-stu-id="a51f4-253">Because an assembly is a self-describing unit of functionality containing both code and metadata, there's no need for `#include` directives and header files in C#.</span></span> <span data-ttu-id="a51f4-254">Чтобы использовать в программе C# открытые типы и члены, содержащиеся в определенной сборке, вам достаточно указать ссылку на эту сборку при компиляции программы.</span><span class="sxs-lookup"><span data-stu-id="a51f4-254">The public types and members contained in a particular assembly are made available in a C# program simply by referencing that assembly when compiling the program.</span></span> <span data-ttu-id="a51f4-255">Например, эта программа использует класс `Acme.Collections.Stack` из сборки `acme.dll`:</span><span class="sxs-lookup"><span data-stu-id="a51f4-255">For example, this program uses the `Acme.Collections.Stack` class from the `acme.dll` assembly:</span></span>

:::code language="csharp" source="./snippets/shared/StackUsage.cs":::

<span data-ttu-id="a51f4-256">Для компиляции программы вам потребуется создать *ссылку* на сборку, содержащую класс стека, определенный в примере выше.</span><span class="sxs-lookup"><span data-stu-id="a51f4-256">To compile this program, you would need to *reference* the assembly containing the stack class defined in the earlier example.</span></span>

<span data-ttu-id="a51f4-257">Программы C# можно хранить в нескольких исходных файлах.</span><span class="sxs-lookup"><span data-stu-id="a51f4-257">C# programs can be stored in several source files.</span></span> <span data-ttu-id="a51f4-258">При компиляции программы C# все исходные файлы обрабатываются вместе, при этом они могут свободно ссылаться друг на друга.</span><span class="sxs-lookup"><span data-stu-id="a51f4-258">When a C# program is compiled, all of the source files are processed together, and the source files can freely reference each other.</span></span> <span data-ttu-id="a51f4-259">По сути, это аналогично тому, как если бы все исходные файлы были объединены в один большой файл перед обработкой.</span><span class="sxs-lookup"><span data-stu-id="a51f4-259">Conceptually, it's as if all the source files were concatenated into one large file before being processed.</span></span> <span data-ttu-id="a51f4-260">В C# никогда не используются опережающие объявления, так как порядок объявления, за редким исключением, не играет никакой роли.</span><span class="sxs-lookup"><span data-stu-id="a51f4-260">Forward declarations are never needed in C# because, with few exceptions, declaration order is insignificant.</span></span> <span data-ttu-id="a51f4-261">В C# нет требований объявлять только один открытый тип в одном исходном файле, а также имя исходного файла не обязано совпадать с типом, объявляемом в этом файле.</span><span class="sxs-lookup"><span data-stu-id="a51f4-261">C# doesn't limit a source file to declaring only one public type nor does it require the name of the source file to match a type declared in the source file.</span></span>

<span data-ttu-id="a51f4-262">Такие организационные блоки описываются в других статьях этого обзора.</span><span class="sxs-lookup"><span data-stu-id="a51f4-262">Further articles in this tour explain these organizational blocks.</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="a51f4-263">Вперед</span><span class="sxs-lookup"><span data-stu-id="a51f4-263">Next</span></span>](types.md)
