---
title: История языка C# (руководство по C#)
description: На что был похож этот язык в ранних версиях и во что он превратился сейчас?
author: erikdietrich
ms.date: 09/20/2017
ms.openlocfilehash: 351e4de01a7c3c50cb815a99f0bde546848a9e51
ms.sourcegitcommit: 10986410e59ff29f2ec55c6759bde3eb4d1a00cb
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/31/2019
ms.locfileid: "66423239"
---
# <a name="the-history-of-c"></a>История языка C\#

В этой статье содержится описание основных выпусков языка C#. Команда разработчиков C# продолжает добавлять новые функции. Сведения о состоянии функции для отдельных языков, включая функции, которые будут добавлены в предстоящие выпуски, см. [в репозитории dotnet/roslyn](https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md) на сайте GitHub.

> [!IMPORTANT]
> В некоторых возможностях используются типы и методы, которые в спецификации C# определены как *стандартная библиотека*. Платформа .NET предоставляет эти типы и методы в разных пакетах. например, обработка исключений. Каждая инструкция и выражение `throw` проверяется, чтобы убедиться, что вызываемый объект является производным от <xref:System.Exception>. Аналогичным образом каждая инструкция `catch` проверяется, чтобы убедиться, что перехваченный тип является производным от <xref:System.Exception>. В каждой версии могут добавляться новые требования. Чтобы использовать новейшие возможности языка в старой среде, может потребоваться установить определенные библиотеки. Эти зависимости описаны на странице для каждой конкретной версии. Дополнительные сведения о связи между языком и библиотекой, а также общие сведения о такой зависимости см. [здесь](relationships-between-language-and-library.md).

Для использования средств сборки C# требуется последний основной выпуск версии языка по умолчанию. Основные выпуски, описанные в других статьях этого раздела, могут чередоваться с дополнительными выпусками. Чтобы использовать новые возможности доработанного выпуска, [настройте версию языка компилятора](../language-reference/configure-language-version.md), выбрав необходимую. После C# 7.0 было три дополнительных выпуска:

* [C# 7.3](csharp-7-3.md).
  - Версия C# 7.3 появилась в [Visual Studio 2017 версии 15.7](https://visualstudio.microsoft.com/vs/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link) и [пакете SDK для .NET Core 2.1](../../core/whats-new/dotnet-core-2-1.md).
* [C# 7.2](csharp-7-2.md).
  - Версия C# 7.2 появилась в [Visual Studio 2017 версии 15.5](https://visualstudio.microsoft.com/vs/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link) и [пакете SDK для .NET Core 2.0](../../core/whats-new/dotnet-core-2-0.md).
* [C# 7.1](csharp-7-1.md).
  - Версия C# 7.1 появилась в [Visual Studio 2017 версии 15.3](https://visualstudio.microsoft.com/vs/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link) и [пакете SDK для .NET Core 2.0](../../core/whats-new/dotnet-core-2-0.md).

## <a name="c-version-10"></a>C# версии 1.0

Если взглянуть на C# версии 1.0, станет очевидно его сходство с Java. В число [поставленных перед ECMA задач проектирования](https://feeldotneteasy.blogspot.com/2011/01/c-design-goals.html) входило создание "простого и современного объектно-ориентированного языка общего назначения".  В то время схожесть с Java означала достижение этих ранних целей проектирования.

Однако если взглянуть на C# 1.0 сейчас, вам может стать немного не по себе. В этой версии не было встроенных асинхронных возможностей и некоторых функций для универсальных шаблонов, к которым вы уже привыкли. Фактически, в ней вообще не было универсальных шаблонов.  А [LINQ](../linq/index.md)? Еще нет. Для добавления этих возможностей потребовалось несколько лет.

По современным меркам C# версии 1.0 не предоставлял практически никаких возможностей. Вам пришлось бы писать довольно подробный код. Однако надо же было с чего-то начинать. C# версии 1.0 был достойной альтернативой Java на платформе Windows.

Основные возможности C# 1.0 включали следующие компоненты:

- [Классы](../programming-guide/classes-and-structs/classes.md)
- [Структуры](../programming-guide/classes-and-structs/structs.md)
- [Интерфейсы](../programming-guide/interfaces/index.md)
- [События](../events-overview.md)
- [Свойства](../properties.md)
- [Делегаты](../delegates-overview.md)
- [Выражения](../programming-guide/statements-expressions-operators/expressions.md)
- [Операторы](../programming-guide/statements-expressions-operators/statements.md)
- [Атрибуты](../programming-guide/concepts/attributes/index.md)

## <a name="c-version-12"></a>Версия для C# 1.2

Версия C# 1.2 входит в состав Visual Studio 2003. Она содержит ряд небольших улучшений языка. Наиболее значительным изменением является то, что начиная с этой версии код, создаваемый в цикле `foreach`, вызывает <xref:System.IDisposable.Dispose%2A> в <xref:System.Collections.IEnumerator>, если <xref:System.Collections.IEnumerator> реализует <xref:System.IDisposable>.

## <a name="c-version-20"></a>C# версии 2.0

Вот теперь все становится гораздо интереснее. Давайте рассмотрим некоторые основные возможности языка C# 2.0, выпущенного в 2005 году вместе с Visual Studio 2005:

- [Универсальные шаблоны](../programming-guide/generics/index.md)
- [Разделяемые типы](../programming-guide/classes-and-structs/partial-classes-and-methods.md#partial-classes)
- [Анонимные методы](../programming-guide/statements-expressions-operators/anonymous-methods.md)
- [Типы, допускающие значения NULL](../programming-guide/nullable-types/index.md)
- [Итераторы](../programming-guide/concepts/iterators.md)
- [Ковариантность и контравариантность](../programming-guide/concepts/covariance-contravariance/index.md)

Другие возможности C# 2.0 расширяли существующие возможности:

- Отдельный доступ к методу получения и методу задания
- Преобразования групп методов (делегаты)
- Статические классы
- Выведение делегата

Хотя сначала C# и был универсальным объектно-ориентированным языком, в C# версии 2.0 все кардинально изменилось. Нащупав опору под ногами, команда уделила внимание решению серьезных проблем, с которыми сталкивались разработчики. И они подошли к делу с огоньком.

Благодаря универсальным шаблонам вы получаете типы и методы, которые могут работать с произвольным типом, при этом обеспечивая безопасность типа. В результате, например, наличие <xref:System.Collections.Generic.List%601> позволяет использовать `List<string>` или `List<int>` и совершать типобезопасные операции с этими строками или целыми числами, выполняя итерацию по ним. Использовать универсальные шаблоны удобнее, чем создавать `ListInt`, производный от `ArrayList`, или выполнять приведение из `Object` для каждой операции.

В C# версии 2.0 появились итераторы. Если кратко, итераторы позволяют изучать все элементы в `List` (или других перечислимых типов) с помощью цикла `foreach`. Наличие итераторов в качестве первоклассного компонента в языке значительно улучшило удобочитаемость языка и способность воспринимать код.

А еще C# продолжил играть в салки с Java. Для Java уже были выпущены версии, включающие универсальные шаблоны и итераторы. Но вскоре этому было суждено измениться, так как языки продолжили развиваться независимо.

## <a name="c-version-30"></a>C# версии 3.0

C# версии 3.0 был выпущен в конце 2007 года вместе с Visual Studio 2008, однако существенно набор возможностей языка пополнится только в .NET Framework версии 3.5. Эта версия ознаменовала кардинальное изменение развития C#. Она доказала, что C# действительно является достойным языком программирования. Давайте рассмотрим некоторые основные возможности в этой версии:

- [Автоматически реализуемые свойства](../programming-guide/classes-and-structs/auto-implemented-properties.md)
- [Анонимные типы](../programming-guide/classes-and-structs/anonymous-types.md)
- [Выражения запросов](../linq/query-expression-basics.md)
- [Лямбда-выражения](../programming-guide/statements-expressions-operators/lambda-expressions.md)
- [Деревья выражений](../expression-trees.md)
- [Методы расширения](../programming-guide/classes-and-structs/extension-methods.md)
- [Неявно типизированные локальные переменные](../language-reference/keywords/var.md)
- [Разделяемые методы](../language-reference/keywords/partial-method.md)
- [Инициализаторы объектов и коллекций](../programming-guide/classes-and-structs/object-and-collection-initializers.md)

Если оглянуться назад, становится ясно, что многие из этих возможностей не могли не появиться или появиться отдельно друг от друга. Все они образуют единый и стратегически значимый набор. Принято считать, что уникальным преимуществом C# было выражение запроса, которое также называется LINQ.

Немного углубившись, можно отметить деревья выражений, лямбда-выражения и анонимные типы как основу для создания LINQ. Однако в любом случае в C# 3.0 была представлена революционная концепция. Версия C# 3.0 начала закладывать фундамент для превращения C# в гибридный объектно-ориентированный/функциональный язык.

Среди прочего, теперь вы можете создавать декларативные запросы в стиле SQL для выполнения операций с коллекциями. Вместо создания цикла `for` для вычисления среднего значения из списка целых чисел теперь вам достаточно использовать `list.Average()`. Сочетание выражений запросов и методов расширения позволяет сделать работу со списком целых чисел гораздо интеллектуальнее.

Людям потребовалось некоторое время, чтобы принять эту концепцию и начать применять ее, но это у них получилось. А теперь, спустя несколько лет, код стал гораздо более кратким, простым и функциональным.

## <a name="c-version-40"></a>C# версии 4.0

Версии C# 4.0 пришлось приложить серьезные усилия, чтобы не отставать от новаторской версии 3.0. С появлением версии 3.0 язык C# смог выйти из тени Java и занять доминирующее положение. Он быстро становился утонченным и элегантным.

Следующая версия представила ряд интересных функций:

- [Динамическая привязка](../language-reference/keywords/dynamic.md)
- [Именованные/дополнительные аргументы](../programming-guide/classes-and-structs/named-and-optional-arguments.md)
- [Универсальная ковариантность и контравариантность](../../standard/generics/covariance-and-contravariance.md)
- [Внедренные типы взаимодействия](../../framework/interop/type-equivalence-and-embedded-interop-types.md)

Внедренные типы взаимодействия помогли сделать развертывание более удобным. Универсальная ковариантность и контравариантность расширяют возможности применения универсальных шаблонов, однако эти функции несколько академичны и высоко оценены авторами, создающими платформы и библиотеки. Именованные и дополнительные параметры позволяют избавиться от многих перегрузок методов и сделать работу более удобной. Однако ни одна из этих функций не является кардинальным изменением.

Значимым событием стало появление ключевого слова `dynamic`. Благодаря ключевому слову `dynamic` в C# версии 4.0 появилась возможность переопределять компилятор при типизации во время компиляции. Используя это ключевое слово, вы можете создавать конструкции, характерные для языков с динамической типизацией, таких как JavaScript. Вы можете создать `dynamic x = "a string"` и добавить туда шестерку, отложив решение о дальнейших действиях во времени выполнения.

Динамическое связывание подвержено ошибкам, однако открывает великолепные возможности внутри языка.

## <a name="c-version-50"></a>C# версии 5.0

Версия C# 5.0 была крайне целенаправленной. Практически все нововведения в этой версии касались другой инновационной концепции: модели `async` и `await` для асинхронного программирования.  Ниже приведен список основных функций:

- [Асинхронные члены](../async.md)
- [Информационные атрибуты вызывающего объекта](../programming-guide/concepts/caller-information.md)

### <a name="see-also"></a>См. также раздел

* [Code Project. Информационные атрибуты вызывающего объекта в C# 5.0](https://www.codeproject.com/Tips/606379/Caller-Info-Attributes-in-Csharp)

Информационный атрибут вызывающего объекта позволяет легко получать сведения о контексте, в котором выполняется работа, не прибегая к массивному стандартному коду отражения. Он находит обширное применение в задачах диагностики и ведения журнала.

Однако настоящими звездами этого выпуска являются `async` и `await`. После появления этих функций в 2012 г. C# удалось снова взять быка за рога, первоклассным образом внедрив асинхронность в язык. Если вы когда-либо сталкивались с длительными операциями и реализацией переплетающихся обратных вызовов, эта возможность, скорее всего, вам понравится.

## <a name="c-version-60"></a>C# версии 6.0

Версии 3.0 и 5.0 добавили в объектно-ориентированный язык C# несколько впечатляющих возможностей. Версия 6.0 отступает от проторенного пути по реализации уникальных возможностей и концентрируется на предоставлении незначительных функций, с которыми программирование на C# становится гораздо эффективнее. Вот некоторые из них:

- [Статические импорты](./csharp-6.md#using-static)
- [Фильтры исключений](./csharp-6.md#exception-filters)
- [Инициализаторы автосвойств](./csharp-6.md#auto-property-initializers)
- [Элементы, воплощающие выражение](./csharp-6.md#expression-bodied-function-members)
- [Null-распространитель](./csharp-6.md#null-conditional-operators)
- [Интерполяция строк](./csharp-6.md#string-interpolation)
- [Оператор nameof](./csharp-6.md#the-nameof-expression)
- [Инициализаторы индекса](csharp-6.md#extension-add-methods-in-collection-initializers)

Другие новые возможности:

- Выражение Await в блоках Catch и Finally
- Значения по умолчанию для свойств метода получения

Каждая из этих функций интересна сама по себе. Но если взглянуть на них вместе, заметна интересная особенность. В этой версии C# избавился от стандартного текста, чтобы сделать код более сжатым и удобочитаемым. Поэтому эта версия, несомненно, привлечет сторонников простого и понятного кода.

Еще одно новшество, связанное с этой версией, не является функцией языка в обычном понимании. Состоялся выпуск [компилятора Roslyn в виде службы](https://github.com/dotnet/roslyn). Теперь компилятор C# написан на C#, и вы можете использовать его при программировании.

## <a name="c-version-70"></a>C# версии 7.0

Сейчас последним основным номером версии для C# является 7.0. В этой версии получили развитие некоторые функции из версии C# 6.0, однако компилятор в виде службы отсутствует. Ниже приведены некоторые из новых функций:

- [Переменные Out](./csharp-7.md#out-variables)
- [Кортежи и деконструкция](./csharp-7.md#tuples)
- [Сопоставление шаблонов](./csharp-7.md#pattern-matching)
- [Локальные функции](./csharp-7.md#local-functions)
- [Расширенные элементы, воплощающие выражение](./csharp-7.md#more-expression-bodied-members)
- [Локальные переменные и возвращаемые значения Ref](./csharp-7.md#ref-locals-and-returns)

Другие возможности:

- [Операции удаления](./csharp-7.md#discards)
- [Двоичные литералы и цифровые разделители](./csharp-7.md#numeric-literal-syntax-improvements)
- [Выражения throw](./csharp-7.md#throw-expressions)

Все это предоставляет разработчиком множество новых возможностей и позволяет писать более понятный код. Важным аспектом является доработка объявления переменных путем использования ключевого слова `out` и поддержки нескольких возвращаемых значений благодаря кортежу.

Но при этом сфера применения C# продолжает расширяться. Теперь .NET Core подходит для любой операционной системы, а также уверенно движется в направлении облачных технологий и портативности.  Очевидно, что разработчики активно занимаются этими новыми возможностями наравне с добавлением новых функций.

_Статья_ [_изначально опубликована в блоге NDepend_](https://blog.ndepend.com/c-versions-look-language-history/) _, с разрешения Эрика Дитриха (Erik Dietrich) и Патрика Смачиа (Patrick Smacchia)._
