---
title: Новые возможности C# 6. Руководство по языку C#
description: Сведения о новых возможностях в C# 6
ms.date: 12/12/2018
ms.openlocfilehash: da40b4c9d4af0094fdd907c542e971ba55086e0f
ms.sourcegitcommit: 67ebdb695fd017d79d9f1f7f35d145042d5a37f7
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/20/2020
ms.locfileid: "92224233"
---
# <a name="whats-new-in-c-6"></a>Новые возможности C# 6

Версия C# 6.0 содержит множество функций, помогающих повысить производительность труда разработчиков. Общим эффектом этих функций является написание более краткого кода, который также является более удобным для чтения. Синтаксис содержит меньше формальных элементов для многих общих рекомендаций. Благодаря краткости становится проще понять назначение кода. Хорошо изучив эти возможности, вы сможете работать более производительно и создавать более читаемый код. Вы можете посвятить больше времени разработке вашей функциональности, а не конструкциям языка.

В оставшейся части этой статьи приведены общие сведения о каждой из этих функций со ссылкой для изучения каждого компонента. Вы также можете ознакомиться с функциями в [интерактивном обзоре по C# 6](../tutorials/exploration/csharp-6.yml) в разделе учебников.

## <a name="read-only-auto-properties"></a>Автосвойства, доступные только для чтения

*Автосвойства только для чтения* предоставляют более краткий синтаксис для создания неизменяемых типов. Автосвойство объявляется с помощью только метода доступа get:

[!code-csharp[ReadOnlyAutoProperty](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadOnlyAutoProperty)]

Свойства `FirstName` и `LastName` могут задаваться только в теле конструктора того же класса:

[!code-csharp[ReadOnlyAutoPropertyConstructor](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadOnlyAutoPropertyConstructor)]

Попытка задать `LastName` в другом методе создает ошибку компиляции `CS0200`:

```csharp
public class Student
{
    public string LastName { get;  }

    public void ChangeName(string newLastName)
    {
        // Generates CS0200: Property or indexer cannot be assigned to -- it is read only
        LastName = newLastName;
    }
}
```

Эта функция обеспечивает действительную поддержку создания неизменяемых типов на уровне языка и использование более краткого и удобного синтаксиса автосвойств.

Если в результате добавления такого синтаксиса доступный метод не удаляется, такое изменение считается [совместимым на уровне двоичного кода](version-update-considerations.md#binary-compatible-changes).

## <a name="auto-property-initializers"></a>Инициализаторы автосвойств

*Инициализаторы автосвойств* позволяют объявить начальное значение для автосвойства при объявлении свойства.

[!code-csharp[Initialization](../../../samples/snippets/csharp/new-in-6/newcode.cs#Initialization)]

Член `Grades` инициализируется там, где он объявлен. Это упрощает выполнение инициализации ровно один раз. Инициализация является частью объявления свойства, упрощая уравнение выделения хранилища с открытым интерфейсом для объектов `Student`.

## <a name="expression-bodied-function-members"></a>Члены функции, воплощающие выражение

Большое количество элементов, которые вы пишете, будут выражены одиночной инструкцией и могут быть отдельными выражениями. Вместо этого напишите элемент с телом выражения. Это работает для методов и свойств, доступных только для чтения. Например, переопределение `ToString()` часто бывает отличным кандидатом:

[!code-csharp[ToStringExpressionMember](../../../samples/snippets/csharp/new-in-6/newcode.cs#ToStringExpressionMember)]

Этот синтаксис также можно использовать для свойств только для чтения:

[!code-csharp[FullNameExpressionMember](../../../samples/snippets/csharp/new-in-6/newcode.cs#FullNameExpressionMember)]

Изменение существующего члена, воплощающего выражение, является [двоично совместимым изменением](version-update-considerations.md#binary-compatible-changes).

## <a name="using-static"></a>using static

Усовершенствование *using static* позволяет импортировать статические методы одного класса. Необходимо указать класс, который вы используете:

[!code-csharp[UsingStaticMath](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStaticMath)]

Объект <xref:System.Math> не содержит никаких элементов экземпляров. `using static` можно также использовать для импорта статических методов класса для класса, который содержит как статические методы, так и методы экземпляра. Одним из наиболее полезных примеров является <xref:System.String>:

[!code-csharp[UsingStatic](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStatic)]

> [!NOTE]
> В операторе static using необходимо использовать полное имя класса, `System.String`.  Нельзя использовать вместо него ключевое слово `string`.

При импорте из оператора `static using` методы расширения находятся в области только при вызове с помощью синтаксиса вызова метода расширения. Это не так при вызове в качестве статического метода. Это часто встречается в запросах LINQ. Шаблон LINQ можно импортировать путем импорта <xref:System.Linq.Enumerable> или <xref:System.Linq.Queryable>.

[!code-csharp[UsingStaticLinq](../../../samples/snippets/csharp/new-in-6/newcode.cs#usingStaticLinq)]

Обычно методы расширения вызываются с помощью выражения вызова метода расширения. Добавление имени класса в тех редких случаях, где их можно вызывать с помощью вызова статического метода, устраняет неоднозначность.

Директива `static using` также импортирует все вложенные типы. Вы можете ссылаться на любые вложенные типы без указания полного имени.

## <a name="null-conditional-operators"></a>Условные операторы NULL

*Условный оператор NULL* существенно упрощает проверки на NULL. Замените доступ к члену `.` оператором `?.`:

[!code-csharp[NullConditional](../../../samples/snippets/csharp/new-in-6/program.cs#NullConditional)]

В предыдущем примере переменная `first` назначается `null`, если объект person имеет значение `null`. В противном случае назначается значение свойства `FirstName`. Важно то, что `?.` означает, что эта строка кода не создает `NullReferenceException`, если переменная `person` имеет значение `null`. Вместо этого выполняется сокращенное вычисление, и возвращается `null`. Можно также использовать условный оператор NULL для доступа к массиву или индексатору. Замените `[]` на `?[]` в выражении индекса.

Следующее выражение возвращает `string`, независимо от значения `person`. Эта конструкция часто используется с оператором *объединения со значением NULL* для присвоения значений по умолчанию, если одно из свойств имеет значение `null`. В случае сокращенного вычисления выражений возвращаемое значение `null` имеет тип для сопоставления с полным выражением.

[!code-csharp[NullCoalescing](../../../samples/snippets/csharp/new-in-6/program.cs#NullCoalescing)]

`?.` также можно использовать для условного вызова методов. Чаще всего функции-члены с условным оператором NULL используются для безопасного вызова делегатов (или обработчиков событий), которые могут иметь значение `null`.  Это делается путем вызова метода `Invoke` делегата с помощью оператора `?.` для доступа к члену. Вы увидите пример в статье [Шаблоны делегатов](../delegates-patterns.md#handling-null-delegates).

Правила оператора `?.` гарантируют, что левая часть оператора вычисляется только один раз. Это обеспечивает поддержку многих идиом, включая пример с использованием обработчиков событий.

```csharp
// preferred in C# 6:
this.SomethingHappened?.Invoke(this, eventArgs);
```

Обеспечение того, что левая часть вычисляется только один раз, также позволяет использовать любое выражение, включая вызовы методов, в левой части `?.`

## <a name="string-interpolation"></a>Интерполяция строк

В C# 6 новая функция [интерполяции строк](../language-reference/tokens/interpolated.md) позволяет внедрять выражения в строку. Просто добавьте перед строкой префикс `$` и используйте выражения между `{` и `}` вместо порядковых номеров:

[!code-csharp[stringInterpolation](../../../samples/snippets/csharp/new-in-6/newcode.cs#FullNameExpressionMember)]

В этом примере для замененных выражений используются свойства. Можно использовать любое выражение. Например, можно вычислить средний балл учащегося как часть интерполяции:

[!code-csharp[stringInterpolationFormat](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationFormat)]

Предыдущая строка кода форматирует значение для `Grades.Average()` как число с плавающей запятой с двумя десятичными разрядами.

Часто требуется отформатировать строку, полученную с использованием конкретного языка и региональных параметров. Для этого положитесь на тот факт, что объект, созданный в результате интерполяции строк, можно неявно преобразовывать в <xref:System.FormattableString?displayProperty=nameWithType>. Экземпляр <xref:System.FormattableString> содержит составную строку формата и результаты вычисления выражений до преобразования в строки. С помощью метода <xref:System.FormattableString.ToString(System.IFormatProvider)?displayProperty=nameWithType> вы можете явно указать язык и региональные параметры при форматировании строки. Так, приведенный ниже пример создает строку, используя немецкий язык (de-DE) в качестве языка и региональных параметров. (В качестве десятичного разделителя в немецком обычно используется символ ",", а "." — в качестве разделителя тысяч.)

```csharp
FormattableString str = $"Average grade is {s.Grades.Average()}";
var gradeStr = str.ToString(new System.Globalization.CultureInfo("de-DE"));
```

Чтобы начать работу с интерполяцией строк, см. интерактивный учебник [Интерполяция строк в C#](../tutorials/exploration/interpolated-strings.yml), статью [Интерполяция](../language-reference/tokens/interpolated.md) и учебник [Интерполяция строк в C#](../tutorials/string-interpolation.md).

## <a name="exception-filters"></a>Фильтры исключений

*Фильтры исключений*  — это предложения, которые определяют, когда должно применяться данное предложение catch. Если выражение, используемое для фильтра исключений, принимает значение `true`, предложение catch выполняет обычную обработку исключения. Если выражение принимает значение `false`, то предложение `catch` пропускается. Например, эту функцию можно использовать для просмотра сведений об исключении, чтобы определить, может ли предложение `catch` обработать исключение:

[!code-csharp[ExceptionFilter](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#ExceptionFilter)]

## <a name="the-nameof-expression"></a>Выражение `nameof`

Результатом применения выражения [nameof](../language-reference/operators/nameof.md) является имя символа. Это отличный способ заставить инструменты работать, если вам требуется имя переменной, свойства или поля члена. Одно из наиболее распространенных применений `nameof` — предоставление имени символа, который вызвал исключение:

[!code-csharp[nameof](../../../samples/snippets/csharp/new-in-6/NewCode.cs#UsingStaticString)]

Другая сфера применения — с приложениями на основе XAML, реализующими интерфейс `INotifyPropertyChanged`:

[!code-csharp[nameofNotify](../../../samples/snippets/csharp/new-in-6/viewmodel.cs#nameofNotify)]

## <a name="await-in-catch-and-finally-blocks"></a>Выражение Await в блоках Catch и Finally

В C# 5 было несколько ограничений в отношении размещения выражений `await`. В C# 6 вы можете использовать `await` в выражениях `catch` или `finally`. Чаще всего это используется в сценариях ведения журнала:

[!code-csharp[AwaitFinally](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#AwaitFinally)]

Реализация добавления поддержки `await` внутри предложений `catch` и `finally` гарантирует согласованность поведения с поведением для синхронного кода. Если код, выполняемый в предложении `catch` или `finally`, создает исключение, выполнение ищет подходящее предложение `catch` в следующем окружающем блоке. При наличии текущего исключения это исключение будет потеряно. То же самое происходит с ожидаемыми выражениями в предложениях `catch` и `finally`: выполняется поиск подходящего `catch`, а текущее исключение (при наличии) утрачивается.  

> [!NOTE]
> Это поведение лежит в основе рекомендации тщательного написания предложений `catch` и `finally` во избежание внесения новых исключений.

## <a name="initialize-associative-collections-using-indexers"></a>Инициализация ассоциативных коллекций с помощью индексаторов

*Инициализаторы индекса* — это одна из двух функций, обеспечивающих согласованность инициализаторов коллекций с использованием индексов. В более ранних версиях C# можно было использовать *инициализаторы коллекций* с коллекциями типа последовательности, включая <xref:System.Collections.Generic.Dictionary%602>, заключая пару ключ-значение в фигурные скобки:

[!code-csharp[ListInitializer](../../../samples/snippets/csharp/new-in-6/initializers.cs#CollectionInitializer)]

Вы можете использовать их с коллекциями <xref:System.Collections.Generic.Dictionary%602> и другими типами, где доступный метод `Add` принимает более одного аргумента. Новый синтаксис поддерживает назначение в коллекцию с помощью индекса:

[!code-csharp[DictionaryInitializer](../../../samples/snippets/csharp/new-in-6/initializers.cs#DictionaryInitializer)]

Эта функция означает, что ассоциативные контейнеры могут быть инициализированы с помощью синтаксиса, аналогичного используемому для контейнеров последовательностей для нескольких версий.

## <a name="extension-add-methods-in-collection-initializers"></a>Методы расширения `Add` в инициализаторах коллекций

Еще одна функция, упрощающая инициализацию коллекций, — это возможность использования *метода расширения* для метода `Add`. Эта функция была добавлена для согласования с Visual Basic. Она наиболее удобна при наличии пользовательского класса коллекции, имеющего метод с другим именем для семантического добавления новых элементов.

## <a name="improved-overload-resolution"></a>Улучшенное разрешение перегрузки

Эта последняя функция, на которую вы, вероятно, не обратите внимания. Есть примеры того, что предыдущая версия компилятора C# могла определять некоторые вызовы методов, работающих с лямбда-выражениями, как неоднозначные. Рассмотрим этот метод:

[!code-csharp[AsyncMethod](../../../samples/snippets/csharp/new-in-6/overloads.cs#AsyncMethod)]

В более ранних версиях C# вызов этого метода с использованием синтаксиса группы методов приведет к сбою:

[!code-csharp[MethodGroup](../../../samples/snippets/csharp/new-in-6/overloads.cs#MethodGroup)]

Компилятор прежних версий не мог правильно различать методы `Task.Run(Action)` и `Task.Run(Func<Task>())`. В предыдущих версиях вам бы потребовалось использовать лямбда-выражение в качестве аргумента:

[!code-csharp[Lambda](../../../samples/snippets/csharp/new-in-6/overloads.cs#Lambda)]

Компилятор C# 6 правильно определяет, что `Task.Run(Func<Task>())` является лучшим вариантом.

### <a name="deterministic-compiler-output"></a>Детерминированные выходные данные компилятора

Параметр `-deterministic` дает компилятору инструкцию создать полностью идентичную выходную сборку для последовательных компиляций одного исходного файла.

По умолчанию каждая компиляция выдает уникальные выходные данные. Компилятор добавляет метку времени и идентификатор GUID из случайных чисел. Используйте этот параметр для побайтового сравнения выходных данных и гарантии согласованности сборок.

Дополнительные сведения см. в статье [Параметр компилятора -deterministic](../language-reference/compiler-options/deterministic-compiler-option.md).
