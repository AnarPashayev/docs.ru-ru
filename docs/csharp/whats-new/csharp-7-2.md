---
title: Новые возможности C# 7.2
description: Обзор новых возможностей в C# 7.2.
ms.date: 08/16/2017
ms.openlocfilehash: 7febefb81bbea6f24690adb05488ad6a18bbf552
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "75694599"
---
# <a name="whats-new-in-c-72"></a>Новые возможности C# 7.2

В очередной версии C# 7.2 реализован ряд новых полезных возможностей.
Одной из основных задач этого выпуска стало повышение эффективности работы с типами значений за счет исключения избыточных операций копирования и выделения памяти.

Остальные нововведения реализованы преимущественно для удобства.

В C# 7.2 предусмотрен элемент управления [выбором версии языка](../language-reference/configure-language-version.md), с помощью которого можно задать версию языка компилятора.

Новые языковые функции в этом выпуске

- [Методы написания безопасного и эффективного кода](#safe-efficient-code-enhancements)
  - Ряд улучшений синтаксиса, обеспечивающих работу с типами значений с использованием семантики ссылок.
- [Неконечные именованные аргументы](#non-trailing-named-arguments)
  - После именованных аргументов могут следовать позиционные аргументы.
- [Начальные символы подчеркивания в числовых литералах](#leading-underscores-in-numeric-literals)
  - Перед любыми печатными знаками в числовых литералах теперь могут использоваться начальные знаки подчеркивания.
- [Модификатор доступа `private protected`](#private-protected-access-modifier)
  - Модификатор доступа `private protected` разрешает доступ для производных классов в одной сборке.
- [Условные выражения`ref`](#conditional-ref-expressions)
  - Результат условного выражения `?:` теперь может быть ссылкой.

В оставшейся части этой статьи представлены общие сведения об этих функциях. Каждая функция сопровождается обоснованием. Вы изучите синтаксис Эти функции можно изучить в своей среде с помощью глобального средства `dotnet try`:

1. Установите глобальное средство [dotnet-try](https://github.com/dotnet/try/blob/master/README.md#setup).
1. Клонируйте репозиторий [dotnet/try-samples](https://github.com/dotnet/try-samples).
1. Для репозитория *try-samples* установите в качестве текущего каталога подкаталог *csharp7*.
1. Выполните `dotnet try`.

## <a name="safe-efficient-code-enhancements"></a>Улучшения для написания безопасного и эффективного кода

Представленные в версии 7.2 языковые функции обеспечивают работу с типами значений с использованием семантики ссылок. Благодаря этому удается повысить производительность за счет использования минимального числа операций копирования типов значений без выделения памяти в связи с применением ссылочных типов. Доступны следующие функции:

- модификатор `in` для параметров, указывающий, что аргумент передается по ссылке, но не изменяется вызываемым методом; Добавление модификатора `in` к аргументу является [изменением, совместимым на уровне исходного кода](version-update-considerations.md#source-compatible-changes).
- модификатор `ref readonly` для возвращаемого значения метода, указывающий, что метод возвращает значение по ссылке, но не допускает операции записи в соответствующий объект; Добавление модификатора `ref readonly` к аргументу является [изменением, совместимым на уровне исходного кода](version-update-considerations.md#source-compatible-changes), если оператору return присваивается значение. Добавление модификатора `readonly` к существующему оператору return `ref` является [несовместимым изменением](version-update-considerations.md#incompatible-changes). Требуется указать вызывающие объекты, чтобы добавить модификатор `ref` в объявление локальных переменных `readonly`.
- объявление `readonly struct`, указывающее, что структура является неизменяемой и должна передаваться в методы члена как параметр `in`; Добавление модификатора `readonly` к существующему объявлению структуры является [двоично совместимым изменением](version-update-considerations.md#binary-compatible-changes).
- объявление `ref struct`, указывающее, что тип структуры обращается напрямую к управляемой памяти и всегда должен обрабатываться с выделением стека. Добавление модификатора `ref` к существующему объявлению `struct` является [двоично совместимым изменением](version-update-considerations.md#incompatible-changes). Объект `ref struct` не может быть членом класса или использоваться в других местах, где он может выделяться в куче.

Дополнительные сведения обо всех эти изменениях см. в статье о том, как [писать безопасный и эффективный код](../write-safe-efficient-code.md).

## <a name="non-trailing-named-arguments"></a>Неконечные именованные аргументы

В вызовах методов после находящихся в правильной позиции именованных аргументов теперь можно использовать позиционные аргументы. Дополнительные сведения см. в разделе [Именованные и необязательные аргументы](../programming-guide/classes-and-structs/named-and-optional-arguments.md).

## <a name="leading-underscores-in-numeric-literals"></a>Начальные символы подчеркивания в числовых литералах

Из-за того, как в версии C# 7.0 была реализована поддержка разделителей между знаками, в качестве первого знака в значении литерала нельзя было использовать символ `_`. Теперь шестнадцатеричные и двоичные числовые литералы могут начинаться со знака `_`.

Пример:

```csharp
int binaryValue = 0b_0101_0101;
```

## <a name="private-protected-access-modifier"></a>*private protected* — модификатор доступа

Новый составной модификатор доступа `private protected` указывает, что доступ к члену может осуществляться содержащим классом или производными классами, которые объявлены в рамках одной сборки. В отличие от модификатора `protected internal`, который разрешает доступ производным классам или классам из той же сборки, `private protected` ограничивает доступ только для производных классов, объявленных в рамках одной сборки.

Дополнительные сведения см. в разделе [Модификаторы доступа](../language-reference/keywords/access-modifiers.md) в справочнике по языку.

## <a name="conditional-ref-expressions"></a>Условные выражения `ref`

Результат условного выражения может быть ссылкой, а не значением. Например, можно написать следующий код, чтобы получить ссылку на первый элемент в одном из двух массивов:

```csharp
ref var r = ref (arr != null ? ref arr[0] : ref otherArr[0]);
```

Переменная `r` — это ссылка на первое значение в `arr` или `otherArr`.

Дополнительные сведения см. в описании [условного оператора (?:)](../language-reference/operators/conditional-operator.md) в справочнике по языку.
