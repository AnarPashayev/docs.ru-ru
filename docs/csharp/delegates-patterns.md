---
title: Общие шаблоны делегатов
description: Сведения об общих шаблонах, позволяющих использовать делегаты в коде и избежать возникновения сильных взаимозависимостей между компонентами.
ms.date: 06/20/2016
ms.assetid: 0ff8fdfd-6a11-4327-b061-0f2526f35b43
ms.openlocfilehash: 22ab88e5b139381e3a8921baa20df035f1405146
ms.sourcegitcommit: 67ebdb695fd017d79d9f1f7f35d145042d5a37f7
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/20/2020
ms.locfileid: "92223684"
---
# <a name="common-patterns-for-delegates"></a><span data-ttu-id="f5d10-103">Общие шаблоны делегатов</span><span class="sxs-lookup"><span data-stu-id="f5d10-103">Common Patterns for Delegates</span></span>

[<span data-ttu-id="f5d10-104">Назад</span><span class="sxs-lookup"><span data-stu-id="f5d10-104">Previous</span></span>](delegates-strongly-typed.md)

<span data-ttu-id="f5d10-105">Делегаты предоставляют механизм, который обеспечивает проектирование программного обеспечения с минимальной взаимозависимостью между компонентами.</span><span class="sxs-lookup"><span data-stu-id="f5d10-105">Delegates provide a mechanism that enables software designs involving minimal coupling between components.</span></span>

<span data-ttu-id="f5d10-106">Отличным примером такого проектирования является LINQ.</span><span class="sxs-lookup"><span data-stu-id="f5d10-106">One excellent example for this kind of design is LINQ.</span></span> <span data-ttu-id="f5d10-107">В модели выражений запросов LINQ делегаты применяются для обеспечения всех возможностей.</span><span class="sxs-lookup"><span data-stu-id="f5d10-107">The LINQ Query Expression Pattern relies on delegates for all of its features.</span></span> <span data-ttu-id="f5d10-108">Рассмотрим простой пример.</span><span class="sxs-lookup"><span data-stu-id="f5d10-108">Consider this simple example:</span></span>

```csharp
var smallNumbers = numbers.Where(n => n < 10);
```

<span data-ttu-id="f5d10-109">В нем из последовательности чисел отфильтровываются только числа со значением меньше 10.</span><span class="sxs-lookup"><span data-stu-id="f5d10-109">This filters the sequence of numbers to only those less than the value 10.</span></span>
<span data-ttu-id="f5d10-110">Метод `Where` использует делегат, который определяет, какие элементы последовательности проходят через фильтр.</span><span class="sxs-lookup"><span data-stu-id="f5d10-110">The `Where` method uses a delegate that determines which elements of a sequence pass the filter.</span></span> <span data-ttu-id="f5d10-111">При создании запроса LINQ вы предоставляете реализацию делегата для этой цели.</span><span class="sxs-lookup"><span data-stu-id="f5d10-111">When you create a LINQ query, you supply the implementation of the delegate for this specific purpose.</span></span>

<span data-ttu-id="f5d10-112">Прототип метода Where имеет следующий вид:</span><span class="sxs-lookup"><span data-stu-id="f5d10-112">The prototype for the Where method is:</span></span>

```csharp
public static IEnumerable<TSource> Where<TSource> (this IEnumerable<TSource> source, Func<TSource, bool> predicate);
```

<span data-ttu-id="f5d10-113">Этот пример актуален для всех методов, которые относятся к LINQ.</span><span class="sxs-lookup"><span data-stu-id="f5d10-113">This example is repeated with all the methods that are part of LINQ.</span></span> <span data-ttu-id="f5d10-114">Все они используют делегаты для управления определенными запросами.</span><span class="sxs-lookup"><span data-stu-id="f5d10-114">They all rely on delegates for the code that manages the specific query.</span></span> <span data-ttu-id="f5d10-115">Этот конструктивный шаблон API очень эффективен, что делает его важным для изучения и понимания.</span><span class="sxs-lookup"><span data-stu-id="f5d10-115">This API design pattern is a very powerful one to learn and understand.</span></span>

<span data-ttu-id="f5d10-116">Из этого примера видно, что делегаты почти не требуют взаимозависимости между компонентами.</span><span class="sxs-lookup"><span data-stu-id="f5d10-116">This simple example illustrates how delegates require very little coupling between components.</span></span> <span data-ttu-id="f5d10-117">Не нужно создавать класс, производный от некоторого базового класса.</span><span class="sxs-lookup"><span data-stu-id="f5d10-117">You don't need to create a class that derives from a particular base class.</span></span> <span data-ttu-id="f5d10-118">Не нужно реализовывать определенный интерфейс.</span><span class="sxs-lookup"><span data-stu-id="f5d10-118">You don't need to implement a specific interface.</span></span>
<span data-ttu-id="f5d10-119">Единственным требованием является предоставление реализации одного метода, на основе которого решается поставленная задача.</span><span class="sxs-lookup"><span data-stu-id="f5d10-119">The only requirement is to provide the implementation of one method that is fundamental to the task at hand.</span></span>

## <a name="building-your-own-components-with-delegates"></a><span data-ttu-id="f5d10-120">Создание собственных компонентов с помощью делегатов</span><span class="sxs-lookup"><span data-stu-id="f5d10-120">Building Your Own Components with Delegates</span></span>

<span data-ttu-id="f5d10-121">Давайте продолжим пример, создав компонент с помощью модели, основанной на делегатах.</span><span class="sxs-lookup"><span data-stu-id="f5d10-121">Let's build on that example by creating a component using a design that relies on delegates.</span></span>

<span data-ttu-id="f5d10-122">Определим компонент, который можно использовать для сообщений журнала в большой системе.</span><span class="sxs-lookup"><span data-stu-id="f5d10-122">Let's define a component that could be used for log messages in a large system.</span></span> <span data-ttu-id="f5d10-123">Компоненты библиотеки можно использовать во множестве разных сред на различных платформах.</span><span class="sxs-lookup"><span data-stu-id="f5d10-123">The library components could be used in many different environments, on multiple different platforms.</span></span> <span data-ttu-id="f5d10-124">В компонентах, управляющих журналами, много общих черт.</span><span class="sxs-lookup"><span data-stu-id="f5d10-124">There are a lot of common features in the component that manages the logs.</span></span> <span data-ttu-id="f5d10-125">Они должны принимать сообщения от любого компонента системы.</span><span class="sxs-lookup"><span data-stu-id="f5d10-125">It will need to accept messages from any component in the system.</span></span> <span data-ttu-id="f5d10-126">Эти сообщения имеют разные приоритеты, которыми управляет основной компонент.</span><span class="sxs-lookup"><span data-stu-id="f5d10-126">Those messages will have different priorities, which the core component can manage.</span></span> <span data-ttu-id="f5d10-127">В окончательной архивной форме сообщений должны быть метки времени.</span><span class="sxs-lookup"><span data-stu-id="f5d10-127">The messages should have timestamps in their final archived form.</span></span> <span data-ttu-id="f5d10-128">В более сложных сценариях может потребоваться фильтровать сообщения по исходному компоненту.</span><span class="sxs-lookup"><span data-stu-id="f5d10-128">For more advanced scenarios, you could filter messages by the source component.</span></span>

<span data-ttu-id="f5d10-129">Часто будет меняться один аспект: куда записываются сообщения.</span><span class="sxs-lookup"><span data-stu-id="f5d10-129">There is one aspect of the feature that will change often: where messages are written.</span></span> <span data-ttu-id="f5d10-130">В некоторых средах они могут записываться в консоль ошибок.</span><span class="sxs-lookup"><span data-stu-id="f5d10-130">In some environments, they may be written to the error console.</span></span> <span data-ttu-id="f5d10-131">В других — в файл.</span><span class="sxs-lookup"><span data-stu-id="f5d10-131">In others, a file.</span></span> <span data-ttu-id="f5d10-132">К иным вариантам относятся хранилище базы данных, журналы событий ОС или иные хранилища документов.</span><span class="sxs-lookup"><span data-stu-id="f5d10-132">Other possibilities include database storage, OS event logs, or other document storage.</span></span>

<span data-ttu-id="f5d10-133">В некоторых ситуациях могут использоваться сочетания назначений вывода.</span><span class="sxs-lookup"><span data-stu-id="f5d10-133">There are also combinations of output that might be used in different scenarios.</span></span> <span data-ttu-id="f5d10-134">Например, сообщения могут записываться в консоль и в файл.</span><span class="sxs-lookup"><span data-stu-id="f5d10-134">You may want to write messages to the console and to a file.</span></span>

<span data-ttu-id="f5d10-135">Модель на основе делегатов обеспечивает высокую гибкость и упрощает поддержку механизмов хранения, добавляемых в будущем.</span><span class="sxs-lookup"><span data-stu-id="f5d10-135">A design based on delegates will provide a great deal of flexibility, and make it easy to support storage mechanisms that may be added in the future.</span></span>

<span data-ttu-id="f5d10-136">В рамках этой модели основным компонентом журнала может быть невиртуальный и даже запечатанный класс.</span><span class="sxs-lookup"><span data-stu-id="f5d10-136">Under this design, the primary log component can be a non-virtual, even sealed class.</span></span> <span data-ttu-id="f5d10-137">Вы можете подключать любой набор делегатов для записи сообщений на различные носители данных.</span><span class="sxs-lookup"><span data-stu-id="f5d10-137">You can plug in any set of delegates to write the messages to different storage media.</span></span> <span data-ttu-id="f5d10-138">Встроенная поддержка делегатов многоадресной рассылки позволяет легко реализовывать сценарии, в которых сообщения должны записываться в несколько расположений (в файл и консоль).</span><span class="sxs-lookup"><span data-stu-id="f5d10-138">The built in support for multicast delegates makes it easy to support scenarios where messages must be written to multiple locations (a file, and a console).</span></span>

## <a name="a-first-implementation"></a><span data-ttu-id="f5d10-139">Первая реализация</span><span class="sxs-lookup"><span data-stu-id="f5d10-139">A First Implementation</span></span>

<span data-ttu-id="f5d10-140">Начнем с малого: начальная реализация будет принимать новые сообщения и записывать их с помощью любого подключенного делегата.</span><span class="sxs-lookup"><span data-stu-id="f5d10-140">Let's start small: the initial implementation will accept new messages, and write them using any attached delegate.</span></span> <span data-ttu-id="f5d10-141">Можно начать с одного делегата, который записывает сообщения в консоль.</span><span class="sxs-lookup"><span data-stu-id="f5d10-141">You can start with one delegate that writes messages to the console.</span></span>

[!code-csharp[LoggerImplementation](../../samples/snippets/csharp/delegates-and-events/Logger.cs#FirstImplementation "A first Logger implementation.")]

<span data-ttu-id="f5d10-142">Приведенный выше статический класс содержит только самое необходимое для работы.</span><span class="sxs-lookup"><span data-stu-id="f5d10-142">The static class above is the simplest thing that can work.</span></span> <span data-ttu-id="f5d10-143">Нам нужно создать единственную реализацию метода, который записывает сообщения в консоль.</span><span class="sxs-lookup"><span data-stu-id="f5d10-143">We need to write the single implementation for the method that writes messages to the console:</span></span>

[!code-csharp[LogToConsole](../../samples/snippets/csharp/delegates-and-events/LoggingMethods.cs#LogToConsole "A Console logger.")]

<span data-ttu-id="f5d10-144">Наконец, необходимо подключить делегат к делегату WriteMessage, объявленному в средстве ведения журнала.</span><span class="sxs-lookup"><span data-stu-id="f5d10-144">Finally, you need to hook up the delegate by attaching it to the WriteMessage delegate declared in the logger:</span></span>

[!code-csharp[ConnectDelegate](../../samples/snippets/csharp/delegates-and-events/Program.cs#ConnectDelegate "Connect to the delegate")]

## <a name="practices"></a><span data-ttu-id="f5d10-145">Рекомендации</span><span class="sxs-lookup"><span data-stu-id="f5d10-145">Practices</span></span>

<span data-ttu-id="f5d10-146">Наш пример пока очень прост, но все же он демонстрирует некоторые важные моменты, касающиеся проектирования с помощью делегатов.</span><span class="sxs-lookup"><span data-stu-id="f5d10-146">Our sample so far is fairly simple, but it still demonstrates some of the important guidelines for designs involving delegates.</span></span>

<span data-ttu-id="f5d10-147">Использование типов делегатов, определенных в Core Framework, упрощает пользователям работу с делегатами.</span><span class="sxs-lookup"><span data-stu-id="f5d10-147">Using the delegate types defined in the Core Framework makes it easier for users to work with the delegates.</span></span> <span data-ttu-id="f5d10-148">Вам не нужно определять новые типы, а разработчикам, использующим вашу библиотеку, не нужно изучать новые специальные типы делегатов.</span><span class="sxs-lookup"><span data-stu-id="f5d10-148">You don't need to define new types, and developers using your library do not need to learn new, specialized delegate types.</span></span>

<span data-ttu-id="f5d10-149">Применяются минимально необходимые, но при этом максимально гибкие интерфейсы: чтобы создать компонент для вывода данных журнала, необходимо написать всего один метод.</span><span class="sxs-lookup"><span data-stu-id="f5d10-149">The interfaces used are as minimal and as flexible as possible: To create a new output logger, you must create one method.</span></span> <span data-ttu-id="f5d10-150">Это может быть статический метод или метод экземпляра.</span><span class="sxs-lookup"><span data-stu-id="f5d10-150">That method may be a static method, or an instance method.</span></span> <span data-ttu-id="f5d10-151">Он может иметь любой уровень доступа.</span><span class="sxs-lookup"><span data-stu-id="f5d10-151">It may have any access.</span></span>

## <a name="formatting-output"></a><span data-ttu-id="f5d10-152">Форматирование выходных данных</span><span class="sxs-lookup"><span data-stu-id="f5d10-152">Formatting Output</span></span>

<span data-ttu-id="f5d10-153">Давайте немного улучшим первую версию, а затем приступим к созданию других механизмов ведения журнала.</span><span class="sxs-lookup"><span data-stu-id="f5d10-153">Let's make this first version a bit more robust, and then start creating other logging mechanisms.</span></span>

<span data-ttu-id="f5d10-154">Затем добавим в метод `LogMessage()` несколько аргументов, чтобы класс журнала создавал более структурированные сообщения.</span><span class="sxs-lookup"><span data-stu-id="f5d10-154">Next, let's add a few arguments to the `LogMessage()` method so that your log class creates more structured messages:</span></span>

[!code-csharp[Severity](../../samples/snippets/csharp/delegates-and-events/Logger.cs#Severity "Define severities")]
[!code-csharp[NextLogger](../../samples/snippets/csharp/delegates-and-events/Logger.cs#LoggerTwo "Refine the Logger")]

<span data-ttu-id="f5d10-155">Далее используем аргумент `Severity` для фильтрации сообщений, отправляемых в место вывода журнала.</span><span class="sxs-lookup"><span data-stu-id="f5d10-155">Next, let's make use of that `Severity` argument to filter the messages that are sent to the log's output.</span></span>

[!code-csharp[FinalLogger](../../samples/snippets/csharp/delegates-and-events/Logger.cs#LoggerFinal "Finish the Logger")]

## <a name="practices"></a><span data-ttu-id="f5d10-156">Рекомендации</span><span class="sxs-lookup"><span data-stu-id="f5d10-156">Practices</span></span>

<span data-ttu-id="f5d10-157">Вы добавили новые функции в инфраструктуру ведения журналов.</span><span class="sxs-lookup"><span data-stu-id="f5d10-157">You've added new features to the logging infrastructure.</span></span> <span data-ttu-id="f5d10-158">Так как компонент logger очень слабо связан с любым из механизмов вывода, эти функции можно добавлять без влияния на код, в котором реализуется делегат logger.</span><span class="sxs-lookup"><span data-stu-id="f5d10-158">Because the logger component is very loosely coupled to any output mechanism, these new features can be added with no impact on any of the code implementing the logger delegate.</span></span>

<span data-ttu-id="f5d10-159">По мере расширения кода вы увидите дополнительные примеры того, как такая слабая взаимосвязь обеспечивает большую гибкость в плане обновления компонентов сайта без внесения изменений в другие его части.</span><span class="sxs-lookup"><span data-stu-id="f5d10-159">As you keep building this, you'll see more examples of how this loose coupling enables greater flexibility in updating parts of the site without any changes to other locations.</span></span> <span data-ttu-id="f5d10-160">На самом деле в более крупном приложении классы вывода данных журнала могут находиться в другой сборке и даже не требовать повторной сборки.</span><span class="sxs-lookup"><span data-stu-id="f5d10-160">In fact, in a larger application, the logger output classes might be in a different assembly, and not even need to be rebuilt.</span></span>

## <a name="building-a-second-output-engine"></a><span data-ttu-id="f5d10-161">Создание второго модуля вывода</span><span class="sxs-lookup"><span data-stu-id="f5d10-161">Building a Second Output Engine</span></span>

<span data-ttu-id="f5d10-162">Работа над компонентом журнала продвигается.</span><span class="sxs-lookup"><span data-stu-id="f5d10-162">The Log component is coming along well.</span></span> <span data-ttu-id="f5d10-163">Давайте добавим еще один модуль вывода, который записывает сообщения в файл.</span><span class="sxs-lookup"><span data-stu-id="f5d10-163">Let's add one more output engine that logs messages to a file.</span></span> <span data-ttu-id="f5d10-164">Для этого потребуется немного больше усилий.</span><span class="sxs-lookup"><span data-stu-id="f5d10-164">This will be a slightly more involved output engine.</span></span> <span data-ttu-id="f5d10-165">Это будет класс, который инкапсулирует файловые операции и обеспечивает закрытие файла после каждой операции записи.</span><span class="sxs-lookup"><span data-stu-id="f5d10-165">It will be a class that encapsulates the file operations, and ensures that the file is always closed after each write.</span></span> <span data-ttu-id="f5d10-166">Благодаря этому все данные будут окончательно записываться на диск после создания каждого сообщения.</span><span class="sxs-lookup"><span data-stu-id="f5d10-166">That ensures that all the data is flushed to disk after each message is generated.</span></span>

<span data-ttu-id="f5d10-167">Вот это средство ведения журнала на основе файла:</span><span class="sxs-lookup"><span data-stu-id="f5d10-167">Here is that file based logger:</span></span>

[!code-csharp[FileLogger](../../samples/snippets/csharp/delegates-and-events/FileLogger.cs#FileLogger "Log to files")]

<span data-ttu-id="f5d10-168">После создания этого класса можно создать его экземпляр, и он подключит свой метод LogMessage к компоненту Logger:</span><span class="sxs-lookup"><span data-stu-id="f5d10-168">Once you've created this class, you can instantiate it and it attaches its LogMessage method to the Logger component:</span></span>

[!code-csharp[FileLogger](../../samples/snippets/csharp/delegates-and-events/Program.cs#FileLogger "Log to files")]

<span data-ttu-id="f5d10-169">Эти два метода не являются взаимоисключающими.</span><span class="sxs-lookup"><span data-stu-id="f5d10-169">These two are not mutually exclusive.</span></span> <span data-ttu-id="f5d10-170">Вы можете подключить оба метода ведения журнала, чтобы сообщения создавались как в консоли, так и в файле.</span><span class="sxs-lookup"><span data-stu-id="f5d10-170">You could attach both log methods and generate messages to the console and a file:</span></span>

```csharp
var fileOutput = new FileLogger("log.txt");
Logger.WriteMessage += LoggingMethods.LogToConsole; // LoggingMethods is the static class we utilized earlier
```

<span data-ttu-id="f5d10-171">Позднее вы можете удалить один из делегатов даже в том же приложении без каких-либо проблем для системы.</span><span class="sxs-lookup"><span data-stu-id="f5d10-171">Later, even in the same application, you can remove one of the delegates without any other issues to the system:</span></span>

```csharp
Logger.WriteMessage -= LoggingMethods.LogToConsole;
```

## <a name="practices"></a><span data-ttu-id="f5d10-172">Рекомендации</span><span class="sxs-lookup"><span data-stu-id="f5d10-172">Practices</span></span>

<span data-ttu-id="f5d10-173">Итак, вы добавили второй обработчик вывода для подсистемы ведения журнала.</span><span class="sxs-lookup"><span data-stu-id="f5d10-173">Now, you've added a second output handler for the logging sub-system.</span></span>
<span data-ttu-id="f5d10-174">Ему требуется немного больший объем инфраструктуры для правильной поддержки файловой системы.</span><span class="sxs-lookup"><span data-stu-id="f5d10-174">This one needs a bit more infrastructure to correctly support the file system.</span></span> <span data-ttu-id="f5d10-175">Делегат представляет собой метод экземпляра.</span><span class="sxs-lookup"><span data-stu-id="f5d10-175">The delegate is an instance method.</span></span> <span data-ttu-id="f5d10-176">Кроме того, это закрытый метод.</span><span class="sxs-lookup"><span data-stu-id="f5d10-176">It's also a private method.</span></span>
<span data-ttu-id="f5d10-177">В более высоком уровне доступности нет необходимости, так как инфраструктура делегатов может подключать делегаты.</span><span class="sxs-lookup"><span data-stu-id="f5d10-177">There's no need for greater accessibility because the delegate infrastructure can connect the delegates.</span></span>

<span data-ttu-id="f5d10-178">Во-вторых, модель на основе делегатов предоставляет несколько методов вывода без дополнительного кода.</span><span class="sxs-lookup"><span data-stu-id="f5d10-178">Second, the delegate-based design enables multiple output methods without any extra code.</span></span> <span data-ttu-id="f5d10-179">Вам не нужно создавать дополнительную инфраструктуру для поддержки нескольких методов вывода.</span><span class="sxs-lookup"><span data-stu-id="f5d10-179">You don't need to build any additional infrastructure to support multiple output methods.</span></span> <span data-ttu-id="f5d10-180">Они просто добавляются в список вызова.</span><span class="sxs-lookup"><span data-stu-id="f5d10-180">They simply become another method on the invocation list.</span></span>

<span data-ttu-id="f5d10-181">Обратите особое внимание на код в методе вывода данных журнала в файл.</span><span class="sxs-lookup"><span data-stu-id="f5d10-181">Pay special attention to the code in the file logging output method.</span></span> <span data-ttu-id="f5d10-182">Он написан так, что не создает никаких исключений.</span><span class="sxs-lookup"><span data-stu-id="f5d10-182">It is coded to ensure that it does not throw any exceptions.</span></span> <span data-ttu-id="f5d10-183">Хотя это не является строго обязательным, зачастую это более удобно.</span><span class="sxs-lookup"><span data-stu-id="f5d10-183">While this isn't always strictly necessary, it's often a good practice.</span></span> <span data-ttu-id="f5d10-184">Если какой-либо из методов делегата создает исключение, остальные делегаты в списке вызова не будут вызваны.</span><span class="sxs-lookup"><span data-stu-id="f5d10-184">If either of the delegate methods throws an exception, the remaining delegates that are on the invocation won't be invoked.</span></span>

<span data-ttu-id="f5d10-185">Наконец, отметим, что компонент записи данных журнала в файл должен управлять своими ресурсами, открывая и закрывая файл для каждого сообщения журнала.</span><span class="sxs-lookup"><span data-stu-id="f5d10-185">As a last note, the file logger must manage its resources by opening and closing the file on each log message.</span></span> <span data-ttu-id="f5d10-186">Вы можете оставить файл открытым и реализовать интерфейс IDisposable для закрытия файла по завершении операции.</span><span class="sxs-lookup"><span data-stu-id="f5d10-186">You could choose to keep the file open and implement IDisposable to close the file when you are completed.</span></span>
<span data-ttu-id="f5d10-187">У каждого метода свои плюсы и минусы.</span><span class="sxs-lookup"><span data-stu-id="f5d10-187">Either method has its advantages and disadvantages.</span></span> <span data-ttu-id="f5d10-188">В обоих случаях несколько усиливается взаимозависимость между классами.</span><span class="sxs-lookup"><span data-stu-id="f5d10-188">Both do create a bit more coupling between the classes.</span></span>

<span data-ttu-id="f5d10-189">Для поддержки каждого из сценариев в код класса Logger не нужно вносить никаких изменений.</span><span class="sxs-lookup"><span data-stu-id="f5d10-189">None of the code in the Logger class would need to be updated in order to support either scenario.</span></span>

## <a name="handling-null-delegates"></a><span data-ttu-id="f5d10-190">Обработка пустых делегатов</span><span class="sxs-lookup"><span data-stu-id="f5d10-190">Handling Null Delegates</span></span>

<span data-ttu-id="f5d10-191">Наконец, давайте изменим метод LogMessage так, чтобы он был эффективен в случаях, когда механизм вывода не выбран.</span><span class="sxs-lookup"><span data-stu-id="f5d10-191">Finally, let's update the LogMessage method so that it is robust for those cases when no output mechanism is selected.</span></span> <span data-ttu-id="f5d10-192">Текущая реализация вызывает исключение `NullReferenceException`, когда к делегату `WriteMessage` не подключен список вызова.</span><span class="sxs-lookup"><span data-stu-id="f5d10-192">The current implementation will throw a `NullReferenceException` when the `WriteMessage` delegate does not have an invocation list attached.</span></span>
<span data-ttu-id="f5d10-193">Однако предпочтительнее может быть автоматическое продолжение выполнения в случае, если методы не подключены.</span><span class="sxs-lookup"><span data-stu-id="f5d10-193">You may prefer a design that silently continues when no methods have been attached.</span></span> <span data-ttu-id="f5d10-194">Такое поведение легко реализовать с помощью условного оператора null в сочетании с методом `Delegate.Invoke()`.</span><span class="sxs-lookup"><span data-stu-id="f5d10-194">This is easy using the null conditional operator, combined with the `Delegate.Invoke()` method:</span></span>

```csharp
public static void LogMessage(string msg)
{
    WriteMessage?.Invoke(msg);
}
```

<span data-ttu-id="f5d10-195">Условный оператор null (`?.`) замыкается, если левый операнд (в данном случае `WriteMessage`) имеет значение null, что означает, что попытки записать сообщение не предпринимаются.</span><span class="sxs-lookup"><span data-stu-id="f5d10-195">The null conditional operator (`?.`) short-circuits when the left operand (`WriteMessage` in this case) is null, which means no attempt is made to log a message.</span></span>

<span data-ttu-id="f5d10-196">Метод `Invoke()` не указан в документации по `System.Delegate` или `System.MulticastDelegate`.</span><span class="sxs-lookup"><span data-stu-id="f5d10-196">You won't find the `Invoke()` method listed in the documentation for `System.Delegate` or `System.MulticastDelegate`.</span></span> <span data-ttu-id="f5d10-197">Компилятор создает типобезопасный метод `Invoke` для любого объявленного типа делегата.</span><span class="sxs-lookup"><span data-stu-id="f5d10-197">The compiler generates a type safe `Invoke` method for any delegate type declared.</span></span> <span data-ttu-id="f5d10-198">В этом примере это означает, что метод `Invoke` принимает один аргумент `string` и имеет тип возвращаемого значения void.</span><span class="sxs-lookup"><span data-stu-id="f5d10-198">In this example, that means `Invoke` takes a single `string` argument, and has a void return type.</span></span>

## <a name="summary-of-practices"></a><span data-ttu-id="f5d10-199">Сводка рекомендаций</span><span class="sxs-lookup"><span data-stu-id="f5d10-199">Summary of Practices</span></span>

<span data-ttu-id="f5d10-200">Вы ознакомились с простейшим компонентом журнала, который можно расширять с помощью других модулей записи и иных функций.</span><span class="sxs-lookup"><span data-stu-id="f5d10-200">You've seen the beginnings of a log component that could be expanded with other writers, and other features.</span></span> <span data-ttu-id="f5d10-201">Благодаря использованию делегатов при проектировании эти компоненты оказываются слабо взаимосвязанными.</span><span class="sxs-lookup"><span data-stu-id="f5d10-201">By using delegates in the design these different components are very loosely coupled.</span></span> <span data-ttu-id="f5d10-202">Преимуществ несколько.</span><span class="sxs-lookup"><span data-stu-id="f5d10-202">This provides several advantages.</span></span> <span data-ttu-id="f5d10-203">Очень легко создавать новые механизмы вывода и подключать их к системе.</span><span class="sxs-lookup"><span data-stu-id="f5d10-203">It's very easy to create new output mechanisms and attach them to the system.</span></span> <span data-ttu-id="f5d10-204">Этим механизмам требуется только один метод, который записывает сообщение журнала.</span><span class="sxs-lookup"><span data-stu-id="f5d10-204">These other mechanisms only need one method: the method that writes the log message.</span></span> <span data-ttu-id="f5d10-205">Такая модель очень устойчива при добавлении новых возможностей.</span><span class="sxs-lookup"><span data-stu-id="f5d10-205">It's a design that is very resilient when new features are added.</span></span> <span data-ttu-id="f5d10-206">Обязательным требованием для каждого модуля записи является реализация одного метода.</span><span class="sxs-lookup"><span data-stu-id="f5d10-206">The contract required for any writer is to implement one method.</span></span> <span data-ttu-id="f5d10-207">Это может быть статический метод или метод экземпляра.</span><span class="sxs-lookup"><span data-stu-id="f5d10-207">That method could be a static or instance method.</span></span> <span data-ttu-id="f5d10-208">Он может быть открытым, закрытым или иметь любой иной допустимый уровень доступа.</span><span class="sxs-lookup"><span data-stu-id="f5d10-208">It could be public, private, or any other legal access.</span></span>

<span data-ttu-id="f5d10-209">В класс Logger можно вносить любое количество улучшений и изменений без серьезной модификации.</span><span class="sxs-lookup"><span data-stu-id="f5d10-209">The Logger class can make any number of enhancements or changes without introducing breaking changes.</span></span> <span data-ttu-id="f5d10-210">Открытый интерфейс API, как и любой другой класс, нельзя модифицировать без риска внесения существенных изменений.</span><span class="sxs-lookup"><span data-stu-id="f5d10-210">Like any class, you cannot modify the public API without the risk of breaking changes.</span></span> <span data-ttu-id="f5d10-211">Но так как взаимосвязь между средством ведения журнала и модулями вывода осуществляется только посредством делегата, другие типы (например, интерфейсы или базовые классы) не затрагиваются.</span><span class="sxs-lookup"><span data-stu-id="f5d10-211">But, because the coupling between the logger and any output engines is only through the delegate, no other types (like interfaces or base classes) are involved.</span></span> <span data-ttu-id="f5d10-212">Взаимосвязь минимальна.</span><span class="sxs-lookup"><span data-stu-id="f5d10-212">The coupling is as small as possible.</span></span>

[<span data-ttu-id="f5d10-213">Вперед</span><span class="sxs-lookup"><span data-stu-id="f5d10-213">Next</span></span>](events-overview.md)
