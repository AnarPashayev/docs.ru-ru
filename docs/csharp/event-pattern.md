---
title: Стандартные шаблоны событий .NET
description: Сведения о шаблонах событий .NET, а также о создании источников стандартных событий, подписке на такие события и их обработке в коде.
ms.date: 06/20/2016
ms.technology: csharp-fundamentals
ms.assetid: 8a3133d6-4ef2-46f9-9c8d-a8ea8898e4c9
ms.openlocfilehash: dec516767e43a6bf4edfa555e34f3adcc21a46e3
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "79146145"
---
# <a name="standard-net-event-patterns"></a>Стандартные шаблоны событий .NET

[Назад](events-overview.md)

События .NET обычно следуют нескольким известным шаблонам. Стандартизация на основе этих шаблонов означает, что разработчики могут использовать знание таких стандартных шаблонов, применяя их к любой программе событий .NET.

Мы разберем эти стандартные шаблоны, чтобы снабдить вас знаниями, необходимыми для создания источников стандартных событий, подписки и обработки стандартных событий в коде.

## <a name="event-delegate-signatures"></a>Сигнатуры делегатов событий

Стандартной сигнатурой делегата события .NET является:

```csharp
void OnEventRaised(object sender, EventArgs args);
```

Тип возвращаемого значения — void. События основаны на делегатах и являются делегатами многоадресной рассылки. Это обеспечивает поддержку нескольких подписчиков для любого источника событий. Одно значение, возвращаемое из метода, не масштабируется на несколько подписчиков событий. Какое возвращаемое значение доступно источнику события после возникновения события? Далее в этой статье будет показано, как создавать протоколы событий, которые поддерживают подписчики на события, передающие данные в источник событий.

Список аргументов содержит два аргумента: отправителя и аргументы события. Тип времени компиляции `sender` — `System.Object`, даже если вам, вероятно, известен более производный тип, который всегда является правильным. По соглашению используйте `object`.

Второй аргумент обычно являлся типом, производным от `System.EventArgs`. (В [следующем разделе](modern-events.md) вы увидите, что это соглашение больше не является обязательным.) Даже если тип события не требует дополнительных аргументов, необходимо предоставить оба аргумента.
Существует специальное значение `EventArgs.Empty`, которое следует использовать для обозначения того, что событие не содержит никаких дополнительных сведений.

Создадим класс, который перечисляет соответствующие шаблону файлы в каталоге или любом из его подкаталогов. Этот компонент создает событие для каждого найденного файла, который соответствует шаблону.

Использование модели событий обеспечивает некоторые преимущества разработки. Можно создать несколько прослушивателей событий, которые выполняют разные действия при нахождении искомого файла. Сочетание разных прослушивателей позволяет создавать более надежные алгоритмы.

Ниже показано объявление аргумента исходного события для поиска искомого файла:

[!code-csharp[EventArgs](../../samples/snippets/csharp/events/Program.cs#EventArgsV1 "Define event arguments")]

Несмотря на то, что этот тип выглядит как небольшой тип, содержащий только данные, вы должны выполнить соглашение и назначить его ссылочным типом (`class`). Это означает, что объект аргумента будет передаваться по ссылке, а любые обновления данных будут доступны всем подписчикам. Первая версия является неизменяемым объектом. Рекомендуется сделать свойства в типе аргумента события неизменяемыми. Таким образом, один подписчик не сможет изменить значения до того, как их увидит другой подписчик. (Существуют исключения, как можно будет увидеть ниже.)  

Затем нужно создать объявление события в классе FileSearcher. Использование типа `EventHandler<T>` означает, что вам не требуется создавать еще одно определение типа. Вы просто используете универсальную специализацию.

Заполним класс FileSearcher для поиска файлов, соответствующих шаблону, и вызова правильного события при обнаружении совпадения.

[!code-csharp[FileSearcher](../../samples/snippets/csharp/events/Program.cs#FileSearcherV1 "Create the initial file searcher")]

## <a name="defining-and-raising-field-like-events"></a>Определение и вызов событий, подобных полям

Самый простой способ добавить событие в класс — объявить это событие как открытое поле, как показано в предыдущем примере.

[!code-csharp[DeclareEvent](../../samples/snippets/csharp/events/Program.cs#DeclareEvent "Declare the file found event")]

В таком коде объявляется открытое поле, что не рекомендуется в объектно-ориентированном программировании, поскольку необходимо обеспечить защиту доступа к данным с помощью свойств и методов. Хотя это выглядит нарушением рекомендаций, код, созданный компилятором, создает программы-оболочки, чтобы доступ к объектам событий мог осуществляться только безопасным образом. Единственные операции, доступные для событий, подобных полям, — обработчик add:

[!code-csharp[DeclareEventHandler](../../samples/snippets/csharp/events/Program.cs#DeclareEventHandler "Declare the file found event handler")]

и обработчик remove:

[!code-csharp[RemoveEventHandler](../../samples/snippets/csharp/events/Program.cs#RemoveHandler "Remove the event handler")]

Обратите внимание, что для обработчика используется локальная переменная. Если вы используете тело лямбда-выражения, удаление не будет работать корректно. Будет существовать другой экземпляр делегата, не выполняющий никаких действий.

Код вне класса не может вызывать события, а также выполнять другие операции.

## <a name="returning-values-from-event-subscribers"></a>Получение возвращаемых значений от подписчиков на событие

Простая версия работает нормально. Давайте добавим еще одну возможность — отмену.

При вызове события нахождения прослушиватели должны иметь возможность остановить дальнейшую обработку, если этот файл является последним искомым.

Обработчики событий не возвращают значение, поэтому вам нужно выполнить это другим способом. Стандартный шаблон события использует объект EventArgs для включения полей, которые подписчики на события могут использовать для передачи сообщения об отмене.

Для этого случая предусмотрено два разных шаблона, которые можно использовать в зависимости от семантики контракта "Отмена". В обоих случаях в EventArguments добавляется логическое поле для события найденного файла.

Один шаблон позволяет любому одному подписчику отменить операцию.
Для этого шаблона новое поле инициализируется значением `false`. Любой подписчик можно изменить его на `true`. После того как все подписчики увидят событие, компонент FileSearcher проверяет логическое значение и выполняет действие.

Второй шаблон отменяет операцию, только если все подписчики подтвердили ее отмену. В этом шаблоне новое поле инициализируется для указания того, что операцию следует отменить, и любой подписчик может изменить его, чтобы указать, что следует продолжить операцию.
После того как все подписчики увидят событие, компонент FileSearcher проверяет логическое значение и выполняет действие. В этом шаблоне есть еще один дополнительный шаг: компонент должен знать, все ли подписчики видели событие. Если подписчики отсутствуют, поле неверно сообщит об отмене.

Реализуем первую версию для этого примера. Добавьте логическое поле с именем `CancelRequested` в тип `FileFoundArgs`:

[!code-csharp[EventArgs](../../samples/snippets/csharp/events/Program.cs#EventArgs "Update event arguments")]

Это новое поле автоматически инициализируется значением `false`, которое используется по умолчанию для логических полей, чтобы не происходило случайной отмены. Единственным другим изменением в компоненте является установка флага после вызова события для просмотра, если любой из подписчиков запросил отмену:

```csharp
public void List(string directory, string searchPattern)
{
    foreach (var file in Directory.EnumerateFiles(directory, searchPattern))
    {
        var args = new FileFoundArgs(file);
        FileFound?.Invoke(this, args);
        if (args.CancelRequested)
            break;
    }
}
```

Одно из преимуществ этого шаблона заключается в том, что это не является критическим изменением.
Ни один из подписчиков не запрашивал отмену ранее и не запрашивает в настоящий момент. Код подписчиков не требует обновления, если не требуется поддержка нового протокола отмены. Они очень слабо связаны.

Изменим подписчик, чтобы он запрашивал отмену, когда обнаруживает первый исполняемый файл:

```csharp
EventHandler<FileFoundArgs> onFileFound = (sender, eventArgs) =>
{
    Console.WriteLine(eventArgs.FoundFile);
    eventArgs.CancelRequested = true;
};
```

## <a name="adding-another-event-declaration"></a>Добавление другого объявления события

Добавим еще одну возможность и продемонстрируем другие выражения языка для событий. Добавим перегрузку метода `Search`, который проходит через все подкаталоги в поиске файлов.

Эта операция может выполняться длительное время в каталоге с большим числом вложенных каталогов. Добавим событие, которое вызывается в начале каждого нового поиска в каталоге. Это позволяет подписчикам отслеживать ход выполнения и сообщать о нем пользователю. Все примеры, которые мы создали до сих пор, являются открытыми. Сделаем это событие внутренним. Это означает, что типы, используемые для аргументов, также можно сделать внутренними.

Вы начнете с создания нового производного класса EventArgs для передачи сведений о новом каталоге и ходе выполнения.

[!code-csharp[DirEventArgs](../../samples/snippets/csharp/events/Program.cs#SearchDirEventArgs "Define search directory event arguments")]

Опять же, вы можете следовать рекомендациям по созданию неизменяемого ссылочного типа для аргументов событий.

Теперь определим событие. На этот раз будет использоваться другой синтаксис. Помимо синтаксиса полей можно явно создать свойство c помощью обработчиков add и remove. В этом примере вы не будете добавлять код в эти обработчики, здесь просто демонстрируется их создание.

[!code-csharp[Declare event with add and remove handlers](../../samples/snippets/csharp/events/Program.cs#DeclareSearchEvent "Declare the event with add and remove handlers")]

Созданный здесь код очень похож на тот код, который компилятор создает для определения полей событий, как было показано ранее. Для создания события используется синтаксис, очень похожий на используемый для [свойств](properties.md). Обратите внимание, что обработчики имеют разные имена: `add` и `remove`. Они вызываются для подписки на событие или отмены подписки на событие. Учтите, что вы также должны объявить закрытое резервное поле для хранения переменной событий. Оно инициализируется значением NULL.

Теперь добавим перегрузку метода `Search`, который обходит подкаталоги и вызывает оба события. Для этого проще всего использовать аргумент по умолчанию для задания поиска по всем каталогам:

[!code-csharp[SearchImplementation](../../samples/snippets/csharp/events/Program.cs#FinalImplementation "Implementation to search directories")]

На этом этапе можно запустить приложение, вызывающее перегруженный метод для поиска всех вложенных каталогов. Для нового события `ChangeDirectory` нет подписчиков, однако благодаря использованию идиомы `?.Invoke()` мы можем гарантировать правильную работу метода.

 Добавим обработчик для написания строки, показывающей ход выполнения в окне консоли.

[!code-csharp[Search](../../samples/snippets/csharp/events/Program.cs#Search "Declare event handler")]

Мы познакомились с шаблонами, которые используются во всей экосистеме .NET.
Научившись использовать эти шаблоны и соглашения, вы сможете быстро создавать код C# и .NET на основе идиом.

Далее мы рассмотрим некоторые изменения в этих шаблонах в самой последней версии .NET.

[Вперед](modern-events.md)
