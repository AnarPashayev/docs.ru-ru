---
title: Справочник по C#. Типы кортежей
description: Сведения о кортежах C# — упрощенных структурах данных, которые можно использовать для группировки слабо связанных элементов данных.
ms.date: 07/09/2020
helpviewer_keywords:
- value tuples [C#]
ms.openlocfilehash: d996c7afecba1b58bfd8337fa444fd71790dd482
ms.sourcegitcommit: 870bc4b4087510f6fba3c7b1c0d391f02bcc1f3e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/23/2020
ms.locfileid: "92471776"
---
# <a name="tuple-types-c-reference"></a>Типы кортежей (справочник по C#)

*Кортежи* , доступные в C# 7.0 и более поздних версиях, предоставляют краткий синтаксис для группирования нескольких элементов данных в упрощенную структуру данных. В следующем примере показано, как можно объявить переменную кортежа, инициализировать ее и получить доступ к ее элементам данных.

[!code-csharp-interactive[tuple intro](snippets/shared/ValueTuples.cs#Introduction)]

Как показано в предыдущем примере, для определения типа кортежа необходимо указать типы всех его элементов данных и, при необходимости, [имена полей](#tuple-field-names). В типе кортежа невозможно определить методы, но можно использовать методы, предоставляемые .NET, как показано в следующем примере.

[!code-csharp-interactive[tuple methods](snippets/shared/ValueTuples.cs#MethodOnTuples)]

Начиная с C# 7.3, типы кортежей поддерживают [операторы равенства](../operators/equality-operators.md) `==` и `!=`. Дополнительные сведения см. в разделе [Равенство кортежей](#tuple-equality).

Типы кортежей являются [типами значений](value-types.md), а элементы кортежа — общедоступными полями. Поэтому кортежи представляют собой *изменяемые* типы значений.

> [!NOTE]
> Для кортежей требуется тип <xref:System.ValueTuple?displayProperty=nameWithType> и связанные универсальные типы (например, <xref:System.ValueTuple%602?displayProperty=nameWithType>), доступные в .NET Core и .NET Framework 4.7 и более поздних версий. Чтобы использовать кортежи в проекте, предназначенном для .NET Framework 4.6.2 или более ранней версии, добавьте в проект пакет NuGet [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/).

Можно определить кортежи со сколь угодно большим числом элементов.

[!code-csharp-interactive[large tuple](snippets/shared/ValueTuples.cs#LargeTuple)]

## <a name="use-cases-of-tuples"></a>Варианты использования кортежей

Чаще всего кортежи используются как возвращаемый методом тип. То есть вместо определения [параметров метода `out`](../keywords/out-parameter-modifier.md) можно сгруппировать результаты метода в возвращаемый тип кортежа, как показано в следующем примере.

[!code-csharp-interactive[multiple method outputs](snippets/shared/ValueTuples.cs#MultipleReturns)]

Как показано в предыдущем примере, с возвращаемым экземпляром кортежа можно работать напрямую или [деконструировать](#tuple-assignment-and-deconstruction) его в отдельные переменные.

Типы кортежей можно также использовать вместо [анонимных типов](../../programming-guide/classes-and-structs/anonymous-types.md), например в запросах LINQ. Дополнительные сведения см. в статье [Выбор между анонимными типами и кортежами](../../../standard/base-types/choosing-between-anonymous-and-tuple.md).

Как правило, кортежи используются для группирования слабо связанных элементов данных. Это целесообразно в закрытых и внутренних служебных методах. При работе с общедоступным API рассмотрите возможность определения типа [класса](../keywords/class.md) или [структуры](struct.md).

## <a name="tuple-field-names"></a>Имена полей кортежей

Имена полей кортежей указываются явным образом либо в выражении инициализации кортежа, либо в определении типа кортежа, как показано в следующем примере.

[!code-csharp-interactive[explicit field names](snippets/shared/ValueTuples.cs#ExplicitFieldNames)]

Начиная с C# 7.1, если имя поля не указано, оно может быть выведено из имени соответствующей переменной в выражении инициализации кортежа, как показано в следующем примере.

[!code-csharp-interactive[inferred field names](snippets/shared/ValueTuples.cs#InferFieldNames)]

Это называется инициализаторами проекций кортежа. Имя переменной не проецируется на имя поля кортежа в следующих случаях:

- Имя кандидата — это имя элемента типа кортежа, например `Item3`, `ToString`или `Rest`.
- Имя кандидата является дубликатом другого имени поля кортежа, явного или неявного.

В этих случаях необходимо либо явно указать имя поля, либо получить доступ к полю по имени по умолчанию.

По умолчанию поля кортежа имеют имена `Item1`, `Item2`, `Item3` и т. д. Всегда можно использовать имя поля по умолчанию, даже если имя поля указано явно или является выводимым, как показано в следующем примере.

[!code-csharp-interactive[default field names](snippets/shared/ValueTuples.cs#DefaultFieldNames)]

Имена полей не учитываются при [присваивании кортежа](#tuple-assignment-and-deconstruction) и [сравнении кортежей на равенство](#tuple-equality).

Во время компиляции компилятор заменяет имена полей не по умолчанию соответствующими именами по умолчанию. В результате явно указанные или выводимые имена полей будут недоступны во время выполнения.

## <a name="tuple-assignment-and-deconstruction"></a>Присваивание и деконструкция кортежей

В C# поддерживается присваивание между типами кортежей, которые соответствуют обоим следующим условиям:

- оба типа кортежей должны содержать одинаковое количество элементов;
- для каждой позиции кортежа тип правого элемента кортежа аналогичен типу соответствующего левого элемента кортежа или может быть неявно преобразован в этот тип.

Значения элементов кортежа присваиваются в порядке расположения элементов кортежа. Имена полей кортежа не учитываются и не присваиваются, как показано в следующем примере.

[!code-csharp-interactive[tuple assignment](snippets/shared/ValueTuples.cs#Assignment)]

Оператор присваивания `=` можно также использовать для *деконструкции* экземпляра кортежа в отдельные переменные. Существует три способа деконструкции кортежа.

- Вы можете явно объявить тип каждой переменной в скобках.

  [!code-csharp-interactive[specify types of variables](snippets/shared/ValueTuples.cs#DeconstructExplicit)]

- Вы можете использовать ключевое слово `var` за пределами круглых скобок, чтобы объявить неявно типизированные переменные и позволить компилятору вывести их типы.

  [!code-csharp-interactive[implicitly typed variables](snippets/shared/ValueTuples.cs#DeconstructVar)]

- Вы можете использовать существующие переменные.

  [!code-csharp-interactive[existing variables](snippets/shared/ValueTuples.cs#DeconstructExisting)]

Подробнее о деконструкции кортежей с помощью и других типов см. в статье [Деконструкция кортежей и других типов](../../deconstruct.md).

## <a name="tuple-equality"></a>Равенство кортежей

Начиная с C# 7.3, типы кортежей поддерживают операторы `==` и `!=`. Эти операторы сравнивают элементы левого операнда с соответствующими элементами правого операнда в соответствии с порядком расположения элементов кортежа.

[!code-csharp-interactive[tuple equality](snippets/shared/ValueTuples.cs#TupleEquality)]

Как показано в предыдущем примере, в операциях `==` и `!=` не учитываются имена полей кортежей.

Два кортежа сравнимы, если выполнены оба следующих условия:

- оба кортежа содержат одинаковое количество элементов. Например, `t1 != t2` не компилируется, если `t1` и `t2` имеют разное количество элементов.
- Для каждой позиции кортежа соответствующие элементы из левого и правого операндов кортежа сравниваются с помощью операторов `==` и `!=`. Например, `(1, (2, 3)) == ((1, 2), 3)` не компилируется, поскольку `1` не сравнивается с помощью `(1, 2)`.

Операторы `==` и `!=` сравнивают кортежи с сокращенной обработкой. Это значит, что операция останавливается, как только она соответствует паре неравных элементов или достигает конца кортежей. Однако перед любым сравнением *все* элементы кортежа вычисляются, как показано в следующем примере.

[!code-csharp-interactive[tuple element evaluation](snippets/shared/ValueTuples.cs#TupleEvaluationForEquality)]

## <a name="tuples-as-out-parameters"></a>Кортежи как параметры вывода

Как правило, вы выполняете рефакторинг метода, имеющего [параметры `out`](../keywords/out-parameter-modifier.md), в метод, возвращающий кортеж. Однако бывают случаи, когда параметр `out` может иметь тип кортежа. В следующем примере показано, как работать с кортежами в виде параметров `out`.

[!code-csharp-interactive[tuple as out parameter](snippets/shared/ValueTuples.cs#TupleAsOutParameter)]

## <a name="tuples-vs-systemtuple"></a>Кортежи и `System.Tuple`

Кортежи C# с типами <xref:System.ValueTuple?displayProperty=nameWithType>, отличаются от кортежей, представленных типами <xref:System.Tuple?displayProperty=nameWithType>. Основные различия заключаются в следующем.

- Типы `ValueTuple` являются [типами значений](value-types.md). Типы `Tuple` являются [ссылочными типами](../keywords/reference-types.md).
- Типы `ValueTuple` являются изменяемыми. Типы `Tuple` являются неизменяемыми.
- Элементами данных типов `ValueTuple` являются поля. Элементами данных типов `Tuple` являются свойства.

## <a name="c-language-specification"></a>Спецификация языка C#

Дополнительные сведения см. в следующих примечаниях к предлагаемой функции.

- [Выводимые имена кортежей (инициализаторы проекций кортежа)](~/_csharplang/proposals/csharp-7.1/infer-tuple-names.md)
- [Поддержка `==` и `!=` для типов кортежей](~/_csharplang/proposals/csharp-7.3/tuple-equality.md)

## <a name="see-also"></a>См. также

- [справочник по C#](../index.md)
- [Типы значений](value-types.md)
- [Выбор между анонимными типами и кортежами](../../../standard/base-types/choosing-between-anonymous-and-tuple.md)
- <xref:System.ValueTuple?displayProperty=nameWithType>
