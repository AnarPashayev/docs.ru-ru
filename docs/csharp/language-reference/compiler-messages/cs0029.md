---
title: Ошибка компилятора CS0029
ms.date: 07/20/2015
f1_keywords:
- CS0029
helpviewer_keywords:
- CS0029
ms.assetid: 63c3e574-1868-4a9e-923e-dcd9f38bce88
ms.openlocfilehash: f4dec41945ace6c6b0821b9870a88960efbe1e52
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "71332304"
---
# <a name="compiler-error-cs0029"></a><span data-ttu-id="d3a34-102">Ошибка компилятора CS0029</span><span class="sxs-lookup"><span data-stu-id="d3a34-102">Compiler Error CS0029</span></span>

<span data-ttu-id="d3a34-103">Не удается неявно преобразовать тип "type" в "type"</span><span class="sxs-lookup"><span data-stu-id="d3a34-103">Cannot implicitly convert type 'type' to 'type'</span></span>

 <span data-ttu-id="d3a34-104">Компилятору требуется явное преобразование.</span><span class="sxs-lookup"><span data-stu-id="d3a34-104">The compiler requires an explicit conversion.</span></span> <span data-ttu-id="d3a34-105">Например, может потребоваться приведение r-значения к тому же типу, который имеет l-значение.</span><span class="sxs-lookup"><span data-stu-id="d3a34-105">For example, you may need to cast an r-value to be the same type as an l-value.</span></span> <span data-ttu-id="d3a34-106">Или может быть необходимо предоставить подпрограммы преобразования для поддержки перегрузки определенных операторов.</span><span class="sxs-lookup"><span data-stu-id="d3a34-106">Or, you must provide conversion routines to support certain operator overloads.</span></span>

 <span data-ttu-id="d3a34-107">Преобразование должно выполняться в том случае, когда переменная одного типа присваивается переменной другого типа.</span><span class="sxs-lookup"><span data-stu-id="d3a34-107">Conversions must occur when assigning a variable of one type to a variable of a different type.</span></span> <span data-ttu-id="d3a34-108">При присвоении между переменными разных типов компилятор должен преобразовать тип в правой части оператора присваивания в тип в его левой части.</span><span class="sxs-lookup"><span data-stu-id="d3a34-108">When making an assignment between variables of different types, the compiler must convert the type on the right-hand side of the assignment operator to the type on the left-hand side of the assignment operator.</span></span> <span data-ttu-id="d3a34-109">Рассмотрим следующий код:</span><span class="sxs-lookup"><span data-stu-id="d3a34-109">Take the following the code:</span></span>

```csharp
int i = 50;
long lng = 100;
i = lng;
```

 <span data-ttu-id="d3a34-110">`i = lng;` выполняет присваивание, однако типы данных переменных в левой и правой частях оператора присваивания не совпадают.</span><span class="sxs-lookup"><span data-stu-id="d3a34-110">`i = lng;` makes an assignment, but the data types of the variables on the left and right-hand side of the assignment operator don't match.</span></span> <span data-ttu-id="d3a34-111">Прежде чем выполнять присваивание, компилятор неявно преобразует переменную `lng` типа long в тип int. Выполнение этого преобразования не предписывается явно какими-либо инструкциями кода и поэтому называется неявным.</span><span class="sxs-lookup"><span data-stu-id="d3a34-111">Before making the assignment the compiler is implicitly converting the variable `lng`, which is of type long, to an int. This is implicit because no code explicitly instructed the compiler to perform this conversion.</span></span> <span data-ttu-id="d3a34-112">Обратите внимание, что в этом коде реализуется неявное сужающее преобразование, которое не допускается компилятором из-за риска потери данных.</span><span class="sxs-lookup"><span data-stu-id="d3a34-112">The problem with this code is that this is considered a narrowing conversion, and the compiler does not allow implicit narrowing conversions because there could be a potential loss of data.</span></span>

 <span data-ttu-id="d3a34-113">Преобразование является сужающим в тех случаях, когда целевой тип данных занимает в памяти меньше места, чем исходный.</span><span class="sxs-lookup"><span data-stu-id="d3a34-113">A narrowing conversion exists when converting to a data type that occupies less storage space in memory than the data type we are converting from.</span></span> <span data-ttu-id="d3a34-114">Например, сужающим является преобразование из long в int.</span><span class="sxs-lookup"><span data-stu-id="d3a34-114">For example, converting a long to an int would be considered a narrowing conversion.</span></span> <span data-ttu-id="d3a34-115">Тип long занимает в памяти 8 байт, а тип int — 4 байта.</span><span class="sxs-lookup"><span data-stu-id="d3a34-115">A long occupies 8 bytes of memory while an int occupies 4 bytes.</span></span> <span data-ttu-id="d3a34-116">Ниже показан пример потери данных в результате такого преобразования:</span><span class="sxs-lookup"><span data-stu-id="d3a34-116">To see how data loss can occur, consider the following sample:</span></span>

```csharp
int i = 50;
long lng = 3147483647;
i = lng;
```

 <span data-ttu-id="d3a34-117">Переменная `lng` содержит слишком большое значение, которое нельзя сохранить в переменной `i`.</span><span class="sxs-lookup"><span data-stu-id="d3a34-117">The variable `lng` now contains a value that cannot be stored in the variable `i` because it is too large.</span></span> <span data-ttu-id="d3a34-118">Таким образом, при преобразовании этого значения в тип int потеряется часть данных, а преобразованное значение не будет в точности равно исходному.</span><span class="sxs-lookup"><span data-stu-id="d3a34-118">If we were to convert this value to an int type we would be losing some of our data and the converted value would not be the same as the value before the conversion.</span></span>

 <span data-ttu-id="d3a34-119">Расширяющие преобразования являются противоположностью сужающих.</span><span class="sxs-lookup"><span data-stu-id="d3a34-119">A widening conversion would be the opposite of a narrowing conversion.</span></span> <span data-ttu-id="d3a34-120">В этом случае целевой тип данных занимает в памяти больше места, чем исходный.</span><span class="sxs-lookup"><span data-stu-id="d3a34-120">With widening conversions, we are converting to a data type that occupies more storage space in memory than the data type we are converting from.</span></span> <span data-ttu-id="d3a34-121">Ниже приведен пример расширяющего преобразования:</span><span class="sxs-lookup"><span data-stu-id="d3a34-121">Here is an example of a widening conversion:</span></span>

```csharp
int i = 50;
long lng = 100;
lng = i;
```

 <span data-ttu-id="d3a34-122">Обратите внимание на отличие этого примера кода от первого.</span><span class="sxs-lookup"><span data-stu-id="d3a34-122">Notice the difference between this code sample and the first.</span></span> <span data-ttu-id="d3a34-123">На этот раз переменная `lng` находится в левой части оператора присваивания и является его целевой переменной.</span><span class="sxs-lookup"><span data-stu-id="d3a34-123">This time the variable `lng` is on the left-hand side of the assignment operator, so it is the target of our assignment.</span></span> <span data-ttu-id="d3a34-124">Перед присвоением компилятор должен неявно преобразовать переменную `i` типа int в тип long.</span><span class="sxs-lookup"><span data-stu-id="d3a34-124">Before the assignment can be made, the compiler must implicitly convert the variable `i`, which is of type int, to type long.</span></span> <span data-ttu-id="d3a34-125">Это будет расширяющее преобразование, поскольку исходный тип (int) занимает в памяти 4 байта, а целевой (long) — 8 байт.</span><span class="sxs-lookup"><span data-stu-id="d3a34-125">This is a widening conversion since we are converting from a type that occupies 4 bytes of memory (an int) to a type that occupies 8 bytes of memory (a long).</span></span> <span data-ttu-id="d3a34-126">Неявные расширяющие преобразования не связаны с риском потери данных и допускаются к применению.</span><span class="sxs-lookup"><span data-stu-id="d3a34-126">Implicit widening conversions are allowed because there is no potential loss of data.</span></span> <span data-ttu-id="d3a34-127">Любое значение типа int может быть сохранено в переменной типа long.</span><span class="sxs-lookup"><span data-stu-id="d3a34-127">Any value that can be stored in an int can also be stored in a long.</span></span>

 <span data-ttu-id="d3a34-128">Поскольку неявные сужающие преобразования не допускаются, для успешной компиляции этого кода необходимо явно выполнить преобразование типа данных.</span><span class="sxs-lookup"><span data-stu-id="d3a34-128">We know that implicit narrowing conversions are not allowed, so to be able to compile this code we need to explicitly convert the data type.</span></span> <span data-ttu-id="d3a34-129">Явные преобразования выполняются путем приведения типов.</span><span class="sxs-lookup"><span data-stu-id="d3a34-129">Explicit conversions are done using casting.</span></span> <span data-ttu-id="d3a34-130">Понятие приведения типов в языке C# описывает преобразование одного типа в другой.</span><span class="sxs-lookup"><span data-stu-id="d3a34-130">Casting is the term used in C# to describe converting one data type to another.</span></span> <span data-ttu-id="d3a34-131">Чтобы гарантировать успешную компиляцию кода, необходимо использовать следующий синтаксис:</span><span class="sxs-lookup"><span data-stu-id="d3a34-131">To get the code to compile we would need to use the following syntax:</span></span>

```csharp
int i = 50;
long lng = 100;
i = (int) lng;   // Cast to int.
```

 <span data-ttu-id="d3a34-132">В третьей строке кода содержится инструкция для явного преобразования переменной `lng` типа long в тип int перед выполнением присвоения.</span><span class="sxs-lookup"><span data-stu-id="d3a34-132">The third line of code tells the compiler to explicitly convert the variable `lng`, which is of type long, to an int before making the assignment.</span></span> <span data-ttu-id="d3a34-133">Помните, что при сужающем преобразовании существует риск потери данных.</span><span class="sxs-lookup"><span data-stu-id="d3a34-133">Remember that with a narrowing conversion, there is a potential loss of data.</span></span> <span data-ttu-id="d3a34-134">Сужающие преобразования следует использовать с осторожностью, поскольку даже в случае успешной компиляции кода во время выполнения могут быть получены непредвиденные результаты.</span><span class="sxs-lookup"><span data-stu-id="d3a34-134">Narrowing conversions should be used with caution and even though the code will compile you may get unexpected results at run-time.</span></span>

 <span data-ttu-id="d3a34-135">Приведенная здесь информация относится только к типам значений.</span><span class="sxs-lookup"><span data-stu-id="d3a34-135">This discussion has only been for value types.</span></span> <span data-ttu-id="d3a34-136">При использовании типов значений вы работаете напрямую с данными, хранящимися в переменной.</span><span class="sxs-lookup"><span data-stu-id="d3a34-136">When working with value types you work directly with the data stored in the variable.</span></span> <span data-ttu-id="d3a34-137">Тем не менее на платформе .NET Framework также используются ссылочные типы.</span><span class="sxs-lookup"><span data-stu-id="d3a34-137">However, the .NET Framework also has reference types.</span></span> <span data-ttu-id="d3a34-138">В случае с ними вы работаете не с фактическими данными, а со ссылками на переменные.</span><span class="sxs-lookup"><span data-stu-id="d3a34-138">When working with reference types you are working with a reference to a variable, not the actual data.</span></span> <span data-ttu-id="d3a34-139">Например, к ссылочным типам относятся классы, интерфейсы и массивы.</span><span class="sxs-lookup"><span data-stu-id="d3a34-139">Examples of reference types would be classes, interfaces and arrays.</span></span> <span data-ttu-id="d3a34-140">Неявные или явные преобразования между ссылочными типами не поддерживаются кроме случаев, когда компилятор допускает конкретные преобразования или реализованы соответствующие операторы преобразования.</span><span class="sxs-lookup"><span data-stu-id="d3a34-140">You cannot implicitly or explicitly convert one reference type to another unless the compiler allows the specific conversion or the appropriate conversion operators are implemented.</span></span>

 <span data-ttu-id="d3a34-141">В следующем примере возникает ошибка CS0029:</span><span class="sxs-lookup"><span data-stu-id="d3a34-141">The following sample generates CS0029:</span></span>

```csharp
// CS0029.cs
public class MyInt
{
    private int x = 0;

    // Uncomment this conversion routine to resolve CS0029.
    /*
    public static implicit operator int(MyInt i)
    {
        return i.x;
    }
    */

    public static void Main()
    {
        var myInt = new MyInt();
        int i = myInt; // CS0029
    }
}
```

## <a name="see-also"></a><span data-ttu-id="d3a34-142">См. также</span><span class="sxs-lookup"><span data-stu-id="d3a34-142">See also</span></span>

- [<span data-ttu-id="d3a34-143">Операторы пользовательского преобразования</span><span class="sxs-lookup"><span data-stu-id="d3a34-143">User-defined conversion operators</span></span>](../operators/user-defined-conversion-operators.md)
