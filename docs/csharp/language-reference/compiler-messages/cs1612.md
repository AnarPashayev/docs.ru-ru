---
title: Ошибка компилятора CS1612
ms.date: 07/20/2015
f1_keywords:
- CS1612
helpviewer_keywords:
- CS1612
ms.assetid: ef5db985-030a-4f15-b53f-e92c9297c6a3
ms.openlocfilehash: 5c84d8f98aeb8beaaaa0a076b9ccc28b3bcb9b23
ms.sourcegitcommit: c2d9718996402993cf31541f11e95531bc68bad0
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/27/2020
ms.locfileid: "77673086"
---
# <a name="compiler-error-cs1612"></a><span data-ttu-id="3a117-102">Ошибка компилятора CS1612</span><span class="sxs-lookup"><span data-stu-id="3a117-102">Compiler Error CS1612</span></span>
<span data-ttu-id="3a117-103">Не удалось изменить возвращаемое значение "expression", т. к. оно не является переменной</span><span class="sxs-lookup"><span data-stu-id="3a117-103">Cannot modify the return value of 'expression' because it is not a variable</span></span>  
  
 <span data-ttu-id="3a117-104">Была предпринята попытка изменить тип значения, полученный в результате промежуточного выражения, но этот тип не хранится в переменной.</span><span class="sxs-lookup"><span data-stu-id="3a117-104">An attempt was made to modify a value type that is produced as the result of an intermediate expression but is not stored in a variable.</span></span> <span data-ttu-id="3a117-105">Эта ошибка может возникнуть при попытке напрямую изменить структуру в универсальной коллекции, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="3a117-105">This error can occur when you attempt to directly modify a struct in a generic collection, as shown in the following example:</span></span>  
  
```csharp  
List<myStruct> list = {…};  
list[0].Name = "MyStruct42"; //CS1612  
```  
  
 <span data-ttu-id="3a117-106">Чтобы изменить структуру, сначала назначьте локальную переменную, измените ее, а затем снова присвойте эту переменную элементу в коллекции.</span><span class="sxs-lookup"><span data-stu-id="3a117-106">To modify the struct, first assign it to a local variable, modify the variable, then assign the variable back to the item in the collection.</span></span>  
  
```csharp  
List<myStruct> list = {…};  
MyStruct ms = list[0];  
ms.Name = "MyStruct42";  
list[0] = ms;  
```  
  
 <span data-ttu-id="3a117-107">Эта ошибка возникает, поскольку типы значений копируются при назначении.</span><span class="sxs-lookup"><span data-stu-id="3a117-107">This error occurs because value types are copied on assignment.</span></span> <span data-ttu-id="3a117-108">Извлекая тип значения из свойства или индексатора, вы получаете копию объекта, а не ссылку на этот объект.</span><span class="sxs-lookup"><span data-stu-id="3a117-108">When you retrieve a value type from a property or indexer, you are getting a copy of the object, not a reference to the object itself.</span></span> <span data-ttu-id="3a117-109">Свойство или индексатор не сохраняют полученную копию, поскольку по сути являются методами, а не местами хранения (переменными).</span><span class="sxs-lookup"><span data-stu-id="3a117-109">The copy that is returned is not stored by the property or indexer because they are actually methods, not storage locations (variables).</span></span> <span data-ttu-id="3a117-110">Копию необходимо сохранить в переменную; перед изменением эту переменную следует объявить.</span><span class="sxs-lookup"><span data-stu-id="3a117-110">You must store the copy into a variable that you declare before you can modify it.</span></span>  
  
 <span data-ttu-id="3a117-111">Данная ошибка не возникает в связи со ссылочными типами, поскольку в этом случае свойство или индексатор возвращают ссылку на существующий объект, который является местом хранения.</span><span class="sxs-lookup"><span data-stu-id="3a117-111">The error does not occur with reference types because a property or indexer in that case returns a reference to an existing object, which is a storage location.</span></span>  
  
 <span data-ttu-id="3a117-112">При определении класса или структуры эту ошибку можно устранить, изменив объявление свойства таким образом, чтобы оно предоставляло доступ к членам структуры.</span><span class="sxs-lookup"><span data-stu-id="3a117-112">If you are defining the class or struct, you can resolve this error by modifying your property declaration to provide access to the members of a struct.</span></span> <span data-ttu-id="3a117-113">При написании кода клиента эту ошибку можно устранить, создав собственный экземпляр структуры, изменив его поля, а затем снова назначив всю структуру свойству.</span><span class="sxs-lookup"><span data-stu-id="3a117-113">If you are writing client code, you can resolve the error by creating your own instance of the struct, modifying its fields, and then assigning the entire struct back to the property.</span></span> <span data-ttu-id="3a117-114">Третий вариант — это изменить структуру на класс.</span><span class="sxs-lookup"><span data-stu-id="3a117-114">As a third alternative, you can change your struct to a class.</span></span>  
  
## <a name="example"></a><span data-ttu-id="3a117-115">Пример</span><span class="sxs-lookup"><span data-stu-id="3a117-115">Example</span></span>  
 <span data-ttu-id="3a117-116">Ошибка CS1612 также возникает при попытке доступа к члену структуры через свойство внешнего класса, которое возвращает структуру целиком, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="3a117-116">CS1612 also occurs when you attempt to access the member of a struct through a property on an enclosing class that is returning the entire struct, as shown in the following example:</span></span>  
  
```csharp  
// CS1612.cs  
using System;  
  
public struct MyStruct  
{  
    public int Width;  
}  
  
public class ListView  
{  
    MyStruct ms;  
    public MyStruct Size  
    {  
        get { return ms; }  
        set { ms = value; }  
    }  
}  
  
public class MyClass  
{  
    public MyClass()  
    {  
        ListView lvi;  
        lvi = new ListView();  
        lvi.Size.Width = 5; // CS1612  
  
        // You can use the following lines instead.  
        // MyStruct ms;  
        // ms.Width = 5;  
        // lvi.Size = ms;
    }  
  
    public static void Main()   
    {  
        MyClass mc = new MyClass();  
        // Keep the console open in debug mode.  
        Console.WriteLine("Press any key to exit.");  
        Console.ReadKey();     
    }  
}  
```  
  
## <a name="see-also"></a><span data-ttu-id="3a117-117">См. также</span><span class="sxs-lookup"><span data-stu-id="3a117-117">See also</span></span>

- [<span data-ttu-id="3a117-118">Типы структур</span><span class="sxs-lookup"><span data-stu-id="3a117-118">Structure types</span></span>](../builtin-types/struct.md)
- [<span data-ttu-id="3a117-119">Типы значений</span><span class="sxs-lookup"><span data-stu-id="3a117-119">Value types</span></span>](../builtin-types/value-types.md)
- [<span data-ttu-id="3a117-120">Ссылочные типы</span><span class="sxs-lookup"><span data-stu-id="3a117-120">Reference types</span></span>](../keywords/reference-types.md)
