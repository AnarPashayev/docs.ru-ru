---
title: Выполнение деревьев выражений
description: Сведения о выполнении деревьев выражений путем их преобразования в исполняемые инструкции промежуточного языка (IL).
ms.date: 06/20/2016
ms.technology: csharp-advanced-concepts
ms.assetid: 109e0ac5-2a9c-48b4-ac68-9b6219cdbccf
ms.openlocfilehash: 802a83f52f9c05a99c3f49f8f6511eff81ef3eaa
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "79146025"
---
# <a name="executing-expression-trees"></a>Выполнение деревьев выражений

[Предыдущий раздел: "Типы платформ, поддерживающие деревья выражений"](expression-classes.md)

*Дерево выражения* — это структура данных, представляющая некоторый код.
Это не компилируемый и исполняемый код. Чтобы выполнить код .NET, представленный деревом выражения, необходимо преобразовать его в исполняемые инструкции на промежуточном языке (IL).

## <a name="lambda-expressions-to-functions"></a>Преобразование лямбда-выражений в функции

Любое лямбда-выражение или тип, производный от лямбда-выражения, можно преобразовать в исполняемый код IL. Другие типы выражений невозможно преобразовать в код напрямую. На практике это ограничение редко имеет значение. Лямбда-выражения — это единственный тип выражений, которые может потребоваться выполнить путем преобразования в исполняемый код IL. (Например, представьте, есть ли смысл выполнять `ConstantExpression` напрямую. Может ли это быть полезным?) Любое дерево выражения, представляющее собой `LambdaExpression` или тип, производный от `LambdaExpression`, можно преобразовать в IL.
Тип выражения `Expression<TDelegate>` — единственный конкретный пример в библиотеках .NET Core. Он служит для представления выражения, которое соответствует любому типу делегата. Так как этот тип сопоставлен с типом делегата, .NET может проверить выражение и создать код IL для делегата, который соответствует сигнатуре лямбда-выражения.

В большинстве случаев при этом создается простое сопоставление между выражением и соответствующим ему делегатом. Например, дерево выражения, представленное `Expression<Func<int>>`, преобразуется в делегат типа `Func<int>`. Для лямбда-выражения с любым типом возвращаемого значения и списком аргументов существует тип делегата, который является целевым типом для исполняемого кода, представленного этим лямбда-выражением.

Тип `LambdaExpression` содержит члены `Compile` и `CompileToMethod`, которые используются для преобразования дерева выражения в исполняемый код. Метод `Compile` создает делегат. Метод `CompileToMethod` обновляет объект `MethodBuilder` с помощью кода IL, который представляет скомпилированные выходные данные дерева выражения. Обратите внимание на то, что метод `CompileToMethod` доступен только на полнофункциональной классической платформе, но не на платформе .NET Core.

При необходимости можно также предоставить объект `DebugInfoGenerator`, который будет получать символьную отладочную информацию для создаваемого объекта делегата. Это позволяет преобразовать дерево выражения в объект делегата и иметь полную отладочную информацию о созданном делегате.

Выражение преобразовывается в делегат с помощью следующего кода:

```csharp
Expression<Func<int>> add = () => 1 + 2;
var func = add.Compile(); // Create Delegate
var answer = func(); // Invoke Delegate
Console.WriteLine(answer);
```

Обратите внимание на то, что тип делегата основан на типе выражения. Если требуется использовать объект делегата строго типизированным образом, необходимо знать тип возвращаемого значения и список аргументов. Метод `LambdaExpression.Compile()` возвращает тип `Delegate`. Его необходимо будет привести к правильному типу делегата, чтобы средства времени компиляции могли проверить список аргументов или тип возвращаемого значения.

## <a name="execution-and-lifetimes"></a>Выполнение и время существования

Код выполняется путем вызова делегата, созданного при вызове `LambdaExpression.Compile()`. Это можно увидеть в приведенном выше примере, где `add.Compile()` возвращает делегат. Вызов этого делегата путем вызова `func()` приводит к выполнению кода.

Делегат представляет код в дереве выражения. Вы можете сохранить дескриптор делегата и вызвать его позднее. Вам не нужно компилировать дерево выражения каждый раз, когда вы хотите выполнить представляемый им код. (Помните, что деревья выражений являются неизменяемыми и повторная компиляция того же дерева выражения приведет к созданию делегата, который выполняет этот же код.)

Не рекомендуется создавать более сложные механизмы перехвата с целью повышения производительности за счет уменьшения количества вызовов компиляции. Сравнение двух произвольных деревьев выражений с целью определить, представляют ли они один и тот же алгоритм, также требует времени. Скорее всего, время, сэкономленное за счет уменьшения количества вызовов `LambdaExpression.Compile()`, будет больше времени, затрачиваемого на выполнение кода, который определяет, приводят ли два разных дерева выражений к созданию одного и того же исполняемого кода.

## <a name="caveats"></a>Предупреждения

Компиляция лямбда-выражения в делегат и вызов этого делегата — одна из простейших операций, которые можно выполнять с деревом выражения. Однако даже в случае с такой простой операцией следует учитывать ряд моментов.

Лямбда-выражения создают замыкания для всех локальных переменных, на которые в них имеются ссылки. Необходимо обеспечить возможность использования всех переменных, которые будут входить в делегат, в месте вызова `Compile` и при выполнении итогового делегата.

Как правило, эту задачу решает компилятор. Однако если выражение обращается к переменной, которая реализует `IDisposable`, в коде может быть удален объект, который все еще удерживается деревом выражения.

Например, следующий код выполняется нормально, так как `int` не реализует `IDisposable`:

```csharp
private static Func<int, int> CreateBoundFunc()
{
    var constant = 5; // constant is captured by the expression tree
    Expression<Func<int, int>> expression = (b) => constant + b;
    var rVal = expression.Compile();
    return rVal;
}
```

Делегат захватил ссылку на локальную переменную `constant`.
Доступ к этой переменной осуществляется позднее, когда выполняется функция, возвращаемая `CreateBoundFunc`.

Однако следует рассмотреть также следующий (несколько искусственный) класс, который реализует `IDisposable`:

```csharp
public class Resource : IDisposable
{
    private bool isDisposed = false;
    public int Argument
    {
        get
        {
            if (!isDisposed)
                return 5;
            else throw new ObjectDisposedException("Resource");
        }
    }

    public void Dispose()
    {
        isDisposed = true;
    }
}
```

Если он используется в выражении, как показано ниже, то при выполнении кода, к которому обращается свойство `Resource.Argument`, возникнет исключение `ObjectDisposedException`:

```csharp
private static Func<int, int> CreateBoundResource()
{
    using (var constant = new Resource()) // constant is captured by the expression tree
    {
        Expression<Func<int, int>> expression = (b) => constant.Argument + b;
        var rVal = expression.Compile();
        return rVal;
    }
}
```

Делегат, возвращенный этим методом, замкнулся на объекте `constant`, который был ликвидирован. (Причиной ликвидации является то, что он был объявлен в операторе `using`.)

Теперь при выполнении делегата, возвращаемого этим методом, будет возникать исключение `ObjectDisposedException`.

Может показаться странным, что ошибка времени выполнения представляет конструкцию времени компиляции, но таковы особенности работы с деревьями выражений.

Эта проблема может принимать разные формы, поэтому трудно дать общую рекомендацию по тому, как ее избежать. Проявляйте осторожность в отношении доступа к локальным переменным при определении выражений и в отношении доступа к состоянию в текущем объекте (представленном `this`) при создании дерева выражения, которое может возвращаться открытым интерфейсом API.

Код выражения может ссылаться на методы или свойства в других сборках. Эти сборки должны быть доступны при определении выражения, его компиляции и вызове итогового делегата. В случае их отсутствия будет возникать исключение `ReferencedAssemblyNotFoundException`.

## <a name="summary"></a>Сводка

Деревья выражений, представляющие лямбда-выражения, можно компилировать с целью создания делегатов, которые можно выполнять. Таким образом обеспечивается механизм выполнения кода, представленного деревом выражения.

Дерево выражения представляет код, который будет выполняться для определенной конструкции, которую вы создаете. При условии, что среда, в которой компилируется и выполняется код, соответствует среде, в которой создается выражение, все работает правильно. В противном случае ошибки очень предсказуемы и выявляются при проведении первых тестов кода, в котором используются деревья выражений.

[Следующий раздел: "Интерпретация выражений"](expression-trees-interpreting.md)
