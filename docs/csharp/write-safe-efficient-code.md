---
title: Написание безопасного и эффективного кода C#
description: Последние улучшения языка C# позволяют создавать проверяемый безопасный код с производительностью, не уступающей небезопасному коду.
ms.date: 10/23/2018
ms.technology: csharp-advanced-concepts
ms.custom: mvc
ms.openlocfilehash: 365320fef5a2f9cd123086c1baed9a786ede9f05
ms.sourcegitcommit: 59e36e65ac81cdd094a5a84617625b2a0ff3506e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/27/2020
ms.locfileid: "80345082"
---
# <a name="write-safe-and-efficient-c-code"></a><span data-ttu-id="202ad-103">Написание безопасного и эффективного кода C#</span><span class="sxs-lookup"><span data-stu-id="202ad-103">Write safe and efficient C# code</span></span>

<span data-ttu-id="202ad-104">Новые возможности в C# позволяют создавать проверяемый безопасный код с более высокой производительностью.</span><span class="sxs-lookup"><span data-stu-id="202ad-104">New features in C# enable you to write verifiable safe code with better performance.</span></span> <span data-ttu-id="202ad-105">Если вы будете внимательно применять эти методы, у вас будет меньше сценариев, требующих небезопасного кода.</span><span class="sxs-lookup"><span data-stu-id="202ad-105">If you carefully apply these techniques, fewer scenarios require unsafe code.</span></span> <span data-ttu-id="202ad-106">Эти функции упрощают использование ссылок на типы значений в качестве аргументов метода и возвращаемых значений метода.</span><span class="sxs-lookup"><span data-stu-id="202ad-106">These features make it easier to use references to value types as method arguments and method returns.</span></span> <span data-ttu-id="202ad-107">При безопасном выполнении эти методики сводят к минимуму копирование типов значений.</span><span class="sxs-lookup"><span data-stu-id="202ad-107">When done safely, these techniques minimize copying value types.</span></span> <span data-ttu-id="202ad-108">Используя типы значений, можно свести к минимуму число распределений и сборок мусора.</span><span class="sxs-lookup"><span data-stu-id="202ad-108">By using value types, you can minimize the number of allocations and garbage collection passes.</span></span>

<span data-ttu-id="202ad-109">В большей части примера кода в этой статье демонстрируются функции, добавленные в C# 7.2.</span><span class="sxs-lookup"><span data-stu-id="202ad-109">Much of the sample code in this article uses features added in C# 7.2.</span></span> <span data-ttu-id="202ad-110">Чтобы их использовать, нужно настроить проект для работы с языком C# 7.2 или более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="202ad-110">To use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="202ad-111">Дополнительные сведения об установке версии языка см. в разделе [Настройка языковой версии](language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="202ad-111">For more information on setting the language version, see [configure the language version](language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="202ad-112">Эта статья посвящена методам эффективного управления ресурсами.</span><span class="sxs-lookup"><span data-stu-id="202ad-112">This article focuses on techniques for efficient resource management.</span></span> <span data-ttu-id="202ad-113">Преимущество использования типов значений заключается в том, что они часто позволяют избежать выделения памяти в кучах.</span><span class="sxs-lookup"><span data-stu-id="202ad-113">One advantage to using value types is that they often avoid heap allocations.</span></span> <span data-ttu-id="202ad-114">Недостаток состоит в том, что они копируются по значению.</span><span class="sxs-lookup"><span data-stu-id="202ad-114">The disadvantage is that they're copied by value.</span></span> <span data-ttu-id="202ad-115">Этот компромисс усложняет оптимизацию алгоритмов, работающих с большими объемами данных.</span><span class="sxs-lookup"><span data-stu-id="202ad-115">This trade-off makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="202ad-116">Новые возможности языка в C# 7.2 предоставляют механизмы, обеспечивающие безопасный и эффективный код со ссылками на типы значений.</span><span class="sxs-lookup"><span data-stu-id="202ad-116">New language features in C# 7.2 provide mechanisms that enable safe efficient code using references to value types.</span></span> <span data-ttu-id="202ad-117">При рациональном использовании этих функций можно свести к минимуму число операций выделения и копирования.</span><span class="sxs-lookup"><span data-stu-id="202ad-117">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="202ad-118">В этой статье приводится описание этих новых функций.</span><span class="sxs-lookup"><span data-stu-id="202ad-118">This article explores those new features.</span></span>

<span data-ttu-id="202ad-119">Эта статья описывает следующие методы управления ресурсами:</span><span class="sxs-lookup"><span data-stu-id="202ad-119">This article focuses on the following resource management techniques:</span></span>

- <span data-ttu-id="202ad-120">Объявите [`readonly struct`](language-reference/builtin-types/struct.md#readonly-struct), чтобы указать, что тип — **неизменяемый**.</span><span class="sxs-lookup"><span data-stu-id="202ad-120">Declare a [`readonly struct`](language-reference/builtin-types/struct.md#readonly-struct) to express that a type is **immutable**.</span></span> <span data-ttu-id="202ad-121">Это позволяет компилятору сохранять защищенные копии при использовании параметров [`in`](language-reference/keywords/in-parameter-modifier.md).</span><span class="sxs-lookup"><span data-stu-id="202ad-121">That enables the compiler to save defensive copies when using [`in`](language-reference/keywords/in-parameter-modifier.md) parameters.</span></span>
- <span data-ttu-id="202ad-122">Если тип не может быть неизменяемым, объявите члены `struct``readonly`, чтобы указать, что элемент не изменяет состояние.</span><span class="sxs-lookup"><span data-stu-id="202ad-122">If a type can't be immutable, declare `struct` members `readonly` to indicate that the member doesn't modify state.</span></span>
- <span data-ttu-id="202ad-123">Используйте [`ref readonly`](language-reference/keywords/ref.md#reference-return-values), если возвращаемое значение — `struct` больше, чем <xref:System.IntPtr.Size?displayProperty=nameWithType>, и время существования хранилища больше, чем метод, возвращающий значение.</span><span class="sxs-lookup"><span data-stu-id="202ad-123">Use a [`ref readonly`](language-reference/keywords/ref.md#reference-return-values) return when the return value is a `struct` larger than <xref:System.IntPtr.Size?displayProperty=nameWithType> and the storage lifetime is greater than the method returning the value.</span></span>
- <span data-ttu-id="202ad-124">Если размер `readonly struct` больше, чем <xref:System.IntPtr.Size?displayProperty=nameWithType>, необходимо передать его как параметр `in` для повышения производительности.</span><span class="sxs-lookup"><span data-stu-id="202ad-124">When the size of a `readonly struct` is bigger than <xref:System.IntPtr.Size?displayProperty=nameWithType>, you should pass it as an `in` parameter for performance reasons.</span></span>
- <span data-ttu-id="202ad-125">Никогда не передавайте `struct` как параметр `in`, если он не объявлен с модификатором `readonly` или метод вызывает только члены `readonly` структуры.</span><span class="sxs-lookup"><span data-stu-id="202ad-125">Never pass a `struct` as an `in` parameter unless it's declared with the `readonly` modifier or the method calls only `readonly` members of the struct.</span></span> <span data-ttu-id="202ad-126">Нарушение этого правила может негативно сказаться на производительности и привести к непонятному поведению.</span><span class="sxs-lookup"><span data-stu-id="202ad-126">Violating this guidance may negatively affect performance and could lead to an obscure behavior.</span></span>
- <span data-ttu-id="202ad-127">Используйте [`ref struct`](language-reference/keywords/ref.md#ref-struct-types) или `readonly ref struct`, например <xref:System.Span%601> или <xref:System.ReadOnlySpan%601>, для работы с памятью как последовательностью байтов.</span><span class="sxs-lookup"><span data-stu-id="202ad-127">Use a [`ref struct`](language-reference/keywords/ref.md#ref-struct-types), or a `readonly ref struct` such as <xref:System.Span%601> or <xref:System.ReadOnlySpan%601> to work with memory as a sequence of bytes.</span></span>

<span data-ttu-id="202ad-128">Эти методы помогают найти баланс между двумя противоположными целями в отношении **ссылок** и **значений**.</span><span class="sxs-lookup"><span data-stu-id="202ad-128">These techniques force you to balance two competing goals with regard to **references** and **values**.</span></span> <span data-ttu-id="202ad-129">Переменные, которые являются [ссылочными типами](programming-guide/types/index.md#reference-types), содержат ссылку на расположение в памяти.</span><span class="sxs-lookup"><span data-stu-id="202ad-129">Variables that are [reference types](programming-guide/types/index.md#reference-types) hold a reference to the location in memory.</span></span> <span data-ttu-id="202ad-130">Переменные, которые являются [типами значений](programming-guide/types/index.md#value-types), непосредственно содержат значение.</span><span class="sxs-lookup"><span data-stu-id="202ad-130">Variables that are [value types](programming-guide/types/index.md#value-types) directly contain their value.</span></span> <span data-ttu-id="202ad-131">Это ключевые различия, которые важны для управления ресурсами памяти.</span><span class="sxs-lookup"><span data-stu-id="202ad-131">These differences highlight the key differences that are important for managing memory resources.</span></span> <span data-ttu-id="202ad-132">**Типы значений** обычно копируются при передаче в метод или возвращаются из метода.</span><span class="sxs-lookup"><span data-stu-id="202ad-132">**Value types** are typically copied when passed to a method or returned from a method.</span></span> <span data-ttu-id="202ad-133">Это поведение включает в себя копирование значения `this` при вызове членов типа значения.</span><span class="sxs-lookup"><span data-stu-id="202ad-133">This behavior includes copying the value of `this` when calling members of a value type.</span></span> <span data-ttu-id="202ad-134">Издержки копирования связаны с размером типа.</span><span class="sxs-lookup"><span data-stu-id="202ad-134">The cost of the copy is related to the size of the type.</span></span> <span data-ttu-id="202ad-135">**Ссылочные типы** размещаются в управляемой куче.</span><span class="sxs-lookup"><span data-stu-id="202ad-135">**Reference types** are allocated on the managed heap.</span></span> <span data-ttu-id="202ad-136">Каждый новый объект требует новое распределение и впоследствии должен быть освобожден.</span><span class="sxs-lookup"><span data-stu-id="202ad-136">Each new object requires a new allocation, and subsequently must be reclaimed.</span></span> <span data-ttu-id="202ad-137">Обе эти операции занимают время.</span><span class="sxs-lookup"><span data-stu-id="202ad-137">Both these operations take time.</span></span> <span data-ttu-id="202ad-138">Ссылка копируется, когда ссылочный тип передается в качестве аргумента в метод или возвращается из метода.</span><span class="sxs-lookup"><span data-stu-id="202ad-138">The reference is copied when a reference type is passed as an argument to a method or returned from a method.</span></span>

<span data-ttu-id="202ad-139">В этой статье используется следующий пример концепции трехмерной структуры для объяснения этих рекомендаций:</span><span class="sxs-lookup"><span data-stu-id="202ad-139">This article uses the following example concept of the 3D-point structure to explain these recommendations:</span></span>

```csharp
public struct Point3D
{
    public double X;
    public double Y;
    public double Z;
}
```

<span data-ttu-id="202ad-140">Различные примеры использования других реализаций этой концепции.</span><span class="sxs-lookup"><span data-stu-id="202ad-140">Different examples use different implementations of this concept.</span></span>

## <a name="declare-readonly-structs-for-immutable-value-types"></a><span data-ttu-id="202ad-141">Объявление структур только для чтения для неизменяемых типов значений</span><span class="sxs-lookup"><span data-stu-id="202ad-141">Declare readonly structs for immutable value types</span></span>

<span data-ttu-id="202ad-142">Объявление `struct` с помощью модификатора `readonly` сообщает компилятору, что ваша цель — создать неизменяемый тип.</span><span class="sxs-lookup"><span data-stu-id="202ad-142">Declaring a `struct` using the `readonly` modifier informs the compiler that your intent is to create an immutable type.</span></span> <span data-ttu-id="202ad-143">Компилятор указывает это решение со следующими правилами:</span><span class="sxs-lookup"><span data-stu-id="202ad-143">The compiler enforces that design decision with the following rules:</span></span>

- <span data-ttu-id="202ad-144">Все члены поля должны быть `readonly`</span><span class="sxs-lookup"><span data-stu-id="202ad-144">All field members must be `readonly`</span></span>
- <span data-ttu-id="202ad-145">Все свойства должны быть только для чтения, включая автоматически реализуемые свойства.</span><span class="sxs-lookup"><span data-stu-id="202ad-145">All properties must be read-only, including auto-implemented properties.</span></span>

<span data-ttu-id="202ad-146">Этих двух правил достаточно, чтобы убедиться, что ни один из элементов `readonly struct` не изменяет состояние этой структуры.</span><span class="sxs-lookup"><span data-stu-id="202ad-146">These two rules are sufficient to ensure that no member of a `readonly struct` modifies the state of that struct.</span></span> <span data-ttu-id="202ad-147">Объект `struct` является неизменяемым.</span><span class="sxs-lookup"><span data-stu-id="202ad-147">The `struct` is immutable.</span></span> <span data-ttu-id="202ad-148">Структура `Point3D` может быть определена как неизменяемая, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="202ad-148">The `Point3D` structure could be defined as an immutable struct as shown in the following example:</span></span>

```csharp
readonly public struct ReadonlyPoint3D
{
    public ReadonlyPoint3D(double x, double y, double z)
    {
        this.X = x;
        this.Y = y;
        this.Z = z;
    }

    public double X { get; }
    public double Y { get; }
    public double Z { get; }
}
```

<span data-ttu-id="202ad-149">Следуйте этим рекомендациям, когда планируете создать неизменяемый тип значения.</span><span class="sxs-lookup"><span data-stu-id="202ad-149">Follow this recommendation whenever your design intent is to create an immutable value type.</span></span> <span data-ttu-id="202ad-150">Улучшения производительности являются дополнительным преимуществом.</span><span class="sxs-lookup"><span data-stu-id="202ad-150">Any performance improvements are an added benefit.</span></span> <span data-ttu-id="202ad-151">`readonly struct` четко выражает ваше намерение.</span><span class="sxs-lookup"><span data-stu-id="202ad-151">The `readonly struct` clearly expresses your design intent.</span></span>

## <a name="declare-readonly-members-when-a-struct-cant-be-immutable"></a><span data-ttu-id="202ad-152">Объявление членов, доступных только для чтения, если структура не может быть неизменяемой</span><span class="sxs-lookup"><span data-stu-id="202ad-152">Declare readonly members when a struct can't be immutable</span></span>

<span data-ttu-id="202ad-153">В C# 8.0 и более поздних версиях, когда тип структуры является изменяемым, следует объявить члены, которые не приводят к тому, что изменение имеет статус `readonly`.</span><span class="sxs-lookup"><span data-stu-id="202ad-153">In C# 8.0 and later, when a struct type is mutable, you should declare members that don't cause mutation to be `readonly`.</span></span> <span data-ttu-id="202ad-154">Рассмотрим другое приложение, для которого требуется структура объемных точек, однако оно должно поддерживать изменяемость.</span><span class="sxs-lookup"><span data-stu-id="202ad-154">Consider a different application that needs a 3D point structure, but must support mutability.</span></span> <span data-ttu-id="202ad-155">Следующая версия структуры объемных точек добавляет модификатор `readonly` только к тем элементам, которые не изменяют структуру.</span><span class="sxs-lookup"><span data-stu-id="202ad-155">The following version of the 3D point structure adds the `readonly` modifier only to those members that don't modify the structure.</span></span> <span data-ttu-id="202ad-156">Используйте этот пример, если проект должен поддерживать модификации структуры некоторыми членами, однако вам все равно нужны преимущества реализации через "только для чтения" для некоторых членов:</span><span class="sxs-lookup"><span data-stu-id="202ad-156">Follow this example when your design must support modifications to the struct by some members, but you still want the benefits of enforcing readonly on some members:</span></span>

```csharp
public struct Point3D
{
    public Point3D(double x, double y, double z)
    {
        _x = x;
        _y = y;
        _z = z;
    }

    private double _x;
    public double X
    {
        readonly get => _x;
        set => _x = value;
    }

    private double _y;
    public double Y
    {
        readonly get => _y;
        set => _y = value;
    }

    private double _z;
    public double Z
    {
        readonly get => _z;
        set => _z = value;
    }

    public readonly double Distance => Math.Sqrt(X * X + Y * Y + Z * Z);

    public readonly override string ToString() => $"{X}, {Y}, {Z}";
}
```

<span data-ttu-id="202ad-157">В предыдущем примере показаны многие расположения, в которых можно применить модификатор `readonly`: методы, свойства и методы доступа к свойствам.</span><span class="sxs-lookup"><span data-stu-id="202ad-157">The preceding sample shows many of the locations where you can apply the `readonly` modifier: methods, properties, and property accessors.</span></span> <span data-ttu-id="202ad-158">При использовании автоматически реализуемых свойств компилятор добавляет модификатор `readonly` к методу доступа `get` для свойств, предназначенных для чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="202ad-158">If you use auto-implemented properties, the compiler adds the `readonly` modifier to the `get` accessor for read-write properties.</span></span> <span data-ttu-id="202ad-159">Компилятор добавляет модификатор `readonly` к автоматически реализуемым объявлениям свойств для свойств только с методом доступа `get`.</span><span class="sxs-lookup"><span data-stu-id="202ad-159">The compiler adds the `readonly` modifier to the auto-implemented property declarations for properties with only a `get` accessor.</span></span>

<span data-ttu-id="202ad-160">Добавление модификатора `readonly` к членам, которые не изменяют состояние, предоставляет два связанных преимущества.</span><span class="sxs-lookup"><span data-stu-id="202ad-160">Adding the `readonly` modifier to members that don't mutate state provides two related benefits.</span></span> <span data-ttu-id="202ad-161">Во первых, компилятор применяет свое намерение.</span><span class="sxs-lookup"><span data-stu-id="202ad-161">First, the compiler enforces your intent.</span></span> <span data-ttu-id="202ad-162">Этот член не может изменять состояние структуры и получить доступ к члену, который также не помечен как `readonly`.</span><span class="sxs-lookup"><span data-stu-id="202ad-162">That member can't mutate the struct's state, nor can it access a member that isn't also marked `readonly`.</span></span> <span data-ttu-id="202ad-163">Во-вторых, компилятор не создает защитные копии параметров `in` при доступе к члену `readonly`.</span><span class="sxs-lookup"><span data-stu-id="202ad-163">Second, the compiler won't create defensive copies of `in` parameters when accessing a `readonly` member.</span></span> <span data-ttu-id="202ad-164">Компилятор может безопасно выполнить эту оптимизацию, так как она гарантирует, что `struct` не изменяется членом `readonly`.</span><span class="sxs-lookup"><span data-stu-id="202ad-164">The compiler can make this optimization safely because it guarantees that the `struct` is not modified by a `readonly` member.</span></span>

## <a name="use-ref-readonly-return-statements-for-large-structures-when-possible"></a><span data-ttu-id="202ad-165">Используйте операторы `ref readonly return` для больших структур, когда это возможно</span><span class="sxs-lookup"><span data-stu-id="202ad-165">Use `ref readonly return` statements for large structures when possible</span></span>

<span data-ttu-id="202ad-166">Вы можете возвращать значения по ссылке, когда возвращаемое значение не является локальным для возвращающего метода.</span><span class="sxs-lookup"><span data-stu-id="202ad-166">You can return values by reference when the value being returned isn't local to the returning method.</span></span> <span data-ttu-id="202ad-167">Возврат по ссылке означает, что копируется только ссылка, не структура.</span><span class="sxs-lookup"><span data-stu-id="202ad-167">Returning by reference means that only the reference is copied, not the structure.</span></span> <span data-ttu-id="202ad-168">В следующем примере свойство `Origin` не может использовать возврат `ref`, так как возвращаемое значение является локальной переменной:</span><span class="sxs-lookup"><span data-stu-id="202ad-168">In the following example, the `Origin` property can't use a `ref` return because the value being returned is a local variable:</span></span>

```csharp
public Point3D Origin => new Point3D(0,0,0);
```

<span data-ttu-id="202ad-169">Тем не менее, следующее определение свойства может возвращаться по ссылке, так как возвращаемое значение является статическим элементом:</span><span class="sxs-lookup"><span data-stu-id="202ad-169">However, the following property definition can be returned by reference because the returned value is a static member:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    // Dangerous! returning a mutable reference to internal storage
    public ref Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="202ad-170">Вы не хотите, чтобы вызывающие объекты изменяли источник, поэтому следует возвращать значение через `ref readonly`:</span><span class="sxs-lookup"><span data-stu-id="202ad-170">You don't want callers modifying the origin, so you should return the value by `ref readonly`:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    public static ref readonly Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="202ad-171">Возвращение `ref readonly` позволяет сохранить копирование больших структур и неизменность внутренних элементов данных.</span><span class="sxs-lookup"><span data-stu-id="202ad-171">Returning `ref readonly` enables you to save copying larger structures and preserve the immutability of your internal data members.</span></span>

<span data-ttu-id="202ad-172">Во время вызова вызывающие объекты выбирают использовать свойство `Origin` как `ref readonly` или как значение:</span><span class="sxs-lookup"><span data-stu-id="202ad-172">At the call site, callers make the choice to use the `Origin` property as a `ref readonly` or as a value:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="202ad-173">При первом назначении в предыдущем примере кода создается и назначается копия константы `Origin`.</span><span class="sxs-lookup"><span data-stu-id="202ad-173">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="202ad-174">При втором назначается ссылка.</span><span class="sxs-lookup"><span data-stu-id="202ad-174">The second assigns a reference.</span></span> <span data-ttu-id="202ad-175">Обратите внимание, что модификатор `readonly` должен быть частью объявления переменной.</span><span class="sxs-lookup"><span data-stu-id="202ad-175">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="202ad-176">Ссылку, на которую он ссылается, изменить невозможно.</span><span class="sxs-lookup"><span data-stu-id="202ad-176">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="202ad-177">В противном случае возникнет ошибка времени компиляции.</span><span class="sxs-lookup"><span data-stu-id="202ad-177">Attempts to do so result in a compile-time error.</span></span>

<span data-ttu-id="202ad-178">В объявлении `originReference` требуется модификатор `readonly`.</span><span class="sxs-lookup"><span data-stu-id="202ad-178">The `readonly` modifier is required on the declaration of `originReference`.</span></span>

<span data-ttu-id="202ad-179">Компилятор применяет правило, не позволяющее вызывающему объекту изменять ссылку.</span><span class="sxs-lookup"><span data-stu-id="202ad-179">The compiler enforces that the caller can't modify the reference.</span></span> <span data-ttu-id="202ad-180">Попытки назначить значение напрямую вызывают ошибку времени компиляции.</span><span class="sxs-lookup"><span data-stu-id="202ad-180">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="202ad-181">Однако компилятору не может быть известно, изменяет ли какой-либо метод члена состояние структуры.</span><span class="sxs-lookup"><span data-stu-id="202ad-181">However, the compiler can't know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="202ad-182">Чтобы защитить объект от изменений, компилятор создает копию и с ее помощью вызывает ссылки на члены.</span><span class="sxs-lookup"><span data-stu-id="202ad-182">To ensure that the object isn't modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="202ad-183">Все изменения будут вноситься в эту защитную копию.</span><span class="sxs-lookup"><span data-stu-id="202ad-183">Any modifications are to that defensive copy.</span></span>

## <a name="apply-the-in-modifier-to-readonly-struct-parameters-larger-than-systemintptrsize"></a><span data-ttu-id="202ad-184">Применение модификатора `in` к параметрам `readonly struct`, больше чем `System.IntPtr.Size`</span><span class="sxs-lookup"><span data-stu-id="202ad-184">Apply the `in` modifier to `readonly struct` parameters larger than `System.IntPtr.Size`</span></span>

<span data-ttu-id="202ad-185">При передаче аргументов по ссылке можно использовать ключевое слово `in` как дополнение к существующим ключевым словам `ref` и `out`.</span><span class="sxs-lookup"><span data-stu-id="202ad-185">The `in` keyword complements the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="202ad-186">Ключевое слово `in` указывает, что аргумент передается по ссылке, но вызванный метод не изменяет это значение.</span><span class="sxs-lookup"><span data-stu-id="202ad-186">The `in` keyword specifies passing the argument by reference, but the called method doesn't modify the value.</span></span>

<span data-ttu-id="202ad-187">Это дополнение позволяет полностью выразить намерение разработки.</span><span class="sxs-lookup"><span data-stu-id="202ad-187">This addition provides a full vocabulary to express your design intent.</span></span>
<span data-ttu-id="202ad-188">Если в сигнатуре метода не указан ни один из следующих модификаторов, типы значений копируются при передаче в вызываемый метод.</span><span class="sxs-lookup"><span data-stu-id="202ad-188">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="202ad-189">Каждый из этих модификаторов указывает, что переменная передается по ссылке, предотвращая копирование.</span><span class="sxs-lookup"><span data-stu-id="202ad-189">Each of these modifiers specifies that a variable is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="202ad-190">Каждый модификатор выражает конкретное намерение.</span><span class="sxs-lookup"><span data-stu-id="202ad-190">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="202ad-191">`out`. этот метод задает значение аргумента, используемого в качестве этого параметра.</span><span class="sxs-lookup"><span data-stu-id="202ad-191">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="202ad-192">`ref`. этот метод может задавать значение аргумента, используемого в качестве этого параметра.</span><span class="sxs-lookup"><span data-stu-id="202ad-192">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="202ad-193">`in`. этот метод не изменяет значение аргумента, используемого в качестве этого параметра.</span><span class="sxs-lookup"><span data-stu-id="202ad-193">`in`: This method doesn't modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="202ad-194">При добавлении модификатора `in` для передачи аргумента по ссылке вы объявляете о своем намерении передавать аргументы по ссылке, чтобы избежать ненужных операций копирования.</span><span class="sxs-lookup"><span data-stu-id="202ad-194">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="202ad-195">Вы не собираетесь изменять объект, используемый в качестве этого аргумента.</span><span class="sxs-lookup"><span data-stu-id="202ad-195">You don't intend to modify the object used as that argument.</span></span>

<span data-ttu-id="202ad-196">Такой подход часто повышает производительность для типов значений только для чтения, размер которых превышает <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="202ad-196">This practice often improves performance for readonly value types that are larger than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span> <span data-ttu-id="202ad-197">Для простых типов (`sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal` и `bool` и `enum`) возможное повышение производительности минимально.</span><span class="sxs-lookup"><span data-stu-id="202ad-197">For simple types (`sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal` and `bool`, and `enum` types), any potential performance gains are minimal.</span></span> <span data-ttu-id="202ad-198">На самом деле, производительность может снизиться при использовании передачи по ссылке для типов, меньше чем <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="202ad-198">In fact, performance may degrade by using pass-by-reference for types smaller than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="202ad-199">Ниже приведен пример метода, который вычисляет расстояние между двумя точками в трехмерном пространстве.</span><span class="sxs-lookup"><span data-stu-id="202ad-199">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span>

[!code-csharp[InArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="202ad-200">Аргументами являются две структуры, каждая из которых содержит три типа double.</span><span class="sxs-lookup"><span data-stu-id="202ad-200">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="202ad-201">double имеет размер 8 байт, поэтому каждый аргумент равен 24 байтам.</span><span class="sxs-lookup"><span data-stu-id="202ad-201">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="202ad-202">Указывая модификатор `in`, вы, в зависимости от архитектуры компьютера, передаете этим аргументам 4- или 8-байтовую ссылку.</span><span class="sxs-lookup"><span data-stu-id="202ad-202">By specifying the `in` modifier, you pass a 4 byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="202ad-203">Разница в размере невелика, но она может вырасти, когда приложение вызывает этот метод в непрерывном цикле с помощью множества различных значений.</span><span class="sxs-lookup"><span data-stu-id="202ad-203">The difference in size is small, but it adds up when your application calls this method in a tight loop using many different values.</span></span>

<span data-ttu-id="202ad-204">Существуют и другие способы, которыми модификатор `in` дополняет `out` и `ref`.</span><span class="sxs-lookup"><span data-stu-id="202ad-204">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="202ad-205">Невозможно создать перегрузки метода, которые отличаются только наличием `in`, `out` или `ref`.</span><span class="sxs-lookup"><span data-stu-id="202ad-205">You can't create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="202ad-206">Эти новые правила расширяют то же поведение, которое всегда действовало для параметров `out` и `ref`.</span><span class="sxs-lookup"><span data-stu-id="202ad-206">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span> <span data-ttu-id="202ad-207">Как и модификаторы `out` и `ref`, типы значений не упаковываются, так как применяется модификатор `in`.</span><span class="sxs-lookup"><span data-stu-id="202ad-207">Like the `out` and `ref` modifiers, value types aren't boxed because the `in` modifier is applied.</span></span>

<span data-ttu-id="202ad-208">Модификатор `in` может применяться к любому члену, который принимает параметры: к методам, делегатам, лямбда-выражениям, локальным функциям, индексаторам, операторам.</span><span class="sxs-lookup"><span data-stu-id="202ad-208">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="202ad-209">Еще одно преимущество параметров `in` состоит в том, что вы можете использовать литеральные значения или константы для аргумента в параметре `in`.</span><span class="sxs-lookup"><span data-stu-id="202ad-209">Another feature of `in` parameters is that you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="202ad-210">Кроме того, в отличие от параметра `ref` или `out`, не нужно применять модификатор `in` на сайте вызова.</span><span class="sxs-lookup"><span data-stu-id="202ad-210">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="202ad-211">В следующем коде показаны два примера вызова метода `CalculateDistance`.</span><span class="sxs-lookup"><span data-stu-id="202ad-211">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="202ad-212">В первом используются две локальные переменные, передаваемые по ссылке.</span><span class="sxs-lookup"><span data-stu-id="202ad-212">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="202ad-213">Второй содержит временную переменную, созданную в рамках вызова метода.</span><span class="sxs-lookup"><span data-stu-id="202ad-213">The second includes a temporary variable created as part of the method call.</span></span>

[!code-csharp[UseInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="202ad-214">Существует несколько способов, когда компилятор гарантирует, что аргумент `in` доступен только для чтения.</span><span class="sxs-lookup"><span data-stu-id="202ad-214">There are several ways in which the compiler enforces the read-only nature of an `in` argument.</span></span>  <span data-ttu-id="202ad-215">Во-первых, вызванный метод не может быть напрямую назначен параметру `in`.</span><span class="sxs-lookup"><span data-stu-id="202ad-215">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="202ad-216">Его невозможно напрямую назначить полю параметра `in`, когда это значение имеет тип `struct`.</span><span class="sxs-lookup"><span data-stu-id="202ad-216">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="202ad-217">Кроме того, параметр `in` невозможно передать какому-либо методу, использующему модификатор `ref` или `out`.</span><span class="sxs-lookup"><span data-stu-id="202ad-217">In addition, you can't pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="202ad-218">Эти правила применяются к любому полю параметра `in` при условии, что данное поле имеет тип `struct` и параметр имеет тип `struct`.</span><span class="sxs-lookup"><span data-stu-id="202ad-218">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="202ad-219">На самом деле эти правила применяются к нескольким уровням доступа к членам при условии, что все уровни доступа к членам являются `structs`.</span><span class="sxs-lookup"><span data-stu-id="202ad-219">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span>
<span data-ttu-id="202ad-220">Компилятор принудительно указывает, что типы `struct`, передаваемые в качестве аргументов `in`, и их члены `struct` являются переменными, доступными только для чтения, когда используются в качестве аргументов для других методов.</span><span class="sxs-lookup"><span data-stu-id="202ad-220">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="202ad-221">Использование параметров `in` позволяет избежать потенциальных затрат на создание копий.</span><span class="sxs-lookup"><span data-stu-id="202ad-221">The use of `in` parameters can avoid the potential performance costs of making copies.</span></span> <span data-ttu-id="202ad-222">Это не меняет семантику ни одного вызова метода.</span><span class="sxs-lookup"><span data-stu-id="202ad-222">It doesn't change the semantics of any method call.</span></span> <span data-ttu-id="202ad-223">Таким образом, указывать модификатор `in` в месте вызова не нужно.</span><span class="sxs-lookup"><span data-stu-id="202ad-223">Therefore, you don't need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="202ad-224">Пропуск модификатора `in` в месте вызова сообщает компилятору, что он может сделать копию аргумента по следующим причинам:</span><span class="sxs-lookup"><span data-stu-id="202ad-224">Omitting the `in` modifier at the call site informs the compiler that it's allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="202ad-225">Выполняется неявное преобразование, но не преобразование удостоверения из типа аргумента в тип параметра.</span><span class="sxs-lookup"><span data-stu-id="202ad-225">There exists an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="202ad-226">Аргумент является выражением, но не имеет известную переменную хранения.</span><span class="sxs-lookup"><span data-stu-id="202ad-226">The argument is an expression but doesn't have a known storage variable.</span></span>
- <span data-ttu-id="202ad-227">Существует перегрузка, которая отличается наличием или отсутствием `in`.</span><span class="sxs-lookup"><span data-stu-id="202ad-227">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="202ad-228">В этом случае перегрузка по значению подходит лучше.</span><span class="sxs-lookup"><span data-stu-id="202ad-228">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="202ad-229">Эти правила полезны и при обновлении существующего кода для использования аргументов со ссылками, доступными только для чтения.</span><span class="sxs-lookup"><span data-stu-id="202ad-229">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="202ad-230">Внутри вызываемого метода можно вызвать любой метод экземпляра, который использует параметры передачи по значению.</span><span class="sxs-lookup"><span data-stu-id="202ad-230">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="202ad-231">В этих экземплярах создается копия параметра `in`.</span><span class="sxs-lookup"><span data-stu-id="202ad-231">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="202ad-232">Поскольку компилятор может создавать временную переменную для любого параметра `in`, вы можете также указать значения по умолчанию для любого параметра `in`.</span><span class="sxs-lookup"><span data-stu-id="202ad-232">Because the compiler may create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="202ad-233">Следующий код указывает начало координат (точку 0,0) в качестве значения по умолчанию для второй точки:</span><span class="sxs-lookup"><span data-stu-id="202ad-233">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="202ad-234">Чтобы велеть компилятору передавать аргументы, доступные только для чтения, по ссылке, укажите модификатор `in` для аргументов в месте вызова, как показано в следующем коде:</span><span class="sxs-lookup"><span data-stu-id="202ad-234">To force the compiler to pass read-only arguments by reference, specify the `in` modifier on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="202ad-235">Это упрощает постепенное внедрение параметров `in` в больших базах кода, где возможен выигрыш по производительности.</span><span class="sxs-lookup"><span data-stu-id="202ad-235">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="202ad-236">Сначала нужно добавить модификатор `in` в сигнатуры методов.</span><span class="sxs-lookup"><span data-stu-id="202ad-236">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="202ad-237">Затем можно добавить модификатор `in` в местах вызовов и создать типы `readonly struct`, чтобы разрешить компилятору не создавать защитные копии параметров `in` в дополнительных расположениях.</span><span class="sxs-lookup"><span data-stu-id="202ad-237">Then, you can add the `in` modifier at call sites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="202ad-238">Обозначение параметра `in` также можно использовать со ссылочными типами или числовыми значениями.</span><span class="sxs-lookup"><span data-stu-id="202ad-238">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="202ad-239">Однако преимущества в обоих случаях минимальны (если они вообще есть).</span><span class="sxs-lookup"><span data-stu-id="202ad-239">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="avoid-mutable-structs-as-an-in-argument"></a><span data-ttu-id="202ad-240">Не используйте изменяемые структуры как аргумент `in`</span><span class="sxs-lookup"><span data-stu-id="202ad-240">Avoid mutable structs as an `in` argument</span></span>

<span data-ttu-id="202ad-241">Методики, описанные выше, объясняют, как избежать копий путем возврата ссылок и передачи значения по ссылке.</span><span class="sxs-lookup"><span data-stu-id="202ad-241">The techniques described above explain how to avoid copies by returning references and passing values by reference.</span></span> <span data-ttu-id="202ad-242">Эти методы лучше всего работают, когда типы аргументов объявляются как типы `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="202ad-242">These techniques work best when the argument types are declared as `readonly struct` types.</span></span> <span data-ttu-id="202ad-243">В противном случае компилятор должен создавать **защитные копии** во многих ситуациях, чтобы гарантировать, что все аргументы будут доступны только для чтения.</span><span class="sxs-lookup"><span data-stu-id="202ad-243">Otherwise, the compiler must create **defensive copies** in many situations to enforce the readonly-ness of any arguments.</span></span> <span data-ttu-id="202ad-244">Рассмотрим следующий пример, который вычисляет расстояние до точки в трехмерном пространстве от начала координат:</span><span class="sxs-lookup"><span data-stu-id="202ad-244">Consider the following example that calculates the distance of a 3D point from the origin:</span></span>

[!code-csharp[InArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="202ad-245">Структура `Point3D`*не* предоставляется только для чтения.</span><span class="sxs-lookup"><span data-stu-id="202ad-245">The `Point3D` structure is *not* a readonly struct.</span></span> <span data-ttu-id="202ad-246">В тексте этого метода есть шесть разных вызовов доступа к свойству.</span><span class="sxs-lookup"><span data-stu-id="202ad-246">There are six different property access calls in the body of this method.</span></span> <span data-ttu-id="202ad-247">На первый взгляд может показаться, что эти доступы безопасны.</span><span class="sxs-lookup"><span data-stu-id="202ad-247">On first examination, you may have thought these accesses were safe.</span></span> <span data-ttu-id="202ad-248">В конце концов, метод доступа `get` не должен изменять состояние объекта.</span><span class="sxs-lookup"><span data-stu-id="202ad-248">After all, a `get` accessor shouldn't modify the state of the object.</span></span> <span data-ttu-id="202ad-249">Но нет правила языка, которое это обеспечивает.</span><span class="sxs-lookup"><span data-stu-id="202ad-249">But there's no language rule that enforces that.</span></span> <span data-ttu-id="202ad-250">Это просто общее соглашение.</span><span class="sxs-lookup"><span data-stu-id="202ad-250">It's only a common convention.</span></span> <span data-ttu-id="202ad-251">Любой тип может реализовывать метод доступа `get`, который изменил внутреннее состояние.</span><span class="sxs-lookup"><span data-stu-id="202ad-251">Any type could implement a `get` accessor that modified the internal state.</span></span> <span data-ttu-id="202ad-252">Без языковой гарантии компилятору необходимо создавать временную копию аргумента перед вызовом любого члена, не помеченного модификатором `readonly`.</span><span class="sxs-lookup"><span data-stu-id="202ad-252">Without some language guarantee, the compiler must create a temporary copy of the argument before calling any member not marked with the `readonly` modifier.</span></span> <span data-ttu-id="202ad-253">Временное хранилище создается на стеке, значения аргумента копируются во временном хранилище, и значение копируется в стек для каждого доступа к членам как аргумент `this`.</span><span class="sxs-lookup"><span data-stu-id="202ad-253">The temporary storage is created on the stack, the values of the argument are copied to the temporary storage, and the value is copied to the stack for each member access as the `this` argument.</span></span> <span data-ttu-id="202ad-254">Во многих случаях эти копии достаточно снижают производительность, так что передача по значению работает быстрее, чем передача по ссылке только для чтения, если тип аргумента не `readonly struct` и метод вызывает члены, не помеченные как `readonly`.</span><span class="sxs-lookup"><span data-stu-id="202ad-254">In many situations, these copies harm performance enough that pass-by-value is faster than pass-by-readonly-reference when the argument type isn't a `readonly struct` and the method calls members that aren't marked `readonly`.</span></span> <span data-ttu-id="202ad-255">Если пометить все методы, которые не изменяют состояние структуры как `readonly`, компилятор сможет безопасно определить, что состояние структуры не изменено и защитная копия не требуется.</span><span class="sxs-lookup"><span data-stu-id="202ad-255">If you mark all methods that don't modify the struct state as `readonly`, the compiler can safely determine that the struct state isn't modified, and a defensive copy is not needed.</span></span>

<span data-ttu-id="202ad-256">Вместо этого, если вычисление расстояния использует неизменяемую структуру, `ReadonlyPoint3D`, временные объекты не требуются:</span><span class="sxs-lookup"><span data-stu-id="202ad-256">Instead, if the distance calculation uses the immutable struct, `ReadonlyPoint3D`, temporary objects aren't needed:</span></span>

[!code-csharp[readonlyInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ReadOnlyInArgument "Specifying a readonly in argument")]

<span data-ttu-id="202ad-257">Компилятор создает более эффективный код, когда вызываются члены `readonly struct`: Ссылка `this`, а не копия приемника, всегда является параметром `in`, переданным по ссылке методу члена.</span><span class="sxs-lookup"><span data-stu-id="202ad-257">The compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="202ad-258">Эта оптимизация позволяет избежать копирования при использовании `readonly struct` в качестве аргумента `in`.</span><span class="sxs-lookup"><span data-stu-id="202ad-258">This optimization saves copying when you use a `readonly struct` as an `in` argument.</span></span>

<span data-ttu-id="202ad-259">Не следует передавать тип значения, допускающий значения NULL, в качестве аргумента `in`.</span><span class="sxs-lookup"><span data-stu-id="202ad-259">You shouldn't pass a nullable value type as an `in` argument.</span></span> <span data-ttu-id="202ad-260">Тип <xref:System.Nullable%601> не объявлен как структура только для чтения.</span><span class="sxs-lookup"><span data-stu-id="202ad-260">The <xref:System.Nullable%601> type isn't declared as a read-only struct.</span></span> <span data-ttu-id="202ad-261">Это означает, что компилятор должен создавать защитные копии для любого аргумента типа, допускающего значение NULL и передаваемого в метод с помощью модификатора `in` в объявлении параметра.</span><span class="sxs-lookup"><span data-stu-id="202ad-261">That means the compiler must generate defensive copies for any nullable value type argument passed to a method using the `in` modifier on the parameter declaration.</span></span>

<span data-ttu-id="202ad-262">Вы видите пример программы, который демонстрирует разницу в производительности с помощью [BenchmarkDotNet](https://www.nuget.org/packages/BenchmarkDotNet/) в наших [репозиториях примеров](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) на сайте GitHub.</span><span class="sxs-lookup"><span data-stu-id="202ad-262">You can see an example program that demonstrates the performance differences using [BenchmarkDotNet](https://www.nuget.org/packages/BenchmarkDotNet/) in our [samples repository](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) on GitHub.</span></span> <span data-ttu-id="202ad-263">Он сравнивает передачу изменяемых структур по значению и по ссылке с передачей неизменяемых структур по значению и по ссылке.</span><span class="sxs-lookup"><span data-stu-id="202ad-263">It compares passing a mutable struct by value and by reference with passing an immutable struct by value and by reference.</span></span> <span data-ttu-id="202ad-264">Быстрее всего использовать неизменяемую структуру и передачу по ссылке.</span><span class="sxs-lookup"><span data-stu-id="202ad-264">The use of the immutable struct and pass by reference is fastest.</span></span>

## <a name="use-ref-struct-types-to-work-with-blocks-or-memory-on-a-single-stack-frame"></a><span data-ttu-id="202ad-265">Используйте типы `ref struct` для работы с блоками или памятью в одном кадре стека</span><span class="sxs-lookup"><span data-stu-id="202ad-265">Use `ref struct` types to work with blocks or memory on a single stack frame</span></span>

<span data-ttu-id="202ad-266">Еще одной связанной функцией языка является возможность объявлять тип значения, который должен быть ограничен одним кадром стека.</span><span class="sxs-lookup"><span data-stu-id="202ad-266">A related language feature is the ability to declare a value type that must be constrained to a single stack frame.</span></span> <span data-ttu-id="202ad-267">Это ограничение позволяет компилятору кое-что оптимизировать.</span><span class="sxs-lookup"><span data-stu-id="202ad-267">This restriction enables the compiler to make several optimizations.</span></span> <span data-ttu-id="202ad-268">Главным стимулом для создания этой функции была структура <xref:System.Span%601> и связанные структуры.</span><span class="sxs-lookup"><span data-stu-id="202ad-268">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="202ad-269">Вы получите повышение производительности благодаря этим усовершенствованиям, если будете использовать новые и обновленные интерфейсы API .NET, которые используют тип <xref:System.Span%601>.</span><span class="sxs-lookup"><span data-stu-id="202ad-269">You'll achieve performance improvements from these enhancements by using new and updated .NET APIs that make use of the <xref:System.Span%601> type.</span></span>

<span data-ttu-id="202ad-270">Похожие требования могут иметь место при работе с памятью, созданной с помощью [`stackalloc`](language-reference/operators/stackalloc.md), или при использовании памяти из API взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="202ad-270">You may have similar requirements working with memory created using [`stackalloc`](language-reference/operators/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="202ad-271">Для этих задач можно определить собственные типы `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="202ad-271">You can define your own `ref struct` types for those needs.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="202ad-272">Тип `readonly ref struct`</span><span class="sxs-lookup"><span data-stu-id="202ad-272">`readonly ref struct` type</span></span>

<span data-ttu-id="202ad-273">Объявление структуры как `readonly ref` сочетает в себе преимущества и недостатки объявлений `ref struct` и `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="202ad-273">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` declarations.</span></span> <span data-ttu-id="202ad-274">Объем памяти, используемой диапазоном только для чтения, будет ограничен одним кадром стека, а объем памяти, используемой диапазоном только для чтения, невозможно изменить.</span><span class="sxs-lookup"><span data-stu-id="202ad-274">The memory used by the readonly span is restricted to a single stack frame, and the memory used by the readonly span can't be modified.</span></span>

## <a name="conclusions"></a><span data-ttu-id="202ad-275">Выводы</span><span class="sxs-lookup"><span data-stu-id="202ad-275">Conclusions</span></span>

<span data-ttu-id="202ad-276">Использование типов значений сводит к минимуму число операций распределения:</span><span class="sxs-lookup"><span data-stu-id="202ad-276">Using value types minimizes the number of allocation operations:</span></span>

- <span data-ttu-id="202ad-277">Хранилище для типов значений выделяется в стеке для локальных переменных и аргументов метода.</span><span class="sxs-lookup"><span data-stu-id="202ad-277">Storage for value types is stack allocated for local variables and method arguments.</span></span>
- <span data-ttu-id="202ad-278">Хранилище для типов значений, которые являются членами других объектов, выделяется как часть этого объекта, а не отдельное распределение.</span><span class="sxs-lookup"><span data-stu-id="202ad-278">Storage for value types that are members of other objects is allocated as part of that object, not as a separate allocation.</span></span>
- <span data-ttu-id="202ad-279">Хранилища возвращаемых значений типов значений выделяется в стеке.</span><span class="sxs-lookup"><span data-stu-id="202ad-279">Storage for value type return values is stack allocated.</span></span>

<span data-ttu-id="202ad-280">Сравните это со ссылочными типами в таких же ситуациях:</span><span class="sxs-lookup"><span data-stu-id="202ad-280">Contrast that with reference types in those same situations:</span></span>

- <span data-ttu-id="202ad-281">Хранилище для ссылочных типов выделяется в куче для локальных переменных и аргументов метода.</span><span class="sxs-lookup"><span data-stu-id="202ad-281">Storage for reference types are heap allocated for local variables and method arguments.</span></span> <span data-ttu-id="202ad-282">Ссылка хранится в стеке.</span><span class="sxs-lookup"><span data-stu-id="202ad-282">The reference is stored on the stack.</span></span>
- <span data-ttu-id="202ad-283">Хранилище для ссылочных типов, которые являются членами других объектов, выделяется в куче отдельно.</span><span class="sxs-lookup"><span data-stu-id="202ad-283">Storage for reference types that are members of other objects are separately allocated on the heap.</span></span> <span data-ttu-id="202ad-284">Объект хранит ссылку.</span><span class="sxs-lookup"><span data-stu-id="202ad-284">The containing object stores the reference.</span></span>
- <span data-ttu-id="202ad-285">Хранилище возвращаемых значений ссылочного типа выделяется в куче.</span><span class="sxs-lookup"><span data-stu-id="202ad-285">Storage for reference type return values is heap allocated.</span></span> <span data-ttu-id="202ad-286">Ссылка на это хранилище хранится в стеке.</span><span class="sxs-lookup"><span data-stu-id="202ad-286">The reference to that storage is stored on the stack.</span></span>

<span data-ttu-id="202ad-287">Чтобы свести распределения к минимуму, придется пойти на компромисс.</span><span class="sxs-lookup"><span data-stu-id="202ad-287">Minimizing allocations comes with tradeoffs.</span></span> <span data-ttu-id="202ad-288">Вы копируете больше памяти, если размер `struct` больше, чем размер ссылки.</span><span class="sxs-lookup"><span data-stu-id="202ad-288">You copy more memory when the size of the `struct` is larger than the size of a reference.</span></span> <span data-ttu-id="202ad-289">Ссылка обычно является 64- или 32-разрядной и зависит от ЦП целевого компьютера.</span><span class="sxs-lookup"><span data-stu-id="202ad-289">A reference is typically 64 bits or 32 bits, and depends on the target machine CPU.</span></span>

<span data-ttu-id="202ad-290">Эти компромиссы обычно имеют минимальное влияние на производительность.</span><span class="sxs-lookup"><span data-stu-id="202ad-290">These tradeoffs generally have minimal performance impact.</span></span> <span data-ttu-id="202ad-291">Однако для больших структур или больших коллекций влияние на производительность возрастает.</span><span class="sxs-lookup"><span data-stu-id="202ad-291">However, for large structs or larger collections, the performance impact increases.</span></span> <span data-ttu-id="202ad-292">Влияние может быть большим в плотных циклах и часто используемых путях для программ.</span><span class="sxs-lookup"><span data-stu-id="202ad-292">The impact can be large in tight loops and hot paths for programs.</span></span>

<span data-ttu-id="202ad-293">Эти усовершенствования языка C# предназначены для критических алгоритмов производительности, когда минимизация распределений памяти может иметь большое значение для достижения необходимой производительности.</span><span class="sxs-lookup"><span data-stu-id="202ad-293">These enhancements to the C# language are designed for performance critical algorithms where minimizing memory allocations is a major factor in achieving the necessary performance.</span></span> <span data-ttu-id="202ad-294">Может оказаться, что в создаваемом коде эти функции используются довольно редко.</span><span class="sxs-lookup"><span data-stu-id="202ad-294">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="202ad-295">Тем не менее эти усовершенствования были реализованы в .NET.</span><span class="sxs-lookup"><span data-stu-id="202ad-295">However, these enhancements have been adopted throughout .NET.</span></span> <span data-ttu-id="202ad-296">Поскольку с этими функциями работает все больше API-интерфейсов, повышение производительности приложений не останется незаметным.</span><span class="sxs-lookup"><span data-stu-id="202ad-296">As more and more APIs make use of these features, you'll see the performance of your applications improve.</span></span>

## <a name="see-also"></a><span data-ttu-id="202ad-297">См. также</span><span class="sxs-lookup"><span data-stu-id="202ad-297">See also</span></span>

- [<span data-ttu-id="202ad-298">Ключевое слово ref</span><span class="sxs-lookup"><span data-stu-id="202ad-298">ref keyword</span></span>](language-reference/keywords/ref.md)
- [<span data-ttu-id="202ad-299">Возвращаемые значения ref и локальные переменные ref</span><span class="sxs-lookup"><span data-stu-id="202ad-299">Ref returns and ref locals</span></span>](programming-guide/classes-and-structs/ref-returns.md)
