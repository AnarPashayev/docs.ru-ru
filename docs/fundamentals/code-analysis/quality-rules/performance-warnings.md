---
title: Правила производительности (анализ кода)
description: Сведения о правилах производительности анализа кода.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.performancerules
helpviewer_keywords:
- rules, performance
- performance rules
- performance, rules
- managed code analysis rules, performance rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 4409cc46eb73f13f8e59d7a51899da27035bb6af
ms.sourcegitcommit: 2e4adc490c1d2a705a0592b295d606b10b9f51f1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/25/2020
ms.locfileid: "96592401"
---
# <a name="performance-rules"></a>Правила производительности

Правила производительности поддерживают высокопроизводительные библиотеки и приложения.

## <a name="in-this-section"></a>В этом разделе

| Правило | Описание |
| - | - |
| [CA1802. По возможности используйте литералы](ca1802.md) | Поле объявлено как статическое и доступное только для чтения (Shared и ReadOnly в Visual Basic) и инициализируется со значением, вычисляемым во время компиляции. Так как значение, назначенное целевому полю, вычисляемым во время компиляции, измените объявление на const (const в Visual Basic), чтобы значение было вычислено во время компиляции, а не во время выполнения. |
| [CA1805: не выполнять инициализацию без необходимости](ca1805.md) | Среда выполнения .NET инициализирует все поля ссылочных типов значениями по умолчанию перед выполнением конструктора. В большинстве случаев явное инициализация поля значением по умолчанию является избыточным, что добавляет к затратам на обслуживание и может привести к снижению производительности (например, при увеличении размера сборки). |
| [CA1806. Не игнорируйте результаты метода](ca1806.md) | Новый объект создается, но не используется, или метод, создающий и возвращающий новую строку, вызывается, а новая строка никогда не используется, или метод P/Invoke модели компонента возвращает значение HRESULT или код ошибки, который никогда не используется. |
| [CA1810. Инициализируйте статические поля ссылочных типов при объявлении](ca1810.md) | Если в типе объявляется явный статический конструктор, компилятор JIT добавляет проверку в каждый статический метод и конструктор экземпляров этого типа, чтобы убедиться, что статический конструктор уже вызывался ранее. Проверки статических конструкторов могут привести к снижению производительности. |
| [CA1812. Избегайте неиспользуемых внутренних классов](ca1812.md) | Экземпляр типа уровня сборки не создается кодом в сборке. |
| [CA1813. Избегайте незапечатанных атрибутов](ca1813.md) | .NET предоставляет методы для извлечения пользовательских атрибутов. По умолчанию эти методы осуществляют поиск иерархии наследования атрибутов. Если запечатать атрибут, поиск в иерархии наследования выполняться не будет, в результате чего может повыситься производительность. |
| [CA1814. Используйте массивы массивов вместо многомерных массивов](ca1814.md) | Массив массивов — это массив, элементы которого сами являются массивами. Массивы, составляющие элементы, могут иметь различные размеры, что может привести к уменьшению объема неиспользуемого пространства для некоторых наборов данных. |
| [CA1815. Переопределяйте операторы Equals и равенства для типов значений](ca1815.md) | В унаследованной реализации Equals для типов значений используется библиотека отражения и сравнивается содержимое всех полей. Отражение является процессом, требующим с точки зрения вычислений больших затрат, и сравнение каждого поля на равенство может быть лишним. Если предполагается, что пользователи будут сравнивать, сортировать экземпляры или использовать их в качестве ключей хэш-таблиц, тип значения должен реализовывать Equals. |
| [CA1819. Свойства не должны возвращать массивы](ca1819.md) | Массивы, возвращаемые свойствами, не защищаются от записи, даже если свойство доступно только для чтения. Чтобы защитить массив от изменений, свойство должно возвращать копию массива. Как правило, пользователи не понимают требований к производительности при вызове такого свойства. |
| [CA1820. Проверяйте наличие пустых строк, используя длину строки](ca1820.md) | Сравнивать строки с использованием свойства String.Length или метода String.IsNullOrEmpty значительно быстрее, чем с помощью Equals. |
| [CA1821. Удалите пустые методы завершения](ca1821.md) | Если возможно, старайтесь не использовать финализаторы, поскольку из-за отслеживания жизненного срока объектов снижается производительность программы. Пустой метод завершения требует дополнительной дополнительной нагрузки без каких бы то ни было преимуществ. |
| [CA1822. Пометьте члены как статические](ca1822.md) | Члены, которые не обращаются к данным экземпляра или вызывают методы экземпляра, могут быть помечены как статические (Shared в Visual Basic). Если пометить методы как статические, компилятор предоставит этим членам невиртуальные места вызова. Это обеспечивает значительное повышение производительности при работе с кодом, для которого важна высокая производительность системы. |
| [CA1823. Избегайте неиспользуемых частных полей](ca1823.md) | Обнаружены закрытые поля, доступ к которым, судя по всему, не предоставляется в сборке. |
| [CA1824. Помечайте сборки с помощью NeutralResourcesLanguageAttribute](ca1824.md) | Атрибут NeutralResourcesLanguage информирует диспетчер ресурсов языка, который использовался для вывода ресурсов нейтральной культуры для сборки. При этом повышается эффективность поиска первого загружаемого ресурса и может сократиться рабочее множество. |
| [CA1825: Избегайте выделения массивов нулевой длины](ca1825.md) | Инициализация массива нулевой длины приводит к ненужному выделению памяти. Вместо этого используйте статический выделенный экземпляр пустого массива, вызвав метод <xref:System.Array.Empty%2A?displayProperty=nameWithType> . Выделение памяти является общим для всех вызовов этого метода. |
| [CA1826: Используйте свойство вместо метода Enumerable в LINQ](ca1826.md) | <xref:System.Linq.Enumerable> Метод LINQ использовался для типа, который поддерживает эквивалентное, более эффективное свойство. |
| [CA1827: Не используйте Count/LongCount, если можно использовать Any](ca1827.md) | <xref:System.Linq.Enumerable.Count%2A><xref:System.Linq.Enumerable.LongCount%2A>метод или был использован, когда <xref:System.Linq.Enumerable.Any%2A> метод был бы более эффективным. |
| [CA1828: Не используйте CountAsync/LongCountAsync, если можно использовать AnyAsync](ca1828.md) | <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A>метод или был использован, когда <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> метод был бы более эффективным. |
| [CA1829: Используйте свойство Length/Count вместо метода Enumerable.Count](ca1829.md) | <xref:System.Linq.Enumerable.Count%2A> Метод LINQ использовался для типа, который поддерживает эквивалентное, более эффективное `Length` или `Count` свойство. |
| [CA1830: предпочитать строго типизированные перегрузки методов Append и Insert в StringBuilder](ca1830.md) | <xref:System.Text.StringBuilder.Append%2A> и <xref:System.Text.StringBuilder.Insert%2A> предоставляют перегрузки для нескольких типов, кроме System. String.  По возможности рекомендуется использовать строго типизированные перегрузки с использованием ToString () и перегрузки на основе строк. |
| [CA1831: при необходимости используйте AsSpan вместо индексаторов на основе диапазона для строки](ca1831.md) | При использовании в строке индексатора Range и неявного присваивания значения Реадонлиспан &lt; &gt; типу Char метод <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> будет использоваться вместо <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , который создает копию запрошенной части строки. |
| [CA1832: используйте AsSpan или AsMemory вместо индексаторов на основе диапазона для получения части массива ReadOnlySpan или ReadOnlyMemory](ca1832.md) | При использовании индексатора диапазонов для массива и неявного присваивания значения <xref:System.ReadOnlySpan%601> <xref:System.ReadOnlyMemory%601> типу или, метод <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> будет использоваться вместо <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , который создает копию запрошенной части массива. |
| [CA1833: используйте AsSpan или AsMemory вместо индексаторов на основе диапазона для получения части массива Span или Memory](ca1833.md) | При использовании индексатора диапазонов для массива и неявного присваивания значения <xref:System.Span%601> <xref:System.Memory%601> типу или, метод <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> будет использоваться вместо <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , который создает копию запрошенной части массива. |
| [CA1834: используйте StringBuilder.Append(char) для строк с одним символом.](ca1834.md) | <xref:System.Text.StringBuilder> имеет `Append` перегрузку, которая принимает в `char` качестве аргумента. Предпочитать вызов `char` перегрузки для повышения производительности. |
| [CA1835: предпочитать перегрузки на основе Мемори' для "ReadAsync" и "WriteAsync"](ca1835.md) | "Stream" имеет перегрузку "ReadAsync", которая принимает " &lt; байт памяти &gt; " в качестве первого аргумента, и перегрузка "WriteAsync", принимающая в &lt; &gt; качестве первого аргумента значение "реадонлимемори Byte". Предпочитать вызов перегрузок на основе памяти, что более эффективно. |
| [CA1836: предпочитать `IsEmpty` `Count` при доступности](ca1836.md) | Предпочитать `IsEmpty` свойство, которое более эффективно, чем `Count` , `Length` , <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> или, <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> чтобы определить, содержит ли объект какие-либо элементы или нет. |
| [CA1837: используйте `Environment.ProcessId` вместо `Process.GetCurrentProcess().Id`](ca1837.md) | `Environment.ProcessId` проще и быстрее, чем `Process.GetCurrentProcess().Id` . |
| [CA1838: Избегайте `StringBuilder` параметров для вызовов P/Invoke](ca1838.md) | `StringBuilder`При упаковке всегда создается собственная копия буфера, что приводит к многократному выделению для одной операции упаковки. |
